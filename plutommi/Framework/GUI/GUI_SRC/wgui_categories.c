/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * wgui_categories.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Ordinary categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/**
 * Copyright Notice
 * (c) 2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

/**********************************************************************************
   Filename:      wgui_categories.c
   Author:        manju, Vandana Mehtani, Vandana Dhawan
   Date Created:  August-07-2002
   Contains:      PixTel UI wrapper routines
               High Level Category screen wrappers.
**********************************************************************************/

#include "MMI_features.h"
#include "CustDataProts.h"
#include "CustMenuRes.h"
#include "wgui_fixed_menuitems.h"
#include "wgui_softkeys.h"

#include "ScreenRotationGprot.h"

#if 0 //lhm: remove for option slim
#ifdef __MMI_AUDIO_PLAYER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_AUDIO_PLAYER__ */ 
#endif

/* MTK Elvis for R2L characters */
#include "BIDIDEF.h"
#include "BIDIProt.h"
/* MTK end */

#ifdef __MMI_AVATAR__
#include "mmi_phnset_dispchar.h"
#include "avatarGprot.h"
#endif

#if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)
#include "SmsGuiInterfaceType.h"
#endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 
#if defined(__MMI_TOUCH_SCREEN__)
#include "wgui_virtual_keyboard.h"
#endif /* defined(__MMI_TOUCH_SCREEN__) */ 

#if 0
#ifdef __MMI_EDITABLE_AUDIO_EQUALIZER__
/* under construction !*/
#endif /* __MMI_EDITABLE_AUDIO_EQUALIZER__ */ 
#endif

#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__)
#include "VolumeHandler.h"
#endif 

#if (defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI))
#include "bmt.h"
extern kal_bool custom_uem_gpio_set_level(kal_uint8 gpio_dev_type, kal_uint8 gpio_dev_level);
#endif /* (defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI)) */ 

#if defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
#include "mmi_features_dtv_player.h"
#endif


/*RHR*/
    #include "kal_general_types.h"
    #include "gui_virtual_keyboard.h"
    #include "MMIDataType.h"
    #include "gui_data_types.h"
    #include "wgui_categories_list.h"
    #include "wgui_inputs.h"
    #include "wgui_categories_util.h"
    #include "gui_typedef.h"
    #include "gdi_datatype.h"
    #include "gui_scrollbars.h"
    #include "GlobalConstants.h"
    #include "gui_effect_oem.h"
    #include "wgui_include.h"
    #include "wgui.h"
    #include "mmi_frm_history_gprot.h"
    #include "gdi_include.h"
    #include "gui_config.h"
    #include "gui_windows.h"
    #include "wgui_fixed_menus.h"
    #include "gui.h"
    #include "gui_fixed_menuitems.h"
    #include "wgui_draw_manager.h"
    #include "wgui_title.h"
    #include "gui_title_pre_oem.h"
    #include "gui_menu_shortcut.h"
    #include "gui_switch.h"
    #include "gui_fixed_menus.h"
    #include "gui_inputs.h"
    #include "mmi_frm_events_gprot.h"
    #include "wgui_categories_enum.h"
    #include "CustThemesRes.h"
    #include "string.h"
    #include "stdio.h"
    #include "Unicodexdcl.h"
    #include "gui_themes.h"
    #include "wgui_categories_inputs.h"
    #include "gui_buttons.h"
    #include "mmi_rp_app_uiframework_def.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "mmi_frm_input_gprot.h"
    #include "PixcomFontEngine.h"
    #include "gdi_const.h"
    #include "wgui_categories.h"
    #include "lcd_sw_inc.h"
    #include "Gui_Setting.h"
    #include "gui_theme_struct.h"
    #include "CustDataRes.h"
    #include "wgui_touch_screen.h"
    #include "gui_resource_type.h"
    #include "TimerEvents.h"
    #include "mmi_frm_timer_gprot.h"
    #include "GlobalResDef.h"
    #include "ImeGprot.h"
    #include "device.h"
    #include "MMI_fw_trc.h"
    #include "kal_trace.h"
/*RHR end*/
	#include "dcl.h" /*for PW_CTRL_GET_POWERON_REASON*/
    #include "custom_uem.h"
#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_MAINLCD_128X128__)
#include "mmi_rp_app_idle_swatch_def.h"	

#endif /*defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_MAINLCD_128X128__)*/

/* for NFB progress bar images */
#if (defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI))
    extern kal_bool custom_cfg_gpio_set_level(kal_uint8 gpio_dev_type, kal_uint8 gpio_dev_level);
    extern U8 *nfb_progress_images[];
#endif /* (defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI)) */ 

/* Store current menu type..matrix,list,circular */
S32 MMI_current_menu_type = MATRIX_MENU;
S32 volume_level_UI;

///TODO: The following parameter was used in other files, it should be moved to wgui_categories_util.c
U16 on_idle_screen = 0;
U8 flag_scroll = FALSE;
S16 status_icon = 0;

/* for dummy screen */
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR 
U32 status_bar_flag[2];
#else
U32 status_bar_flag[1];
#endif /*WGUI_STATUS_ICON_SHOW_V_BAR*/

/*****************************************************************************
 * FUNCTION
 *  ExitCategoryDummyScreen
 * DESCRIPTION
 *  Exits the dummy category screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategoryDummyScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_set_is_dummy_screen(MMI_FALSE);

    reset_small_screen();

    wgui_status_icon_bar_set_flag(WGUI_STATUS_ICON_BAR_H_BAR, status_bar_flag[0]);
    
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR 
    wgui_status_icon_bar_set_flag(WGUI_STATUS_ICON_BAR_V_BAR, status_bar_flag[1]);
#endif /*WGUI_STATUS_ICON_SHOW_V_BAR*/
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategoryDummyScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_set_is_dummy_screen(MMI_TRUE);

    status_bar_flag[0] = wgui_status_icon_bar_get_flag(WGUI_STATUS_ICON_BAR_H_BAR);
    wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);

#ifdef WGUI_STATUS_ICON_SHOW_V_BAR 
    status_bar_flag[1] = wgui_status_icon_bar_get_flag(WGUI_STATUS_ICON_BAR_V_BAR);
    wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_V_BAR);
#endif /*WGUI_STATUS_ICON_SHOW_V_BAR*/

    ExitCategoryFunction = ExitCategoryDummyScreen;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategoryDummySmallScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_screen_rotate_enum rotate;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_set_is_dummy_screen(MMI_TRUE);

#if defined(__MMI_SCREEN_ROTATE__)
	rotate = mmi_frm_get_previous_screen_rotate();	
	mmi_frm_screen_rotate(rotate);
#endif

    set_small_screen();    
    ShowCategoryDummyScreen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowListCategoryScreen_ext
 * DESCRIPTION
 *  Common function to show category screens containing list menu.
 * PARAMETERS
 *  title                   [IN]        String of title
 *  title_icon              [IN]        Icon of title
 *  left_softkey            [IN]        String of left softkey
 *  right_softkey           [IN]        String of right softkey
 * RETURNS
 *  void
 *****************************************************************************/
void ShowListCategoryScreen_ext(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        UI_string_type right_softkey)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_add_title(title, title_icon);
    dm_add_softkey_str(left_softkey, right_softkey);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory61Screen(U8 *message, U16 message_icon, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    SetupCategoryKeyHandlers();

    MMI_message_string = (UI_string_type) message;
    MMI_message_icon = (PU8) get_image(message_icon);

    l = gui_strlen(MMI_message_string);
    wgui_inputs_ml_create_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.border_color = gui_color(255, 255, 255);
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    dm_add_image(MMI_message_icon, NULL, NULL);

    gdi_layer_unlock_frame_buffer();

    wgui_cat_setup_category_default_history(MMI_CATEGORY61_ID, DM_CLEAR_SCREEN_BACKGROUND, MMI_dummy_function);
    dm_redraw_category_screen();
}

#if 0 //lhm: remove for option slim
#if defined(__MMI_MENSTRUAL__) || defined(__MMI_139_PUSH_MAIL__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if defined(__MMI_FTE_SUPPORT__)
/* under construction !*/
#endif /* defined(__MMI_FTE_SUPPORT__) */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if defined(__MMI_FTE_SUPPORT__)
/* under construction !*/
#endif /* defined(__MMI_FTE_SUPPORT__) */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_MENSTRUAL__ */ 
#endif //if 0

#ifdef __PLUTO_MMI_PACKAGE__
#define MIN_LEVEL   0
#ifdef __MMI_WEARABLE_DEVICE__
#define MAX_LEVEL   MDI_AUD_VOL_NUM - 1
#else
#define MAX_LEVEL   7
#endif
#if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__)
#define WGUI_VOLUME_SHOW_START_LEVEL 1
#else /* (__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__)*/
#define WGUI_VOLUME_LEVEL_BASE WGUI_VOLUME_LEVEL0
#endif /* (__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__)*/

/*added by lhm for 9664*/
#ifdef __MMI_MAINLCD_96X64__
void show_vertical_bar(S32 volume_level)
{
    volume_level_UI = volume_level;
    if (volume_level_UI <= MIN_LEVEL)
    {
        volume_level_UI = MIN_LEVEL;
    }
    if (volume_level_UI >= MAX_LEVEL)
    {
        volume_level_UI = MAX_LEVEL;
    }
    
    wgui_slide_control_set_value(volume_level_UI);
}

void show_vertical_bar_previous(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_vertical_bar(--volume_level_UI);
}

void show_vertical_bar_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_vertical_bar(++volume_level_UI);
}
void wgui_cat105_slide_callback(S32 value)
{
    volume_level_UI = value;
    if (volume_level_UI <= MIN_LEVEL)
    {
        volume_level_UI = MIN_LEVEL;
    }
    if (volume_level_UI >= MAX_LEVEL)
    {
        volume_level_UI = MAX_LEVEL;
    }
}
void ShowCategory105Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 *volume_level,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);


    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);

    dm_add_title_id(title, title_icon);
    dm_add_softkey_id(left_softkey, right_softkey);

    volume_level_UI = (*volume_level);
    MMI_ASSERT(volume_level_UI >=MIN_LEVEL && volume_level_UI <= MAX_LEVEL );
    
    MMI_slide_control_value[0] = volume_level;

    MMI_current_slide_control = &MMI_slide_control[0];
    MMI_current_slide_control_value = (S32*) MMI_slide_control_value[0];            
    /* Avoid NULL pointer in global context */
    MMI_ASSERT(MMI_current_slide_control && MMI_current_slide_control_value);

    dm_add_slide_control(MIN_LEVEL, MAX_LEVEL, *volume_level, wgui_cat105_slide_callback, NULL);
 
    SetKeyDownHandler(wgui_slide_control_previous, KEY_LEFT_ARROW);
    SetKeyRepeatHandler(wgui_slide_control_previous, KEY_LEFT_ARROW);
    SetKeyDownHandler(wgui_slide_control_previous, KEY_VOL_DOWN);
    
    SetKeyDownHandler(wgui_slide_control_next, KEY_RIGHT_ARROW);
    SetKeyRepeatHandler(wgui_slide_control_next, KEY_RIGHT_ARROW);
    SetKeyDownHandler(wgui_slide_control_next, KEY_VOL_UP);

    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY88_1ITEM_ID, DM_CLEAR_SCREEN_BACKGROUND, UI_dummy_function);
    dm_redraw_category_screen();
}

#else
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
U16 g_wgui_cat105_btn_up_id = 0;
U16 g_wgui_cat105_btn_down_id = 0;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_set_up_button
 * DESCRIPTION
 *  set up button status
 * PARAMETERS
 *  enable     [IN]        if button is enable
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_set_up_button(MMI_BOOL enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button* bt_info = dm_get_button(g_wgui_cat105_btn_up_id);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (enable == MMI_TRUE)
    {
        bt_info->flags |= UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags &= ~UI_BUTTON_NO_SHIFT_BUTTON;
        bt_info->flags &= ~UI_BUTTON_STATE_DISABLED;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_UP_UP_IMAGE_ID), gui_transparent_color(0, 0, 0));      
        bt_info->clicked_down_icon = get_image(WGUI_VOLUME_UP_DOWN_IMAGE_ID);
    }
    else
    {
        bt_info->flags &= ~UI_BUTTON_STATE_CLICKED;
        bt_info->flags &= ~UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
        bt_info->flags |= UI_BUTTON_STATE_DISABLED;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_UP_DISABLE_IMAGE_ID), gui_transparent_color(0, 0, 0));
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_set_down_button
 * DESCRIPTION
 *  set down button status
 * PARAMETERS
 *  enable     [IN]        if button is enable
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_set_down_button(MMI_BOOL enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    icontext_button* bt_info = dm_get_button(g_wgui_cat105_btn_down_id);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/      
    if (enable == MMI_TRUE)
    {
        bt_info->flags |= UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags &= ~UI_BUTTON_NO_SHIFT_BUTTON;
        bt_info->flags &= ~UI_BUTTON_STATE_DISABLED;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_DOWN_UP_IMAGE_ID), gui_transparent_color(0, 0, 0));
        bt_info->clicked_down_icon = get_image(WGUI_VOLUME_DOWN_DOWN_IMAGE_ID);
    }
    else
    {
        bt_info->flags &= ~UI_BUTTON_STATE_CLICKED;
        bt_info->flags &= ~UI_BUTTON_SHIFT_BUTTON1;
        bt_info->flags |= UI_BUTTON_NO_SHIFT_BUTTON;
        bt_info->flags |= UI_BUTTON_STATE_DISABLED;
        gui_icontext_button_set_icon(bt_info, get_image(WGUI_VOLUME_DOWN_DISABLE_IMAGE_ID), gui_transparent_color(0, 0, 0));
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_clear_btn_bg
 * DESCRIPTION
 *  Draws the category105 button background
 * PARAMETERS
 *  button_object      [IN]        Button pointer.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat105_clear_btn_bg(void *button_object)
{
    button *b = (button*) button_object;

    gdi_draw_solid_rect(b->x, b->y, b->x+b->width, b->y+b->height, GDI_COLOR_TRANSPARENT);
}
#endif  /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */

#if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_WEARABLE_DEVICE__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_ctrl_area_redraw
 * DESCRIPTION
 *  Draws the category105 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_ctrl_area_redraw(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    {
#if defined(__MMI_WEARABLE_DEVICE__)
#ifdef __MMI_WEARABLE_DEVICE_UI_ENHANCE__
		gui_watch_progress_bar_struct volume_bar = {0};
		wgui_watch_progress_bar_create(&volume_bar,
        24,
        79,
        MAX_LEVEL,
        volume_level_UI);
		wgui_watch_progress_bar_draw(volume_bar);
#else
        gui_volume_bar_struct volume_bar = {0};

        volume_bar.bg_opacity = 128;
        volume_bar.block_gap = 5;
        volume_bar.slot_width = 3;
        volume_bar.slot_gap = 1;
        volume_bar.show_bg = MMI_TRUE;
        volume_bar.slot_height = 40;
        volume_bar.max_value = MAX_LEVEL;
        volume_bar.level_value = volume_level_UI;
        volume_bar.slot_num = 8;
		volume_bar.x = (LCD_WIDTH - ((volume_bar.slot_width * volume_bar.slot_num + volume_bar.slot_gap * (volume_bar.slot_num - 1)) * volume_bar.max_value
					+ (volume_bar.max_value - 1) * volume_bar.block_gap)) / 2;
		volume_bar.y = (LCD_HEIGHT - MMI_SW_BUTTON_BAR_HEIGHT) / 2 - volume_bar.slot_height - MMI_VOLUME_BAR_BG_TOP_OFFSET - 1;
        volume_bar.bg_color = gdi_act_color_from_rgb(255, 25, 26, 31);
        volume_bar.highlight_color = gdi_act_color_from_rgb(255, 54, 155, 165);
        volume_bar.normal_color = gdi_act_color_from_rgb(255, 62, 64, 76);

        gui_volume_bar_draw(volume_bar);
#endif/*__MMI_WEARABLE_DEVICE_UI_ENHANCE__*/
#else /* __MMI_WEARABLE_DEVICE__ */
        S32 img_w, img_h;
        
        /* Draw BG and FILL */    
        gui_measure_image(get_image(WGUI_VOLUME_BG), &img_w, &img_h);
        gui_show_image(((UI_device_width - img_w) >> 1), MMI_CAT105_BG_Y, get_image(WGUI_VOLUME_BG));

#if defined(__MMI_SLIM_IMG_RES__)
        /* draw progress bar */
        gui_fill_rectangle(
            WGUI_CAT105_PROGRESS_BAR_X, 
            WGUI_CAT105_PROGRESS_BAR_Y, 
            WGUI_CAT105_PROGRESS_BAR_X + WGUI_CAT105_PROGRESS_BAR_W,
            WGUI_CAT105_PROGRESS_BAR_Y + WGUI_CAT105_PROGRESS_BAR_H, 
            WGUI_CAT105_PROGRESS_BAR_BG_COLOR);
        if (volume_level_UI > 0)
        {
            gui_fill_rectangle(
                WGUI_CAT105_PROGRESS_BAR_X + 1, 
                WGUI_CAT105_PROGRESS_BAR_Y + 1, 
                WGUI_CAT105_PROGRESS_BAR_X + (WGUI_CAT105_PROGRESS_BAR_W * volume_level_UI / MAX_LEVEL) - 1,
                WGUI_CAT105_PROGRESS_BAR_Y + WGUI_CAT105_PROGRESS_BAR_H - 1, 
                WGUI_CAT105_PROGRESS_BAR_COLOR);
        }
#else
        /* draw progress bar */
        gdi_image_draw_resized(
            WGUI_CAT105_PROGRESS_BAR_X, 
            WGUI_CAT105_PROGRESS_BAR_Y, 
            WGUI_CAT105_PROGRESS_BAR_W + 1,
            WGUI_CAT105_PROGRESS_BAR_H + 1, 
            get_image(WGUI_VOLUME_PROGRESS_OFF));
        if (volume_level_UI > 0)
        {
            GDI_HANDLE act_layer = GDI_NULL_HANDLE;

            gdi_layer_get_active(&act_layer);
            if (act_layer != GDI_NULL_HANDLE)
            {
                gdi_push_and_set_alpha_blending_source_layer(act_layer);
            }

            gdi_image_draw_resized(
                    WGUI_CAT105_PROGRESS_BAR_X + 1, 
                    WGUI_CAT105_PROGRESS_BAR_Y + 1, 
                    (WGUI_CAT105_PROGRESS_BAR_W * volume_level_UI / MAX_LEVEL) - 1,
                    WGUI_CAT105_PROGRESS_BAR_H - 1, 
                    get_image(WGUI_VOLUME_PROGRESS_ON));

            if (act_layer != GDI_NULL_HANDLE)
            {
                gdi_pop_and_restore_alpha_blending_source_layer();
            }
        }
#endif
#endif /* __MMI_WEARABLE_DEVICE__ */
    }
}


#elif defined(__MMI_MAINLCD_128X64__)
#define WGUI_VOLUME__IMG_X        (13)
#define WGUI_VOLUME__IMG_Y        (37)
#define WGUI_VOLUME__IMG_W        (11)
#define WGUI_VOLUME__IMG_H        (8)
#define WGUI_VOLUME__IMG_W_GAP    (4)
#define WGUI_VOLUME__IMG_H_GAP    (5)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat105_ctrl_area_redraw
 * DESCRIPTION
 *  Draws the category105 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat105_ctrl_area_redraw(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MAX_LEVEL; i++)
    { 
        if (i > volume_level_UI - 1)
        {
            gui_draw_rectangle(
                WGUI_VOLUME__IMG_X + (WGUI_VOLUME__IMG_W + WGUI_VOLUME__IMG_W_GAP) * i, 
                WGUI_VOLUME__IMG_Y - WGUI_VOLUME__IMG_H_GAP * i,
                WGUI_VOLUME__IMG_X + WGUI_VOLUME__IMG_W + (WGUI_VOLUME__IMG_W + WGUI_VOLUME__IMG_W_GAP) * i,
                WGUI_VOLUME__IMG_Y + WGUI_VOLUME__IMG_H,
                UI_COLOR_BLACK);
        }
        else
        {
            gui_fill_rectangle(
                WGUI_VOLUME__IMG_X + (WGUI_VOLUME__IMG_W + WGUI_VOLUME__IMG_W_GAP) * i, 
                WGUI_VOLUME__IMG_Y - WGUI_VOLUME__IMG_H_GAP * i,
                WGUI_VOLUME__IMG_X + WGUI_VOLUME__IMG_W + (WGUI_VOLUME__IMG_W + WGUI_VOLUME__IMG_W_GAP) * i,
                WGUI_VOLUME__IMG_Y + WGUI_VOLUME__IMG_H,
                UI_COLOR_BLACK);
        }
    }
}
#endif /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) */

void wgui_cat105_set_button_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
    MMI_BOOL down = MMI_TRUE, up = MMI_TRUE;
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */            
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
#if defined(__MMI_TOUCH_SCREEN__)
    ResetCallbackTimer();
#endif
    if (volume_level_UI <= MIN_LEVEL)
    {
        volume_level_UI = MIN_LEVEL;
        down = MMI_FALSE;
    }
    if (volume_level_UI >= MAX_LEVEL)
    {
        volume_level_UI = MAX_LEVEL;
        up = MMI_FALSE;
    }

    wgui_cat105_set_down_button(down);
    wgui_cat105_set_up_button(up);
    RedrawCategoryFunction();
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) */            
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */
}

/* For detail description, please refer to wgui_categories.h */
void ShowCategory105Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 *volume_level,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_data_flags = DM_CLEAR_SCREEN_BACKGROUND;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    dm_add_title_id(title, title_icon);
    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey_id(left_softkey, right_softkey);

#ifdef __MMI_WEARABLE_DEVICE__
    dm_data_flags |= DM_SHOW_SWATCH_SOFTKEY;
#endif

    volume_level_UI = (*volume_level);

    if ((left_softkey == 0) && (right_softkey == 0))
    {
        dm_data_flags |= DM_NO_SOFTKEY;
    }

#if defined(__MMI_MAINLCD_128X64__)
    dm_data_flags |= DM_NO_TITLE;
#endif /* __MMI_MAINLCD_128X64__ */

    //wgui_softkey_set_filler_disabled(MMI_TRUE);

    MMI_ASSERT(volume_level_UI >=MIN_LEVEL && volume_level_UI <= MAX_LEVEL );

#if defined(__MMI_MAINLCD_128X64__) || defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_WEARABLE_DEVICE__)
    dm_register_category_controlled_callback(wgui_cat105_ctrl_area_redraw);
#else /* __MMI_SLIM_IMG_RES__ */
    dm_add_image(get_image(WGUI_VOLUME_LEVEL_BASE + volume_level_UI), NULL, NULL);
#endif /* __MMI_SLIM_IMG_RES__ */

    SetKeyDownHandler(show_vertical_bar_previous, KEY_VOL_DOWN);
    SetKeyDownHandler(show_vertical_bar_next, KEY_VOL_UP);
    SetKeyUpHandler(wgui_cat105_set_button_state, KEY_VOL_DOWN);
    SetKeyUpHandler(wgui_cat105_set_button_state, KEY_VOL_UP);

#ifdef __MMI_BTD_BOX_UI_STYLE__
    SetKeyHandler(show_vertical_bar_previous, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(show_vertical_bar_next, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_cat105_set_button_state, KEY_DOWN_ARROW, KEY_EVENT_UP);
    SetKeyHandler(wgui_cat105_set_button_state, KEY_UP_ARROW, KEY_EVENT_UP);
#endif

#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
    g_wgui_cat105_btn_up_id = dm_add_button(
                                  NULL,
                                  get_image(WGUI_VOLUME_UP_UP_IMAGE_ID),
                                  get_image(WGUI_VOLUME_UP_DOWN_IMAGE_ID),
                                  wgui_cat105_clear_btn_bg);

    g_wgui_cat105_btn_down_id = dm_add_button(
                                    NULL,
                                    get_image(WGUI_VOLUME_DOWN_UP_IMAGE_ID),
                                    get_image(WGUI_VOLUME_DOWN_DOWN_IMAGE_ID),
                                    wgui_cat105_clear_btn_bg);

    /* if level reach boundary, set button as disable */
    if (volume_level_UI == MIN_LEVEL)
    {
        wgui_cat105_set_down_button(MMI_FALSE);
    }
    else if (volume_level_UI == MAX_LEVEL)
    {
        wgui_cat105_set_up_button(MMI_FALSE);
    }
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */

    gdi_layer_unlock_frame_buffer();

#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)
    dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_EVENT_UP, wgui_cat105_set_button_state);
    dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_EVENT_DOWN, ShowVerticalBarUp);
    dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_REPEAT, ShowVerticalBarUp);
    dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_EVENT_UP, wgui_cat105_set_button_state);
    dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_EVENT_DOWN, ShowVerticalBarDown);
    dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_REPEAT, ShowVerticalBarDown);
#endif /* defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY105_ID, dm_data_flags, MMI_dummy_function);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void show_vertical_bar(S32 volume_level)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) && !defined(__MMI_MAINLCD_128X64__)
    MMI_BOOL down = MMI_TRUE, up = MMI_TRUE;
#endif
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    volume_level_UI = volume_level;

    if (volume_level_UI <= MIN_LEVEL)
    {
        volume_level_UI = MIN_LEVEL;
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) && !defined(__MMI_MAINLCD_128X64__)
        down = MMI_FALSE;
#endif
#endif
    }
    if (volume_level_UI >= MAX_LEVEL)
    {
        volume_level_UI = MAX_LEVEL;
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) && !defined(__MMI_MAINLCD_128X64__)
        up = MMI_FALSE;
#endif
#endif
    }

#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_) && !defined(__MMI_MAINLCD_128X64__)
#ifndef __MMI_WEARABLE_DEVICE__
    dm_change_image(get_image(WGUI_VOLUME_LEVEL_BASE + volume_level_UI), NULL, 0);
#endif
    wgui_cat105_set_up_button(up);
    wgui_cat105_set_down_button(down);
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */
#endif /* __MMI_MAINLCD_128X64__ */

    RedrawCategoryFunction();
}


/* For detail description, please refer to wgui_categories.h */
void show_vertical_bar_previous(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_vertical_bar(--volume_level_UI);
}


/* For detail description, please refer to wgui_categories.h */ 
void show_vertical_bar_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    show_vertical_bar(++volume_level_UI);
}
#ifdef __MMI_WEARABLE_DEVICE__

#define WGUI_PROGRESS_SLOT_WIDTH 3
#define WGUI_PROGRESS_SLOT_HEIGHT 34
#define WGUI_PROGRESS_SLOT_GAP 1
#define WGUI_PROGRESS_BLOCK_GAP 5
#define WGUI_PROGRESS_SLOT_NUM 10
S32 cat105_max_level = MAX_LEVEL;
S32 cat105_min_level = MIN_LEVEL;
S32 *progress_level = NULL;
static FuncPtr cat105_bt_callback[DM_MAX_BUTTONS][MAX_KEY_TYPE];

void cat105_register_increase_bt_callback(U16 key_type, FuncPtr f)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)	

	cat105_bt_callback[g_wgui_cat105_btn_up_id][key_type] = f;

#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */	
}

void cat105_register_decrease_bt_callback(U16 key_type, FuncPtr f)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)

	cat105_bt_callback[g_wgui_cat105_btn_down_id][key_type] = f;	

#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */

}

void cat105screen_redraw_progress()
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MMI_BOOL down = MMI_TRUE, up = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (*progress_level<cat105_min_level)
	{
		*progress_level = cat105_min_level;
		down = MMI_FALSE;
	}

	if (*progress_level>cat105_max_level)
	{
		*progress_level = cat105_max_level;
		up = MMI_FALSE;
	}
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)


	wgui_cat105_set_up_button(up);
    wgui_cat105_set_down_button(down);

#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */
	RedrawCategoryFunction();
}

void cat105screen_up_bt_handle(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	(*progress_level)++;
	cat105screen_redraw_progress();

#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)

	
	if (cat105_bt_callback[g_wgui_cat105_btn_up_id][KEY_EVENT_DOWN]!=NULL)
	{
		cat105_bt_callback[g_wgui_cat105_btn_up_id][KEY_EVENT_DOWN]();
	}

#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */

	
}

void cat105screen_down_bt_handle(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	(*progress_level)--;
	cat105screen_redraw_progress();
	
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)	

	if (cat105_bt_callback[g_wgui_cat105_btn_down_id][KEY_EVENT_DOWN]!=NULL)
	{
		cat105_bt_callback[g_wgui_cat105_btn_down_id][KEY_EVENT_DOWN]();
	}
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */		
}

void cat105screen_exit(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	cat105_max_level = MAX_LEVEL;
	cat105_min_level = MIN_LEVEL;
	progress_level = NULL;
}

static void wgui_cat105_ctrl_area_redraw_ext(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	#ifdef __MMI_WEARABLE_DEVICE_UI_ENHANCE__
	gui_watch_progress_bar_struct volume_bar = {0};
	#else
    gui_volume_bar_struct volume_bar = {0};
	#endif /*__MMI_WEARABLE_DEVICE_UI_ENHANCE__*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	#ifdef __MMI_WEARABLE_DEVICE_UI_ENHANCE__
	wgui_watch_progress_bar_create(&volume_bar,
        24,
        79,
        cat105_max_level,
        *progress_level);
		wgui_watch_progress_bar_draw(volume_bar);
	#else
	volume_bar.bg_opacity = 128;
	volume_bar.x = (LCD_WIDTH - ((WGUI_PROGRESS_SLOT_WIDTH * WGUI_PROGRESS_SLOT_NUM + WGUI_PROGRESS_SLOT_GAP * (WGUI_PROGRESS_SLOT_NUM - 1)) * cat105_max_level
					+ (cat105_max_level - 1) * WGUI_PROGRESS_BLOCK_GAP)) / 2;
	volume_bar.y = (LCD_HEIGHT - MMI_SW_BUTTON_BAR_HEIGHT) / 2 - WGUI_PROGRESS_SLOT_HEIGHT - MMI_VOLUME_BAR_BG_TOP_OFFSET - 1;
	volume_bar.block_gap = WGUI_PROGRESS_BLOCK_GAP;
	volume_bar.slot_width = WGUI_PROGRESS_SLOT_WIDTH;
	volume_bar.slot_gap = WGUI_PROGRESS_SLOT_GAP;
	volume_bar.show_bg = MMI_TRUE;
	volume_bar.slot_height = WGUI_PROGRESS_SLOT_HEIGHT;
	volume_bar.max_value = cat105_max_level;
	volume_bar.level_value = *progress_level;
	volume_bar.slot_num = WGUI_PROGRESS_SLOT_NUM;
	volume_bar.bg_color = gdi_act_color_from_rgb(255, 25, 26, 31);
    volume_bar.highlight_color = gdi_act_color_from_rgb(255, 54, 155, 165);
    volume_bar.normal_color = gdi_act_color_from_rgb(255, 62, 64, 76);

	//draw progress
	gui_volume_bar_draw(volume_bar);
	#endif /*__MMI_WEARABLE_DEVICE_UI_ENHANCE__*/
}

void ShowCategory105Screen_ext(
        U16 title,
        U16 title_icon,  
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        S32 max_level,  
        S32 min_level,
        S32 *volume_level,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_data_flags = DM_CLEAR_SCREEN_BACKGROUND;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    dm_add_title_id(title, title_icon);
    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey_id(left_softkey, right_softkey);

    dm_data_flags |= DM_SHOW_SWATCH_SOFTKEY;
	
	cat105_max_level = max_level;
	cat105_min_level = min_level;
    progress_level = volume_level;

    if ((left_softkey == 0) && (right_softkey == 0))
    {
        dm_data_flags |= DM_NO_SOFTKEY;
    }


    MMI_ASSERT(*progress_level >=MIN_LEVEL && *progress_level <= max_level);

    dm_register_category_controlled_callback(wgui_cat105_ctrl_area_redraw_ext);


#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)

    g_wgui_cat105_btn_up_id = dm_add_button(
                                  NULL,
                                  get_image(WGUI_VOLUME_UP_UP_IMAGE_ID),
                                  get_image(WGUI_VOLUME_UP_DOWN_IMAGE_ID),
                                  wgui_cat105_clear_btn_bg);

    g_wgui_cat105_btn_down_id = dm_add_button(
                                    NULL,
                                    get_image(WGUI_VOLUME_DOWN_UP_IMAGE_ID),
                                    get_image(WGUI_VOLUME_DOWN_DOWN_IMAGE_ID),
                                    wgui_cat105_clear_btn_bg);

    /* if level reach boundary, set button as disable */
    if (*progress_level == cat105_min_level)
    {
        wgui_cat105_set_down_button(MMI_FALSE);
    }
    else if (*progress_level == cat105_max_level)
    {
        wgui_cat105_set_up_button(MMI_FALSE);
    }
#endif /* defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */


	
    gdi_layer_unlock_frame_buffer();

	
#if (!defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__)) || defined(__MMI_WEARABLE_DEVICE__)
#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__) && !defined(__MMI_MAINLCD_128X128_)

  //  dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_EVENT_UP, wgui_cat105_set_button_state);
   dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_EVENT_DOWN, cat105screen_up_bt_handle);
   dm_register_button_functions(g_wgui_cat105_btn_up_id, KEY_REPEAT, cat105screen_up_bt_handle);
   // dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_EVENT_UP, wgui_cat105_set_button_state);
   dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_EVENT_DOWN, cat105screen_down_bt_handle);
   dm_register_button_functions(g_wgui_cat105_btn_down_id, KEY_REPEAT, cat105screen_down_bt_handle);
   
#endif /* defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WALLPAPER_ON_BOTTOM__) &&  !defined(__MMI_MAINLCD_128X128_) */ 
#endif /* #if !defined(__MMI_SLIM_IMG_RES__) && !defined(__MMI_FTE_SUPPORT__) */


   wgui_cat_setup_category_default_history(MMI_CATEGORY105_ID, dm_data_flags, cat105screen_exit);
   dm_redraw_category_screen();
}

#endif /*__MMI_WEARABLE_DEVICE_UI_ENHANCE__*/
#endif /*__MMI_MAINLCD_96X64__*/
#endif /* __PLUTO_MMI_PACKAGE__ */


#ifdef __MMI_BMI__

/* For properly placing the strings, images and boxes, the screen is divided into blocks. */
#define NUMBER_OF_X_BLOCKS 7
#define NUMBER_OF_Y_BLOCKS 15

/* used by categopry 122 */
U8 *disp_barstr = NULL, *left_value = NULL, *right_value = NULL;

/*****************************************************************************
 * FUNCTION
 *  RedrawCategory122Screen
 * DESCRIPTION
 *  Category 122 redraw
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCategory122Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fh, fw;
    S32 total_width = 0;
    S32 x1, y1, x2, y2;
    S32 block_size_x = MMI_content_width / NUMBER_OF_X_BLOCKS;
    S32 block_size_y = MMI_content_height / NUMBER_OF_Y_BLOCKS;
    S32 gap_x = (MMI_content_width % NUMBER_OF_X_BLOCKS) >> 1;
    S32 gap_y = (MMI_content_height % NUMBER_OF_Y_BLOCKS) >> 1;

    color c = *current_MMI_theme->title_text_color;
    color bc = *current_MMI_theme->title_text_border_color; /* calendar text */
    stFontAttribute *f = &MMI_medium_font;

    UI_filled_area yellowwgui_pop_up_dialog_background = 
    {
        UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
        UI_NULL_IMAGE,
        NULL,
        {249, 244, 171, 100},
        {0, 0, 0, 0},
        {0, 0, 0, 100},
        {50, 50, 50, 100},
        0
    };
    
    UI_filled_area orangewgui_without_boder_pop_up_dialog_background = 
    {
        UI_FILLED_AREA_TYPE_COLOR | UI_FILLED_AREA_SINGLE_BORDER,
        UI_NULL_IMAGE,
        NULL,
        {242, 174, 33, 100},
        {0, 0, 0, 0},
        {0, 0, 0, 100},
        {50, 50, 50, 100},
        0
    };
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_font(f);
    gui_set_text_color(c);
    gui_set_text_border_color(bc);

    gdi_layer_lock_frame_buffer();

    gdi_layer_push_clip();
    gdi_layer_reset_clip();

    wgui_show_transparent_animation();

    y1 = MMI_content_y + gap_y + block_size_y;
    y2 = y1 + (3 * block_size_y) - 1;


    gui_measure_string(MMI_message_string, &fw, &fh);
    total_width += fw;
    gui_measure_string((UI_string_type) disp_barstr, &fw, &fh);
    total_width += fw;
    gui_measure_image(_MMI_animated_icon, &fw, &fh);
    total_width += fw;

    x1 = _MMI_animated_icon_x;
    if (fw > 0)
    {
        if (mmi_fe_get_r2l_state())
        {   
            x1 -= 10;
        }
        else
        {
            x1 += (fw + 10);
        }
    }

    gui_measure_string(MMI_message_string, &fw, &fh);
    gui_move_text_cursor(x1, y2 - fh);
    gui_print_bordered_text(MMI_message_string);


    if (mmi_fe_get_r2l_state())
    {
        x1 -= (fw + 5);
    }
    else
    {
        x1 += (fw + 5);
    }

    gui_measure_string((UI_string_type) disp_barstr, &fw, &fh);
    gui_move_text_cursor(x1, y2 - fh);
    gui_print_bordered_text((UI_string_type) disp_barstr);

    x1 = MMI_content_x + gap_x + (block_size_x / 2);
    y1 = y2 + (block_size_y);
    x2 = x1 + (6 * block_size_x) - 1;
    y2 = y1 + (3 * block_size_y) - 1;

    gui_draw_filled_area(
        x1 + (2 * block_size_x) - 5,
        y1,
        x2 - (2 * block_size_x) + 5,
        y2,
        &orangewgui_without_boder_pop_up_dialog_background);

    gui_measure_string((UI_string_type) MMI_message_string2, &fw, &fh);
    if (mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(x1 + (3 * block_size_x) + (fw >> 1), ((y1 >> 1) + (y2 >> 1)) - (fh >> 1));
    }
    else
    {
        gui_move_text_cursor(x1 + (3 * block_size_x) - (fw >> 1), ((y1 >> 1) + (y2 >> 1)) - (fh >> 1));
    }

    gui_print_bordered_text((UI_string_type) MMI_message_string2);

    x1 = MMI_content_x + gap_x + (block_size_x / 2);
    y1 = MMI_content_y + gap_y + (9 * block_size_y);
    x2 = x1 + (6 * block_size_x);
    y2 = y1 + (3 * block_size_y) - 1;

    gui_draw_filled_area(x1, y1, x2, y2, &yellowwgui_pop_up_dialog_background);
    gui_draw_vertical_line(y1, y2, x1 + (2 * block_size_x), yellowwgui_pop_up_dialog_background.border_color); /* 082606 calendar line */
    gui_draw_vertical_line(y1, y2, x1 + (4 * block_size_x), yellowwgui_pop_up_dialog_background.border_color);

    /* wgui_image_clip_x1 stores the percentage value for deciding the position
       of highlighted block. */
    x1 = x1 + (wgui_image_clip_x1 * (2 * block_size_x));
    x2 = x1 + (2 * block_size_x);
    gui_draw_filled_area(x1, y1, x2, y2, &orangewgui_without_boder_pop_up_dialog_background);

    x1 = MMI_content_x + gap_x + (block_size_x / 2);
    y1 = y1 + (4 * block_size_y);
    x2 = x1 + (6 * block_size_x) - 1;
    y2 = y1 + block_size_y;

    gui_measure_string((UI_string_type) left_value, &fw, &fh);
    if (mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(x1 + (2 * block_size_x) + (fw >> 1), y1);
    }
    else
    {
        gui_move_text_cursor(x1 + (2 * block_size_x) - (fw >> 1), y1);
    }

    gui_print_bordered_text((UI_string_type) left_value);

    gui_measure_string((UI_string_type) right_value, &fw, &fh);
    if (mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(x1 + (4 * block_size_x) + (fw >> 1), y1);
    }
    else
    {
        gui_move_text_cursor(x1 + (4 * block_size_x) - (fw >> 1), y1);
    }

    gui_print_bordered_text((UI_string_type) right_value);

    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate122CategoryControlArea
 * DESCRIPTION
 *  Draws the category122 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate122CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCategory122Screen();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory122Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message,
        S32 percentage_value,
        U8 *history_buffer,
        S8 *disp_val,
        U8 *bar_status,
        U16 side_icon,
        U8 *left_limit,
        U8 *right_limit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fw, fh;
    S32 total_width = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    wgui_title_set_menu_shortcut_number(-1);
    dm_add_softkey_id(left_softkey, right_softkey);

    dm_add_title_id(title, title_icon);

    MMI_message_string = get_string(message);

    MMI_message_string2 = (UI_string_type) disp_val;
    disp_barstr = (PU8) bar_status;

    /* 
     * store the percentage value in Global variable, so that is can be used
     * in the redraw category. 
     */
    wgui_image_clip_x1 = percentage_value;

    left_value = (PU8) left_limit;
    right_value = (PU8) right_limit;

    gui_measure_string(MMI_message_string, &fw, &fh);
    total_width += fw;
    gui_measure_string((UI_string_type) disp_barstr, &fw, &fh);
    total_width += fw;
    gui_measure_image((PU8) get_image(side_icon), &fw, &fh);
    total_width += fw;

    /* add gaps between image and strings */
    if (fw > 0)
    {
        total_width += (10 + 5);
    }
    else
    {
        total_width += 5;
    }
    if (mmi_fe_get_r2l_state())
    {   
        wgui_set_animation_y(
            (UI_device_width >> 1) + (total_width >> 1) - (fw >> 1),
            MMI_content_y + ((MMI_content_height % NUMBER_OF_Y_BLOCKS) >> 1) + (4 * (MMI_content_height / NUMBER_OF_Y_BLOCKS)) - 1 - fh,
            side_icon);

    }
    else
    {
        wgui_set_animation_y(
            (UI_device_width >> 1) - (total_width >> 1) + (fw >> 1),
            MMI_content_y + ((MMI_content_height % NUMBER_OF_Y_BLOCKS) >> 1) + (4 * (MMI_content_height / NUMBER_OF_Y_BLOCKS)) - 1 - fh,
            side_icon);

    }

    dm_register_category_controlled_callback(DrawCate122CategoryControlArea);
    wgui_cat_setup_category_default_history(MMI_CATEGORY122_ID, DM_CLEAR_SCREEN_BACKGROUND, UI_dummy_function);
    dm_redraw_category_screen();
}
#endif /* __MMI_BMI__ */ 

///TODO: Remove after BT revise, ( Zhanying Liu)
#ifndef WGUI_REMOVE_CAT113_TO_SLIM
static U8 g_wgui_cat113_number_of_icons = 0;
static PU8 *g_wgui_cat113_list_of_icons = NULL;
static U8 g_wgui_cat113_backup_scr_bg_opacity = 0;
static color cat113_multi_line_backup_color;


/*****************************************************************************
 * FUNCTION
 *  RedrawCate113IconArray
 * DESCRIPTION
 *  Redraw category 113 icon array.
 *  This icon arry will be center alignment.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCate113IconArray(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h, i, x_offset, y_offset, number_of_visible_icons, accumulated_width;
    S32 gap = 5;
    S32 img_w, img_h, max_h;
    GDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = MMI_COMMON_CONTENT_X;
#if defined(__MMI_MAINLCD_128X128__)
	y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - MMI_MENUITEM_HEIGHT;
#else /*__MMI_MAINLCD_128X128__*/
    y = CAT113_START_Y + MMI_MENUITEM_HEIGHT * 4 + 6;
#endif /*__MMI_MAINLCD_128X128__*/
    w = MMI_COMMON_CONTENT_WIDTH;
#if defined(__MMI_MAINLCD_128X128__)
    h = MMI_MENUITEM_HEIGHT;
#else /*__MMI_MAINLCD_128X128__*/
    h = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - y;
#endif /*__MMI_MAINLCD_128X128__*/
    number_of_visible_icons = 0;

    /* calculate visible icons */
    accumulated_width = max_h = 0;
    for (i = 0 ; i < g_wgui_cat113_number_of_icons ; i++)
    {
        ret = gdi_image_get_dimension(g_wgui_cat113_list_of_icons[i], &img_w, &img_h);
        if (ret >= 0)
        {
            img_w += gap;
            if ((accumulated_width + img_w) <= w)
            {
                accumulated_width += img_w;
                number_of_visible_icons++;

                max_h = (img_h > max_h) ? (img_h) : (max_h);
            }
            else
            {
                break;
            }
        }
    }
    max_h = (max_h > h) ? (h) : (max_h);

    x_offset = ((w - accumulated_width) >> 1);
    y_offset = ((h - max_h) >> 1);

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, (x + w - 1), (y + h - 1));

    /* clear background */
    gdi_draw_solid_rect(x, y, (x + w - 1), (y + h - 1), GDI_COLOR_TRANSPARENT);

    /* display visible icons */
    accumulated_width = 0;
    for (i = 0 ; i < number_of_visible_icons ; i++)
    {
        ret = gdi_image_get_dimension(g_wgui_cat113_list_of_icons[i], &img_w, &img_h);
        if (ret >= 0)
        {
            img_w += gap;
            gdi_image_draw(x + x_offset + accumulated_width, y + y_offset, g_wgui_cat113_list_of_icons[i]);
            accumulated_width += img_w;
        }
    }

    gdi_layer_pop_clip();
}


/* For detail description, please refer to wgui_categories.h */
void UpdateCate113IconArray(U8 number_of_icons, PU8 *list_of_icons)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat113_number_of_icons = number_of_icons;
    g_wgui_cat113_list_of_icons = list_of_icons;
    RedrawCate113IconArray();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate113CategoryControlArea
 * DESCRIPTION
 *  Cateogry 113 control area redraw callback
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate113CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCate113IconArray();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory113Screen
 * DESCRIPTION
 *  Exit category 113
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory113Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_multi_line_input_box_theme->normal_text_color = cat113_multi_line_backup_color;

    g_wgui_cat113_number_of_icons = 0;
    g_wgui_cat113_list_of_icons = NULL;
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_set_scr_bg_opacity(g_wgui_cat113_backup_scr_bg_opacity);
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory113Screen(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type message1,
        UI_string_type message2,
        UI_string_type message3,
        U8 number_of_icons,
        PU8 *list_of_icons,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    /* set title */
    dm_add_title(title, title_icon);

    /* set softkey */
    dm_add_softkey_str(left_softkey, right_softkey);

    cat113_multi_line_backup_color = current_multi_line_input_box_theme->normal_text_color;
    current_multi_line_input_box_theme->normal_text_color = *(current_MMI_theme->list_normal_text_color);

    /* set messages */
    dm_add_string(message1, &MMI_medium_font,
        current_multi_line_input_box_theme->normal_text_color, UI_COLOR_BLACK, NULL);
    dm_add_string(message2, &MMI_medium_font,
        current_multi_line_input_box_theme->normal_text_color, UI_COLOR_BLACK, NULL);

    l = gui_strlen(message3);
    create_multiline_inputbox_set_buffer(message3, l, l, 0);
    MMI_multiline_inputbox.flags |= (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE | UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY);  /* |UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND); */
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER;
    wgui_inputs_ml_register_viewer_keys();

#ifdef __MMI_FTE_SUPPORT__
    gui_inputs_set_transparent_background(MMI_TRUE);
#endif /* __MMI_FTE_SUPPORT */

    /* set icon array */
    g_wgui_cat113_number_of_icons = number_of_icons;
    g_wgui_cat113_list_of_icons = list_of_icons;

    /* set opacity */
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
    dm_get_scr_bg_opacity(&g_wgui_cat113_backup_scr_bg_opacity);
    dm_set_scr_bg_opacity((U8)(current_MMI_theme->bg_opacity_low));
#endif 

    gdi_layer_unlock_frame_buffer();

    /* Setup category/draw manager data */
    dm_register_category_controlled_callback(DrawCate113CategoryControlArea);
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY113_ID, DM_CLEAR_SCREEN_BACKGROUND, ExitCategory113Screen);
    dm_redraw_category_screen();
}
#endif /*WGUI_REMOVE_CAT113_TO_SLIM*/

#ifdef __MMI_ENGINEER_MODE__
/*****************************************************************************
 * FUNCTION
 *  ExitCategory204Screen
 * DESCRIPTION
 *  Exits the category204 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory204Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_inputs_sl_reset();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory204Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 NotificationStringId,
        U16 value,
        U16 imageId,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_string_type text[5];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    UI_UNUSED_PARAMETER(imageId);
    gdi_layer_lock_frame_buffer();
    
    dm_add_softkey_id(left_softkey, right_softkey);

    MMI_title_string = (UI_string_type) get_string(NotificationStringId);

    gui_itoa(value, (UI_string_type) text, 10);
    wgui_inputs_sl_create_set_buffer(
        (UI_string_type) text,
        gui_strlen((UI_string_type) text) + 1,
        gui_strlen((UI_string_type) text),
        gui_strlen((UI_string_type) text));
    wgui_inputs_sl_set_mask(0);
    MMI_singleline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_singleline_inputbox.flags |=
        (UI_SINGLE_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_SINGLE_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
         UI_SINGLE_LINE_INPUT_BOX_CENTER_JUSTIFY);

    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY204_ID, DM_CLEAR_SCREEN_BACKGROUND_COLOR, ExitCategory204Screen);
    dm_redraw_category_screen();
}
#endif /* __MMI_ENGINEER_MODE__ */ 


#ifdef __MMI_FACTORY_MODE__
/*****************************************************************************
 * FUNCTION
 *  ShowCategory205Screen
 * DESCRIPTION
 *  Displays the category205 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  message                 [IN]        String to be displayed.
 *  message_icon            [IN]        Id of image to be displayed.
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory205Screen(
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        UI_string_type message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);

    dm_add_softkey_id(left_softkey, right_softkey);

    MMI_message_string = (UI_string_type) message;
    l = gui_strlen(MMI_message_string);
    wgui_inputs_ml_create_set_buffer(MMI_message_string, l, l, 0);
    MMI_multiline_inputbox.flags |=
        (UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
         UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR);
    gui_set_font(MMI_multiline_inputbox.text_font);

    dm_add_image(get_image(message_icon), NULL, NULL);

    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        MMI_dummy_function);

#ifdef WGUI_STATUS_ICON_SHOW_V_BAR 
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        MMI_dummy_function);
#endif /*WGUI_STATUS_ICON_SHOW_V_BAR*/

    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY205_ID, DM_CLEAR_SCREEN_BACKGROUND, MMI_dummy_function);
    dm_redraw_category_screen();
}
#endif /* __MMI_FACTORY_MODE__ */ 


/*****************************************************************************
 * FUNCTION
 *  category88_handle_down_key
 * DESCRIPTION
 *  handle key down of category88
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category88_handle_down_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_hide_slide_control_focus();
    if (MMI_current_slide_control == &MMI_slide_control[dm_get_slide_control_count() - 1])
    {
        MMI_current_slide_control = &MMI_slide_control[0];
    }
    else
    {
        MMI_current_slide_control++;
    }
    if (dm_get_slide_control_count() > 1)
    {
        wgui_slide_control_set_focus(MMI_current_slide_control);
        wgui_show_slide_control_focus();
    }

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/*****************************************************************************
 * FUNCTION
 *  category88_handle_up_key
 * DESCRIPTION
 *  handle key up of category88
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void category88_handle_up_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_hide_slide_control_focus();
    if (MMI_current_slide_control == &MMI_slide_control[0])
    {
        MMI_current_slide_control = &MMI_slide_control[dm_get_slide_control_count() - 1];
    }
    else
    {
        MMI_current_slide_control--;
    }
    if (dm_get_slide_control_count() > 1)
    {
        wgui_slide_control_set_focus(MMI_current_slide_control);
        wgui_show_slide_control_focus();
    }

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory88Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        U16 bg_image_id,
        U16 n_items,
        U8 **string_list,
        S32 *lower_limit,
        S32 *upper_limit,
        S32 **current_value,
        void (**cb_func) (S32 value),
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 idx = 0;
    U8 h_flag;
    color c = gui_color(0, 0, 0);
    color wc = gui_color(255, 255, 255);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(n_items <= MMI_MAX_SLIDE_CONTROL);

    UI_UNUSED_PARAMETER(history_buffer);

    MMI_ASSERT(lower_limit != NULL);
    MMI_ASSERT(upper_limit != NULL);
    MMI_ASSERT(current_value != NULL);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);

    dm_add_title_id(title, title_icon);
    dm_add_softkey_id(left_softkey, right_softkey);

    h_flag = set_slide_control_category_history((U16) (MMI_CATEGORY88_1ITEM_ID + n_items - 1), (U8*) history_buffer);
    if (h_flag)
    {
        /* the number of slide controls should be the same as the number kept in history */
        MMI_ASSERT(h_flag == n_items);

        for (idx = 0; idx < n_items; idx++)
        {
            *current_value[idx] = *MMI_slide_control_value[idx];
        }
    }
    else
    {
        for (idx = 0; idx < n_items; idx++)
        {
            MMI_slide_control_value[idx] = (current_value[idx]);
        }

        MMI_current_slide_control = &MMI_slide_control[0];
        MMI_current_slide_control_value = (S32*) MMI_slide_control_value[0];            
    }

    /* Avoid NULL pointer in global context */
    MMI_ASSERT(MMI_current_slide_control && MMI_current_slide_control_value);

    for (idx = 0; idx < n_items; idx++)
    {
    #ifndef __MMI_MAINLCD_96X64__ /*modified by lhm for 9664*/
        if (string_list)
        {
            dm_add_string((UI_string_type) string_list[idx], &MMI_default_font, c, wc, NULL);
            if (cb_func != NULL)
            {
                dm_add_slide_control(
                    lower_limit[idx],
                    upper_limit[idx],
                    *current_value[idx],
                    cb_func[idx],
                    string_list[idx]);
            }
            else
            {
                dm_add_slide_control(lower_limit[idx], upper_limit[idx], *current_value[idx], NULL, string_list[idx]);
            }
        }
        else
     #endif /*__MMI_MAINLCD_96X64__*/
        {
            if (cb_func != NULL)
            {
                dm_add_slide_control(lower_limit[idx], upper_limit[idx], *current_value[idx], cb_func[idx], NULL);
            }
            else
            {
                dm_add_slide_control(lower_limit[idx], upper_limit[idx], *current_value[idx], NULL, NULL);
            }
        }
    }

    SetKeyDownHandler(wgui_slide_control_previous, KEY_LEFT_ARROW);
    SetKeyRepeatHandler(wgui_slide_control_previous, KEY_LEFT_ARROW);

    SetKeyDownHandler(wgui_slide_control_next, KEY_RIGHT_ARROW);
    SetKeyRepeatHandler(wgui_slide_control_next, KEY_RIGHT_ARROW);

#ifdef __MMI_BTD_BOX_UI_STYLE__   
    SetKeyHandler(wgui_slide_control_previous, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_slide_control_previous, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);
    SetKeyHandler(wgui_slide_control_next, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_slide_control_next, KEY_UP_ARROW, KEY_EVENT_REPEAT);
#endif

    if (n_items > 1)
    {
        SetKeyDownHandler(category88_handle_up_key, KEY_VOL_UP);
        SetKeyRepeatHandler(category88_handle_up_key, KEY_VOL_UP);

        SetKeyDownHandler(category88_handle_down_key, KEY_VOL_DOWN);
        SetKeyRepeatHandler(category88_handle_down_key, KEY_VOL_DOWN);

        SetKeyDownHandler(category88_handle_up_key, KEY_UP_ARROW);
        SetKeyRepeatHandler(category88_handle_up_key, KEY_UP_ARROW);

        SetKeyDownHandler(category88_handle_down_key, KEY_DOWN_ARROW);
        SetKeyRepeatHandler(category88_handle_down_key, KEY_DOWN_ARROW);
    }

    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY88_1ITEM_ID + n_items - 1, DM_CLEAR_SCREEN_BACKGROUND, UI_dummy_function);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory87Screen_int(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 right_softkey,
        S32 l_limit,
        S32 u_limit,
        S32 *current_value,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 lower_limit[1], upper_limit[1];
    S32 *curr_value[1];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    lower_limit[0] = l_limit;
    upper_limit[0] = u_limit;
    curr_value[0] = current_value;
    ShowCategory88Screen_int(
        title,
        title_icon,
        left_softkey,
        right_softkey,
        0,
        1,
        NULL,
        lower_limit,
        upper_limit,
        curr_value,
        NULL,
        history_buffer);
}   /* end of ShowCategory87Screen */

/* For detail description, please refer to wgui_categories.h */
/*added by lhm for 9664*/
#ifdef __MMI_MAINLCD_96X64__
void ShowCategory141Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    UI_UNUSED_PARAMETER(message_icon);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    dm_add_softkey_id(left_softkey, right_softkey);

    gui_set_font(&MMI_small_font);
    ShowStatusIconsTitle();

    l = gui_strlen((UI_string_type) message);
    wgui_inputs_ml_create_set_buffer((UI_string_type) message, l, l, 0);
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.border_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT;
    MMI_multiline_inputbox.flags |=  UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
        UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
        UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_USE_ENCODING_BASED_LENGTH;

    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(
        MMI_CATEGORY141_STATUS_ICON_ID, 
        DM_CLEAR_SCREEN_BACKGROUND_COLOR | DM_SET_NEW_LAYER_ACTIVE, 
        NULL);
    dm_redraw_category_screen();
}

#else
void ShowCategory141Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message,
        U16 message_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 dm_data_cat_id;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    dm_add_softkey_id(left_softkey, right_softkey);

    gui_set_font(&MMI_medium_font);
    if (title == 0)
    {
        ShowStatusIconsTitle();
        dm_data_cat_id = MMI_CATEGORY141_STATUS_ICON_ID;
    }
    else
    {
        dm_add_title_id(title, title_icon);
        dm_data_cat_id = MMI_CATEGORY141_ID;
    }
    l = gui_strlen((UI_string_type) message);
    wgui_inputs_ml_create_set_buffer((UI_string_type) message, l, l, 0);
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.flags |=
        UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
        UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
        UI_MULTI_LINE_INPUT_BOX_AUTO_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_USE_ENCODING_BASED_LENGTH;

    dm_add_image(get_image(message_icon), NULL, NULL);

    gdi_layer_unlock_frame_buffer();

    wgui_cat_setup_category_default_history(
        dm_data_cat_id, 
        DM_CLEAR_SCREEN_BACKGROUND_COLOR | DM_SET_NEW_LAYER_ACTIVE, 
        NULL);
    dm_redraw_category_screen();
}
#endif /*__MMI_MAINLCD_96X64__*/

#if defined(__MMI_SMART_MESSAGE_MT__) || (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__))
/* category 154 message 1 */
UI_string_type category_620_message1 = NULL;

/* category 154 message 2 */
UI_string_type category_620_message2 = NULL;

/* category 154 message 1 y postition */
S32 category_620_message1_y = 0;

/* category 154 message 2 y position  */
S32 category_620_message2_y = 0;
U8 Category620Align = 0;


/* For detail description, please refer to wgui_categories.h */
void RedrawCategory620Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w1, h1, w2, h2, x;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    clear_screen();
    if (wgui_switch_title_with_status_bar)
    {
        wgui_status_icon_bar_update();
    }
    else
    {
        draw_title();
    }
    gdi_layer_reset_clip();
    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(category_620_message1, &w1, &h1);
    gui_measure_string(category_620_message2, &w2, &h2);
    gui_set_text_color(gui_color(0, 0, 0));
    if (Category620Align)
    {
        x = 2;
    }
    else
    {
        x = (UI_device_width >> 1) - (w1 >> 1);
        if (x < 2)
        {
            x = 2;
        }
    }
    gui_move_text_cursor(x, category_620_message1_y);
    gui_set_line_height(h1);
    gui_print_text(category_620_message1);
    if (Category620Align)
    {
        x = 2;
    }
    else
    {
        x = (UI_device_width >> 1) - (w2 >> 1);
        if (x < 2)
        {
            x = 2;
        }
    }
    gui_print_truncated_text(x, category_620_message2_y, UI_device_width - 2, category_620_message2);
    gdi_layer_set_clip(
        0,
        (MMI_title_y + MMI_title_height) + 1,
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1);
    wgui_show_transparent_animation();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/* For detail description, please refer to wgui_categories.h */
void Setcategory620LeftAlign(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Category620Align = 1;
}


/* For detail description, please refer to wgui_categories.h */
void ChangeCategory620Data(U8 *message1, U8 *message2, U8 *message_icon_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w1, h1, w2, h2, w3, h3, y, th, rh;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    category_620_message1 = (UI_string_type) message1;
    category_620_message2 = (UI_string_type) message2;
    gui_set_font(current_UI_theme->multi_line_input_box_theme->text_font);
    gui_measure_string(category_620_message1, &w1, &h1);
    gui_measure_string(category_620_message2, &w2, &h2);
    gui_measure_image((PU8) message_icon_buffer, &w3, &h3);
    th = h1 + h2 + h3 + 2;
    y = (MMI_title_y + MMI_title_height) + 1 + ((MMI_content_height - 1) >> 1) - (th >> 1);
    if (th < MMI_content_height)
    {
        rh = (MMI_content_height - th) >> 2;
    }
    else
    {
        rh = 0;
    }
    y -= rh;
    if (y < ((MMI_title_y + MMI_title_height) + 1))
    {
        y = (MMI_title_y + MMI_title_height) + 1;
    }
    category_620_message1_y = y;
    category_620_message2_y = y + h1;
    y += h1 + h2 + rh + 2;
    wgui_set_animation_image_y((UI_device_width >> 1), y, (PU8) message_icon_buffer);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory620Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *message1,
        U8 *message2,
        U8 *message_icon_buffer,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);
    
    gdi_layer_lock_frame_buffer();
    wgui_title_set_menu_shortcut_number(-1);
    
    dm_add_softkey_id(left_softkey, right_softkey);

    if (title == 0)
    {
        wgui_switch_title_with_status_bar = 1;
        ShowStatusIconsTitle();
    }
    else
    {
        MMI_title_string = get_string(title);
//huking	
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__		
        MMI_title_icon = get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
        wgui_switch_title_with_status_bar = 0;
    }

    dm_add_image((PU8) message_icon_buffer, NULL, NULL);
    dm_add_string((UI_string_type) message1, &MMI_medium_font, UI_COLOR_BLACK, UI_COLOR_BLACK, NULL);
    dm_add_string((UI_string_type) message2, &MMI_medium_font, UI_COLOR_BLACK, UI_COLOR_BLACK, NULL);

    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY620_ID, DM_CLEAR_SCREEN_BACKGROUND, UI_dummy_function);
    dm_redraw_category_screen();
}
#endif /* defined(__MMI_SMART_MESSAGE_MT__) || (defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)) */ 


/*****************************************************************************
* [Category166]
*
* This category draws a full screen animation (align at center of screen)
* Used by power on/off animation
* This screen also able to mimic a static image with animation's behavior
*
*  **********************
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  *     Animation      *
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  *                    *
*  **********************
*
*****************************************************************************/
static void (*cat166_animation_complete_callback) (GDI_RESULT result);
static PS8 cat166_animation_name;
static U16 cat166_animation_id;
static S32 cat166_image_offset_x;
static S32 cat166_image_offset_y;
static S32 cat166_image_width;
static S32 cat166_image_height;
static BOOL cat166_is_gif_anim;
static BOOL cat166_is_avatar_anim;
static U16 cat166_need_resize;
static BOOL cat166_is_invalid;
static GDI_HANDLE cat166_animation_handle = GDI_ERROR_HANDLE;


/*****************************************************************************
 * FUNCTION
 *  Cat166AnimationMimicTimer
 * DESCRIPTION
 *  Mimic animation's play complete call back function for static images
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat166AnimationMimicTimer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Mimic GDI to return last frame callback */
    if (cat166_animation_complete_callback != NULL)
    {
        if (cat166_is_invalid)
        {
            /* error file */
            cat166_animation_complete_callback(-1);
        }
        else
        {
            cat166_animation_complete_callback(GDI_GIF_LAST_FRAME);
            gui_start_timer(1000, Cat166AnimationMimicTimer);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  cat166_animation_complete_callback_failed
 * DESCRIPTION
 *  the animation of category screen no.166 is failed, inform application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void cat166_animation_complete_callback_failed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cat166_animation_complete_callback != NULL)
    {
        cat166_animation_complete_callback(-1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  cat166_animation_complete_callback_int
 * DESCRIPTION
 *  category screen no.166 default animation callback
 * PARAMETERS
 *  result      [IN]        Result of animation
 * RETURNS
 *  void
 *****************************************************************************/
static void cat166_animation_complete_callback_int(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (result < 0)
    {
        /* 
         *animation is terminated abnormally,
         * wait for a while for redraw category no.166
         * to accomplish its job 
         */
        gui_start_timer(200, cat166_animation_complete_callback_failed);
    }
    else if (result == GDI_IMAGE_IS_STILL_IMAGE)
    {
        gui_start_timer(200, Cat166AnimationMimicTimer);
    }
    else
    {
        /* 
         * animation is terminated normally,
         * execute application callback 
         */
        if (cat166_animation_complete_callback != NULL)
        {
            cat166_animation_complete_callback(result);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory166Screen
 * DESCRIPTION
 *  Redraws sategory 166 screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void RedrawCategory166Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_clear(GDI_COLOR_BLACK);
    gui_reset_clip();

    if (cat166_animation_name != NULL)
    {
        /* source from file */
        if (cat166_is_gif_anim)
        {
            /* animation, use GDI's auto play animation */
            gdi_image_set_animation_last_frame_callback(cat166_animation_complete_callback_int);
            
            /* 070406 SVG support Start */
            if (cat166_need_resize)
            {
                cat166_animation_handle = GDI_ERROR_HANDLE;
                result = gdi_image_draw_animation_resized_file(
                            cat166_image_offset_x,
                            cat166_image_offset_y,
                            cat166_image_width,
                            cat166_image_height,
                            (U8*) cat166_animation_name,
                            &cat166_animation_handle);
            }
            else
            {
                cat166_animation_handle = GDI_ERROR_HANDLE;
                result = gdi_image_draw_animation_file(
                            cat166_image_offset_x,
                            cat166_image_offset_y,
                            (U8*) cat166_animation_name,
                            &cat166_animation_handle);
            }
            /* 070406 SVG support End */

            /* if is 1 frame gif, treat as still image */
            if (result == GDI_IMAGE_IS_STILL_IMAGE)
            {
                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
        }
#ifdef __MMI_AVATAR__
        else if (cat166_is_avatar_anim == TRUE)
        {
            result = gdi_anim_draw_mem(
                        0,
                        0,
                        (PS8) cat166_animation_name,
                        GDI_IMAGE_TYPE_AVATAR,
                        0, // NO USE
                        &cat166_animation_handle);
        } 
#endif
        else
        {
            if (cat166_need_resize)
            {
                /* static image */
                result = gdi_image_draw_resized_file(
                            cat166_image_offset_x,
                            cat166_image_offset_y,
                            cat166_image_width,
                            cat166_image_height,
                            cat166_animation_name);

                if (result < 0)
                {
                    /* invalid file */
                    cat166_is_invalid = TRUE;
                }

                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
            else
            {
                /* static image */
                result = gdi_image_draw_file(cat166_image_offset_x, cat166_image_offset_y, cat166_animation_name);

                if (result < 0)
                {
                    /* invalid file */
                    cat166_is_invalid = TRUE;
                }

                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
        }
    }
    else
    {
        /* source from id */
        if (cat166_is_gif_anim)
        {
            /* animation, use GDI's auto play animation */
            gdi_image_set_animation_last_frame_callback(cat166_animation_complete_callback_int);
            cat166_animation_handle = GDI_ERROR_HANDLE;
            result = gdi_image_draw_animation(cat166_image_offset_x, cat166_image_offset_y, (U8*) GetImage(cat166_animation_id), &cat166_animation_handle); 

            /* if is 1 frame gif, treat as still image */
            if (result == GDI_IMAGE_IS_STILL_IMAGE)
            {
                gui_start_timer(200, Cat166AnimationMimicTimer);
            }
        }
        else
        {
            /* static image */
            gdi_image_draw_id(cat166_image_offset_x, cat166_image_offset_y, cat166_animation_id);
            gui_start_timer(200, Cat166AnimationMimicTimer);
        }
    }

    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate166CategoryControlArea
 * DESCRIPTION
 *  draw category 166 category control area
 * PARAMETERS
 *  coordinate      [IN]     Area to redraw     
 * RETURNS
 *  void
 *****************************************************************************/
static void DrawCate166CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    RedrawCategory166Screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory166Screen
 * DESCRIPTION
 *  Exit Category166 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory166Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* stop animtion */
    gdi_image_stop_animation_all();
    if(cat166_animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(cat166_animation_handle);
        cat166_animation_handle = GDI_ERROR_HANDLE;
    }
    gui_cancel_timer(Cat166AnimationMimicTimer);
    gui_cancel_timer(cat166_animation_complete_callback_failed);

    cat166_animation_complete_callback = NULL;
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory166Screen(U16 image_id, S8 *image_filename, void (*animation_complete_callback) (GDI_RESULT))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width = 0;
    S32 image_height = 0;
    GDI_RESULT ret;
    U16 img_type;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 
     * If image_filename != NULL, means will use image from file as first priority.
     * We will use image_id when the file is not able to play correctly. 
     */

    /* init var */
    cat166_animation_complete_callback = animation_complete_callback;

    cat166_animation_id = image_id;
    cat166_animation_name = image_filename;
    cat166_image_offset_x = 0;
    cat166_image_offset_y = 0;
    cat166_is_gif_anim = FALSE;
    cat166_need_resize = FALSE;
    cat166_is_invalid = FALSE;

#ifdef __MMI_AVATAR__
    if(PhnsetGetDisplayType(image_id) == PHNSET_TYPE_DISP_AVATAR)
    cat166_is_avatar_anim = TRUE;
    else 
    cat166_is_avatar_anim = FALSE;
#else
    cat166_is_avatar_anim = FALSE;
#endif

    /* clear all key handlers */
    clear_category_screen_key_handlers();
    clear_left_softkey();
    clear_right_softkey();

   /*** get image parameters ***/

    /* source from file */
    if (cat166_animation_name != NULL)
    {
    #ifdef __MMI_AVATAR__
        if (cat166_is_avatar_anim)
        {
            
            if (mmi_avatar_is_avatar_existed((U32)cat166_animation_name))
            ret = gdi_image_get_dimension_mem(GDI_IMAGE_TYPE_AVATAR,(U8 *)cat166_animation_name,0, &image_width, &image_height);
            else 
                ret = -1;
            if (ret >= 0)
            {
                cat166_is_gif_anim = FALSE;
                cat166_need_resize = FALSE;		
            }
        }    
        else
            ret = gdi_image_get_dimension_file(cat166_animation_name, &image_width, &image_height);
    #else
        ret = gdi_image_get_dimension_file(cat166_animation_name, &image_width, &image_height);
    #endif


        if (ret < 0)
        {
            /* set filename to NULL, will skip play this file */
            cat166_animation_name = NULL;
            gdi_layer_clear(GDI_COLOR_BLACK);
            gdi_layer_blt_base_layer(0, 0, UI_device_width - 1, UI_device_height - 1);

            if (cat166_animation_complete_callback != NULL)
            {
                cat166_animation_complete_callback(-1);
            }

            return;
        }
        else if (cat166_is_avatar_anim == FALSE)
        {
            /* check if is gif animation or not */
            switch (gdi_image_get_type_from_file(cat166_animation_name))
            {
                case GDI_IMAGE_TYPE_JPG_FILE:
                case GDI_IMAGE_TYPE_PNG_FILE: /* png resize */
                    cat166_is_gif_anim = FALSE;
                    cat166_need_resize = TRUE;
                    break;

                case GDI_IMAGE_TYPE_GIF_FILE:
                case GDI_IMAGE_TYPE_SVG_FILE: /* SVG support */
                    cat166_is_gif_anim = TRUE;
                    cat166_need_resize = TRUE; /* resize screensaver */
                    break;

                case GDI_IMAGE_TYPE_M3D_FILE:
                    cat166_is_gif_anim = TRUE;
                    cat166_need_resize = FALSE;		
                    break;

                default:
                    cat166_is_gif_anim = FALSE;
                    cat166_need_resize = FALSE;
                    break;
            }

            if (cat166_need_resize == TRUE)
            {
                if ((image_width <= UI_device_width) && (image_height <= UI_device_height))
                {
                    cat166_need_resize = FALSE;
                }
            }
        }
    }

    /* source from ID */
    if (cat166_animation_id != 0 && cat166_is_avatar_anim == FALSE)
    {
        /* we assume internal resource is always correct */
        gdi_image_get_dimension_id(cat166_animation_id, &image_width, &image_height);

        /* check if is gif animation or not */
        /* PMT DLT_FIXES_157 - TK 20060225 START */
        img_type = gdi_image_get_type_from_id(cat166_animation_id);
        
#if 0
    #ifdef __MMI_DOWNLOADABLE_THEMES_SUPPORT__
/* under construction !*/
    #else 
/* under construction !*/
    #endif 
#else
    if (img_type == IMAGE_TYPE_GIF || img_type == IMAGE_TYPE_M3D || img_type == IMAGE_TYPE_SVG)
#endif

            /* PMT DLT_FIXES_157 - TK 20060225 END */
        {
            cat166_is_gif_anim = TRUE;
        }
        else
        {
            cat166_is_gif_anim = FALSE; /* still image */
        }
    }

    /* calc image draw pos, check if need resize */
    if (cat166_need_resize)
    {

        gdi_image_util_fit_bbox(
            UI_device_width,
            UI_device_height,
            image_width,
            image_height,
            &cat166_image_offset_x,
            &cat166_image_offset_y,
            &cat166_image_width,
            &cat166_image_height);
    }
    else
    {
        cat166_image_offset_x = (UI_device_width - image_width) >> 1;
        cat166_image_offset_y = (UI_device_height - image_height) >> 1;
    }
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY166_ID, DM_NO_FLAGS, ExitCategory166Screen);
    dm_register_category_controlled_callback(DrawCate166CategoryControlArea);
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void StopCategory166Animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_stop_animation_all();
    gui_cancel_timer(Cat166AnimationMimicTimer);
}

///TODO: should be removed after app revise, (Shaoqing)
#ifdef __MMI_EM_MISC_TOUCH_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  GetCategory400History
 * DESCRIPTION
 *  Get category 400 history
 * PARAMETERS
 *  history_buffer     [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  
 *****************************************************************************/
static U8 *GetCategory400History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory400HistorySize
 * DESCRIPTION
 *  Get category 400 history size
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static S32 GetCategory400HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}

 
/* For detail description, please refer to wgui_categories.h */
void RedrawCategory400Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color cb = gui_color(0, 0, 0);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    clear_screen();
    show_title_status_icon();
    draw_title();
    gui_draw_rectangle(
        MMI_content_x,
        MMI_content_y,
        MMI_content_x + MMI_content_width - 1,
        MMI_content_y + MMI_content_height - 1,
        cb);
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory400Screen
 * DESCRIPTION
 *  Exit category 400 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory400Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory400Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    gdi_layer_lock_frame_buffer();
    clear_category_screen_key_handlers();
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    clear_left_softkey();
    clear_right_softkey();
    register_left_softkey_handler();
    register_right_softkey_handler();
    register_default_hide_softkeys();
    MMI_title_string = (UI_string_type) get_string(title);
//huking	
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    MMI_title_icon = (PU8) get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory400Screen;
    RedrawCategoryFunction = RedrawCategory400Screen;
    GetCategoryHistory = GetCategory400History;
    GetCategoryHistorySize = GetCategory400HistorySize;
    RedrawCategory400Screen();
}
#endif /*__MMI_EM_MISC_TOUCH_SCREEN__*/

#if defined (__MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_240X400__)
#define MMI_CAT401_X_OFFSET   17
#elif defined (__MMI_MAINLCD_320X240__)
#define MMI_CAT401_X_OFFSET   17
#elif defined (__MMI_MAINLCD_176X220__)
#define MMI_CAT401_X_OFFSET   14
#else
#define MMI_CAT401_X_OFFSET   10
#endif

#pragma arm section code = "PRIMARY_ROCODE", rodata = "PRIMARY_RODATA", rwdata = "PRIMARY_RW"
/*****************************************************************************
 * FUNCTION
 *  ShowCategory401Screen
 * DESCRIPTION
 *  show category 401 screen
 * PARAMETERS
 *  percentage      [IN]        Number of percentage
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory401Screen(U16 percentage)
{
#if ((defined(_NAND_FLASH_BOOTING_) || defined(__EMMC_BOOTING__)) && defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI))
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bar_width = 0, bar_height = 0;
    S32 bar_x = 0, bar_y = 0;
    S32 fill_width = 0;
    S32 str_width = 0, str_height = 0;
    S32 str_x = 0, str_y = 0;
    U8 *bar_bg_image = nfb_progress_images[0];
    U16 digit[3], idx = 0;
    S32 digit_width[3];
    S32 digit_height[3];
    static U8 isInited = 0;
    PW_CTRL_GET_POWERON_REASON CtrlVal; /*power on reason structure*/
    DCL_HANDLE handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*Get the power on reason*/
    handle = DclPW_Open(DCL_PW, FLAGS_NONE);
    DclPW_Control(NULL, PW_CMD_GET_POWERON_REASON, (DCL_CTRL_DATA_T *) &CtrlVal);
    DclPW_Close(handle);

    /* it is not necessary to display progress bar while power-on is due to abnormal reset or alarm */
    if ((CtrlVal.powerOnReason == ABNRESET) || (CtrlVal.powerOnReason == RTCPWRON))
    {
        return;
    }

    if (!isInited)
    {
        gdi_init();
    }

    gdi_layer_lock_frame_buffer();

#if defined(__COSMOS_MMI__)
    gdi_layer_clear(gdi_act_color_from_rgb(255, 45, 45, 45));
#else /*__COSMOS_MMI__*/
    gdi_layer_clear(GDI_COLOR_WHITE);
#endif /*__COSMOS_MMI__*/
    gdi_layer_push_clip();
    gdi_layer_reset_clip();

    /*the following line is for COSMOS project*/
    /* Progress bar background image */
    gdi_image_get_dimension(bar_bg_image, &bar_width, &bar_height);
#if defined(__COSMOS_MMI__)
    bar_x = (LCD_WIDTH - bar_width) >> 1;
    bar_y = (LCD_HEIGHT >> 1);
#else /*__COSMOS_MMI__*/
    bar_x = (LCD_WIDTH - bar_width - 2 /* gap */ ) >> 1;
    bar_y = (LCD_HEIGHT >> 1) - bar_height;
#endif /*__COSMOS_MMI__*/

    /* percentage images */

    /* decide which images are used */
    if (percentage == 100)
    {
        digit[2] = 1;
        digit[1] = 0;
        digit[0] = 0;
    }
    else if (percentage == 0)
    {
        digit[2] = 0;
        digit[1] = 0;
        digit[0] = 0;
    }
    else if (percentage > 0 && percentage < 100)
    {
        digit[2] = 0;
        digit[1] = percentage / 10;
        digit[0] = percentage - (digit[1] * 10);
    }
    else
    {
        MMI_ASSERT(percentage <= 100);
    }

#if !defined(__COSMOS_MMI__) || !defined(__LOW_COST_SUPPORT_COMMON__)
    /* calculate digit image width and height */
    gdi_image_get_dimension(nfb_progress_images[11], &str_width, &str_height);

    for (idx = 2; idx > 0; idx--)
    {
        if (digit[idx] != 0 || digit[2] == 1)
        {
            gdi_image_get_dimension(nfb_progress_images[digit[idx] + 1], &digit_width[idx], &digit_height[idx]);
            str_width += digit_width[idx];
            if(str_height < digit_height[idx])
            {
                str_height = digit_height[idx];
            }
        }
    }
    gdi_image_get_dimension(nfb_progress_images[digit[0] + 1], &digit_width[0], &digit_height[0]);
    if(str_height < digit_height[0])
    {
        str_height = digit_height[0];
    }

    /* decide digit images position */
#if defined(__COSMOS_MMI__)
    str_x = bar_x;
    str_y = (LCD_HEIGHT >> 1) - 6 - str_height;
#else /*__COSMOS_MMI__*/
    str_x = (LCD_WIDTH - str_width) >> 1;
    str_y = (LCD_HEIGHT >> 1) + 2;
#endif /*__COSMOS_MMI__*/

    /* show the digit images */
    for (idx = 2; idx > 0; idx--)
    {
        if (digit[idx] != 0 || digit[2] == 1)
        {
            gdi_image_draw(str_x, str_y, nfb_progress_images[digit[idx] + 1]);
            str_x += digit_width[idx];
        }
    }
    gdi_image_draw(str_x, str_y, nfb_progress_images[digit[0] + 1]);
    str_x += digit_width[0];
    gdi_image_draw(str_x, str_y, nfb_progress_images[11]);
#endif /* __LOW_COST_SUPPORT_COMMON__ */

    /* Progress bar background image */

    /* Progress bar fill area */
#if defined(__COSMOS_MMI__)
    gdi_image_draw(bar_x, bar_y, bar_bg_image);
    fill_width = ((bar_width - 2) * (S32) percentage) / 100;
#else/*__COSMOS_MMI__*/
    fill_width = ((bar_width - (MMI_CAT401_X_OFFSET << 1)) * (S32) percentage) / 100;
#endif/*__COSMOS_MMI__*/

#if defined(__COSMOS_MMI__)
    gdi_layer_set_clip(bar_x + 1, bar_y + 1, bar_x + fill_width, bar_y + bar_height);
#ifndef __LOW_COST_SUPPORT_COMMON__
    gdi_image_draw(bar_x + 1, bar_y + 1, nfb_progress_images[12]);
#else
    if (nfb_progress_images[1] != NULL)
    {
        gdi_image_draw(bar_x + 1, bar_y + 1, nfb_progress_images[1]);
    }
#endif
#else /*__COSMOS_MMI__*/
    gdi_layer_set_clip(bar_x, bar_y, bar_x + bar_width - 1, bar_y + bar_height - 1);

    /* Progress bar fill area */
    gdi_draw_solid_rect(
        bar_x + MMI_CAT401_X_OFFSET,
        bar_y,
        bar_x + MMI_CAT401_X_OFFSET + fill_width - 1,
        bar_y + bar_height - 1,
        GDI_COLOR_RED);

    gdi_image_draw(bar_x, bar_y, bar_bg_image);
#endif/*__COSMOS_MMI__*/

    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);

    if (!isInited)
    {
        isInited = 1;
        custom_uem_gpio_set_level(GPIO_DEV_LED_MAINLCD, 5);
    }
#endif /* (((defined(_NAND_FLASH_BOOTING_) || defined(__EMMC_BOOTING__)) && defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && !defined(__L1_STANDALONE__) && !defined(EMPTY_MMI)) */ 
}
#pragma arm section code, rodata, rwdata

//#if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__)
#if defined(__MMI_MAINLCD_176X220__)
#define WGUI_CAT412_PROG_BAR_W       (166)
#elif defined(__MMI_MAINLCD_240X320__)
#define WGUI_CAT412_PROG_BAR_W       (230)
#elif defined(__MMI_MAINLCD_240X400__)
#define WGUI_CAT412_PROG_BAR_W       (230)
#elif defined(__MMI_MAINLCD_320X480__)
#define WGUI_CAT412_PROG_BAR_W       (300)
#elif defined(__MMI_MAINLCD_320X240__)
#define WGUI_CAT412_PROG_BAR_W       (300)
#else
#define WGUI_CAT412_PROG_BAR_W       (120)
#endif /* __MMI_MAINLCD_176X220__ */
//#endif /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__) */

static UI_string_type cat412_display_str = NULL;
static U8 cat412_percentage_value = 0;
static S32 cat412_number_of_items = 0;
static UI_string_type *cat412_list_of_items = NULL;

#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
static MMI_BOOL g_cat412_MBBMS_style = MMI_FALSE;
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */

/*****************************************************************************
 * FUNCTION
 *  ExitCategory412Screen
 * DESCRIPTION
 *  Exit the category412 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExitCategory412Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
    g_cat412_MBBMS_style = MMI_FALSE;
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */
}


/*****************************************************************************
 * FUNCTION
 *  Cat412DrawCantent
 * DESCRIPTION
 *  This function will draw the displayed string, percentage value,
 *  progressive bar, and detail information of category 412 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat412DrawCantent(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h, perc_w, str_w, str_h, img_w, img_h, rect_x, rect_y, rect_w, rect_h, i;
    UI_character_type str_buf[5];
    S32 text_offset = 5;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(str_buf, 0, 5 * sizeof(UI_character_type));

    gdi_layer_lock_frame_buffer();
    /* set font */
    gui_set_font(&MMI_medium_font);
    gui_set_text_color(*current_MMI_theme->list_normal_text_color);

    /* compute percentage value width */
    {
        U16 temp[] = L"0123456789";
        S32 w, h, pw, w2, w3;

        pw = gui_get_string_width(L"%");
        mmi_fe_measure_string_by_char_num((U8*)temp, 2 /* 99% */, &w2, &h);
        w3 = gui_get_string_width(L"100");
        w = 5 /* gap */ + pw + ((w2 > w3) ? (w2) : (w3));
        perc_w = w;
    }

    gui_push_clip();
    gui_push_text_clip();
    gui_reset_clip();

    /* clear background */
    rect_x = x = MMI_content_x;
    rect_w = w = MMI_content_width;
#if defined(__MMI_SCREEN_ROTATE__)
    if (mmi_frm_is_screen_width_height_swapped())
    {
        rect_y = y = MMI_content_y;
        rect_h = h = MMI_content_height;
    }
    else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    {
#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
        if(g_cat412_MBBMS_style)
        {
            //rect_y = y = MMI_content_y + ((MMI_content_height<<1)/3);
            //rect_h = h = MMI_content_height - ((MMI_content_height<<1)/3);
            rect_y = y = MMI_content_y + (MMI_COMMON_CONTENT_HEIGHT - WGUI_CAT1040_MULTILINE_H - MMI_MENUITEM_HEIGHT);
            rect_h = h = MMI_content_height - (MMI_COMMON_CONTENT_HEIGHT - WGUI_CAT1040_MULTILINE_H - MMI_MENUITEM_HEIGHT);
        }
        else
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */
        {
            #ifdef __MMI_MAINLCD_128X160__
			rect_y = y = MMI_content_y + MMI_MENUITEM_HEIGHT;
            rect_h = h = MMI_content_height - MMI_MENUITEM_HEIGHT;
            #else
			rect_y = y = MMI_content_y + MMI_MENUITEM_HEIGHT * 2;
            rect_h = h = MMI_content_height - MMI_MENUITEM_HEIGHT * 2;
            #endif
        }
    }

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
#ifdef __MMI_IMAGE_CACHE_FOR_ONE_GDI_LAYER__
    gui_one_layer_draw_filled_bg_area(x, y, x + w - 1, y + h - 1);
#else
    gdi_draw_solid_rect(x, y, x + w - 1, y + h - 1, GDI_COLOR_TRANSPARENT);
#endif
    gdi_layer_pop_clip();

    /* draw filename */
    //x = (r2lMMIFlag) ? (rect_x + rect_w - 1 - text_offset) : (rect_x + text_offset);
    if(mmi_fe_get_r2l_state())
    {
        x = rect_x + rect_w - 1 - text_offset;
    }
    else
    {
        x = rect_x + text_offset;
    }
    y = rect_y;
#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
    if(g_cat412_MBBMS_style)
    {
        S32 resized_w, resized_h, buffer_length;
        
        w = rect_w - (text_offset<<1) /* gap */;
        h = WGUI_CAT1040_MULTILINE_H;
        buffer_length = gui_strlen((UI_string_type) cat412_display_str);
        wgui_inputs_ml_create_set_buffer((UI_string_type) cat412_display_str, buffer_length, buffer_length, 0);
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
        MMI_multiline_inputbox.text_font = &MMI_small_font;
#endif
        MMI_multiline_inputbox.flags = UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
        #ifdef __MMI_WALLPAPER_ON_BOTTOM__ 
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_TRANSPARENT_BACKGROUND;
        #endif
        #ifdef __MMI_FTE_SUPPORT__
        gui_inputs_set_transparent_background(MMI_TRUE);
        #endif /* __MMI_FTE_SUPPORT */
        wgui_inputs_ml_set_text_color(*current_MMI_theme->list_normal_text_color);
        wgui_inputs_ml_resize_fit(w, h, &resized_w, &resized_h);
        MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_ONLY_VISIBLE_LINE;
        if (resized_h > WGUI_CAT1040_MULTILINE_H)
        {
            resized_h = WGUI_CAT1040_MULTILINE_H;
        }
        wgui_inputs_ml_move(x, y + ((WGUI_CAT1040_MULTILINE_H - resized_h) >> 1));
        wgui_inputs_ml_show();
    }
    else
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */
    {
        w = rect_w - perc_w - text_offset * 3 /* gap */;
        h = MMI_MENUITEM_HEIGHT;

        gui_measure_string(cat412_display_str, &str_w, &str_h);
        y += (h - str_h);       /* align bottom */
        gui_print_truncated_text(x, y, w, cat412_display_str);
    }

    /* draw percentage value */
    //x = (r2lMMIFlag) ? (rect_x + text_offset) : (rect_x + rect_w - text_offset);
    if(mmi_fe_get_r2l_state())
    {
        x = rect_x + text_offset;
    }
    else
    {
        x = rect_x + rect_w - text_offset;
    }
    y = rect_y;
    w = perc_w;
    h = MMI_MENUITEM_HEIGHT;

    if (cat412_percentage_value == 0xFF)
    {
        mmi_ucs2cat((S8*)&str_buf, (S8*)L"--%");
    }
    else
    {
        gui_itoa((S32)cat412_percentage_value, str_buf, 10);
        mmi_ucs2cat((S8*)&str_buf, (S8*)L"%");
    }

    gui_measure_string(str_buf, &str_w, &str_h);
    //x += (r2lMMIFlag) ? (str_w) : (0);
    //x -= (r2lMMIFlag) ? (0) : (str_w);
    if(mmi_fe_get_r2l_state())
    {
        x += str_w;
    }
    else
    {
        x -= str_w;
    }
    y += (h - str_h);       /* align bottom */

#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
    if(g_cat412_MBBMS_style)
    {
         /*do nothing, do not show percentage value*/
    }
    else
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */
    {
        gui_move_text_cursor(x, y);
        gui_print_text(str_buf);
    }

    /* draw progressive bar */
#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
    if(g_cat412_MBBMS_style)
    {
         y = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height;
    }
    else
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */
    {
        y = rect_y + MMI_MENUITEM_HEIGHT;
    }
    x = rect_x;
    w = rect_w;
    h = MMI_MENUITEM_HEIGHT;

    gdi_image_get_dimension((U8*)GetImage(IMG_CAT412_PROG_BAR_BG), &img_w, &img_h);
//#if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__)
    img_w = WGUI_CAT412_PROG_BAR_W;
//#endif /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__) */
    x += (w - img_w) >> 1;
    y += (h - img_h) >> 1;

    gdi_layer_push_clip();

    gdi_layer_set_clip(x, y, x + img_w - 1, y + img_h - 1);
//#if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__)
    gdi_image_draw_resized_id(x, y, img_w, img_h, IMG_CAT412_PROG_BAR_BG);
//#else /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__) */
//    gdi_image_draw(x, y, (U8*)GetImage(IMG_CAT412_PROG_BAR_BG));
//#endif /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__) */

    if(cat412_percentage_value == 0)
        gdi_layer_set_clip(0, 0, 0, 0);
    else
        gdi_layer_set_clip(x, y, x + (img_w * cat412_percentage_value / 100) - 1, y + img_h - 1);

//#if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__)
    gdi_image_draw_resized_id(x, y, img_w, img_h, IMG_CAT412_PROG_BAR_FULL);
//#else /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__) */
//    gdi_image_draw(x, y, (U8*)GetImage(IMG_CAT412_PROG_BAR_FULL));
//#endif /* #if defined(__MMI_SLIM_IMG_RES__) || defined(__MMI_FTE_SUPPORT__) || defined(__MMI_BASIC_UI_STYLE__) */

    gdi_layer_pop_clip();

    /* draw detail info */
    //x = (r2lMMIFlag) ? (rect_x + rect_w - text_offset) : (rect_x + text_offset);
    if(mmi_fe_get_r2l_state())
    {
        x = rect_x + rect_w - text_offset;
    }
    else
    {
        x = rect_x + text_offset;
    }
    y = rect_y + MMI_MENUITEM_HEIGHT * 2;
    w = rect_w - (text_offset << 1);
    h = rect_h - MMI_MENUITEM_HEIGHT * 2;

    for (i = 0 ; i < cat412_number_of_items ; i++)
    {
        S32 str_w, str_h;
        gui_measure_string(cat412_list_of_items[i], &str_w, &str_h);

        if ((y + (str_h + 5)) > (rect_y + rect_h))
        {
            break;
        }

        gui_print_truncated_text(x, y, w, cat412_list_of_items[i]);
        
        y += (str_h + 5);
    }

    gui_pop_text_clip();
    gui_pop_clip();

    gdi_layer_unlock_frame_buffer();

    gdi_layer_blt_previous(x, y, w - 1, h - 1);
}


/*****************************************************************************
 * FUNCTION
 *  Cat412DrawControlAred
 * DESCRIPTION
 *  Draw Cat412 control area,
 *  including displayed_string, percentage_value, and progressive bar
 * PARAMETERS
 *  coordinate          [IN]    useless, we have pre-defined area
 * RETURNS
 *  void
 *****************************************************************************/
void Cat412DrawControlAred(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    UI_UNUSED_PARAMETER(coordinate);
    Cat412DrawCantent();
}


/* For detail description, please refer to wgui_categories.h */
void Cat412UpdateList(
        UI_string_type display_str,
        U8 percentage_value,
        S32 number_of_items,
        UI_string_type *list_of_items)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
	
    cat412_display_str = display_str;
    cat412_percentage_value = percentage_value;
    cat412_number_of_items = number_of_items;
    cat412_list_of_items = list_of_items;
    wgui_inputs_ml_reset();
    Cat412DrawCantent();

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory412Screen(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        PU8 progress_image,
        UI_string_type display_str,
        U8 percentage_value,
        S32 number_of_items,
        UI_string_type *list_of_items,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 catID = MMI_CATEGORY412_ID;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_ROTATE__)
    if (!mmi_frm_is_screen_width_height_swapped())
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    {
        gui_setup_common_layout();
    }

    gdi_layer_lock_frame_buffer();
    
#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
    if(g_cat412_MBBMS_style)
    {
        catID = MMI_CAT1040_ID;
    }
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */

    /* set title */
    dm_add_title(title, title_icon);
    
    /* set softkey */
    dm_add_softkey_str(left_softkey, right_softkey);

    /* set image */
#if defined(__MMI_SCREEN_ROTATE__)
    if (!mmi_frm_is_screen_width_height_swapped())
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    {
        if (progress_image != NULL)
        {
            dm_add_image(progress_image, NULL, NULL);
        }
    }

    /* set information */
    cat412_display_str = display_str;
    cat412_percentage_value = percentage_value;
    cat412_number_of_items = number_of_items;
    cat412_list_of_items = list_of_items;

    gdi_layer_unlock_frame_buffer();

    /* Setup category/draw manager data */
    wgui_cat_setup_category_default_history(catID, DM_CLEAR_SCREEN_BACKGROUND, ExitCategory412Screen);
    dm_register_category_controlled_callback(Cat412DrawControlAred);
    dm_redraw_category_screen();
}


#if defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)
void wgui_cat1040_show(
        UI_string_type title,
        PU8 title_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        PU8 progress_image,
        UI_string_type display_str,
        U8 percentage_value,
        S32 number_of_items,
        UI_string_type *list_of_items,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_cat412_MBBMS_style = MMI_TRUE;
	
    ShowCategory412Screen(
        title,
        title_icon,
        left_softkey,
        left_softkey_icon,
        right_softkey,
        right_softkey_icon,
        progress_image,
        display_str,
        percentage_value,
        number_of_items,
        list_of_items,
        history_buffer);
}
#endif /* defined(__MMI_ATV_SUPPORT__) || defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) */


U16 Cat402PercentageBarId = 0;
/*****************************************************************************
 * FUNCTION
 *  Cat402ScrolTextBg
 * DESCRIPTION
 *  scrol text background
 * PARAMETERS
 *  x1      [IN]        Start x
 *  y1      [IN]        Start y
 *  x2      [IN]        End x
 *  y2      [IN]        End y
 * RETURNS
 *  void
 *****************************************************************************/
static void Cat402ScrolTextBg(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_WHITE);
}



/* For detail description, please refer to wgui_categories.h */
void ShowCategory402Screen(
    U8 *title,
    U16 title_icon,
    U16 left_softkey,
    U16 left_softkey_icon,
    U16 right_softkey,
    U16 right_softkey_icon,
    U8 *string,
    U16 percentage,
    U8 *progress_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color text_color = gui_color(0, 0, 0);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    
    dm_add_title((UI_string_type) title, get_image(title_icon));
    wgui_title_set_menu_shortcut_number(-1);
    
    dm_add_softkey_id(left_softkey, right_softkey);

    dm_add_scroll_text((UI_string_type) string, NULL, Cat402ScrolTextBg, text_color, text_color);
    
#ifdef __DM_PROGRESS_BAR_9_SLICE_BG_IMAGE__
            Cat402PercentageBarId = dm_add_percentage_bar(
                                        percentage,
                                        progress_string,
                                        UI_COLOR_RED,
                                        IMG_PERCENTAGE_BAR_BG_IMAGE);
#else
    Cat402PercentageBarId = dm_add_percentage_bar(
                                percentage,
                                progress_string,
                                UI_COLOR_RED,
                                IMG_PERCENTAGE_BAR_BG_IMAGE,
                                IMG_PERCENTAGE_BAR_LEFT_IMAGE,
                                IMG_PERCENTAGE_BAR_RIGHT_IMAGE);
#endif

    gdi_layer_unlock_frame_buffer();

#ifdef __MMI_MAINLCD_128X64__
    wgui_cat_setup_category_default_history(MMI_CATEGORY402_ID, DM_CLEAR_SCREEN_BACKGROUND_COLOR | DM_NO_TITLE | DM_NO_STATUS_BAR, UI_dummy_function);
#else
    wgui_cat_setup_category_default_history(MMI_CATEGORY402_ID, DM_CLEAR_SCREEN_BACKGROUND_COLOR, UI_dummy_function);
#endif
    dm_redraw_category_screen();
}


/* For detail description, please refer to wgui_categories.h */
void UpdateCategory402Value(U16 value, U8 *string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_update_percentage_bar_value(Cat402PercentageBarId, value, string);
    dm_redraw_percentage_bar(Cat402PercentageBarId);
}


#if defined(__MMI_BROWSER_2__)// || defined(__MMI_GADGET_SUPPORT__)
static GDI_HANDLE mmi_cat431_title_handle = 0;
static GDI_HANDLE mmi_cat431_bottom_handle = 0;
#ifdef __MMI_TOUCH_SCREEN__
static cat431_pen_handler mmi_cat431_pen_event_handler = NULL;
static MMI_BOOL cat431_is_fullscreen = MMI_FALSE;
#endif /* __MMI_TOUCH_SCREEN__ */


/* For detail description, please refer to wgui_categories.h */
void Cat431GetScreenInfo(MMI_BOOL isFullScreen, U32 *x, U32 *y, U32 *w, U32 *h, GDI_HANDLE *title_layer, GDI_HANDLE *bottom_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!isFullScreen)
    {
#if defined(__MMI_SCREEN_ROTATE__)
        if(mmi_frm_is_screen_width_height_swapped())
        {
            *x = CAT431_ROTATE_X;
            *y = CAT431_ROTATE_Y;
            *w = CAT431_ROTATE_W;
            *h = CAT431_ROTATE_H;
        }
        else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        {
            *x = CAT431_X;
            *y = CAT431_Y;
            *w = CAT431_W;
            *h = CAT431_H;
        }
    }
    else
    {
#if defined(__MMI_SCREEN_ROTATE__)
        if(mmi_frm_is_screen_width_height_swapped())
        {
            *x = CAT431_ROTATE_FULLSCREEN_X;
            *y = CAT431_ROTATE_FULLSCREEN_Y;
            *w = CAT431_ROTATE_FULLSCREEN_W;
            *h = CAT431_ROTATE_FULLSCREEN_H;
        }
        else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        {
            *x = CAT431_FULLSCREEN_X;
            *y = CAT431_FULLSCREEN_Y;
            *w = CAT431_FULLSCREEN_W;
            *h = CAT431_FULLSCREEN_H;
        }
    }

#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
#if defined(__MMI_SCREEN_ROTATE__)
    if (!mmi_frm_is_screen_width_height_swapped() && wgui_icon_bar_is_created())
    {
        *h -= MMI_ICON_BAR_HEIGHT;
    }
#else /* __MMI_SCREEN_ROTATE__ */
    if (wgui_icon_bar_is_created())
    {
        *h -= MMI_ICON_BAR_HEIGHT;
    }
#endif/* __MMI_SCREEN_ROTATE__ */
#endif /* defined(__MMI_FTE_SUPPORT__) &&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__) */

    *title_layer = mmi_cat431_title_handle;
    *bottom_layer = mmi_cat431_bottom_handle;
}


#ifdef __MMI_TOUCH_SCREEN__
static MMI_BOOL g_wgui_cat431_is_pen_down = MMI_FALSE;
#if defined(__MMI_FTE_SUPPORT__)
static MMI_BOOL g_wgui_cat431_is_pen_down_toolbar = MMI_FALSE;
#endif /* defined(__MMI_FTE_SUPPORT__) */
/*****************************************************************************
 * FUNCTION
 *  Cat431CheckPenEvent
 * DESCRIPTION
 *  Check whether the pen event is available
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL Cat431CheckPenEvent(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 x, y, w, h;
	GDI_HANDLE dummy_layer1, dummy_layer2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    Cat431GetScreenInfo(cat431_is_fullscreen, (U32*)&x, (U32*)&y, (U32*)&w, (U32*)&h, &dummy_layer1, &dummy_layer2);

    if ((point.x < x) || (point.y < y) || (point.x >= x + w) || (point.y >= y + h))
    {
        return MMI_FALSE;
    }
	else
	{
	    return MMI_TRUE;
	}
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenDownHandler
 * DESCRIPTION
 *  Pen down events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenDownHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (cat431_is_fullscreen &&
#if defined(__MMI_SCREEN_ROTATE__)
        !mmi_frm_is_screen_width_height_swapped() &&
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        wgui_icon_bar_is_created())
    {
        if ((point.y >= UI_device_height - MMI_ICON_BAR_HEIGHT) && (point.y < UI_device_height))
        {
            MMI_BOOL ret = wgui_icon_bar_translate_pen_event(point, MMI_PEN_EVENT_DOWN);
            if (ret)
            {
                g_wgui_cat431_is_pen_down_toolbar = MMI_TRUE;
                return MMI_TRUE;
            }
        }
    }
#endif /* defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__) */

    if (Cat431CheckPenEvent(point) && mmi_cat431_pen_event_handler != NULL)
    {
        MMI_BOOL ret = mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_DOWN);

        g_wgui_cat431_is_pen_down = (ret) ? (MMI_TRUE) : (MMI_FALSE);
        return ret;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenUpHandler
 * DESCRIPTION
 *  Pen up events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenUpHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (g_wgui_cat431_is_pen_down_toolbar == MMI_TRUE)
    {
        wgui_icon_bar_translate_pen_event(point, MMI_PEN_EVENT_UP);
        g_wgui_cat431_is_pen_down_toolbar = MMI_FALSE;
        return MMI_TRUE;
    }
#endif /* defined(__MMI_FTE_SUPPORT__) &&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)*/

    if (g_wgui_cat431_is_pen_down && mmi_cat431_pen_event_handler != NULL)
    {
        mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_UP);
        g_wgui_cat431_is_pen_down = MMI_FALSE;
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenLongTapHandler
 * DESCRIPTION
 *  Pen long-tap events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenLongTapHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (g_wgui_cat431_is_pen_down_toolbar == MMI_TRUE)
    {
        wgui_icon_bar_translate_pen_event(point, MMI_PEN_EVENT_LONG_TAP);
        return MMI_TRUE;
    }
#endif /* defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__) */

    if (g_wgui_cat431_is_pen_down && mmi_cat431_pen_event_handler != NULL)
    {
        mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_LONG_TAP);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenRepeatHandler
 * DESCRIPTION
 *  Pen repeat events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenRepeatHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (g_wgui_cat431_is_pen_down_toolbar == MMI_TRUE)
    {
        wgui_icon_bar_translate_pen_event(point, MMI_PEN_EVENT_REPEAT);
        return MMI_TRUE;
    }
#endif /* defined(__MMI_FTE_SUPPORT__) &&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)*/
    
    if (g_wgui_cat431_is_pen_down && mmi_cat431_pen_event_handler != NULL)
    {
        mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_REPEAT);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenMoveHandler
 * DESCRIPTION
 *  Pen move events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenMoveHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (g_wgui_cat431_is_pen_down_toolbar == MMI_TRUE)
    {
        wgui_icon_bar_translate_pen_event(point, MMI_PEN_EVENT_MOVE);
        return MMI_TRUE;
    }
#endif /* defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__) */

    if (g_wgui_cat431_is_pen_down && mmi_cat431_pen_event_handler != NULL)
    {
        mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_MOVE);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  Cat431ControlAreaPenAbortHandler
 * DESCRIPTION
 *  Pen abort events handler function for category431 control area.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenAbortHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (g_wgui_cat431_is_pen_down_toolbar == MMI_TRUE)
    {
        wgui_icon_bar_translate_pen_event(point, MMI_PEN_EVENT_ABORT);
        return MMI_TRUE;
    }
#endif /* defined(__MMI_FTE_SUPPORT__) &&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)*/

    if (g_wgui_cat431_is_pen_down && mmi_cat431_pen_event_handler != NULL)
    {
        mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_ABORT);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 * Cat431ControlAreaPenDoubleClickHandler 
 * DESCRIPTION
 *  Pen double-click events handler function for category431 control area.
 *  TODO: this function should be triggered from WGUI instead of MMI framework directly.
 * PARAMETERS
 *  point                       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL Cat431ControlAreaPenDoubleClickHandler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (Cat431CheckPenEvent(point) == MMI_FALSE)
    {
        return MMI_FALSE;
    }
    
    if (mmi_cat431_pen_event_handler != NULL)
    {
        return mmi_cat431_pen_event_handler(point, MMI_PEN_EVENT_DOUBLE_CLICK);
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


#define WGUI_CAT431_PROGRESS_BAR_BG_COLOR       gui_color(135, 135, 135)
#define WGUI_CAT431_PROGRESS_BAR_BORDER_COLOR   gui_color(255, 255, 255)
#define WGUI_CAT431_PROGRESS_BAR_BAR_COLOR      gui_color(253, 143, 0)
#define WGUI_CAT431_PROGRESS_BAR_TEXT_COLOR     gui_color(255, 255, 255)

/* For detail description, please refer to wgui_categories.h */
void wgui_cat431_display_progressive_bar(S32 percentage, S8* display_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, str_w, str_h, bar_x1, bar_y1, bar_x2, bar_y2, adjusted_string_width;
    UI_font_type font;
    UI_character_type str_buf[5] = {0};
    UI_string_type str_buf_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_dm_data.s32CatId != MMI_CATEGORY431_ID) &&
#if defined(__MMI_SCREEN_ROTATE__)
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_ID) &&
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_FULL_ID) &&
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        (g_dm_data.s32CatId != MMI_CATEGORY431_FULL_ID))
    {
        return;
    }

    gdi_layer_lock_frame_buffer();

#if defined(MMI_SHOW_STATUS_ICON_IN_TITLE)
    if (g_dm_data.s32CatId == MMI_CATEGORY431_ID)
    {
        wgui_status_icon_bar_enable_integrated(MMI_FALSE);
        wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    }
    else
#endif /* defined(MMI_SHOW_STATUS_ICON_IN_TITLE) */
    {
        x1 = MMI_title_x;
        y1 = MMI_title_y;
        x2 = MMI_title_x + MMI_title_width - 1;
        y2 = MMI_title_y + MMI_title_height - 1;
    }
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    wgui_stop_title_animation();
#endif
    font = &MMI_medium_font;

    /* set string */
    gui_set_font(font);
    gui_set_text_color(WGUI_CAT431_PROGRESS_BAR_TEXT_COLOR);
    gui_itoa(percentage, (UI_string_type)&str_buf, 10);
    mmi_ucs2cat((S8*)&str_buf, (S8*)L"%");
    str_buf_p = (display_string) ? ((UI_string_type)display_string) : ((UI_string_type)str_buf);
    gui_measure_string((UI_string_type)str_buf_p, &str_w, &str_h);

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

    /* clear background */
    gui_fill_rectangle(x1, y1, x2, y2, WGUI_CAT431_PROGRESS_BAR_BG_COLOR);

    /* calculate bar position */
    {
        /* string upper gap: 3, string lower gap: 2 */
        S32 gap = ((str_h + 5) < (y2 - y1 + 1)) ? (((y2 - y1 + 1) - (str_h + 5)) >> 1) : (0);

        bar_x1 = x1 + gap;
        bar_y1 = y1 + gap;
        bar_x2 = x2 - gap;
        bar_y2 = y2 - gap;
    }

    /* draw percentage */
    {
        S32 w = (bar_x2 - bar_x1 + 1) * percentage / 100;

        gui_fill_rectangle(bar_x1, bar_y1, bar_x1 + w - 1, bar_y2, WGUI_CAT431_PROGRESS_BAR_BAR_COLOR);
    }

    /* draw rect */
    gui_draw_rectangle(bar_x1, bar_y1, bar_x2, bar_y2, WGUI_CAT431_PROGRESS_BAR_BORDER_COLOR);

    /* show string */
    {
        S32 str_x, str_y = bar_y1 + 3;

	adjusted_string_width = (bar_x2 - bar_x1 + 1) - 6;

	if(str_w > adjusted_string_width)
	{	
	    str_x = bar_x1 + (((bar_x2 - bar_x1 + 1) - adjusted_string_width) >> 1);
            //str_x += (r2lMMIFlag) ? (adjusted_string_width - 1) : (0);
            if(mmi_fe_get_r2l_state())
            {
                str_x += adjusted_string_width - 1;
            }
	    gui_print_truncated_text(str_x, str_y, adjusted_string_width, str_buf_p);
	}
	else
	{
             str_x = bar_x1 + (((bar_x2 - bar_x1 + 1) - str_w) >> 1);
            //str_x += (r2lMMIFlag) ? (str_w - 1) : (0);
            if(mmi_fe_get_r2l_state())
            {
                str_x += str_w - 1;
            }
            gui_move_text_cursor(str_x, str_y);
            gui_print_text(str_buf_p);
        }
    }

    gdi_layer_pop_clip();

    gdi_layer_unlock_frame_buffer();
    //gdi_lcd_repaint_all();
    gdi_layer_blt_previous(x1, y1, x2, y2);
}


/* For detail description, please refer to wgui_categories.h */
void wgui_cat431_disable_progressive_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_dm_data.s32CatId != MMI_CATEGORY431_ID) &&
#if defined(__MMI_SCREEN_ROTATE__)
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_ID) &&
        (g_dm_data.s32CatId != MMI_CATEGORY431_ROTATE_FULL_ID) &&
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        (g_dm_data.s32CatId != MMI_CATEGORY431_FULL_ID))
    {
        return;
    }

    gdi_layer_lock_frame_buffer();

#if defined(MMI_SHOW_STATUS_ICON_IN_TITLE)
    if (g_dm_data.s32CatId == MMI_CATEGORY431_ID)
    {
        wgui_status_icon_bar_enable_integrated(MMI_TRUE);
    }
#endif /* defined(MMI_SHOW_STATUS_ICON_IN_TITLE) */
    draw_title();

    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


#if defined(__MMI_SCREEN_ROTATE__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_lsk_cb
 * DESCRIPTION
 *  hide LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_lsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = MMI_softkeys[MMI_LEFT_SOFTKEY].x;
    y = MMI_softkeys[MMI_LEFT_SOFTKEY].y;
    w = MMI_softkeys[MMI_LEFT_SOFTKEY].width;
    h = MMI_softkeys[MMI_LEFT_SOFTKEY].height;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_image_draw_id(0, y, IMG_SCREEN_ROTATE_BOTTOM_BG);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_rsk_cb
 * DESCRIPTION
 *  hide LSK
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_rsk_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x = MMI_softkeys[MMI_RIGHT_SOFTKEY].x;
    y = MMI_softkeys[MMI_RIGHT_SOFTKEY].y;
    w = MMI_softkeys[MMI_RIGHT_SOFTKEY].width;
    h = MMI_softkeys[MMI_RIGHT_SOFTKEY].height;

    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_image_draw_id(0, y, IMG_SCREEN_ROTATE_TOP_BG);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_title_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  x   [IN]
 *  y   [IN]
 *  w   [IN]
 *  h   [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_title_cb(S32 x, S32 y, S32 w, S32 h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x, y, x + w - 1, y + h - 1);
    gdi_image_draw_id(0, y, IMG_SCREEN_ROTATE_TOP_BG);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_hide_status_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  x   [IN]
 *  y   [IN]
 *  w   [IN]
 *  h   [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_hide_status_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gdi_image_draw_id(0, y1, IMG_SCREEN_ROTATE_BOTTOM_BG);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_ctrl_area2_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  coordinate  [IN]    unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_ctrl_area2_cb(dm_coordinates* coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat431_hide_lsk_cb();
    wgui_cat431_hide_rsk_cb();

    show_softkey(MMI_LEFT_SOFTKEY);
    show_softkey(MMI_RIGHT_SOFTKEY);
}
#endif /* defined(__MMI_SCREEN_ROTATE__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat431_ctrl_area_cb
 * DESCRIPTION
 *  hide title
 * PARAMETERS
 *  coordinate  [IN]    unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat431_ctrl_area_cb(dm_coordinates* coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
    if (cat431_is_fullscreen &&
#if defined(__MMI_SCREEN_ROTATE__)
        !mmi_frm_is_screen_width_height_swapped() &&
#endif /* defined(__MMI_SCREEN_ROTATE__) */
        wgui_icon_bar_is_created())
    {
        wgui_icon_bar_move(0, UI_device_height - MMI_ICON_BAR_HEIGHT);
        wgui_icon_bar_resize(UI_device_width, MMI_ICON_BAR_HEIGHT);
        wgui_icon_bar_show();
    }
#endif /* defined(__MMI_FTE_SUPPORT__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__) */
}


/* For detail description, please refer to wgui_categories.h */
void ShowCategory431Screen(
        U8* title,
        U16 title_icon1,
        U16 title_icon2,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        cat431_pen_handler pen_handler,
        MMI_BOOL isFullScreen,
        S32 percentage,
        S8* display_string,
        U8* history_buffer)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set full screen */
#ifdef __MMI_TOUCH_SCREEN__
    cat431_is_fullscreen = isFullScreen;
#endif /* __MMI_TOUCH_SCREEN__ */

    /* lock GDI frame buffer */
    gdi_layer_lock_frame_buffer();

    /* do not show shortcut */
    wgui_title_set_menu_shortcut_number(-1);

    if(!isFullScreen)
    {  
        /* change soft keys' label & icon */
        change_left_softkey(left_softkey, left_softkey_icon);
        change_right_softkey(right_softkey, right_softkey_icon);
    }
    else
    {
        DisableLeftSoftkey(STRING_ID_NULL, IMAGE_ID_NULL);
        DisableRightSoftkey(STRING_ID_NULL, IMAGE_ID_NULL);
        disable_softkey_background();

#if defined(MMI_SHOW_STATUS_ICON_IN_TITLE)
        /* Because status icon is default enabled in integrated title,
           disable it manually. */
        wgui_status_icon_bar_enable_integrated(MMI_FALSE);
#endif /* defined(MMI_SHOW_STATUS_ICON_IN_TITLE) */
    }
    
    /* clear soft keys' handle function */
    SetupCategoryKeyHandlers();

    /* set title */
    wgui_title_change(title_icon1, title_icon2, title, WGUI_TITLE_CHANGE_ICON | WGUI_TITLE_CHANGE_ICON2 | WGUI_TITLE_CHANGE_TEXT);

    /* set flags */
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
#if defined(__MMI_SCREEN_ROTATE__)
    dm_data.s32flags |= (mmi_frm_is_screen_width_height_swapped()) ? (DM_LEFT_ALIGN_TITLE | DM_SPECIFIC_HIDE_STATUS_BAR) : (0);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    dm_data.s32flags |= (percentage >= 0) ? (DM_NO_BLT) : (0);

    /* un-lock GDI frame buffer */
    gdi_layer_unlock_frame_buffer();

    /* set exit category screen function */
    ExitCategoryFunction = ExitCategory431Screen;

    /* register control area callback */
    dm_register_category_controlled_callback(wgui_cat431_ctrl_area_cb);

#if defined(__MMI_SCREEN_ROTATE__)
    /* set status icon bar */
    if(mmi_frm_is_screen_width_height_swapped())
    {
        /* title */
        wgui_title_register_hide_callback(wgui_cat431_hide_title_cb);

        if (!isFullScreen)
        {
            /* statuc icon */
            wgui_status_icon_bar_move(
                WGUI_STATUS_ICON_BAR_H_BAR,
                CAT431_ROTATE_X, 
                CAT431_ROTATE_Y);
            wgui_status_icon_bar_resize(
                WGUI_STATUS_ICON_BAR_H_BAR,
                CAT431_ROTATE_W - MMI_ROTATED_SOFTKEY_WIDTH,
                MMI_ROTATED_LCD_HEIGHT - CAT431_ROTATE_Y - CAT431_ROTATE_H);
            wgui_status_icon_bar_set_rotate_for_wap();
            wgui_status_icon_bar_register_hide_callback(
                WGUI_STATUS_ICON_BAR_H_BAR,
                wgui_cat431_hide_status_cb);

            /* softkey */
            register_hide_softkey(wgui_cat431_hide_lsk_cb, MMI_LEFT_SOFTKEY);
            register_hide_softkey(wgui_cat431_hide_rsk_cb, MMI_RIGHT_SOFTKEY);

            /* hook: force to redraw the softkey background */
            dm_register_category_controlled2_callback(wgui_cat431_ctrl_area2_cb);
        }
    }
#endif /* defined(__MMI_SCREEN_ROTATE__) */

    /* set draw manager attributes */
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    if(!isFullScreen)
    {
        dm_data.s32CatId = MMI_CATEGORY431_ID;
#if defined(__MMI_SCREEN_ROTATE__)
        dm_data.s32CatId = (mmi_frm_is_screen_width_height_swapped()) ? (MMI_CATEGORY431_ROTATE_ID) : (dm_data.s32CatId);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    }
    else
    {
        dm_data.s32CatId = MMI_CATEGORY431_FULL_ID;
#if defined(__MMI_SCREEN_ROTATE__)
        dm_data.s32CatId = (mmi_frm_is_screen_width_height_swapped()) ? (MMI_CATEGORY431_ROTATE_FULL_ID) : (dm_data.s32CatId);
#endif /* defined(__MMI_SCREEN_ROTATE__) */
    }
    dm_setup_data(&dm_data);

#if defined(__MMI_SCREEN_ROTATE__)
    if (mmi_frm_is_screen_width_height_swapped() && !isFullScreen)
    {   /* hook: dm_setup_data will clost statuc icon while rotated */
        wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
    }
#endif /* defined(__MMI_SCREEN_ROTATE__) */

    /* register pen event handler */
#ifdef __MMI_TOUCH_SCREEN__
    mmi_cat431_pen_event_handler = pen_handler,
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenDownHandler,
            MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenUpHandler,
            MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenLongTapHandler,
            MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenRepeatHandler,
            MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenMoveHandler,
            MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(
            Cat431ControlAreaPenAbortHandler,
            MMI_PEN_EVENT_ABORT);
    mmi_pen_register_double_click_handler((mmi_pen_hdlr)Cat431ControlAreaPenDoubleClickHandler);
#endif /* __MMI_TOUCH_SCREEN__ */

    /* re-draw category screen */
    dm_redraw_category_screen();

    if (percentage >= 0)
    {
        wgui_cat431_display_progressive_bar(percentage, display_string);
    }

    gdi_layer_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    MMI_ASSERT((mmi_cat431_title_handle == GDI_NULL_HANDLE) && (mmi_cat431_bottom_handle == GDI_NULL_HANDLE));

    {   /* set title layer */
        S32 ptr_offset = 0;
        S32 x, y, w, h;
        U8 bpp;
        U8 *buf_ptr;
        
        x = 0;
        y = 0;
        w = (isFullScreen) ? (CAT431_FULLSCREEN_W) : (CAT431_W);
        h = (isFullScreen) ? (CAT431_FULLSCREEN_Y) : (CAT431_Y);

#if defined(__MMI_SCREEN_ROTATE__)
		if (mmi_frm_is_screen_width_height_swapped())
		{
			w = CAT431_ROTATE_FULLSCREEN_W;
			h = MMI_ROTATED_SOFTKEY_HEIGHT;
		}
#endif /* defined(__MMI_SCREEN_ROTATE__) */

        bpp = gdi_layer_get_bit_per_pixel();
        gdi_layer_get_buffer_ptr(&buf_ptr);
        gdi_layer_create_cf_using_outside_memory(
                (gdi_color_format)(bpp >> 3),
                x, y, w, h,
                &mmi_cat431_title_handle,
                buf_ptr + ptr_offset,
                ((w*h*bpp + 7) >> 3));

        MMI_ASSERT(mmi_cat431_title_handle);
        gdi_layer_push_and_set_active(mmi_cat431_title_handle);
        gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_and_restore_active();
    }

    {   /* set bottom layer */
        if (!isFullScreen
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_SCREEN_ROTATE__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
            || (!mmi_frm_is_screen_width_height_swapped() && wgui_icon_bar_is_created())
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_SCREEN_ROTATE__) &&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)*/
            )
        {
            S32 ptr_offset = 0;
            S32 x = 0, y = 0, w = 1, h = 1;
            U8 bpp;
            U8 *buf_ptr;

            if (!isFullScreen)
            {
#if defined(__MMI_SCREEN_ROTATE__)
                if (mmi_frm_is_screen_width_height_swapped())
                {
                    x = CAT431_ROTATE_X;
                    y = CAT431_ROTATE_Y + CAT431_ROTATE_H;
                    w = CAT431_ROTATE_FULLSCREEN_W;
                    h = MMI_ROTATED_SOFTKEY_HEIGHT;
                }
                else
#endif /* defined(__MMI_SCREEN_ROTATE__) */
                {
                    x = 0;
                    y = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT;
                    w = MAIN_LCD_DEVICE_WIDTH;
                    h = MMI_BUTTON_BAR_HEIGHT;
                }

#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_SCREEN_ROTATE__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
                if (!mmi_frm_is_screen_width_height_swapped() && wgui_icon_bar_is_created())
                {
                    y -= MMI_ICON_BAR_HEIGHT;
                    h += MMI_ICON_BAR_HEIGHT;
                }
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_SCREEN_ROTATE__) &&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)*/
            }
#if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_SCREEN_ROTATE__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__)
            else if (!mmi_frm_is_screen_width_height_swapped() && wgui_icon_bar_is_created())
            {
                x = 0;
                y = UI_device_height - MMI_ICON_BAR_HEIGHT;
                w = UI_device_width;
                h = MMI_ICON_BAR_HEIGHT;
            }
#endif /* defined(__MMI_FTE_SUPPORT__) && defined(__MMI_SCREEN_ROTATE__)&&defined(__MMI_TOUCH_SCREEN__)&&defined(__MMI_ICON_BAR_SUPPORT__) */

            bpp = gdi_layer_get_bit_per_pixel();
            gdi_layer_get_buffer_ptr(&buf_ptr);
            ptr_offset = (w*y*bpp + 7) >> 3;
            gdi_layer_create_cf_using_outside_memory(
                    (gdi_color_format)(bpp >> 3),
                    x, y, w, h,
                    &mmi_cat431_bottom_handle,
                    buf_ptr + ptr_offset,
                    ((w*h*bpp + 7) >> 3));

            MMI_ASSERT(mmi_cat431_bottom_handle);
            gdi_layer_push_and_set_active(mmi_cat431_bottom_handle);
            gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
        }
        else
        {
            mmi_cat431_bottom_handle = GDI_ERROR_HANDLE;
        }
    }
}


/* For detail description, please refer to wgui_categories.h */
void ExitCategory431Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_cat431_title_handle > 0)
    {
        gdi_layer_free(mmi_cat431_title_handle);
        mmi_cat431_title_handle = 0;
    }
    if (mmi_cat431_bottom_handle > 0)
    {
        gdi_layer_free(mmi_cat431_bottom_handle);
        mmi_cat431_bottom_handle = 0;
    }

#ifdef __MMI_TOUCH_SCREEN__
    mmi_cat431_pen_event_handler = NULL;
#if defined(__MMI_FTE_SUPPORT__)
    g_wgui_cat431_is_pen_down_toolbar = MMI_FALSE;
#endif /* defined(__MMI_FTE_SUPPORT__) */
#endif /* __MMI_TOUCH_SCREEN__ */

    /* in order to flatten the rendering page (in base layer memory) with blue characters,
     * disable the source key */
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_BLUE);
    gdi_layer_pop_and_restore_active();

    enable_softkey_background();

#if defined(__MMI_SCREEN_ROTATE__)
    wgui_status_icon_bar_reset_rotate_for_wap();
#endif /* defined(__MMI_SCREEN_ROTATE__) */
}
#endif /* defined(__MMI_BROWSER_2__) */

#ifdef __MMI_ECOMPASS__

extern void flat_triangle_fill(polygon_vertex vertices[], color c);
extern void polygon_draw(polygon_vertex vertices[], S32 n_vertices, color c);

#if defined(__MMI_MAINLCD_320X480__) 
#if defined(__MMI_FTE_SUPPORT__)
    #define WGUI_CAT126_COMPASS_RADIUS 89
    #define WGUI_CAT126_COMPASS_CENTER_X 160
    #define WGUI_CAT126_COMPASS_CENTER_Y 243
#else
    #define WGUI_CAT126_COMPASS_RADIUS 90
    #define WGUI_CAT126_COMPASS_CENTER_X 159
    #define WGUI_CAT126_COMPASS_CENTER_Y 232
#endif
#elif defined(__MMI_MAINLCD_240X400__) 
#if defined(__MMI_FTE_SUPPORT__)
    #define WGUI_CAT126_COMPASS_RADIUS 61
    #define WGUI_CAT126_COMPASS_CENTER_X 118
    #define WGUI_CAT126_COMPASS_CENTER_Y 202
#else
    #define WGUI_CAT126_COMPASS_RADIUS 60
    #define WGUI_CAT126_COMPASS_CENTER_X 120
    #define WGUI_CAT126_COMPASS_CENTER_Y 185
#endif
#elif defined(__MMI_MAINLCD_240X320__) 
#if defined(__MMI_FTE_SUPPORT__)
    #define WGUI_CAT126_COMPASS_RADIUS 53
    #define WGUI_CAT126_COMPASS_CENTER_X 118
    #define WGUI_CAT126_COMPASS_CENTER_Y 162
#else
    #define WGUI_CAT126_COMPASS_RADIUS 60
    #define WGUI_CAT126_COMPASS_CENTER_X 118
    #define WGUI_CAT126_COMPASS_CENTER_Y 155
#endif
#elif defined(__MMI_MAINLCD_320X240__) 
    #define WGUI_CAT126_COMPASS_RADIUS 45
    #define WGUI_CAT126_COMPASS_CENTER_X 157
    #define WGUI_CAT126_COMPASS_CENTER_Y 114
#elif defined(__MMI_MAINLCD_176X220__) 
    #define WGUI_CAT126_COMPASS_RADIUS 42
    #define WGUI_CAT126_COMPASS_CENTER_X 86
    #define WGUI_CAT126_COMPASS_CENTER_Y 111
#elif defined(__MMI_MAINLCD_128X160__) 
    #define WGUI_CAT126_COMPASS_RADIUS 30
    #define WGUI_CAT126_COMPASS_CENTER_X 66
    #define WGUI_CAT126_COMPASS_CENTER_Y 74
#else
    #define WGUI_CAT126_COMPASS_RADIUS 43
    #define WGUI_CAT126_COMPASS_CENTER_X 88
    #define WGUI_CAT126_COMPASS_CENTER_Y 117
#endif

#if defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_MAINLCD_320X480__)
    #define WGUI_CAT126_LOCATION_TEXT_HEIGHT    34
#elif defined(__MMI_MAINLCD_240X400__)
    #define WGUI_CAT126_LOCATION_TEXT_HEIGHT    34
#elif defined(__MMI_MAINLCD_240X320__)
    #define WGUI_CAT126_LOCATION_TEXT_HEIGHT    22
#else /*__MMI_MAINLCD_320X480__*/
    #define WGUI_CAT126_LOCATION_TEXT_HEIGHT    0
#endif /*__MMI_MAINLCD_320X480__*/
#endif /* __MMI_FTE_SUPPORT__ */

/* define location text height above the ecmopass */
#if defined(__MMI_FTE_SUPPORT__)
#if defined(__MMI_MAINLCD_320X480__)
    #define ECM_LOC_TEXT_HEIGHT    34
    #define EMC_LOC_TEXT_LEFT_GAP  10
#elif defined(__MMI_MAINLCD_240X400__)
    #define ECM_LOC_TEXT_HEIGHT    34
    #define EMC_LOC_TEXT_LEFT_GAP  6
#elif defined(__MMI_MAINLCD_240X320__)
    #define ECM_LOC_TEXT_HEIGHT    22
    #define EMC_LOC_TEXT_LEFT_GAP  6
#else /* __MMI_MAINLCD_320X480__ */
    #define ECM_LOC_TEXT_HEIGHT    0
    #define EMC_LOC_TEXT_LEFT_GAP  0
#endif /* __MMI_MAINLCD_320X480__ */
#else /* __MMI_FTE_SUPPORT__ */
    #define ECM_LOC_TEXT_HEIGHT    0
    #define EMC_LOC_TEXT_LEFT_GAP  0
#endif /* __MMI_FTE_SUPPORT__ */

/* define ecompass image start y position */
#define ECM_BACKGROUND_Y (MMI_CONTENT_Y + ECM_LOC_TEXT_HEIGHT)

static scrolling_text g_cat126_scroll_text;

static U16 g_cat126_compass_north_degree;
static U16 g_cat126_compass_mecca_degree;
static UI_string_type g_cat126_compass_info;
static const FLOAT g_wgui_compass_sine_table[] = 
{
    (FLOAT) 0.0, (FLOAT) 0.01745240, (FLOAT) 0.03489949, (FLOAT) 0.05233595,
        (FLOAT) 0.06975647,
        (FLOAT) 0.08715574, (FLOAT) 0.10452846, (FLOAT) 0.12186934,
    (FLOAT) 0.13917310, (FLOAT) 0.15643446, (FLOAT) 0.17364817, (FLOAT) 0.19080899,
        (FLOAT) 0.20791169,
        (FLOAT) 0.22495105, (FLOAT) 0.24192189, (FLOAT)0.25881904, /* 15*/
    (FLOAT) 0.27563735, (FLOAT) 0.29237170, (FLOAT) 0.30901699, (FLOAT) 0.32556815, (FLOAT) 0.34202014,
        (FLOAT) 0.35836794,
        (FLOAT)0.37460659, (FLOAT)0.39073112,
    (FLOAT) 0.40673664, (FLOAT) 0.42261826, (FLOAT) 0.43837114, (FLOAT) 0.45399049, (FLOAT) 0.46947156,
        (FLOAT) 0.48480962,
        (FLOAT)0.5, /*30*/(FLOAT)0.51503807,
    (FLOAT) 0.52991926, (FLOAT) 0.54463903, (FLOAT) 0.55919290, (FLOAT) 0.57357643, (FLOAT) 0.58778525,
        (FLOAT) 0.60181502,
        (FLOAT)0.61566147, (FLOAT)0.62932039,
    (FLOAT) 0.64278760, (FLOAT) 0.656059023, (FLOAT) 0.66913060, (FLOAT) 0.68199836, (FLOAT) 0.69465837,
        (FLOAT) 0.70710678, /*45*/
        (FLOAT) 0.71933980, (FLOAT) 0.73135370,
    (FLOAT) 0.74314482, (FLOAT) 0.75470958, (FLOAT) 0.76604444, (FLOAT) 0.77714596,
        (FLOAT) 0.78801075,
        (FLOAT) 0.79863551, (FLOAT) 0.80901699, (FLOAT) 0.81915204,
    (FLOAT) 0.82903757, (FLOAT) 0.83867056, (FLOAT) 0.84804809, (FLOAT) 0.85716730,(FLOAT) 0.86602540,/*60*/
    (FLOAT) 0.87461970, (FLOAT) 0.88294759, (FLOAT) 0.89100652, (FLOAT) 0.89879404, (FLOAT) 0.90630778,
    (FLOAT) 0.91354545, (FLOAT) 0.92059485, (FLOAT) 0.92718385, (FLOAT) 0.93358042, (FLOAT) 0.93969262,
    (FLOAT) 0.94551857, (FLOAT) 0.95105651, (FLOAT) 0.95630475, (FLOAT) 0.96126169, (FLOAT) 0.96592582,/*75*/
    (FLOAT) 0.97029572, (FLOAT) 0.97437006, (FLOAT) 0.97814760, (FLOAT) 0.98162718, (FLOAT) 0.98480775,
    (FLOAT) 0.98768834, (FLOAT) 0.99026806, (FLOAT) 0.99254615, (FLOAT) 0.99452189, (FLOAT) 0.99619469,
    (FLOAT) 0.99756405, (FLOAT) 0.99862953, (FLOAT) 0.99939082, (FLOAT) 0.99984769, (FLOAT) 1.0
};


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_map_value
 * DESCRIPTION
 *  map FLOAT to s32. if > 0.5, value will add 1.
 * PARAMETERS
 *  FLOAT*		[IN]
 *  FLOAT*        [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_map_value(FLOAT *x1, FLOAT *y1)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	FLOAT x, y;
	s32 sx, sy;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
	x = *x1;
	y = *y1;
	sx = (s32)x;
	sy = (s32)y;

	if((x - sx) > 0.5)
	{
		*x1 = sx + 1;
	}
	else if((x - sx) < -0.5)
	{
		*x1 = sx - 1;
	}
	
	if((y - sy) > 0.5)
	{
		*y1 = sy + 1;
	}
	else if((y - sy) < -0.5)
	{
		*y1 = sy - 1;
	}
}
/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_rotate_compass_arrow
 * DESCRIPTION
 *  compute offset from center point.
 * PARAMETERS
 *  vertices    [IN]
 *  degree      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_rotate_compass_arrow(polygon_vertex vertices[], U16 degree)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FLOAT cosa, sina, x, y, x1, y1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_DBG_ASSERT(vertices != NULL);
    MMI_DBG_ASSERT(degree<=360);
    switch (degree/90)
        {
            case 0: /* 0<= degree < 90 */
            {
                cosa = g_wgui_compass_sine_table[90 - degree];
                sina = g_wgui_compass_sine_table[degree];
                break;
            }
            case 1: /* 90 <= degree < 180 */
            {
                cosa = -g_wgui_compass_sine_table[degree - 90];
                sina = g_wgui_compass_sine_table[180 - degree];
                break;
            }
            case 2: /* 180 <= degree < 270 */
            {
                cosa = -g_wgui_compass_sine_table[270 - degree];
                sina = -g_wgui_compass_sine_table[degree - 180];
                break;
            }
            case 3: /* 270 <= degree < 360 */
            {
                cosa = g_wgui_compass_sine_table[degree - 270];
                sina = -g_wgui_compass_sine_table[360 - degree];
                break;
            }
			case 4: /* degree = 360 */
			{
				cosa = 1;
				sina = 0;
				break;
			}
            default:
            {
                cosa = 0;
                sina = 0;
                break;
            }

        }    

    x1 = (FLOAT)vertices[0].x;
    y1 = (FLOAT)vertices[0].y;
    x = (x1 * cosa - y1 * sina);
    y = (x1 * sina + y1 * cosa);
	wgui_cat126_map_value(&x, &y);
	vertices[0].x = (s32)x;
	vertices[0].y = (s32)y;

    x1 = (FLOAT)vertices[1].x;
    y1 = (FLOAT)vertices[1].y;
    x = (x1 * cosa - y1 * sina);
    y = (x1 * sina + y1 * cosa);
	wgui_cat126_map_value(&x, &y);
	vertices[1].x = (s32)x;
	vertices[1].y = (s32)y;

    x = (FLOAT)vertices[2].x;
    y = (FLOAT)vertices[2].y;
    vertices[2].x = (S32) (x * cosa - y * sina);
    vertices[2].y = (S32) (x * sina + y * cosa);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_arrow
 * DESCRIPTION
 *  draw compass arrow
 *	      .v[2]
 *       /  \ 
 *      /    \ 
 *     v[0]   v[1]
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_arrow(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	color c = {153, 0, 0, 100};
	color c1 = {51, 51, 51, 100};
	color c2 = {0, 80, 160, 100};
	s32 x1 = WGUI_CAT126_COMPASS_CENTER_X;
	s32 y1 = WGUI_CAT126_COMPASS_CENTER_Y;
	s32 radius = WGUI_CAT126_COMPASS_RADIUS;
    s32 x = 0, y = 0;

    U8 i = 0;
    U16 north_degree, sourth_degree, mecca_degree;

#if defined(__MMI_MAINLCD_320X480__) || defined (__MMI_MAINLCD_240X400__)
	polygon_vertex v[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };

	polygon_vertex v1[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };
    
	polygon_vertex v2[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };
    
    polygon_vertex v3[3] = { {-5, 0},
    {+5, 0},
    {0, 0},
    };
#elif defined(__MMI_MAINLCD_240X320__) || defined (__MMI_MAINLCD_320X240__)
	polygon_vertex v[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };

	polygon_vertex v1[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
    
	polygon_vertex v2[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
    
    polygon_vertex v3[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
#else
	polygon_vertex v[3] = { {-3, 0},
    {+3, 0},
    {0, 0},
    };

	polygon_vertex v1[3] = { {-3, 0},
    {+3, 0},
    {0, 0},
    };
    
	polygon_vertex v2[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
    
    polygon_vertex v3[3] = { {-4, 0},
    {+4, 0},
    {0, 0},
    };
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	v[2].y =  -radius;
	v1[2].y = -radius;
    v2[2].y = -radius;
#if defined(__MMI_MAINLCD_176X220__) || defined (__MMI_MAINLCD_128X160__)
    v3[2].y = -(radius*3)/4;    /* temp for Mecca's arrow */
#else
    v3[2].y = -(radius*4)/5;    /* temp for Mecca's arrow */
#endif
    north_degree = g_cat126_compass_north_degree;
    mecca_degree = g_cat126_compass_mecca_degree;
    sourth_degree = (north_degree > 180)? (north_degree - 180):(180 + north_degree);
	wgui_cat126_rotate_compass_arrow(v, north_degree);
	wgui_cat126_rotate_compass_arrow(v1, sourth_degree);
    wgui_cat126_rotate_compass_arrow(v2, mecca_degree);
	wgui_cat126_rotate_compass_arrow(v3, mecca_degree);
    for(i = 0; i < 3; i++)
    {
        v[i].x += x1;
        v[i].y += y1;

        v1[i].x += x1;
        v1[i].y += y1;
    }

/* compute v2 point array for tip arrow of Mecca by setting v3[2] as center point*/
    v2[2].x += x1;
    v2[2].y += y1;

    v3[2].x += x1;
    v3[2].y += y1;

    v2[0].x += v3[2].x;
    v2[0].y += v3[2].y;

    v2[1].x += v3[2].x;
    v2[1].y += v3[2].y;
/* clear background */
    x = x1 - radius;
    y = y1 - radius;
    gdi_draw_solid_rect(x, y, x + 2*radius, y + 2*radius, GDI_COLOR_TRANSPARENT);
    
/* draw mecca arrow */
    gdi_draw_antialiasing_line(x1, y1, v2[2].x, v2[2].y, gdi_act_color_from_rgb(255, c2.r, c2.g, c2.b));
	gdi_draw_antialiasing_line(v2[0].x, v2[0].y, v2[2].x, v2[2].y, gdi_act_color_from_rgb(255, c2.r, c2.g, c2.b));
	gdi_draw_antialiasing_line(v2[1].x, v2[1].y, v2[2].x, v2[2].y, gdi_act_color_from_rgb(255, c2.r, c2.g, c2.b));
/* draw compass arrow */
    flat_triangle_fill(v, c);   /* north arrow */
    gdi_draw_antialiasing_line(v[2].x, v[2].y, v[0].x, v[0].y, gdi_act_color_from_rgb(255, c.r, c.g, c.b));
    gdi_draw_antialiasing_line(v[2].x, v[2].y, v[1].x, v[1].y, gdi_act_color_from_rgb(255, c.r, c.g, c.b));

    flat_triangle_fill(v1, c1); /* sourth arrow */
    gdi_draw_antialiasing_line(v1[2].x, v1[2].y, v1[0].x, v1[0].y, gdi_act_color_from_rgb(255, c1.r, c1.g, c1.b));
    gdi_draw_antialiasing_line(v1[2].x, v1[2].y, v1[1].x, v1[1].y, gdi_act_color_from_rgb(255, c1.r, c1.g, c1.b));
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_controlled_area
 * DESCRIPTION
 *  draw controlled area
 * PARAMETERS
 *  coordinate		[IN]	Unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_controlled_area(dm_coordinates *coordinate)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE handle0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    handle0 = dm_get_layer_handle(0);

    gdi_layer_push_and_set_active(handle0);
    gdi_image_draw_id(MMI_COMMON_CONTENT_X, /*MMI_COMMON_CONTENT_Y*/ECM_BACKGROUND_Y,IMG_ID_COMPASS_BACKGROUND);
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_info
 * DESCRIPTION
 *  draw arrow in compass
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_info(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y1, y2;
    S32 sw, sh, w;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	y1 = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - MMI_MENUITEM_HEIGHT - 1;
	y2 = MAIN_LCD_DEVICE_HEIGHT - MMI_BUTTON_BAR_HEIGHT - 1;
    w = UI_device_width - 2;    /* left and right gap is 1*/
    gdi_layer_lock_frame_buffer();
    gui_push_clip();
    gui_set_clip(0, y1, UI_device_width, y2);
    gdi_draw_solid_rect(0,  y1, UI_device_width, y2, GDI_COLOR_TRANSPARENT); 
	gui_set_text_color(*current_MMI_theme->title_text_color);
    Get_StringWidthHeight((U8*)g_cat126_compass_info, &sw, &sh);
    if (sw > w)
    {
         if (mmi_fe_get_r2l_state())
         {
             gui_print_truncated_text(
                 UI_device_width - 2,
                 y1,
                 w,
                 g_cat126_compass_info);
         }
         else
         {
             gui_print_truncated_text(1, y1, w, g_cat126_compass_info);
         }
     }
     else
     {
         if (mmi_fe_get_r2l_state())
         {
             gui_move_text_cursor((w + sw)>>1, y1);
         }
         else
         {
             gui_move_text_cursor(1 + (w - sw)>>1, y1);
         }
         gui_print_text(g_cat126_compass_info);
     }
     gui_pop_clip();
     gdi_layer_unlock_frame_buffer();

}

#if defined(__MMI_FTE_SUPPORT__)

static WCHAR *wgui_cat126_location_info = NULL;

void wgui_cat126_set_location_info(WCHAR *location)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat126_location_info = location;
}

static void wgui_cat126_reset_location_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat126_location_info = NULL;
}

static void wgui_cat126_scroll_text_timer_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     gui_handle_scrolling_text(&g_cat126_scroll_text);
}

static void wgui_cat126_scroll_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y11, x22, y22;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x1);
    UI_UNUSED_PARAMETER(y1);
    UI_UNUSED_PARAMETER(x2);
    UI_UNUSED_PARAMETER(y2);

    y11 = MMI_CONTENT_Y;
    x22 = UI_DEVICE_WIDTH - 1;
    y22 = MMI_CONTENT_Y + WGUI_CAT126_LOCATION_TEXT_HEIGHT - 1;
    
    gui_push_clip();
    gui_reset_clip();
    
    gui_set_clip(0, y11, x22, y22);
#ifdef __MMI_MAINLCD_128X128__
    gdi_draw_solid_rect(
        0, y11, x22, y22,
        GDI_COLOR_WHITE);
#else /* __MMI_MAINLCD_128X128__ */
    gdi_draw_solid_rect(
        0, y11, x22, y22,
        GDI_COLOR_TRANSPARENT);
#endif /* __MMI_MAINLCD_128X128__ */
    
    gui_pop_clip();
}

static void wgui_cat126_draw_location_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 tw = 0, th = 0;
    S32 x, y;
    stFontAttribute sf = MMI_small_font;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(wgui_cat126_location_info != NULL)
    {
    #if !defined(__MMI_MAINLCD_320X480__)
        gui_set_font(&MMI_small_font);
    #endif /*__MMI_MAINLCD_320X480__*/
        Get_StringWidthHeight((U8*)wgui_cat126_location_info, &tw, &th);

        if(tw < UI_DEVICE_WIDTH - (EMC_LOC_TEXT_LEFT_GAP<<1))
        {
            x = ((UI_DEVICE_WIDTH - tw)>>1) + 1;
        }
        else
        {
            x = EMC_LOC_TEXT_LEFT_GAP;
            tw = UI_DEVICE_WIDTH - (EMC_LOC_TEXT_LEFT_GAP<<1);
        }
        y = MMI_content_y + ((WGUI_CAT126_LOCATION_TEXT_HEIGHT - th)>>1);

        gui_create_scrolling_text(
            &g_cat126_scroll_text,
            x,
            y,
            tw,
            th,
            (UI_string_type) wgui_cat126_location_info,
            wgui_cat126_scroll_text_timer_callback,
            wgui_cat126_scroll_text_background,
    #ifdef __MMI_MAINLCD_128X128__
            gui_color(0, 0, 0),
            gui_color(255, 255, 255)
    #else /* __MMI_MAINLCD_128X128__ */
            *current_MMI_theme->list_normal_text_color,
            gui_color(255, 255, 255)
    #endif /* __MMI_MAINLCD_128X128__ */
        );
        
    #if !defined(__MMI_MAINLCD_320X480__)
        gui_set_font(&MMI_medium_font);
    #endif /*__MMI_MAINLCD_320X480__*/

    #if defined(__MMI_MAINLCD_320X480__)
        g_cat126_scroll_text.text_font = MMI_medium_font;
    #else
        g_cat126_scroll_text.text_font = MMI_small_font;
    #endif

        gui_show_scrolling_text(&g_cat126_scroll_text);
    }
}
#endif /*__MMI_FTE_SUPPORT__*/

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_draw_controlled2_area
 * DESCRIPTION
 *  draw controlled2 area
 * PARAMETERS
 *  coordinate	[IN]	Unused
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_draw_controlled2_area(dm_coordinates *coordinate)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
#if defined(__MMI_FTE_SUPPORT__)
    gui_scrolling_text_stop(&g_cat126_scroll_text);
#endif /*__MMI_FTE_SUPPORT__*/
	wgui_cat126_draw_arrow();
    wgui_cat126_draw_info();
#if defined(__MMI_FTE_SUPPORT__)
    wgui_cat126_draw_location_info();
#endif /*__MMI_FTE_SUPPORT__*/
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_exit_screen
 * DESCRIPTION
 *  Exits the category126 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat126_exit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)
    wgui_cat126_reset_location_info();
    gui_scrolling_text_stop(&g_cat126_scroll_text);
#endif /*__MMI_FTE_SUPPORT__*/
}
/*****************************************************************************
 * FUNCTION
 *  ShowCategory126Screen
 * DESCRIPTION
 *  Displays the category126 screen
 * PARAMETERS
 *  mecca_string            [IN]        Mecca direction string
 *  mecca_icon              [IN]        Mecca icon
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the right softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the left softkey
 *  info_message            [IN]        String to display singal strength
 *	north_degree			[IN]		Degree of North from NS axis.
 *  mecca_degree			[IN]		Degree of Mecca from NS axis.
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory126Screen(
        UI_string_type mecca_string,
        PU8 mecca_icon,
        UI_string_type left_softkey,
        PU8 left_softkey_icon,
        UI_string_type right_softkey,
        PU8 right_softkey_icon,
        UI_string_type info_message,
        U16 north_degree, 
        U16 mecca_degree,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

	dm_add_title(mecca_string, mecca_icon);
    dm_add_softkey_str(left_softkey, right_softkey);
    g_cat126_compass_info = info_message;
    g_cat126_compass_north_degree = north_degree;
    g_cat126_compass_mecca_degree = mecca_degree;
	
    gdi_layer_unlock_frame_buffer();
    
    wgui_cat_setup_category_default_history(MMI_CATEGORY126_ID, DM_CLEAR_SCREEN_BACKGROUND | DM_SCR_BG_NO_CACHE, wgui_cat126_exit_screen);
	dm_register_category_controlled_callback(wgui_cat126_draw_controlled_area);
    dm_register_category_controlled2_callback(wgui_cat126_draw_controlled2_area);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_update_degree
 * DESCRIPTION
 *  update north and Mecca degree, and Mecca string in title.
 * PARAMETERS
 *  north_degree		[IN]	Degree of North from NS axis.
 *  mecca_degree		[IN]	Degree of Mecca from NS axis.
 *	mecca_string		[IN]	String of Mecca in title.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat126_update_degree(U16 north_degree, U16 mecca_degree, UI_string_type mecca_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_cat126_compass_north_degree = north_degree;
    g_cat126_compass_mecca_degree = mecca_degree;
    gdi_layer_lock_frame_buffer();
    wgui_cat126_draw_arrow();

    ChangeTitleString((U8*)mecca_string);
    draw_title();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_update_info
 * DESCRIPTION
 *  display singal strength info message on bottom.
 * PARAMETERS
 *  info_message	[IN]	info message on bottom.
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat126_update_info(UI_string_type info_message)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	g_cat126_compass_info = info_message;
    wgui_cat126_draw_info();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat126_update_data
 * DESCRIPTION
 *  update information at the bottom and the location of the current place
 * PARAMETERS
 *  info	    [IN]	info message on bottom.
 *  location    [IN]    location of the current place
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat126_update_data(UI_string_type info, WCHAR *location)
{
    gdi_layer_lock_frame_buffer();

    if(info != NULL)
    {
        g_cat126_compass_info = info;
        wgui_cat126_draw_info();
    }

#if defined(__MMI_FTE_SUPPORT__)
    if(location != NULL)
    {
        gui_scrolling_text_stop(&g_cat126_scroll_text);
        wgui_cat126_set_location_info(location);
        wgui_cat126_draw_location_info();
    }
#endif /*__MMI_FTE_SUPPORT__*/

    gdi_layer_unlock_frame_buffer();

    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}

#endif /* __MMI_ECOMPASS__ */

#if defined(__MMI_MOBILE_TV_CMMB_SUPPORT__) && defined(__MBBMS_INTER__)
static void (*wgui_cat6001_app_draw) (S16 x, S16 y, S16 width, S16 height ) = NULL;
static U32 g_wgui_cat6001_config_info;
#ifdef __MMI_TOUCH_SCREEN__
static MMI_BOOL (*wgui_cat6001_ctrl_area_pen_hdlr)(mmi_pen_event_type_enum pen_event, mmi_pen_point_struct point) = NULL;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_is_in_control_area
 * DESCRIPTION
 *  Check the point is in control area or not.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          In control area.
 *  MMI_FALSE                         Not in control area.
 *****************************************************************************/
static MMI_BOOL wgui_cat6001_is_in_control_area(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_coordinates control_area_coordinates;
    S32 cat_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_SCR_BG)
    {
        cat_id = MMI_CAT6001_ID_WITH_SCR_BG;
    }
    else
    {
        cat_id = MMI_CAT6001_ID;
    }

    /* initialize control area */
    dm_get_control_coordinates_from_category(
        -1,
        cat_id,
        DM_CATEGORY_CONTROLLED_AREA,
        -1,
        &control_area_coordinates);

    /* reset by config infomation */
    if (!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_TITLE))
    {
        control_area_coordinates.s16Y -= MMI_title_height;
        control_area_coordinates.s16Height += MMI_title_height;
    }
    if (!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_STATUS_ICON))
    {
        control_area_coordinates.s16Y -= MMI_status_bar_height;
        control_area_coordinates.s16Height += MMI_status_bar_height;
    }    
    if (!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_SOFTKEY))
    {
        control_area_coordinates.s16Height += MMI_softkey_height;
    }

    /* check the point whether within the control area */
    if ((point.x < control_area_coordinates.s16X) ||
        (point.x > control_area_coordinates.s16X + control_area_coordinates.s16Width) ||
        (point.y < control_area_coordinates.s16Y) ||
        (point.y > control_area_coordinates.s16Y + control_area_coordinates.s16Height))
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_pen_down_hdlr
 * DESCRIPTION
 *  Execute application pen down handler.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          Success.
 *  MMI_FALSE                         Fail.
 *****************************************************************************/
MMI_BOOL wgui_cat6001_pen_down_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_PEN_POINT, point.x, point.y);

    if ((wgui_cat6001_is_in_control_area(point)) && (wgui_cat6001_ctrl_area_pen_hdlr != NULL))
    {
        return wgui_cat6001_ctrl_area_pen_hdlr(MMI_PEN_EVENT_DOWN, point);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_pen_up_hdlr
 * DESCRIPTION
 *  Execute application pen up handler.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          Success.
 *  MMI_FALSE                         Fail.
 *****************************************************************************/
MMI_BOOL wgui_cat6001_pen_up_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_PEN_POINT, point.x, point.y);

    if ((wgui_cat6001_is_in_control_area(point)) && (wgui_cat6001_ctrl_area_pen_hdlr != NULL))
    {
        return wgui_cat6001_ctrl_area_pen_hdlr(MMI_PEN_EVENT_UP, point);
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_pen_move_hdlr
 * DESCRIPTION
 *  Execute application pen move handler.
 * PARAMETERS
 *  mmi_pen_point_struct  point [IN]  The coordinates of the pen events. 
 * RETURNS VALUES
 *  MMI_TRUE                          Success.
 *  MMI_FALSE                         Fail.
 *****************************************************************************/
MMI_BOOL wgui_cat6001_pen_move_hdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_PEN_POINT, point.x, point.y);

    if ((wgui_cat6001_is_in_control_area(point)) && (wgui_cat6001_ctrl_area_pen_hdlr != NULL))
    {
        return wgui_cat6001_ctrl_area_pen_hdlr(MMI_PEN_EVENT_MOVE, point);
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat6001_draw_ctrl_area
 * DESCRIPTION
 *  Draw Cat6001 control area,
 * 
 * PARAMETERS
 *  coordinate          [IN]    useless, we have pre-defined area
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat6001_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 x = coordinate->s16X, y = coordinate->s16Y, w = coordinate->s16Width, h = coordinate->s16Height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* confirm the control area */
    if(!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_TITLE))
    {
        y -= MMI_title_height;
        h += MMI_title_height;
    }

    if(!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_STATUS_ICON))
    {
        y -= MMI_status_bar_height;
        h += MMI_status_bar_height;
        /* if need titile but without status icon bar, the title will be moved up. */
        if(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_TITLE)
        {
            wgui_title_move(x, y - MMI_title_height);
            draw_title();
        }
    }    

    if(!(g_wgui_cat6001_config_info & WGUI_CAT6001_NEED_SOFTKEY))
    {
        h += MMI_softkey_height;
    }

    MMI_TRACE(MMI_FW_TRC_G3_CAT, MMI_WGUI_TRC_CAT6001_CONTROL_AREA, y, h);

    /* draw by application */
    if (wgui_cat6001_app_draw != NULL)
    {
        wgui_cat6001_app_draw(x, y, w, h);
    }
}


/* For detail description, please refer to wgui_categories.h */
void wgui_cat6001_show(
        UI_string_type title_string,
        PU8 title_icon,
        UI_string_type left_softkey_string,
        PU8 left_softkey_icon,
        UI_string_type right_softkey_string,
        PU8 right_softkey_icon,
        U32 config_info,
        void (*display_call_back) (S16 x, S16 y, S16 width, S16 height),
        MMI_BOOL (*pen_all_call_back)(mmi_pen_event_type_enum pen_event, mmi_pen_point_struct point))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* setup title bar and softkey bar */
    dm_add_title(title_string,title_icon);
    dm_add_softkey_str(left_softkey_string, right_softkey_string);
    wgui_title_set_menu_shortcut_number(-1);

    /* for confirm control area */
    g_wgui_cat6001_config_info = config_info;

    dm_setup_category_functions(dm_redraw_category_screen, dm_get_category_history, dm_get_category_history_size);

    if(config_info & WGUI_CAT6001_NEED_SCR_BG)
    {
        dm_data.s32CatId = MMI_CAT6001_ID_WITH_SCR_BG; /* include "DM_SCR_BG" */
        dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    }
    else
    {
        dm_data.s32CatId = MMI_CAT6001_ID;
        dm_data.s32flags = DM_NO_FLAGS;
    }
    dm_data.s32ScrId = GetActiveScreenId();
    
    /* don't need the title bar */
    if(!(config_info & WGUI_CAT6001_NEED_TITLE))
    {
        dm_data.s32flags |= DM_NO_TITLE;
    }
    /* don't need the status icon bar */
    if(!(config_info & WGUI_CAT6001_NEED_STATUS_ICON))
    {
        /* title will be moved up, so it will be displayed by control area callback */
        dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE;
    }
    /* don't need the softkey bar */
    if(!(config_info & WGUI_CAT6001_NEED_SOFTKEY))
    {
        dm_data.s32flags |= DM_NO_SOFTKEY;
    }
    dm_setup_data(&dm_data);
    
    wgui_cat6001_app_draw = display_call_back;
    dm_register_category_controlled_callback(wgui_cat6001_draw_ctrl_area);
#if defined(__MMI_TOUCH_SCREEN__)
    wgui_cat6001_ctrl_area_pen_hdlr = pen_all_call_back;
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat6001_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat6001_pen_up_hdlr, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat6001_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /* defined(__MMI_TOUCH_SCREEN__) */

    dm_redraw_category_screen();
}
#endif /*defined(__MMI_MOBILE_TV_CMMB_SUPPORT__)&&define(__MBBMS_INTER__)*/

/* For detail description, please refer to wgui_categories_c.h */
void wgui_cat9001_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
    color c = {0, 0, 0, 100};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    dm_add_rectangle(c, DM_RECTANGLE_FILL_GRAYSCALE);
    
    wgui_cat_setup_category_default_history(MMI_CAT9001_ID, 0, MMI_dummy_function);
    dm_redraw_category_screen();
}


#if defined(__MMI_TOUCH_SCREEN__)
void wgui_register_tap_callback(void (*tap_callback_funtion)(mmi_tap_type_enum tap_type,S32 index))
{
    if(MMI_current_menu_type == LIST_MENU)
    {
        wgui_register_list_tap_callback(tap_callback_funtion);
    }
    if(MMI_current_menu_type == MATRIX_MENU)
    {
        wgui_register_matrix_tap_callback(tap_callback_funtion);
    }
}
#else
/* here an empty function for SNS app which is released as library */
void wgui_register_tap_callback(void (*tap_callback_funtion)(mmi_tap_type_enum tap_type,S32 index))
{
}
#endif /* __MMI_TOUCH_SCREEN__ */


MMI_BOOL wgui_category_if_pop_option_menu(void)
{
#if defined(MMI_POPUP_OPTION_MENU)
    return MMI_TRUE;
#else
    return MMI_FALSE;
#endif /* MMI_POPUP_OPTION_MENU */
}

#if defined(__MMI_FACTORY_MODE__) && defined(__TOUCH_PANEL_MULTITOUCH__) && defined(__MMI_TOUCH_SCREEN__)
static S32 g_wgui_cat9011_check_point_num;
static wgui_cat9011_check_point_struct *g_wgui_cat9011_check_point_list;
static U32 g_wgui_cat9011_flag;

/*****************************************************************************
 * FUNCTION
 *  wgui_cat9011_draw_check_point_by_state
 * DESCRIPTION
 *  Draw the check point
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat9011_draw_check_point_by_state(MMI_BOOL blt_flag , S32 cp_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
    PU8 cp_img = NULL;
    S32 cp_img_w, cp_img_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((cp_idx < 0) || (cp_idx >= g_wgui_cat9011_check_point_num) || (g_wgui_cat9011_check_point_list == NULL))
    {
        return;
    }
    
    /* set image by state */
    if (g_wgui_cat9011_check_point_list[cp_idx].cp_state == WGUI_CAT9011_CP_NORMAL_STATE)
    {
        cp_img = g_wgui_cat9011_check_point_list[cp_idx].normal_img;
    }
    else if (g_wgui_cat9011_check_point_list[cp_idx].cp_state == WGUI_CAT9011_CP_PRESSED_STATE)
    {
        cp_img = g_wgui_cat9011_check_point_list[cp_idx].pressed_img;
    }
    else
    {
        MMI_ASSERT(0);
    }
    MMI_ASSERT(cp_img != NULL);

    /* draw image */
    gdi_layer_lock_frame_buffer();

    gdi_image_draw(
        g_wgui_cat9011_check_point_list[cp_idx].cp_pos_x,
        g_wgui_cat9011_check_point_list[cp_idx].cp_pos_y,
        cp_img);

    gdi_layer_unlock_frame_buffer();

    if (blt_flag)
    {
        gdi_image_get_dimension(cp_img, &cp_img_w, &cp_img_h);
        gdi_layer_blt_previous(
            g_wgui_cat9011_check_point_list[cp_idx].cp_pos_x,
            g_wgui_cat9011_check_point_list[cp_idx].cp_pos_y,
            g_wgui_cat9011_check_point_list[cp_idx].cp_pos_x + cp_img_w - 1,
            g_wgui_cat9011_check_point_list[cp_idx].cp_pos_y + cp_img_h - 1);
    }

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat9011_get_check_point_idx
 * DESCRIPTION
 *  get the check point index by pen event position
 * PARAMETERS
 *  param        [IN]
 * RETURNS
 *  MMI_RET
 *****************************************************************************/
static S32 wgui_cat9011_get_check_point_idx(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_wgui_cat9011_check_point_num; i++)
    {
        if (PEN_CHECK_BOUND(
                x,
                y, 
                g_wgui_cat9011_check_point_list[i].cp_response_x, 
                g_wgui_cat9011_check_point_list[i].cp_response_y, 
                g_wgui_cat9011_check_point_list[i].cp_response_w, 
                g_wgui_cat9011_check_point_list[i].cp_response_h))
        {
            return i;
        }
    }

    return -1;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat9011_pen_proc
 * DESCRIPTION
 *  pen proc function of touch panel accuracy item
 * PARAMETERS
 *  param        [IN]
 * RETURNS
 *  MMI_RET
 *****************************************************************************/
static MMI_RET wgui_cat9011_pen_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_touch_data_struct *touch_data;
    mmi_multi_touch_event_struct *evt = (mmi_multi_touch_event_struct *)param;
    S32 i;
    S32 cp_idx;
    MMI_BOOL cp_pressed_in_this_evt[WGUI_CAT9011_CP_MAX_NUM] = {MMI_FALSE};
    MMI_BOOL pen_up_in_this_evt = MMI_FALSE;
    //MMI_BOOL cp_state_is_changed = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    if (EVT_ID_ON_TOUCH == param->evt_id)
    {
        for (i = 0; i < evt->touch_num; i++)
        {
            touch_data = &evt->touch_data[i];

            switch (touch_data->event)
            {
                case MMI_PEN_EVENT_DOWN:
                case MMI_PEN_EVENT_REPEAT:
                case MMI_PEN_EVENT_LONG_TAP:
                    cp_idx = wgui_cat9011_get_check_point_idx(touch_data->currpos.pos.x, touch_data->currpos.pos.y);
                    if (cp_idx >= 0)
                    {
                        cp_pressed_in_this_evt[cp_idx] = MMI_TRUE;
                        if (g_wgui_cat9011_check_point_list[cp_idx].cp_state == WGUI_CAT9011_CP_NORMAL_STATE)
                        {
                            g_wgui_cat9011_check_point_list[cp_idx].cp_state = WGUI_CAT9011_CP_PRESSED_STATE;
                            wgui_cat9011_draw_check_point_by_state(MMI_FALSE, cp_idx);
                            //cp_state_is_changed = MMI_TRUE;
                        }
                    }
                    break;

                case MMI_PEN_EVENT_UP:
                case MMI_PEN_EVENT_ABORT:
                    if (g_wgui_cat9011_flag & WGUI_CAT9011_RESET_CP_STATE_IF_PEN_MOVE_OUT)
                    {
                        cp_idx = wgui_cat9011_get_check_point_idx(touch_data->currpos.pos.x, touch_data->currpos.pos.y);
                        if (cp_idx >= 0)
                        {
                            if (cp_pressed_in_this_evt[cp_idx] == MMI_FALSE)
                            {
                                if (g_wgui_cat9011_check_point_list[cp_idx].cp_state == WGUI_CAT9011_CP_PRESSED_STATE)
                                {
                                    g_wgui_cat9011_check_point_list[cp_idx].cp_state = WGUI_CAT9011_CP_NORMAL_STATE;
                                    wgui_cat9011_draw_check_point_by_state(MMI_FALSE, cp_idx);
                                    //cp_state_is_changed = MMI_TRUE;
                                }
                            }
                        }
                    }
                    else
                    {
                        pen_up_in_this_evt = MMI_TRUE;
                    }

                    break;

               case MMI_PEN_EVENT_MOVE:
                    cp_idx = wgui_cat9011_get_check_point_idx(touch_data->currpos.pos.x, touch_data->currpos.pos.y);
                    if (cp_idx >= 0)
                    {
                        cp_pressed_in_this_evt[cp_idx] = MMI_TRUE;
                        if (g_wgui_cat9011_check_point_list[cp_idx].cp_state == WGUI_CAT9011_CP_NORMAL_STATE)
                        {
                            g_wgui_cat9011_check_point_list[cp_idx].cp_state = WGUI_CAT9011_CP_PRESSED_STATE;
                            wgui_cat9011_draw_check_point_by_state(MMI_FALSE, cp_idx);
                            //cp_state_is_changed = MMI_TRUE;
                        }
                    }

                    if (g_wgui_cat9011_flag & WGUI_CAT9011_RESET_CP_STATE_IF_PEN_MOVE_OUT)
                    {
                        cp_idx = wgui_cat9011_get_check_point_idx(touch_data->pre_pos.pos.x, touch_data->pre_pos.pos.y);
                        if (cp_idx >= 0)
                        {
                            if (cp_pressed_in_this_evt[cp_idx] == MMI_FALSE)
                            {
                                if (g_wgui_cat9011_check_point_list[cp_idx].cp_state == WGUI_CAT9011_CP_PRESSED_STATE)
                                {
                                    g_wgui_cat9011_check_point_list[cp_idx].cp_state = WGUI_CAT9011_CP_NORMAL_STATE;
                                    wgui_cat9011_draw_check_point_by_state(MMI_FALSE, cp_idx);
                                    //cp_state_is_changed = MMI_TRUE;
                                }
                            }
                        }
                    }

                    break;
      
               default:
                    break;
            }
        }

        if ((!(g_wgui_cat9011_flag & WGUI_CAT9011_RESET_CP_STATE_IF_PEN_MOVE_OUT)) && (pen_up_in_this_evt))
        {
            for(i = 0; i < WGUI_CAT9011_CP_MAX_NUM; i++)
            {
                if (cp_pressed_in_this_evt[i] == MMI_TRUE)
                {
                    pen_up_in_this_evt = MMI_FALSE;
                    continue;
                }
            }

            /* all finger pen up, reset the check point state */
            if (pen_up_in_this_evt)
            {
                for(i = 0; i < g_wgui_cat9011_check_point_num; i++)
                {
                    if (g_wgui_cat9011_check_point_list[i].cp_state == WGUI_CAT9011_CP_PRESSED_STATE)
                    {
                        g_wgui_cat9011_check_point_list[i].cp_state = WGUI_CAT9011_CP_NORMAL_STATE;
                        wgui_cat9011_draw_check_point_by_state(MMI_FALSE, i);
                        //cp_state_is_changed = MMI_TRUE;
                    }
                }
            }
        }

    }

    gdi_lcd_repaint_all();
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat9011_controll_area_callback
 * DESCRIPTION
 *  Draw the check point
 * PARAMETERS
 *  coordinate      [IN]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat9011_controll_area_callback(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    S32 cp_img_w, cp_img_h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* draw line */
    if (!(g_wgui_cat9011_flag & WGUI_CAT9011_RESET_CP_STATE_IF_PEN_MOVE_OUT))
    {
        gdi_image_get_dimension(g_wgui_cat9011_check_point_list[0].normal_img, &cp_img_w, &cp_img_h);
        for (i = 0; i < g_wgui_cat9011_check_point_num - 1; i++)
        {
            gdi_draw_line(
                g_wgui_cat9011_check_point_list[i].cp_pos_x + (cp_img_w >> 1),
                g_wgui_cat9011_check_point_list[i].cp_pos_y + (cp_img_h >> 1),
                g_wgui_cat9011_check_point_list[i + 1].cp_pos_x + (cp_img_w >> 1),
                g_wgui_cat9011_check_point_list[i + 1].cp_pos_y + (cp_img_h >> 1),
                GDI_COLOR_WHITE);
        }
    }
    for (i = 0; i < g_wgui_cat9011_check_point_num; i++)
    {
        wgui_cat9011_draw_check_point_by_state(MMI_FALSE, i);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategoryDummyScreen
 * DESCRIPTION
 *  Exits the dummy category screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat9011_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat9011_check_point_num = 0;
    g_wgui_cat9011_check_point_list = NULL;
    g_wgui_cat9011_flag = 0;
}

/* For detail description, please refer to wgui_categories.h */
void wgui_cat9011_show(
        S32 check_point_num,
        wgui_cat9011_check_point_struct *check_point_list,
        U32 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(check_point_list);

    gdi_layer_lock_frame_buffer();

    g_wgui_cat9011_check_point_num = check_point_num;
    g_wgui_cat9011_check_point_list = check_point_list;
    g_wgui_cat9011_flag = flag;

    mmi_frm_touch_set_mode(MMI_FRM_MULTI_TOUCH);
    mmi_frm_touch_register_proc(wgui_cat9011_pen_proc, NULL);

    dm_register_category_controlled_callback(wgui_cat9011_controll_area_callback);
    wgui_cat_setup_category_default_history(MMI_CAT9011_ID, DM_CLEAR_SCREEN_BACKGROUND, wgui_cat9011_exit);
    
    gdi_layer_unlock_frame_buffer();
    dm_redraw_category_screen();
}
#endif /* __MMI_TOUCH_SCREEN__ */
/* __MMI_FACTORY_MODE__*/
/* __TOUCH_PANEL_MULTITOUCH__*/


#if  defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_MAINLCD_128X128__)

gdi_handle content_layer_handle;
gdi_handle base_layer;
gdi_handle status_icon_layer;
PU8 status_buf_ptr;
U8 screen_key[MAX_KEY_NUM] = {KEY_INVALID};
void show_key_content(UI_string_type lefttop_key,
        U16 lefttop_key_icon,
        UI_string_type leftbottom_key,
        U16 leftbottom_key_icon,
        UI_string_type righttop_key,
        U16 righttop_key_icon,
        UI_string_type rightbottom_key,
        U16 rightbottom_key_icon)
{
	if (NULL != lefttop_key_icon) //add lefttop key
		gdi_image_draw_id(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, lefttop_key_icon);
	
	if (NULL != leftbottom_key_icon) //add leftbottom key
		gdi_image_draw_id(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT, leftbottom_key_icon);

	if (NULL != righttop_key_icon) //add righttop key
		gdi_image_draw_id(MMI_SMALL_SW_SIDE_BAR_RIGHT_BTN_X_OFFSET, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, righttop_key_icon);

	if (NULL != rightbottom_key_icon) //add rightbottom key
		gdi_image_draw_id(MMI_SMALL_SW_SIDE_BAR_RIGHT_BTN_X_OFFSET, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT, rightbottom_key_icon);
	
}

void show_content_main(U8* text, U16 content_icon, U16 bg_icon, S32 flag)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/  
	S32 img_w = 0, img_h = 0;
	S32 str_w = 0, str_h = 0;
	S32 text_x = 0, text_y = 0;
	S32 icon_x = 0, icon_y = 0;
	S32 icon_width = 0, icon_height = 0;
	S32 text_width = 0, text_height = 0;
	S32 str_len = 0;
	
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/

	if (SW_COMMONAPP_SCREEN_COLUMN_1 & flag) //screen column is 1, only show text
	{
		text_width = MMI_SMALL_SW_SCREEN_CONTENT_WIDTH;
		text_height = MMI_SMALL_SW_1_COLUMN_SCREEN_CONTENT_HEIGHT;
		icon_width = 0;
		icon_height = 0;
	}
	else if (SW_COMMONAPP_SCREEN_COLUMN_2 & flag) //screen column is 2
	{
		text_width = MMI_SMALL_SW_SCREEN_CONTENT_WIDTH;
		text_height = MMI_SMALL_SW_2_COLUMN_SCREEN_CONTENT_HEIGHT;
		icon_width = MMI_SMALL_SW_SCREEN_CONTENT_WIDTH;
		icon_height = MMI_SMALL_SW_2_COLUMN_SCREEN_CONTENT_HEIGHT;
	}
	else if (SW_COMMONAPP_SCREEN_COLUMN_3 & flag) //screen column is 3
	{
		text_width = MMI_SMALL_SW_SCREEN_CONTENT_WIDTH;
		text_height = MMI_SMALL_SW_3_COLUMN_SCREEN_CONTENT_HEIGHT;
		icon_width = MMI_SMALL_SW_SCREEN_CONTENT_WIDTH;
		icon_height = MMI_SMALL_SW_3_COLUMN_SCREEN_CONTENT_HEIGHT * 2;
	}

	//draw bg
	if (NULL == bg_icon)
	{
		gdi_image_draw_id(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, IMG_ID_SWATCH_128_128_BG_PICTURE);
	}
	else if (NULL != bg_icon)
	{	
		gdi_image_draw_id(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, bg_icon);
	}
	
	
	if (SW_COMMONAPP_SCREEN_TEXT_ABOVE & flag) //text show above
	{
		text_x = MMI_SMALL_SW_SIDE_BAR_BTN_WIDTH + MMI_SMALL_SW_CONTENT_GAP_WITH_SIDE;
		text_y = MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_CONTENT_GAP_WITH_SIDE;
		icon_x = MMI_SMALL_SW_SIDE_BAR_BTN_WIDTH + MMI_SMALL_SW_CONTENT_GAP_WITH_SIDE;
		icon_y = text_y + text_height;
	}
	else
	{	
		text_x = MMI_SMALL_SW_SIDE_BAR_BTN_WIDTH + MMI_SMALL_SW_CONTENT_GAP_WITH_SIDE;
		text_y = icon_y + icon_height;
		icon_x = MMI_SMALL_SW_SIDE_BAR_BTN_WIDTH + MMI_SMALL_SW_CONTENT_GAP_WITH_SIDE;
		icon_y = MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_CONTENT_GAP_WITH_SIDE;
	}
	
	gdi_image_get_dimension_id(content_icon, &img_w, &img_h);
	gui_measure_string((UI_string_type)text, &str_w, &str_h);
	

	//show text
	if (str_w > text_width) //use multiline to show
	{
        str_len = mmi_ucs2strlen((S8*) text);

        create_multiline_inputbox_set_buffer((UI_string_type)text, str_len, str_len, 0);
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
            | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
            | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;

		
		//if not defined default is left justify
		if (SW_COMMONAPP_SCREEN_TEXT_CENTER_JUSTIFY & flag) //center justify
		{
			MMI_multiline_inputbox.flags |=  UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY;
		}
		else if (SW_COMMONAPP_SCREEN_TEXT_RIGHT_JUSTIFY & flag) //right justify
		{
			MMI_multiline_inputbox.flags |=  UI_MULTI_LINE_INPUT_BOX_RIGHT_JUSTIFY;
		}
	        MMI_multiline_inputbox.text_font = &MMI_medium_font;
	        MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);
	      //  MMI_multiline_inputbox.border_color = border_color;

	        resize_multiline_inputbox(text_width, text_height);
        move_multiline_inputbox(text_x, text_y);

	        /* vertical center alignment */
	      /*  show_multiline_inputbox_no_draw();
	        line_height = get_multiline_inputbox_line_height();
	        resize_multiline_inputbox(
	            width,
	            (MMI_multiline_inputbox.n_lines * line_height) + MULTILINE_INPUTBOX_HEIGHT_PAD + MMI_multiline_inputbox.text_y);
	        move_multiline_inputbox(
	            0,
	            offset_y + ((height - MMI_multiline_inputbox.height) >> 1));*/

	        show_multiline_inputbox();        

    	}
		else
		{
		if (SW_COMMONAPP_SCREEN_TEXT_CENTER_JUSTIFY & flag) //center justify
		{
			text_x = text_x + (text_width - str_w ) / 2;
		}
		else if (SW_COMMONAPP_SCREEN_TEXT_RIGHT_JUSTIFY & flag) //right justify
		{
			text_x = text_x + MMI_SMALL_SW_SCREEN_CONTENT_WIDTH - MMI_SMALL_SW_COMMON_SCREEN_TEXT_X_OFFSET;
		}
		else //left justify
		{
			text_x = MMI_SMALL_SW_COMMON_SCREEN_TEXT_X_OFFSET;
		}
		text_y = text_y + (text_height - str_h ) / 2;
		gui_move_text_cursor(text_x, text_y);
    	gui_print_text((UI_string_type)text);	
	}

	//draw icon
	if (!(SW_COMMONAPP_SCREEN_COLUMN_1 & flag) && NULL != content_icon)
	{
		icon_x = icon_x + (icon_width - img_w) / 2;
		icon_y = icon_y + (icon_height- img_h ) / 2;
		gdi_image_draw_id(icon_x,icon_y, content_icon);
	}

}

void ExitCommonAppScreen(void)
{
	/*----------------------------------------------------------------*/
	 /* Local Variables												 */
   /*----------------------------------------------------------------*/  
 
   /*----------------------------------------------------------------*/
   /* Code Body 													 */
   /*----------------------------------------------------------------*/
	if (NULL != content_layer_handle)
	{
		gdi_layer_free(content_layer_handle);
		content_layer_handle = NULL;
	}	

	if (NULL != status_icon_layer)
	{
		gdi_layer_free(status_icon_layer);
		status_icon_layer = NULL;
		mmi_frm_asm_free_anonymous(status_buf_ptr);
		status_buf_ptr = NULL;
	}
	GoBackHistory(); 
}


void RedrawCommonAppKey(S32 key_x, S32 key_y, U16 image_id)
{
	/*----------------------------------------------------------------*/
	 /* Local Variables 											 */
   /*----------------------------------------------------------------*/  
 
   /*----------------------------------------------------------------*/
   /* Code Body 													 */
   /*----------------------------------------------------------------*/
	gdi_layer_get_base_handle(&base_layer);
	gdi_layer_push_and_set_active(content_layer_handle);
	gdi_push_and_set_alpha_blending_source_layer(content_layer_handle);
	gdi_layer_push_and_set_clip(key_x, key_y, key_x + MMI_SMALL_SW_SIDE_BAR_BTN_WIDTH - 1, \
		key_y + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT - 1);
	gdi_draw_solid_rect(key_x,key_y,key_x + MMI_SMALL_SW_SIDE_BAR_BTN_WIDTH - 1,key_y + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT - 1,GDI_COLOR_WHITE);
	gdi_image_draw_id(key_x, key_y, image_id);
	gdi_layer_pop_clip();
	gdi_pop_and_restore_alpha_blending_source_layer();
	gdi_layer_pop_and_restore_active();
	gdi_layer_blt(        
        base_layer,
        content_layer_handle,
        NULL,
        NULL,
        0, 0, LCD_WIDTH, LCD_HEIGHT);
}

static mmi_ret CommonAppScreenKeyProc(mmi_frm_key_evt_struct *evt)
{
	/*----------------------------------------------------------------*/
   /* Local Variables												 */
   /*----------------------------------------------------------------*/  
   
   /*----------------------------------------------------------------*/
   /* Code Body 													 */
   /*----------------------------------------------------------------*/

	switch (evt->evt_id)
    {
        case EVT_ID_PRE_KEY:
        {
			
            if (evt->key_code == screen_key[0]) //RSK, left top
            {
            	if (KEY_EVENT_DOWN == evt->key_type)
            		RedrawCommonAppKey(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, IMG_ID_SWATCH_LEFTTOP_PRESS_BTN);
				else if (KEY_EVENT_UP == evt->key_type)
				{
					RedrawCommonAppKey(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, IMG_ID_SWATCH_LEFTTOP_BTN);
					ExitCommonAppScreen();
				}
				
            }
			else if (evt->key_code == screen_key[1]) //LSK, left bottom
			{
				if (KEY_EVENT_DOWN == evt->key_type)
					RedrawCommonAppKey(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT, IMG_ID_SWATCH_LEFTBOTTOM_PRESS_BTN);
				else if (KEY_EVENT_UP == evt->key_type)
					RedrawCommonAppKey(0, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT, IMG_ID_SWATCH_LEFTBOTTOM_BTN);
			}
			else if (evt->key_code == screen_key[2]) //Up_Arrow, right top
			{
				if (KEY_EVENT_DOWN == evt->key_type)
					RedrawCommonAppKey(MMI_SMALL_SW_SIDE_BAR_RIGHT_BTN_X_OFFSET, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, IMG_ID_SWATCH_RIGHTTOP_PRESS_BTN);
				else if (KEY_EVENT_UP == evt->key_type)
					RedrawCommonAppKey(MMI_SMALL_SW_SIDE_BAR_RIGHT_BTN_X_OFFSET, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT, IMG_ID_SWATCH_RIGHTTOP_BTN);
			}
			else if (evt->key_code == screen_key[3]) //Down_Arrow, right bottom
			{
				if (KEY_EVENT_DOWN == evt->key_type)
					RedrawCommonAppKey(MMI_SMALL_SW_SIDE_BAR_RIGHT_BTN_X_OFFSET, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT, IMG_ID_SWATCH_RIGHTBOTTOM_PRESS_BTN);
				else if (KEY_EVENT_UP == evt->key_type)
					RedrawCommonAppKey(MMI_SMALL_SW_SIDE_BAR_RIGHT_BTN_X_OFFSET, MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT + MMI_SMALL_SW_SIDE_BAR_BTN_HEIGHT, IMG_ID_SWATCH_RIGHTBOTTOM_BTN);
			}
			break;
        }
    }
    return MMI_RET_OK;
}

void mmi_swatch_comscreen_status_icon(void)
{
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	gdi_layer_push_and_set_active(status_icon_layer);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
	
	wgui_status_icon_bar_set_target_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, status_icon_layer);

    /* Set status bar's blending layer */
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, status_icon_layer);

    /* Register draw-background callback */
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR,
        hide_status_icons_bar0_by_transparent);

    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR); 

	wgui_status_icon_bar_update();
}


void ShowCommonAppScreen(
        UI_string_type lefttop_key,
        U16 lefttop_key_icon,
        UI_string_type leftbottom_key,
        U16 leftbottom_key_icon,
        UI_string_type righttop_key,
        U16 righttop_key_icon,
        UI_string_type rightbottom_key,
        U16 rightbottom_key_icon,
        U8* text,
        U16	content_icon,
        U16 bg_icon,
        S32 flag)
{
	 /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
	 int i;
	//U16 down_key_icon = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	//set key info
	for (i=0; i<MAX_KEY_NUM; i++)
		screen_key[i] = KEY_INVALID;

	//get key info
	if (NULL != lefttop_key_icon)
		screen_key[0] = KEY_RSK;
	if (NULL != leftbottom_key_icon)
		screen_key[1] = KEY_LSK;
	if (NULL != righttop_key_icon)
		screen_key[2] = KEY_UP_ARROW;
	if (NULL != rightbottom_key_icon)
		screen_key[3] = KEY_DOWN_ARROW;

	gdi_layer_get_base_handle(&base_layer);
	status_buf_ptr = mmi_frm_asm_alloc_anonymous_nc(LCD_WIDTH * MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT * 4);
	gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_32_PARGB,
        0,
        0,
        LCD_WIDTH,
        MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT,
        &status_icon_layer,
        status_buf_ptr,
        LCD_WIDTH * MMI_SMALL_SW_STATUS_ICON_BAR_HEIGHT * 4);

	mmi_swatch_comscreen_status_icon();
	if(NULL == content_layer_handle)
	{
    	gdi_layer_create(0,0,128,128,&content_layer_handle);
	}
    gdi_layer_push_and_set_active(content_layer_handle);
	gdi_push_and_set_alpha_blending_source_layer(content_layer_handle);
	gdi_layer_clear(GDI_COLOR_TRANSPARENT);
	show_content_main(text, content_icon, bg_icon, flag);
	show_key_content(lefttop_key, lefttop_key_icon, leftbottom_key, leftbottom_key_icon, righttop_key, righttop_key_icon, rightbottom_key, rightbottom_key_icon);

	gdi_pop_and_restore_alpha_blending_source_layer();
	gdi_layer_pop_and_restore_active();
	
	gdi_layer_set_blt_layer(        
        base_layer,
        content_layer_handle,
        status_icon_layer,
        NULL);

	//register key handler
	//mmi_frm_set_key_handler(RedrawCommonAppKey, KEY_LSK,KEY_EVENT_DOWN);
	mmi_frm_set_key_handler(ExitCommonAppScreen,KEY_RSK,KEY_EVENT_UP);
	/*mmi_frm_set_key_handler(mmi_swatch_mainmenu_redraw_back_key, KEY_RSK,KEY_EVENT_DOWN);
	mmi_frm_set_key_handler(mmi_swatch_mainmenu_redraw_up_key, KEY_DOWN_ARROW,KEY_EVENT_DOWN);
      mmi_frm_set_key_handler(mmi_swatch_mainmenu_redraw_up_key, KEY_UP_ARROW,KEY_EVENT_DOWN);
	mmi_frm_set_key_handler(mmi_swatch_mainmenu_enter_key_handler,KEY_LSK,KEY_EVENT_UP);
	mmi_frm_set_key_handler(mmi_swatch_mainmenu_back_key_handler,KEY_RSK,KEY_EVENT_UP);
	mmi_frm_set_key_handler(mmi_swatch_mainmenu_key_down_handler,KEY_DOWN_ARROW,KEY_EVENT_UP);
      mmi_frm_set_key_handler(mmi_swatch_mainmenu_key_up_handler,KEY_UP_ARROW,KEY_EVENT_UP);*/
	MMI_SCR_SET_KEY_PROC(CommonAppScreenKeyProc, NULL);
	
}
   
#endif /*defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_MAINLCD_128X128__)*/

#if  defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_MAINLCD_128X32__)
void ShowCommonAppScreen(
        U8* text,
        U16	content_icon)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/  
	gdi_handle base_handler;
	S32 str_w = 0, str_h = 0;
	S32 width, height;
	S32 text_width, text_height, text_offsetx, text_offsety;
	S32 str_len;
	//U16 down_key_icon = 0;
	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	gdi_layer_get_base_handle(&base_handler);
    gdi_layer_push_and_set_active(base_handler);
    gdi_layer_clear(GDI_COLOR_BLACK);

	gui_measure_string((UI_string_type)text, &str_w, &str_h);
    gdi_image_get_dimension_id(content_icon,&width,&height);

	gdi_image_draw_id(5,3,content_icon);

    text_width = LCD_WIDTH - width - 5 - 2- 2;
	text_height = LCD_HEIGHT - 4;
	text_offsetx = 5 + width + 2;
	text_offsety = 2;
		
	if (str_w > text_width) //use multiline to show
	{
        str_len = mmi_ucs2strlen((S8*) text);

        create_multiline_inputbox_set_buffer((UI_string_type)text, str_len, str_len, 0);
        MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
            | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
            | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;

        /*Center Display only*/
		MMI_multiline_inputbox.flags |=  UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY;
		
	    MMI_multiline_inputbox.text_font = &MMI_medium_font;
	    MMI_multiline_inputbox.normal_text_color = gui_color(255, 255, 255);
	    //  MMI_multiline_inputbox.border_color = border_color;

	    resize_multiline_inputbox(text_width, text_height);
        move_multiline_inputbox(text_offsetx, text_offsety);
	    show_multiline_inputbox();        

    }
	else
	{
	    text_offsetx = text_offsetx + (text_width - str_w ) / 2;
		  text_offsety = text_offsety + (text_height - str_h ) / 2;;
		  gui_move_text_cursor(text_offsetx, text_offsety);
		  gui_set_text_color(gui_color(255, 255, 255));
    	gui_print_text((UI_string_type)text);	
	}		
	gdi_layer_pop_and_restore_active();
	gdi_layer_blt(base_handler, NULL, NULL, NULL, 0, 0, LCD_WIDTH, LCD_HEIGHT);	
}


#endif

