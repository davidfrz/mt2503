/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 *
 * Filename:
 * ---------
 * fmt_main.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ¡K.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/
#define FMT_MAIN_C

#ifndef FMT_NOT_PRESENT

/****************************************************************************
* Include Files                                                                
*****************************************************************************/

/* MMI header */
#include "mmi_features.h"

#include "string.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "kal_trace.h"

#include "stack_ltlcom.h"
#include "stack_config.h"

#include "stack_common.h"
#include "stack_msgs.h"
#include "app_ltlcom.h" /* Task message communiction */
#include "syscomp_config.h"
#include "task_config.h"        /* Task creation */
#include "App_features.h"

#include "msdc_api.h"    
#if defined(__FS_CARD_SUPPORT__)
#include "msdc_lsd.h"
#endif

#include "fs_errcode.h"
#include "fs_type.h"
#include "fs_func.h"

#include "fmt_def.h"
#include "fmt_main.h"
#include "fmt_struct.h"
#include "fmt_trc.h"

#ifdef __OTG_ENABLE__
#include "usb_host_ms_if.h"
#endif 

#if defined(__FOTA_DM__) && defined(__MTK_TARGET__)
#include "fota.h"
#endif /* defined(__FOTA_DM__) && defined(__MTK_TARGET__) */

#ifdef MMS_SUPPORT
#include "wap_adp.h" /* for wap_is_init() */
#include "mms_adp.h" /* for mma_is_ready_for_format(), mms_get_service_module() */
#include "mma_api.h"
#endif 

#if defined(NEPTUNE_MMI)
#include "FileMgrType.h"
extern void mmi_fmgr_remove_last_dir(char *path);
extern fmgr_filter_struct fmgr_filter[];
#endif

/****************************************************************************
* Define
*****************************************************************************/
#ifdef __OTG_ENABLE__
#define MAX_OTG_SLOT    8
#endif

#if !defined(PLUTO_MMI)
#define FMT_DELETE_FOLDER           FS_RECURSIVE_TYPE
#define FMT_DELETE_SINGLE           FS_FILE_TYPE
#define FMT_DELETE_ALL              FS_DIR_TYPE
#define FMT_DELETE_ALL_BY_FILTER    FS_DIR_TYPE
#endif

#define FMT_TRACE0(trc, str)                kal_trace(TRACE_GROUP_1, trc)
#define FMT_TRACE1(trc, str, a1)            kal_trace(TRACE_GROUP_1, trc, a1)
#define FMT_TRACE2(trc, str, a1, a2)        kal_trace(TRACE_GROUP_1, trc, a1, a2)
#define FMT_TRACE3(trc, str, a1, a2, a3)    kal_trace(TRACE_GROUP_1, trc, a1, a2, a3)

#if defined(PLUTO_MMI) && defined(__MMI_SLIM_FILE_MANAGER__)
#ifndef __SLIM_FMT_MAIN__
#define __SLIM_FMT_MAIN__
#endif
#endif
/****************************************************************************
* Global Variable
*****************************************************************************/
#if defined(__FOTA_DM__) && !defined(__MTK_TARGET__)
FS_HANDLE g_fhandle;
#endif /* defined(__FOTA_DM__) && !defined(__MTK_TARGET__) */

/****************************************************************************
* Static Variable
*****************************************************************************/

static T_MSDC_CARD fmt_msdc_type = UNKNOWN_CARD;
static fmt_msdc_state_enum fmt_msdc_present = FMT_MSDC_STATE_UNINIT;
#if defined(NEPTUNE_MMI)
static kal_bool fmt_need_abort = KAL_FALSE;
#endif
static kal_uint8 g_fmt_format_drive;
static void* g_fmt_format_callback;
static kal_uint32 g_fmt_format_userdata;

#ifdef __OTG_ENABLE__
static fmt_msdc_state_enum fmt_otg_present[MAX_OTG_SLOT];
#endif

#ifdef __FS_CHECKDRIVE_SUPPORT__
#ifdef __MTK_TARGET__
__align(4)
#endif
static kal_uint8 g_fmt_buffer[FMT_MAX_BUFFER_SIZE];
#endif 

/****************************************************************************
* Function Forward Declaration
*****************************************************************************/

#if defined(PLUTO_MMI)
extern void fmt_adv_init(void);
extern kal_bool fmt_adv_handler(ilm_struct *ilm_ptr);
extern kal_bool fmt_adv_is_ilm_valid(ilm_struct *ilm_ptr);

#define FMT_MAX_INT_QUEUE_COUNT               20   /* Should be the same as FMT_ADV_MAX_JOB_COUNT */

static ilm_struct g_fmt_int_queue[FMT_MAX_INT_QUEUE_COUNT];
static kal_uint32 g_fmt_cur_int_queue_count;

static kal_bool fmt_int_queue_push(ilm_struct *ilm_ptr);
static void fmt_int_queue_pop(ilm_struct *ilm_ptr);
#endif


/*****************************************************************************
 * FUNCTION
 *  fmt_create
 * DESCRIPTION
 *  fmt task create function
 * PARAMETERS
 *  handle      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool fmt_create(comptask_handler_struct **handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static const comptask_handler_struct fmt_handler_info = 
    {
        fmt_task_main,  /* task entry function */
        fmt_init,       /* task initialization function */
        NULL,           /* task configuration function */
        fmt_reset,      /* task reset handler */
        NULL,           /* task termination handler */
    };

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *handle = (comptask_handler_struct*) & fmt_handler_info;
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  fmt_task_main
 * DESCRIPTION
 *  fmt task main loop
 * PARAMETERS
 *  task_entry_ptr      [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_task_main(task_entry_struct *task_entry_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ilm_struct current_ilm;
    kal_uint32 my_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_get_my_task_index(&my_index);

    fmt_init_drive();

    /* Init internal queue */
#if defined(PLUTO_MMI)
    memset(g_fmt_int_queue, 0, sizeof(ilm_struct)*FMT_MAX_INT_QUEUE_COUNT);
    g_fmt_cur_int_queue_count = 0;
#endif   
    while (1)
    {
#if !defined(PLUTO_MMI)
        receive_msg_ext_q_for_stack(task_info_g[task_entry_ptr->task_indx].task_ext_qid, &current_ilm);
#else
        fmt_move_ext_q_to_int_q(task_info_g[task_entry_ptr->task_indx].task_ext_qid, KAL_TRUE);

        fmt_clear_invalid_ilm_from_int_q();

        fmt_int_queue_pop(&current_ilm);
#endif
        stack_set_active_module_id(my_index, current_ilm.dest_mod_id);

        fmt_main((void*)&current_ilm);

        free_ilm(&current_ilm);
    }
}


/*****************************************************************************
 * FUNCTION
 *  fmt_init
 * DESCRIPTION
 *  fmt task init handler
 * PARAMETERS
 *  task_indx       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool fmt_init(task_indx_type task_indx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(PLUTO_MMI)
    fmt_adv_init();
#endif

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  fmt_reset
 * DESCRIPTION
 *  fmt task reset handler
 * PARAMETERS
 *  task_indx       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool fmt_reset(task_indx_type task_indx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 * fmt_GetDiskInfo
 * DESCRIPTION
 *  fmt get disk info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

kal_int32 fmt_GetDiskInfo(kal_uint32 Type, kal_uint32 Serial, kal_uint32 AltMask, int Flags, int *phone)
 {
 	FS_DiskInfo info;
	kal_uint8 path[10];
	//int phone;
	kal_int32 fs_ret = 0;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if(*phone == NULL)
	{
		*phone = FS_GetDrive(Type, Serial, AltMask);
	}
	
	memset(path, 0, 10);

	if (*phone >= FS_NO_ERROR)
	{
		FMT_TRACE0(TRC_FMT_2b6e0d923e164c7987d7c2b912afd54e, "[FMT][MSDC]Calculate free space start");
		kal_wsprintf((WCHAR*) path, "%c:\\", *phone);

		fs_ret = FS_GetDiskInfo((WCHAR*) path, &info, Flags);
		FMT_TRACE2(TRC_FMT_a3115bfea84a44b591f7060f50f2a70d, "[FMT][MSDC]Calculate free space end(%d, %d)", fs_ret, *phone);
	}
	return fs_ret;

 }


/*****************************************************************************
 * FUNCTION
 *  fmt_init_drive
 * DESCRIPTION
 *  fmt task message dispatcher
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_init_drive(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //FS_DiskInfo info;
    //kal_uint8 path[10];

    
    ilm_struct *ilm_ptr = NULL;

    #if defined(__FS_CARD_SUPPORT__)
         fmt_msdc_type = SD_CARD;
    #endif
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  
#if defined(__FS_CARD_SUPPORT__)
/* under construction !*/
/* under construction !*/
#if 0
/* under construction !*/
#endif /* 0 */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif /* __FS_CARD_SUPPORT__ */
/* under construction !*/
#if defined(MT6223P) && defined(__FS_CARD_SUPPORT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
#if defined(__FS_CARD2_SUPPORT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
#endif /* __FS_CARD_SUPPORT__ */
/* under construction !*/
#ifdef __OTG_ENABLE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif // TODO: remove this func
    /* notify Fmgr Service all cards are ready */
    ilm_ptr = allocate_ilm(MOD_FMT);
    ilm_ptr->msg_id = MSG_ID_MMI_FMT_CARD_READY_IND;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = NULL;
    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
}


/*****************************************************************************
 * FUNCTION
 *  fmt_main
 * DESCRIPTION
 *  fmt task message dispatcher
 * PARAMETERS
 *  ilm_ptr     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_main(ilm_struct *ilm_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#if defined(PLUTO_MMI)
    if(fmt_adv_handler(ilm_ptr))
        return;
#endif
    
    switch (ilm_ptr->msg_id)
    {
    #ifdef __OTG_ENABLE__
        case MSG_ID_OTG_MS_INSERT_IND:
            fmt_otg_insert_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_OTG_MS_REMOVE_IND:
            fmt_otg_remove_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_OTG_DISPLAY_IND:
            fmt_otg_display_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_OTG_CARD_DETECT_IND:
            fmt_otg_card_detect_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif /* __OTG_ENABLE__ */ 

    #ifdef __FS_CARD_SUPPORT__
    #if defined(__MSDC_DUAL_CARD_SWITCH__) && !(defined __MSDC_NOT_SUPPORT_HOT_PLUG__)
        case MSG_ID_MMI_FMT_MSDC_CARD_DETECT_IND:
    #endif
        case MSG_ID_MSDC_CARD_DETECT_IND:
            fmt_card_detect_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #ifndef __SLIM_FMT_MAIN__
        case MSG_ID_MMI_FMT_UNMOUNT_REQ:
            fmt_unmount_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif /* __SLIM_FMT_MAIN__ */
    #endif /* __FS_CARD_SUPPORT__ */
    #if defined(NEPTUNE_MMI)
        case MSG_ID_MMI_FMT_COPY_REQ:
            fmt_copy_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif
        case MSG_ID_MMI_FMT_FORMAT_REQ:
            fmt_format_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_MMI_FMT_FORMAT_RSP:
            fmt_format_done_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #ifdef __FS_CHECKDRIVE_SUPPORT__
        case MSG_ID_MMI_FMT_CHECK_DRIVE_REQ:
            fmt_check_drive_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif /* __FS_CHECKDRIVE_SUPPORT__ */
    #if defined(NEPTUNE_MMI)
        case MSG_ID_MMI_FMT_DELETE_REQ:
            fmt_delete_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif
        case MSG_ID_MMI_FMT_GET_MSDC_STATUS_REQ:
            fmt_get_msdc_status_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #ifdef __SIM_PLUS__
        case MSG_ID_SIM_PLUS_DETECT_IND:
            fmt_sim_plus_detect_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif

    #if defined(__FOTA_DM__)
        case MSG_ID_MMI_FMT_FOTA_INIT_REQ:
            fmt_fota_init_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_MMI_FMT_FOTA_WRITE_DATA_REQ:
            fmt_fota_write_data_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_MMI_FMT_FOTA_FINALIZE_REQ:
            fmt_fota_finalize_hdlr(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
    #endif /* defined(__FOTA_DM__)*/

#if defined (__MMI_EM_PROFILING_FS_TEST__)
        case MSG_ID_MMI_FMT_TEST_START_REQ:
            fmt_test_start_handler(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        case MSG_ID_MMI_FMT_TEST_SAVE_REQ:
            fmt_test_save_file_handler(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
#endif
        case MSG_ID_USB_MSDRV_REMOUNT_REQ:
            fmt_calculate_free_space(ilm_ptr->local_para_ptr, ilm_ptr->peer_buff_ptr);
            break;
        default:
            break;
    }
}

/*****************************************************************************
 * FUNCTION
 *  fmt_calculate_free_space
 * DESCRIPTION
 *  Receive message from USB task and to calculate free space of drive
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_calculate_free_space(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //FS_DiskInfo info;
    //kal_uint8 path[10];
    int phone = 0;
    int card = 0;
    //kal_int32 fs_ret;
		//= FS_NO_ERROR;
    ilm_struct *ilm_ptr;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Calculate phone free space */
        FMT_TRACE0(TRC_FMT_960e7465659749adb2edb3a010072598, "[FMT][REMOUNT]Calculate free space start");
	fmt_GetDiskInfo(FS_DRIVE_V_NORMAL, 2, FS_DRIVE_V_NORMAL | FS_DRIVE_I_SYSTEM, FS_DI_FREE_SPACE, &phone);

#if defined(__FS_CARD_SUPPORT__)
    //fs_ret = FS_NO_ERROR;
    fmt_GetDiskInfo(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE, FS_DI_FREE_SPACE | FS_DI_OPT_READ_PERMITTED, &card);
#endif /* __FS_CARD_SUPPORT__ */

#if defined(__FS_CARD2_SUPPORT__)
    //fs_ret = FS_NO_ERROR;
    fmt_GetDiskInfo(FS_DRIVE_V_REMOVABLE, 2, FS_NO_ALT_DRIVE, FS_DI_FREE_SPACE | FS_DI_OPT_READ_PERMITTED, &card);

#endif /* __FS_CARD2_SUPPORT__ */
    ilm_ptr = allocate_ilm(MOD_FMT);
    ilm_ptr->msg_id = MSG_ID_MMI_FMT_CALCULATE_DONE;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = NULL;

    SEND_ILM(MOD_FMT, MOD_UEM, MMI_FMT_SAP, ilm_ptr);

}

#ifdef __OTG_ENABLE__


/*****************************************************************************
 * FUNCTION
 *  fmt_otg_card_detect_hdlr
 * DESCRIPTION
 *  msdc detect message handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_otg_card_detect_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_DiskInfo info;
    kal_uint8 path[10];
    ilm_struct *ilm_ptr = NULL;
    fmt_mmi_msdc_ind_struct *param_ptr = NULL;
    usb_host_ms_media_struct *ms_ind;
    kal_uint32 *media_array;
    kal_int32 fs_ret=0;
    kal_uint8 media_size;
    kal_uint8 index;
    kal_int32 result = FS_NO_ERROR;
    kal_uint8 media_num = 0;

    kal_uint8 i=0;
    kal_uint8 drv_list[FMT_MAX_DRIVE]={0};
    kal_uint32 changed_drv_num=FMT_MAX_DRIVE;
    fmt_msdc_state_enum slot_state[MAX_OTG_SLOT]={0};
    msg_type message_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ms_ind = (usb_host_ms_media_struct*) local_para_ptr;
    media_array = (kal_uint32*) & ms_ind->media_array;
    media_size = ms_ind->media_size;

    /* prepare ilm */
    param_ptr = (fmt_mmi_msdc_ind_struct*) construct_local_para(sizeof(fmt_mmi_msdc_ind_struct), TD_CTRL | TD_RESET);
    param_ptr->type = SD_CARD;
    param_ptr->cause = fs_ret;
    param_ptr->drv_num = 0;

    /* mount the device one by one */
    for (index = 0; index < media_size; index++)
    {
        if (media_array[index] != 0)
        {
            FMT_TRACE0(TRC_FMT_34ED45EAD9D14147A873982414AE53F6, "[FMT][OTG]FS_TestMSDC start\n");
            fs_ret = FS_TestMSDC((void*)media_array[index], (BYTE *)&drv_list, (UINT*)&changed_drv_num);
            FMT_TRACE2(TRC_FMT_41D098824A56415DB6BC9F885355E706, "[FMT][OTG]FS_TestMSDC end(%d, %d)\n", fs_ret, changed_drv_num);
            if (fs_ret == FS_NO_ERROR)
            {
                for (i=0;i<changed_drv_num;i++)
                {

					fs_ret = fmt_GetDiskInfo(0, 0, 0, FS_DI_FREE_SPACE, drv_list[i]);

                    if (fs_ret >= 0)
                    {
                        fs_ret = FS_NO_ERROR;
                    }

                }
            }
            
            if (fs_ret < FS_NO_ERROR && fs_ret != FS_MSDC_MOUNT_ERROR)
            {
                result = fs_ret;
            }
            media_num++;

            ASSERT(changed_drv_num<sizeof(param_ptr->drv_letter));
            ASSERT(changed_drv_num<sizeof(drv_list));

            if (fs_ret != FS_MSDC_MOUNT_ERROR)
            {
                /* If mount fail, don't let MMI see the device. */
                for (i=0;i<changed_drv_num;i++)
                {
        		    param_ptr->drv_letter[param_ptr->drv_num]=drv_list[i];
        		    param_ptr->drv_num++;
                }
            }

            if ((fs_ret == FS_NO_ERROR) || (fs_ret == FS_DEVICE_EXPORTED_ERROR))
            {
                slot_state[index] = FMT_MSDC_STATE_PLUG_IN;
            }
            else
            {
                slot_state[index] = FMT_MSDC_STATE_PLUG_OUT;
            }
        }
    }

    if (media_num == 1)
    {
        for (i=0;i<MAX_OTG_SLOT;i++)
        {
            if (slot_state[i]!=FMT_MSDC_STATE_UNINIT)
            {
                index=i;
                break;
            }
        }
        
        if ((fs_ret == FS_NO_ERROR) || (fs_ret == FS_DEVICE_EXPORTED_ERROR))
        {
            if ((slot_state[index] == FMT_MSDC_STATE_PLUG_IN) &&
                (fmt_otg_present[index]==slot_state[index]))
            {
                /* Strange !? Plug-in Twice ?! */
                free_local_para((local_para_struct*)param_ptr);
                return;
            }
            message_id = MSG_ID_FMT_MMI_CARD_PLUG_IN_IND;
            fmt_otg_present[index] = FMT_MSDC_STATE_PLUG_IN;
            
        }
        else
        {
            if ((slot_state[index] == FMT_MSDC_STATE_PLUG_OUT) &&
                (fmt_otg_present[index]==slot_state[index]||(fmt_otg_present[index]== FMT_MSDC_STATE_UNINIT)))
            {
                /* Strange !? Plug-out Twice ?! */
                free_local_para((local_para_struct*)param_ptr);
                return;
            }
            message_id = MSG_ID_FMT_MMI_CARD_PLUG_OUT_IND;
            fmt_otg_present[index] = FMT_MSDC_STATE_PLUG_OUT;
        }
    }
    else
    {
        /* First allocate a memory for an interlayer message structure */
        if (result == FS_NO_ERROR)
        {
            kal_bool need_to_notify = KAL_FALSE;;
            
            for (i=0;i<MAX_OTG_SLOT;i++)
            {
                if ((slot_state[i]==FMT_MSDC_STATE_PLUG_IN) &&
                     fmt_otg_present[i]!=slot_state[i])
                {

                    need_to_notify = KAL_TRUE;
                }
                fmt_otg_present[i]=slot_state[i];
            }
            
            if (need_to_notify == KAL_FALSE)
            {
                /* Strange !? Plug-in Twice ?! */
                free_local_para((local_para_struct*)param_ptr);
                return;
            }
            message_id = MSG_ID_FMT_MMI_CARD_PLUG_IN_IND;

        }
        else
        {
            kal_bool need_to_notify = KAL_FALSE;;
            
            for (i=0;i<MAX_OTG_SLOT;i++)
            {
                if ((slot_state[i]==FMT_MSDC_STATE_PLUG_OUT) &&
                     fmt_otg_present[i]!=slot_state[i])
                {

                    need_to_notify = KAL_TRUE;
                }
                fmt_otg_present[i]=slot_state[i];
            }
        
            if (need_to_notify == KAL_FALSE)
            {
                /* Strange !? Plug-out Twice ?! */
                free_local_para((local_para_struct*)param_ptr);
                return;
            }        
            message_id = MSG_ID_FMT_MMI_CARD_PLUG_OUT_IND;
        }
    }

    ilm_ptr = allocate_ilm(MOD_FMT);
    ilm_ptr->msg_id = message_id;

    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
}
#endif /* __OTG_ENABLE__ */ 

#ifdef __FS_CARD_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  fmt_card_detect_hdlr
 * DESCRIPTION
 *  msdc detect message handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_card_detect_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmt_mmi_msdc_ind_struct *param_ptr = NULL;
    msdc_card_detect_ind_struct *msg_ptr;
    //FS_DiskInfo info;
    //kal_uint8 path[10];
    ilm_struct *ilm_ptr = NULL;
    kal_int32 fs_ret = FS_NO_ERROR;
    kal_uint32 msg_id;

    kal_uint8 i=0;
    kal_uint8 drv_list[FMT_MAX_DRIVE]={0};
    kal_uint32 changed_drv_num=FMT_MAX_DRIVE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* scan queue for multiple detect ind */
    msg_ptr = (msdc_card_detect_ind_struct*) local_para_ptr;

#if defined(MT6223P)
    MSDC_unsealMountOperation();
#endif

    FMT_TRACE0(TRC_FMT_E5F5C86ED75F4949AF87D9775454EFA2, "[FMT][MSDC]FS_TestMSDC start");
    fs_ret = FS_TestMSDC((void*)msg_ptr->media_array, (BYTE*)&drv_list, (UINT*)&changed_drv_num);
    FMT_TRACE2(TRC_FMT_0075DDC3E23541B38725E9B6799092A9, "[FMT][MSDC]FS_TestMSDC end(%d, %d)", fs_ret, changed_drv_num);
    if (fs_ret == FS_NO_ERROR)
    {
        for (i=0;i<changed_drv_num;i++)
        {
        	fs_ret = fmt_GetDiskInfo(0, 0, 0, FS_DI_FREE_SPACE, (int *)(drv_list + i));

            if (fs_ret >= 0)
            {
                fs_ret = FS_NO_ERROR;
            }
        }
    }
    fmt_msdc_type = SD_CARD;

    /* First allocate a memory for an interlayer message structure */
    
#if defined(__MSDC_DUAL_CARD_SWITCH__) && !(defined __MSDC_NOT_SUPPORT_HOT_PLUG__)
    FMT_TRACE2(TRC_FMT_dd4dff4ad57342618bec0fb4d72a9e03, "[FMT][MSDC] MSDC status: %d, fmt_msdc_present: %d", 
               msg_ptr->media_status, fmt_msdc_present);
    if (msg_ptr->media_status == 1)
    {
        msg_id = MSG_ID_FMT_MMI_CARD_PLUG_IN_IND;
        fmt_msdc_present = FMT_MSDC_STATE_PLUG_IN;
    }
    else
    {
        msg_id = MSG_ID_FMT_MMI_CARD_PLUG_OUT_IND;
        fmt_msdc_present = FMT_MSDC_STATE_PLUG_OUT;
    }
#else
    if ((fs_ret == FS_NO_ERROR) || (fs_ret == FS_DEVICE_EXPORTED_ERROR) || (fs_ret == FS_MSDC_MOUNT_ERROR))
    {
        if (fmt_msdc_present == FMT_MSDC_STATE_PLUG_IN)
        {
            /* Strange !? Plug-in Twice ?! */
            //work around MAUI_03332134
            //return;     
        }
        msg_id = MSG_ID_FMT_MMI_CARD_PLUG_IN_IND;
        fmt_msdc_present = FMT_MSDC_STATE_PLUG_IN;
    }
    else
    {
        if (fmt_msdc_present == FMT_MSDC_STATE_PLUG_OUT)
        {
            /* Already Plug-Out , Early Return */
            return;
        }
        msg_id = MSG_ID_FMT_MMI_CARD_PLUG_OUT_IND;
        fmt_msdc_present = FMT_MSDC_STATE_PLUG_OUT;
    }
#endif
#ifdef __J2ME__
    ilm_ptr = allocate_ilm(MOD_FMT);
    param_ptr = (fmt_mmi_msdc_ind_struct *)construct_local_para
                 (sizeof (fmt_mmi_msdc_ind_struct), TD_CTRL | TD_RESET);

    param_ptr->type = fmt_msdc_type;
    param_ptr->cause = fs_ret;
    param_ptr->drv_num = 0;

    ASSERT(changed_drv_num<sizeof(param_ptr->drv_letter));
    ASSERT(changed_drv_num<sizeof(drv_list));
	
    for (i=0;i<changed_drv_num;i++)
    {
        param_ptr->drv_letter[i]=drv_list[i];
        param_ptr->drv_num++;
    }

    ilm_ptr->msg_id = msg_id;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr =  (local_para_struct *)param_ptr;

    SEND_ILM( MOD_FMT, MOD_JASYN, MMI_L4C_SAP, ilm_ptr);
#endif /* __J2ME__ */ 

    if (fs_ret == FS_NO_ERROR)
    {
        int card = 0;
	    fmt_GetDiskInfo(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE, &card);

    }

    FMT_TRACE1(TRC_FMT_65A3C6FB1B62437B9CDA966DDB964BCF, "FS return: %d\n", fs_ret);

    ilm_ptr = allocate_ilm(MOD_FMT);
    param_ptr = (fmt_mmi_msdc_ind_struct *)construct_local_para
                  (sizeof (fmt_mmi_msdc_ind_struct), TD_CTRL | TD_RESET);

    param_ptr->type = fmt_msdc_type;
    param_ptr->cause = fs_ret;
    param_ptr->drv_num = 0;

    ASSERT(changed_drv_num<sizeof(param_ptr->drv_letter));
    ASSERT(changed_drv_num<sizeof(drv_list));
	
    for (i=0;i<changed_drv_num;i++)
    {
        param_ptr->drv_letter[i]=drv_list[i];
        param_ptr->drv_num++;
    }

    ilm_ptr->msg_id = (msg_type)msg_id;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM( MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
    return;
}

#ifndef __SLIM_FMT_MAIN__
/*****************************************************************************
 * FUNCTION
 *  fmt_unmount_hdlr
 * DESCRIPTION
 *  unmount request handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_unmount_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_unmount_req_strcut *msg_ptr;
    mmi_fmt_unmount_rsp_strcut *param_ptr;
    ilm_struct *ilm_ptr = NULL;
    kal_int32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (mmi_fmt_unmount_req_strcut*) local_para_ptr;

    fs_ret = FS_CloseMSDC(msg_ptr->index, msg_ptr->mode);

    /* First allocate a memory for an interlayer message structure */
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (mmi_fmt_unmount_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_unmount_rsp_strcut), TD_CTRL | TD_RESET);

    param_ptr->result = fs_ret;
    param_ptr->data = msg_ptr->index;

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_UNMOUNT_RSP;

    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);

    return;
}
#endif /* __SLIM_FMT_MAIN__ */
#endif /* __FS_CARD_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  fmt_get_msdc_status_hdlr
 * DESCRIPTION
 *  msdc status request handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_get_msdc_status_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_get_msdc_status_rsp_strcut *param_ptr;
    ilm_struct *ilm_ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (mmi_fmt_get_msdc_status_rsp_strcut*) construct_local_para
        (sizeof(mmi_fmt_get_msdc_status_rsp_strcut), TD_CTRL | TD_RESET);

    if (fmt_msdc_present == FMT_MSDC_STATE_PLUG_IN)
    {
        param_ptr->present = KAL_TRUE;
    }
    else if (fmt_msdc_present == FMT_MSDC_STATE_PLUG_OUT)
    {
        param_ptr->present = KAL_FALSE;
    }
    else if (fmt_msdc_present == FMT_MSDC_STATE_UNINIT)
    {
        kal_int8 drive;     
        
        drive = FS_GetDrive(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE);

        if(FS_GetDevStatus(drive, FS_MOUNT_STATE_ENUM) == FS_NO_ERROR)
        {
            param_ptr->present = KAL_TRUE;
        }
    else
    {
        param_ptr->present = KAL_FALSE;
    }
    }
    else
    {
        ASSERT(0);
    }

    param_ptr->type = fmt_msdc_type;

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_GET_MSDC_STATUS_RSP;

    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);

    return;
}

#if defined(NEPTUNE_MMI)
/*****************************************************************************
 * FUNCTION
 *  fmt_copy_hdlr
 * DESCRIPTION
 *  copy request handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_copy_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_copy_req_strcut *msg_ptr;
    mmi_fmt_copy_rsp_strcut *param_ptr;
    ilm_struct *ilm_ptr = NULL;
    kal_int32 fs_ret = 0;
    
    FS_HANDLE   fh;
    WCHAR       dest_drv[4];
    FS_DiskInfo disk_info;
    kal_uint64  free_space;
    kal_uint32  file_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (mmi_fmt_copy_req_strcut*) local_para_ptr;

    if ((msg_ptr->action != FMT_MOVE_SEVERAL) && (msg_ptr->action != FMT_COPY_SEVERAL))
    {
        fmt_need_abort = KAL_FALSE;
    }

    if (fmt_need_abort != KAL_TRUE)
    {
        kal_bool copy_enhance = KAL_FALSE;

        if (msg_ptr->recursive_buffer!=NULL && msg_ptr->recur_buffer_size!=0)
        {
            copy_enhance = KAL_TRUE;
        }

        if(msg_ptr->action == FMT_COPY || msg_ptr->action == FMT_COPY_SEVERAL ||
            msg_ptr->src_file[0] != msg_ptr->dest_file[0])
        {
            FMT_TRACE0(TRC_FMT_B34150F30F1E47E39A12BB12E4A7DFA3, "[FMT] FS_Move check free space");

            file_size = 0;
            fh = FS_Open((WCHAR*) msg_ptr->src_file, FS_READ_ONLY);
            if(fh >= 0)
            {
                if(FS_GetFileSize(fh, &file_size) < 0)
                    file_size = 0;
                FS_Close(fh);
            }
                
            free_space = 0;
            kal_wstrncpy(dest_drv, (WCHAR*)msg_ptr->dest_file, 3);
            fs_ret = FS_GetDiskInfo(dest_drv, &disk_info, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE);
            if(fs_ret >= 0)
                free_space = (kal_uint64)disk_info.FreeClusters * disk_info.SectorsPerCluster * disk_info.BytesPerSector;
            else
                file_size = 0;  // skip checking

            fs_ret = 0;
            if(file_size && free_space < file_size)
                fs_ret = FS_DISK_FULL;
        }

        if(fs_ret >= 0)
        {
            FMT_TRACE0(TRC_FMT_42D36049A36B4BF98588B6562092D286, "[FMT] FS_Move start");

            if (msg_ptr->action == FMT_COPY || msg_ptr->action == FMT_COPY_SEVERAL)
            {
                if (copy_enhance == KAL_TRUE)
                {
                    fs_ret = FS_Move((WCHAR*) msg_ptr->src_file, 
               	                      (WCHAR*) msg_ptr->dest_file, 
               	                      FS_MOVE_COPY, 
               	                      fmt_copy_rsp_hdlr, 
               	                      (BYTE *)msg_ptr->recursive_buffer, 
               	                      (kal_int32)msg_ptr->recur_buffer_size);			
                }
                else
                {
                    fs_ret = FS_Move((WCHAR*) msg_ptr->src_file, (WCHAR*) msg_ptr->dest_file, FS_MOVE_COPY, fmt_copy_rsp_hdlr, NULL, 0);
                }
            }
            else if (msg_ptr->action == FMT_MOVE || msg_ptr->action == FMT_MOVE_SEVERAL)
            {
        	    if (copy_enhance == KAL_TRUE)
        	    {
                    fs_ret = FS_Move((WCHAR*) msg_ptr->src_file, 
                                      (WCHAR*) msg_ptr->dest_file, 
                                      FS_MOVE_KILL,
                                      fmt_copy_rsp_hdlr, 
                                      (BYTE *)msg_ptr->recursive_buffer, 
                                      (kal_int32)msg_ptr->recur_buffer_size);		  
                }
                else
                {
                    fs_ret = FS_Move((WCHAR*) msg_ptr->src_file, (WCHAR*) msg_ptr->dest_file, FS_MOVE_KILL, fmt_copy_rsp_hdlr, NULL, 0);
                }
            }
            else
                ASSERT(0); 
        }
        FMT_TRACE1(TRC_FMT_0C0CC64F0ACC4F55A04D94540602D220, "[FMT] FS_Move end(%d)", fs_ret);
    }
    else
    {
        FMT_TRACE0(TRC_FMT_28B41D5DEE99429EB00ADA34F4DBCC5B, "[FMT] FS_Move abort");
        fs_ret = FS_ABORTED_ERROR;
    }

    if ((msg_ptr->action != FMT_MOVE_SEVERAL) && (msg_ptr->action != FMT_COPY_SEVERAL))
    {
        /* for single move/copy, the need abort flag should be clear in FMT;
    	   but the multi move/copy, the flag should be clear in MMI */
        fmt_need_abort = KAL_FALSE;
    }

    /* First allocate a memory for an interlayer message structure */
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (mmi_fmt_copy_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_copy_rsp_strcut), TD_CTRL | TD_RESET);

    param_ptr->result = fs_ret;

    param_ptr->callback = msg_ptr->callback;

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_COPY_RSP;

    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);

    return;
}

/*****************************************************************************
 * FUNCTION
 *  fmt_copy_rsp_hdlr
 * DESCRIPTION
 *  call back function for FS_Move
 * PARAMETERS
 *  action          [IN]        
 *  total           [IN]        
 *  completed       [IN]        
 *  handle          [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
int fmt_copy_rsp_hdlr(int action, UINT total, UINT completed, UINT handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMT_TRACE1(TRC_FMT_7C47C68C1AEF45A2A961EEF2BCC69603, "[FMT] FS_Move cb(%d)", fmt_need_abort);

    if (action == FS_MOVE_PGS_FAIL)
    {
        ilm_struct *ilm_ptr = NULL;
        mmi_fmt_op_abort_processing_ind_struct *param_ptr = NULL;
        
        ilm_ptr = allocate_ilm(MOD_FMT);

        param_ptr = (mmi_fmt_op_abort_processing_ind_struct*) construct_local_para(sizeof(mmi_fmt_op_abort_processing_ind_struct), TD_CTRL | TD_RESET);

        param_ptr->op_type = FMT_MOVE;
        param_ptr->result = FS_MOVE_PGS_FAIL;

        ilm_ptr->msg_id = MSG_ID_MMI_FMT_OP_ABORT_PROCESSING_IND;
        ilm_ptr->peer_buff_ptr = NULL;
        ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

        SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);        
    }
    else if (fmt_need_abort == KAL_TRUE)
    {
        if (handle > 0)
        {
            fmt_need_abort = KAL_FALSE;
            FS_Abort(handle);
        }
    }    
    else
    {
        /* send message to MMI to show progress */
    }
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  fmt_abort_copy
 * DESCRIPTION
 *  abort copy by MMI
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_abort_copy(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmt_need_abort = KAL_TRUE;
    FMT_TRACE0(TRC_FMT_F592C96B2CFD43D8B717136EC29D3E0C, "[FMT] abort");
}


/*****************************************************************************
 * FUNCTION
 *  fmt_get_abort_copy
 * DESCRIPTION
 *  abort copy by MMI
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool fmt_get_abort_copy(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMT_TRACE1(TRC_FMT_D78AB1AE989541A29B78B6B1AE63EEF8, "[FMT] abort=%d", fmt_need_abort);
    return fmt_need_abort;
}


/*****************************************************************************
 * FUNCTION
 *  fmt_reset_abort_copy
 * DESCRIPTION
 *  reset abort copy by MMI
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_reset_abort_copy(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmt_need_abort = KAL_FALSE;
    FMT_TRACE0(TRC_FMT_BE79F490C01440AAA1C436C2ACF1A7C6, "[FMT] reset_abort");
}
#endif /* NEPTUNE_MMI */

/*****************************************************************************
 * FUNCTION
 *  fmt_format_hdlr
 * DESCRIPTION
 *  format request handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_format_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_format_req_strcut *msg_ptr;
    ilm_struct *ilm_ptr = NULL;
    kal_int32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (mmi_fmt_format_req_strcut*) local_para_ptr;

    g_fmt_format_drive = msg_ptr->drive;
    g_fmt_format_callback = msg_ptr->callback;
    g_fmt_format_userdata = msg_ptr->user_data;
    if (msg_ptr->drive != 0)
    {
    #if (defined (MMS_SUPPORT) && !defined (APP_STORAGE_IN_SYS_DRV))
        /* not allow format public drive before WAP ready */
        if ((wap_is_init() == KAL_TRUE || !mma_is_ready_for_format(g_fmt_format_drive)))
        {
            fs_ret = FS_DEVICE_BUSY;
        }
        else
    #endif /* (defined (MMS_SUPPORT) && !defined (APP_STORAGE_IN_SYS_DRV)) */ 
        {
            kal_uint8 drive[20];

            kal_wsprintf((WCHAR*) drive, "\\\\.\\%c:", msg_ptr->drive);
            fs_ret = FS_GeneralFormat((WCHAR*) drive, msg_ptr->level, NULL);
        }
    }
    else
    {
        fs_ret = FS_DRIVE_NOT_FOUND;
    }

#if defined(__FS_CARD_SUPPORT__)
    if (fs_ret  >= FS_NO_ERROR)
    {
        int card;
        kal_uint8 path[10];
        FS_DiskInfo info;

        card = FS_GetDrive(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE);

        if (card >= FS_NO_ERROR && card == msg_ptr->drive)
        {
            kal_wsprintf((WCHAR*) path, "%c:\\", card);

            FS_GetDiskInfo((WCHAR*) path, &info, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE);
        }
    }
#endif /* defined(__FS_CARD_SUPPORT__) */

#if defined(__FS_CARD2_SUPPORT__)
    if (fs_ret  >= FS_NO_ERROR)
    {
        int card;
        kal_uint8 path[10];
        FS_DiskInfo info;

        card = FS_GetDrive(FS_DRIVE_V_REMOVABLE, 2, FS_NO_ALT_DRIVE);

        if (card >= FS_NO_ERROR && card == msg_ptr->drive)
        {
            kal_wsprintf((WCHAR*) path, "%c:\\", card);

            FS_GetDiskInfo((WCHAR*) path, &info, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE);
        }
    }
#endif /* defined(__FS_CARD2_SUPPORT__) */


#ifdef MMS_SUPPORT /*GH_V02*/
    if (fs_ret >= FS_NO_ERROR)
    {
        mmi_fmt_format_req_strcut *param_ptr;

        /* First allocate a memory for an interlayer message structure */
        ilm_ptr = allocate_ilm(MOD_FMT);

        param_ptr = (mmi_fmt_format_req_strcut*) construct_local_para(sizeof(mmi_fmt_format_req_strcut), TD_CTRL | TD_RESET);

        param_ptr->drive = msg_ptr->drive;
        param_ptr->level = msg_ptr->level;

        ilm_ptr->msg_id = MSG_ID_MMI_FMT_FORMAT_REQ;

        ilm_ptr->peer_buff_ptr = NULL;
        ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

        SEND_ILM(MOD_FMT, mms_get_service_module(MSG_ID_MMI_FMT_FORMAT_REQ), MMI_L4C_SAP, ilm_ptr);
    }
    else
#endif /* MMS_SUPPORT */ 
    {
        mmi_fmt_format_rsp_strcut *param_ptr;

    #ifdef __IMPS__
        {
            /* Send format response to IMPS. */
            /* First allocate a memory for an interlayer message structure */
            ilm_ptr = allocate_ilm(MOD_FMT);

            param_ptr = (mmi_fmt_format_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_format_rsp_strcut), TD_CTRL | TD_RESET);
    
            param_ptr->result = fs_ret;
            param_ptr->data = msg_ptr->drive;
    
            ilm_ptr->msg_id = MSG_ID_MMI_FMT_FORMAT_RSP;
    
            ilm_ptr->peer_buff_ptr = NULL;
            ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;
    
            SEND_ILM(MOD_FMT, MOD_IMPS, MMI_L4C_SAP, ilm_ptr);
        }
    #endif /* __IMPS__ */

        {
            /* First allocate a memory for an interlayer message structure */
            ilm_ptr = allocate_ilm(MOD_FMT);

            param_ptr = (mmi_fmt_format_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_format_rsp_strcut), TD_CTRL | TD_RESET);

            param_ptr->result = fs_ret;
            param_ptr->data = msg_ptr->drive;
            param_ptr->callback = msg_ptr->callback;
            param_ptr->user_data = msg_ptr->user_data;

            ilm_ptr->msg_id = MSG_ID_MMI_FMT_FORMAT_RSP;

            ilm_ptr->peer_buff_ptr = NULL;
            ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

            SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
        }

    }

    return;
#endif	
}


/*****************************************************************************
 * FUNCTION
 *  fmt_format_done_hdlr
 * DESCRIPTION
 *  format done handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_format_done_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
#ifndef __MMI_FMGR_HIDE_FORMAT_DRIVE__

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_format_rsp_strcut *msg_ptr;
    mmi_fmt_format_rsp_strcut *param_ptr;
    ilm_struct *ilm_ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (mmi_fmt_format_rsp_strcut*) local_para_ptr;

#ifdef __IMPS__
    {
        /* Send format response to IMPS. */
        /* First allocate a memory for an interlayer message structure */
        ilm_ptr = allocate_ilm(MOD_FMT);

        param_ptr = (mmi_fmt_format_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_format_rsp_strcut), TD_CTRL | TD_RESET);

        param_ptr->result = msg_ptr->result;
        param_ptr->data = g_fmt_format_drive;

        ilm_ptr->msg_id = MSG_ID_MMI_FMT_FORMAT_RSP;

        ilm_ptr->peer_buff_ptr = NULL;
        ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

        SEND_ILM(MOD_FMT, MOD_IMPS, MMI_L4C_SAP, ilm_ptr);
    }
#endif /* __IMPS__ */

    {
        /* First allocate a memory for an interlayer message structure */
        ilm_ptr = allocate_ilm(MOD_FMT);

        param_ptr = (mmi_fmt_format_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_format_rsp_strcut), TD_CTRL | TD_RESET);

        param_ptr->result = msg_ptr->result;
        param_ptr->data = g_fmt_format_drive;
        param_ptr->callback = g_fmt_format_callback;
        param_ptr->user_data = g_fmt_format_userdata;

        ilm_ptr->msg_id = MSG_ID_MMI_FMT_FORMAT_RSP;

        ilm_ptr->peer_buff_ptr = NULL;
        ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

        SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
    }


    return;
#endif	
}

#ifdef __FS_CHECKDRIVE_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  fmt_check_drive_hdlr
 * DESCRIPTION
 *  check drive request handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_check_drive_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_check_drive_req_strcut *msg_ptr;
    mmi_fmt_check_drive_rsp_strcut *param_ptr;
    ilm_struct *ilm_ptr = NULL;
    kal_int32 fs_ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (mmi_fmt_check_drive_req_strcut*) local_para_ptr;

    if (msg_ptr->drive != 0)
    {
        //#ifdef APPMEM_SUPPORT 
        //kal_uint8 *buffer;
        /*kal_int32 len;

        len = FS_GetCheckBufferSize(msg_ptr->drive);
        if (len > FMT_MAX_BUFFER_SIZE)
        {
            len = FMT_MAX_BUFFER_SIZE;
        }*/
        /* buffer = kal_app_mem_alloc(len, KAL_APPMEM_FUNC, MOD_FMT);
           if (buffer == NULL)
           fs_ret = FS_FAIL_GET_MEM;
           else */
        {
            fs_ret = FS_CheckDrive(msg_ptr->drive, g_fmt_buffer, FMT_MAX_BUFFER_SIZE);
            /* kal_app_mem_free (buffer); */
        }
        // #endif
    }
    else
    {
        fs_ret = FS_DRIVE_NOT_FOUND;
    }

    /* First allocate a memory for an interlayer message structure */
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (mmi_fmt_check_drive_rsp_strcut*) construct_local_para
        (sizeof(mmi_fmt_check_drive_rsp_strcut), TD_CTRL | TD_RESET);

    param_ptr->result = fs_ret;
    param_ptr->user_data = msg_ptr->user_data;
    param_ptr->callback = msg_ptr->callback;

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_CHECK_DRIVE_RSP;

    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);

    return;
}
#endif /* __FS_CHECKDRIVE_SUPPORT__ */ 

#if defined(NEPTUNE_MMI)
/*****************************************************************************
 * FUNCTION
 *  fmt_delete_hdlr
 * DESCRIPTION
 *  delete request handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_delete_hdlr(local_para_struct *in_local_para_ptr, peer_buff_struct *in_peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmt_delete_req_strcut   *msg_ptr;
    mmi_fmt_delete_rsp_strcut   *param_ptr;
    ilm_struct                  *ilm_ptr;
    kal_int32                   fs_ret = 0;
    kal_uint16                  path_len;
    peer_buff_struct            *peer_buff_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (mmi_fmt_delete_req_strcut*) in_local_para_ptr;

    if (msg_ptr->type == FMT_DELETE_FOLDER)
    {
        if (msg_ptr->recursive_buffer && msg_ptr->recur_buffer_size!=0)
        {
            fs_ret = FS_XDelete((WCHAR*) msg_ptr->path, FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE, 
 				                 msg_ptr->recursive_buffer, msg_ptr->recur_buffer_size);		        
        }
        else
        {
            fs_ret = FS_XDelete((WCHAR*) msg_ptr->path, FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE, NULL, 0);
        }
        fmt_need_abort = KAL_FALSE;
    }
    else if (msg_ptr->type == FMT_DELETE_ALL)
    {
#if defined(NEPTUNE_MMI)
        if (!FMGR_FILTER_IS_SET(((FMGR_FILTER*) (msg_ptr->filter)), FMGR_TYPE_ALL))
        {
            fs_ret = fmt_delete_by_filter_hdlr(msg_ptr->path, (void*) msg_ptr->filter, NULL);
        }
        else
#endif
        {
            fs_ret = FS_XDelete((WCHAR*) msg_ptr->path, FS_FILE_TYPE, NULL, 0);
        }
        fmt_need_abort = KAL_FALSE;
    }
    else if (msg_ptr->type == FMT_DELETE_ALL_BY_FILTER)
    {
        fs_ret = fmt_delete_by_filter_hdlr(msg_ptr->path, (void*) msg_ptr->filter, (CheckFilterFuncPtr)msg_ptr->check_callback);
    }
    else if (msg_ptr->type == FMT_DELETE_SINGLE)        
    {
        fs_ret = FS_Delete((WCHAR*) msg_ptr->path);
        fmt_need_abort = KAL_FALSE;
    }
#if defined(PLUTO_MMI)
    else if (msg_ptr->type == FMT_DELETE_SEVERAL)
    {
        fs_ret = FS_Delete((WCHAR*) msg_ptr->path);
    }
#endif

    //fmt_need_abort = KAL_FALSE;

    /* First allocate a memory for an interlayer message structure */
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (mmi_fmt_delete_rsp_strcut*) construct_local_para(sizeof(mmi_fmt_delete_rsp_strcut), TD_CTRL | TD_RESET);

    param_ptr->result = fs_ret;
    param_ptr->callback = msg_ptr->callback;

    /* copy path, response back */
    path_len = kal_wstrlen((kal_wchar*)msg_ptr->path);
    peer_buff_ptr = construct_peer_buff((kal_uint16)((path_len+1)*2), 0, 0, TD_RESET);
    param_ptr->path = (kal_wchar*)get_pdu_ptr(peer_buff_ptr, &path_len);
    kal_wstrcpy((kal_wchar*)param_ptr->path, (kal_wchar*)msg_ptr->path);

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_DELETE_RSP;

    ilm_ptr->peer_buff_ptr = peer_buff_ptr;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);

    return;
}

/*****************************************************************************
 * FUNCTION
 *  fmt_delete_by_filter_hdlr
 * DESCRIPTION
 *  delete file according to filter
 * PARAMETERS
 *  path            [?]     
 *  filter_mask     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
kal_int32 fmt_delete_by_filter_hdlr(kal_uint8 *path, void *filter_mask, CheckFilterFuncPtr check_callback)
{
#if defined(PLUTO_MMI) || defined(NEPTUNE_MMI)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_DOSDirEntry  file_info;
    FS_HANDLE       handle;
    kal_int32       fs_ret;
    kal_wchar       *new_path;
    kal_wchar       *file_name;
    kal_uint8       i;
    kal_int8        file_read_only;

#if defined(PLUTO_MMI)
    kal_int8        result;
    kal_int32       ext_loc;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    new_path = (kal_wchar*)get_ctrl_buffer((kal_wstrlen((kal_wchar*)path) + 5)*2);
    kal_wstrcpy(new_path, (kal_wchar*) path);
    kal_wstrcat(new_path, (kal_wchar*) L"*.*");
#if defined(PLUTO_MMI)
    file_name = (kal_wchar*)get_ctrl_buffer(256*2);
    handle = FS_FindFirst((WCHAR*) new_path, 0, 0, &file_info, (WCHAR*) file_name, 255);
#else
    file_name = (kal_wchar*)get_ctrl_buffer((FMT_MAX_FILE_LEN+1)*2);
    handle = FS_FindFirst((WCHAR*) new_path, 0, 0, &file_info, (WCHAR*) file_name, FMT_MAX_FILE_LEN);
#endif
    free_ctrl_buffer(new_path);

    if (handle < 0)
    {
        free_ctrl_buffer(file_name);
        return FS_NO_ERROR;
    }

    fs_ret = FS_SetCurrentDir((WCHAR*) path);
    if (fs_ret < 0)
    {
        FS_FindClose(handle);
        free_ctrl_buffer(file_name);
        return fs_ret;
    }

    i = 0;
    file_read_only = KAL_FALSE;
    while (1)
    {
#if defined(PLUTO_MMI)
        /* find extension */
        ext_loc = kal_wstrlen(file_name);
        while(ext_loc && file_name[ext_loc] != '.')
            ext_loc--;

        if(ext_loc)
            result = check_callback(filter_mask, FMT_DELETE_ALL_BY_FILTER, (kal_int8*)(file_name + ext_loc + 1));
        else
            result = KAL_FALSE;
        i++;

        if (result==KAL_TRUE)
        {
            fs_ret = FS_Delete((WCHAR*) file_name);
            if (fs_ret != FS_READ_ONLY_ERROR)
            {
                if (fs_ret < 0)
                    goto end_delete;
            }
            else
            {
                file_read_only = KAL_TRUE;
            }
        }
        fs_ret = FS_FindNext(handle, &file_info, (WCHAR*) file_name, 255);
#else
        for (i = 0; i < FMGR_MAX_FILTER_COUNT; i++)
        {
            if (FMGR_FILTER_IS_SET((FMGR_FILTER*)filter_mask, fmgr_filter[i].type))
            {
                if ( (strncmp((char*)file_info.Extension, (char*)fmgr_filter[i].ext, 3) == 0) ||
                	    ((strlen((char*)fmgr_filter[i].ext) == 2) && 
                	     (strncmp((char*)file_info.Extension, (char*)fmgr_filter[i].ext, 2) == 0 )))
                {
                    fs_ret = FS_Delete((WCHAR*) file_name);
                    if (fs_ret != FS_READ_ONLY_ERROR)
                    {
                        if (fs_ret < 0)
                            goto end_delete;
                    }
                    else
                    {
                        file_read_only = KAL_TRUE;
                    }
                    break;
                }
            }
        }
        fs_ret = FS_FindNext(handle, &file_info, (WCHAR*) file_name, FMT_MAX_FILE_LEN);
#endif

        if (fs_ret < 0 || fmt_need_abort == KAL_TRUE)
        {
            break;
        }
    }

    if (file_read_only == KAL_TRUE)
    {
        fs_ret = FS_READ_ONLY_ERROR;
    }
    else if (fmt_need_abort == KAL_TRUE)
    {
        fs_ret = FS_ABORTED_ERROR;
    }
    else
    {
        fs_ret = FS_NO_ERROR;
    }

end_delete:
    /* reset current dir */
    kal_wstrncpy((kal_wchar*)file_name, (kal_wchar*)path, 3);
    FS_SetCurrentDir((kal_wchar*)file_name);

    FS_FindClose(handle);
    free_ctrl_buffer(file_name);
    return fs_ret;
#else
    return 0;
#endif
}
#endif /* NEPTUNE_MMI */

#ifdef __OTG_ENABLE__

extern kal_uint8 USBHost_Media_Handle[];
extern FS_Driver FS_OTGDrv;


/*****************************************************************************
 * FUNCTION
 *  fmt_otg_insert_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_otg_insert_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 fs_ret;
    void *array[USB_HOST_MS_SUPPORT_LUN];
    int i, done;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* IT's hard code HERE */
    for (i = 0; i < USB_HOST_MS_SUPPORT_LUN; i++)
    {
        array[i] = &(USBHost_Media_Handle[i]);
    }
    fs_ret = FS_ConfigExtDevice(FS_SETUP_EXT_DEVICE, &FS_OTGDrv, USB_HOST_MS_SUPPORT_LUN, array, &done);
    FMT_TRACE2(TRC_FMT_676A85A95F8B4E2C868477926E163A64, "fmt call FS_ConfigExtDevice get (%d), done = %d \n", fs_ret, done);
}


/*****************************************************************************
 * FUNCTION
 *  fmt_otg_remove_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_otg_remove_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 fs_ret;
    void *array[USB_HOST_MS_SUPPORT_LUN];
    int i, done;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* IT's hard code HERE */
    for (i = 0; i < USB_HOST_MS_SUPPORT_LUN; i++)
    {
        array[i] = &(USBHost_Media_Handle[i]);
    }
    fs_ret = FS_ConfigExtDevice(FS_RELEASE_EXT_DEVICE, &FS_OTGDrv, USB_HOST_MS_SUPPORT_LUN, array, &done);
    FMT_TRACE2(TRC_FMT_676A85A95F8B4E2C868477926E163A64, "fmt call FS_ConfigExtDevice get (%d), done = %d \n", fs_ret, done);
}


/*****************************************************************************
 * FUNCTION
 *  fmt_otg_display_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_otg_display_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ilm_struct *ilm_ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    hold_local_para(local_para_ptr);

    ilm_ptr = allocate_ilm(MOD_FMT);
    ilm_ptr->msg_id = MSG_ID_FMT_MMI_OTG_DISPLAY_IND;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = local_para_ptr;

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
}
#endif /* __OTG_ENABLE__ */ 


#ifdef __SIM_PLUS__
/*****************************************************************************
 * FUNCTION
 *  fmt_sim_plus_detect_hdlr
 * DESCRIPTION
 *  sim plus detect message handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_sim_plus_detect_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    msdc_card_detect_ind_struct *msg_ptr;
    ilm_struct *ilm_ptr = NULL;
    kal_int32 fs_ret = FS_NO_ERROR;
    kal_uint32 msg_id;

    fmt_mmi_msdc_ind_struct *param_ptr = NULL;
    kal_uint8 i=0;
    kal_uint8 drv_list[FMT_MAX_DRIVE]={0};
    kal_uint32 changed_drv_num=FMT_MAX_DRIVE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* scan queue for multiple detect ind */
    msg_ptr = (msdc_card_detect_ind_struct*) local_para_ptr;
    FMT_TRACE0(TRC_FMT_5D5EB1CF24E94312BF3DDA63D2F65035, "[FMT][SIM+]FS_TestMSDC start\n");
    fs_ret = FS_TestMSDC((void*)msg_ptr->media_array,(BYTE*)&drv_list, (UINT*)&changed_drv_num);
    FMT_TRACE2(TRC_FMT_19121A2CC0A64B2281697485CB4A5FF0, "[FMT][SIM+]FS_TestMSDC end(%d, %d)\n", fs_ret, changed_drv_num);

    ilm_ptr = allocate_ilm(MOD_FMT);
    ilm_ptr->msg_id = MSG_ID_FMT_MMI_SIM_PLUS_DETECT_IND;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr =  (local_para_struct *)param_ptr;
	
    param_ptr = (fmt_mmi_msdc_ind_struct *)construct_local_para
                  (sizeof (fmt_mmi_msdc_ind_struct), TD_CTRL | TD_RESET);

    param_ptr->type = SD_CARD;
    param_ptr->cause = fs_ret;
    param_ptr->drv_num = 0;

    ASSERT(changed_drv_num<sizeof(param_ptr->drv_letter));
    ASSERT(changed_drv_num<sizeof(drv_list));
	
    for (i=0;i<changed_drv_num;i++)
    {
        param_ptr->drv_letter[i]=drv_list[i];
        param_ptr->drv_num++;
    }

    SEND_ILM( MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
    return;
}
#endif

#if defined(__FOTA_DM__)
/*****************************************************************************
 * FUNCTION
 *  fmt_fota_init_hdlr
 * DESCRIPTION
 *  FOTA initialize handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_fota_init_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmt_fota_init_rsp_struct *param_ptr;
    ilm_struct *ilm_ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (fmt_fota_init_rsp_struct*) construct_local_para
        (sizeof(fmt_fota_init_rsp_struct), TD_CTRL | TD_RESET);

#ifdef __MTK_TARGET__
    param_ptr->result = FOTA_Initialize();
    if(ERROR_FOTA_SUCCESS == param_ptr->result)
    {
        param_ptr->result = FOTA_ClearPackageReservoir();
    }
#else
    g_fhandle = FS_Open(L"c:\\test.txt", FS_CREATE_ALWAYS | FS_READ_WRITE );
    
    if (g_fhandle < FS_NO_ERROR)
    {
        FS_Close(g_fhandle);
        return ;
    }
    param_ptr->result = 0;    
#endif /* __MTK_TARGET__ */

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_FOTA_INIT_RSP;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    FMT_TRACE1(TRC_FMT_3CCB9F5B75E74FBA97769480580ED767, "fmt fota_init result = %d \n", param_ptr->result);

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  fmt_fota_write_data_hdlr
 * DESCRIPTION
 *  FOTA write data handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_fota_write_data_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmt_fota_write_data_req_struct *msg_ptr; 
    fmt_fota_write_data_rsp_struct *param_ptr;
    ilm_struct *ilm_ptr = NULL;

    kal_int32 write_result = 0;
    kal_uint32 write_len; 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (fmt_fota_write_data_req_struct*) local_para_ptr;
    
    ilm_ptr = allocate_ilm(MOD_FMT);

    param_ptr = (fmt_fota_write_data_rsp_struct*) construct_local_para
        (sizeof(fmt_fota_write_data_rsp_struct), TD_CTRL | TD_RESET);

#ifdef __MTK_TARGET__
    param_ptr->result = FOTA_WriteData(msg_ptr->length, msg_ptr->pkg_buffer);
    {
        extern kal_int32 FOTA_Start_Download_State(void);
        extern kal_bool FUE_NFB_Is_Download_Complete(void);

        if(ERROR_FOTA_SUCCESS == param_ptr->result)
        {
            if( FUE_NFB_Is_Download_Complete() )
            {
                param_ptr->result = FOTA_Start_Download_State();
            }
        }
    }
#else
    if ((write_result = FS_Write(g_fhandle, msg_ptr->pkg_buffer, msg_ptr->length, (kal_uint32*) & write_len)) == FS_NO_ERROR)
    {
   	    param_ptr->result = 0;    
    }
    else
    {
        FS_Close(g_fhandle);
	    param_ptr->result = write_result;
    }
#endif /* #ifdef __MTK_TARGET__ */

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_FOTA_WRITE_DATA_RSP;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;

    FMT_TRACE1(TRC_FMT_E787D0ED27564BC192E600101846F40C, "fmt fota_write_data result = %d \n", param_ptr->result);

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  fmt_fota_finalize_hdlr
 * DESCRIPTION
 *  FOTA finalize handler
 * PARAMETERS
 *  local_para_ptr      [?]     
 *  peer_buff_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void fmt_fota_finalize_hdlr(local_para_struct *local_para_ptr, peer_buff_struct *peer_buff_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fmt_fota_finalize_req_struct *msg_ptr; 
    fmt_fota_finalize_rsp_struct *param_ptr;
    ilm_struct *ilm_ptr = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_ptr = (fmt_fota_finalize_req_struct*) local_para_ptr;
        
    ilm_ptr = allocate_ilm(MOD_FMT);
    
    param_ptr = (fmt_fota_finalize_rsp_struct*) construct_local_para
        (sizeof(fmt_fota_finalize_rsp_struct), TD_CTRL | TD_RESET);

#ifdef __MTK_TARGET__
    param_ptr->result = FOTA_Finalize();
    {
        extern kal_int32 FOTA_Start_Update_State(void);

        if(ERROR_FOTA_SUCCESS == param_ptr->result)
        {
            param_ptr->result = FOTA_Start_Update_State();
        }
    }
#else
    FS_Close(g_fhandle);
    param_ptr->result = 0;
#endif /* __MTK_TARGET__ */

    ilm_ptr->msg_id = MSG_ID_MMI_FMT_FOTA_FINALIZE_RSP;
    ilm_ptr->peer_buff_ptr = NULL;
    ilm_ptr->local_para_ptr = (local_para_struct*) param_ptr;
    FMT_TRACE1(TRC_FMT_60EE8AF92E794DE2B0AB6F14DD65F746, "fmt fota_finalize result = %d \n", param_ptr->result);

    SEND_ILM(MOD_FMT, MOD_MMI, MMI_L4C_SAP, ilm_ptr);
    return;
}

#endif /* defined(__FOTA_DM__) */

#define FMT_INT_QUEUE_FUNC

#if defined(PLUTO_MMI)
static kal_bool fmt_int_queue_push(ilm_struct *ilm_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_fmt_cur_int_queue_count == FMT_MAX_INT_QUEUE_COUNT || ilm_ptr == NULL)
    {
        /* INT Queue full */
        return KAL_FALSE;
    }
    
    /* Copy content */
    memcpy(&g_fmt_int_queue[g_fmt_cur_int_queue_count], ilm_ptr, sizeof(ilm_struct));
    g_fmt_cur_int_queue_count++;

    return KAL_TRUE;
}

static void fmt_int_queue_pop(ilm_struct *ilm_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_int32 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (ilm_ptr == NULL || g_fmt_cur_int_queue_count == 0)
    {
        memset(ilm_ptr, 0, sizeof(ilm_struct));
        return;
    }

    /* Copy content */
    memcpy(ilm_ptr, &g_fmt_int_queue[0], sizeof(ilm_struct));

    /* Shrink elements */
    for (i = 1; i < g_fmt_cur_int_queue_count; i++)
    {
        memcpy(&g_fmt_int_queue[i-1], &g_fmt_int_queue[i], sizeof(ilm_struct));
    }

    g_fmt_cur_int_queue_count--;
    memset(&g_fmt_int_queue[g_fmt_cur_int_queue_count], 0, sizeof(ilm_struct));
}

static kal_bool fmt_fetch_msg_to_int_q(ilm_struct *ilm_ptr)
{
    /* Check ilm */
    if (fmt_adv_is_ilm_valid(ilm_ptr))
    {
        FMT_TRACE1(TRC_FMT_FETCH_MSG_VALID_Q, "[FMT] fmt_fetch_msg_to_int_q, valid? %d", 1);
        hold_peer_buff(ilm_ptr->peer_buff_ptr);
        hold_local_para(ilm_ptr->local_para_ptr);
        
        /* push ilm into internal queue */
        if (!fmt_int_queue_push(ilm_ptr))
        {
            return KAL_FALSE;
        }
    }
    else
    {
        /* Let adv handler to run ABORT or DISCARD case */
        FMT_TRACE1(TRC_FMT_FETCH_MSG_VALID_Q, "[FMT] fmt_fetch_msg_to_int_q, valid? %d", 0);
        fmt_adv_int_queue_abort_hdlr(ilm_ptr);
    }
    return KAL_TRUE;
}

void fmt_move_ext_q_to_int_q(kal_msgqid task_ext_qid, kal_bool wait)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 queue_node_number = 0;
    ilm_struct current_ilm;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMT_TRACE2(TRC_FMT_INT_Q_NUM, "[FMT] INT Queue number (%d,%d)", g_fmt_cur_int_queue_count, 0);
    if (g_fmt_cur_int_queue_count == FMT_MAX_INT_QUEUE_COUNT)
    {
        /* INT queue full */
        return;
    }

    /* Get Total count in external queue */
    msg_get_ext_queue_info(task_ext_qid, &queue_node_number);
    FMT_TRACE1(TRC_FMT_EXT_TO_INT_QUEUE_NUM, "[FMT] fmt_move_ext_q_to_int_q - queue num %d", queue_node_number);
    while (queue_node_number > 0 && (g_fmt_cur_int_queue_count < FMT_MAX_INT_QUEUE_COUNT))
    {
        receive_msg_ext_q(task_ext_qid, &current_ilm);
        if (!fmt_fetch_msg_to_int_q(&current_ilm))
        {
            free_ilm(&current_ilm);
            break;
        }
        free_ilm(&current_ilm);

        queue_node_number--;
    }

    FMT_TRACE2(TRC_FMT_INT_Q_NUM, "[FMT] INT Queue number (%d,%d)", g_fmt_cur_int_queue_count, 1);
    if (g_fmt_cur_int_queue_count == 0 && wait)
    {
        receive_msg_ext_q(task_ext_qid, &current_ilm);
        fmt_fetch_msg_to_int_q(&current_ilm);
        free_ilm(&current_ilm);
    }
}

void fmt_clear_invalid_ilm_from_int_q(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint16 free_bit = 0x0000, free_mask = 0x0000;
    kal_uint32 i = 0, reset_count = 0;
    kal_int32 free_index_p = 0, new_index = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMT_TRACE2(TRC_FMT_CLEAR_INT_Q_NUM, "[FMT] fmt_clear_invalid_ilm_from_int_q - INT Queue number (%d,%d)", g_fmt_cur_int_queue_count, 0);
    for (i = 0; i < g_fmt_cur_int_queue_count; i++)
    {
        /* Initialize */
        free_mask = 0x0000;

        if (!fmt_adv_is_ilm_valid(&g_fmt_int_queue[i]))
        {
            /* Invalid ilm */
            free_bit |= (1 << i);
            free_index_p = i;
            /* Let adv handler to run ABORT or DISCARD case */
            fmt_adv_int_queue_abort_hdlr(&g_fmt_int_queue[i]);
            free_ilm(&g_fmt_int_queue[i]);
            memset(&g_fmt_int_queue[i], 0, sizeof(ilm_struct));
            reset_count++;
        }
        else
        {
            /* Move valid ilm */
            if (reset_count > 0)
            {
                free_mask |= 1 << free_index_p;
                if ((free_bit & free_mask) == 1)
                {
                    new_index = free_index_p;
                    ASSERT(new_index > -1);
                    memcpy(&g_fmt_int_queue[new_index], &g_fmt_int_queue[i], sizeof(ilm_struct));
                    memset(&g_fmt_int_queue[i], 0, sizeof(ilm_struct));
                    free_index_p++;
                    /* Modified free_bit 
                       1. Clear the used free bit 
                       2. Set free bit into that moved slot */
                    free_bit &= ~(free_mask);
                    free_bit |= (1 << i);
                }
            }
        }
    }

    g_fmt_cur_int_queue_count -= reset_count;
    FMT_TRACE2(TRC_FMT_CLEAR_INT_Q_NUM, "[FMT] fmt_clear_invalid_ilm_from_int_q - INT Queue number (%d,%d)", g_fmt_cur_int_queue_count, 1);
}
#endif /* PLUTO_MMI */
#endif /* FMT_NOT_PRESENT */ 

