/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
*
* Filename:
* ---------
*  CallLogLayout.c
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  
*
* Author:
* -------
 * -------
*                      
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
*
 * removed!
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/

/*----------------------------------------------------------------------------*/
/* Comments                                                                   */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Include                                                                    */
/*----------------------------------------------------------------------------*/
#include "MMI_features.h"
#include "wgui_touch_screen.h"  /* mmi_tap_type_enum */
#include "UcmGprot.h"

#include "gui_typedef.h"
#include "wgui_categories_list.h"
#include "MMIDataType.h"

#if defined(__MMI_TELEPHONY_SUPPORT__) || defined(__MMI_BT_PBAP_CLIENT__)


#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_history_gprot.h"
#include "gui_data_types.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "GlobalResDef.h"
#include "mmi_rp_app_mainmenu_def.h"
#include "string.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "MMI_common_app_trc.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_util.h"
#include "wgui_categories_list.h"

#include "CustDataRes.h"
#include "Unicodexdcl.h"
#include "GlobalConstants.h"
#include "app_datetime.h"
#include "wgui.h"
#include "wgui_include.h"
#include "wgui_categories.h"
#include "CommonScreensResDef.h"
#include "Menucuigprot.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_rp_app_uiframework_def.h"

#include "custom_calllog.h"
#include "CallLogSrvGprot.h"
#include "CallLogSrvIprot.h"
#include "CallLogConfig.h"
#include "CallLogGprot.h"
#include "CallLogProt.h"
#include "CallLogLayout.h"
#include "CallLogViewer.h"
#include "mmi_rp_app_calllog_def.h"

#include "PbapSrvGprot.h"
#ifdef __MMI_BT_PBAP_CLIENT__
#include "gui_typedef.h"
#include "wgui_categories_CM.h"

#include"custom_mmi_default_value.h"
#include "DateTimeType.h"
#include "app_datetime.h"
#include "PbapSrvGprot.h"
#include "CallLogAdpProt.h"
#include "mmi_rp_app_bluetooth_def.h"
#include "phbpbapsrvGprot.h"
#include "CallLogAdpprot.h"
#include "BtcmSrvGprot.h"
#include "calllogAdppbapc.h"
#include "mmi_rp_app_phonebook_def.h"
#include "BTNotiSrvGprot.h"
#endif

#ifdef __MMI_NCENTER_SUPPORT__
#include "Vsrv_ncenter.h"
#endif

#ifndef __MMI_UNIFIED_COMPOSER__
#ifdef __MMI_MMS__
#include "mms_api.h"
#endif 
#endif /* __MMI_UNIFIED_COMPOSER__ */ 
#include "MMI_common_app_trc.h"
#include "BTMMIScrGprots.h"
#include "pbapSrvgprot.h"
/*----------------------------------------------------------------------------*/
/* Constant                                                                   */
/*----------------------------------------------------------------------------*/
#define  MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED       (0x0004)

#define  MMI_CLOG_LT_BIT_PER_BYTE      (8)
#define  MMI_CLOG_LT_BIT_SHIFT         (3)
#define  MMI_CLOG_LT_BIT_MASK_BYTE     ((SRV_CLOG_LOG_MAX_NUM + MMI_CLOG_LT_BIT_PER_BYTE - 1) / MMI_CLOG_LT_BIT_PER_BYTE)
/*----------------------------------------------------------------------------*/
/* Macro                                                                      */
/*----------------------------------------------------------------------------*/
#if defined (__MMI_BTD_BOX_UI_STYLE__) && defined (__MMI_BT_PBAP_CLIENT__)
#ifndef __MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__
#define __MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__
#endif /*__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__ */ 
#endif /* */ 



/*----------------------------------------------------------------------------*/
/* typedef                                                                    */
/*----------------------------------------------------------------------------*/

typedef FuncPtr MMI_CLOG_LT_TAB_HDLR;

#ifdef __MMI_FTE_SUPPORT__
typedef GUIIconbarItemCallback MMI_CLOG_LT_TB_HDLR;
#endif /* __MMI_FTE_SUPPORT__ */ 


#if defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)
typedef void (*MMI_CLOG_LT_TAP_HDLR) (mmi_tap_type_enum tap_type, S32 index);
#endif /*defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)*/


/*----------------------------------------------------------------------------*/
/* Enum                                                                       */
/*----------------------------------------------------------------------------*/
#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)

typedef enum
{
    MMI_CLOG_LT_TB_ID_MAKE_CALL = 0x01,
    MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL = 0x02,
    MMI_CLOG_LT_TB_ID_SEND_MSG = 0x04,
    MMI_CLOG_LT_TB_ID_SEND_SMS = 0x08,
    MMI_CLOG_LT_TB_ID_SEND_MMS = 0x10,
    MMI_CLOG_LT_TB_ID_ALL_MSG = MMI_CLOG_LT_TB_ID_SEND_MSG | MMI_CLOG_LT_TB_ID_SEND_SMS | MMI_CLOG_LT_TB_ID_SEND_SMS,
    MMI_CLOG_LT_TB_ID_ALL = 0xFF,
    MMI_CLOG_LT_TB_ID_MAX_ITEM = 10
} mmi_clog_lt_tb_id_enum;
#endif /* defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/

/*----------------------------------------------------------------------------*/
/* Structure                                                                  */
/*----------------------------------------------------------------------------*/

typedef struct
{
    mmi_clog_lt_id_enum lt_id;
    MMI_STR_ID str_id;
} mmi_clog_lt_title_struct;

typedef struct
{
    const mmi_clog_lt_title_struct *title[MMI_CLOG_LT_ID_MAX_NUM];
} mmi_clog_lt_title_tbl_struct;

typedef struct
{
    mmi_clog_lt_id_enum lt_id;
    U16 scrn_id;
    MMI_STR_ID str_id;
    MMI_IMG_ID img_id;
} mmi_clog_lt_tab_page_struct;

typedef struct
{
    U32 total_num;
    const mmi_clog_lt_tab_page_struct *page[MMI_CLOG_LT_ID_MAX_NUM];
    MMI_CLOG_LT_TAB_HDLR page_hdlr;
} mmi_clog_lt_tab_struct;

#ifdef __MMI_BT_PBAP_CLIENT__

#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
typedef struct 
{
   const mmi_clog_lt_bt_tab_page_struct *image[MMI_CLOG_LT_ID_MAX_NUM];
}mmi_clog_lt_bt_tab_page_add_struct;
#endif

typedef struct
{
    U32 total_num;
#if SRV_PBAPC_LINK_NUM >= 2
#ifndef __MMI_TELEPHONY_SUPPORT__
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    const mmi_clog_lt_bt_tab_page_add_struct *page[SRV_PBAPC_LINK_NUM];
#else
    const mmi_clog_lt_bt_tab_page_struct *page[SRV_PBAPC_LINK_NUM];
#endif

#else
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    const mmi_clog_lt_bt_tab_page_add_struct *page[SRV_PBAPC_LINK_NUM+1];
#else
    const mmi_clog_lt_bt_tab_page_struct *page[SRV_PBAPC_LINK_NUM +1];
#endif
#endif
#else
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    const mmi_clog_lt_bt_tab_page_add_struct *page[2];
#else
    const mmi_clog_lt_bt_tab_page_struct *page[2];
#endif
#endif

    MMI_CLOG_LT_TAB_HDLR page_hdlr;
} mmi_clog_lt_bt_tab_struct;
#endif

#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
typedef struct
{
    mmi_clog_lt_tb_id_enum tb_id;
    MMI_IMG_ID enb_img_id;
    MMI_IMG_ID dis_img_id;
    MMI_STR_ID str_id;
} mmi_clog_lt_tb_item_struct;

typedef struct
{
    U32 total_num;
    const mmi_clog_lt_tb_item_struct *items;
    MMI_CLOG_LT_TB_HDLR tb_hdlr;
} mmi_clog_lt_tb_struct;
#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/

#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))
typedef struct
{
    #if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
    const mmi_clog_lt_tb_struct *tb;
    #endif /*defined(__MMI_ICON_BAR_SUPPORT__)*/
	
	#if defined (__MMI_TOUCH_SCREEN__)
    MMI_CLOG_LT_TAP_HDLR tap_hdlr;
	#endif /*defined (__MMI_TOUCH_SCREEN__)*/
	
} mmi_clog_lt_fte_struct;
#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__)) */ 

typedef struct
{
    MMI_MENU_ID root_menu_id;
    const mmi_clog_lt_title_tbl_struct *title_tbl;
    const mmi_clog_key_tbl_struct *key_tbl;
    const mmi_clog_lt_img_tbl_struct *img_tbl;
    const mmi_clog_lt_tab_struct *tab;
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))
    const mmi_clog_lt_fte_struct *fte;
#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__)) */ 
} mmi_clog_lt_scrn_data_struct;

#ifdef __MMI_BT_PBAP_CLIENT__
typedef struct
{
    MMI_MENU_ID root_menu_id;
    const mmi_clog_lt_title_tbl_struct *title_tbl;
    const mmi_clog_key_tbl_struct *key_tbl;
    const mmi_clog_lt_img_tbl_struct *img_tbl;
    const mmi_clog_lt_bt_tab_struct *tab;
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))
    const mmi_clog_lt_fte_struct *fte;
#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__)) */ 
} mmi_clog_lt_bt_scrn_data_struct;
#endif


typedef struct
{
    mmi_clog_lt_inst_struct inst_list[MMI_CLOG_LT_INST_MAX_NUM];
} mmi_clog_lt_cntx_struct;


#ifdef __MMI_BT_PBAP_CLIENT__
#if SRV_PBAPC_LINK_NUM >= 2 
#ifdef __MMI_TELEPHONY_SUPPORT__
    S32 g_high_index[SRV_PBAPC_LINK_NUM][4] = {1,1,1,1};
#else

    S32 g_high_index[SRV_PBAPC_LINK_NUM][4] = {0,0,0,0};

#endif
#else
#ifdef __MMI_TELEPHONY_SUPPORT__
    S32 g_high_index[4] = {1,1,1,1};
#endif
#endif

mmi_clog_rsp_missed_call g_is_missed_call;

//extern mmi_clog_pbapc_cntx_struct g_mmi_clog_pbapc_cntx;
extern mmi_clog_pbapc_ex_inst_struct* mmi_clog_get_pbapc_cntx_ex();

extern mmi_clog_pbapc_processing_inst_struct g_mmi_clog_pbapc_processing_inst;
mmi_clog_get_last_num_struct g_mmi_clog_get_last_info;
#endif

/*----------------------------------------------------------------------------*/
/* Static Function Declaration                                                */
/*----------------------------------------------------------------------------*/
/* Instance operations */
static mmi_clog_lt_cntx_struct *mmi_clog_lt_get_cntx(void);
static void mmi_clog_lt_reset_inst(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_destroy_inst(mmi_clog_lt_inst_struct *inst);
static mmi_clog_lt_inst_struct *mmi_clog_lt_alloc_inst(mmi_clog_lt_cntx_struct *cntx);

static MMI_STR_ID mmi_clog_lt_get_title_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id);
static void mmi_clog_lt_update_sel_log_id(mmi_clog_lt_inst_struct *inst);

/* Screen showing */
static MMI_RET mmi_clog_lt_group_proc(mmi_event_struct *evt);
static void mmi_clog_lt_show_list(mmi_clog_lt_inst_struct *inst);

#ifdef __MMI_CLOG_TAB_SUPPORT__
static void mmi_clog_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
static void mmi_clog_lt_enter_tab(mmi_clog_lt_inst_struct * inst);//CHANGE
#else
static void mmi_clog_lt_enter_tab(mmi_scrn_essential_struct *grp_data);
#endif

static void mmi_clog_lt_exit_tab(mmi_scrn_essential_struct *grp_data);
static void mmi_clog_lt_fill_tab_info(mmi_clog_lt_inst_struct *inst, mmi_frm_tab_struct *page_info, U32 page_num);
static void mmi_clog_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data);
static void mmi_clog_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info);
static void mmi_clog_lt_show_tab_page(mmi_clog_lt_inst_struct *inst);
static const mmi_clog_lt_tab_page_struct *mmi_clog_lt_get_page_by_lt_id(
                                            mmi_clog_lt_inst_struct *inst,
                                            mmi_clog_lt_id_enum lt_id);
static S32 mmi_clog_lt_get_page_index_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id);
#endif /* __MMI_CLOG_TAB_SUPPORT__ */ 

/*for bt dialer start */
#ifdef __MMI_BT_PBAP_CLIENT__
static void mmi_clog_bt_link_no_clog_pse_list(mmi_clog_lt_inst_struct * inst);

#if 0
/* under construction !*/
#endif
static MMI_MENU_ID mmi_clog_bt_get_menu_id(mmi_clog_lt_id_enum lt_id);
static void mmi_clog_bt_link_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
static void mmi_clog_bt_link_lt_enter_tab(mmi_clog_lt_inst_struct *inst);//CHANGE
#else
static void mmi_clog_bt_link_lt_enter_tab(mmi_scrn_essential_struct *scr_info);
#endif

static void mmi_clog_bt_link_lt_exit_tab(mmi_scrn_essential_struct *grp_data);
static const mmi_clog_lt_bt_tab_page_struct *mmi_clog_lt_bt_link_get_page_by_lt_id(
                                            mmi_clog_lt_inst_struct *inst,
                                            mmi_clog_lt_bt_id_enum lt_id);
static void mmi_clog_bt_link_fill_tab_info(mmi_clog_lt_inst_struct *inst,
                                                mmi_frm_tab_struct *page_info, 
                                                U32 page_num);
static void mmi_clog_bt_link_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data);
static S32 mmi_clog_bt_pbap_set_index_cb(srv_pbapc_query_req_struct *req);

#ifndef __MMI_CLOG_SLIM_FOR_MT6261__
static MMI_RET mmi_clog_lt_bt_scrn_proc(mmi_event_struct *evt);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
static void mmi_clog_bt_link_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info);
MMI_RET mmi_clog_update_list_by_status(mmi_event_struct*evt);
void mmi_clog_set_bt_status();
static void mmi_clog_bt_dialer_pre_show(mmi_clog_lt_inst_struct *inst);

//static mmi_ret mmi_clog_pbapc_notify_evt_hdlr(mmi_event_struct *evt);
//extern void mmi_clog_pbapc_processing_show_ex(MMI_ID parent_id, mmi_clog_pbapc_op_type_enum type, srv_phb_pbap_storage_enum sel_lt_storage);
#if 0
/* under construction !*/
#endif
#endif
/*for BT dialer end*/
static void mmi_clog_lt_pre_enter(mmi_clog_lt_inst_struct *inst);
static pBOOL mmi_clog_lt_get_log_item(S32 item_index, UI_string_type str_buff, U8 **img_buff_p, U8 str_img_mask);
static void mmi_clog_lt_get_string(mmi_clog_lt_inst_struct *inst, srv_clog_log_struct *log, WCHAR *str_buff);
#ifndef __MMI_CLOG_FPBW__
static S32 mmi_clog_lt_get_log_hint(S32 item_index, UI_string_type *hint_array);
#endif /*__MMI_CLOG_FPBW__*/
static S32 mmi_clog_lt_get_multi_log_items(S32 start_index, gui_iconlist_menu_item *menu_data, S32 item_count);

/* Screen handlers */
static void mmi_clog_lt_item_hlt_hdlr(S32 sel);
static void mmi_clog_lt_set_key_hdlr(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_set_csk_key(S32 is_predef);
static void mmi_clog_lt_csk_hdlr(void);

static void mmi_clog_lt_lsk_hdlr(void);
static void mmi_clog_lt_rsk_hdlr(void);

static void mmi_clog_lt_send_key_hdlr(void);
#ifdef __MMI_IP_KEY__
/* under construction !*/
#endif

/* FTE operations */
#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
static void mmi_clog_lt_tb_create(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_tb_refresh(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_tb_action_hdlr(S32 index);
static const mmi_clog_lt_tb_item_struct *mmi_clog_lt_get_tb_item_by_index(mmi_clog_lt_inst_struct *inst, S32 index);
static U32 mmi_clog_lt_tb_get_enb_items(mmi_clog_lt_inst_struct *inst);

static void mmi_clog_lt_tb_set_enb_state(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_tb_id_enum ids, S32 enable);
#endif /* __MMI_CLOG_ICON_BAR_SUPPORT__*/ 

#if defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
static void mmi_clog_lt_tap_action_hdlr(mmi_tap_type_enum tap_type, S32 index);
static void mmi_clog_lt_set_tap_hdlr(mmi_clog_lt_inst_struct *inst);
#endif /*defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)*/

static void mmi_clog_lt_op_enter(void);
static void mmi_clog_lt_viewer_enter(void);
static MMI_ID mmi_clog_lt_act_proc(mmi_clog_op_mid_enum op_mid, U32 flags);

/* Service access */
static void mmi_clog_lt_log_start(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_refresh_data(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_update_read_status(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_refresh_sel_index(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_load_log_ids(mmi_clog_lt_inst_struct *inst);

#ifdef __MMI_CLOG_EVENT_REFRESH_SUPPORT__
static void mmi_clog_lt_inst_srv_evt_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt);
static void mmi_clog_lt_inst_srv_evt_add_log_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt);
static void mmi_clog_lt_refresh_int(mmi_clog_lt_inst_struct *inst);
static S32 mmi_clog_lt_is_scrn_in_active(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_lt_refresh_screen(mmi_clog_lt_inst_struct *inst);
#endif /* __MMI_CLOG_EVENT_REFRESH_SUPPORT__ */
#ifdef __MMI_CLOG_MARK_SEVERAL__
static void mmi_clog_mark_several_hlt_hdlr(S32 sel);
static S32 mmi_clog_mark_several_get_state(S32 item_index, PU8 *checkbox_image);
static S32 mmi_clog_mark_several_set_state(S32 item_index);
static U16 mmi_clog_mark_several_has_marked(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_mark_several_set_key_hdlr(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_mark_several_change_status(void);
static void mmi_clog_mark_several_op_enter(void);
static MMI_RET mmi_clog_mark_several_op_group_proc(mmi_event_struct *evt);
static void mmi_clog_mark_several_op_hide_menu(mmi_id cui_id, mmi_clog_lt_inst_struct *inst);

static U8 mmi_clog_bitmask_get_state(U8* bit_mask, U16 index);
static void mmi_clog_mark_several_delete_confirm(mmi_clog_lt_inst_struct *inst);
static void mmi_clog_mark_several_delete(mmi_clog_lt_inst_struct *inst);
static S32 mmi_clog_mark_several_delete_common(mmi_clog_lt_inst_struct *inst);
static S32 mmi_clog_mark_several_delete_result(
            SRV_CLOG_HANDLE handle,
            S32 pid,
            void *req_data,
            void *cnf_data,
            MMI_BOOL more,
            srv_clog_ret_enum ret);

#endif /* __MMI_CLOG_MARK_SEVERAL__ */

/*----------------------------------------------------------------------------*/
/* Static Global Variable                                                     */
/*----------------------------------------------------------------------------*/
#ifdef __MMI_BT_PBAP_CLIENT__
typedef struct
{
    mmi_clog_lt_bt_id_enum lt_id;
    MMI_STR_ID str_id;
} mmi_clog_lt_bt_title_struct;
#endif
static const mmi_clog_lt_title_struct g_mmi_clog_lt_dialed_call = 
{
    MMI_CLOG_LT_ID_DIALED_CALL,
    STR_GLOBAL_DIALLED_CALLS
};

static const mmi_clog_lt_title_struct g_mmi_clog_lt_missed_call = 
{
    MMI_CLOG_LT_ID_MISSED_CALL,
    STR_GLOBAL_MISSED_CALLS
};

static const mmi_clog_lt_title_struct g_mmi_clog_lt_recved_call = 
{
    MMI_CLOG_LT_ID_RECVED_CALL,
    STR_GLOBAL_RECEIVED_CALLS
};

static const mmi_clog_lt_title_struct g_mmi_clog_lt_all_call = 
{
    MMI_CLOG_LT_ID_ALL_CALL,
    STR_ID_CLOG_ALL_CALL
};
#ifdef __MMI_BT_PBAP_CLIENT__

#ifdef __MMI_TELEPHONY_SUPPORT__
static const mmi_clog_lt_bt_title_struct g_mmi_clog_lt_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    STR_ID_CLOG_SUB_LOCAL
};
#endif
static const mmi_clog_lt_bt_title_struct g_mmi_clog_lt_bt_call = 
{
    MMI_CLOG_LT_ID_BT,
    STR_ID_PHB_PBAPC_BT1
};


#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_title_struct g_mmi_clog_lt_bt_call_v3 = 
{
    MMI_CLOG_LT_ID_BT_V3,
    STR_ID_PHB_PBAPC_BT2
};
#endif

#endif

static const mmi_clog_lt_title_tbl_struct g_mmi_clog_lt_title_tbl = 
{
    {
        &g_mmi_clog_lt_dialed_call,
        &g_mmi_clog_lt_missed_call,
        &g_mmi_clog_lt_recved_call,
        &g_mmi_clog_lt_all_call
    }
};

static const mmi_clog_key_tbl_struct g_mmi_clog_lt_key_tbl = 
{
    {
        &g_mmi_clog_lsk_option,
        &g_mmi_clog_csk_common,
        &g_mmi_clog_rsk_back
    },
    {
        mmi_clog_lt_lsk_hdlr,
        mmi_clog_lt_csk_hdlr,
        mmi_clog_lt_rsk_hdlr,
        mmi_clog_lt_send_key_hdlr,
#ifdef __MMI_IP_KEY__
/* under construction !*/
#endif
     }
};

#ifdef __MMI_CLOG_TAB_SUPPORT__
static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_call = 
{
    MMI_CLOG_LT_ID_DIALED_CALL,
    SCR_ID_CLOG_DIALED_CALL,
    STR_GLOBAL_DIALLED_CALLS,
    IMG_ID_CLOG_TAB_DIALED_CALL
};

static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_missed_call = 
{
    MMI_CLOG_LT_ID_MISSED_CALL,
    SCR_ID_CLOG_MISSED_CALL,
    STR_GLOBAL_MISSED_CALLS,
    IMG_ID_CLOG_TAB_MISSED_CALL
};

static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_recved_call = 
{
    MMI_CLOG_LT_ID_RECVED_CALL,
    SCR_ID_CLOG_RECVED_CALL,
    STR_GLOBAL_RECEIVED_CALLS,
    IMG_ID_CLOG_TAB_RECVED_CALL
};

static const mmi_clog_lt_tab_page_struct g_mmi_clog_lt_tab_page_all_call = 
{
    MMI_CLOG_LT_ID_ALL_CALL,
    SCR_ID_CLOG_ALL_CALL,
    STR_ID_CLOG_ALL_CALL,
    IMG_ID_CLOG_TAB_ALL_CALL
};

static const mmi_clog_lt_tab_struct g_mmi_clog_lt_tab = 
{
    4,
    {
        &g_mmi_clog_lt_tab_page_dialed_call,
        &g_mmi_clog_lt_tab_page_missed_call,
        &g_mmi_clog_lt_tab_page_recved_call,
        &g_mmi_clog_lt_tab_page_all_call
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_lt_enter_tab_page
};

#endif /* __MMI_CLOG_TAB_SUPPORT__ */

#ifdef __MMI_BT_PBAP_CLIENT__
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
#ifdef __MMI_TELEPHONY_SUPPORT__
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_DIALED_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_DIALED_LOCAL_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_missed_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_MISSED_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_MISSED_LOCAL_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_recieve_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_RECVED_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_RECEIVED_LOCAL_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_all_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    MMI_CLOG_LT_ID_ALL_CALL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_ALL_LOCAL_CALL
};
#endif

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_DIALED_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_DIALED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_missed_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_MISSED_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_MISSED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_all_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_ALL_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_ALL_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_recved_bt_call =
{
    MMI_CLOG_LT_ID_BT,
    MMI_CLOG_LT_ID_RECVED_CALL,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_RECEIVED_BT_CALL
};

#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_dialed_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_DIALED_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_DIALED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_missed_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_MISSED_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_MISSED_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_all_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_ALL_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_ALL_BT_CALL
};

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_recved_bt_call_v3 =
{
    MMI_CLOG_LT_ID_BT_V3,
    MMI_CLOG_LT_ID_RECVED_CALL,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_RECEIVED_BT_CALL
};
#endif
#endif
#endif

#ifdef __MMI_BT_PBAP_CLIENT__
#ifdef __MMI_TELEPHONY_SUPPORT__
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
static const mmi_clog_lt_bt_tab_page_add_struct g_mmi_clog_lt_tab_page_local_call = 
{
    &g_mmi_clog_lt_tab_page_dialed_local_call , 
    &g_mmi_clog_lt_tab_page_missed_local_call,
    &g_mmi_clog_lt_tab_page_recieve_local_call,
    &g_mmi_clog_lt_tab_page_all_local_call
};
#else

static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_local_call = 
{
    MMI_CLOG_LT_ID_LOCAL,
    GRP_ID_CLOG_SUB_LOCAL,
    STR_ID_CLOG_SUB_LOCAL,
    IMG_ID_CLOG_MAIN_ICON
};
#endif  /*#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)*/
#endif /*__MMI_TELEPHONY_SUPPORT__*/

#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
static const mmi_clog_lt_bt_tab_page_add_struct g_mmi_clog_lt_tab_page_bt_dialer_call = 
{ 
    &g_mmi_clog_lt_tab_page_dialed_bt_call, 
    &g_mmi_clog_lt_tab_page_missed_bt_call,
    &g_mmi_clog_lt_tab_page_all_bt_call, 
    &g_mmi_clog_lt_tab_page_recved_bt_call       
};
#else
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_bt_dialer_call = 
{
    MMI_CLOG_LT_ID_BT,
    GRP_ID_CLOG_SUB_BT_DEVICE,
    STR_ID_PHB_PBAPC_BT1,
    IMG_ID_CLOG_MAIN_ICON
};
#endif

#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)

#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_tab_page_add_struct g_mmi_clog_lt_tab_page_bt_dialer_call_v3 = 
{ 
    &g_mmi_clog_lt_tab_page_dialed_bt_call_v3, 
    &g_mmi_clog_lt_tab_page_missed_bt_call_v3,
    &g_mmi_clog_lt_tab_page_all_bt_call_v3, 
    &g_mmi_clog_lt_tab_page_recved_bt_call_v3       
};
#endif
#else

#if SRV_PBAPC_LINK_NUM >= 2
static const mmi_clog_lt_bt_tab_page_struct g_mmi_clog_lt_tab_page_bt_dialer_call_v3 = 
{
    MMI_CLOG_LT_ID_BT_V3,
    SCR_ID_CLOG_SUB_BT_DEVICE_V3,
    STR_ID_PHB_PBAPC_BT2,
    IMG_ID_CLOG_MAIN_ICON
};
#endif
#endif

static const mmi_clog_lt_bt_tab_struct g_mmi_clog_bt_link_lt_tab = 
{
#if SRV_PBAPC_LINK_NUM >= 2

#ifndef __MMI_TELEPHONY_SUPPORT__
    SRV_PBAPC_LINK_NUM,
    {    
        &g_mmi_clog_lt_tab_page_bt_dialer_call,
        &g_mmi_clog_lt_tab_page_bt_dialer_call_v3
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_bt_link_lt_enter_tab_page


#else/*__MMI_TELEPHONY_SUPPORT__*/

    SRV_PBAPC_LINK_NUM+1,
    {    
        &g_mmi_clog_lt_tab_page_local_call,
        &g_mmi_clog_lt_tab_page_bt_dialer_call,
        &g_mmi_clog_lt_tab_page_bt_dialer_call_v3
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_bt_link_lt_enter_tab_page
#endif /*__MMI_TELEPHONY_SUPPORT__*/
#else
    2,
    {    
#ifdef __MMI_TELEPHONY_SUPPORT__
        &g_mmi_clog_lt_tab_page_local_call,
#endif
        &g_mmi_clog_lt_tab_page_bt_dialer_call
    },
    (MMI_CLOG_LT_TAB_HDLR) mmi_clog_bt_link_lt_enter_tab_page
#endif
};
#endif

#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
/* The FTE toolbar show its items in the same order of the declarations in this array  */
static const mmi_clog_lt_tb_item_struct g_mmi_clog_lt_tb_item_list[] = 
{
    /* Make call */
    {
        MMI_CLOG_LT_TB_ID_MAKE_CALL,
        IMG_GLOBAL_TOOLBAR_CALL,
        IMG_GLOBAL_TOOLBAR_CALL_DISABLED,
        STR_GLOBAL_DIAL
    },

#if(defined(__OP01_3G__) && defined(__MMI_VIDEO_TELEPHONY__)) 
    /* Make video call */
    {
        MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL,
        IMG_GLOBAL_TOOLBAR_VIDEO_CALL,
        IMG_GLOBAL_TOOLBAR_VIDEO_CALL_DISABLED,
        STR_GLOBAL_DIAL_VIDEO_CALL
    },  

#endif /* __OP01_3G__ && __MMI_VIDEO_TELEPHONY__ */


#ifdef __MMI_UNIFIED_COMPOSER__
    /* Send message */
    {
        MMI_CLOG_LT_TB_ID_SEND_MSG,
        IMG_GLOBAL_TOOLBAR_SEND_MESSAGE,
        IMG_GLOBAL_TOOLBAR_SEND_MESSAGE_DISABLED,
        STR_GLOBAL_SEND_MESSAGE
    },
#else /* __MMI_UNIFIED_COMPOSER__ */ 
    /* Send SMS */
    {
        MMI_CLOG_LT_TB_ID_SEND_SMS,
        IMG_ID_CLOG_TB_SEND_SMS,
        IMG_ID_CLOG_TB_SEND_SMS_DISABLE,
        STR_GLOBAL_SEND_TEXT_MESSAGE
    },

#ifdef __MMI_MMS__
    /* Send MMS */
    {
        MMI_CLOG_LT_TB_ID_SEND_MMS,
        IMG_ID_CLOG_TB_SEND_MMS,
        IMG_ID_CLOG_TB_SEND_MMS_DISABLE,
        STR_GLOBAL_SEND_MULTIMEDIA_MESSAGE
    }
#endif /* __MMI_MMS__ */ 
#endif /* __MMI_UNIFIED_COMPOSER__ */ 
};

static const mmi_clog_lt_tb_struct g_mmi_clog_lt_tb = 
{
    sizeof(g_mmi_clog_lt_tb_item_list) / sizeof(mmi_clog_lt_tb_item_struct),
    g_mmi_clog_lt_tb_item_list,
    mmi_clog_lt_tb_action_hdlr
};
#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/

#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))
static const mmi_clog_lt_fte_struct g_mmi_clog_lt_fte = 
{
#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
    &g_mmi_clog_lt_tb,
#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/

#if defined (__MMI_TOUCH_SCREEN__)
    mmi_clog_lt_tap_action_hdlr,
#endif /*defined (__MMI_TOUCH_SCREEN__)*/
};

#endif /* defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__)) */ 

static const mmi_clog_lt_scrn_data_struct g_mmi_clog_lt_scrn_data = 
{
    MAIN_MENU_CALL_LOG,
    &g_mmi_clog_lt_title_tbl,
    &g_mmi_clog_lt_key_tbl,
    &g_mmi_clog_lt_img_tbl,
#ifdef __MMI_CLOG_TAB_SUPPORT__
    &g_mmi_clog_lt_tab,
#else /*__MMI_CLOG_TAB_SUPPORT__*/
    NULL,
#endif /*__MMI_CLOG_TAB_SUPPORT__*/
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))
    &g_mmi_clog_lt_fte
#endif /*defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))*/
};

#ifdef __MMI_BT_PBAP_CLIENT__
static const mmi_clog_lt_bt_scrn_data_struct g_mmi_clog_bt_link_lt_scrn_data = 
{
    MAIN_MENU_CALL_LOG,
    &g_mmi_clog_lt_title_tbl,
    &g_mmi_clog_lt_key_tbl,
    &g_mmi_clog_lt_img_tbl,
//#ifdef __MMI_CLOG_TAB_SUPPORT__
    &g_mmi_clog_bt_link_lt_tab,
//#else /*__MMI_CLOG_TAB_SUPPORT__*/
   // NULL,
//#endif /*__MMI_CLOG_TAB_SUPPORT__*/
#if defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))
    &g_mmi_clog_lt_fte
#endif /*defined(__MMI_FTE_SUPPORT__) && (defined (__MMI_TOUCH_SCREEN__) || defined(__MMI_CLOG_ICON_BAR_SUPPORT__))*/
};
#endif

static mmi_clog_lt_cntx_struct g_mmi_clog_lt_cntx;
WCHAR path[41];


extern U8 g_clog_sim_support;

#ifdef __MMI_NCENTER_SUPPORT__
extern vsrv_notification_handle g_ncenter_hdl;

#endif /*__MMI_NCENTER_SUPPORT__*/

extern NMGR_HANDLE nmgr_handle;


/*----------------------------------------------------------------------------*/
/* Extern Function Defines                                                    */
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
/* Function Definition                                                        */
/*----------------------------------------------------------------------------*/
static SRV_CLOG_ID mmi_clog_get_id_by_idx(mmi_clog_lt_id_enum lt_id, U16 sel_log_idx)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_clog_get_list_log_req_struct req_data;
    srv_clog_get_list_log_cnf_struct cnf_data;
    const mmi_clog_lt_id_attr_struct *attr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_clog_init_para(SRV_CLOG_PARA_GET_LIST_LOG_CNF, &cnf_data);

    attr = mmi_clog_get_attr_by_lt_id(lt_id);
    SRV_CLOG_INIT_IDT(
        (srv_clog_log_identity_struct*) & req_data,
        attr->idt.cate,
        //attr->idt.sim_id,
        g_clog_sim_support,
        attr->idt.log_type,
        attr->idt.sub_type);
    
    req_data.get_by = SRV_CLOG_BY_IDX;
    req_data.get_elm = sel_log_idx;
    req_data.fields = SRV_CLOG_LOG_FIELD_LOG_ID;
#ifdef __MMI_TELEPHONY_SUPPORT__
    srv_clog_get_list_log(0,
        (const srv_clog_get_list_log_req_struct *) &req_data,
        &cnf_data);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    return cnf_data.log.data.call_log.log_id;
#else /* __MMI_TELEPHONY_SUPPORT__ */
    return 0;
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


#define MMI_CLOG_LT_INIT


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_cntx
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static mmi_clog_lt_cntx_struct *mmi_clog_lt_get_cntx(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &g_mmi_clog_lt_cntx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_reset_inst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_reset_inst(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(inst, 0x0, sizeof(mmi_clog_lt_inst_struct));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_destroy_inst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_destroy_inst(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT))
        return;

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_DESTROY_INST,
        inst->self_gid,
        inst->flags,
        inst->lt_type,
        inst->sel_lt_id,
        inst->sel_log_idx,
        inst->sel_log_id));
#ifndef __MMI_CLOG_SLIM_FOR_MT6261__
    if (!MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_EXT_HANDLE))
        srv_clog_destroy(inst->log_data.handle);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    mmi_clog_lt_reset_inst(inst);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_alloc_inst
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cntx        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
mmi_clog_lt_inst_struct *mmi_clog_lt_alloc_inst(mmi_clog_lt_cntx_struct *cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_CLOG_LT_INST_MAX_NUM == 1) /* For slim */
    {
        MMI_CLOG_SET_BIT(cntx->inst_list[0].flags, MMI_CLOG_CMN_INST_FLAG_IS_USED | MMI_CLOG_INST_TYPE_LT);
        return &cntx->inst_list[0];
    }
    else
    {
        for (i = 0; i < MMI_CLOG_LT_INST_MAX_NUM; i++)
        {
            inst = &cntx->inst_list[i];
            if (!MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_IS_USED))
            {
                MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_IS_USED | MMI_CLOG_INST_TYPE_LT);
                return inst;
            }
        }
        return NULL;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_title_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]         
 *  lt_id       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_STR_ID mmi_clog_lt_get_title_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_title_tbl_struct *title_tbl = g_mmi_clog_lt_scrn_data.title_tbl;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_CLOG_LT_ID_MAX_NUM; i++)
    {
        if (title_tbl->title[i] && title_tbl->title[i]->lt_id == lt_id)
            return title_tbl->title[i]->str_id;
    }
    
    MMI_CLOG_IT_ASSERT(0);
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_update_sel_log_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_update_sel_log_id(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst->sel_log_id = mmi_clog_get_id_by_idx(inst->sel_lt_id, inst->sel_log_idx);
}

#define MMI_CLOG_LT_IF

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_scrn_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 * evt       [IN]     
 * RETURNS
 *  MMI_RET
 *****************************************************************************/
static MMI_RET mmi_clog_lt_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
#ifdef __MMI_BT_PBAP_CLIENT__
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) evt->user_data;

    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_ACTIVE:
#if defined (__MMI_BT_PBAP_CLIENT__)
        if(MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_BT_HANDLE))
        {
            pbapc_cntx =  mmi_clog_get_pbapc_cntx_ex();
            pbapc_cntx->is_active = 1;
#ifdef __MMI_WEARABLE_DEVICE__
            mmi_clog_bt_dialer_pre_show(inst);
#else
#if SRV_PBAPC_LINK_NUM >= 2
    #ifdef __MMI_PHB_PBAPC_SYNC_CONTACT__ 
        {
            mmi_clog_bt_dialer_pre_show(inst);
        }
    #endif
#else /*SRV_PBAPC_LINK_NUM >= 2*/
    #ifndef __MMI_TELEPHONY_SUPPORT__
        {
            pbapc_cntx->index = 0;
            mmi_clog_bt_dialer_pre_show(inst);
        }
    #endif/*__MMI_TELEPHONY_SUPPORT__*/
#endif/*SRV_PBAPC_LINK_NUM >= 2*/
#endif
        }
		else
#endif /* __MMI_BT_PBAP_CLIENT__ */
        {
#ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_clog_lt_load_log_ids(inst);
            }
            else
#endif /*__MMI_CLOG_MARK_SEVERAL__*/
            {
                mmi_clog_lt_refresh_data(inst);
            }
            mmi_clog_lt_show_list(inst);
        }
        break;
#ifdef __MMI_BT_PBAP_CLIENT__  
      case EVT_ID_SCRN_INACTIVE:
      {
			if(MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_BT_HANDLE))
           	{
           		pbapc_cntx =  mmi_clog_get_pbapc_cntx_ex();
            	pbapc_cntx->is_active = 2;  
			}
      }
            break;
#endif
        default:
             break;
    }  

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_create_and_run
 * DESCRIPTION
 *  
 * PARAMETERS
 *  p_inst      [IN]        parent inst      
 * RETURNS
 *  
 *****************************************************************************/
MMI_ID mmi_clog_lt_create_and_run(mmi_clog_inst_struct *p_inst, mmi_clog_lt_style_enum style)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID gid;
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_lt_cntx_struct *cntx = mmi_clog_lt_get_cntx();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
  #ifdef __MMI_CLOG_MARK_SEVERAL__
    if(style==MMI_CLOG_LT_STYLE_LIST)
        inst = &cntx->inst_list[0];     // for layout list
    else
        inst = &cntx->inst_list[1];     // for multiselection
  #else /* __MMI_CLOG_MARK_SEVERAL__ */
    inst = &cntx->inst_list[0];
  #endif /* __MMI_CLOG_MARK_SEVERAL__ */
    
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    inst = mmi_clog_lt_alloc_inst(cntx);
    if (!inst)
    {
        MMI_CLOG_ASSERT(0);
        return 0;
    }
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

    MMI_CLOG_ASSERT(p_inst->sel_lt_id < MMI_CLOG_LT_ID_MAX_ITEM);
	if(MMI_CLOG_CHECK_BIT(p_inst->flags, MMI_CLOG_CMN_INST_FLAG_BT_HANDLE))
		MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_BT_HANDLE);
	else
		MMI_CLOG_CLEAR_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_BT_HANDLE);
    inst->sel_lt_id = p_inst->sel_lt_id;
    inst->style = style;
    inst->lt_type = p_inst->lt_type;
#ifndef __MMI_CLOG_SLIM_FOR_MT6261__
    inst->log_data.handle = p_inst->handle;

    if (!SRV_CLOG_IS_ELM_INVALID(p_inst->handle))
        MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_EXT_HANDLE);
    mmi_clog_lt_log_start(inst);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    if(style==MMI_CLOG_LT_STYLE_LIST)
        gid = GRP_ID_CLOG_LAYOUT;
    else
        gid = GRP_ID_CLOG_LAYOUT_MARK;
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    gid = mmi_clog_alloc_gid(MMI_CLOG_GRP_TYPE_LT);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

    inst->self_gid = mmi_frm_group_create_ex(p_inst->self_gid, gid, mmi_clog_lt_group_proc, inst, MMI_FRM_NODE_SMART_CLOSE_FLAG);

#ifdef __MMI_CLOG_MARK_SEVERAL__
    if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
    {
        inst->sel_log_idx = cntx->inst_list[0].sel_log_idx; /* use list highlight index, need revise */
    }
    else
#endif /* __MMI_CLOG_MARK_SEVERAL__ */
    {
        inst->sel_log_idx = 0;
    }
    mmi_clog_lt_update_sel_log_id(inst);
    
    g_clog_sim_support = MMI_SIM_ALL;  

#if !defined(__MMI_CLOG_TAB_SUPPORT__) || defined(__MMI_CLOG_MARK_SEVERAL__) 
    if(inst->lt_type == MMI_CLOG_LT_TYPE_LIST)
    {
#ifdef __MMI_BT_PBAP_CLIENT__
#ifdef __MMI_WEARABLE_DEVICE__
        mmi_frm_scrn_create(inst->self_gid, SCR_ID_CLOG_LAYOUT, mmi_clog_lt_scrn_proc, inst);
#else/*__MMI_WEARABLE_DEVICE__*/
#if SRV_PBAPC_LINK_NUM >= 2
    #ifdef __MMI_PHB_PBAPC_SYNC_CONTACT__
    mmi_frm_scrn_create(inst->self_gid, SCR_ID_CLOG_LAYOUT, mmi_clog_lt_scrn_proc, inst);
    #else
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
        mmi_clog_bt_link_lt_enter_tab(inst);//CHANGE
    #else
        mmi_clog_bt_link_lt_first_enter_tab(inst);
    #endif /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    #endif /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
#else
    #ifndef __MMI_TELEPHONY_SUPPORT__
        mmi_frm_scrn_create(inst->self_gid, SCR_ID_CLOG_LAYOUT, mmi_clog_lt_scrn_proc, inst);
    #else /* __MMI_TELEPHONY_SUPPORT__ */
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
        mmi_clog_bt_link_lt_enter_tab(inst);//CHANGE
    #else
        mmi_clog_bt_link_lt_first_enter_tab(inst);
    #endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    #endif /*__MMI_TELEPHONY_SUPPORT__*/ 
#endif /*SRV_PBAPC_LINK_NUM >= 2*/
#endif /*__MMI_WEARABLE_DEVICE__*/
#else/*__MMI_BT_PBAP_CLIENT__*/
        mmi_frm_scrn_create(inst->self_gid, SCR_ID_CLOG_LAYOUT, mmi_clog_lt_scrn_proc, inst);
#endif /*__MMI_BT_PBAP_CLIENT__*/
    }
    else
#endif /*!defined(__MMI_CLOG_TAB_SUPPORT__) || defined(__MMI_CLOG_MARK_SEVERAL__)*/
#ifdef __MMI_CLOG_TAB_SUPPORT__
    if(inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
    { 
    #ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
        mmi_clog_lt_enter_tab(inst);        
    #else
        mmi_clog_lt_first_enter_tab(inst);
    #endif
 
    }
#endif /* __MMI_CLOG_TAB_SUPPORT__ */

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_CREATE,
        p_inst->self_gid,
        inst->self_gid,
        inst->lt_type,
        inst->flags,
        inst->log_data.handle,
        inst->style));

    return inst->self_gid;
}


#define MMI_CLOG_LT_GRP


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_group_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_clog_lt_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
#ifdef __MMI_BT_PBAP_CLIENT__
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) evt->user_data;

    if (evt->evt_id == EVT_ID_GROUP_DEINIT)
    {
        mmi_clog_lt_destroy_inst(inst);
#ifdef __MMI_BT_PBAP_CLIENT__
        //mmi_clog_pbapc_deinit();
        memset((void*)&g_is_missed_call, 0x0,sizeof (mmi_clog_rsp_missed_call));
        pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();

    #ifdef __MMI_WEARABLE_DEVICE__
        pbapc_cntx->is_cancel = 0;
    #endif
        pbapc_cntx->is_active = 2;
#endif
    }
    else if (evt->evt_id == EVT_ID_GROUP_ENTER)
    {
       // mmi_frm_cb_reg_event(EVT_ID_DIALER_EVENT_ID, mmi_clog_update_list_by_status, inst);

    }
#ifdef __MMI_CLOG_MARK_SEVERAL__
    else if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        mmi_alert_result_evt_struct *alert = (mmi_alert_result_evt_struct*) evt;
        if (alert->result == MMI_ALERT_CNFM_YES)
            mmi_clog_mark_several_delete(inst);
    }
#endif
#ifdef __MMI_BT_PBAP_CLIENT__
#ifdef __MMI_WEARABLE_DEVICE__
    else if (evt->evt_id == EVT_ID_TOUCHSCREEN_MOVE_RIGHT)
    {
            MMI_ID group_id = 0;
            MMI_ID scrn_id = 0;

            mmi_frm_get_active_scrn_id(&group_id, &scrn_id);
            MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_BT_BW_GR_PROC, group_id, scrn_id,inst->self_gid);
            if (SCR_ID_CLOG_BT_CONN_FAIL == scrn_id &&
                inst->self_gid == group_id)
            {
                mmi_frm_group_close(inst->self_gid);
                return MMI_RET_DONT_CARE;
            }
    }
#endif
#endif

    return MMI_RET_OK;
}


#define MMI_CLOG_LT_UI

#if defined(__MMI_CLOG_TAB_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_first_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_first_enter(inst->self_gid, SCR_ID_CLOG_LAYOUT, (FuncPtr) mmi_clog_lt_enter_tab, inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  scr_info        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/ 
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    static void mmi_clog_lt_enter_tab(mmi_clog_lt_inst_struct * inst);//CHANGE
#else
    static void mmi_clog_lt_enter_tab(mmi_scrn_essential_struct *grp_data);
#endif
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    mmi_frm_tab_struct page_info[MMI_CLOG_LT_ID_MAX_NUM]; 
    mmi_clog_lt_inst_struct *inst;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__  
   inst = (mmi_clog_lt_inst_struct *)scr_info->user_data;
#endif 
    mmi_clog_lt_fill_tab_info(inst, page_info, MMI_CLOG_LT_ID_MAX_NUM);

#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    cui_tab_create( inst->self_gid,
            SCR_ID_CLOG_LAYOUT,
            page_info,
            (U8) g_mmi_clog_lt_enb_ids.total_num,
            cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT),
            inst);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    mmi_frm_scrn_tab_enter(
        inst->self_gid,
        SCR_ID_CLOG_LAYOUT,
        (FuncPtr) mmi_clog_lt_exit_tab,
        (FuncPtr) mmi_clog_lt_enter_tab,
        page_info,
        (U8) g_mmi_clog_lt_enb_ids.total_num,
        (U8) mmi_clog_lt_get_page_index_by_lt_id(inst, inst->sel_lt_id));
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_exit_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  scr_info        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_exit_tab(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* mmi_frm_general_tab_exit(); */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_fill_tab_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst            [IN]         
 *  page_info       [OUT]         
 *  page_num        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_fill_tab_info(mmi_clog_lt_inst_struct *inst, mmi_frm_tab_struct *page_info, U32 page_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_tab_page_struct *page;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_mmi_clog_lt_enb_ids.total_num && i < page_num; i++)
    {
        page = mmi_clog_lt_get_page_by_lt_id(inst, g_mmi_clog_lt_enb_ids.lt_ids[i]);
        page_info[i].screen_id = page->scrn_id;
        page_info[i].tab_icon = (U8*) GetImage(page->img_id);
        page_info[i].tab_string = NULL;
        page_info[i].tab_entry_func = g_mmi_clog_lt_scrn_data.tab->page_hdlr;
        page_info[i].user_data = inst;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_enter_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  grp_data        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    U8 index;
    mmi_clog_lt_inst_struct *inst;
    const mmi_clog_lt_tab_page_struct *page;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) grp_data->user_data;
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    index = mmi_frm_scrn_tab_get_active_page_index();
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    MMI_CLOG_ASSERT(index < g_mmi_clog_lt_enb_ids.total_num);
    inst->sel_lt_id = g_mmi_clog_lt_enb_ids.lt_ids[index];

    page = mmi_clog_lt_get_page_by_lt_id(inst, inst->sel_lt_id);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    ret = cui_tab_enter(
            inst->self_gid,
            page->scrn_id,
            (FuncPtr) mmi_clog_lt_exit_tab_page,
            (FuncPtr) mmi_clog_lt_enter_tab_page,
            MMI_FRM_FULL_SCRN);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    ret = mmi_frm_scrn_tab_page_enter(
            inst->self_gid,
            SCR_ID_CLOG_LAYOUT,
            page->scrn_id,
            (FuncPtr) mmi_clog_lt_exit_tab_page,
            (FuncPtr) mmi_clog_lt_enter_tab_page,
            MMI_FRM_TAB_PAGE);
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */

    if (!ret)
        return;

    /* Reload log data after change select lt_id */
    mmi_clog_lt_refresh_data(inst);

    mmi_clog_lt_show_tab_page(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_exit_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  scr_info        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_show_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_show_tab_page(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buff;
    S32 category_error_flag;
    U32 has_lsk = MMI_TRUE;
    const mmi_clog_lt_tab_page_struct *page;
    U32 count = 0;

#ifdef __MMI_CLOG_SIM_FILTER__
    S32 ret;
    srv_clog_log_struct log;
    U32 i = 0;
#endif

    U32 log_number = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_pre_enter(inst);

    /* close nmgr */
    if (inst->sel_lt_id == MMI_CLOG_LT_ID_MISSED_CALL 
        || inst->sel_lt_id == MMI_CLOG_LT_ID_ALL_CALL)
    {
        if(nmgr_handle != NULL)
        {
            mmi_frm_nmgr_alert_cancel(nmgr_handle);
            nmgr_handle = NULL;
        }
#ifdef __MMI_NCENTER_SUPPORT__
        vsrv_ncenter_close_notification(g_ncenter_hdl);
#endif /*__MMI_NCENTER_SUPPORT__*/
    }

    page = mmi_clog_lt_get_page_by_lt_id(inst, inst->sel_lt_id);

#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    gui_buff = cui_tab_get_screen_gui_buf(SCR_ID_CLOG_LAYOUT,page->scrn_id);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    gui_buff = mmi_frm_scrn_tab_page_get_active_gui_buf();
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */

    count = inst->log_data.total_num;

    if (MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED))
    {
        //gui_buff = NULL;
        MMI_CLOG_CLEAR_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED);
    }

    RegisterHighlightHandler(mmi_clog_lt_item_hlt_hdlr);

#if (!defined(__MMI_CLOG_CALL_TIME__) && !defined(__MMI_CLOG_CALL_COST__) && !defined(__MMI_CLOG_SMS_COUNT__) && !defined(__MMI_CLOG_GPRS_COUNT__))
    {        
        if (!inst->log_data.total_num)
            has_lsk = MMI_FALSE;

    #ifdef __MMI_CLOG_SIM_FILTER__
        count = 0;

        for (i = 0; i<inst->log_data.total_num; i++)
        {
            ret = srv_clog_get_log_by_id(
                inst->log_data.handle,
                mmi_clog_get_id_by_idx(inst->sel_lt_id, i),
                0, 
                &log);

            if (ret != SRV_CLOG_RET_OK)
            {
                break;
            }
            count ++; 
        }
    #endif /*__MMI_CLOG_SIM_FILTER__*/
       
        if (count == 0)
        {
            has_lsk = MMI_FALSE;
        }           
    }
#endif     

    log_number = count;

    wgui_cat1031_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(page->img_id),
        (has_lsk == MMI_FALSE ? NULL : get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id)),
        (has_lsk == MMI_FALSE ? NULL : (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id)),
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        log_number,//(S32) inst->log_data.total_num,
        mmi_clog_lt_get_multi_log_items,
        mmi_clog_lt_get_log_hint,
        NULL,//inst->sel_log_idx,
        mmi_clog_lt_get_page_index_by_lt_id(inst, inst->sel_lt_id),  
        IMG_ID_CLOG_MISSED_CALL,
        IMG_GLOBAL_SIM1,
        gui_buff,
        &category_error_flag);

    mmi_clog_lt_set_key_hdlr(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_page_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]         
 *  lt_id       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static const mmi_clog_lt_tab_page_struct *mmi_clog_lt_get_page_by_lt_id(
                                            mmi_clog_lt_inst_struct *inst,
                                            mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_tab_struct *tab = g_mmi_clog_lt_scrn_data.tab;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MMI_CLOG_LT_ID_MAX_NUM; i++)
    {
        if (tab->page[i] && tab->page[i]->lt_id == lt_id)
            return tab->page[i];
    }
    MMI_CLOG_IT_ASSERT(0);
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_page_index_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]         
 *  lt_id       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_lt_get_page_index_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0    
/* under construction !*/
/* under construction !*/
#endif

    for (i = 0; i < g_mmi_clog_lt_enb_ids.total_num; i++)
    {
        if (g_mmi_clog_lt_enb_ids.lt_ids[i] == lt_id)
            return i;
    }
    
    MMI_CLOG_IT_ASSERT(0);
    
    return 0;
}
#endif /*__MMI_CLOG_TAB_SUPPORT__*/


#ifdef __MMI_BT_PBAP_CLIENT__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_first_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_first_enter_tab(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_scrn_first_enter(inst->self_gid, SCR_ID_CLOG_LAYOUT, (FuncPtr) mmi_clog_bt_link_lt_enter_tab, inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_enter_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
static void mmi_clog_bt_link_lt_enter_tab(mmi_clog_lt_inst_struct *inst)//CHANGE
#else
static void mmi_clog_bt_link_lt_enter_tab(mmi_scrn_essential_struct *scr_info)
#endif
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
#if SRV_PBAPC_LINK_NUM >= 2
    S32 ret1;
    U16  i;
#endif
#ifndef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    mmi_clog_lt_inst_struct *inst;
#endif
    srv_bt_cm_bt_addr bt_addr; 

    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
#ifndef __MMI_TELEPHONY_SUPPORT__
    mmi_frm_tab_struct page_info[SRV_PBAPC_LINK_NUM];
#else
    mmi_frm_tab_struct page_info[SRV_PBAPC_LINK_NUM + 1];
#endif
    U8 index;
    #if 0
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
/* under construction !*/
#else
/* under construction !*/
#endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
#ifdef __MMI_TELEPHONY_SUPPORT__
/* under construction !*/
#endif
#endif
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
#if SRV_PBAPC_LINK_NUM >= 2
    srv_phb_pbapc_get_btd_addr(&bt_addr,0);
    ret = srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr);
    srv_phb_pbapc_get_btd_addr(&bt_addr,1);
    ret1 = srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr);
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_V31, pbapc_cntx->index, ret, ret1, pbapc_cntx->flag[1]);
#else
    srv_phb_pbapc_get_btd_addr(&bt_addr, pbapc_cntx->index);
    ret = srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &bt_addr);
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    inst = (mmi_clog_lt_inst_struct *)scr_info->user_data;//CHANGE
#endif
#ifndef __MMI_TELEPHONY_SUPPORT__
    mmi_clog_bt_link_fill_tab_info(inst, page_info, (SRV_PBAPC_LINK_NUM));
#else
    mmi_clog_bt_link_fill_tab_info(inst, page_info, (SRV_PBAPC_LINK_NUM + 1));
#endif
#if SRV_PBAPC_LINK_NUM >= 2

    if ((!ret && !ret1)|| g_is_missed_call.is_from_local)
    {
        index = 0;
    }
    else if (!ret && ret1)
    {
        if (g_is_missed_call.is_from_bt)
        {
            index = 1;
        }
        else
        {
            if (!pbapc_cntx->flag[1])
            {
                index = 1;
                for (i = 0; i < 4; i++)
                {
                    g_high_index[0][i] = 1;
                    g_high_index[1][i] = 1;    
                }
            }
            else
            {
                switch (inst->sel_lt_id)
                {
                    case MMI_CLOG_LT_ID_DIALED_CALL:
                        index = g_high_index[pbapc_cntx->index][0];
                        break;
                    case MMI_CLOG_LT_ID_MISSED_CALL:
                        index = g_high_index[pbapc_cntx->index][1];
                        break;
                    case MMI_CLOG_LT_ID_RECVED_CALL:
                        index = g_high_index[pbapc_cntx->index][2];
                        break;
                    case  MMI_CLOG_LT_ID_ALL_CALL:
                        index = g_high_index[pbapc_cntx->index][3];
                        break;
                    default:
                        break;
               }
            }
        }

    }
    else
    {    
        if(g_is_missed_call.is_from_bt)
        {
#if defined (__MMI_BT_NOTI_SRV__)
        #if SRV_PBAPC_LINK_NUM >= 2      
            index = srv_pbapc_get_btd_index(&g_is_missed_call.missed_bt_addr[index], SRV_PBAPC_FLAG_CONNECTED);
        #else
            index = srv_pbapc_get_btd_index(&g_is_missed_call.missed_bt_addr, SRV_PBAPC_FLAG_CONNECTED);
        #endif
#endif           
        }
        else
        {
            switch (inst->sel_lt_id)
             {
                 case MMI_CLOG_LT_ID_DIALED_CALL:
                     index = g_high_index[pbapc_cntx->index][0];
                     break;
                 case MMI_CLOG_LT_ID_MISSED_CALL:
                     index = g_high_index[pbapc_cntx->index][1];
                     break;
                 case MMI_CLOG_LT_ID_RECVED_CALL:
                     index = g_high_index[pbapc_cntx->index][2];
                     break;
                 case  MMI_CLOG_LT_ID_ALL_CALL:
                     index = g_high_index[pbapc_cntx->index][3];
                     break;
                 default:
                     break;
            }
        }
    }
#else /*SRV_PBAPC_LINK_NUM >= 2*/
#ifdef __MMI_TELEPHONY_SUPPORT__
if (!ret|| g_is_missed_call.is_from_local)
    {
        index = 0;
    }
    else
    {    
        if(g_is_missed_call.is_from_bt)
        {
#if defined (__MMI_BT_NOTI_SRV__)
        #if SRV_PBAPC_LINK_NUM >= 2      
            index = srv_pbapc_get_btd_index(&g_is_missed_call.missed_bt_addr[index], SRV_PBAPC_FLAG_CONNECTED);
        #else
            index = srv_pbapc_get_btd_index(&g_is_missed_call.missed_bt_addr, SRV_PBAPC_FLAG_CONNECTED);
        #endif
 #endif   
        }
        else
        {
            switch (inst->sel_lt_id)
             {
                 case MMI_CLOG_LT_ID_DIALED_CALL:
                     index = g_high_index[0];
                     break;
                 case MMI_CLOG_LT_ID_MISSED_CALL:
                     index = g_high_index[1];
                     break;
                 case MMI_CLOG_LT_ID_RECVED_CALL:
                     index = g_high_index[2];
                     break;
                 case  MMI_CLOG_LT_ID_ALL_CALL:
                     index = g_high_index[3];
                     break;
                 default:
                     break;
            }

        }
    }

#endif /*__MMI_TELEPHONY_SUPPORT__*/

#endif

    
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_HIGH_LIGHT, index);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    cui_tab_create(inst->self_gid,
        SCR_ID_CLOG_LAYOUT,
        page_info,
        g_mmi_clog_bt_link_tab_id.tab_num,
        (U8) index,
        inst);
#else
    mmi_frm_scrn_tab_enter(
        inst->self_gid,
        SCR_ID_CLOG_LAYOUT,
        (FuncPtr) mmi_clog_bt_link_lt_exit_tab,
        (FuncPtr) mmi_clog_bt_link_lt_enter_tab,
        page_info,
        (U8) g_mmi_clog_bt_link_tab_id.tab_num,
        (U8) index);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_exit_tab
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_exit_tab(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* mmi_frm_general_tab_exit(); */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_enter_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_enter_tab_page(mmi_scrn_essential_struct *grp_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
    S32 ret;
    U8 index;
    mmi_clog_lt_bt_tab_page_struct *page;
    U16 title_id;
    MMI_MENU_ID sel_menu_id;
    MMI_BOOL is_redraw;
    U8* gui_buffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) grp_data->user_data;
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else
    index = mmi_frm_scrn_tab_get_active_page_index();
#endif
    wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);

    page = (mmi_clog_lt_bt_tab_page_struct *)mmi_clog_lt_bt_link_get_page_by_lt_id(inst, g_mmi_clog_bt_link_tab_id.lt_ids[index]);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__    
    ret = cui_tab_enter(
            inst->self_gid,
            page->scrn_id,
            (FuncPtr) mmi_clog_bt_link_lt_exit_tab_page,
            (FuncPtr) mmi_clog_bt_link_lt_enter_tab_page,
            MMI_FRM_TAB_PAGE);
#else
    ret = mmi_frm_scrn_tab_page_enter(
            inst->self_gid,
            SCR_ID_CLOG_LAYOUT,
            page->scrn_id,
            (FuncPtr) mmi_clog_bt_link_lt_exit_tab_page,
            (FuncPtr) mmi_clog_bt_link_lt_enter_tab_page,
            MMI_FRM_TAB_PAGE);
#endif
    if(!ret)
    {
        return;
    }
    
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_ENTER_TAB_PAGE,grp_data->scrn_id, inst->self_gid);

#ifdef __MMI_TELEPHONY_SUPPORT__
    if(grp_data->scrn_id == GRP_ID_CLOG_SUB_LOCAL)
    {
        mmi_clog_lt_refresh_data(inst);
        mmi_clog_lt_show_list(inst);
    }
    else
#endif
    {
        is_redraw = mmi_frm_scenario_is_redrawing();
        MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_BT_PRE_SHOW, is_redraw, -1);
        if(is_redraw)
        {        
            gui_buffer = (U8*)mmi_frm_scrn_get_active_gui_buf();
            mmi_clog_pbapc_show_category(1, gui_buffer);
        }
        else
        {
             mmi_clog_bt_dialer_show(inst);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_no_conn_show_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
void mmi_clog_bt_link_no_conn_show_list(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_tab_page_struct *page)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 category_error_flag;
    U8 index;
    MMI_BOOL has_lsk;
    U8 *gui_buffer;
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_BT_DIALER_NO_CONN_SHOW_LIST);
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ 
    index = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
    gui_buffer = (U8*)cui_tab_get_screen_gui_buf(inst->tab_id,page->scrn_id);
#else
    index = mmi_frm_scrn_tab_get_active_page_index();
    gui_buffer = (U8*)mmi_frm_scrn_tab_page_get_active_gui_buf();
#endif


    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();

    if (!srv_bt_cm_is_profile_connected_ex(SRV_BT_CM_PBAPC_CONNECTION, &pbapc_cntx->addr[pbapc_cntx->index]))
    {
        has_lsk  = MMI_TRUE;
    }
    else
    {
        has_lsk = MMI_FALSE;
    }
    mmi_clog_bt_reset_pbapc_num();
#ifdef __MMI_WEARABLE_DEVICE__
    wgui_swatch_two_line_menu_list_screen
    ((PU8)get_string(STR_ID_CLOG_CALL_LOG),
    (PU8)GetImage(GetRootTitleIcon(MAIN_MENU_CALL_LOG)),
    NULL,
    IMG_ID_CLOG_MISSED_CALL,
    NULL,
    0,
    NULL,
    inst->sel_log_idx,
    gui_buffer);
#else
    wgui_cat1031_show(
    #ifdef __MMI_WEARABLE_DEVICE__
        get_string(STR_ID_CLOG_CALL_LOG),
    #else
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
    #endif
        (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
        has_lsk ? get_string(STR_GLOBAL_CONNECT): NULL,
        NULL,
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        0,
        NULL,
        NULL,
        inst->sel_log_idx,
        index,
        IMG_ID_CLOG_MISSED_CALL,
        IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        gui_buffer,
        &category_error_flag);
#endif
    //SetRightSoftkeyFunction(mmi_clog_lt_rsk_hdlr,KEY_EVENT_UP);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
    #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_get_menu_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static MMI_MENU_ID mmi_clog_bt_get_menu_id(mmi_clog_lt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(lt_id)
    {
        case MMI_CLOG_LT_ID_DIALED_CALL:
            return MENU_ID_CLOG_PBAPC_DIALED_CALL;
        case MMI_CLOG_LT_ID_MISSED_CALL:
            return MENU_ID_CLOG_PBAPC_MISSED_CALL;
        case MMI_CLOG_LT_ID_RECVED_CALL:
            return MENU_ID_CLOG_PBAPC_RECVED_CALL;
        case MMI_CLOG_LT_ID_ALL_CALL:
            return MENU_ID_CLOG_PBAPC_ALL_CALL;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_update_list_by_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
MMI_RET mmi_clog_update_list_by_status(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_set_bt_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
void mmi_clog_set_bt_status(U8 index)
{
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL;
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_SET_STATUS_0,pbapc_cntx->flag[index]);
#if SRV_PBAPC_LINK_NUM >= 2
    #ifdef __MMI_TELEPHONY_SUPPORT__
    g_high_index[pbapc_cntx->index][0] = 1;
    g_high_index[pbapc_cntx->index][1] = 1;
    g_high_index[pbapc_cntx->index][2] = 1;
    g_high_index[pbapc_cntx->index][3] = 1;
    #else /*__MMI_TELEPHONY_SUPPORT__*/
    g_high_index[pbapc_cntx->index][0] = 0;
    g_high_index[pbapc_cntx->index][1] = 0;
    g_high_index[pbapc_cntx->index][2] = 0;
    g_high_index[pbapc_cntx->index][3] = 0; 
    #endif /*__MMI_TELEPHONY_SUPPORT__*/
#else
#ifdef __MMI_TELEPHONY_SUPPORT__

    g_high_index[0] = 1;
    g_high_index[1] = 1;
    g_high_index[2] = 1;
    g_high_index[3] = 1;
#endif
#endif 
    pbapc_cntx->flag[index] = 0;/*still need change .*/
//    pbapc_cntx->only_update[index] = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_exit_tab_page
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_lt_exit_tab_page(mmi_scrn_essential_struct *scr_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    U16 index = 0;
    //wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_pbapc_ex_inst_struct *pbapc_cntx = NULL; 
    MMI_MENU_ID sel_menu_id;
    inst = (mmi_clog_lt_inst_struct *)scr_info->user_data;
    sel_menu_id = mmi_clog_bt_get_menu_id(inst->sel_lt_id);
    //mmi_clog_pbapc_free_op_handle();
    pbapc_cntx = mmi_clog_get_pbapc_cntx_ex();
    switch (sel_menu_id)
    {
        case MENU_ID_CLOG_PBAPC_DIALED_CALL:
            index = 0;
            break;
        case MENU_ID_CLOG_PBAPC_MISSED_CALL:
            index = 1;
            break;

        case MENU_ID_CLOG_PBAPC_RECVED_CALL:
            index = 2;
            break;
        case MENU_ID_CLOG_PBAPC_ALL_CALL:
            index = 3;
            break;
        default:
            break;
    }
#if SRV_PBAPC_LINK_NUM >= 2
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    g_high_index[pbapc_cntx->index][index] = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    g_high_index[pbapc_cntx->index][index] = mmi_frm_scrn_tab_get_active_page_index();  
#endif /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/

MMI_TRACE(MMI_CLOG_TRC_INFO,TRC_MMI_CLOG_PBAPC_ENTER_TAB_PAGE_MENU,pbapc_cntx->index,g_high_index[pbapc_cntx->index][index]);

#else /*SRV_PBAPC_LINK_NUM >= 2*/
#ifdef __MMI_TELEPHONY_SUPPORT__
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    g_high_index[index] = cui_tab_get_select_index(SCR_ID_CLOG_LAYOUT);
#else /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
    g_high_index[index] = mmi_frm_scrn_tab_get_active_page_index();  
#endif /*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
#endif
#endif/*SRV_PBAPC_LINK_NUM >= 2*/
    wgui_set_menu_empty_string_by_id(STR_GLOBAL_EMPTY);
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_bt_scrn_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_clog_lt_bt_scrn_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) evt->user_data;
        
    switch (evt->evt_id)
    {
        case EVT_ID_SCRN_ACTIVE:
        {
#ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_clog_lt_load_log_ids(inst);
            }
            else
#endif /*__MMI_CLOG_MARK_SEVERAL__*/
            {
                mmi_clog_lt_refresh_data(inst);
            }
            mmi_clog_lt_show_list(inst);
        }
        break;

        default:
            break;
    }  

    return MMI_RET_OK;
}


#ifdef __MMI_BT_PBAP_CLIENT__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_lt_get_page_index_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_bt_link_lt_get_page_index_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < 2; i++)
    {
        if (g_mmi_clog_bt_link_tab_id.lt_ids[i] == lt_id)
            return i;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_bt_link_get_page_by_lt_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static const mmi_clog_lt_bt_tab_page_struct *mmi_clog_lt_bt_link_get_page_by_lt_id(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_bt_id_enum lt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_bt_tab_struct *tab = g_mmi_clog_bt_link_lt_scrn_data.tab;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
    U32 j;
#ifdef __MMI_TELEPHONY_SUPPORT__
    for (i = 0; i < (SRV_PBAPC_LINK_NUM +1); i++)
#else
    for(i =0; i< SRV_PBAPC_LINK_NUM; i++)
#endif
        for(j = 0; j< 4; j++ )
    {
            if (tab->page[i] && tab->page[i]->image[j]->lt_id == lt_id && tab->page[i]->image[j]->lt_type == inst->sel_lt_id)
                return tab->page[i]->image[j];
    }
#else
#ifdef __MMI_TELEPHONY_SUPPORT__
    for (i = 0; i < (SRV_PBAPC_LINK_NUM +1); i++)
#else
    for(i =0; i< SRV_PBAPC_LINK_NUM; i++)
#endif
    {
        if (tab->page[i] && tab->page[i]->lt_id == lt_id)
            return tab->page[i];
    }
#endif
    MMI_CLOG_IT_ASSERT(0);
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bt_link_fill_tab_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_bt_link_fill_tab_info(mmi_clog_lt_inst_struct *inst, mmi_frm_tab_struct *page_info, U32 page_num)
{
    U32 i;
    const mmi_clog_lt_bt_tab_page_struct *page;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < g_mmi_clog_bt_link_tab_id.tab_num && i < page_num; i++)
    {
        page = mmi_clog_lt_bt_link_get_page_by_lt_id(inst, g_mmi_clog_bt_link_tab_id.lt_ids[i]);
        page_info[i].screen_id = page->scrn_id;
#if defined (__MMI_FTE_SUPPORT__) && defined(__MMI_MAINLCD_240X320__)
        page_info[i].tab_string = NULL;
        page_info[i].tab_icon = GetImage(page->img_id);
#else
        page_info[i].tab_icon = NULL;//(U8*) GetImage(page->img_id);
        page_info[i].tab_string = GetString(page->str_id);
#endif
        page_info[i].tab_entry_func = g_mmi_clog_bt_link_lt_scrn_data.tab->page_hdlr;
        page_info[i].user_data = inst;
    }

}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_show_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_show_list(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *gui_buffer;
    S32 has_lsk = MMI_FALSE;
    S32 category_error_flag;
    U32 log_number = 0;
    U32 count = 0;
#ifdef __MMI_CLOG_SIM_FILTER__
    srv_clog_log_struct log;
    S32 ret;
    U32 i = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_pre_enter(inst);

/* close nmgr */
    if (inst->sel_lt_id == MMI_CLOG_LT_ID_MISSED_CALL 
        || inst->sel_lt_id == MMI_CLOG_LT_ID_ALL_CALL)
    {
        if(nmgr_handle != NULL)
        {
            mmi_frm_nmgr_alert_cancel(nmgr_handle);
            nmgr_handle = NULL;
        }

#ifdef __MMI_NCENTER_SUPPORT__
        vsrv_ncenter_close_notification(g_ncenter_hdl);
#endif /*__MMI_NCENTER_SUPPORT__*/
    }

    count = inst->log_data.total_num;
    if (count)
        has_lsk = MMI_TRUE;

#ifdef __MMI_CLOG_SIM_FILTER__
    count = 0;

    for (i=0; i<inst->log_data.total_num; i++)
    {
        ret = srv_clog_get_log_by_id(inst->log_data.handle,
            mmi_clog_get_id_by_idx(inst->sel_lt_id, i), 0, &log);
        if (ret != SRV_CLOG_RET_OK)
        {
            break;
        }
        count++;
    }   
#endif /*__MMI_CLOG_SIM_FILTER__*/

    log_number = count;
    if (log_number == 0)
#ifndef __MMI_CLOG_FPBW__        
        has_lsk = MMI_FALSE;
#else /*__MMI_CLOG_FPBW__*/
    {
        mmi_clog_popup(STR_GLOBAL_EMPTY, MMI_EVENT_FAILURE, inst->self_gid, inst);
        mmi_frm_scrn_close_active_id();
        return ;
    }
#endif /*__MMI_CLOG_FPBW__*/

    gui_buffer = mmi_frm_scrn_get_active_gui_buf();
    if (MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED))
    {
        gui_buffer = NULL;
        MMI_CLOG_CLEAR_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED);
    }

#ifdef __MMI_CLOG_MARK_SEVERAL__
    if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
    {
        RegisterHighlightHandler(mmi_clog_mark_several_hlt_hdlr);
        
        wgui_cat1024_show(
            get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
            (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
            get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id),
            (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id),
            get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
            (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
            NULL,
            log_number,//(S32) inst->log_data.total_num,
            mmi_clog_lt_get_multi_log_items,
        #ifndef __MMI_CLOG_FPBW__
            mmi_clog_lt_get_log_hint,
        #else /*__MMI_CLOG_FPBW__*/
            NULL,
        #endif /*__MMI_CLOG_FPBW__*/
            mmi_clog_mark_several_get_state,
            mmi_clog_mark_several_set_state,
        #ifndef __MMI_CLOG_FPBW__
            IMG_ID_CLOG_MISSED_CALL,
            IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        #else /*__MMI_CLOG_FPBW__*/
            NULL,
            NULL,
        #endif /*__MMI_CLOG_FPBW__*/
            inst->sel_log_idx,
            gui_buffer);

        mmi_clog_mark_several_set_key_hdlr(inst);
        return;
    }
#endif /*__MMI_CLOG_MARK_SEVERAL__*/
 
#if !defined(__MMI_CLOG_TAB_SUPPORT__)
    RegisterHighlightHandler(mmi_clog_lt_item_hlt_hdlr);

  #ifndef __MMI_CLOG_FPBW__

	wgui_override_list_menu_slim_style(WGUI_LIST_MENU_SLIM_STYLE_DRAW_ICON);
    wgui_cat1031_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
        (has_lsk == MMI_FALSE ? NULL : get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id)),
        (has_lsk == MMI_FALSE ? NULL : (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id)),
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        log_number,//(S32) inst->log_data.total_num,
        mmi_clog_lt_get_multi_log_items,
        mmi_clog_lt_get_log_hint,
        inst->sel_log_idx,
        0,
        IMG_ID_CLOG_MISSED_CALL,
        IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        gui_buffer,
        &category_error_flag);
  	wgui_restore_list_menu_slim_style();

  #else /*__MMI_CLOG_FPBW__*/
    wgui_cat1032_show(
        get_string(mmi_clog_lt_get_title_by_lt_id(inst, inst->sel_lt_id)),
        (PU8)GetImage(GetRootTitleIcon(g_mmi_clog_lt_scrn_data.root_menu_id)),
        (has_lsk == MMI_FALSE ? NULL : get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->str_id)),
        (has_lsk == MMI_FALSE ? NULL : (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_LSK]->img_id)),
        get_string(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->str_id),
        (PU8)GetImage(g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_RSK]->img_id),
        log_number,//(S32) inst->log_data.total_num,
        mmi_clog_lt_get_multi_log_items,
        NULL,
        inst->sel_log_idx,
        0,
        NULL,
        IMG_GLOBAL_SIM1, /* Just to get image demision but not care what it is */
        gui_buffer,
        &category_error_flag);
  #endif /**__MMI_CLOG_FPBW__*/
  
    mmi_clog_lt_set_key_hdlr(inst);
    
 #endif /*!defined(__MMI_CLOG_TAB_SUPPORT__)*/
} 


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_pre_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_pre_enter(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
    mmi_clog_lt_tb_create(inst);
    mmi_clog_lt_tb_refresh(inst);
#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_log_item
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item_index          [IN]        
 *  str_buff            [IN]        
 *  img_buff_p          [IN]        
 *  str_img_mask        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static pBOOL mmi_clog_lt_get_log_item(S32 item_index, UI_string_type str_buff, U8 **img_buff_p, U8 str_img_mask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    mmi_clog_lt_inst_struct *inst;
    srv_clog_log_struct log;
    U16 sim_image_id;
    U32 sim_idx;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    if (item_index < 0 || item_index >= (S32) inst->log_data.total_num)
    {
        MMI_CLOG_ASSERT(item_index < (S32) inst->log_data.total_num);
        return MMI_FALSE;
    }
#ifdef __MMI_TELEPHONY_SUPPORT__
    ret = srv_clog_get_log_by_id(
                inst->log_data.handle,
                mmi_clog_get_id_by_idx(inst->sel_lt_id, item_index),
                0, // default All fileds
                &log);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    if (ret != SRV_CLOG_RET_OK)
    {
        str_buff[0] = '\0';
        *img_buff_p = NULL;
        return MMI_FALSE;
    }
    mmi_clog_lt_get_string(inst, &log, str_buff);
    
#ifndef __MMI_CLOG_FPBW__

  #if (MMI_MAX_SIM_NUM >= 2)
    img_buff_p[0] =
        (U8*) GetImage(mmi_clog_get_image((const srv_clog_log_identity_struct*)&log.data.call_log));

  /* For list_icon2, as IMG_GLOBAL_SIMx is defined in number order, so we can use the rule to slim it,
   if unlickily this rule is changed, we can easy find this error in SQC stage, 
   better to provide a common API for this in a common module
  */

    sim_idx = MMI_CLOG_BIT2IDX(log.data.call_log.sim_id);
    sim_image_id = IMG_GLOBAL_SIM1 + sim_idx;

    img_buff_p[1] = (U8 *)GetImage(sim_image_id);
    
  #else /* MMI_MAX_SIM_NUM >= 2 */

    *img_buff_p =
        (U8*) GetImage(mmi_clog_get_image((const srv_clog_log_identity_struct*)&log.data.call_log));

  #endif /* MMI_MAX_SIM_NUM >= 2 */

#else /*__MMI_CLOG_FPBW__*/

  #if (MMI_MAX_SIM_NUM >= 2)
  /* For list_icon2, as IMG_GLOBAL_SIMx is defined in number order, so we can use the rule to slim it,
   if unlickily this rule is changed, we can easy find this error in SQC stage, 
   better to provide a common API for this in a common module
  */
    img_buff_p[0] = NULL;
    sim_idx = MMI_CLOG_BIT2IDX(log.data.call_log.sim_id);
    sim_image_id = IMG_GLOBAL_SIM1 + sim_idx; 
    img_buff_p[1] = (U8 *)GetImage(sim_image_id);
    
  #else /* MMI_MAX_SIM_NUM >= 2 */
  
    *img_buff_p = NULL;
  
  #endif /* MMI_MAX_SIM_NUM >= 2 */
    
#endif /*__MMI_CLOG_FPBW__*/
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_string
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst            [IN]     
 *  log             [IN]     
 *  str_buff        [OUT]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_get_string(mmi_clog_lt_inst_struct *inst, srv_clog_log_struct *log, WCHAR *str_buff)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_CLOG_FPBW__
    WCHAR post[20];
#endif /*__MMI_CLOG_FPBW__*/
    U32 post_len = 0;   
    const WCHAR *unknown_cid;
    srv_clog_call_log_struct *call_log = &log->data.call_log;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_CLOG_FPBW__
    if (call_log->total_num > 1)
    {
        kal_wsprintf(post, " (%d)", call_log->total_num);
        post_len = mmi_wcslen(post);
    }
#endif /*__MMI_CLOG_FPBW__*/
    if (mmi_clog_is_name_empty(log) && mmi_clog_is_cid_empty(log))
    {
        unknown_cid = (const WCHAR*)get_string(STR_ID_CLOG_UNKNOWN_NUMBER);	
        mmi_wcsncpy((WCHAR*) str_buff, unknown_cid, MAX_SUBMENU_CHARACTERS);
    }
    else if (mmi_clog_is_name_empty(log))
    {
        mmi_wcsncpy((WCHAR*) str_buff, (const WCHAR*)call_log->cid, MAX_SUBMENU_CHARACTERS - post_len);
    }
    else
    {
        mmi_wcsncpy((WCHAR*) str_buff, (const WCHAR*)call_log->name, MAX_SUBMENU_CHARACTERS - post_len);
    }
#ifndef __MMI_CLOG_FPBW__
    if (post_len)
        mmi_wcscat((WCHAR*) str_buff, (const WCHAR*)post);
#endif /*__MMI_CLOG_FPBW__*/
}


#ifndef __MMI_CLOG_FPBW__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_log_hint
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item_index      [IN]        
 *  hint_array      [OUT]         
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_lt_get_log_hint(S32 item_index, UI_string_type *hint_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    mmi_clog_lt_inst_struct *inst;
    srv_clog_log_struct log;
    applib_time_struct app_time;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    if (item_index < 0 || item_index >= (S32) inst->log_data.total_num)
    {
        /* MMI_CLOG_ASSERT(item_index < (S32) inst->log_data.total_num); */
        return MMI_FALSE;
    }
#ifdef __MMI_TELEPHONY_SUPPORT__
    ret = srv_clog_get_log_by_id(
                inst->log_data.handle,
                mmi_clog_get_id_by_idx(inst->sel_lt_id, item_index),
                0, // default All fileds
                &log);
#endif /* __MMI_TELEPHONY_SUPPORT__ */

    if (ret != SRV_CLOG_RET_OK)
    {
        hint_array[0][0] = 0;
        return MMI_FALSE;
    }
    if (log.data.call_log.timestamp[SRV_CLOG_LASTEST_TIME_IDX] == 0)
    {
        hint_array[0][0] = 0;
    }
    else
    {
        mmi_clog_time_utc2app(log.data.call_log.timestamp[SRV_CLOG_LASTEST_TIME_IDX], &app_time);
        date_string((UI_time*) & app_time, hint_array[0], DT_IDLE_SCREEN);
        mmi_wcscat(hint_array[0], L" ");
        time_string((UI_time*) & app_time, 
            (UI_string_type) (hint_array[0] + mmi_wcslen((const WCHAR*)hint_array[0])), 
            DT_IDLE_SCREEN);
    }
    return MMI_TRUE;
}

#endif /*__MMI_CLOG_FPBW__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_multi_log_items
 * DESCRIPTION
 *  Asyncdynamic list item load function
 * PARAMETERS
 *  start_index      :    [IN]     Start index of menu item
 *  menu_data        :    [OUT]    A pointer of parameter to store the menu data
 *  item_count        :    [IN]     The number of load menu items
 * RETURNS
 *  S32
 * RETURN VALUES
 *  Number of items can be retrieved
 *****************************************************************************/
static S32 mmi_clog_lt_get_multi_log_items(S32 start_index, gui_iconlist_menu_item *menu_data, S32 item_count)
{
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    S32 total_count;
    S32 i, items = 0;
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();
    
    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    total_count = (S32) inst->log_data.total_num;
    
    for (i = start_index; items < item_count && i < total_count; i++, items++)
    {
        mmi_clog_lt_get_log_item(i, 
            menu_data[items].item_list[0], 
            menu_data[items].image_list, 0);
    }
    return items;
}


#define MMI_CLOG_LT_HDLR


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_item_hlt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sel     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_item_hlt_hdlr(S32 sel)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    inst->sel_log_idx = sel;
    mmi_clog_lt_update_sel_log_id(inst);

#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
    mmi_clog_lt_tb_refresh(inst);
#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/ 
}


#if defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WEARABLE_DEVICE__)
extern U16 g_pen_to_control;
extern fixed_list_menu MMI_fixed_list_menu;

mmi_pen_hdlr mmi_clog_lt_entry_options_long_tap_hdlr(mmi_pen_point_struct pos)
{

     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_pen_to_control != DM_TITLE1)
	{

		int iwidth = 0;
		int iheight = 0;
		
		MMI_fixed_list_menu.item_measure_function(NULL, MMI_fixed_list_menu.common_item_data, &iwidth, &iheight);

		if(pos.y >= MMI_fixed_list_menu.highlight_y && pos.y <= (iheight + MMI_fixed_list_menu.highlight_y))

		{
			g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_LSK]();
		}
	}
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_set_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_set_key_hdlr(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->log_data.total_num)
    {
        mmi_ucm_handle_sendkeys_for_call(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_SEND], KEY_EVENT_DOWN);

    #ifdef __MMI_IP_KEY__
/* under construction !*/
    #endif 

        mmi_clog_lt_set_csk_key(MMI_TRUE);
        SetLeftSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_LSK], KEY_EVENT_UP);
#if defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_WEARABLE_DEVICE__)

		  wgui_register_pen_long_tap_handler(mmi_clog_lt_entry_options_long_tap_hdlr);
#endif
    }
    else
    {
        /* only show LSK option if in tab style and has advanced menu items */
#if (defined(__MMI_CLOG_CALL_TIME__) || defined(__MMI_CLOG_CALL_COST__) || defined(__MMI_CLOG_SMS_COUNT__) || defined(__MMI_CLOG_GPRS_COUNT__))
        if (inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
        {
            mmi_clog_lt_set_csk_key(MMI_FALSE);
            SetLeftSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_LSK], KEY_EVENT_UP);
        }
#endif /* __MMI_CLOG_CALL_TIME__ || __MMI_CLOG_CALL_COST__ || __MMI_CLOG_SMS_COUNT__ || __MMI_CLOG_GPRS_COUNT__ */

    }

    SetRightSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_RSK], KEY_EVENT_UP);

#ifdef __MMI_TOUCH_SCREEN__
    wgui_set_horizontal_tab_bar_select_callback(mmi_frm_set_cur_sel_page);
#endif 
  
#if defined ( __MMI_FTE_SUPPORT__) && defined(__MMI_TOUCH_SCREEN__)
    mmi_clog_lt_set_tap_hdlr(inst);
#endif 

#ifdef __MMI_CLOG_SIM_SYNC_TEST__
    {
        extern void srv_clog_sim_pwon_test(void);
        extern void srv_clog_sim_pwoff_test(void);
        extern void srv_clog_sim_sat_refresh_test(void);

        SetKeyHandler(srv_clog_sim_pwon_test, KEY_VOL_UP, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_pwoff_test, KEY_VOL_DOWN, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_sat_refresh_test, KEY_CAMERA, KEY_EVENT_UP);

        SetKeyHandler(srv_clog_sim_pwon_test, KEY_STAR, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_pwoff_test, KEY_POUND, KEY_EVENT_UP);
        SetKeyHandler(srv_clog_sim_sat_refresh_test, KEY_0, KEY_EVENT_UP);
    }

#endif /* __MMI_CLOG_SIM_SYNC_TEST__ */ 

#ifdef __MMI_CLOG_REVISE_LOGS_TEST__
    {
        extern void srv_clog_revise_log_test(void);

        SetKeyHandler(srv_clog_revise_log_test, KEY_9, KEY_EVENT_UP);
    }
#endif /* __MMI_CLOG_REVISE_LOGS_TEST__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_set_csk_key
 * DESCRIPTION
 *  
 * PARAMETERS
 *  is_predef       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_set_csk_key(S32 is_predef)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_predef)
    {
        EnableCenterSoftkey(
            g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_CSK]->str_id,
            g_mmi_clog_lt_scrn_data.key_tbl->softkey[MMI_CLOG_KEY_CSK]->img_id);

        SetCenterSoftkeyFunction(g_mmi_clog_lt_scrn_data.key_tbl->hdlr[MMI_CLOG_KEY_CSK], KEY_EVENT_UP);
    }
    else
    {
        EnableCenterSoftkey(0, IMG_GLOBAL_OPTION_CSK);
        SetCenterSoftkeyFunction(mmi_clog_lt_lsk_hdlr, KEY_EVENT_UP);
    }
    redraw_center_softkey();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_lsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_lsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_op_enter();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_rsk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_rsk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
    mmi_frm_group_close(GRP_ID_CLOG_LAYOUT);
#else /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
    mmi_frm_scrn_close_active_id();
#endif /* __MMI_TAB_BAR_SUPPORT_TAB_PAGE__ */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_csk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_csk_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_viewer_enter();
}

#ifdef __MMI_IP_KEY__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_IP_KEY__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_send_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_send_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_act_proc(MMI_CLOG_OP_MID_MAKE_CALL, MMI_CLOG_ACT_FLAG_CALL_BY_SEND_KEY);
}

#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_create
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_create(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U32 i;
    U32 j;
    U8 *enb_icons[MMI_CLOG_LT_TB_ID_MAX_ITEM];
    U8 *dis_icons[MMI_CLOG_LT_TB_ID_MAX_ITEM];
    U8 *strings[MMI_CLOG_LT_TB_ID_MAX_ITEM];
    const mmi_clog_lt_tb_struct *tb;
    const mmi_clog_lt_tb_item_struct *item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_clog_lt_scrn_data.fte)
        return;
    tb = g_mmi_clog_lt_scrn_data.fte->tb;
    if (!tb || !tb->items || !tb->total_num)
        return;
    
    for (i = 0, j = 0; i < tb->total_num; i++)
    {
        item = &tb->items[i];
        if (!item)
            break;
        enb_icons[j] = (U8*) GetImage(item->enb_img_id);
        dis_icons[j] = (U8*) GetImage(item->dis_img_id);
        strings[j] = (U8*) get_string(item->str_id);
        j++;
    }
    wgui_icon_bar_setup(j++, enb_icons, dis_icons, strings, tb->tb_hdlr);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_refresh
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_refresh(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 enb_bits;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    enb_bits = mmi_clog_lt_tb_get_enb_items(inst);
    mmi_clog_lt_tb_set_enb_state(inst, (mmi_clog_lt_tb_id_enum)enb_bits, MMI_TRUE);
    wgui_icon_bar_update();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_get_enb_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static U32 mmi_clog_lt_tb_get_enb_items(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    U32 enb_bits = MMI_CLOG_LT_TB_ID_ALL;
    srv_clog_log_struct log;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->log_data.total_num == 0)
    {
        enb_bits = 0;
        return enb_bits;
    }
#ifdef __MMI_TELEPHONY_SUPPORT__
    ret = srv_clog_get_log_by_id(
            inst->log_data.handle,
            inst->sel_log_id,
            SRV_CLOG_LOG_FIELD_IDENTITY | SRV_CLOG_LOG_FIELD_CID,
            &log);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
    if (ret != SRV_CLOG_RET_OK || mmi_clog_is_cid_empty(&log))
    {
        enb_bits = 0;
        return enb_bits;
    }

    if (log.data.call_log.sub_type == SRV_CLOG_CALL_TYPE_VOIP)
    {
        MMI_CLOG_CLEAR_BIT(enb_bits, MMI_CLOG_LT_TB_ID_ALL_MSG | MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL);
    }
    else
    {
    #ifndef __MMI_UNIFIED_COMPOSER__
    #ifdef __MMI_MMS__
        if (!mms_is_ready())
            MMI_CLOG_CLEAR_BIT(enb_bits, MMI_CLOG_LT_TB_ID_SEND_MMS);
    #endif /* __MMI_MMS__ */ 
    #endif /* __MMI_UNIFIED_COMPOSER__ */ 
    }

    return enb_bits;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_action_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_action_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;
    const mmi_clog_lt_tb_item_struct *item;
    mmi_clog_op_mid_enum op_mid = MMI_CLOG_OP_MID_MAKE_CALL;
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    item = mmi_clog_lt_get_tb_item_by_index(inst, index);
    switch (item->tb_id)
    {
        case MMI_CLOG_LT_TB_ID_MAKE_CALL:
            op_mid = MMI_CLOG_OP_MID_MAKE_CALL;

#ifdef __OP01_3G__
           // flags = MMI_CLOG_ACT_FLAG_CALL_VOICE_ONLY;
#endif
            break;

#if(defined(__OP01_3G__) && defined(__MMI_VIDEO_TELEPHONY__)) 
        case MMI_CLOG_LT_TB_ID_MAKE_VIDEO_CALL:
            op_mid = MMI_CLOG_OP_MID_MAKE_CALL;
            flags = MMI_CLOG_ACT_FLAG_CALL_VIDEO_ONLY;
            break;
#endif /* __OP01_3G__ && __MMI_VIDEO_TELEPHONY__ */

        case MMI_CLOG_LT_TB_ID_SEND_MSG:
            op_mid = MMI_CLOG_OP_MID_SEND_MSG;
            break;

        case MMI_CLOG_LT_TB_ID_SEND_SMS:
            op_mid = MMI_CLOG_OP_MID_SEND_SMS;
            break;

        case MMI_CLOG_LT_TB_ID_SEND_MMS:
            op_mid = MMI_CLOG_OP_MID_SEND_MMS;
            break;

        default:
            MMI_CLOG_IT_ASSERT(0);
            break;
    }

    mmi_clog_lt_act_proc(op_mid, flags);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_tb_item_by_index
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [?]         
 *  index       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static const mmi_clog_lt_tb_item_struct *mmi_clog_lt_get_tb_item_by_index(mmi_clog_lt_inst_struct *inst, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const mmi_clog_lt_tb_struct *tb;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_clog_lt_scrn_data.fte)
        return NULL;

    tb = g_mmi_clog_lt_scrn_data.fte->tb;

    if (!tb || !tb->items || !tb->total_num)
        return NULL;

    MMI_CLOG_ASSERT(index >= 0 && index < tb->total_num);

    return &tb->items[index];
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tb_set_enb_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [?]         
 *  ids         [IN]        
 *  enable      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tb_set_enb_state(mmi_clog_lt_inst_struct *inst, mmi_clog_lt_tb_id_enum ids, S32 enable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const mmi_clog_lt_tb_item_struct *item;
    const mmi_clog_lt_tb_struct *tb;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_clog_lt_scrn_data.fte)
        return;

    tb = g_mmi_clog_lt_scrn_data.fte->tb;

    if (!tb || !tb->items || !tb->total_num)
        return;
    
    for (i = 0; i < tb->total_num; i++)
    {
        item = &tb->items[i];
        if (!item)
            break;
        if (MMI_CLOG_CHECK_BIT(ids, item->tb_id))
        {
            wgui_icon_bar_set_item_enable_state(i, (MMI_BOOL)enable);
        }
        else
        {
            wgui_icon_bar_set_item_enable_state(i, (MMI_BOOL)!enable);
        }
    }
}

#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/


#if defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_set_tap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_set_tap_hdlr(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_register_tap_callback(mmi_clog_lt_tap_action_hdlr);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_tap_action_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  tap_type        [IN]        
 *  index           [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_tap_action_hdlr(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
#if !defined(__MMI_WEARABLE_DEVICE__)
    if (tap_type == ENUM_TAP_ON_HIGHLIGHTED_ITEM)
#endif
    {
        mmi_clog_lt_viewer_enter();
    }
}

#endif /*defined (__MMI_FTE_SUPPORT__) && defined (__MMI_TOUCH_SCREEN__)*/


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_op_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_op_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_op_para_struct para;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    para.flags = 0;
    if (inst->lt_type == MMI_CLOG_LT_TYPE_LIST)
        para.type = MMI_CLOG_OP_TYPE_LT_LIST;
    
#ifdef __MMI_CLOG_TAB_SUPPORT__
    else if (inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
        para.type = MMI_CLOG_OP_TYPE_LT_TAB;
#endif /* __MMI_CLOG_TAB_SUPPORT__ */

    else
    {
        MMI_CLOG_IT_ASSERT(0);
    }
    para.sel_lt_id = inst->sel_lt_id;
    para.handle = inst->log_data.handle;
    para.log_id = inst->sel_log_id;
    mmi_clog_op_enter(inst->self_gid, &para);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_viewer_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_viewer_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    S32 ret;
//    U32 merge_style;

    mmi_clog_lt_inst_struct *inst;
    mmi_clog_vr_create_struct create;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    create.handle = inst->log_data.handle;
    create.log_id = inst->sel_log_id;

    create.mode = MMI_CLOG_VR_DEF_MODE;
    create.style = MMI_CLOG_VR_DEF_STYLE;
    if (inst->lt_type == MMI_CLOG_LT_TYPE_LIST)
        MMI_CLOG_SET_BIT(create.style, MMI_CLOG_VR_STYLE_LT_LIST);
#ifdef __MMI_CLOG_TAB_SUPPORT__
    else if (inst->lt_type == MMI_CLOG_LT_TYPE_TAB)
        MMI_CLOG_SET_BIT(create.style, MMI_CLOG_VR_STYLE_LT_TAB);
#endif /* __MMI_CLOG_TAB_SUPPORT__ */
    else
    {
        MMI_CLOG_IT_ASSERT(0);
    }

    create.lt_type = inst->lt_type;
    create.sel_lt_id = inst->sel_lt_id;
    create.sup_merge = (MMI_CLOG_STYLE_MERGE == 0 ? MMI_FALSE : MMI_TRUE);

    mmi_clog_vr_create_and_run(inst->self_gid, &create);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_act_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  op_mid      [IN]        
 *  flags       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static MMI_ID mmi_clog_lt_act_proc(mmi_clog_op_mid_enum op_mid, U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    mmi_clog_op_para_struct para;
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    mmi_clog_act_para_struct para;
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    para.handle = inst->log_data.handle;
    para.log_id = inst->sel_log_id;
    para.op_mid = op_mid;
    para.sel_lt_id = inst->sel_lt_id;
    para.flags = flags;
#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    return mmi_clog_op_run(inst->self_gid, &para);
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    return mmi_clog_act_proc(inst->self_gid, &para);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
}

#define MMI_CLOG_LT_LOG


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_log_start
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_log_start(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
//    U32 style;
    srv_clog_create_struct create;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_CMN_INST_FLAG_EXT_HANDLE))
    {
        srv_clog_init_para(SRV_CLOG_PARA_CREATE, &create);
        create.user_data = inst;
        inst->log_data.handle = srv_clog_create(&create);
        MMI_CLOG_ASSERT(inst->log_data.handle);
    }
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_data
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_data(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_update_read_status(inst);
    mmi_clog_lt_load_log_ids(inst);
    /* Can only refresh current index of select lt_id */
    mmi_clog_lt_refresh_sel_index(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_update_read_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_update_read_status(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 ur_num;
    const mmi_clog_lt_id_attr_struct *attr;
    srv_clog_update_all_logs_req_struct req_data;

    MMI_ID gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //if (inst->sel_lt_id != MMI_CLOG_LT_ID_MISSED_CALL && inst->sel_lt_id != MMI_CLOG_LT_ID_ALL_CALL)
    //    return;

    gid = mmi_frm_scrn_get_active_id();

    if ((gid != SCR_ID_CLOG_LAYOUT
#ifdef __MMI_BT_PBAP_CLIENT__
      && gid != GRP_ID_CLOG_SUB_LOCAL
#endif /* __MMI_BT_PBAP_CLIENT__ */
        )
     || (inst->sel_lt_id != MMI_CLOG_LT_ID_MISSED_CALL && inst->sel_lt_id != MMI_CLOG_LT_ID_ALL_CALL))
        return;

    ur_num = srv_clog_get_unread_missed_call_num();
    if (ur_num == 0)
        return;

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_UPDATE_READ_STATUS,
        inst->self_gid,
        inst->sel_lt_id,
        inst->sel_log_idx,
        inst->sel_log_id));

    attr = mmi_clog_get_attr_by_lt_id(inst->sel_lt_id);

    memcpy((srv_clog_log_identity_struct*) & req_data, &attr->idt, sizeof(srv_clog_log_identity_struct));
    req_data.req_fields = SRV_CLOG_LOG_FIELD_UNREAD_NUM;
    req_data.read = MMI_TRUE;
    srv_clog_update_all_logs(inst->log_data.handle, 0, &req_data, NULL);
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_sel_index
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_sel_index(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    U32 j;
    U32 max_num;
    U16 old_sel_idx;
    SRV_CLOG_ID old_sel_log_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (SRV_CLOG_IS_ELM_INVALID(inst->sel_log_id))
    {
        mmi_clog_lt_update_sel_log_id(inst);
        return;
    }

    if (inst->sel_log_id == mmi_clog_get_id_by_idx(inst->sel_lt_id, inst->sel_log_idx))
        return;

    old_sel_idx = inst->sel_log_idx;
    old_sel_log_id = inst->sel_log_id;
    max_num = inst->log_data.total_num;
    for (i = 0, j = inst->sel_log_idx; i < max_num; i++)
    {
        if (j >= max_num)
            j = 0;
        if (old_sel_log_id == mmi_clog_get_id_by_idx(inst->sel_lt_id, j))
        {
            inst->sel_log_idx = j;
            break;

        }
        j++;
    }

    if (i == max_num)   /* not found, must be deleted, try to highlight next one */
    {
        /* If some log before current selected one are deleted, should find the right index above,
           if current selected log or some log after this is deleted, just highlight next log,
           if current log is the last one, just highlight the previous one, 
           the rule is not to change user's view point except use make a call and merge it */
        if (inst->sel_log_idx > 0 && inst->sel_log_idx >= max_num)
        {
            inst->sel_log_idx--;
        }
        mmi_clog_lt_update_sel_log_id(inst);
    }
    if (inst->sel_log_idx != old_sel_idx)
        MMI_CLOG_SET_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED);

    MMI_CLOG_IT_TRACE((
        MMI_CLOG_TRC_INFO,
        TRC_MMI_CLOG_LT_REFRESH_SEL_INDEX,
        old_sel_log_id,
        inst->sel_log_id,
        old_sel_idx,
        inst->sel_log_idx,
        MMI_CLOG_CHECK_BIT(inst->flags, MMI_CLOG_LT_FLAG_CUR_SEL_IDX_CHANGED)));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_load_log_ids
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_load_log_ids(mmi_clog_lt_inst_struct *inst)
{
#ifdef __MMI_TELEPHONY_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_clog_log_identity_struct identity;
    srv_clog_num_info_struct num_info;
    const mmi_clog_lt_id_attr_struct *attr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_clog_init_para(SRV_CLOG_PARA_NUM_INFO, &num_info);
    attr = mmi_clog_get_attr_by_lt_id(inst->sel_lt_id);
    SRV_CLOG_INIT_IDT(
        &identity,
        attr->idt.cate,
        attr->idt.sim_id,
        attr->idt.log_type,
        attr->idt.sub_type);
    
    srv_clog_get_list_num_info(inst->log_data.handle,
        (const srv_clog_log_identity_struct *) &identity, &num_info);
    inst->log_data.total_num = num_info.num[SRV_CLOG_LOG_NUM_TYPE_TOTAL_LOGS];
#endif /* __MMI_TELEPHONY_SUPPORT__ */
}


#ifdef __MMI_CLOG_EVENT_REFRESH_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_srv_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [IN]     
 * RETURNS
 *  
 *****************************************************************************/
MMI_RET mmi_clog_lt_srv_evt_hdlr(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    mmi_clog_lt_inst_struct *inst;
    mmi_clog_lt_cntx_struct *cntx = mmi_clog_lt_get_cntx();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_CLOG_LT_INST_MAX_NUM == 1)
    {
        inst = &cntx->inst_list[0];
        if (MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT) &&
            inst->log_data.handle != ((srv_clog_evt_log_op_struct*) evt)->handle)
        {
        #ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_frm_group_close(inst->self_gid);
            }
            else
        #endif
            {
                mmi_clog_lt_inst_srv_evt_hdlr(inst, evt);
            }
        }
    }
    else
    {
        for (i = 0; i < MMI_CLOG_LT_INST_MAX_NUM; i++)
        {
            inst = &cntx->inst_list[i];

            if (!MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT))
                continue;

            if (inst->log_data.handle == ((srv_clog_evt_log_op_struct*) evt)->handle)
                continue;
            
        #ifdef __MMI_CLOG_MARK_SEVERAL__
            if (inst->style == MMI_CLOG_LT_STYLE_MARK_SEVERAL)
            {
                mmi_frm_group_close(inst->self_gid);
            }
            else
        #endif
            {
                mmi_clog_lt_inst_srv_evt_hdlr(inst, evt);
            }
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_inst_srv_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 *  evt         [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_inst_srv_evt_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_SRV_CLOG_ADD_LOG:
            mmi_clog_lt_inst_srv_evt_add_log_hdlr(inst, evt);
            break;

        case EVT_ID_SRV_CLOG_DEL_LOG:
        case EVT_ID_SRV_CLOG_DEL_ALL:
        case EVT_ID_SRV_CLOG_UPDATE_LOG:
        case EVT_ID_SRV_CLOG_UPDATE_ALL:
            mmi_clog_lt_refresh_int(inst);
            break;

        default:
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_inst_srv_evt_add_log_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 *  evt         [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_inst_srv_evt_add_log_hdlr(mmi_clog_lt_inst_struct *inst, mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_clog_evt_add_log_struct *srv_evt = (srv_clog_evt_add_log_struct*) evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_evt->add_ret == SRV_CLOG_ADD_LOG_RET_PURE_MERGE)
    {
        MMI_CLOG_ASSERT(!SRV_CLOG_IS_ELM_INVALID(srv_evt->old_idf.log_id));
        if (inst->sel_log_id == srv_evt->old_idf.log_id)
        {
            /* Set new log id here, and will update the sel_idx in mmi_clog_lt_refresh_int after reload the data */
            inst->sel_log_id = srv_evt->new_idf.log_id;

            MMI_CLOG_IT_TRACE((
                MMI_CLOG_TRC_INFO,
                TRC_MMI_CLOG_LT_INST_SRV_EVT_ADD_LOG_HDLR,
                srv_evt->add_ret,
                inst->sel_lt_id,
                inst->sel_log_idx,
                inst->sel_log_id,
                srv_evt->new_idf.log_id));

        }
    }
    mmi_clog_lt_refresh_int(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_int
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_int(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_refresh_data(inst);
    mmi_clog_lt_refresh_screen(inst);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_is_scrn_in_active
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_lt_is_scrn_in_active(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_LAYOUT) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_DIALED_CALL) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_MISSED_CALL) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_RECVED_CALL) ||
        mmi_clog_is_scrn_in_active(inst->self_gid, SCR_ID_CLOG_ALL_CALL))
        return MMI_TRUE;
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_refresh_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_lt_refresh_screen(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_clog_lt_is_scrn_in_active(inst))
        return;
    mmi_frm_display_dummy_screen();
    mmi_frm_scrn_close_active_id();
}
#endif /* __MMI_CLOG_EVENT_REFRESH_SUPPORT__ */


#ifdef __MMI_CLOG_MARK_SEVERAL__
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_hlt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sel     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_hlt_hdlr(S32 sel)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

    inst->sel_log_idx = sel;

#if defined(__MMI_CLOG_ICON_BAR_SUPPORT__)
    //mmi_clog_lt_tb_refresh(inst);
#endif /*defined(__MMI_CLOG_ICON_BAR_SUPPORT__)*/

}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_get_state
 * DESCRIPTION
 *  category will call this function to get check box state for each item
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
static S32 mmi_clog_mark_several_get_state(S32 item_index, PU8 *checkbox_image)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));
    
    *checkbox_image = mmi_clog_bitmask_get_state(inst->bit_mask, item_index) ?
                      (PU8)GetImage(CHECKBOX_ON_IMAGE_ID) :
                      (PU8)GetImage(CHECKBOX_OFF_IMAGE_ID);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bitmask_get_state
 * DESCRIPTION
 *  get a bit state of bitmask
 * PARAMETERS
 *  bit_mask      [IN]
 *  index         [IN]
 * RETURNS
 *  0 is false, else is true
 *****************************************************************************/
static U8 mmi_clog_bitmask_get_state(U8* bit_mask, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return bit_mask[index >> 3] & (1 << (index % 8));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_bitmask_set_state
 * DESCRIPTION
 *  change status
 * PARAMETERS
 *  bit_mask      [IN]
 *  index         [IN]
 * RETURNS
 *  0 is false, else is true
 *****************************************************************************/
static void mmi_clog_bitmask_set_state(U8* bit_mask, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bit_mask[index >> 3] ^= (1 << (index % 8));
}


static void mmi_clog_bitmask_mark_all(U8* bit_mask, U16 total_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, marked_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < total_count; i++)
    {
        bit_mask[i >> 3] |= (1 << (i % 8));
    }
}


static void mmi_clog_bitmask_unmark_all(U8* bit_mask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(bit_mask, 0, MMI_CLOG_LT_BIT_MASK_BYTE * sizeof(U8));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_set_state
 * DESCRIPTION
 *  set check box state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static S32 mmi_clog_mark_several_set_state(S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));
    
    mmi_clog_bitmask_set_state(inst->bit_mask, item_index);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_has_marked
 * DESCRIPTION
 *  check if have marked items in mark several list, return total marked count
 * PARAMETERS
 *  void
 * RETURNS
 *  U16,  return total marked count
 *****************************************************************************/
static U16 mmi_clog_mark_several_has_marked(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, marked_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < inst->log_data.total_num; i++)
    {
        if (mmi_clog_bitmask_get_state(inst->bit_mask, i))
            marked_count++;
    }
    
    return marked_count;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_set_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_set_key_hdlr(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (inst->log_data.total_num != 0)
    {
        SetLeftSoftkeyFunction(mmi_clog_mark_several_op_enter, KEY_EVENT_UP);
        ChangeCenterSoftkey(0, IMG_GLOBAL_MARK_CSK);
        SetCenterSoftkeyFunction(mmi_clog_mark_several_change_status, KEY_EVENT_UP);
    }

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

#ifdef __MMI_TOUCH_SCREEN__
    wgui_set_horizontal_tab_bar_select_callback(mmi_frm_set_cur_sel_page);
#endif 

#ifdef __MMI_FTE_SUPPORT__
    //mmi_clog_lt_set_tap_hdlr(inst);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_change_status
 * DESCRIPTION
 *  change check box status, when press CSK "mark icon" in mark several list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_change_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));
    
    mmi_clog_bitmask_set_state(inst->bit_mask, inst->sel_log_idx);

    RedrawCategoryFunction();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_op_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_op_enter(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_clog_lt_inst_struct *inst;
    MMI_ID gid, cui_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    inst = (mmi_clog_lt_inst_struct*) mmi_clog_get_inst_by_act_gid();

    MMI_CLOG_ASSERT(MMI_CLOG_IS_INST_VALID(inst, MMI_CLOG_INST_TYPE_LT));

#ifdef __MMI_CLOG_SLIM_FOR_MT6261__
    gid = GRP_ID_CLOG_OPTION;
#else /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    gid = mmi_clog_alloc_gid(MMI_CLOG_GRP_TYPE_OP);
#endif /* __MMI_CLOG_SLIM_FOR_MT6261__ */
    gid = mmi_frm_group_create_ex(inst->self_gid, gid, mmi_clog_mark_several_op_group_proc, inst, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    cui_id = cui_menu_create(
                    gid,
                    CUI_MENU_SRC_TYPE_RESOURCE,
                    CUI_MENU_TYPE_OPTION,
                    MENU_ID_CLOG_MARKOPTION,
                    MMI_TRUE,
                    inst);

    cui_menu_set_default_title_image_by_id(cui_id, GetRootTitleIcon(MAIN_MENU_CALL_LOG));
    cui_menu_run(cui_id);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_op_group_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static MMI_RET mmi_clog_mark_several_op_group_proc(mmi_event_struct *cui_evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct* evt = (cui_menu_event_struct*) cui_evt;
    mmi_clog_lt_inst_struct* inst = (mmi_clog_lt_inst_struct*)(evt->user_data);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_MENU_LIST_ENTRY:
            mmi_clog_mark_several_op_hide_menu(evt->sender_id, inst);
            break;
            
        case EVT_ID_CUI_MENU_ITEM_SELECT:
            if (MENU_ID_CLOG_MARK == evt->highlighted_menu_id ||
                MENU_ID_CLOG_UNMARK == evt->highlighted_menu_id)
                mmi_clog_bitmask_set_state(inst->bit_mask, inst->sel_log_idx);
            else if (MENU_ID_CLOG_UNMARK_ALL == evt->highlighted_menu_id)
                mmi_clog_bitmask_unmark_all(inst->bit_mask);
            else if (MENU_ID_CLOG_MARK_ALL == evt->highlighted_menu_id)
                mmi_clog_bitmask_mark_all(inst->bit_mask, inst->log_data.total_num);
            else if (MENU_ID_CLOG_MARK_DELETE == evt->highlighted_menu_id)
            {
                mmi_clog_mark_several_delete_confirm(inst);
                return MMI_RET_OK; // means Don't call mmi_frm_scrn_close_active_id
            }               

            mmi_frm_scrn_close_active_id();
            break;

        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            cui_menu_close(evt->sender_id);
            break;

        default:
            break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_op_hide_menu
 * DESCRIPTION
 *  hide option menu, when highlight diff item or if have mark items
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_op_hide_menu(mmi_id cui_id, mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 marked_count;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK_ALL, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_DELETE, MMI_FALSE);
    cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_ALL, MMI_FALSE);
    
    if (mmi_clog_bitmask_get_state(inst->bit_mask, inst->sel_log_idx))
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK, MMI_TRUE);
    }
    else
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK, MMI_TRUE);
    } 

    marked_count = mmi_clog_mark_several_has_marked(inst);
    if (0 == marked_count)
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_UNMARK_ALL, MMI_TRUE);
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_DELETE, MMI_TRUE);
    }
    else if (inst->log_data.total_num == marked_count)
    {
        cui_menu_set_item_hidden(cui_id, MENU_ID_CLOG_MARK_ALL, MMI_TRUE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_if_delete_log_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_clog_mark_several_delete_confirm(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_clog_confirm(
        CNFM_TYPE_YESNO,
        STR_ID_CLOG_IF_DELETE_MARKED,
        MMI_EVENT_QUERY,
        inst->self_gid,
        inst,
        MMI_CLOG_ALERT_FLAG_AUTO_DISMISS | MMI_CLOG_ALERT_FLAG_HIDE_CSK);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_delete
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_clog_mark_several_delete(mmi_clog_lt_inst_struct *inst)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < inst->log_data.total_num; i++)
    {
        if (mmi_clog_bitmask_get_state(inst->bit_mask, i))
        {
            inst->log_ids[j] = mmi_clog_get_id_by_idx(inst->sel_lt_id, (U16)i);
            j++;
        }
    }
    mmi_clog_mark_several_delete_common(inst);
    
    mmi_frm_display_dummy_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_delete_common
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inst        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_mark_several_delete_common(mmi_clog_lt_inst_struct *inst)
{
    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j = 0;
    const mmi_clog_lt_id_attr_struct *attr;
    srv_clog_del_multi_logs_req_struct req_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    attr = mmi_clog_get_attr_by_lt_id(inst->sel_lt_id);
    memcpy((srv_clog_log_identity_struct*) & req_data, &attr->idt, sizeof(srv_clog_log_identity_struct));
    for (i = 0; i < inst->log_data.total_num && j < SRV_CLOG_DEL_MULTI_LOG_MAX_NUM; i++)
    {
        if (inst->log_ids[i] != 0)
        {
            req_data.log_ids[j] = inst->log_ids[i];
            j++;
            inst->log_ids[i] = 0; /* set it as invalid */
        }
    }
    if (j < SRV_CLOG_DEL_MULTI_LOG_MAX_NUM)
    {
        req_data.log_ids[j] = SRV_CLOG_INVALID_ELM;
    }

    if (j == 0) /* don't need to delete */
        return j;
    
    srv_clog_delete_multi_logs(
        inst->log_data.handle, 0, 
        (const srv_clog_del_multi_logs_req_struct *)&req_data, 
        mmi_clog_mark_several_delete_result);
    return j; /* log count of need to delete */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_clog_mark_several_delete_result
 * DESCRIPTION
 *  
 * PARAMETERS
 *  handle          [IN]        
 *  pid             [IN]        
 *  req_data        [IN]         
 *  cnf_data        [IN]         
 *  more            [IN]        
 *  ret             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
static S32 mmi_clog_mark_several_delete_result(
            SRV_CLOG_HANDLE handle,
            S32 pid,
            void *req_data,
            void *cnf_data,
            MMI_BOOL more,
            srv_clog_ret_enum ret)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count; /* count of need to delete continue */
    mmi_clog_lt_inst_struct *mark_inst;    
    mmi_clog_lt_inst_struct *layout_inst;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mark_inst = (mmi_clog_lt_inst_struct*) mmi_frm_group_get_user_data(GRP_ID_CLOG_LAYOUT1); // mark list gruop id
    if (mark_inst != NULL)
    {
        count = mmi_clog_mark_several_delete_common(mark_inst);
        if (count != 0)
            return SRV_CLOG_RET_OK;
        else
            mmi_frm_group_close(mark_inst->self_gid); // this will auto close dummy screen
    }
    
    layout_inst = (mmi_clog_lt_inst_struct*) mmi_frm_group_get_user_data(GRP_ID_CLOG_LAYOUT); //list layout gruop id
    if (layout_inst != NULL && ret != SRV_CLOG_RET_OK)
        mmi_clog_popup(STR_GLOBAL_UNFINISHED, MMI_EVENT_FAILURE, layout_inst->self_gid, layout_inst);

    return SRV_CLOG_RET_OK;
}

#endif /* __MMI_CLOG_MARK_SEVERAL__ */


#ifdef __MMI_BT_PBAP_CLIENT__
#if 0
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

 #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
#else /*__MMI_WEARABLE_DEVICE__*/
#ifndef __MMI_PHB_PBAPC_SYNC_CONTACT__
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
/* under construction !*/
#else
/* under construction !*/
#endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
#ifdef __MMI_TELEPHONY_SUPPORT__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
#endif /*__MMI_WEARABLE_DEVICE__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__            
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
#else 
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
#else 
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
#else /*__MMI_WEARABLE_DEVICE__*/
#ifndef __MMI_PHB_PBAPC_SYNC_CONTACT__
#ifdef __MMI_TAB_BAR_SUPPORT_TAB_PAGE__
/* under construction !*/
#else
/* under construction !*/
#endif/*__MMI_TAB_BAR_SUPPORT_TAB_PAGE__*/
#ifdef __MMI_TELEPHONY_SUPPORT__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /*__MMI_PHB_PBAPC_SYNC_CONTACT__*/
#endif /*__MMI_WEARABLE_DEVICE__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MTK_TARGET__
/* under construction !*/
/* under construction !*/
#ifndef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
        #ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
        #else 
/* under construction !*/
        #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
    #ifdef __MTK_TARGET__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #if !defined(__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__) || defined (__MMI_WEARABLE_DEVICE__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifndef __MMI_WEARABLE_DEVICE__
/* under construction !*/
            #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifndef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
/* under construction !*/
        #ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
        #endif
        #else /*__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /*__MMI_NO_SHOW_CLOG_WHEN_DISCONNECT__*/
/* under construction !*/
/* under construction !*/
    #endif
/* under construction !*/
        #ifdef __MMI_BT_NOTI_SRV__
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #else
            #if SRV_PBAPC_LINK_NUM > 2
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
        #endif
/* under construction !*/
        #endif /*__MMI_BT_NOTI_SRV__*/
/* under construction !*/
        #ifdef __MMI_WEARABLE_DEVICE__            
/* under construction !*/
        #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                #ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
                #else
/* under construction !*/
                #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /*__MMI_BT_PBAP_CLIENT__*/
#endif

#if 0
#ifdef __MMI_BT_PBAP_CLIENT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_WEARABLE_DEVICE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif
#endif

#ifdef __MMI_BT_PBAP_CLIENT__
static void mmi_clog_bt_dialer_pre_show(mmi_clog_lt_inst_struct *inst)
{
    MMI_BOOL is_redraw;
    U8 *gui_buffer;
    MMI_MENU_ID sel_menu_id = 0;
    mmi_clog_pbapc_ex_inst_struct* clog_cntx = mmi_clog_get_pbapc_cntx_ex();

    is_redraw = mmi_frm_scenario_is_redrawing();
    if (is_redraw)
    {
        gui_buffer = (U8*)mmi_frm_scrn_get_active_gui_buf();
        sel_menu_id = mmi_clog_bt_get_menu_id(inst->sel_lt_id);
        clog_cntx->path = mmi_clog_pbapc_menu_to_storage_path(sel_menu_id);
        mmi_clog_pbapc_show_category(1, gui_buffer);
    }
    else
    {      
        mmi_clog_bt_dialer_show(inst);
    }
    MMI_TRACE(MMI_CLOG_TRC_INFO, TRC_MMI_CLOG_BT_PRE_SHOW,is_redraw, sel_menu_id);
}
#endif
#endif /* __MMI_TELEPHONY_SUPPORT__ || __MMI_BT_PBAP_CLIENT__ */

