/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*  
*  A. Patent Notice:
*  The software delivered hereunder, including any and all updates and upgrades, 
*  might be subject to patent rights of standard-setting organizations, patent pools 
*  or their respective patent owners, that will be necessarily infringed by the use 
*  and distribution of the products incorporating all or part of this software.  
*  According to the licensing terms of these patent holders, it is your sole 
*  obligation to obtain the necessary patent licenses from these patent holders 
*  before you can use or distribute the products incorporating all or part of this 
*  software. MediaTek shall not be liable for your failure to obtain or maintain such 
*  licenses.
*  
*    As a courtesy to our customers, the following are some of the software that might 
*    contain such patent licenses, but MediaTek does not warrant the accuracy or
*    completeness of the information below.  
*    (1) MPEG4/AAC/AACPLUS/AACVPLUSV2: essential patents license must be obtained
*        from Via Licensing: <www.vialicensing.com>
*    (2) WAP/MMS security RC5 algorithm belongs to RSA Data Security: 
*        <www.rsasecurity.com> 
*    Notice: Please contact RSA to get this license before shipping the products to 
*    USA which include RC5 security algorithm.
*  
*  B. In addition, customers must contact the respective licensors to obtain 
*  necessary software licenses before it can use or distribute the licensed 
*  products. 
*  
*    As a courtesy to our customers, the following are some of the software licensers 
*    and the notice or disclaimer required by their licenses, but MediaTek does not 
*    warrant the accuracy or completeness of the information below.  
*    (1) Microsoft Windows Media (WMA software): 
*        Microsoft: <www.microsoft.com> 
*        Approved OEM Manufacturers: <wmlicense.smdisp.net/oem_approved/>
*        Sample Windows Media Licensing Agreements: 
*        <www.microsoft.com/windows/windowsmedia/licensing/agreements.aspx>
*    Notice in header or documentation: "This product is protected by certain 
*    intellectual property rights of Microsoft and cannot be used or further 
*    distributed without a license from Microsoft."
*    
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   usbimage_drv.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *  This file intends for usb IMAGE class driver definitions
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef USBIMAGE_DRV_H
#define USBIMAGE_DRV_H

#include "usb_adap.h"
#include "usb.h"
#include "usb_custom.h"
#include "usb_msdisk.h"
#include "app_ltlcom.h"
#include "kal_general_types.h"
#include "usb_custom_def.h"



/***********************************************
	image class specific command definition
************************************************/
#define USB_IMAGE_DEVICE_CODE						0x00
#define USB_IMAGE_SUBCLASS_CODE					0x00
#define USB_IMAGE_PROTOCOL_CODE					0x00
#define USB_IMAGE_INTERFACE_CLASS_CODE 			0x06
#define USB_IMAGE_INTERFACE_SUBCLASS_CODE 		0x01
#define USB_IMAGE_INTERFACE_PROTOCOL_CODE 		0x01

/* Class-Specific Requset Code, EP0 command*/
#define USB_IMAGE_CANCEL         						0x64
#define USB_IMAGE_GET_EXTENDED_EVENT_DATA		0x65
#define USB_IMAGE_RESET         						0x66
#define USB_IMAGE_GET_DEVICE_STATUS  				0x67

/* Class-Specific Container Type */
#define USB_IMAGE_UNDEFINED						0x00
#define USB_IMAGE_COMMAND_BLOCK					0x01
#define USB_IMAGE_DATA_BLOCK						0x02
#define USB_IMAGE_RESPONSE_BLOCK					0x03
#define USB_IMAGE_EVENT_BLOCK						0x04

/***********************************************
	Implement definition
************************************************/
#define USB_IMAGE_EP_NUMBER						3 


/* For PTP */
//#define USB_IMAGE_PTP_MAX_BUFFERSIZE     				(2*1024)
#define USB_IMAGE_PTP_MAX_BUFFERSIZE     				(28*1024)
#define USB_IMAGE_PTP_MAX_TX_BUFFERSIZE     			(USB_IMAGE_PTP_MAX_BUFFERSIZE/2)
//#define USB_IMAGE_PTP_MAX_RX_BUFFERSIZE     			(USB_IMAGE_PTP_MAX_BUFFERSIZE/2)

#define USB_IMAGE_PTP_MAX_XMLBUFFERSIZE     			(1024)
#define USB_IMAGE_PTP_MAX_XMLHREQUESTSIZE     		(1040)
#define USB_IMAGE_PTP_MAX_XMLHRSPONSESIZE     		(1008)

#define USB_IMAGE_PTP_MAX_OBJECT_INFO   	  			(1024)
/* For start job XML buffer */
#define USB_IMAGE_PTP_MAX_START_JOB_XMLBUFFERSIZE    (USB_IMAGE_PTP_MAX_BUFFERSIZE + USB_IMAGE_PTP_MAX_XMLBUFFERSIZE - USB_IMAGE_PTP_MAX_OBJECT_INFO)


/* For MTP */
#define USB_IMAGE_MTP_MAX_TX_BUFFERSIZE     			(USB_IMAGE_MTP_MAX_BUFFERSIZE/2)
#define USB_IMAGE_MTP_MAX_RX_BUFFERSIZE     			(USB_IMAGE_MTP_MAX_BUFFERSIZE/2)




#define USB_IMAGE_CONTAINER_LENGTH				12
#define USB_IMAGE_RES_1_PARA						16
#define USB_IMAGE_RES_3_PARA						24
#define USB_IMAGE_RES_5_PARA						32

/* Interrupt packet buffer */
#define USB_IMAGE_MAX_INTERRUPT_PKT				5


/***********************************************
	Implement enum and structure 
************************************************/
typedef struct
{
	kal_uint32	ContainerLength;
	kal_uint16	ContainerType;
	kal_uint16	Code;
	kal_uint32	TransactionID;
	kal_uint32	Parameter1;
	kal_uint32	Parameter2;
	kal_uint32	Parameter3;
#ifdef __MTP_ENABLE__
	kal_uint32	Parameter4;
	kal_uint32	Parameter5;
#endif
}USB_IMAGE_CONTAINER;


typedef struct
{
	kal_uint32	ContainerLength;
	kal_uint16	ContainerType;
	kal_uint16	Code;
	kal_uint32	TransactionID;
}USB_IMAGE_CONTAINER_HEADER;


typedef struct
{
	kal_uint32	ContainerLength;
	kal_uint16	ContainerType;
	kal_uint16	Code;
	kal_uint32	TransactionID;
	kal_uint32	Parameter1;
}USB_IMAGE_EVENT_CONTAINER;


typedef enum
{
	/* msg from USB to MMI */
	USB_IMAGE_MSG_MMI_DISCOVERY_IND,
	USB_IMAGE_MSG_MMI_HREQUEST_IND,
	USB_IMAGE_MSG_MMI_HRESPONSE_IND,
	USB_IMAGE_MSG_MMI_DREQUEST_CONF,
	USB_IMAGE_MSG_MMI_DRESPONSE_CONF,
//	USB_IMAGE_MSG_MMI_CONNECT_TO_PC_IND,
	USB_IMAGE_MSG_MMI_OPEN_FILE_FAIL_IND,
	USB_IMAGE_MSG_MMI_HOST_RESET_IND
}USB_IMAGE_MSG_TYPE;


typedef enum
{
	/* msg from USB to MTP */
	USB_MTP_IMAGE_MSG_ENABLE_REQ,
	USB_MTP_IMAGE_MSG_DISABLE_REQ,
	USB_MTP_IMAGE_MSG_OPERATION_REQ,
	USB_MTP_IMAGE_MSG_HOST_ABORT_IND,
//	USB_MTP_IMAGE_MSG_DEVICE_ABORT_IND,
//	USB_MTP_IMAGE_MSG_HOST_CANCEL_IND,
	USB_MTP_IMAGE_MSG_HOST_SUSPEND_IND
//	USB_MTP_IMAGE_MSG_HOST_RESET_IND
}USB_MTP_IMAGE_MSG_TYPE;


typedef struct {
	LOCAL_PARA_HDR
	kal_uint8             *xml_address; 				/* address of xml packet*/
	kal_uint32		xml_packet_size; 			/*xml packet size*/   
}usb_image_xml_struct;


typedef struct {
	LOCAL_PARA_HDR
	kal_uint8             	*dps_xml_request_address; 	/* address of xml packet*/
	kal_uint32		dps_xml_request_buffer_size;
	kal_uint32		dps_xml_start_job_buffer_size;
	kal_uint8			*dps_xml_response_address;
	kal_uint32		dps_xml_response_buffer_size;
}usb_mmi_dps_discovery_ind_struct;


typedef struct {
	LOCAL_PARA_HDR
	kal_uint32             	rx_data_size;
}usb_ptpimage_data_rx_done_conf_struct, usb_mtpimage_data_rx_done_conf_struct;


typedef struct
{
	kal_uint8		data_buffer[2][USB_IMAGE_PTP_MAX_BUFFERSIZE/2];
}USB_IMAGE_PTP_BUFFER;


typedef struct
{
	kal_uint8		data_buffer[2][USB_IMAGE_MTP_MAX_BUFFERSIZE/2];
}USB_IMAGE_MTP_BUFFER;


typedef struct
{
	kal_uint16	Cancellation_Code;
	kal_uint16	TransactionID[2];
}USB_IMAGE_BLOCK_STRUCT;

typedef struct
{
	kal_uint16	wLength;
	kal_uint16	Code;
	kal_uint32	TxEndPoint;
	kal_uint32	RxEndPoint;
}USB_IMAGE_DEVICE_STATUS_STRUCT;


typedef enum 
{
	USB_IMAGE_CMD_RX = 0,  			/* Initial Idle Phase, Receive Command */
	USB_IMAGE_DATA_TX,  				/* Transmit Data Phase */
	USB_IMAGE_DATA_RX,				/* Receive Data Phase */
	USB_IMAGE_RESPONSE 	 			/* Transmit Response phase */
}USB_IMAGE_STATE;


typedef enum 
{
	IMAGE_INTR_IDLE = 0,
	IMAGE_INTR_SEND_ONE_PKT,
	IMAGE_INTR_SEND_TWO_PKT,
	IMAGE_INTR_SEND_LAST_PKT
}USB_IMAGE_INTR_PIPE_STATE;


typedef enum 
{
	IMAGE_MTP_DISABLE = 0,
//	IMAGE_MTP_DEVICE_ABORT,
	IMAGE_MTP_HOST_CANCEL,	/* When USB receive ep0 cancel command, USB will enter this state,
									and exit this state to enable when USB receive MTP send the event msg */
	IMAGE_MTP_HOST_SUSPEND,  /* Only USB is waiting for MTP's request response and target receive suspend signal, USB will enter this state,
									and exit this state to enable when USB receive MTP send the event msg, too. */
	IMAGE_MTP_ENABLE		/* state is enable after MTP response the enable request */
}USB_IMAGE_MTP_STATE;


typedef struct
{
	USB_IMAGE_STATE				state; 					/* USB image class state machine */
	USB_IMAGE_INTR_PIPE_STATE	intr_state;				/* interrupt pipe state machine */
	Usb_EpBIn_Status				*txpipe;
	Usb_EpBOut_Status			*rxpipe;
	Usb_EpBIn_Status				*intrpipe;

	Usb_Ep_Info					*image_ep_in_info;
	Usb_Ep_Info					*image_ep_out_info;
	Usb_Ep_Info					*image_ep_intr_info;
	Usb_Interface_Info				*image_if_info;

	/* the PTP container  */
	USB_IMAGE_CONTAINER			image_cmd;
//	USB_IMAGE_CONTAINER			image_response;
	USB_IMAGE_EVENT_CONTAINER		image_event;

#ifdef PICTBRIDGE_SUPPORT
	/* buffer for data/image transmission operation*/
	USB_IMAGE_PTP_BUFFER			*image_buffer;

	/* buffer for data/image's info transmission operation */
	kal_uint8						*image_info_buffer;
#endif

#ifdef __MTP_ENABLE__
	/* buffer for data/image transmission operation*/
	USB_IMAGE_MTP_BUFFER			*mtp_image_buffer;

	/* message content for data phase */
	kal_uint32 data_total_size;             /* size of total data, 0 means no Data phase */
	kal_uint8  *data_pool_ptr;              /* data pool */
	kal_uint32 data_pool_size;              /* size of data pool */
	kal_uint32 data_size;                   /* size of real data */

	kal_bool  b_is_first_rsp;		/* a flag to check if it is the first rsp msg from MTP task */

	kal_bool  b_is_mtp_abnormal_msg;		/* a flag to check if there is a abnormal (result is not OK) msg from MTP task */
#endif

	/*  Image class ep0 cmd structure */
	USB_IMAGE_BLOCK_STRUCT		cancel_block;
	USB_IMAGE_DEVICE_STATUS_STRUCT	device_status;

	USB_IMAGE_EVENT_CONTAINER	image_event_array[USB_IMAGE_MAX_INTERRUPT_PKT];

	kal_uint32					current_transactionID;
	kal_uint32					total_rx_bytes;			/* total RX data phase length with 12 bytes header (PTP only) */
	kal_uint32					current_rx_bytes;		/* current RX data phase length with 12 bytes header (PTP only) */
	kal_uint32					total_tx_bytes;			/* total TX data phase length with 12 bytes header (PTP only) */
	kal_uint32					current_tx_bytes;		/* current TX data phase length with 12 bytes header (PTP only) */
#ifdef PICTBRIDGE_SUPPORT
	kal_uint8						rw_buffer_index;		/*  buffer index for double buffer */
#endif
#ifdef __MTP_ENABLE__
	USB_IMAGE_MTP_STATE		mtp_state;
	kal_uint32					buffer_rw_bytes[2];			/*  buffer data load for double buffer, no header */
	kal_uint8						buffer_read_index;			/*  buffer read index for double buffer */
	kal_uint8						buffer_write_index;			/*  buffer write index for double buffer */
	kal_bool						b_wait_enable_rsp;
	kal_bool						b_wait_disable_rsp;
	kal_bool						b_wait_req_rsp;
	kal_bool						b_is_pending_disable_mtp_msg; /* pending disable mtp due to MTP does not response enable request */
	kal_bool						b_delay_disable_mtp_msg_for_req;	/* delay to disable mtp due to MTP is processing a request and USB go into suspend state */
	kal_bool						b_mtp_release_type;		/* MTP is disabled due to cable out */
	kal_bool						b_mtp_stop_type;			/* MTP is disabled due to user wants to stop */
	kal_bool						b_delay_mtp_stop_config;	/* a flag to delay disable MTP in USB boot mode when USB receives STOP_MTP msg */
	kal_bool						b_host_suspend;		/* When suspend, USB will send a close session operation to MTP task automatically.
														This flag is to prevent that USB task handles this close session response msg from MTP due to suspend */
	kal_bool						b_device_cancel;	/* When RX cmd, user may hot plug out the memory card, so USB can not continue to receive data.
														USB will send stall to host, and set this flag to response MTP_TRANSACTION_CANCELLED
														when PC send USB_IMAGE_GET_DEVICE_STATUS ep0 cmd */
#endif
	kal_uint8						intr_read_ptr;
	kal_uint8						intr_write_ptr;

//	kal_bool						host_cancel_flag;		/*  a flag for ep0 get device status cmd to return response code  */
	kal_bool						send_usb_image_reset_ilm; 		 /*  a flag to check whether it needs to send the reset message */
	kal_bool						usb_reset;
	kal_bool						image_ep0_reset;

	kal_bool						usb_image_stop;		/* Upper layer is slower than USB task, if user plug cable in/out quickly,
																USB task's state machine will not sync with upper layer.
																Use this flag to let USB task wait for upper layer */
	kal_bool						is_suspend_state;
	kal_bool						is_session_open;

#ifdef PICTBRIDGE_SUPPORT
	/* Customizable variables */
	const USB_IMAGE_PARAM		*image_param;
#endif
#ifdef __MTP_ENABLE__
	/* Customizable variables */
	const USB_MTP_IMAGE_PARAM		*mtp_image_param;
#endif
}USBImage_Struct;


/***********************************************
	function and global variable
************************************************/
extern USBImage_Struct g_USBImage;
extern USB_IMAGE_CONTAINER g_USB_Image_Response;

extern void USB_Image_Copy_Unicode_String(kal_uint8 *pdest, const kal_uint16 *source_string, kal_uint8 string_num);
extern void USB_Image_If_Create(void *ifname);
extern void USB_Image_If_Reset(void);
extern void USB_Image_If_Enable(void);
extern void USB_Image_If_Speed_Reset(kal_bool b_other_speed);
extern void USB_Init_Image_Status(void);
#ifdef PICTBRIDGE_SUPPORT
extern void USB_Init_PTP_Status(void);
#endif
#ifdef __MTP_ENABLE__
extern void USB_Init_MTP_Status(void);
#endif
extern void USB_Release_Image_Status(void);
#ifdef __MTP_ENABLE__
extern void USB_Release_MTP_Status(void);
#endif

extern void USB_Image_Suspend_Hdlr(void);
extern void USB_Image_Reset_Hdlr(void);
#ifdef PICTBRIDGE_SUPPORT
extern void USB_Image_Reset_PTP_Hdlr(void);
#endif
extern void USB_Image_BuildRx(void *addr, kal_uint32 len);
extern void USB_Image_BuildTx(void *addr, kal_uint32 len);
extern void USB_Image_ReturnTx(void *addr, kal_uint32 len);
extern void USB_Send_Null_Packet(kal_uint8 no);
#ifdef __MTP_ENABLE__
extern void USB_Send_Header_Packet(kal_uint8 ep_num, void *pSrc);
extern kal_uint16* USB_MTP_Image_Get_Storage_Description_String_1_Ptr(void);
extern kal_uint16* USB_MTP_Image_Get_Storage_Description_String_2_Ptr(void);
#endif
extern void USB_Image_Send_Intr(void);
extern void USB_Image_Cancel_By_Device(void);
extern void USB_Image_Send_Msg(USB_IMAGE_MSG_TYPE usb_msg_type);
extern void USB_MTP_Image_Send_Msg(USB_MTP_IMAGE_MSG_TYPE usb_msg_type);


#endif /* USBIMAGE_DRV_H */


