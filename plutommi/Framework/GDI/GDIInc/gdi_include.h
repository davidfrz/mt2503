/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gdi_include.h
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  Include file for full set GDI function.
 *
 * Author:
 * -------
 * -------
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/
#ifndef _GDI_INCLUDE_H_
#define _GDI_INCLUDE_H_

#ifdef __cplusplus
extern "C"
{
#endif 

/* DOM-NOT_FOR_SDK-BEGIN */
#include "kal_general_types.h"
#include "lcd_sw_rnd.h"
#if !defined(__RESOURCE_GEN_)
#include "lcd_if.h"
#endif
#include "drv_sw_features_display.h"
#include "MMIDataType.h"
#include "MMI_features.h"

#define act_bit_per_pixel           bits_per_pixel
#define act_buf_ptr              buf_ptr
#define act_pitch                width
#define act_rows                 height

#if defined(__OP01_FWPBW__) && defined(__MMI_DISPLAY_TYPE_COLOR__)
#ifndef GDI_USE_RGB565_TO_SHOW_BW
#define GDI_USE_RGB565_TO_SHOW_BW
#endif /* GDI_USE_RGB565_TO_SHOW_BW */
#endif

/* flag operation macros */
#define GDI_IMAGE_INFO_FLAG_HAS(i, f)       ((i) & (f))
#define GDI_IMAGE_INFO_FLAG_SET(i, f)       do { i |= (f); } while (0)
#define GDI_IMAGE_INFO_FLAG_CLEAR(i, f)     do { i &= ~(f); } while (0)

/* default flag value */
#define GDI_IMAGE_INFO_FLAG_DEFAULT         0

/* info flags */
#define GDI_IMAGE_INFO_FLAG_IS_FULLY_OPAQUE (1 << 0)
#define GDI_IMAGE_INFO_FLAG_HAS_ALPHA       (1 << 1)

typedef enum
{
    GDI_MSG_ID_RELEASE_G2D_LT_HANDLER,
    
    GDI_MSG_ID_END_OF_ENUM
} gdi_msg_id_enum;


/* those function will be out-of-date. */
#define gdi_layer_clear_background gdi_layer_clear
/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_draw_with_background_color
 * DESCRIPTION
 *  Displays a given frame of the GIF file, and full layer will be filled with background color
 * PARAMETERS
 *  GIF_src                 : [IN]        source image         
 *  size                    : [IN]        source image size
 *  frame_number            : [IN]        Frame number to load for animated GIF.
 *  background_color        : [IN]        background color
 *  is_transparent          : [OUT]       is transparent
 * RETURNS
 *  0  if GIF_load failed (invalid GIF image)
 *  1  if GIF_load is successful
 *****************************************************************************/
#define gdi_image_gif_draw_java     gdi_image_gif_draw_with_background_color

#define gdi_layer_get_text_clip     gdi_layer_get_clip
#define gdi_layer_set_text_clip     gdi_layer_set_clip
#define gdi_layer_reset_text_clip      gdi_layer_reset_clip
#define gdi_layer_push_text_clip    gdi_layer_push_clip
#define gdi_layer_pop_text_clip     gdi_layer_pop_clip

#include "gdi_features.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gdi_lcd_config.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERAL API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*****************************************************************************
 * FUNCTION
 *  gdi_init
 * DESCRIPTION
 *  init gdi
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_init(void);


///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// PIXEL INFORMATION
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define GDI_MAINLCD_BIT_PER_PIXEL                  DRV_MAINLCD_BIT_PER_PIXEL
#ifdef __MMI_SUBLCD__
#define GDI_SUBLCD_BIT_PER_PIXEL                   DRV_SUBLCD_BIT_PER_PIXEL
#else 
#define GDI_SUBLCD_BIT_PER_PIXEL                   0
#endif 


#include "drv_sw_features_color.h"

#if defined(__COLOR_HW_SUPPORTED__)
    #define GDI_COLORENGINE_SUPPORT
#endif

//warning
extern GDI_RESULT gdi_layer_set_blt_layer_nb_concurrent_ext(
            gdi_handle handle0, 
            gdi_handle handle1, 
            gdi_handle handle2, 
            gdi_handle handle3
        #ifdef GDI_6_LAYERS
            ,gdi_handle handle4
            ,gdi_handle handle5
        #endif
            );


#if defined GDI_COLORENGINE_SUPPORT
/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Enable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_color_engine_open();
/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Enable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_color_engine_enable();
/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Disable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_color_engine_disable();
/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Enable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_color_engine_close();


#endif

#ifdef __LCD_COLOR_ENGINE_SUPPORT__
extern void gdi_color_engine_custom_on(void);     
extern void gdi_color_engine_custom_off(void);        
extern void gdi_color_engine_get_power_status(kal_bool* enable);
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ALPHA SOURCE LAYER API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*****************************************************************************
 * FUNCTION
 *  gdi_set_alpha_blending_source_layer
 * DESCRIPTION
 *  set alpha source blending source layer
 * PARAMETERS
 *  src_layer_handle       : [IN] gdi handle of the alpha source layer
 * RETURNS
 *  gdi_handle  old alpha source layer handle
 *****************************************************************************/
extern gdi_handle gdi_set_alpha_blending_source_layer(gdi_handle src_layer_handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_get_alpha_blending_source_layer
 * DESCRIPTION
 *  get alpha blending source layer
 * PARAMETERS
 *  src_layer_handle       : [OUT] gdi handle of the alpha source layer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_get_alpha_blending_source_layer(gdi_handle *src_layer_handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_push_and_set_alpha_blending_source_layer
 * DESCRIPTION
 *  push current alpha source layer into stack and set passin layer as alpha source layer
 * PARAMETERS
 *  handle      : [IN]        new alpha blending source layer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_push_and_set_alpha_blending_source_layer(gdi_handle handle);

/*****************************************************************************
 * FUNCTION
 *  gdi_pop_and_restore_alpha_blending_source_layer
 * DESCRIPTION
 *  pop the layer in stack and make it as alpha source layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_pop_and_restore_alpha_blending_source_layer(void);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// PRIMITIVE API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*****************************************************************************
 * FUNCTION
 *  gdi_rgb565_to_rgb888
 * DESCRIPTION
 *  convert RGB565 to RGB888
 * PARAMETERS
 *  p       : [IN]    RGB565 pixel
 * RETURNS
 *  U32, 24-bit RGB888 pixel
 *****************************************************************************/
extern U32 gdi_rgb565_to_rgb888(U32 p);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_point
 * DESCRIPTION
 *  draw a point on active layer
 * PARAMETERS
 *  x                 : [IN]  point x position
 *  y                 : [IN]  point y position
 *  pixel_color       : [IN]  point color
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_point(S32 x, S32 y, gdi_color pixel_color);
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_line
 * DESCRIPTION
 *  draw a line on active layer
 * PARAMETERS
 *  x1               : [IN]   the x of first end point of line
 *  y1               : [IN]   the y of first end point of line
 *  x2               : [IN]   the x of the other end point of line
 *  y2               : [IN]   the y of the other end point of line
 *  line_color       : [IN]   the color of line
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_line(S32 x1, S32 y1, S32 x2, S32 y2, gdi_color line_color);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_line_style
 * DESCRIPTION
 *  draw dotted line with specified "bit value"
 * PARAMETERS
 *  x1               : [IN]   the x of first end point of line
 *  y1               : [IN]   the y of first end point of line
 *  x2               : [IN]   the x of the other end point of line
 *  y2               : [IN]   the y of the other end point of line
 *  line_color       : [IN]   the color of line
 *  cycle            : [IN]   the size of bitvalues
 *  bitvalues        : [IN]   an array represent the dotted style
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_line_style(S32 x1, S32 y1, S32 x2, S32 y2, gdi_color line_color, U8 cycle, const U8 *bitvalues);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_antialiasing_line
 * DESCRIPTION
 *  draw a anti-aliasing thin line
 * PARAMETERS
 *  x1               : [IN]   the x of first end point of line
 *  y1               : [IN]   the y of first end point of line
 *  x2               : [IN]   the x of the other end point of line
 *  y2               : [IN]   the y of the other end point of line
 *  line_color       : [IN]   the color of line
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_antialiasing_line(S32 x1, S32 y1, S32 x2, S32 y2, gdi_color line_color);
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_rect
 * DESCRIPTION
 *  draw a rectangle on active layer
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of rectangle
 *  y1                : [IN]   y of left-top cornor of rectangle
 *  x2                : [IN]   x of right-down cornor of rectangle
 *  y2                : [IN]   y of right-down cornor of rectangle
 *  frame_color       : [IN]   the color of the rectangle frame
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_rect(S32 x1, S32 y1, S32 x2, S32 y2, gdi_color rect_color);
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_solid_rect
 * DESCRIPTION
 *  draw a solid rectangle on active layer
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of rectangle
 *  y1                : [IN]   y of left-top cornor of rectangle
 *  x2                : [IN]   x of right-down cornor of rectangle
 *  y2                : [IN]   y of right-down cornor of rectangle
 *  rect_color        : [IN]   the color of solid rectangle
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_solid_rect(S32 x1, S32 y1, S32 x2, S32 y2, gdi_color rect_color);
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_circle
 * DESCRIPTION
 *  draw a circle on active layer
 * PARAMETERS
 *  x                  : [IN] x position of the center of the circle
 *  y                  : [IN] y position of the center of the circle
 *  r                  : [IN] radius of the circle
 *  circle_color       : [IN] color of the circle
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_circle(S32 x, S32 y, S32 r, gdi_color circle_color);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_solid_circle
 * DESCRIPTION
 *  draw a solid circle on the active layer
 * PARAMETERS
 *  x                  : [IN] x position of the center of the circle
 *  y                  : [IN] y position of the center of the circle
 *  r                  : [IN] radius of the circle
 *  circle_color       : [IN] color of the circle
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_solid_circle(S32 x, S32 y, S32 r, gdi_color circle_color);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_arc
 * DESCRIPTION
 *  draw a arc on active layer, six clock is angle 0, positive anticloclwise
 * PARAMETERS
 *  circle_x          : [IN]  x position of the center of the circle
 *  circle_y          : [IN]  y position of the center of the circle
 *  circle_r          : [IN]  radius of the circle
 *  startAngle        : [IN]  the start angle of the arc
 *  angleExtent       : [IN]  the extended angle of the arc
 *  color             : [IN]  the color of the arc
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_arc(S32 circle_x, S32 circle_y, S32 circle_r, int startAngle, int angleExtent, gdi_color color);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_arc_ext
 * DESCRIPTION
 *  draw a arc on active layer, six clock is angle 0, positive anticloclwise
 * PARAMETERS
 *  circle_x          : [IN]  x position of the center of the circle
 *  circle_y          : [IN]  y position of the center of the circle
 *  circle_r          : [IN]  radius of the circle
 *  width             : [IN]  width from outer bound to inner
 *  startAngle        : [IN]  the start angle of the arc
 *  angleExtent       : [IN]  the extended angle of the arc
 *  color             : [IN]  the color of the arc
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_arc_ext(S32 circle_x, S32 circle_y, S32 circle_r, S32 width, int startAngle, int angleExtent, gdi_color color);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_ring
 * DESCRIPTION
 *  draw a ring on active layer, six clock is angle 0, positive anticloclwise
 * PARAMETERS
 *  circle_x          : [IN]  x position of the center of the circle
 *  circle_y          : [IN]  y position of the center of the circle
 *  circle_r          : [IN]  radius of the circle
 *  width             : [IN]  width from outer bound to inner
 *  startAngle        : [IN]  the start angle of the arc
 *  angleExtent       : [IN]  the extended angle of the arc
 *  sColor            : [IN]  the color of the start circle
 *  mColor            : [IN]  the color of the middle part
 *  eColor            : [IN]  the color of the end circle
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_ring(S32 circle_x, S32 circle_y, S32 circle_r, S32 width, int startAngle, int angleExtent, gdi_color sColor, gdi_color mColor, gdi_color eColor);


/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_solid_arc
 * DESCRIPTION
 *  draw a solid arc on active layer, the x axis is angle 0
 *  But this API is broken, GDI needs to fix it.
 * PARAMETERS
 *  circle_x          : [IN]  x position of the center of the circle
 *  circle_y          : [IN]  y position of the center of the circle
 *  circle_r          : [IN]  radius of the circle
 *  startAngle        : [IN]  the start angle of the arc
 *  angleExtent       : [IN]  the extended angle of the arc
 *  color             : [IN]  the color of the arc
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_solid_arc(S32 circle_x, S32 circle_y, S32 circle_r, int startAngle, int angleExtent, gdi_color color);

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_frame_rect
 * DESCRIPTION
 *  draw a rect with frame and filling
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of rectangle
 *  y1                : [IN]   y of left-top cornor of rectangle
 *  x2                : [IN]   x of right-down cornor of rectangle
 *  y2                : [IN]   y of right-down cornor of rectangle
 *  rect_color        : [IN]   the color of solid rectangle
 *  frame_color       : [IN]   the color of the rectangle frame
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_frame_rect(
                S32 x1,
                S32 y1,
                S32 x2,
                S32 y2,
                gdi_color rect_color,
                gdi_color frame_color,
                S32 frame_width);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_round_rect
 * DESCRIPTION
 *  draw a rectangle with frame on active layer
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of rectangle
 *  y1                : [IN]   y of left-top cornor of rectangle
 *  x2                : [IN]   x of right-down cornor of rectangle
 *  y2                : [IN]   y of right-down cornor of rectangle
 *  rect_color        : [IN]   the color of rectangle
 *  frame_color       : [IN]   the color of rectangle frame
 *  frame_width       : [IN]   the width of rectangle frame
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_round_rect(
                S32 x1,
                S32 y1,
                S32 x2,
                S32 y2,
                gdi_color rect_color,
                gdi_color frame_color,
                S32 frame_width);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_button_rect
 * DESCRIPTION
 *  draw a rect with button style
 * PARAMETERS
 *  x1                  : [IN]   x of left-top cornor of rectangle
 *  y1                  : [IN]   y of left-top cornor of rectangle
 *  x2                  : [IN]   x of right-down cornor of rectangle
 *  y2                  : [IN]   y of right-down cornor of rectangle
 *  rect_color          : [IN]   the color of rectangle
 *  frame_color         : [IN]   the color of rectangle frame
 *  frame_width         : [IN]   the width of rectangle frame
 *  button_height       : [IN]   button height
 *  invert              : [IN]   draw a normal button, or a pushed button
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_button_rect(
                S32 x1,
                S32 y1,
                S32 x2,
                S32 y2,
                gdi_color rect_color,
                gdi_color frame_color,
                U16 frame_width,
                U16 button_height,
                BOOL invert);
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_shadow_rect
 * DESCRIPTION
 *  draw a rect with shadow style
 * PARAMETERS
 *  x1                  : [IN]   x of left-top cornor of rectangle
 *  y1                  : [IN]   y of left-top cornor of rectangle
 *  x2                  : [IN]   x of right-down cornor of rectangle
 *  y2                  : [IN]   y of right-down cornor of rectangle
 *  rect_color          : [IN]   the color of rectangle
 *  frame_color         : [IN]   the color of rectangle frame
 *  frame_width         : [IN]   the width of rectangle frame
 *  shadow_color        : [IN]   shadow color
 *  shadow_height       : [IN]   shadow height
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_shadow_rect(
                S32 x1,
                S32 y1,
                S32 x2,
                S32 y2,
                gdi_color rect_color,
                gdi_color frame_color,
                S32 frame_width,
                gdi_color shadow_color,
                S32 shadow_height);
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_gradient_rect
 * DESCRIPTION
 *  draw a rect with gradient filling
 * PARAMETERS
 *  x1                  : [IN]   x of left-top cornor of rectangle
 *  y1                  : [IN]   y of left-top cornor of rectangle
 *  x2                  : [IN]   x of right-down cornor of rectangle
 *  y2                  : [IN]   y of right-down cornor of rectangle
 *  rect_color_start    : [IN]   the gradient start color
 *  rect_color_end      : [IN]   the gradient end color
 *  frame_color         : [IN]   the color of rectangle frame
 *  frame_width         : [IN]   the width of rectangle frame
 *  style               : [IN]   the gradient style
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_gradient_rect(
                S32 x1,
                S32 y1,
                S32 x2,
                S32 y2,
                gdi_color rect_color_start,
                gdi_color rect_color_end,
                gdi_color frame_color,
                S32 frame_width,
                gdi_gradient_rect_style_enum style);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_darken_rect
 * DESCRIPTION
 *  Darken all pixels in a rectangle. Trasnparent pixels are not supported.
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of rectangle
 *  y1                : [IN]   y of left-top cornor of rectangle
 *  x2                : [IN]   x of right-down cornor of rectangle
 *  y2                : [IN]   y of right-down cornor of rectangle
 *  brightness_value  : [IN]   brightness. Range: 0 (darkest) to 100 (brightest).
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_darken_rect(S32 x1, S32 y1, S32 x2, S32 y2, S32 brightness_value);                

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_draw_greyscale_rect
 * DESCRIPTION
 *  draw a greyscale rectangle
 *
 *  The greyscale value of a pixel is decided by the following described.
 *  1. Get the average of r, g, b color of the pixel, called "ave"
 *  2. tmp = ave + (256-ave) * white_value / 256
 *     tmp will be a value between ave and 255(white color).
 *     256:white_value = (256-ave):(t01-ave)
 *
 *     256-----------|----------|------0
 *                  tmp        ave     
 *
 *  3. grey = tmp * black_value / 256
 *     256:black_value = tmp:grey
 *
 *     tmp-----------|-----------------0
 *                  grey             
 * PARAMETERS
 *  x1                : [IN]
 *  y1                : [IN]
 *  x2                : [IN]
 *  y2                : [IN]
 *  white_value       : [IN]
 *  black_value       : [IN]
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_greyscale_rect(S32 x1, S32 y1, S32 x2, S32 y2, S32 white_value, S32 black_value);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_effect_alpha_blending_rect
 * DESCRIPTION
 *  do alpha blending between the src_layer and transparent_color, then output to active layer
 * PARAMETERS
 *  src_layer_handle          : [IN]   layer handle of alpha blending source layer
 *  x1                        : [IN]   x of left-top cornor of blending region in source layer
 *  y1                        : [IN]   y of left-top cornor of blending region in source layer
 *  x2                        : [IN]   x of right-down cornor of blending region in source layer
 *  y2                        : [IN]   y of right-down cornor of blending region in source layer
 *  transparent_color_r       : [IN]   red of transparent_color
 *  transparent_color_g       : [IN]   green of transparent_color
 *  transparent_color_b       : [IN]   blue of transparent_color
 * RETURNS
 *  void
 *****************************************************************************/
 extern void gdi_effect_alpha_blending_rect(
                gdi_handle src_layer_handle,
                S32 x1,
                S32 y1,
                S32 x2,
                S32 y2,
                U32 transparent_color_a,
                U32 transparent_color_r,
                U32 transparent_color_g,
                U32 transparent_color_b);

/* DOM-NOT_FOR_SDK-BEGIN */
/*****************************************************************************
 * FUNCTION
 *  gdi_draw_solid_polygon
 * DESCRIPTION
 *  draw a solid polygon
 * PARAMETERS
 *  point_array : [IN]    point array
 *  point_num   : [IN]    the number of elements of point array
 *  color       : [IN]    the color of polygon
 * RETURNS
 *   *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_draw_solid_polygon(
                    gdi_point2D_struct point[], 
                    U32 point_num, 
                    gdi_color color);


/*****************************************************************************
 * FUNCTION
 *  gdi_draw_polygon
 * DESCRIPTION
 *  draw a polygon
 * PARAMETERS
 *  point_array : [IN]    point array
 *  point_num   : [IN]    the number of elements of point array
 *  color       : [IN]    the color of polygon
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_draw_polygon(gdi_point2D_struct point[], U32 point_num, gdi_color color);


/*****************************************************************************
 * FUNCTION
 *  gdi_2d_memory_blt
 * DESCRIPTION
 *  Do bitblt from src to dest. Copy a region from src to a region in dest.
 *  If there are transparent color on source buffer, the output color will do ^1
 *  to avoid the transparent color on source buffer is blt out.
 *  If you want to keep the transparent color, use gdi_2d_memory_blt_without_transpant_check().
 * PARAMETERS
 *  src_ptr              : [IN]   source pointer
 *  src_pitch            : [IN]   source buffer width
 *  src_offset_x         : [IN]   start point x offset of source
 *  src_offset_y         : [IN]   start point y offset of source
 *  src_width            : [IN]   source copy region width
 *  src_height           : [IN]   source copy region height
 *  dest_ptr             : [IN]   destination pointer
 *  dest_pitch           : [IN]   destination buffer width
 *  dest_offset_x        : [IN]   start point x offset of destination
 *  dest_offset_y        : [IN]   start point y offset of destination
 *  dest_clip            : [IN]   clipping region of destination
 *  bits_per_pixel       : [IN]   bits per pixel of source and destination
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_2d_memory_blt(
                U8 *src_ptr,
                S32 src_pitch,
                S32 src_offset_x,
                S32 src_offset_y,
                S32 src_width,
                S32 src_height,
                U8 *dest_ptr,
                S32 dest_pitch,
                S32 dest_offset_x,
                S32 dest_offset_y,
                gdi_rect_struct dest_clip,
                S32 bits_per_pixel);
/*****************************************************************************
 * FUNCTION
 *  gdi_2d_memory_blt_without_transpant_check
 * DESCRIPTION
 *  Do bitblt from src to dest. Copy a region from src to a region in dest.
 * PARAMETERS
 *  src_ptr              : [IN]   source pointer
 *  src_pitch            : [IN]   source buffer width
 *  src_offset_x         : [IN]   start point x offset of source
 *  src_offset_y         : [IN]   start point y offset of source
 *  src_width            : [IN]   source copy region width
 *  src_height           : [IN]   source copy region height
 *  dest_ptr             : [IN]   destination pointer
 *  dest_pitch           : [IN]   destination buffer width
 *  dest_offset_x        : [IN]   start point x offset of destination
 *  dest_offset_y        : [IN]   start point y offset of destination
 *  dest_clip            : [IN]   clipping region of destination
 *  bits_per_pixel       : [IN]   bits per pixel of source and destination
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_2d_memory_blt_without_transpant_check(
                U8 *src_ptr,
                S32 src_pitch,
                S32 src_offset_x,
                S32 src_offset_y,
                S32 src_width,
                S32 src_height,
                U8 *dest_ptr,
                S32 dest_pitch,
                S32 dest_offset_x,
                S32 dest_offset_y,
                gdi_rect_struct dest_clip,
                S32 bits_per_pixel);
/*****************************************************************************
 * FUNCTION
 *  gdi_fill_dot_rect
 * DESCRIPTION
 *  draw a dotted rectangle
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of rectangle
 *  y1                : [IN]   y of left-top cornor of rectangle
 *  x2                : [IN]   x of right-down cornor of rectangle
 *  y2                : [IN]   y of right-down cornor of rectangle
 *  c                 [IN]the color of the rectangle
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_fill_dot_rect(S32 x1,S32 y1,S32 x2,S32 y2,gdi_color c);
/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_internal
 * DESCRIPTION
 *  gdi HW bitblt using g2d
 * PARAMETERS
 *  src_ptr                   : [IN]  source buffer pointer
 *  src_pitch                 : [IN]  source buffer width
 *  src_offset_x              : [IN]  start x position of bitblt source region
 *  src_offset_y              : [IN]  start y position of bitblt source region
 *  src_width                 : [IN]  source region width
 *  src_height                : [IN]  source region height
 *  src_cf                    : [IN]  color format of source buffer
 *  dest_ptr                  : [IN]  destination buffer pointer
 *  dest_pitch                : [IN]  destination buffer width
 *  dest_offset_x             : [IN]  start x position of bitblt destination region
 *  dest_offset_y             : [IN]  start y position of bitblt destination region
 *  dest_clip_x1              : [IN]  destination clip region x1
 *  dest_clip_y1              : [IN]  destination clip region y1
 *  dest_clip_x2              : [IN]  destination clip region x2
 *  dest_clip_y2              : [IN]  destination clip region y2
 *  dest_cf                   : [IN]  destination buffer color format
 *  dest_buf_size             : [IN]  destination buffer size
 *  tilt                      : [IN]  tile the destination bitblt region if true
 *  enable_src_key            : [IN]  enable source key
 *  src_key                   : [IN]  source key
 *  is_alpha_blending         : [IN]  enable alpha blending if ture
 *  alpha_value               : [IN]  alpha value
 *  is_rop_mode               : [IN]  enable rop(Raster Operation) mode
 *  rop_value                 : [IN]  which kind of rop want to do
 *  transform_value           : [IN]  transform value
 *  transform_direction       : [IN]  transform direction
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_bitblt_internal(U8* src_ptr, U32 src_pitch, 
			S32 src_offset_x, S32 src_offset_y, 
			U32 src_width, U32 src_height,
			gdi_color_format src_cf,
			U8* dest_ptr, U32 dest_pitch,
			S32 dest_offset_x, S32 dest_offset_y,
			S32 dest_clip_x1, S32 dest_clip_y1, S32 dest_clip_x2, S32 dest_clip_y2,
			gdi_color_format dest_cf, U32 dest_buf_size,
			BOOL tilt,
			BOOL enable_src_key, gdi_color src_key,
			BOOL is_alpha_blending, U8 alpha_value,
			BOOL is_rop_mode, U8 rop_value,
			U8 transform_value,
			U8 transform_direction);

/*****************************************************************************
 * FUNCTION
 *  gdi_bits_draw
 * DESCRIPTION
 *  draw the src data using the color in palette.
 * PARAMETERS
 *  x                    : [IN]   x draw position 
 *  y                    : [IN]   y draw position
 *  src                  : [IN]   source data
 *  src_size             : [IN]   source data size
 *  w                    : [IN]   source data width
 *  h                    : [IN]   source data height
 *  bits_per_pixel       : [IN]   bits per pixel of source data
 *  palette[]            : [IN]   use this palette to draw src data
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_bits_draw(S32 x,S32 y,U8* src,S32 src_size,S32 w,S32 h,S32 bits_per_pixel,gdi_color palette[]);
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// MUTEX API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef GDI_USING_MUTEX
#define GDI_LOCK     gdi_fast_mutex_lock()
#define GDI_LOCK_NO_WAIT    gdi_fast_mutex_lock_no_wait()
#define GDI_UNLOCK      gdi_fast_mutex_unlock()
#define GDI_UNLOCK_N(N) while(N< gdi_mutex.cnt) {gdi_fast_mutex_unlock();}
#else /* GDI_USING_MUTEX */ 
#define GDI_LOCK
#define GDI_UNLOCK
#define GDI_UNLOCK_N(N)
#endif /* GDI_USING_MUTEX */ 

/* DOM-NOT_FOR_SDK-END */
/*****************************************************************************
 * FUNCTION
 *  gdi_fast_mutex_lock
 * DESCRIPTION
 *  lock gdi mutex
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_fast_mutex_lock(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_fast_mutex_unlock
 * DESCRIPTION
 *  unlock gdi mutex
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_fast_mutex_unlock(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_fast_mutex_lock_no_wait
 * DESCRIPTION
 *  the same with gdi_fast_mutex_lock 
 *  but it won't wait the mutex if it can't get the mutex immediately
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_fast_mutex_lock_no_wait(void);
extern S32 gdi_fast_mutex_get_count(void);

/* DOM-NOT_FOR_SDK-BEGIN */
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// COLOR API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define GDI_COLOR_WHITE       gdi_act_color_from_rgb(255, 255, 255, 255)
#define GDI_COLOR_BLACK       gdi_act_color_from_rgb(255, 0, 0, 0)
#define GDI_COLOR_GRAY           gdi_act_color_from_rgb(255, 127, 127, 127)
#define GDI_COLOR_RED            gdi_act_color_from_rgb(255, 255,    0,     0)
#define GDI_COLOR_BLUE           gdi_act_color_from_rgb(255,    0,     0, 255)
#define GDI_COLOR_GREEN       gdi_act_color_from_rgb(255,    0, 255,      0)

#ifdef GDI_USING_LAYER
#define GDI_COLOR_TRANSPARENT    gdi_act_color_from_rgb(0,    0,     0, 255)
#else
#define GDI_COLOR_TRANSPARENT    gdi_act_color_from_rgb(255,    255,     255, 255)
#endif

#if defined(GDI_USE_RGB565_TO_SHOW_BW)
#undef GDI_COLOR_TRANSPARENT
#define GDI_COLOR_TRANSPARENT    gdi_act_color_from_rgb(255,    255,     255, 255)
#endif
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LAYER API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define GDI_LAYER_EMPTY_HANDLE               (0)        /* handle 0 is empty handle, not used */
#define GDI_LAYER_MEDIA_HW_TRIGGER_LAYER     (1)

#define GDI_LAYER_ENABLE_LAYER_0       LCD_LAYER0_ENABLE
#define GDI_LAYER_ENABLE_LAYER_1       LCD_LAYER1_ENABLE
#define GDI_LAYER_ENABLE_LAYER_2       LCD_LAYER2_ENABLE
#define GDI_LAYER_ENABLE_LAYER_3       LCD_LAYER3_ENABLE
#ifdef GDI_6_LAYERS
#define GDI_LAYER_ENABLE_LAYER_4       LCD_LAYER4_ENABLE
#define GDI_LAYER_ENABLE_LAYER_5       LCD_LAYER5_ENABLE
#endif /* GDI_6_LAYERS */ 

#ifdef GDI_USING_LAYER_ROTATE
#define GDI_LAYER_ROTATE_0             LCD_LAYER_ROTATE_NORMAL
#define GDI_LAYER_ROTATE_90            LCD_LAYER_ROTATE_90
#define GDI_LAYER_ROTATE_180           LCD_LAYER_ROTATE_180
#define GDI_LAYER_ROTATE_270           LCD_LAYER_ROTATE_270
#define GDI_LAYER_ROTATE_0_MIRROR      LCD_LAYER_MIRROR
#define GDI_LAYER_ROTATE_90_MIRROR     LCD_LAYER_MIRROR_ROTATE_90
#define GDI_LAYER_ROTATE_180_MIRROR    LCD_LAYER_MIRROR_ROTATE_180
#define GDI_LAYER_ROTATE_270_MIRROR    LCD_LAYER_MIRROR_ROTATE_270
#else /* GDI_USING_LAYER_ROTATE */ 
#define GDI_LAYER_ROTATE_0             0
#define GDI_LAYER_ROTATE_90            1
#define GDI_LAYER_ROTATE_180           2
#define GDI_LAYER_ROTATE_270           3
#define GDI_LAYER_ROTATE_0_MIRROR      4
#define GDI_LAYER_ROTATE_90_MIRROR     5
#define GDI_LAYER_ROTATE_180_MIRROR    6
#define GDI_LAYER_ROTATE_270_MIRROR    7
#endif /* GDI_USING_LAYER_ROTATE */ 

/* post effect */
typedef enum
{
    GDI_IPP_EFFECT_GRAYSCALE = 0,
    GDI_IPP_EFFECT_SEPIA,
    GDI_IPP_EFFECT_SEPIAGREEN,
    GDI_IPP_EFFECT_SEPIABLUE,
    GDI_IPP_EFFECT_COLORINV,
    GDI_IPP_EFFECT_GRAYINV,
    GDI_IPP_EFFECT_WATERCOLOR,
    GDI_IPP_EFFECT_LIGHTBLUR,
    GDI_IPP_EFFECT_BLUR,
    GDI_IPP_EFFECT_STRONGBLUR,
    GDI_IPP_EFFECT_UNSHARP,
    GDI_IPP_EFFECT_SHARPEN,
    GDI_IPP_EFFECT_MORESHARPEN,
    GDI_IPP_EFFECT_MEDIAN,
    GDI_IPP_EFFECT_DILATION,
    GDI_IPP_EFFECT_EROSION,
    GDI_IPP_EFFECT_TOTAL
}gdi_ipp_effect_enum;

#if defined(GDI_USING_ISP)

#define GDI_LAYER_ADJUSMENT_BRIGHTNESS       0
#define GDI_LAYER_ADJUSMENT_CONTRAST         1
#define GDI_LAYER_ADJUSMENT_SATURATION       2
#define GDI_LAYER_ADJUSMENT_HUE              3
#define GDI_LAYER_ADJUSMENT_ADJR             4
#define GDI_LAYER_ADJUSMENT_ADJG             5
#define GDI_LAYER_ADJUSMENT_ADJB             6
#endif /* defined(GDI_USING_ISP) */ 

#define GDI_LAYER_MAIN_BASE_LAYER_HANDLE     ((gdi_handle)(&GDI_LAYERS[0]))
#ifdef __MMI_SUBLCD__
#define GDI_LAYER_SUB_BASE_LAYER_HANDLE         ((gdi_handle)(&GDI_LAYERS[1]))
#endif 

#if defined(GDI_USE_RGB565_TO_SHOW_BW)
extern GDI_HANDLE g_gdi_copy_handle;
#endif

/* 
 * In current design, GDI_MAINLCD_BIT_PER_PIXEL is always 16. 
 * 
 * Assume MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL == 24 bit, then 
 * GDI_MAINLCD_BIT_PER_PIXEL != MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL.
 * We need to convert cache buffer (16-bit) to base layer (24-bit) in some applications
 */
#if defined(GDI_USING_LAYER_COLOR_FORMAT) && (GDI_MAINLCD_BIT_PER_PIXEL != MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL)
    #if MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL==24
        #define  GDI_SET_BUFFER_PIXEL2(X,Y,VALUE)        gdi_act_put_pixel(X,Y,gdi_rgb565_to_rgb888(VALUE));
    #elif MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL==32
        #define  GDI_SET_BUFFER_PIXEL2(X,Y,VALUE)        gdi_act_put_pixel(X,Y,gdi_rgb565_to_rgb888(VALUE)|0xff000000);
    #elif MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL==16
        #define  GDI_SET_BUFFER_PIXEL2                  GDI_SET_BUFFER_PIXEL
    #else
        #error "didn't support this color format!!"
    #endif
#else
#define  GDI_SET_BUFFER_PIXEL2                  GDI_SET_BUFFER_PIXEL
#endif

#define  GDI_SET_BUFFER_PIXEL(X,Y,VALUE)        gdi_act_put_pixel(X,Y,VALUE)
#define  GDI_GET_BUFFER_PIXEL(X,Y,VALUE)     VALUE=gdi_act_get_pixel(X,Y)


typedef struct gdi_layer_struct
{
    /* Field position is arranged to optimize the usage of cache
       for govl_config_layer */
    U8 id;
    U8 flag;
    U8 clips_top;
    U16 width, height;
    
    U8 cf;          /* real color format ( it will support LCD color format) */
    U8 vcf;         /* virtual color format (convert to standard color format) */
    U8 bits_per_pixel;
    U8 rotate_value;
    
    S32 offset_x, offset_y;
    U16 blt_x, blt_y, blt_width, blt_height; /* blt rect, the coordinate is offset from layer frame buffer */
    
    gdi_color background;   /* only valide when this layer is the "lowest" layer. */
    U8 *buf_ptr;
    U8 *buf_ptr1;

    S16 clipx1, clipy1, clipx2, clipy2;
    gdi_rect_struct clips[GDI_LAYER_CLIP_STACK_COUNT];
#if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
    U8* bltdb_buf_ptr1;     /*inactive buf when calling blt*/
    U8* bltdb_buf_ptr2;     /*hw update buf*/
#endif
    U32 hw_update_element;   /* if it's hw layer, remember its blt element after hw udpate stop. For blt or flatten hw layer after hw update stop. */
    S32 layer_size; /* bytes */
    gd_get_pixel_func get_pixel;
    gd_put_pixel_func put_pixel;
    
    void (*lazy_free_callback)(gdi_handle handle);
#ifdef GDI_DEBUG_SUPPORT
    /* The layer creator for debug */
    void *creator_lr;
#endif
} gdi_layer_struct;

extern gdi_layer_struct GDI_LAYERS[GDI_LAYER_TOTAL_LAYER_COUNT];
extern gdi_layer_struct *gdi_act_layer;
extern gd_color_from_rgb_func gdi_act_color_from_rgb;
extern gd_color_to_rgb_func gdi_act_color_to_rgb;
extern gd_put_pixel_func gdi_act_put_pixel;
extern gd_get_pixel_func gdi_act_get_pixel;

#define GDI_LAYER (*gdi_act_layer)
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_cf
 * DESCRIPTION
 *  creat a layer
 * PARAMETERS
 *  cf               : [IN]   layer color format
 *  offset_x         : [IN]   layer position x
 *  offset_y         : [IN]   layer position y
 *  width            : [IN]   layer width
 *  height           : [IN]   layer height
 *  handle_ptr       : [OUT]  return the created layer handle   
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_create_cf(
                    gdi_color_format cf,
                    S32 offset_x,
                    S32 offset_y,
                    S32 width,
                    S32 height,
                    gdi_handle *handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_cf_double
 * DESCRIPTION
 *  Create a double buffer layer
 *  Will return handle of the layer.
 * PARAMETERS
 *  cf               : [IN]   layer color format
 *  offset_x         : [IN]   layer position x
 *  offset_y         : [IN]   layer position y
 *  width            : [IN]   layer width
 *  height           : [IN]   layer height
 *  handle_ptr       : [OUT]  return the created layer handle        
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_create_cf_double(
                    gdi_color_format cf,
                    S32 offset_x,
                    S32 offset_y,
                    S32 width,
                    S32 height,
                    gdi_handle *handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_cf_using_outside_memory
 * DESCRIPTION
 *  Create a layer using buffer in parameter.
 *  Will return handle of the layer.
 * PARAMETERS
 *  cf                      : [IN]   layer color format
 *  offset_x                : [IN]   layer position x
 *  offset_y                : [IN]   layer position y
 *  width                   : [IN]   layer width
 *  height                  : [IN]   layer height
 *  handle_ptr              : [OUT]  return the created layer handle        
 *  outside_memory          : [IN]   the buffer used to create layer
 *  outside_memory_size     : [IN]   size of outside_memory
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_create_cf_using_outside_memory(
                    gdi_color_format cf,
                    S32 offset_x,
                    S32 offset_y,
                    S32 width,
                    S32 height,
                    gdi_handle *handle_ptr,
                    U8 *outside_memory,
                    S32 outside_memory_size);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_cf_double_using_outside_memory
 * DESCRIPTION
 *  Create a double buffer layer using buffer in parameter.
 *  Will return handle of the layer.
 * PARAMETERS
 *  cf                      : [IN]   layer color format
 *  offset_x                : [IN]   layer position x
 *  offset_y                : [IN]   layer position y
 *  width                   : [IN]   layer width
 *  height                  : [IN]   layer height
 *  handle_ptr              : [OUT]  return the created layer handle        
 *  outside_memory1         : [IN]   the buffer1 used to create layer 
 *  outside_memory_size_1   : [IN]   size of outside_memory1
 *  outside_memory2         : [IN]   the buffer2 used to create layer 
 *  outside_memory_size_2   : [IN]   size of outside_memory2     
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_create_cf_double_using_outside_memory(
                    gdi_color_format cf,
                    S32 offset_x,
                    S32 offset_y,
                    S32 width,
                    S32 height,
                    gdi_handle *handle_ptr,
                    U8 *outside_memory1,
                    S32 outside_memory_size_1,
                    U8 *outside_memory2,
                    S32 outside_memory_size_2);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_free
 * DESCRIPTION
 *  free the resource of a layer
 * PARAMETERS
 *  handle       : [IN]   layer to free
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_free(gdi_handle handle);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_lazy_free
 * DESCRIPTION
 *  Release layer
 *  Lazy free means we won't really realease this layer until we don't have enougn layer buffer.
 *  return FALSE if not valid handle.
 * PARAMETERS
 *  handle      : [IN]        
 * RETURNS
 * BOOL
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_lazy_free(gdi_handle handle,void (*lazy_free_callback)(gdi_handle handle));

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_active
 * DESCRIPTION
 *  Set a layer as active layer
 * PARAMETERS
 *  handle       : [IN]   layer handle to be set as active layer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_set_active(gdi_handle handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_toggle_double
 * DESCRIPTION
 *  Toggle double buf of active layer
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_toggle_double(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_base_handle
 * DESCRIPTION
 *  Get handle of base layer
 * PARAMETERS
 *  handle_ptr       : [OUT]   return the base layer handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_base_handle(gdi_handle *handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_restore_base_active
 * DESCRIPTION
 *  Restore base layer as active layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_restore_base_active(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_active
 * DESCRIPTION
 *  get currently active layer handle
 * PARAMETERS
 *  handle_ptr      : [OUT]       return active layer handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern void gdi_layer_get_active(gdi_handle *handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_push_and_set_active
 * DESCRIPTION
 *  push current layer into stack and set passin layer active
 * PARAMETERS
 *  handle      : [IN]    layer to be set as active layer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_push_and_set_active(gdi_handle handle);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_pop_and_restore_active
 * DESCRIPTION
 *  pop the layer in stack and make it active
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_pop_and_restore_active(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_is_double
 * DESCRIPTION
 *  return TRUE if the layer is a double buffer layer
 * PARAMETERS
 *  layer       : [IN]        the layer handle
 * RETURNS
 *  BOOL, return TRUE if the layer is a double buffer layer
 *****************************************************************************/
extern BOOL gdi_layer_is_double(gdi_handle layer);

/* layer setting */
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_color_format
 * DESCRIPTION
 *  get layer color format
 * PARAMETERS
 *  cf      [OUT]    active layer color format 
 * RETURNS
 * GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_color_format(gdi_color_format *cf);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_color_format
 * DESCRIPTION
 *  change color format of active layer.
 *  It assert if the layer buffer size is not enough for new color format.
 *  Please noticy that it may change the opacity & color_palette_enable of layer.
 * PARAMETERS
 *  cf      [IN]    new color format 
 * RETURNS
 * GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_color_format(gdi_color_format cf);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_position
 * DESCRIPTION
 *  Move the layer to its desired position.
 * PARAMETERS
 *  offset_x            : [IN]        move layer to this x position
 *  offset_y            : [IN]        move layer to this y position
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_position(S32 offset_x, S32 offset_y);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_source_key
 * DESCRIPTION
 *  Set transparent color and enable transparent color
 * PARAMETERS
 *  source_key_enable       : [IN]        TRUE if want to enable transparent color
 *  source_key_value        : [IN]        source key (transparent color)
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_source_key(BOOL source_key_enable, gdi_color source_key_value);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_source_key
 * DESCRIPTION
 *  Get transparent color and enable transparent color
 * PARAMETERS
 *  source_key_enable       : [OUT]   get TRUE if transparent color is enable
 *  source_key_value        : [OUT]   source key (transparent color)
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_source_key(BOOL *source_key_enable, gdi_color *source_key_value);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_opacity
 * DESCRIPTION
 *  Set opacity value and enable opacity.
 * PARAMETERS
 *  opacity_enable      : [IN]        TRUE if want to enable opacity
 *  opacity_value       : [IN]        opacity value
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_opacity(BOOL opacity_enable, U8 opacity_value);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_opacity
 * DESCRIPTION
 *  Get opacity value and enable opacity.
 * PARAMETERS
 *  opacity_enable      : [OUT]     TRUE if opacity is enable
 *  opacity_value       : [OUT]     opacity value 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_opacity(BOOL *opacity_enable, U8 *opacity_value);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_frame_buffer_lock_count
 * DESCRIPTION
 *  get the frame buffer blt_lock count
 * PARAMETERS
 *  frame_buffer_lock_count : [OUT]  frame buffer lock count
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_get_frame_buffer_lock_count(S32 *frame_buffer_lock_count);

/* DOM-NOT_FOR_SDK-END */

/* clip */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_clip
 * DESCRIPTION
 *  Get current clip region of a layer.
 * PARAMETERS
 *  x1                : [OUT]   x of left-top cornor of clip region
 *  y1                : [OUT]   y of left-top cornor of clip region
 *  x2                : [OUT]   x of right-down cornor of clip region
 *  y2                : [OUT]   y of right-down cornor of clip region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_get_clip(S32 *x1, S32 *y1, S32 *x2, S32 *y2);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_clip
 * DESCRIPTION
 *  Set clip region.
 *  
 *  Will set clip region, use layer's own coordinate.
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of clip region
 *  y1                : [IN]   y of left-top cornor of clip region
 *  x2                : [IN]   x of right-down cornor of clip region
 *  y2                : [IN]   y of right-down cornor of clip region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_set_clip(S32 x1, S32 y1, S32 x2, S32 y2);
extern GDI_RESULT gdi_layer_test_set_clip(gdi_rect_struct *rect);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_reset_clip
 * DESCRIPTION
 *  Reset clip region to layer size
 *  Will reset clip region to layer's width/height.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_reset_clip(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_push_clip
 * DESCRIPTION
 *  Push current clip region into clip stack.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_push_clip(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_push_and_set_clip
 * DESCRIPTION
  *  Push current clip region into stack and set clip region, use layer's 
  *  own coordinate.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_push_and_set_clip(S32 x1, S32 y1, S32 x2, S32 y2);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_pop_clip
 * DESCRIPTION
 *  Pop current clip region from stack.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_pop_clip(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_clip_preset
 * DESCRIPTION
 *  Set clip region.
 *  The new clip region will be the intersection of original clip and clip in parameters.
 * PARAMETERS
 *  x1                  : [IN]        x position of left-up corner of cilp region
 *  y1                  : [IN]        y position of left-up corner of cilp region
 *  x2                  : [IN]        x position of right-down corner of cilp region
 *  y2                  : [IN]        y position of right-down corner of cilp region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_set_clip_preset(S32 x1, S32 y1, S32 x2, S32 y2);

/* get buffer info */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_buffer_ptr
 * DESCRIPTION
 *  get currently active layer's frame buffer pointer.
 * PARAMETERS
 *  buf_ptr     : [OUT]       return the buffer pointer of layer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_buffer_ptr(U8 **buf_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_dimension
 * DESCRIPTION
 *  get currently active layer's size.
 * PARAMETERS
 *  width       : [OUT]       return widht of active layer
 *  height      : [OUT]       return height of active layer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_dimension(S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_position
 * DESCRIPTION
 *  get currently active layer's position.
 * PARAMETERS
 *  offset_x        : [OUT]       return position x of active layer
 *  offset_y        : [OUT]       return position y of active layer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_position(S32 *offset_x, S32 *offset_y);

/* DOM-NOT_FOR_SDK-BEGIN */

/* blt */
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt_ext
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The last four parameters are the region which to blt to LCD.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 *  x1          : [IN]        x of left-top cornor of blt region
 *  y1          : [IN]        y of left-top cornor of blt region
 *  x2          : [IN]        x of right-down cornor of blt region
 *  y2          : [IN]        y of right-down cornor of blt region
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_blt_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3,
                #ifdef GDI_6_LAYERS
                    gdi_handle handle4,
                    gdi_handle handle5,
                #endif
                    S32 x1, 
                    S32 y1, 
                    S32 x2, 
                    S32 y2);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt_previous
 * DESCRIPTION
 *  Blt previous blt layers.
 * PARAMETERS
 *  x1  : [IN]   x of left-top cornor of blt region
 *  y1  : [IN]   y of left-top cornor of blt region
 *  x2  : [IN]   x of right-down cornor of blt region
 *  y2  : [IN]   y of right-down cornor of blt region 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_blt_previous(S32 x1, S32 y1, S32 x2, S32 y2);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt_base_layer
 * DESCRIPTION
 *  Blt base layer to LCD
 * PARAMETERS
 *  x1                : [IN]   x of left-top cornor of blt region
 *  y1                : [IN]   y of left-top cornor of blt region
 *  x2                : [IN]   x of right-down cornor of blt region
 *  y2                : [IN]   y of right-down cornor of blt region
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_blt_base_layer(S32 x1, S32 y1, S32 x2, S32 y2);

/* DOM-NOT_FOR_SDK-BEGIN */
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_blt_layer_previous
 * DESCRIPTION
 *  config the settings of previous blt layers to LCD driver.
 * PARAMETERS
 *  
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_blt_layer_previous(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_blt_layer_ext
 * DESCRIPTION
 *  Set blt layers to GDI and config driver's setting
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_blt_layer_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2,
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                    );

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_blt_layer_ext
 * DESCRIPTION
 *  get the blt layer
 * PARAMETERS
 *  handle0     : [OUT]        layer handle 0, the most bottom layer
 *  handle1     : [OUT]        layer handle 1
 *  handle2     : [OUT]        layer handle 2
 *  handle3     : [OUT]        layer handle 3
 *  handle4     : [OUT]        layer handle 4
 *  handle5     : [OUT]        layer handle 5
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_blt_layer_ext(
                    gdi_handle *handle0, 
                    gdi_handle *handle1, 
                    gdi_handle *handle2,
                    gdi_handle *handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle *handle4
                    ,gdi_handle *handle5
                #endif
                    );

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_blt_layer_number
 * DESCRIPTION
 *  get how many layers that hw can blt or flatten at one time.
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
extern S32 gdi_layer_get_blt_layer_number(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_blt_layer_flag
 * DESCRIPTION
 *  MDI needs to set blt layer flag when they set hw update layer.
 *  So they have to get blt layer flag from gdi.
 *  When "blt with double buffer" is enable, the real blt layer is in gdi_blt_with_double_buf_blt_handle[].
 * PARAMETERS
 *  blt_layer_flag  [OUT]  return the blt_layer_flag
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern gdi_result gdi_layer_get_blt_layer_flag(U32 *blt_layer_flag);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_lock_frame_buffer
 * DESCRIPTION
 *  Lock blt. Avoid others to blt this layer.
 *  And merge the blt region, so gdi will blt all region after unlock frame buffer.
 *  remeber to call gdi_layer_unlock_frame_buffer after this function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_lock_frame_buffer(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_unlock_frame_buffer
 * DESCRIPTION
 *  Unlock layer. Let others able to blt this layer.
 * PARAMETERS
 *  void  
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_unlock_frame_buffer(void);

/* clear background */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_clear
 * DESCRIPTION
 *  paint active layer with bg_color
 * PARAMETERS
 *  bg_color        : [IN]        color to paint on active layer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_clear(gdi_color color);

/* DOM-NOT_FOR_SDK-BEGIN */

/* multi-layering flag */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_multi_layer_enable
 * DESCRIPTION
 *  This function is useless now.
 *  Enable multi-layer functions
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_multi_layer_enable(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_multi_layer_disable
 * DESCRIPTION
 *  This function is useless now.
 *  Disable multi-layer functions
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_multi_layer_disable(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_is_multi_layer_enable
 * DESCRIPTION
 *  This function is useless now.
 * PARAMETERS
 *  void
 * RETURNS
 *  BOOL
 *****************************************************************************/
extern BOOL gdi_layer_is_multi_layer_enable(void);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_previous_to_base
 * DESCRIPTION
 *  flatten previous blt layers to base layer
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_flatten_previous_to_base(void);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_is_ready
 * DESCRIPTION
 *  Check if flatten is available or not.
 *  When multimedia is running, using LCD to flatten is not allowed. 
 *  But we can use GOVL to do it, so it always return true on MT6236.
 * PARAMETERS       
 * RETURNS
 *  kal_bool
 *****************************************************************************/
extern kal_bool gdi_layer_flatten_is_ready(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_to_base_ext
 * DESCRIPTION
 *  flatten layers to base layer
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_flatten_to_base_ext(
                    gdi_handle src_handle0, 
                    gdi_handle src_handle1, 
                    gdi_handle src_handle2,
                    gdi_handle src_handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle src_handle4
                    ,gdi_handle src_handle5
                #endif
                    );
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_ext
 * DESCRIPTION
 *  flatten the specified layers to active layer.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_flatten_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                    );
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_with_clipping_ext
 * DESCRIPTION
 *  flatten layers to active layer in active layer's clipping region
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_flatten_with_clipping_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2,
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                    );

/* debug use, for print debug info, this will print base layer, ignore all locked flag */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_debug_blt
 * DESCRIPTION
 *  Use when ASSERT or Fatal Error happen to print debug info.
 *  Debug use, for print debug info, this will print base layer, ignore all locked flag.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_debug_blt(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_debug_flatten
 * DESCRIPTION
 *  use when ASSERT or Fatal Error happen to flatten all layers to base layer.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_debug_flatten(void);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_save_jpeg_file
 * DESCRIPTION
 *  encode the layer content to a jpeg file
 * PARAMETERS
 *  layer_handle       : [IN]     layer to encode
 *  file_name          : [IN]     save jpeg file with this filename
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_save_jpeg_file(gdi_handle layer_handle, PS8 file_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_save_pbm_file
 * DESCRIPTION
 *  encode the layer content to a pbm file
 * PARAMETERS
 *  layer_handle       : [IN]     layer to encode
 *  file_name          : [IN]     save pbm file with this filename
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_save_pbm_file(gdi_handle layer_handle, PS8 file_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_save_bmp_file
 * DESCRIPTION
 *  encode the layer content to a bmp file
 * PARAMETERS
 *  layer_handle       : [IN]     layer to encode
 *  file_name          : [IN]     save bmp file with this filename
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_save_bmp_file(gdi_handle layer_handle, PS8 file_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_bit_per_pixel
 * DESCRIPTION
 *  get the active layer pixel size (in bits)
 * PARAMETERS
 *  void
 * RETURNS
 *  int, bit_per_pixel of layer
 *****************************************************************************/
extern int gdi_layer_get_bit_per_pixel(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_resize
 * DESCRIPTION
 *  set the dimension of layer.
 *  (w*h*bit_per_pixel) can't larger than the buffer size of layer.
 * PARAMETERS
 *  width       : [IN]        width of layer (in pixel)
 *  height      : [IN]        height of layer (in pixel)
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_resize(S32 width, S32 height);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_rotate
 * DESCRIPTION
 *  set rotate value of active layer
 * PARAMETERS
 *  rotate_value    : [IN]    should be GDI_LCD_LAYER_ROTATE_0,90,180...defined in gdi_const.h
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_set_rotate(U8 rotate_value);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_copy_double
 * DESCRIPTION
 *  copy content from the second buffer to the active buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_copy_double(void);
#ifdef GDI_COLORFORMAT8_PALETTE
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_palette
 * DESCRIPTION
 *  set color to palette entry
 * PARAMETERS
 *  index       : [IN]        the entry index in palette
 *  color       : [IN]        set color to palette entry
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_set_palette(U8 index, gdi_color color);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_palette
 * DESCRIPTION
 *  get the palette pointer
 * PARAMETERS
 *  void
 * RETURNS
 *  gdi_color, the palette pointer
 *****************************************************************************/
extern gdi_color *gdi_layer_get_palette(void);
#endif /* GDI_COLORFORMAT8_PALETTE */
/*****************************************************************************
 * FUNCTION
 *  gdi_enable_non_block_blt
 * DESCRIPTION
 *  enable non blocking blt call.
 *  After calling this API, blt will become non-blocking blt when all layers in draw section.
 *  DEPRECATED: Please use gdi_layer_blt_with_flag instead
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_enable_non_block_blt(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_disable_non_block_blt
 * DESCRIPTION
 *  disable non blocking blt call
 *  DEPRECATED: Please use gdi_layer_blt_with_flag instead
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_disable_non_block_blt(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_enable_non_block_blt
 * DESCRIPTION
 *  get gdi_is_non_block_blt
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern BOOL gdi_layer_get_enable_non_block_blt(void);

/* DOM-NOT_FOR_SDK-BEGIN */
#ifdef GDI_NB_BLT_SUPPORT
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_enter_draw_section
 * DESCRIPTION
 *  When using non-blocking blt, this API will wait blt finishing 
 *  and unfroze layer.
 *  This API need called when you want change the layer content when using non-blocking blt.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_enter_draw_section(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_exit_draw_section
 * DESCRIPTION
 *  Exit draw section. If there is no layer in draw section, set frozen flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_exit_draw_section(void);
#endif /* GDI_NB_BLT_SUPPORT */
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_del
 * DESCRIPTION
 *  delete a node in blt layer tree.
 * PARAMETERS
 *  parent      : [IN]        the parent node of the node you want to delete
 *  child       : [IN]        the node want to delete
 * RETURNS
 *  BOOL, return TRUE if success
 *****************************************************************************/
extern BOOL gdi_layer_del(gdi_handle parent, gdi_handle child);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_add
 * DESCRIPTION
 *  add a node to blt layer tree.
 * PARAMETERS
 *  parent          : [IN]        the parent of the the node you want to add
 *  child           : [IN]        the node you want to add
 *  offset_x        : [IN]        x offset of child layer
 *  offset_y        : [IN]        y offset of child layer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_add(gdi_handle parent, gdi_handle child, S32 offset_x, S32 offset_y);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_del_all_child
 * DESCRIPTION
 *  delete all child node of the parent node
 * PARAMETERS
 *  parent      : [IN]        the parent node, all its node will be deleted.
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_del_all_child(gdi_handle parent);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_background
 * DESCRIPTION
 *  set the layer background color
 * PARAMETERS
 *  color       : [IN]        layer background color
 * RETURNS
 *  BOOL, return TRUE if succeed
 *****************************************************************************/
extern BOOL gdi_layer_set_background(gdi_color color);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_background
 * DESCRIPTION
 *  get the layer background color
 * PARAMETERS
 *  void
 * RETURNS
 *  gdi_color, background color
 *****************************************************************************/
extern gdi_color gdi_layer_get_background(void);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_add_post_effect
 * DESCRIPTION
 *  add post effect to a layer
 * PARAMETERS
 *  effect_id           : [IN]        Effect type
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_add_post_effect(U16 effect_id);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_add_post_adjustment
 * DESCRIPTION
 *  preview fail handler (driver error)
 * PARAMETERS
 *  adjustment_id       : [IN]        Adjustment type
 *  value               : [IN]        Adjustment value
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_add_post_adjustment(U16 adjustment_id, S32 value);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_apply_gray_effect
 * DESCRIPTION
 *  apply gray scale effect to the active layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_layer_apply_gray_effect(void);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create
 * DESCRIPTION
 *  creat a layer
 * PARAMETERS
 *  OFFSET_X         : [IN]   layer position x
 *  OFFSET_Y         : [IN]   layer position y
 *  WIDTH            : [IN]   layer width
 *  HEIGHT           : [IN]   layer height
 *  HANDLE_PTR       : [OUT]  return the created layer handle   
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_create(
            S32 offset_x,
            S32 offset_y,
            S32 width,
            S32 height,
            gdi_handle *handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_double
 * DESCRIPTION
 *  Create a double buffer layer
 *  Will return handle of the layer.
 *  If no valid layer, will retrun GDI_LAYER_ERROR_HANDLE.
 * PARAMETERS
 *  OFFSET_X         : [IN]   layer position x
 *  OFFSET_Y         : [IN]   layer position y
 *  WIDTH            : [IN]   layer width
 *  HEIGHT           : [IN]   layer height
 *  HANDLE_PTR       : [OUT]  return the created layer handle        
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_layer_create_double(OFFSET_X, OFFSET_Y,WIDTH,HEIGHT,HANDLE_PTR) \
      gdi_layer_create_cf_double(GDI_LCD->cf,OFFSET_X,OFFSET_Y,WIDTH,HEIGHT,HANDLE_PTR)

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_using_outside_memory
 * DESCRIPTION
 *  Create a layer using buffer in parameter.
 *  Will return handle of the layer.
 * PARAMETERS
 *  X               : [IN]   layer position x
 *  Y               : [IN]   layer position y
 *  WIDTH           : [IN]   layer width
 *  HEIGHT          : [IN]   layer height
 *  HANDLE_PTR      : [OUT]  return the created layer handle        
 *  OUTMEM_PTR      : [IN]   the buffer used to create layer
 *  OUTMEM_SIZE     : [IN]   size of outside_memory
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_layer_create_using_outside_memory(X,Y,WIDTH,HEIGHT,HANDLE_PTR,OUTMEM_PTR,OUTMEM_SIZE) \
      gdi_layer_create_cf_using_outside_memory(GDI_LCD->cf,X,Y,WIDTH,HEIGHT,HANDLE_PTR,OUTMEM_PTR,OUTMEM_SIZE)

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_create_double_using_outside_memory
 * DESCRIPTION
 *  Create a double buffer layer using buffer in parameter.
 *  Will return handle of the layer.
 * PARAMETERS
 *  X                : [IN]   layer position x
 *  Y                : [IN]   layer position y
 *  WIDTH            : [IN]   layer width
 *  HEIGHT           : [IN]   layer height
 *  HANDLE_PTR       : [OUT]  return the created layer handle        
 *  OUTMEM_PTR       : [IN]   the buffer used to create layer
 *  OUTMEM_SIZE      : [IN]   size of outside_memory, should be (w*h*cf*2) for double buffer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_layer_create_double_using_outside_memory(X,Y, WIDTH,HEIGHT,HANDLE_PTR,OUTMEM_PTR,OUTMEM_SIZE) \
         gdi_layer_create_cf_double_using_outside_memory                                                  \
            (GDI_LCD->cf,X,Y,WIDTH,HEIGHT,HANDLE_PTR,                                                     \
             OUTMEM_PTR,(OUTMEM_SIZE)>>1,OUTMEM_PTR+(OUTMEM_SIZE>>1),(OUTMEM_SIZE)>>1)

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The last four parameters are the region which to blt to LCD.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  x1          : [IN]        x of left-top cornor of blt region
 *  y1          : [IN]        y of left-top cornor of blt region
 *  x2          : [IN]        x of right-down cornor of blt region
 *  y2          : [IN]        y of right-down cornor of blt region
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#ifdef GDI_6_LAYERS
#define gdi_layer_blt(H1,H2,H3,H4,X1,Y1,X2,Y2)        gdi_layer_blt_ext(H1,H2,H3,H4,0,0,X1,Y1,X2,Y2)
#else
#define gdi_layer_blt(H1,H2,H3,H4,X1,Y1,X2,Y2)        gdi_layer_blt_ext(H1,H2,H3,H4,X1,Y1,X2,Y2)
#endif
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_blt_layer
 * DESCRIPTION
 *  get the blt layer
 * PARAMETERS
 *  handle0     : [OUT]        layer handle 0, the most bottom layer
 *  handle1     : [OUT]        layer handle 1
 *  handle2     : [OUT]        layer handle 2
 *  handle3     : [OUT]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#ifdef GDI_6_LAYERS
#define gdi_layer_get_blt_layer(H1,H2,H3,H4)       gdi_layer_get_blt_layer_ext(H1,H2,H3,H4,0,0)
#else
#define gdi_layer_get_blt_layer(H1,H2,H3,H4)       gdi_layer_get_blt_layer_ext(H1,H2,H3,H4)
#endif
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_blt_layer
 * DESCRIPTION
 *  Set blt layers to GDI and config driver's setting
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_blt_layer(
            gdi_handle handle0, 
            gdi_handle handle1, 
            gdi_handle handle2,
            gdi_handle handle3);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_to_base
 * DESCRIPTION
 *  flatten layers to base layer
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_flatten_to_base(
            gdi_handle src_handle0, 
            gdi_handle src_handle1, 
            gdi_handle src_handle2,
            gdi_handle src_handle3);
/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten
 * DESCRIPTION
 *  flatten the specified layers to active layer.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_layer_flatten(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3);
#ifdef GDI_6_LAYERS
#define gdi_layer_set_blt_layer_nb_concurrent(H1,H2,H3,H4)      gdi_layer_set_blt_layer_nb_concurrent_ext(H1,H2,H3,H4,0,0)
#define gdi_layer_blt_nb_concurrent(H1,H2,H3,H4,X1,Y1,X2,Y2)    gdi_layer_blt_nb_concurrent_ext(H1,H2,H3,H4,0,0,X1,Y1,X2,Y2)
#else
#define gdi_layer_set_blt_layer_nb_concurrent(H1,H2,H3,H4)      gdi_layer_set_blt_layer_nb_concurrent_ext(H1,H2,H3,H4)
#define gdi_layer_blt_nb_concurrent(H1,H2,H3,H4,X1,Y1,X2,Y2)    gdi_layer_blt_nb_concurrent_ext(H1,H2,H3,H4,X1,Y1,X2,Y2)
#endif
/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_flatten_with_clipping
 * DESCRIPTION
 *  flatten layers to active layer in active layer's clipping region
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#ifdef GDI_6_LAYERS
#define gdi_layer_flatten_with_clipping(H1,H2,H3,H4)  gdi_layer_flatten_with_clipping_ext(H1,H2,H3,H4,0,0)
#else
#define gdi_layer_flatten_with_clipping(H1,H2,H3,H4)  gdi_layer_flatten_with_clipping_ext(H1,H2,H3,H4)
#endif
/* DOM-NOT_FOR_SDK-BEGIN */
/*
 *  NB Concurrent API
 */

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt_previous_nb_concurrent
 * DESCRIPTION
 *  Blt previous blt layers.
 * PARAMETERS
 *  x1      [IN]        
 *  y1      [IN]        
 *  x2      [IN]        
 *  y2      [IN]        
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_blt_previous_nb_concurrent(S32 x1, S32 y1, S32 x2, S32 y2);

extern GDI_RESULT gdi_layer_set_position_nb_concurrent(gdi_handle layer_handle, S32 offset_x, S32 offset_y);
extern GDI_RESULT gdi_layer_set_rotate_nb_concurrent(gdi_handle layer_handle, U8 rotate_value);
extern GDI_RESULT gdi_layer_set_source_key_nb_concurrent(
            gdi_handle layer_handle, 
            BOOL source_key_enable, 
            gdi_color source_key_value);
extern GDI_RESULT gdi_layer_set_opacity_nb_concurrent(gdi_handle layer_handle, BOOL opacity_enable, U8 opacity_value);
extern GDI_RESULT gdi_layer_set_background_nb_concurrent(gdi_handle layer_handle, gdi_color color);
extern GDI_RESULT gdi_layer_resize_nb_concurrent(gdi_handle layer_handle, S32 width, S32 height);
extern GDI_RESULT gdi_layer_clear_nb_concurrent(gdi_handle layer_handle, gdi_color bg_color);
extern GDI_RESULT gdi_layer_get_dimension_nb_concurrent(gdi_handle layer_handle, S32 *width, S32 *height);
extern void gdi_draw_solid_rect_nb_concurrent(gdi_handle layer_handle, S32 x1, S32 y1, S32 x2, S32 y2, gdi_color rect_color);
extern GDI_RESULT gdi_layer_get_position_nb_concurrent(gdi_handle layer_handle, S32 *offset_x, S32 *offset_y);
extern U8 gdi_layer_get_rotate_nb_concurrent(gdi_handle layer_handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_rotate
 * DESCRIPTION
 *  get layer rotate value
 * PARAMETERS
 *  void
 * RETURNS
 *  U8, the rotate value defined in gdi_const.h, should be GDI_LCD_LAYER_ROTATE_0,90,180...
 *****************************************************************************/
extern U8 gdi_layer_get_rotate(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_layer_to_lcd_region
 * DESCRIPTION
 *  map a region from layer to lcd coordinate
 *  input layer coordinate, output lcd coordinate.
 * PARAMETERS
 *  rotate_value       : [IN]     rotate value of lcd
 *  x1                 : [OUT]    the x position of left-up corner of the region
 *  y1                 : [OUT]    the y position of left-up corner of the region
 *  x2                 : [OUT]    the x position of right-down corner of the region
 *  y2                 : [OUT]    the y position of right-down corner of the region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_layer_to_lcd_region(U8 rotate_value, S32 *x1, S32 *y1, S32 *x2, S32 *y2);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_layer_to_lcd
 * DESCRIPTION
 *  map a point from layer to lcd coordinate
 *  input layer coordinate, output lcd coordinate.
 * PARAMETERS
 *  rotate_value        : [IN]        rotate value of lcd
 *  x                   : [OUT]       the x position of the point
 *  y                   : [OUT]       the y position of the point
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_layer_to_lcd(U8 rotate_value, S32 *x, S32 *y);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_lcd_to_layer
 * DESCRIPTION
 *  map a region from lcd to layer coordinate
 *  input lcd coordinate, output layer coordinate.
 * PARAMETERS
 *  rotate_value        : [IN]        rotate value of layer
 *  x                   : [OUT]       the x position of the point
 *  y                   : [OUT]       the y position of the point
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_lcd_to_layer(U8 rotate_value, S32 *x, S32 *y);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// LCD API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define GDI_LCD_MAIN_LCD_HANDLE  (1)
#define GDI_LCD_SUB_LCD_HANDLE   (2)
#define GDI_LCD_TVOUT_HANDLE  (3)
#define GDI_LCD_ESD_RECOVERY_TIME 2000

typedef struct
{
    /* active LCD */
    gdi_handle act_handle;
    gdi_handle act_layer_handle;
    gdi_handle bind_handle;
    S32 act_width;
    S32 act_height;
    gdi_handle blt_handle[GDI_LAYER_HW_LAYER_COUNT];
    U32 blt_counter;                  /* Venus use this counter to know whether their setting ever blt out or not. */
    gdi_color_format cf;
    BOOL is_freeze;
    BOOL is_high_priority_freeze;   /* this freeze flag can override is_freeze */
    gdi_lcd_type_enum lcd_type;

    /* validate update area. */
    S32 blt_lock;
    gdi_rect_struct blt_rect;       /* blt region */
    BOOL blt_rect_is_used;    /* blt_rect is validate */
    U8 rotate_value;
    BOOL rotate_by_layer;
    /* CABC:Content-Adaptive-Backlight-Control */
    BOOL cabc_enable_setting;
    gdi_cabc_mode_enum cabc_current_mode;
#if defined(GDI_LCD_SCANLINE_ROTATION)
    /* need GDI handle scanline rotation or not */
    BOOL scanline_rotation;
    gdi_handle scanline_blt_handle;
#endif
} gdi_lcd_cntx_struct;

extern gdi_lcd_cntx_struct *GDI_LCD;

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_active
 * DESCRIPTION
 *  set a lcd active
 * PARAMETERS
 *  lcd_handle      : [IN]        lcd handle to set active
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_set_active(gdi_handle lcd_handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_active
 * DESCRIPTION
 *  get current active lcd's handle
 * PARAMETERS
 *  lcd_handle_ptr      : [OUT]       return active lcd handle
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_get_active(gdi_handle *lcd_handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_dimension
 * DESCRIPTION
 *  get dimesion of current active lcd
 * PARAMETERS
 *  width       : [OUT]       return width of active lcd
 *  height      : [OUT]       return height of active lcd
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_get_dimension(S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_bits_per_pixel
 * DESCRIPTION
 *  get the bits per pixel value of active lcd
 * PARAMETERS
 *  void
 * RETURNS
 *  int, bits per pixel of active lcd
 *****************************************************************************/
extern int gdi_lcd_get_bits_per_pixel(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_freeze
 * DESCRIPTION
 *  set active lcd freezed or not, if freezed, the lcd won't be blt
 * PARAMETERS
 *  is_freeze       : [IN]        if TRUE, the lcd won't be blt
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_freeze(BOOL is_freeze);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_freeze
 * DESCRIPTION
 *  get the state if lcd is freezed or not
 * PARAMETERS
 *  void        
 * RETURNS
 *  BOOL, The acrive LCD is freezed or not
 *****************************************************************************/
extern BOOL gdi_lcd_get_freeze(void);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_esd_recovery
 * DESCRIPTION
 *  check whether LCM is corrupted by ESD.
 *  if ture, init the LCD, call gdi_layer_blt_previous.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_esd_recovery(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_stop_esd_recovery_timer
 * DESCRIPTION
 *  stop the timer used to call gdi_lcd_start_esd_recovery_timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_stop_esd_recovery_timer(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_start_esd_recovery_timer
 * DESCRIPTION
 *  call gdi_lcd_esd_recovery(), and restart a timer, the timer will call itself when time out
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_start_esd_recovery_timer(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_lcd_to_absolute_hw_region
 * DESCRIPTION
 *  map a region from lcd to absolute hw coordinate
 *  input lcd coordinate, output lcd coordinate.
 * PARAMETERS
 *  rotate_value       : [IN]     rotate value of lcd
 *  x1                 : [OUT]    the x position of left-up corner of the region
 *  y1                 : [OUT]    the y position of left-up corner of the region
 *  x2                 : [OUT]    the x position of right-down corner of the region
 *  y2                 : [OUT]    the y position of right-down corner of the region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_lcd_to_absolute_hw_region(U8 rotate_value, S32 *x1, S32 *y1, S32 *x2, S32 *y2);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_absolute_hw_to_lcd_region
 * DESCRIPTION
 *  map a region from absolute hw to lcd coordinate
 *  input absolute hw coordinate, output lcd coordinate.
 * PARAMETERS
 *  rotate_value       : [IN]     rotate value of lcd
 *  x1                 : [OUT]    the x position of left-up corner of the region
 *  y1                 : [OUT]    the y position of left-up corner of the region
 *  x2                 : [OUT]    the x position of right-down corner of the region
 *  y2                 : [OUT]    the y position of right-down corner of the region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_absolute_hw_to_lcd_region(U8 rotate_value, S32 *x1, S32 *y1, S32 *x2, S32 *y2);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_rotate
 * DESCRIPTION
 *  get the rotate value of active lcd
 * PARAMETERS
 *  void
 * RETURNS
 *  U8, lcd rotate value, ex.GDI_LCD_LAYER_ROTATE_0,90,180...
 *****************************************************************************/
extern U8 gdi_lcd_get_rotate(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_rotate
 * DESCRIPTION
 *  set rotate value of active lcd
 * PARAMETERS
 *  rotate_value    : [IN]    rotate value, ex.GDI_LCD_LAYER_ROTATE_0,90,180...
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_set_rotate(U8 rotate_value);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_bind
 * DESCRIPTION
 *  bind active lcd with another lcd.
 * PARAMETERS
 *  lcd_handle      : [IN]        lcd handle to bind. usually GDI_LCD_TVOUT_HANDLE or GDI_NULL_HANDLE
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_set_bind(gdi_handle lcd_handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_rotate
 * DESCRIPTION
 *  set rotate value of active lcd
 * PARAMETERS
 *  rotate_value    : [IN]    rotate value, ex.GDI_LCD_LAYER_ROTATE_0,90,180...
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_set_rotate(U8 rotate_value);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_rotate
 * DESCRIPTION
 *  get the rotate value of active lcd
 * PARAMETERS
 *  void
 * RETURNS
 *  U8, lcd rotate value, ex.GDI_LCD_LAYER_ROTATE_0,90,180...
 *****************************************************************************/
extern U8 gdi_lcd_get_rotate(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_rotate_by_layer
 * DESCRIPTION
 *  Implement lcd rotate by layer rotate. 
 *  LCD rotate need hw support, so use layer rotate to implement it.
 * PARAMETERS
 *  rotate_by_layer     : [IN]        TRUE to enable rotate by layer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_lcd_set_rotate_by_layer(BOOL rotate_by_layer);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_rotate_by_layer
 * DESCRIPTION
 *  Implement lcd rotate by layer rotate. 
 *  LCD rotate need hw support, so use layer rotate to implement it.
 * PARAMETERS
 *  rotate_by_layer     : [IN]        TRUE to enable rotate by layer
 * RETURNS
 *  void
 *****************************************************************************/
extern BOOL gdi_lcd_get_rotate_by_layer(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_absolute_hw_to_lcd
 * DESCRIPTION
 *  map a point from absolute hw to lcd coordinate
 *  input absolute hw coordinate, output lcd coordinate.
 * PARAMETERS
 *  x1                 : [OUT]    the x position of the point
 *  y1                 : [OUT]    the y position of the point
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_absolute_hw_to_lcd(S32 *x, S32 *y);
/*****************************************************************************
 * FUNCTION
 *  gdi_rotate_map_lcd_to_absolute_hw
 * DESCRIPTION
 *  map a region from lcd to absolute hw coordinate.
 *  Input the lcd coordinate, output the absolute hw coordinate.
 * PARAMETERS
 *  x1                 : [OUT]    the x position of the point
 *  y1                 : [OUT]    the y position of the point
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_rotate_map_lcd_to_absolute_hw(S32 *x, S32 *y);

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_te_ctrl
 * DESCRIPTION
 *  lcd API wrapper for application to set te ctrl.(tearing control)
 * PARAMETERS
 *  te_ctrl [IN] turn on or turn off lcd te ctrl.
 * RETURNS
 *  kal_bool, return the previous setting of te ctrl
 *****************************************************************************/
extern kal_bool gdi_lcd_set_te_ctrl(kal_bool te_ctrl);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_te_ctrl
 * DESCRIPTION
 *  lcd API wrapper for application to set te ctrl.(tearing control) for MATV
 * PARAMETERS
 *  te_ctrl [IN] turn on or turn off lcd te ctrl.
 * RETURNS
 *  kal_bool, return the previous setting of te ctrl
 *****************************************************************************/
extern kal_bool gdi_lcd_set_te_ctrl_with_commit(kal_bool te_ctrl);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_te_ctrl
 * DESCRIPTION
 *  lcd API wrapper for application to get te ctrl.(tearing control)
 * PARAMETERS
 *  
 * RETURNS
 *  kal_bool, return the current setting of te ctrl
 *****************************************************************************/
extern kal_bool gdi_lcd_get_te_ctrl(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_te_ctrl_handle
 * DESCRIPTION
 *  lcd API wrapper for application to set te ctrl.
 *  call this API before calling gdi_lcd_te_ctrl_push.
 * PARAMETERS
 *  void
 * RETURNS
 *  kal_uint8 te_ctrl_handle
 *****************************************************************************/
extern kal_uint8 gdi_lcd_get_te_ctrl_handle(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_te_ctrl_push
 * DESCRIPTION
 *  lcd API wrapper for application to set te ctrl.
 *  Set new setting and push previous setting to stack.
 * PARAMETERS
 *  on_Noff [IN] turn on or turn off lcd te ctrl.
 *  handle  [IN] handle get from gdi_lcd_get_te_ctrl_handle();
 * RETURNS
 *  kal_bool
 *****************************************************************************/
extern kal_bool gdi_lcd_te_ctrl_push(kal_bool on_Noff, kal_uint8 handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_te_ctrl_push
 * DESCRIPTION
 *  lcd API wrapper for application to set te ctrl.
 *  Pop and restore to previous lcd te ctrl setting.
 * PARAMETERS
 *  handle  [IN] handle get from gdi_lcd_get_te_ctrl_handle();
 * RETURNS
 *  kal_bool
 *****************************************************************************/
extern kal_bool gdi_lcd_te_ctrl_pop(kal_uint8 handle);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_blt
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The blt region is the full LCD size.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_blt(gdi_handle handle0, gdi_handle handle1, gdi_handle handle2, gdi_handle handle3);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_paint_ext
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The last four parameters are the region which to blt to LCD.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 *  x1          : [IN]        x of left-top cornor of blt region
 *  y1          : [IN]        y of left-top cornor of blt region
 *  x2          : [IN]        x of right-down cornor of blt region
 *  y2          : [IN]        y of right-down cornor of blt region
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_paint_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3,
                #ifdef GDI_6_LAYERS
                    gdi_handle handle4, 
                    gdi_handle handle5,
                #endif
                    S32 x1, 
                    S32 y1, 
                    S32 x2, 
                    S32 y2);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_repaint
 * DESCRIPTION
 *  Blt the previous blt layers to LCD.
 *  The four parameters are the region to blt to LCD.
 * PARAMETERS
 *  x1          : [IN]        x of left-top cornor of blt region
 *  y1          : [IN]        y of left-top cornor of blt region
 *  x2          : [IN]        x of right-down cornor of blt region
 *  y2          : [IN]        y of right-down cornor of blt region
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed 
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_repaint(S32 x1, S32 y1, S32 x2, S32 y2);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_paint_all_ext
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The blt region is the full screen.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  handle4     : [IN]        layer handle 4
 *  handle5     : [IN]        layer handle 5
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed 
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_paint_all_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                    );

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_repaint_all
 * DESCRIPTION
 *  Blt the previous blt layers to LCD. The blt region is the full LCD.
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_repaint_all(void);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_paint
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The last four parameters are the region which to blt to LCD.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 *  x1          : [IN]        x of left-top cornor of blt region
 *  y1          : [IN]        y of left-top cornor of blt region
 *  x2          : [IN]        x of right-down cornor of blt region
 *  y2          : [IN]        y of right-down cornor of blt region
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#ifdef GDI_6_LAYERS
#define gdi_lcd_paint(H1,H2,H3,H4,X1,Y1,X2,Y2)        gdi_lcd_paint_ext(H1,H2,H3,H4,0,0,X1,Y1,X2,Y2)
#else
#define gdi_lcd_paint(H1,H2,H3,H4,X1,Y1,X2,Y2)        gdi_lcd_paint_ext(H1,H2,H3,H4,X1,Y1,X2,Y2)
#endif
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_paint_all
 * DESCRIPTION
 *  Blt layers to LCD in the order that handle0 is the most bottom layer.
 *  The blt region is the full screen.
 * PARAMETERS
 *  handle0     : [IN]        layer handle 0, the most bottom layer
 *  handle1     : [IN]        layer handle 1
 *  handle2     : [IN]        layer handle 2
 *  handle3     : [IN]        layer handle 3
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed 
 *****************************************************************************/
#ifdef GDI_6_LAYERS
#define gdi_lcd_paint_all(H1,H2,H3,H4)       gdi_lcd_paint_all_ext(H1,H2,H3,H4,0,0)
#else
#define gdi_lcd_paint_all(H1,H2,H3,H4)       gdi_lcd_paint_all_ext(H1,H2,H3,H4)
#endif
/// IMAGE API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
typedef struct
{
    S32 width;
    S32 height;
    U8 *buf_ptr;
} gdi_image_cache_bmp_struct;

typedef enum
{
    GDI_IMAGE_SRC_FROM_RESOURCE,
    GDI_IMAGE_SRC_FROM_MEMORY,
    GDI_IMAGE_SRC_FROM_FILE,
    GDI_IMAGE_SRC_FROM_RESOURCE_WITHOUT_HEADER
} gdi_image_src_enum;

#if defined(GDI_USING_SCREEN_SHOT_BUFFER)
extern U32 gdi_screen_shot_buffer[];
#endif
extern U32 gdi_screen_shot_buffer_size;
/*****************************************************************************
 * FUNCTION
 *  gdi_image_codec_draw
 * DESCRIPTION
 *  draw image
 * PARAMETERS
 *  src_type        : [IN]        resource, or file, or memory. ex.GDI_IMAGE_SRC_FROM_RESOURCE...
 *  img_src         : [IN]        image pointer, if src_type is file, img_src is file name
 *  img_type        : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  img_size        : [IN]        if img_src is memory, this is size of img_src
 *  x               : [IN]        x position to draw image
 *  y               : [IN]        y position to draw image
 *  w               : [IN]        image width to draw
 *  h               : [IN]        image height to draw
 *  flag            : [IN]        flags defined in gdi_image_codec_flag_enum
 *  frame_pos       : [IN]        this is frame index to draw if image is animation, 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_codec_draw(
                    gdi_image_src_enum src_type,
                    U8 *img_src,
                    U8 img_type,
                    S32 img_size,
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    U32 flag,
                    U32 frame_pos);
    
/* DOM-NOT_FOR_SDK-END */

////////////////
// RESOURCE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw
 * DESCRIPTION
 *  draw image from resource with original image dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_PTR         : [IN]        image pointer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw(
                    S32 x,
                    S32 y,
                    U8 *img_src);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized
 * DESCRIPTION
 *  draw image from resource with specified image dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_resized(
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    U8 *img_src);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_frames
 * DESCRIPTION
 *  draw one frame in animation from resource
 * PARAMETERS
 *  OFFSET_X       : [IN]        x position to draw image
 *  OFFSET_Y       : [IN]        y position to draw image
 *  IMAGE_PTR      : [IN]        image pointer
 *  FRAME_NO       : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_frames(
                    S32 x,
                    S32 y,
                    U8 *img_src,
                    U32 frame_pos);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_frames
 * DESCRIPTION
 *  draw one frame in animation from resource with specified dimension
 * PARAMETERS
 *  OFFSET_X       : [IN]        x position to draw image
 *  OFFSET_Y       : [IN]        y position to draw image
 *  RESIZED_WIDTH  : [IN]        image width to draw
 *  RESIZED_HEIGHT : [IN]        image height to draw
 *  IMAGE_PTR      : [IN]        image pointer
 *  FRAME_NO       : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_frames(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                IMAGE_PTR,                      \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                0,                              \
                                (U32) FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_id
 * DESCRIPTION
 *  draw image from resource with original image dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_ID          : [IN]        image resource id
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_id(
                    S32 x,
                    S32 y,
                    U16 image_id);
/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_id_frames
 * DESCRIPTION
 *  draw one frame in animation from resource
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_ID          : [IN]        image resource id 
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_id_frames(OFFSET_X,OFFSET_Y,IMAGE_ID,FRAME_NO) gdi_image_draw_frames(OFFSET_X,OFFSET_Y,(U8*) GetImage(IMAGE_ID),FRAME_NO)

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_id
 * DESCRIPTION
 *  draw image from resource with specified image dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_ID          : [IN]        image resource id 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_resized_id(
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    U16 image_id);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_id_with_transparent_color
 * DESCRIPTION
 *  draw image from resource, the transparent color will be drawn if image type is gif.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_ID          : [IN]        image resource id 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_id_with_transparent_color(OFFSET_X,OFFSET_Y,IMAGE_ID) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                (U8*) GetImage(IMAGE_ID),       \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                GDI_IMAGE_CODEC_FLAG_DISABLE_SRC_KEY,\
                                0)
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_id_with_transparent_color
 * DESCRIPTION
 *  draw image from resource, the transparent color will be drawn if image type is gif.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_ID          : [IN]        image resource id 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_id_with_transparent_color(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_ID) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                (U8*) GetImage(IMAGE_ID),       \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                              \
                                RESIZED_HEIGHT,                              \
                                GDI_IMAGE_CODEC_FLAG_DISABLE_SRC_KEY,\
                                0)

////////////////
// MEMORY
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_mem
 * DESCRIPTION
 *  draw image in memory with original image dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_mem(
                    S32 x,
                    S32 y,
                    U8 *img_src,
                    U8 img_type,
                    S32 img_size);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_mem
 * DESCRIPTION
 *  draw image in memory with specified dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_mem(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_LENGTH) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_MEMORY,      \
                                IMAGE_PTR,                      \
                                IMAGE_TYPE,                     \
                                IMAGE_LENGTH,                   \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                0,                              \
                                0)

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_mem_frames
 * DESCRIPTION
 *  draw one frame in animation in memory
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_mem_frames(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_LENGTH,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_MEMORY,      \
                                IMAGE_PTR,                      \
                                IMAGE_TYPE,                     \
                                IMAGE_LENGTH,                   \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                0,                              \
                                (U32)FRAME_NO)
                                
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_mem_frames
 * DESCRIPTION
 *  draw one frame in animation in memory with specified dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_mem_frames(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_LENGTH,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_MEMORY,      \
                                IMAGE_PTR,                      \
                                IMAGE_TYPE,                     \
                                IMAGE_LENGTH,                   \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                0,                              \
                                (U32)FRAME_NO)

////////////////
// FILE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_file
 * DESCRIPTION
 *  draw image from file with original image dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_NAME        : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_file(
                    S32 x,
                    S32 y,
                    S8 *img_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_file
 * DESCRIPTION
 *  draw image from file with specified dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_NAME        : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_resized_file(
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    S8 *img_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_file_frames
 * DESCRIPTION
 *  draw one frame in animation from file
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_NAME        : [IN]        image file name
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_file_frames(OFFSET_X,OFFSET_Y,IMAGE_NAME,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_FILE,        \
                                (U8*) IMAGE_NAME,               \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                0,                              \
                                (U32)FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_file_frames
 * DESCRIPTION
 *  draw one frame in animation from file with specified dimension
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_NAME        : [IN]        image file name
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_file_frames(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_NAME,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_FILE,        \
                                (U8*) IMAGE_NAME,               \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                0,                              \
                                (U32)FRAME_NO)

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_blend2layers
 * DESCRIPTION
 *  draw image from resource with original image dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_PTR         : [IN]        image pointer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_blend2layers(
                    S32 x,
                    S32 y,
                    U8 *img_src);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_blend2layers
 * DESCRIPTION
 *  draw image from resource with specified image dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_resized_blend2layers(
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    U8 *img_src);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation from resource
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X       : [IN]        x position to draw image
 *  OFFSET_Y       : [IN]        y position to draw image
 *  IMAGE_PTR      : [IN]        image pointer
 *  FRAME_NO       : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_frames_blend2layers(OFFSET_X,OFFSET_Y,IMAGE_PTR,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                IMAGE_PTR,                      \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                (U32) FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation from resource with specified dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X       : [IN]        x position to draw image
 *  OFFSET_Y       : [IN]        y position to draw image
 *  RESIZED_WIDTH  : [IN]        image width to draw
 *  RESIZED_HEIGHT : [IN]        image height to draw
 *  IMAGE_PTR      : [IN]        image pointer
 *  FRAME_NO       : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_frames_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                IMAGE_PTR,                      \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                (U32) FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_id_blend2layers
 * DESCRIPTION
 *  draw image from resource with original image dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_ID          : [IN]        image resource id
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_id_blend2layers(OFFSET_X,OFFSET_Y,IMAGE_ID)           gdi_image_draw_blend2layers(OFFSET_X,OFFSET_Y,(U8*) GetImage(IMAGE_ID))

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_id_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation from resource
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_ID          : [IN]        image resource id 
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_id_frames_blend2layers(OFFSET_X,OFFSET_Y,IMAGE_ID,FRAME_NO) gdi_image_draw_frames_blend2layers(OFFSET_X,OFFSET_Y,(U8*) GetImage(IMAGE_ID),FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_id_blend2layers
 * DESCRIPTION
 *  draw image from resource with specified image dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_ID          : [IN]        image resource id 
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_id_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_ID) \
                    gdi_image_draw_resized_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,(U8*) GetImage(IMAGE_ID))

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_mem_blend2layers
 * DESCRIPTION
 *  draw image in memory with original image dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_draw_mem_blend2layers(
                    S32 x,
                    S32 y,
                    U8 *img_src,
                    U8 img_type,
                    S32 img_size);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_mem_blend2layers
 * DESCRIPTION
 *  draw image in memory with specified dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_mem_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_LENGTH) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_MEMORY,      \
                                IMAGE_PTR,                      \
                                IMAGE_TYPE,                     \
                                IMAGE_LENGTH,                   \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                0)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_mem_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation in memory
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_mem_frames_blend2layers(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_LENGTH,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_MEMORY,      \
                                IMAGE_PTR,                      \
                                IMAGE_TYPE,                     \
                                IMAGE_LENGTH,                   \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                (U32)FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_mem_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation in memory with specified dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_mem_frames_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_LENGTH,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_MEMORY,      \
                                IMAGE_PTR,                      \
                                IMAGE_TYPE,                     \
                                IMAGE_LENGTH,                   \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                (U32)FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_file_blend2layers
 * DESCRIPTION
 *  draw image from file with original image dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_NAME        : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_file_blend2layers(OFFSET_X,OFFSET_Y,IMAGE_NAME) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_FILE,        \
                                (U8*) IMAGE_NAME,               \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                0)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_file_blend2layers
 * DESCRIPTION
 *  draw image from file with specified dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_NAME        : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_file_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_NAME) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_FILE,        \
                                (U8*) IMAGE_NAME,               \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                0)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_file_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation from file
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  IMAGE_NAME        : [IN]        image file name
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_file_frames_blend2layers(OFFSET_X,OFFSET_Y,IMAGE_NAME,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_FILE,        \
                                (U8*) IMAGE_NAME,               \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                0,                              \
                                0,                              \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                (U32)FRAME_NO)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_file_frames_blend2layers
 * DESCRIPTION
 *  draw one frame in animation from file with specified dimension
 *  When drawing png and abm image, 
 *  it use src layer color as alpha blending color only when the active layer color is transparent color.
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_NAME        : [IN]        image file name
 *  FRAME_NO          : [IN]        this is frame index to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_file_frames_blend2layers(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_NAME,FRAME_NO) \
                    gdi_image_codec_draw(                       \
                                GDI_IMAGE_SRC_FROM_FILE,        \
                                (U8*) IMAGE_NAME,               \
                                GDI_IMAGE_TYPE_INVALID,         \
                                0,                              \
                                OFFSET_X,                       \
                                OFFSET_Y,                       \
                                RESIZED_WIDTH,                  \
                                RESIZED_HEIGHT,                 \
                                GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,                              \
                                (U32)FRAME_NO)
                                
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_delay
 * DESCRIPTION
 *  get frame delay of each frame of an animation from memory
 * PARAMETERS
 *  image_ptr        : [IN]       image data pointer
 *  frame_count      : [OUT]      number of frames in image
 *  frame_delay_array[OUT]      delay time of each frame
 *  max_frame_count  : [IN]       the size of frame_delay_array
 * RETURNS
 *  U16, frame delay
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_delay(U8 *image_ptr, S32 *frame_count, U32 *frame_delay_array, U32 max_frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_delay_file
 * DESCRIPTION
 *  get frame delay of each frame of an animation from file
 * PARAMETERS
 *  image_ptr        : [IN]       image file name
 *  frame_count      : [OUT]      number of frames in image
 *  frame_delay_array[OUT]      delay time of each frame
 *  max_frame_count  : [IN]       the size of frame_delay_array
 * RETURNS
 *  U16, frame delay
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_delay_file(U8 *image_ptr, S32 *frame_count, U32 *frame_delay_array, U32 max_frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_delay_id
 * DESCRIPTION
 *  get frame delay of each frame of an animation from image id
 * PARAMETERS
 *  image_id         : [IN]       the resource id of image
 *  frame_count      : [OUT]      number of frames in image
 *  frame_delay_array[OUT]      delay time of each frame
 *  max_frame_count  : [IN]       the size of frame_delay_array
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_delay_id(U16 image_id, S32 *frame_count, U32 *frame_delay_array, U32 max_frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_codec_get_frame_delay
 * DESCRIPTION
 *  get frame delay of each frame of an animation from memory
 * PARAMETERS
 *  src_type                : [IN]    resource, or file, or memory. ex.GDI_IMAGE_SRC_FROM_RESOURCE...
 *  img_src                 : [IN]    image pointer, if src_type is file, img_src is file name
 *  img_type                : [IN]    if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  img_size                : [IN]    if img_src is memory, this is size of img_src
 *  frame_count             : [OUT]   return the frame count
 *  frame_delay_array       : [OUT]   return frame delay time of each frame
 *  max_frame_count         : [IN]    frame delay array size
 *  flag                    : [IN]    flags defined in gdi_image_codec_flag_enum
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_codec_get_frame_delay(
            gdi_image_src_enum src_type,
            U8 *img_src,
            U8 img_type,
            S32 img_size,
            S32 *frame_count,
            U32 *frame_delay_array, 
            U32 max_frame_count,
            U32 flag);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_count
 * DESCRIPTION
 *  get frame count of an animation from resource
 * PARAMETERS
 *  image_ptr       : [IN]        image pointer from resource
 *  frame_count     : [OUT]       return the frame count in this image
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_count(U8 *image_ptr, S32 *frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_count_id
 * DESCRIPTION
 *  get frame count of an animation from id
 * PARAMETERS
 *  image_id        : [IN]        image resource id
 *  frame_count     : [OUT]       return the frame count in this image
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_count_id(U16 image_id, S32 *frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_count_file
 * DESCRIPTION
 *  get frame count of an animation from file
 * PARAMETERS
 *  image_ptr       : [IN]        image file name
 *  frame_count     : [OUT]       return the frame count in this image
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_count_file(U8 *image_ptr, S32 *frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_frame_count_mem
 * DESCRIPTION
 *  get frame count of an animation from memory
 * PARAMETERS
 *  image_type      [IN]        image type, ex.GDI_IMAGE_TYPE_GIF
 *  image_ptr       [IN]        image pointer
 *  image_size      [IN]        image size
 *  frame_count     [OUT]       return the frame count in this image
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_frame_count_mem(
            U8  image_type,
            U8  *image_ptr,
            S32 image_size,
            S32 *frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_dimension
 * DESCRIPTION
 *  get image dimension from resource
 * PARAMETERS
 *  image_ptr       : [IN]        image pointer
 *  width           : [OUT]       return image width
 *  height          : [OUT]       return image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_dimension(U8 *image_ptr, S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_dimension_id
 * DESCRIPTION
 *  get image dimension from resource
 * PARAMETERS
 *  image_id        : [IN]        image resource id
 *  width           : [OUT]       return image width
 *  height          : [OUT]       return image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_dimension_id(U16 image_id, S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_dimension_file
 * DESCRIPTION
 *  get image dimension from a file
 * PARAMETERS
 *  image_name      : [IN]        image file name
 *  width           : [OUT]       return image width
 *  height          : [OUT]       return image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_dimension_file(S8 *image_name, S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_dimension_mem
 * DESCRIPTION
 *  get image dimension from memory
 * PARAMETERS
 *  image_ptr       : [IN]        image pointer
 *  width           : [OUT]       return image width
 *  height          : [OUT]       return image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_get_dimension_mem(U8 img_type,U8 *img_ptr,S32 img_size,S32 *width, S32 *height);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_type_from_file
 * DESCRIPTION
 *  get image type from file
 * PARAMETERS
 *  file_name       : [IN]    image file name
 * RETURNS
 *  U16, image type, ex. GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *****************************************************************************/
extern U16 gdi_image_get_type_from_file(S8 *file_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_type_from_mem
 * DESCRIPTION
 *  get image type from memory
 * PARAMETERS
 *  ptr        : [IN]        image pointer
 * RETURNS
 *  U16, image type, ex. GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *****************************************************************************/
extern U16 gdi_image_get_type_from_mem(PS8 ptr);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_buf_type
 * DESCRIPTION
 *  get image type from resource
 * PARAMETERS
 *  image_ptr       : [IN]    resource image pointer
 * RETURNS
 *  U16, image type, ex. GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *****************************************************************************/
extern U16 gdi_image_get_buf_type(U8 * image_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_buf_len
 * DESCRIPTION
 *  get image size from resource
 * PARAMETERS
 *  res_src       : [IN]  resource image pointer
 * RETURNS
 *  S32, image size
 *****************************************************************************/
extern S32 gdi_image_get_buf_len(U8* image);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_buf_ptr
 * DESCRIPTION
 *  get image pointer(no resource image header)
 * PARAMETERS
 *  res_src       : [IN]  resource image pointer
 * RETURNS
 *  U8*, image pointer without resource image header
 *****************************************************************************/
extern U8 *gdi_image_get_buf_ptr(U8* image);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_buf_len_from_id
 * DESCRIPTION
 *  get image size from resource
 * PARAMETERS
 *  ID       : [IN]  image resource id
 * RETURNS
 *  S32, image size
 *****************************************************************************/
#define gdi_image_get_buf_len_from_id(ID) gdi_image_get_buf_len((U8*)GetImage(ID))

/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_buf_ptr_from_id
 * DESCRIPTION
 *  get image pointer(no resource image header)
 * PARAMETERS
 *  ID       : [IN]  image resource id
 * RETURNS
 *  U8*, image pointer without resource image header
 *****************************************************************************/
#define gdi_image_get_buf_ptr_from_id(ID) gdi_image_get_buf_ptr((U8*)GetImage(ID))

/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_type_from_id
 * DESCRIPTION
 *  get image type from resource
 * PARAMETERS
 *  ID       : [IN]  image resource id
 * RETURNS
 *  U16, image type, ex. GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *****************************************************************************/
#define gdi_image_get_type_from_id(ID)    gdi_image_get_buf_type((U8*)GetImage(ID))

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_util_fit_bbox
 * DESCRIPTION
 *  resize a given source rectangle to a bounding box
 * PARAMETERS
 *  bbox_width      : [IN]        width of bounding box
 *  bbox_height     : [IN]        height of bounding box
 *  src_width       : [IN]        width of source rectangle
 *  src_height      : [IN]        height of source rectangle
 *  offset_x        : [OUT]       offset x in bounding box of source rectangle
 *  offset_y        : [OUT]       offset y in bounding box of source rectangle  
 *  dest_width      : [OUT]       width of source rectangle after resize
 *  dest_height     : [OUT]       height of source rectangle after resize  
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_util_fit_bbox(
                S32 bbox_width,
                S32 bbox_height,
                S32 src_width,
                S32 src_height,
                S32 *offset_x,
                S32 *offset_y,
                S32 *dest_width,
                S32 *dest_height);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_util_fit_box
 * DESCRIPTION
 *  return dest image position and dimension given a bounding  box
 *  four fit modes:
 *      GDI_UTIL_MODE_LONG_SIDE_FIT, 
 *      GDI_UTIL_MODE_SHORT_SIDE_FIT,
 *      GDI_UTIL_MODE_NO_RESIZE_OR_LONG_SIDE_FIT,
 *      GDI_UTIL_MODE_NO_RESIZE_OR_SHORT_SIDE_FIT,
 *  LONG_SIDE_FIT: return the max size smaller than the bounding box
 *  SHORT_SIDE_FIT:return the min size larger than bounding box
 *  NO_RESIZE:     if the dest size is smaller than src size, return the original size
 * PARAMETERS
 *  mode            : [IN]     fit box mode, ex.GDI_UTIL_MODE_LONG_SIDE_FIT...
 *  bbox_width      : [IN]     bounding box width
 *  bbox_height     : [IN]     bounding box height   
 *  src_width       : [IN]     source image width
 *  src_height      : [IN]     source image height
 *  offset_x        : [OUT]    return offset x of dest box in bounding box
 *  offset_y        : [OUT]    return offset y of dest box in bounding box    
 *  dest_width      : [OUT]    return width of dest box in bounding box
 *  dest_height     : [OUT]    return height of dest box in bounding box    
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_util_fit_box(
                S32 mode,
                S32 bbox_width,
                S32 bbox_height,
                S32 src_width,
                S32 src_height,
                S32 *offset_x,
                S32 *offset_y,
                S32 *dest_width,
                S32 *dest_height);
/*****************************************************************************
 * FUNCTION
 *  gdi_resize_bitblt
 * DESCRIPTION
 *  software layer resizer.
 *  resize src_layer and output to active layer
 * PARAMETERS
 *  src_layer_handle       : [IN]     layer to resize
 *  sx1                    : [IN]     x of left-top cornor of resize region
 *  sy1                    : [IN]     y of left-top cornor of resize region
 *  sx2                    : [IN]     x of right-down cornor of resize region
 *  sy2                    : [IN]     y of right-down cornor of resize region
 *  dx1                    : [IN]     x of left-top cornor of output region
 *  dy1                    : [IN]     y of left-top cornor of output region
 *  dx2                    : [IN]     x of right-down cornor of output region
 *  dy2                    : [IN]     y of right-down cornor of output region
 * RETURNS
 *  void
 *****************************************************************************/
extern GDI_RESULT gdi_resize_bitblt(gdi_handle src_layer, S32 sx1,S32 sy1,S32 sx2,S32 sy2,S32 dx1,S32 dy1,S32 dx2,S32 dy2);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_util_check_decoder_cap
 * DESCRIPTION
 *  check gdi decoder's capability
 * PARAMETERS
 *  image_type          : [IN]        image type
 *  image_width         : [IN]        not used
 *  image_height        : [IN]        not used
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_util_check_decoder_cap(U16 image_type, S32 image_width, S32 image_height);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_cache_bmp_get
 * DESCRIPTION
 *  cache a region from a layer
 * PARAMETERS
 *  x1          : [IN]    left-up cornor x of destination region
 *  y1          : [IN]    left-up cornor y of destination region
 *  x2          : [IN]    right-down cornor x of destination region
 *  y2          : [IN]    right-down cornor y of destination region
 *  bmp_ptr     : [OUT]   return width, height, and pointer to cached region
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_cache_bmp_get(S32 x1, S32 y1, S32 x2, S32 y2, gdi_image_cache_bmp_struct *bmp_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_cache_bmp_draw
 * DESCRIPTION
 *  draw cached image to a layer
 * PARAMETERS
 *  offset_x        : [IN]    position of layer want to draw to
 *  offset_y        : [IN]    position of layer want to draw to 
 *  bmp_ptr         : [IN]    the bmp want to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_cache_bmp_draw(S32 offset_x, S32 offset_y, gdi_image_cache_bmp_struct *bmp_ptr);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_set_encoding_flag
 * DESCRIPTION
 *  set JPEG encoding flag
 * PARAMETERS
 *  flag       : [IN] GDI_IMAGE_ENCODING_FLAG_JPEG_YUV_440,442,GRAY
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_set_encoding_flag(U32 flag);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_layer_to_jpeg
 * DESCRIPTION
 *  encode the layer content to a jpeg file
 * PARAMETERS
 *  layer_handle       : [IN]     layer to encode
 *  file_name          : [IN]     save jpeg file with this filename
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_encode_layer_to_jpeg(gdi_handle layer_handle, PS8 file_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_file_to_jpeg
 * DESCRIPTION
 *  encode a image file content to a jpeg file
 * PARAMETERS
 *  src_file_name       : [IN]         source file name
 *  dest_file_name      : [IN]         destination file name
 *  dest_width          : [IN]         destination file width
 *  dest_height         : [IN]         destination file height
 *  buf_ptr             : [IN]         tmp buffer pointer
 *  buf_size            : [IN]         tmp buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_encode_file_to_jpeg(
                    S8 *src_file_name,
                    S8 *dest_file_name,
                    S32 dest_width,
                    S32 dest_height,
                    U8 *buf_ptr,
                    S32 buf_size);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_layer_to_jpeg_with_exp_size
 * DESCRIPTION
 *  encode a layer to jpeg file.
 *  This API can assign a expected encode size of the output jpeg file.
 * PARAMETERS
 *  layer_handle               : [IN]     layer to encode
 *  file_name                  : [IN]     output file name
 *  expected_encode_size       : [IN]     expected encode size of output jpeg file
 *  encode_file_size           : [OUT]    actual encode size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_encode_layer_to_jpeg_with_exp_size(
                gdi_handle layer_handle, 
                PS8 file_name,
                S32 expected_encode_size,
                S32 *encode_file_size);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_buffer_to_jpeg_with_exp_size
 * DESCRIPTION
 *  encode a buffer to jpeg file.
 *  This API can assign a expected encode size of the output jpeg file.
 * PARAMETERS
 *  buf_ptr                     : [IN] butter to encode
 *  width                       : [IN] butter width
 *  buf_ptr                     : [IN] butter height
 *  cf                          : [IN] butter color format
 *  file_name                   : [IN] output file name
 *  expected_encode_size        : [IN] expected encode size of output jpeg file
 *  encode_file_size            : [OUT] actual encode size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
GDI_RESULT gdi_image_encode_buffer_to_jpeg_with_exp_size(
            U8* buf_ptr,
            S32 width,
            S32 height,
            U8 cf,
            PS8 file_name,
            S32 expected_encode_size,
            S32 *encode_file_size,
            kal_bool is_force_sw);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_file_to_jpeg
 * DESCRIPTION
 *  encode a image file content to a jpeg file
 *  This API can assign a expected encode size of the output jpeg file.
 * PARAMETERS
 *  src_file_name           : [IN]         source file name
 *  dest_file_name          : [IN]         destination file name
 *  dest_width              : [IN]         destination file width
 *  dest_height             : [IN]         destination file height
 *  buf_ptr                 : [IN]         tmp buffer pointer
 *  buf_size                : [IN]         tmp buffer size
 *  expected_encode_size    : [IN]     expected encode size of output jpeg file
 *  encode_file_size        : [OUT]    actual encode size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_encode_file_to_jpeg_with_exp_size(
                S8 *src_file_name,
                S8 *dest_file_name,
                S32 dest_width,
                S32 dest_height,
                U8 *buf_ptr,
                S32 buf_size,
                S32 expected_encode_size,
                S32 *encode_file_size);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_buffer_to_jpeg_in_memory
 * DESCRIPTION
 *  encode a buffer to jpeg format, output data to a memory buffer.
 * PARAMETERS
 *  buf_ptr             : [IN] butter to encode
 *  width               : [IN] butter width
 *  buf_ptr             : [IN] butter height
 *  cf                  : [IN] butter color format
 *  output_mem          : [IN] output memory buffer pointer
 *  output_mem_size     : [IN] output memory buffer size
 *  encode_data_size    : [OUT]  result jpeg data size
 *  quality:  [IN] JPEG quality to encode
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_image_encode_buffer_to_jpeg_in_memory(
                U8* buf_ptr,
                S32 width,
                S32 height,
                U8 cf,
                U8  *output_mem,
                S32 output_mem_size,
                S32 *encode_data_size,
                gdi_jpeg_encode_quality_enum quality);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_layer_to_jpeg_in_memory
 * DESCRIPTION
 *  encode a layer to jpeg format, output data to a memory buffer.
 * PARAMETERS
 *  layer_handle        [IN]    the layer you want to encode to jpeg format
 *  output_mem          [IN]    output memory buffer pointer
 *  output_mem_size     [IN]    output memory buffer size
 *  encode_data_size    [OUT]   result jpeg data size
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
 #define gdi_image_encode_layer_to_jpeg_in_memory(layer_handle,output_mem,output_mem_size,encode_data_size) \
                          gdi_image_encode_layer_to_jpeg_in_memory_ext(               \
                                    layer_handle,        \
                                    output_mem,              \
                                    output_mem_size,         \
                                    encode_data_size,                              \
                                    GDI_JPEG_ENCODE_QUALITY_EXCELLENT)


/*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_layer_to_jpeg_in_memory_with_quality
 * DESCRIPTION
 *  encode a layer to jpeg format, output data to a memory buffer.
 * PARAMETERS
 *  layer_handle        [IN]    the layer you want to encode to jpeg format
 *  output_mem          [IN]    output memory buffer pointer
 *  output_mem_size     [IN]    output memory buffer size
 *  encode_data_size    [OUT]   result jpeg data size
 *  quality        [IN]    the quality you want to encode to jpeg format
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
 #define gdi_image_encode_layer_to_jpeg_in_memory_with_quality(layer_handle,output_mem,output_mem_size,encode_data_size, quality) \
                          gdi_image_encode_layer_to_jpeg_in_memory_ext(               \
                                    layer_handle,        \
                                    output_mem,              \
                                    output_mem_size,         \
                                    encode_data_size,                              \
                                    quality)

 
 /*****************************************************************************
 * FUNCTION
 *  gdi_image_encode_layer_to_jpeg_in_memory
 * DESCRIPTION
 *  encode a layer to jpeg format, output data to a memory buffer.
 * PARAMETERS
 *  layer_handle        [IN]    the layer you want to encode to jpeg format
 *  output_mem          [IN]    output memory buffer pointer
 *  output_mem_size     [IN]    output memory buffer size
 *  encode_data_size    [OUT]   result jpeg data size
 *  quality        [IN]    the quality you want to encode to jpeg format
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_image_encode_layer_to_jpeg_in_memory_ext(
                gdi_handle layer_handle, 
                U8  *output_mem,
                S32 output_mem_size,
                S32 *encode_data_size,
                gdi_jpeg_encode_quality_enum quality);


/*****************************************************************************
 * FUNCTION
 *  gdi_image_bmp_encode_get_size
 * DESCRIPTION
 *  get the buffer size needed when bmp encode
 * PARAMETERS
 *  width           [IN]    encode width
 *  height          [IN]    encode height
 *  depth           [IN]    bits per pixel
 *  bmp_size        [OUT]   the buffer size needed when bmp encode
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_image_bmp_encode_get_size(S32 width, S32 height, U8  depth, S32 *bmp_size);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_bmp_encode_mem
 * DESCRIPTION
 *  encode layer data to memory
 * PARAMETERS
 *  width           [IN]    encode width
 *  height          [IN]    encode height
 *  depth           [IN]    bits per pixel
 *  buf_ptr         [IN]    source memory address
 *  output_mem          [IN]    output memory buffer pointer
 *  output_mem_size     [IN]    output memory buffer size
 *  encode_data_size    [OUT]   result bmp data size
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
 extern GDI_RESULT gdi_image_bmp_encode_mem(S32 width, S32 height, U8  depth, PU8 buf_ptr, U8  *output_mem, S32 output_mem_size, S32 *encode_data_size);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_bmp_encode_file
 * DESCRIPTION
 *  encode bmp file
 * PARAMETERS
 *  width           : [IN]    encode width
 *  height          : [IN]    encode height
 *  cf              : [IN]    color format
 *  buf_ptr         : [IN]    source memory address
 *  file_name       : [IN]    output filename
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_bmp_encode_file(S32 width, S32 height, gdi_color_format cf, PU8 buf_ptr, PS8 file_name);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_output_another_buffer
 * DESCRIPTION
 *  set memory output buffer of jpeg
 * PARAMETERS
 *  enable      : [IN]        enable output to another memory buffer
 *  src         : [IN]        output buffer
 *  size        : [IN]        output buffer size
 *  width       : [IN]        output buffer width
 *  height      : [IN]        output buffer height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_output_another_buffer(BOOL enable, U8 *src, U32 size, U16 width, U16 height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_clear_work_buffer
 * DESCRIPTION
 *  clear work buffer to zero
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_clear_work_buffer(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_codec_set_flag_begin
 * DESCRIPTION
 *  Do "or" to the new flag and original flag, and push the result to flag stack.
 *  This API need appear in a pair with gdi_image_codec_set_flag_end.
 * PARAMETERS
 *  flag    : [IN]    the new flag
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_codec_set_flag_begin(U32 flag);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_codec_set_flag_end
 * DESCRIPTION
 *  pop the flag stack
 *  This API need appear in a pair with gdi_image_codec_set_flag_begin.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_codec_set_flag_end(void);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_cache_reset
 * DESCRIPTION
 *  clear gif cache
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_cache_reset(void);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_cache_reset_entry
 * DESCRIPTION
 *  reset the entry of a gif resource in gif cache
 * PARAMETERS
 *  src        : [IN]     gif image
 *  size       : [IN]     gif image size
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_cache_reset_entry(U8* src,U32 size);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_set_progress_callback
 * DESCRIPTION
 *  set the progress callback function
 * PARAMETERS
 *  ptr       : [IN]  the progress callback function
 *  arg       : [IN]  the first parameter of callback funciton "ptr"
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_set_progress_callback(void (*ptr)(void *,S32,S32,S32,S32),void* arg);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_progress_callback
 * DESCRIPTION
 *  Called in decoder. 
 *  Used to force abort non-blocking decode and stop decode if decode timeout.
 *  If gdi_image_progress_callback_ptr is registered, 
 *  it will call gdi_image_progress_callback_ptr to progressively blt image.
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 * RETURN VALUES
 *  0 : if decoder need to be force abort or timeout
 *  1 : otherwise
 *****************************************************************************/
extern S32  gdi_image_progress_callback(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_set_update_area
 * DESCRIPTION
 *  set update area.
 *  This update area is used in gdi_image_progress_callback to progressive blt image.
 * PARAMETERS
 *  x1                 : [OUT]    the x position of left-up corner of the region
 *  y1                 : [OUT]    the y position of left-up corner of the region
 *  x2                 : [OUT]    the x position of right-down corner of the region
 *  y2                 : [OUT]    the y position of right-down corner of the region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_set_update_area(S32 x1,S32 y1,S32 x2,S32 y2);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_get_update_area
 * DESCRIPTION
 *  get the update area
 *  This update area is used in gdi_image_progress_callback to progressive blt image.
 * PARAMETERS
 *  x1                 : [OUT]    the x position of left-up corner of the region
 *  y1                 : [OUT]    the y position of left-up corner of the region
 *  x2                 : [OUT]    the x position of right-down corner of the region
 *  y2                 : [OUT]    the y position of right-down corner of the region
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_get_update_area(S32 *x1,S32 *y1,S32 *x2,S32 *y2);
extern MMI_BOOL gdi_image_check_image_file_valid(S8 *filepath);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ANIMATION API
///////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_codec_draw_internal
 * DESCRIPTION
 *  play a animation
 * PARAMETERS
 *  src_type         : [IN]        resource, or file, or memory. ex.GDI_IMAGE_SRC_FROM_RESOURCE...
 *  img_src          : [IN]        image pointer, if src_type is file, img_src is file name
 *  img_type         : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  img_size         : [IN]        if img_src is memory, this is size of img_src
 *  x                : [IN]        x position to draw animtaion
 *  y                : [IN]        y position to draw animtaion
 *  w                : [IN]        animtaion width to draw
 *  h                : [IN]        animtaion height to draw
 *  flag             : [IN]        flags defined in gdi_image_codec_flag_enum
 *  handle_ptr       : [OUT]       return the animation handle
 *  frame_pos        : [IN]        the start frame of this animation
 *  anim_count       : [IN]        the loop count of animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_codec_draw_internal(
                    gdi_image_src_enum src_type,
                    U8 *img_src,
                    U8 img_type,
                    S32 img_size,
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    U32 flag,
                    gdi_handle *handle_ptr,
                    U32 frame_pos,
                    S32 draw_count);

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_count
 * DESCRIPTION
 *  set the loop count of animation
 *  When calling gdi_anim_codec_draw_internal, if the anim_count<0,
 *  it will use this loop count.
 * PARAMETERS
 *  count       : [IN]    loop count
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_anim_set_count(S32 count);
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_get_count
 * DESCRIPTION
 *  get the loop count of animation from resource
 * PARAMETERS
 *  res_src       : [IN]  resource pointer
 * RETURNS
 *  S32, the loop count of animation
 *****************************************************************************/
extern S32 gdi_anim_get_count(U8* res_src);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_last_frame_callback
 * DESCRIPTION
 *  set the "last frame callback function".
 *  The function will be called after drawing the last frame of animation
 * PARAMETERS
 *  callback_ptr       : [IN]     last frame callback function
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_last_frame_callback(void (*callback_ptr) (GDI_RESULT result));

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_stop_all
 * DESCRIPTION
 *  stop all animation
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_stop_all(void);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_stop
 * DESCRIPTION
 *  stop a animation by handle
 * PARAMETERS
 *  serial_handle       : [IN]    the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_stop(gdi_handle a_handle);

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_get_frame_delay
 * DESCRIPTION
 *  Get the delay time of current frame. This delay is the exact data recorded
 *  in image.
 * PARAMETERS
 *  void
 * RETURNS
 *  U32, the current animation delay time
 *****************************************************************************/
extern U32 gdi_anim_get_frame_delay(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_get_delay
 * DESCRIPTION
 *  Get the delay time of anim's current playing frame. This delay time equals
 *  to delay data of frame subtract the decode time of this frame.
 * PARAMETERS
 *  void
 * RETURNS
 *  U32, the current animation delay time
 *****************************************************************************/
extern U32 gdi_anim_get_delay(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_draw_before_callback
 * DESCRIPTION
 *  set the "animation draw before callback function".
 *  The function will be called everye time before drawing each frame of animation
 * PARAMETERS
 *  callback_ptr       : [IN] animation draw before callback function
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_draw_before_callback(void (*callback_ptr)(GDI_RESULT result));
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_draw_after_callback
 * DESCRIPTION
 *  set the "animation draw after callback function".
 *  The function will be called everye time after drawing each frame of animation
 * PARAMETERS
 *  callback_ptr       : [IN] animation draw after callback function
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_draw_after_callback(void (*callback_ptr)(GDI_RESULT result));
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_blt_before_callback
 * DESCRIPTION
 *  set the "animation blt before callback function".
 *  The function will be called everye time before blt each frame of animation
 * PARAMETERS
 *  callback_ptr       : [IN] animation blt before callback function
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_blt_before_callback(void (*callback_ptr)(GDI_RESULT result));
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_blt_after_callback
 * DESCRIPTION
 *  set the "animation blt after callback function".
 *  The function will be called everye time after blt each frame of animation
 * PARAMETERS
 *  callback_ptr       : [IN] animation blt after callback function
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_blt_after_callback(void (*callback_ptr)(GDI_RESULT result));

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_disable_blt
 * DESCRIPTION
 *  disable blt animation.
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_disable_blt(void);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_stop_all_by_layer
 * DESCRIPTION
 *  stop all animation in spec layer
 * PARAMETERS
 *  layer       : [IN]
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_stop_all_by_layer(gdi_handle layer);

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_resume_all
 * DESCRIPTION
 *  resume all animation in animation list
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_resume_all(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_pause_all
 * DESCRIPTION
 *  pause all animation in animation list
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_pause_all(void);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_resume
 * DESCRIPTION
 *  If the animation is paused, let it play continuely.
 * PARAMETERS
 *  a_handle       : [IN]     animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_resume(gdi_handle a_handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_pause
 * DESCRIPTION
 *  Pause the animation. It will stop at current frame, and still can resume it.
 * PARAMETERS
 *  a_handle       : [IN]     animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_pause(gdi_handle a_handle);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_get_min_delay_time
 * DESCRIPTION
 *  get anim min delay time
 * PARAMETERS
 *  enable_min_delay_time   : [OUT]   enable min delay time
 *  min_delay_time          : [OUT]   min delay time
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_get_min_delay_time(BOOL *enable_min_delay_time, U32 *min_delay_time);
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_set_min_delay_time
 * DESCRIPTION
 *  set anim min delay time
 * PARAMETERS
 *  min_delay_time          : [IN]    min delay time
 *  enable_min_delay_time   : [IN]    enable min delay time
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_set_min_delay_time(BOOL enable_min_delay_time, U32 min_delay_time);    

////////////////
// RESOURCE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_id
 * DESCRIPTION
 *  play a animation from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  MMI_ID_TYPE      : [IN]        resource id
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_id(OFFSET_X,OFFSET_Y,MMI_ID_TYPE,HANDLE_PTR)       \
            gdi_anim_codec_draw_internal(                                \
                     GDI_IMAGE_SRC_FROM_RESOURCE,                        \
                     (U8*)GetImage(MMI_ID_TYPE),GDI_IMAGE_TYPE_INVALID,0,\
                     OFFSET_X,OFFSET_Y,                                  \
                     0,0,/* resized width,height */                        \
                     0,/* flag */                                          \
                     HANDLE_PTR,                                         \
                     0,/* start_frame */                                   \
                     -1)/* is_draw_once */                              \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_id_blend2layers
 * DESCRIPTION
 *  play a animation from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  MMI_ID_TYPE      : [IN]        resource id
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_id_blend2layers(OFFSET_X,OFFSET_Y,MMI_ID_TYPE,HANDLE_PTR)       \
            gdi_anim_codec_draw_internal(                                \
                     GDI_IMAGE_SRC_FROM_RESOURCE,                        \
                     (U8*)GetImage(MMI_ID_TYPE),GDI_IMAGE_TYPE_INVALID,0,\
                     OFFSET_X,OFFSET_Y,                                  \
                     0,0,/* resized width,height */                        \
                     GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS,/* flag */                                          \
                     HANDLE_PTR,                                         \
                     0,/* start_frame */                                   \
                     -1)/* is_draw_once */ 


/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_id_once
 * DESCRIPTION
 *  play a animation once frome resource 
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  MMI_ID_TYPE      : [IN]        resource id
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_id_once(OFFSET_X,OFFSET_Y,MMI_ID_TYPE, HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                                \
                     GDI_IMAGE_SRC_FROM_RESOURCE,                        \
                     (U8*)GetImage(MMI_ID_TYPE),GDI_IMAGE_TYPE_INVALID,0,\
                     OFFSET_X,OFFSET_Y,                                  \
                     0,0,/* resized width,height */                        \
                     0,/* flag */                                          \
                     HANDLE_PTR,                                         \
                     0,/* start_frame */                                   \
                     1)/* is_draw_once */                               \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_frames
 * DESCRIPTION
 *  play a animation from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer
 *  HANDLE_PTR       : [OUT]       return the animation handle
 *  START_FRAME      : [IN]        the start frame of this animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_frames(OFFSET_X,OFFSET_Y,IMAGE_PTR,HANDLE_PTR,START_FRAME) \
            gdi_anim_codec_draw_internal(                                        \
                     GDI_IMAGE_SRC_FROM_RESOURCE,                                \
                     (U8*)IMAGE_PTR,GDI_IMAGE_TYPE_INVALID,0,                    \
                     OFFSET_X,OFFSET_Y,                                          \
                     0,0,/* resized width,height */                                \
                     0,/* flag */                                                  \
                     HANDLE_PTR,                                                 \
                     START_FRAME,/* start_frame */                                 \
                     -1)/* is_draw_once */                                      \

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_resized_frames
 * DESCRIPTION
 *  play resized animation from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  RESIZED_W        : [IN]        animtaion width to draw
 *  RESIZED_H        : [IN]        animtaion height to draw
 *  IMAGE_PTR        : [IN]        image pointer, if src_type is file, img_src is file name
 *  HANDLE_PTR       : [OUT]       return the animation handle
 *  START_FRAME      : [IN]        the start frame of this animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_resized_frames(OFFSET_X,OFFSET_Y,RESIZED_W,RESIZED_H,IMAGE_PTR,HANDLE_PTR,START_FRAME) \
            gdi_anim_codec_draw_internal(                                        \
                     GDI_IMAGE_SRC_FROM_RESOURCE,                                \
                     (U8*)IMAGE_PTR,GDI_IMAGE_TYPE_INVALID,0,                    \
                     OFFSET_X,OFFSET_Y,                                          \
                     RESIZED_W,RESIZED_H,/* resized width,height */                         \
                     0,/* flag */                                                  \
                     HANDLE_PTR,                                                 \
                     START_FRAME,/* start_frame */                                 \
                     -1)/* is_draw_once */                                      \

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw
 * DESCRIPTION
 *  play a animation from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_draw(
                    S32 x, S32 y,
                    U8* img_src,
                    gdi_handle * handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_resized
 * DESCRIPTION
 *  play a animation from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion 
 *  RESIZED_W        : [IN]        animtaion width to draw
 *  RESIZED_H        : [IN]        animtaion height to draw
 *  IMAGE_PTR        : [IN]        image pointer
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_anim_draw_resized(
                    S32 x, S32 y,
                    S32 w, S32 h,
                    U8* img_src,
                    gdi_handle * handle_ptr);
/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_once
 * DESCRIPTION
 *  play a animation once from resource
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_once(OFFSET_X,OFFSET_Y,IMAGE_PTR,HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                          \
                     GDI_IMAGE_SRC_FROM_RESOURCE,                  \
                     (U8*)IMAGE_PTR,GDI_IMAGE_TYPE_INVALID,0,      \
                     OFFSET_X,OFFSET_Y,                            \
                     0,0,/* resized width,height */                  \
                     0,/* flag */                                    \
                     HANDLE_PTR,                                   \
                     0,/* start_frame */                             \
                     1)/* is_draw_once */                         \

////////////////
// FILE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_file
 * DESCRIPTION
 *  play a animation from file
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_NAME       : [IN]        image file name
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_file(OFFSET_X,OFFSET_Y,IMAGE_NAME,HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                           \
                     GDI_IMAGE_SRC_FROM_FILE,                       \
                     (U8*)IMAGE_NAME,GDI_IMAGE_TYPE_INVALID,0,      \
                     OFFSET_X,OFFSET_Y,                             \
                     0,0,/* resized width,height */                   \
                     0,/* flag */                                     \
                     HANDLE_PTR,                                    \
                     0,/* start_frame */                              \
                     -1)/* is_draw_once */                         \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_file_resized
 * DESCRIPTION
 *  play a animation from file
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion 
 *  RESIZED_W        : [IN]        animtaion width to draw
 *  RESIZED_H        : [IN]        animtaion height to draw
 *  IMAGE_NAME       : [IN]        image file name
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_file_resized(OFFSET_X,OFFSET_Y,RESIZED_W,RESIZED_H,IMAGE_NAME,HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                                                       \
                     GDI_IMAGE_SRC_FROM_FILE,                                                   \
                     (U8*)IMAGE_NAME,GDI_IMAGE_TYPE_INVALID,0,                                  \
                     OFFSET_X,OFFSET_Y,                                                         \
                     RESIZED_W,RESIZED_H,/* resized width,height */                               \
                     0,/* flag */                                                                 \
                     HANDLE_PTR,                                                                \
                     0,/* start_frame */                                                          \
                     -1)/* is_draw_once */                                                     \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_frames
 * DESCRIPTION
 *  play a animation from file
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_NAME       : [IN]        image file name
 *  HANDLE_PTR       : [OUT]       return the animation handle
 *  START_FRAME      : [IN]        the start frame of this animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_file_frames(OFFSET_X,OFFSET_Y,IMAGE_NAME,HANDLE_PTR,START_FRAME) \
            gdi_anim_codec_draw_internal(                                              \
                     GDI_IMAGE_SRC_FROM_FILE,                                          \
                     (U8*)IMAGE_NAME,GDI_IMAGE_TYPE_INVALID,0,                         \
                     OFFSET_X,OFFSET_Y,                                                \
                     0,0,/* resized width,height */                                      \
                     0,/* flag */                                                        \
                     HANDLE_PTR,                                                       \
                     START_FRAME,/* start_frame */                                       \
                     -1)/* is_draw_once */                                            \

////////////////
// Memory
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_mem
 * DESCRIPTION
 *  play a animation from memory
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer, if src_type is file, img_src is file name
 *  IMAGE_TYPE       : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  IMAGE_SIZE       : [IN]        if img_src is memory, this is size of img_src
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_mem(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                                               \
                     GDI_IMAGE_SRC_FROM_MEMORY,                                         \
                     (U8*)IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,                              \
                     OFFSET_X,OFFSET_Y,                                                 \
                     0,0,/* resized width,height */                                       \
                     0,/* flag */                                                         \
                     HANDLE_PTR,                                                        \
                     0,/* start_frame */                                                  \
                     -1)/* is_draw_once */                                             \

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_mem_frames
 * DESCRIPTION
 *  play a animation in memory
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer, if src_type is file, img_src is file name
 *  IMAGE_TYPE       : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  IMAGE_SIZE       : [IN]        if img_src is memory, this is size of img_src
 *  HANDLE_PTR       : [OUT]       return the animation handle
 *  START_FRAME      : [IN]        the start frame of this animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_mem_frames(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,HANDLE_PTR,START_FRAME) \
            gdi_anim_codec_draw_internal(                                                                  \
                     GDI_IMAGE_SRC_FROM_MEMORY,                                                            \
                     (U8*)IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,                                                 \
                     OFFSET_X,OFFSET_Y,                                                                    \
                     0,0,/* resized width,height */                                                          \
                     0,/* flag */                                                                            \
                     HANDLE_PTR,                                                                           \
                     START_FRAME,/* start_frame */                                                           \
                     -1)/* is_draw_once */                                                                \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_mem_resized_frames
 * DESCRIPTION
 *  play a resized animation in memory
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  RESIZED_W        : [IN]        x position to draw animtaion
 *  RESIZED_H        : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer, if src_type is file, img_src is file name
 *  IMAGE_TYPE       : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  IMAGE_SIZE       : [IN]        if img_src is memory, this is size of img_src
 *  HANDLE_PTR       : [OUT]       return the animation handle
 *  START_FRAME      : [IN]        the start frame of this animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_mem_resized_frames(OFFSET_X,OFFSET_Y,RESIZED_W,RESIZED_H,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,HANDLE_PTR,START_FRAME) \
            gdi_anim_codec_draw_internal(                                                                  \
                     GDI_IMAGE_SRC_FROM_MEMORY,                                                            \
                     (U8*)IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,                                                 \
                     OFFSET_X,OFFSET_Y,                                                                    \
                     RESIZED_W,RESIZED_H,/* resized width,height */                                                   \
                     0,/* flag */                                                                            \
                     HANDLE_PTR,                                                                           \
                     START_FRAME,/* start_frame */                                                           \
                     -1)/* is_draw_once */                                                                \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_mem_resized
 * DESCRIPTION
 *  play a resized animation in memory
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  RESIZED_W        : [IN]        x position to draw animtaion
 *  RESIZED_H        : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer, if src_type is file, img_src is file name
 *  IMAGE_TYPE       : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  IMAGE_SIZE       : [IN]        if img_src is memory, this is size of img_src
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_mem_resized(OFFSET_X,OFFSET_Y,RESIZED_W,RESIZED_H,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                                                                           \
                     GDI_IMAGE_SRC_FROM_MEMORY,                                                                     \
                     (U8*)IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,                                                          \
                     OFFSET_X,OFFSET_Y,                                                                             \
                     RESIZED_W,RESIZED_H,/* resized width,height */                                                   \
                     0,/* flag */                                                                                     \
                     HANDLE_PTR,                                                                                    \
                     0,/* start_frame */                                                                              \
                     -1)/* is_draw_once */                                                                         \

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_draw_mem_once
 * DESCRIPTION
 *  play a resized animation in memory
 * PARAMETERS
 *  OFFSET_X         : [IN]        x position to draw animtaion
 *  OFFSET_Y         : [IN]        y position to draw animtaion
 *  IMAGE_PTR        : [IN]        image pointer, if src_type is file, img_src is file name
 *  IMAGE_TYPE       : [IN]        if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  IMAGE_SIZE       : [IN]        if img_src is memory, this is size of img_src
 *  HANDLE_PTR       : [OUT]       return the animation handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_anim_draw_mem_once(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,HANDLE_PTR) \
            gdi_anim_codec_draw_internal(                                                    \
                     GDI_IMAGE_SRC_FROM_MEMORY,                                              \
                     (U8*)IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,                                   \
                     OFFSET_X,OFFSET_Y,                                                      \
                     0,0,/* resized width,height */                                            \
                     0,/* flag */                                                              \
                     HANDLE_PTR,                                                             \
                     0,/* start_frame */                                                       \
                     1)/* is_draw_once */                                                   \

/* DOM-NOT_FOR_SDK-BEGIN */

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// NON-BLOCKING API
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef enum
{
    GDC_JOB_DUMMY           =0,
    GDC_JOB_IS_USED         =1<<0,
    GDC_JOB_IS_ANIM         =1<<1,
    GDC_JOB_IS_NO_BLT       =1<<2,
    GDC_JOB_IS_DRAW_ONCE    =1<<3,    
    GDC_JOB_IS_PROGRESS_BLT =1<<4,
    GDC_JOB_IS_WAIT_PROCESS =1<<5,
    GDC_JOB_IS_IPP          =1<<6,
    GDC_JOB_END
} gdc_job_flag_enum;

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_internal
 * DESCRIPTION
 *  add a non blocking drawing job
 * PARAMETERS
 *  src_type        : [IN]    resource, or file, or memory. ex.GDI_IMAGE_SRC_FROM_RESOURCE...
 *  img_src         : [IN]    image pointer, if src_type is file, img_src is file name
 *  img_type        : [IN]    if img_src is resource, img_type can be GDI_IMAGE_TYPE_INVALID
 *  img_size        : [IN]    if img_src is memory, this is size of img_src
 *  x               : [IN]    x position to draw image
 *  y               : [IN]    y position to draw image
 *  w               : [IN]    image width to draw
 *  h               : [IN]    image height to draw
 *  img_flag        : [IN]    flags defined in gdi_image_codec_flag_enum
 *  frame_pos       : [IN]    the start frame of this animation
 *  job_flag        : [IN]    non-blocking job flags
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
extern gdi_handle gdi_image_nb_draw_internal(
                            gdi_image_src_enum src_type,
                            U8 *img_src,
                            U8 img_type,
                            S32 img_size,
                            S32 x,
                            S32 y,
                            S32 w,
                            S32 h,
                            U32 img_flag,
                            U32 frame_pos,
                            gdc_job_flag_enum job_flag);

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_stop
 * DESCRIPTION
 *  stop a non-blocking drawing job
 * PARAMETERS
 *  handle       : [IN]   nb job handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_nb_stop(gdi_handle handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_stop_all
 * DESCRIPTION
 *  stop all non-blocking drawing jobs
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_nb_stop_all(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_blt
 * DESCRIPTION
 *  set the blt mode of non blocking drawing
 * PARAMETERS
 *  is_blt            : [IN]  whether to blt after drawing
 *  is_progress       : [IN]  If if_blt is TRUE, decide to progress blt or not
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_blt(BOOL is_blt,BOOL is_progress);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_before_frame_callback
 * DESCRIPTION
 *  set animation before frame callback.
 *  This callback will be called once before first frame of non-blocking animation.
 * PARAMETERS
 *  callback        : [IN]    callback pointer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_before_frame_callback(void (*callback)(GDI_RESULT result,gdi_handle handle));
/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_after_frame_callback
 * DESCRIPTION
 *  set animation after frame callback.
 *  This callback will be called once after first frame of non-blocking animation.
 * PARAMETERS
 *  callback        : [IN]    callback pointer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_after_frame_callback(void (*callback)(GDI_RESULT result,gdi_handle handle));
/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_last_frame_callback
 * DESCRIPTION
 *  set animation last frame callback.
 *  This callback will be called once after last frame of non-blocking animation.
 * PARAMETERS
 *  callback       : [IN]     callback pointer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_last_frame_callback(void (*callback)(GDI_RESULT result));
/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_before_each_frame_callback
 * DESCRIPTION
 *  set animation before each frame callback.
 *  This callback will be called before each frame of non-blocking animation.
 * PARAMETERS
 *  callback       : [IN]     callback pointer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_before_each_frame_callback(void (*callback)(GDI_RESULT result));
/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_after_each_frame_callback
 * DESCRIPTION
 *  set animation after each frame callback.
 *  This callback will be called after each frame of non-blocking animation.
 * PARAMETERS
 *  callback       : [IN]     callback pointer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_after_each_frame_callback(void (*callback)(GDI_RESULT result));

/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_handle_query_callback
 * DESCRIPTION
 *  set animation handle query callback.
 *  This callback will be called to get anim handle of non-blocking animation.
 * PARAMETERS
 *  callback       : [IN]     callback pointer
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_handle_query_callback(void (*callback)(gdi_handle anim_handle,gdi_handle job_handle));

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_done_callback
 * DESCRIPTION
 *  set the done callback function. The function will be called after nb drawing job is done.
 * PARAMETERS
 *  callback       : [IN]     done callback function
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_done_callback(void (*callback)(GDI_RESULT result,gdi_handle handle));

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_anim_count
 * DESCRIPTION
 *  set non-blocking animation loop count
 * PARAMETERS
 *  anim_count       : [IN]   animation loop count
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_anim_count(S32 anim_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_nb_set_high_priority
 * DESCRIPTION
 *  set high priority flag
 * PARAMETERS
 *  is_nb_first       : [IN]  is non-blocking decode high priority
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_nb_set_high_priority(BOOL is_nb_first);
/*****************************************************************************
 * FUNCTION
 *  gdi_nb_is_non_blocking_decoding
 * DESCRIPTION
 *  return true if the GDC job queue is empty
 * PARAMETERS
 *  void
 * RETURNS
 *  BOOL, return true if the GDC job queue is empty
 *****************************************************************************/
extern BOOL gdi_nb_is_non_blocking_decoding(void);

#define gdi_anim_nb_stop            gdi_image_nb_stop
#define gdi_anim_nb_stop_all        gdi_image_nb_stop_all

/* DOM-NOT_FOR_SDK-END */

////////////////
// IMAGE RESOURCE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw
 * DESCRIPTION
 *  non-blocking draw a resource image
 * PARAMETERS
 *  IMAGE_PTR        : [IN]    image pointer
 *  OFFSET_X         : [IN]    x position to draw image
 *  OFFSET_Y         : [IN]    y position to draw image
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw(OFFSET_X,OFFSET_Y,IMAGE_PTR)              \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                    IMAGE_PTR,                      \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_resized
 * DESCRIPTION
 *  non-blocking draw a resized resource image
 * PARAMETERS
 *  OFFSET_X         : [IN]    x position to draw image
 *  OFFSET_Y         : [IN]    y position to draw image
 *  RESIZED_WIDTH    : [IN]    image width to draw
 *  RESIZED_HEIGHT   : [IN]    image height to draw
 *  IMAGE_PTR        : [IN]    image pointer
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_resized(OFFSET_X, OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                    IMAGE_PTR,                      \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_frames
 * DESCRIPTION
 *  non-blocking draw one frame in animation from resource
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_PTR       : [IN]    image pointer
 *  FRAME_NO        : [IN]    the start frame of this animation
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_frames(OFFSET_X,OFFSET_Y,IMAGE_PTR,FRAME_NO)              \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                    IMAGE_PTR,                      \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    (U32)FRAME_NO,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_resized_frames
 * DESCRIPTION
 *  non-blocking draw one frame in animation from resource
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_PTR       : [IN]    image pointer
 *  FRAME_NO        : [IN]    the start frame of this animation
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_resized_frames(OFFSET_X, OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,FRAME_NO) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                    IMAGE_PTR,                      \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    (U32)FRAME_NO,                  \
                                    GDC_JOB_DUMMY)
////////////////
// IMAGE MEMORY
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_mem
 * DESCRIPTION
 *  non-blocking draw image from memory
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_PTR       : [IN]    image pointer
 *  IMAGE_TYPE      : [IN]    image type
 *  IMAGE_SIZE      : [IN]    this is size of IMAGE_PTR
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_mem(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE)              \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_MEMORY,      \
                                    IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,\
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_resized_mem
 * DESCRIPTION
 *  non-blocking draw resized image from memory
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_PTR       : [IN]    image pointer
 *  IMAGE_TYPE      : [IN]    image type
 *  IMAGE_SIZE      : [IN]    this is size of IMAGE_PTR
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_resized_mem(OFFSET_X, OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_MEMORY,      \
                                    IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,\
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_mem_frames
 * DESCRIPTION
 *  non-blocking draw one frame in animation from memory
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_PTR       : [IN]    image pointer
 *  IMAGE_TYPE      : [IN]    image type
 *  IMAGE_SIZE      : [IN]    this is size of IMAGE_PTR
 *  FRAME_NO        : [IN]    the start frame of this animation
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_mem_frames(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,FRAME_NO)              \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_MEMORY,      \
                                    IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,\
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    (U32)FRAME_NO,                  \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_resized_mem_frames
 * DESCRIPTION
 *  non-blocking draw one resized frame in animation from memory
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_PTR       : [IN]    image pointer
 *  IMAGE_TYPE      : [IN]    image type
 *  IMAGE_SIZE      : [IN]    this is size of IMAGE_PTR
 *  FRAME_NO        : [IN]    the start frame of this animation
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_resized_mem_frames(OFFSET_X, OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,FRAME_NO) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_MEMORY,      \
                                    IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,\
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    (U32)FRAME_NO,                  \
                                    GDC_JOB_DUMMY)

////////////////
// IMAGE FILE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_file
 * DESCRIPTION
 *  non-blocking draw image from file
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_NAME      : [IN]    file name
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_file(OFFSET_X,OFFSET_Y,IMAGE_NAME) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_FILE,        \
                                    (U8*)(IMAGE_NAME),                     \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_resized_file
 * DESCRIPTION
 *  non-blocking draw resized image from file
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_NAME      : [IN]    file name
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_resized_file(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_NAME) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_FILE,        \
                                    (U8*)(IMAGE_NAME),                     \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_DUMMY)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_nb_draw_file_frames
 * DESCRIPTION
 *  non-blocking draw one frame in animation from file
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_NAME      : [IN]    file name
 *  FRAME_NO        : [IN]    the start frame of this animation
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_image_nb_draw_file_frames(OFFSET_X,OFFSET_Y,IMAGE_NAME,FRAME_NO) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_FILE,        \
                                    (U8*)(IMAGE_NAME),              \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    (U32)FRAME_NO,                  \
                                    GDC_JOB_DUMMY)

 /*****************************************************************************
  * FUNCTION
  *  gdi_image_nb_draw_resized_file_frames
  * DESCRIPTION
  *  non-blocking draw one resized frame in animation from file
  * PARAMETERS
  *  OFFSET_X        : [IN]    x position to draw image
  *  OFFSET_Y        : [IN]    y position to draw image
  *  RESIZED_WIDTH   : [IN]    image width to draw
  *  RESIZED_HEIGHT  : [IN]    image height to draw
  *  IMAGE_NAME      : [IN]    file name
  *  FRAME_NO        : [IN]    the start frame of this animation
  * RETURNS
  *  gdi_handle, non-blocking job handle
  *****************************************************************************/
#define gdi_image_nb_draw_resized_file_frames(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_NAME,FRAME_NO) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_FILE,        \
                                    (U8*)(IMAGE_NAME),              \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    (U32)FRAME_NO,                  \
                                    GDC_JOB_DUMMY)

/* DOM-NOT_FOR_SDK-BEGIN */

////////////////
// ANIMATE RESOURCE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_nb_draw
 * DESCRIPTION
 *  non-blocking draw animtaion from resource
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_PTR       : [IN]    image pointer
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_anim_nb_draw(OFFSET_X,OFFSET_Y,IMAGE_PTR) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                    IMAGE_PTR,                      \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_IS_ANIM)

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_nb_draw_resized
 * DESCRIPTION
 *  non-blocking draw animtaion from resource
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_PTR       : [IN]    image pointer
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_anim_nb_draw_resized(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_RESOURCE,    \
                                    IMAGE_PTR,                      \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_IS_ANIM)
////////////////
// ANIMATE MEMORY
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_nb_draw_mem
 * DESCRIPTION
 *  non-blocking draw animtaion from memory
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_PTR       : [IN]    image pointer
 *  IMAGE_TYPE      : [IN]    image type
 *  IMAGE_SIZE      : [IN]    this is size of IMAGE_PTR
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_anim_nb_draw_mem(OFFSET_X,OFFSET_Y,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_MEMORY,      \
                                    IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,\
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_IS_ANIM)

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_nb_draw_resized_mem
 * DESCRIPTION
 *  non-blocking draw animtaion from memory
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_PTR       : [IN]    image pointer
 *  IMAGE_TYPE      : [IN]    image type
 *  IMAGE_SIZE      : [IN]    this is size of IMAGE_PTR
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_anim_nb_draw_resized_mem(OFFSET_X,OFFSET_Y,RESIZED_WIDTH,RESIZED_HEIGHT,IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_MEMORY,      \
                                    IMAGE_PTR,IMAGE_TYPE,IMAGE_SIZE,\
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    RESIZED_WIDTH,                  \
                                    RESIZED_HEIGHT,                 \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_IS_ANIM)
////////////////
// ANIMATE FILE
////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_nb_draw_file
 * DESCRIPTION
 *  non-blocking draw animtaion from file
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  IMAGE_NAME      : [IN]    image file name
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
#define gdi_anim_nb_draw_file(OFFSET_X,OFFSET_Y,IMAGE_NAME) \
                          gdi_image_nb_draw_internal(               \
                                    GDI_IMAGE_SRC_FROM_FILE,        \
                                    (U8*)(IMAGE_NAME),                     \
                                    GDI_IMAGE_TYPE_INVALID,         \
                                    0,                              \
                                    OFFSET_X,                       \
                                    OFFSET_Y,                       \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    0,                              \
                                    GDC_JOB_IS_ANIM)

/*****************************************************************************
 * FUNCTION
 *  gdi_anim_nb_draw_resized_file
 * DESCRIPTION
 *  non-blocking draw animtaion from file
 * PARAMETERS
 *  OFFSET_X        : [IN]    x position to draw image
 *  OFFSET_Y        : [IN]    y position to draw image
 *  RESIZED_WIDTH   : [IN]    image width to draw
 *  RESIZED_HEIGHT  : [IN]    image height to draw
 *  IMAGE_NAME      : [IN]    image file name
 * RETURNS
 *  gdi_handle, non-blocking job handle
 *****************************************************************************/
extern gdi_handle gdi_anim_nb_draw_resized_file(
                    S32 x,
                    S32 y,
                    S32 w,
                    S32 h,
                    U8 *img_name);
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// DECODER API
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create and free decoder, related hw will be powered on after deocder is created 

/*****************************************************************************
 * FUNCTION
 *  gdi_image_decoder_create
 * DESCRIPTION
 *  set non-blocking decode done callback
 * PARAMETERS
 *  max_img_width        : [IN]   not used
 *  max_img_height       : [IN]   not used
 *  decoder_result       : [IN]   
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_decoder_create(S32 max_img_width, S32 max_img_height,
                                           void (*result_callback_ptr) (GDI_RESULT decode_result, gdi_handle handle));
/*****************************************************************************
 * FUNCTION
 *  gdi_image_decoder_free
 * DESCRIPTION
 *  clear the non-blocking decode done callback
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_decoder_free(void);

/* Decoder functions */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_decoder_free
 * DESCRIPTION
 *  clear the non-blocking decode done callback
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_decoder_decode_file(
                    S32 offset_x,
                    S32 offset_y,
                    S32 width,
                    S32 height,
                    BOOL is_blt,
                    S8 *image_name,
                    gdi_handle *handle_ptr);



/*****************************************************************************
 * FUNCTION
 *  gdi_image_decoder_stop
 * DESCRIPTION
 *  delete the non-blocking decode job by its handle
 * PARAMETERS
 *  handle       : [IN]    non-blocking decode job handle
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_decoder_stop(gdi_handle handle);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_decoder_stop_all
 * DESCRIPTION
 *  delete all non-blocking decode job
 * PARAMETERS
 *  void
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_decoder_stop_all(void);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// JPEG API
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
    U8 make[35];
    U8 model[35];
    U8 orientation[11];
    U8 x_resolution[24];
    U8 y_resolution[24];
    U8 resolution_unit[12];
    U8 software[35];
    U8 date_time[35];
    U8 ycbcr_positioning[9];
    U8 exif_ifd[14];

    U8 exposure_time[24];
    U8 fnumber[24];
    U8 exposure_program[18];
    U8 iso_speed_ratings[8];
    U8 exif_version[20];
    U8 date_time_original[35];
    U8 date_time_digitized[35];
    U8 components_config[6];
    U8 exposure_bias_value[24];
    U8 metering_mode[24];
    U8 light_source[17];
    U8 flash[80];
    U8 maker_note[20];
    U8 flashpix_version[20];
    U8 color_space[13];
    U8 pixel_x_dimension[14];
    U8 pixel_y_dimension[14];
    U8 exposure_mode[16];
    U8 digital_zoom_ratio[24];
    U8 scene_capture_type[12];
} gdi_image_jpeg_exif_info_struct;


/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_set_background_mode
 * DESCRIPTION
 *  set background mode value
 *  Jpeg (MT6228, MT6229, MT6230) won't use TCM when it's in background mode.
 * PARAMETERS
 *  filename       : [IN]     background mode
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_set_background_mode(kal_bool is_background_mode);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_background_mode
 * DESCRIPTION
 *  get background mode value
 * PARAMETERS
 *  info           : [OUT]    return the background mode value
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_background_mode(kal_bool *is_background_mode);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_set_force_use_swjpeg
 * DESCRIPTION
 *  Jpeg (MT6238, MT6268) force to use swjpeg when use_swjpeg is true.
 *  Modify for MT6268 VDO Call(VT). 
 *  MPEG4 and hwjpeg share DCT hw engine.
 *  MT6268 VT would always enalbe MPEG4.
 *  Application can't use hw jpeg in this situation.
 * PARAMETERS
 *  use_swjpeg      : [IN]     force to use swjpeg when use_swjpeg is true
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_set_force_use_swjpeg(kal_bool use_swjpeg);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_force_use_swjpeg
 * DESCRIPTION
 *  get background mode value
 * PARAMETERS
 *  use_swjpeg      : [OUT]    return the gdi_jpeg_force_use_sw_jpeg
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_force_use_swjpeg(kal_bool *use_swjpeg);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_exif_info
 * DESCRIPTION
 *  get exif information of jpeg file.
 *  only valid when GDI_USING_JPEG_EXIF is defined
 * PARAMETERS
 *  filename       : [IN]     jpeg file name
 *  info           : [OUT]    return the exif information in struct
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_exif_info(S8 *filename, gdi_image_jpeg_exif_info_struct *info);
extern GDI_RESULT gdi_image_jpeg_is_progressive(S8 *filename, MMI_BOOL *is_progressive);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_to_buffer
 * DESCRIPTION
 *  draw resized jpeg in memory
 * PARAMETERS
 *  width                     : [IN]  image width want to draw
 *  height                    : [IN]  image height want to draw
 *  jpeg_src                  : [IN]  source image
 *  size                      : [IN]  source image size
 *  buf                       : [IN]  destination buffer
 *  buf_size                  : [IN]  buffer size
 *  decoded_image_width       : [OUT] actual image width to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_draw_to_buffer(
                    S32 width,
                    S32 height,
                    U8 *jpeg_src,
                    U32 size,
                    U8 *buf,
                    S32 buf_size,
                    S32 *decoded_image_width);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_file_to_buffer
 * DESCRIPTION
 *  draw resized jpeg file to buffer
 * PARAMETERS
 *  width                     : [IN]  image width want to draw
 *  height                    : [IN]  image height want to draw
 *  jpeg_file                 : [IN]  source image file name
 *  buf                       : [IN]  destination buffer
 *  buf_size                  : [IN]  buffer size
 *  decoded_image_width       : [OUT] actual image width to draw
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_draw_file_to_buffer(
                    S32 width,
                    S32 height,
                    U8 *jpeg_file,
                    U8 *buf,
                    S32 buf_size,
                    S32 *decoded_image_width);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_dimension
 * DESCRIPTION
 *  get jpeg dimension, source is from memory
 * PARAMETERS
 *  jpeg_src        : [IN]        jpeg source image
 *  size            : [IN]        jpeg source image size
 *  width           : [OUT]       image width
 *  height          : [OUT]       image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_dimension(U8 *jpeg_src, U32 size, S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_dimension_file
 * DESCRIPTION
 *  get jpeg dimension, source is from file
 * PARAMETERS
 *  image_name      : [IN]        image file name
 *  width           : [OUT]       image width
 *  height          : [OUT]       image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_dimension_file(S8 *image_name, S32 *width, S32 *height);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_internal
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  src                     : [IN]        source image buffer or image file name
 *  size                    : [IN]        source image buffer size
 *  is_file                 : [IN]        src is a file name or not
 *  is_resized              : [IN]        want to resize image or not
 *  dest_buf                : [IN]        destination draw buffer
 *  dest_buf_size           : [IN]        destination draw buffer size
 *  decoded_image_width     : [OUT]       actual draw image width
 *  dest_buf_cf             : [IN]        destination draw buffer color format
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_draw_internal(
                    S32 ox,
                    S32 oy,
                    S32 resized_width,
                    S32 resized_height,
                    S32 output_clipx1,
                    S32 output_clipy1,
                    S32 output_clipx2,
                    S32 output_clipy2,
                    U8 *src,
                    U32 size,
                    BOOL is_file,
                    BOOL is_resized,
                    BOOL retry_thumbnail,
                    U8 *dest_buf,
                    S32 dest_buf_size,
                    S32 *decoded_image_width,
                    gdi_color_format dest_buf_cf);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw(ox, oy, jpeg_src, size)\
         gdi_image_jpeg_draw_internal(             \
                  ox, oy,                          \
                  0, 0,                            \
                  -1, -1,                          \
                  -1, -1,                          \
                  jpeg_src,size,                    \
                  FALSE,FALSE,TRUE,                 \
                  NULL, /* dest buf */              \
                  0,    /* dest buf size */         \
                  NULL, /* decode image width */    \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_file
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  filename                : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_file(ox, oy, filename)\
         gdi_image_jpeg_draw_internal(            \
                  ox, oy,                         \
                  0, 0,                           \
                  -1, -1,                         \
                  -1, -1,                         \
                  (U8*)filename,0,                \
                  TRUE,FALSE,TRUE,                \
                  NULL, /* dest buf */             \
                  0,    /* dest buf size */        \
                  NULL, /* decode image width */   \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized(                       \
                     ox, oy, resized_width, resized_height,\
                     jpeg_src, size)                       \
         gdi_image_jpeg_draw_internal(                     \
                  ox, oy,                                  \
                  resized_width,resized_height,            \
                  0, 0,                                    \
                  resized_width-1, resized_height-1,       \
                  jpeg_src,size,                           \
                  FALSE,TRUE,TRUE,                          \
                  NULL, /* dest buf */                      \
                  0,    /* dest buf size */                 \
                  NULL, /* decode image width */            \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_with_output_clipping
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_with_output_clipping(  \
                     ox, oy,                       \
                     output_clipx1, output_clipy1, \
                     output_clipx2, output_clipy2, \
                     jpeg_src,size)                \
         gdi_image_jpeg_draw_internal(             \
                  ox, oy,                          \
                  0, 0,                            \
                  output_clipx1, output_clipy1,    \
                  output_clipx2, output_clipy2,    \
                  jpeg_src,size,                    \
                  FALSE,FALSE,TRUE,                 \
                  NULL, /* dest buf */              \
                  0,    /* dest buf size */         \
                  NULL, /* decode image width */    \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_with_output_clipping
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_with_output_clipping( \
                  ox, oy, resized_width,resized_height,   \
                  output_clipx1, output_clipy1,           \
                  output_clipx2, output_clipy2,           \
                  jpeg_src, size)                         \
         gdi_image_jpeg_draw_internal(                    \
                  ox, oy,                                 \
                  resized_width, resized_height,          \
                  output_clipx1, output_clipy1,           \
                  output_clipx2, output_clipy2,           \
                  jpeg_src,size,                          \
                  FALSE,TRUE,TRUE,                         \
                  NULL, /* dest buf */                     \
                  0,    /* dest buf size */                \
                  NULL, /* decode image width */           \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_file_with_output_clipping
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  filename                : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_file_with_output_clipping( \
                        ox, oy,                        \
                        output_clipx1, output_clipy1,  \
                        output_clipx2, output_clipy2,  \
                        filename)                      \
         gdi_image_jpeg_draw_internal(                 \
                  ox, oy,                              \
                  0, 0,                                \
                  output_clipx1, output_clipy1,        \
                  output_clipx2, output_clipy2,        \
                  (U8*)filename,0,                     \
                  TRUE,FALSE,TRUE,                     \
                  NULL, /* dest buf */                  \
                  0,    /* dest buf size */             \
                  NULL, /* decode image width */        \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_file
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  filename                : [IN]         image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_file(           \
                  ox, oy,                           \
                  resized_width, resized_height,    \
                  filename)                         \
         gdi_image_jpeg_draw_internal(              \
                  ox, oy,                           \
                  resized_width, resized_height,    \
                  0, 0,                             \
                  resized_width-1, resized_height-1,\
                  (U8*)filename,0,                  \
                  TRUE,TRUE,TRUE,                   \
                  NULL, /* dest buf */               \
                  0,    /* dest buf size */          \
                  NULL, /* decode image width */     \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_file_with_output_clipping
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  filename                : [IN]        source image buffer or image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_file_with_output_clipping( \
                  ox,oy,                                       \
                  resized_width, resized_height,               \
                  output_clipx1, output_clipy1,                \
                  output_clipx2, output_clipy2,                \
                  filename)                                    \
         gdi_image_jpeg_draw_internal(                         \
                  ox, oy,                                      \
                  resized_width, resized_height,               \
                  output_clipx1, output_clipy1,                \
                  output_clipx2, output_clipy2,                \
                  (U8*)filename,0,                             \
                  TRUE,TRUE,TRUE,                              \
                  NULL, /* dest buf */                          \
                  0,    /* dest buf size */                     \
                  NULL, /* decode image width */                \
                  0)    /* dest buf color format */
                  
/* Add Macro not to retry to decode thumbnail of jpeg when time out */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  jpeg_src                : [IN]        source image buffer or image file name
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_disable_retry(ox, oy, jpeg_src, size)\
         gdi_image_jpeg_draw_internal(             \
                  ox, oy,                          \
                  0, 0,                            \
                  -1, -1,                          \
                  -1, -1,                          \
                  jpeg_src,size,                    \
                  FALSE,FALSE,FALSE,                 \
                  NULL, /* dest buf */              \
                  0,    /* dest buf size */         \
                  NULL, /* decode image width */    \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_file_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  filename                : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_file_disable_retry(ox, oy, filename)\
         gdi_image_jpeg_draw_internal(            \
                  ox, oy,                         \
                  0, 0,                           \
                  -1, -1,                         \
                  -1, -1,                         \
                  (U8*)filename,0,                \
                  TRUE,FALSE,FALSE,                \
                  NULL, /* dest buf */             \
                  0,    /* dest buf size */        \
                  NULL, /* decode image width */   \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_disable_retry(                       \
                     ox, oy, resized_width, resized_height,\
                     jpeg_src, size)                       \
         gdi_image_jpeg_draw_internal(                     \
                  ox, oy,                                  \
                  resized_width,resized_height,            \
                  0, 0,                                    \
                  resized_width-1, resized_height-1,       \
                  jpeg_src,size,                           \
                  FALSE,TRUE,FALSE,                          \
                  NULL, /* dest buf */                      \
                  0,    /* dest buf size */                 \
                  NULL, /* decode image width */            \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_with_output_clipping_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_with_output_clipping_disable_retry(  \
                     ox, oy,                       \
                     output_clipx1, output_clipy1, \
                     output_clipx2, output_clipy2, \
                     jpeg_src,size)                \
         gdi_image_jpeg_draw_internal(             \
                  ox, oy,                          \
                  0, 0,                            \
                  output_clipx1, output_clipy1,    \
                  output_clipx2, output_clipy2,    \
                  jpeg_src,size,                   \
                  FALSE,FALSE,FALSE,               \
                  NULL, /* dest buf */              \
                  0,    /* dest buf size */         \
                  NULL, /* decode image width */    \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_with_output_clipping_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  jpeg_src                : [IN]        source image buffer
 *  size                    : [IN]        source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_with_output_clipping_disable_retry( \
                  ox, oy, resized_width,resized_height,   \
                  output_clipx1, output_clipy1,           \
                  output_clipx2, output_clipy2,           \
                  jpeg_src, size)                         \
         gdi_image_jpeg_draw_internal(                    \
                  ox, oy,                                 \
                  resized_width, resized_height,          \
                  output_clipx1, output_clipy1,           \
                  output_clipx2, output_clipy2,           \
                  jpeg_src,size,                          \
                  FALSE,TRUE,FALSE,                        \
                  NULL, /* dest buf */                     \
                  0,    /* dest buf size */                \
                  NULL, /* decode image width */           \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_file_with_output_clipping_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  filename                : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_file_with_output_clipping_disable_retry( \
                        ox, oy,                        \
                        output_clipx1, output_clipy1,  \
                        output_clipx2, output_clipy2,  \
                        filename)                      \
         gdi_image_jpeg_draw_internal(                 \
                  ox, oy,                              \
                  0, 0,                                \
                  output_clipx1, output_clipy1,        \
                  output_clipx2, output_clipy2,        \
                  (U8*)filename,0,                     \
                  TRUE,FALSE,FALSE,                     \
                  NULL, /* dest buf */                  \
                  0,    /* dest buf size */             \
                  NULL, /* decode image width */        \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_file_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  filename                : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_file_disable_retry(           \
                  ox, oy,                           \
                  resized_width, resized_height,    \
                  filename)                         \
         gdi_image_jpeg_draw_internal(              \
                  ox, oy,                           \
                  resized_width, resized_height,    \
                  0, 0,                             \
                  resized_width-1, resized_height-1,\
                  (U8*)filename,0,                  \
                  TRUE,TRUE,FALSE,                   \
                  NULL, /* dest buf */               \
                  0,    /* dest buf size */          \
                  NULL, /* decode image width */     \
                  0)    /* dest buf color format */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_file_with_output_clipping_disable_retry
 * DESCRIPTION
 *  draw jpeg image without retrying decode thumbnail
 * PARAMETERS
 *  ox                      : [IN]        image draw x position
 *  oy                      : [IN]        image draw y position
 *  resized_width           : [IN]        image width want to draw
 *  resized_height          : [IN]        image height want to draw
 *  output_clipx1           : [IN]        clip region x1
 *  output_clipy1           : [IN]        clip region y1
 *  output_clipx2           : [IN]        clip region x2
 *  output_clipy2           : [IN]        clip region y2
 *  filename                : [IN]        image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_file_with_output_clipping_disable_retry( \
                  ox,oy,                                       \
                  resized_width, resized_height,               \
                  output_clipx1, output_clipy1,                \
                  output_clipx2, output_clipy2,                \
                  filename)                                    \
         gdi_image_jpeg_draw_internal(                         \
                  ox, oy,                                      \
                  resized_width, resized_height,               \
                  output_clipx1, output_clipy1,                \
                  output_clipx2, output_clipy2,                \
                  (U8*)filename,0,                             \
                  TRUE,TRUE,FALSE,                              \
                  NULL, /* dest buf */                          \
                  0,    /* dest buf size */                     \
                  NULL, /* decode image width */                \
                  0)    /* dest buf color format */


/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_dimension_no_rotate
 * DESCRIPTION
 *  get the JPEG information without rotation info
 * PARAMETERS
 *  src                     : [IN] image src
 *  size                    : [IN] image memory size
 *  width                   : [IN] width to get
 *  height                  : [IN] height to get
 * RETURNS
 *  
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_dimension_no_rotate(U8 *src, U32 size, S32 *width, S32 *height);


/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_get_desc_from_file
 * DESCRIPTION
 *  Get the description field inner a jpeg file
 * PARAMETERS
 *  filepath       : [IN]  Filepath
 *  out_desc       : [OUT] Description string
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_get_desc_from_file(const WCHAR *filepath, kal_char *out_desc);


///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// PNG API
///////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_get_dimension_internal
 * DESCRIPTION
 *  get png dimension, source is from memory
 * PARAMETERS
 *  png_src     : [IN]        png source image
 *  size        : [IN]        png source image size
 *  width       : [OUT]       image width
 *  height      : [OUT]       image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_png_get_dimension_internal(U8 *src, U32 size, S32 *width, S32 *height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_draw_internal
 * DESCRIPTION
 *  draw png image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  resized_width        : [IN]   image width want to draw
 *  resized_height       : [IN]   image height want to draw
 *  src                  : [IN]   source image buffer or image file name
 *  size                 : [IN]   source image buffer size
 *  is_file              : [IN]   src is a file name or not
 *  is_blocking          : [IN]   not used
 *  callback             : [IN]   not used
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_png_draw_internal(S32 ox, S32 oy,
                                              S32 resized_width, S32 resized_height,
                                              U8 *src, U32 size, BOOL is_file, BOOL is_blocking,
                                              void (*callback) (GDI_RESULT result));

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_get_dimension
 * DESCRIPTION
 *  get png dimension from memory
 * PARAMETERS
 *  png_src     : [IN]        png source image
 *  size        : [IN]        png source image size
 *  width       : [OUT]       image width
 *  height      : [OUT]       image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_png_get_dimension(src,size,width,height) \
      gdi_image_png_get_dimension_internal(src,size,width,height)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_get_dimension_file
 * DESCRIPTION
 *  get png dimension, source is from file
 * PARAMETERS
 *  src         : [IN]        png source image
 *  width       : [OUT]       image width
 *  height      : [OUT]       image height
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_png_get_dimension_file(src,width,height) \
      gdi_image_png_get_dimension_internal((U8*)src,0,width,height)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_draw
 * DESCRIPTION
 *  draw png image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  src                  : [IN]   source image buffer
 *  size                 : [IN]   source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_png_draw(ox, oy, src, size)\
         gdi_image_png_draw_internal(        \
                  ox, oy,                    \
                  0, 0,                      \
                  src,size,FALSE,TRUE,NULL)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_draw_file
 * DESCRIPTION
 *  draw png image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  filename             : [IN]   image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_png_draw_file(ox, oy, filename)\
         gdi_image_png_draw_internal(            \
                  ox, oy,                        \
                  0, 0,                          \
                  (U8*)filename,0,TRUE,TRUE,NULL)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_draw_resized
 * DESCRIPTION
 *  draw png image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  resized_width        : [IN]   image width want to draw
 *  resized_height       : [IN]   image height want to draw
 *  src                  : [IN]   source image buffer
 *  size                 : [IN]   source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_png_draw_resized(                        \
                     ox, oy, resized_width, resized_height,\
                     src, size)                            \
         gdi_image_png_draw_internal(                      \
                  ox, oy,                                  \
                  resized_width,resized_height,            \
                  src,size,FALSE,TRUE,NULL)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_png_draw_resized_file
 * DESCRIPTION
 *  draw png image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  resized_width        : [IN]   image width want to draw
 *  resized_height       : [IN]   image height want to draw
 *  filename             : [IN]   image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_png_draw_resized_file(         \
                  ox, oy,                        \
                  resized_width, resized_height, \
                  filename)                      \
         gdi_image_png_draw_internal(            \
                  ox, oy,                        \
                  resized_width, resized_height, \
                  (U8*)filename,0,TRUE,TRUE,NULL)

/* DOM-NOT_FOR_SDK-END */

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ABM API
///////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_set_source_layer
 * DESCRIPTION
 *  set alpha source blending source layer
 * PARAMETERS
 *  src_layer_handle       : [IN] gdi handle of the alpha source layer
 * RETURNS
 *  gdi_handle,  old alpha source layer handle
 *****************************************************************************/
#define gdi_image_abm_set_source_layer  gdi_set_alpha_blending_source_layer

/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_source_layer
 * DESCRIPTION
 *  get alpha blending source layer
 * PARAMETERS
 *  src_layer_handle       : [OUT] gdi handle of the alpha source layer
 * RETURNS
 *  void
 *****************************************************************************/
#define gdi_image_abm_get_source_layer  gdi_get_alpha_blending_source_layer

/* DOM-NOT_FOR_SDK-BEGIN */

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// M3D/M3G API
///////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GDI Catcher Support
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#define GDI_CATCHER_MAX_LCD_COUNT 3
#define GDI_CATCHER_MAX_LAYER_COUNT 8
typedef struct
{
    gdi_handle layer_handle;
    S32 width, height;
    S32 clipx1, clipy1, clipx2, clipy2;
    U8 *buf_ptr;
    U8 *buf_ptr1;
    S32 offset_x, offset_y;
    U32 source_key_value;
    U32 background; /* only valide when this layer is the "lowest" layer. */
    U32 layer_size; /* Buffer Size */
    U8 cf;
    U8 bits_per_pixel;
    U8 opacity_value;
    U8 rotate_value;
    U8 opacity_enable;
    U8 source_key_enable;
} gdi_catcher_layer_info_struct;

typedef struct
{
    S32 act_width;
    S32 act_height;
    S32 layer_count;
    S32 ROIx1;  /* blt region */
    S32 ROIy1;  /* blt region */
    S32 ROIx2;  /* blt region */
    S32 ROIy2;  /* blt region */
    U8 blt_handle[GDI_LAYER_HW_LAYER_COUNT];
    U8 cf;
    U8 rotate_value;
} gdi_catcher_lcd_info_struct;

/* DOM-NOT_FOR_SDK-END */
typedef struct
{
    S32 lcd_count;
    gdi_catcher_lcd_info_struct lcd_array[GDI_CATCHER_MAX_LCD_COUNT];
    S32 layer_count;
    gdi_catcher_layer_info_struct layer_array[GDI_LAYER_TOTAL_LAYER_COUNT];
} gdi_catcher_info_struct;

/*****************************************************************************
 * FUNCTION
 *  gdi_catcher_fill_info
 * DESCRIPTION
 *  fill catcher info struct
 * PARAMETERS
 *  catcher_info        : [OUT]     catcher info struct
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_catcher_fill_info(gdi_catcher_info_struct *catcher_info);

/* DOM-NOT_FOR_SDK-BEGIN */

/*****************************************************************************
 * FUNCTION
 *  gdi_screen_shot_capture
 * DESCRIPTION
 *  output screen capture information
 * PARAMETERS
 *  lcd_handle       [IN]    GDI_LCD_MAIN_LCD_HANDLE or GDI_LCD_SUB_LCD_HANDLE
 *  flag             [IN]    not used currently
 * RETURNS
 *  return gdi_screen_shot_info_struct
 *****************************************************************************/
extern gdi_screen_shot_info_struct* gdi_screen_shot_capture(
                				gdi_handle lcd_handle,
                				U32 flag);

#ifdef GDI_USING_SCREEN_SHOT_BUFFER
/*****************************************************************************
 * FUNCTION
 *  gdi_util_get_screenshot_region
 * DESCRIPTION
 *  Screenshot to given buffer.
 *  This API does not always work since it relies on the layers of application
 *  usage & the flatten hardward state.
 *  For example, if application has already freed some layer, the layer will
 *  not be present in the result. If application occupies the hardware(e.g.
 *  playing video), this function will also fail.
 * PARAMETERS
 *  out_screenshot      : [OUT] Screenshot info structure
 *                            The buf_ptr field will be given buffer
 *  lcd_handle          : [IN]  GDI_LCD_MAIN_LCD_HANDLE or GDI_LCD_SUB_LCD_HANDLE
 *  x                   : [IN]  Region position x
 *  y                   : [IN]  Region position y
 *  width               : [IN]  Region width
 *  height              : [IN]  Region height
 *  buffer              : [IN]  Output buffer. Should be non-cacheable
 *  buffer_size         : [IN]  Size of buffer, should be large enough for
 *                              the region.
 *  expect_cf           : [IN]  Expected color format of snapshot
 *  flag                : [IN]  0 for default
 * RETURNS
 *  GDI_SUCCEED if success; otherwise return the cause
 *  To check the return value is mandatory.
 *****************************************************************************/
extern GDI_RESULT gdi_util_get_screenshot_region(
                gdi_screen_shot_info_struct *out_screenshot,
                gdi_handle lcd_handle,
                kal_int32 x,
                kal_int32 y,
                kal_int32 width,
                kal_int32 height,
                void *buffer, /* Should be non-cacheable */
                kal_uint32 buffer_size,
                gdi_color_format expect_cf,
                kal_uint32 flag);
#endif /* GDI_USING_SCREEN_SHOT_BUFFER */

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// estimate image decoding time
///////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_estimate_decoding_time
 * DESCRIPTION
 *  estimate decode time
 * PARAMETERS
 *  img_type       : [IN]     image type
 *  width          : [IN]     image width
 *  height         : [IN]     image height
 * RETURNS
 *  U32, return the estimate decoding time
 *****************************************************************************/
extern U32 gdi_image_estimate_decoding_time(U8 img_type,S32 width,S32 height);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_estimate_show_fullscreen_time
 * DESCRIPTION
 *  estimate show fullscreen time
 * PARAMETERS
 *  void
 * RETURNS
 *  U32, return the estimate time
 *****************************************************************************/
extern U32 gdi_image_estimate_show_fullscreen_time(void);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// NEED TO REMOVE!!!
///////////////////////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_get_transparent_index
 * DESCRIPTION
 *  get the transparent color index in palette
 * PARAMETERS
 *  void
 * RETURNS
 *  U16, return the transparent index in palette
 *****************************************************************************/
extern U16 gdi_image_gif_get_transparent_index(void);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_get_palette_size
 * DESCRIPTION
 *  get the gif palette size
 * PARAMETERS
 *  void
 * RETURNS
 *  U8, return the gif palette size
 *****************************************************************************/
extern U8 gdi_image_gif_get_palette_size(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_get_next_frame_disposal
 * DESCRIPTION
 *  get the gif disposal of next frame
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
GDI_GIF_DISPOSAL_ENUM gdi_image_gif_get_next_frame_disposal(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_get_frame_disposal
 * DESCRIPTION
 *  get the gif disposal of next frame
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
extern GDI_RESULT gdi_image_gif_get_frame_disposal(
                   U32 flag,
                   U8 *data_ptr,
                   U32 img_size,
                   S32 frame_index,
                   GDI_GIF_DISPOSAL_ENUM *disposal);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_bmp_get_transparent_index
 * DESCRIPTION
 *  get the transparent index of 8-bits bmp
 * PARAMETERS
 *  void
 * RETURNS
 *  U8  transparent index of 8-bits bmp
 *****************************************************************************/
extern U16 gdi_image_bmp_get_transparent_index(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_bmp_get_palette_size
 * DESCRIPTION
 *  get the palette size of 8-bits bmp
 * PARAMETERS
 *  void
 * RETURNS
 *  U8  palette size of 8-bits bmp
 *****************************************************************************/
extern U8 gdi_image_bmp_get_palette_size(void);


/* W05.39 Remove Compile Warnings */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_get_frame_count
 * DESCRIPTION
 *  get gif frame count
 * PARAMETERS
 *  GIF_src         : [IN]         source gif image
 *  size            : [IN]         source gif image size
 *  frame_count     : [OUT]        return the gif image frame count
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_gif_get_frame_count(U8 *GIF_src, U32 size, S32 *frame_count);
/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_get_frame_count_file
 * DESCRIPTION
 *  get gif image frame count from file
 * PARAMETERS
 *  filename        : [IN]        file name
 *  frame_count     : [OUT]       return the gif frame count
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_gif_get_frame_count_file(const S8 *filename, S32 *frame_count);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_gif_reset
 * DESCRIPTION
 *  reset gif cache
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_gif_reset(void);
extern void gdi_image_gif_reset_entry(U8* src,U32 size);

extern GDI_RESULT gdi_image_abm_draw_id_nb_concurrent(
    gdi_handle dst_layer,
    S32 dst_layer_x, 
    S32 dst_layer_y, 
    gdi_handle src_layer,
    U16 ImageId);

extern GDI_RESULT gdi_image_ab2_draw_id_nb_concurrent(
                    gdi_handle dst_layer,
                    S32 dst_layer_x, 
                    S32 dst_layer_y, 
                    gdi_handle src_layer,
                    U16 ImageId);

#define GDI_RGB_TO_BUFFER_FORMAT(R,G,B)      DRV_RGB_TO_HW(R,G,B)
#define GDI_BUFFER_FORMAT_TO_RGB_R(VALUE)    DRV_HW_TO_RGB_R(VALUE)
#define GDI_BUFFER_FORMAT_TO_RGB_G(VALUE)    DRV_HW_TO_RGB_G(VALUE)
#define GDI_BUFFER_FORMAT_TO_RGB_B(VALUE)    DRV_HW_TO_RGB_B(VALUE)
#define GDI_MAINLCD_GET_BUFFER_PIXEL(X,Y,VALUE)    DRV_MAINLCD_GET_BUFFER_PIXEL(X,Y,VALUE)
#define GDI_MAINLCD_SET_BUFFER_PIXEL(X,Y,VALUE)    DRV_MAINLCD_SET_BUFFER_PIXEL(X,Y,VALUE)
#ifdef __MMI_SUBLCD__
#define GDI_SUBLCD_BUFFER_FORMAT(R,G,B)               SUBMMI_RGB_TO_HW_FORMAT(R,G,B)
#define GDI_SUBLCD_BUFFER_FORMAT_TO_RGB_R(VALUE)      HW_FORMAT_TO_SUBMMI_R(VALUE)
#define GDI_SUBLCD_BUFFER_FORMAT_TO_RGB_G(VALUE)      HW_FORMAT_TO_SUBMMI_G(VALUE)
#define GDI_SUBLCD_BUFFER_FORMAT_TO_RGB_B(VALUE)      HW_FORMAT_TO_SUBMMI_B(VALUE)

#define GDI_SUBLCD_GET_BUFFER_PIXEL(X,Y,VALUE)     DRV_SUBLCD_GET_BUFFER_PIXEL(X,Y,VALUE)
#define GDI_SUBLCD_SET_BUFFER_PIXEL(X,Y,VALUE)     DRV_SUBLCD_SET_BUFFER_PIXEL(X,Y,VALUE)
#endif /* __MMI_SUBLCD__ */ 

#define gdi_image_get_animation_delay                 gdi_anim_get_delay
#define gdi_image_stop_animation_all                     gdi_anim_stop_all
#define gdi_image_stop_animation                   gdi_anim_stop
#define gdi_image_set_animation_last_frame_callback         gdi_anim_set_last_frame_callback

#define gdi_image_draw_animation_id          gdi_anim_draw_id
#define gdi_image_draw_animation_once_id     gdi_anim_draw_id_once

#define gdi_image_draw_animation          gdi_anim_draw
#define gdi_image_draw_animation_frames      gdi_anim_draw_frames
#define gdi_image_draw_animation_resized     gdi_anim_draw_resized
#define gdi_image_draw_animation_once        gdi_anim_draw_once

#define gdi_image_draw_animation_file        gdi_anim_draw_file
#define gdi_image_draw_animation_resized_file   gdi_anim_draw_file_resized
#define gdi_image_draw_animation_frames_file gdi_anim_draw_file_frames

#define gdi_image_draw_ext                              gdi_image_draw_mem
#define gdi_image_draw_animation_single_frame           gdi_image_draw_frames
#define gdi_image_draw_animation_single_frame_id        gdi_image_draw_id_frames

/* DOM-NOT_FOR_SDK-END */

/*****************************************************************************
 * FUNCTION
 *  gdi_image_draw_resized_mem
 * DESCRIPTION
 *  draw image in memory
 * PARAMETERS
 *  OFFSET_X          : [IN]        x position to draw image
 *  OFFSET_Y          : [IN]        y position to draw image
 *  RESIZED_WIDTH     : [IN]        image width to draw
 *  RESIZED_HEIGHT    : [IN]        image height to draw
 *  IMAGE_PTR         : [IN]        image pointer
 *  IMAGE_TYPE        : [IN]        image type, ex.GDI_IMAGE_TYPE_BMP...(defined in gdi_const.h)
 *  IMAGE_LENGTH      : [IN]        image size of IMAGE_PTR
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_draw_resized_ext                      gdi_image_draw_resized_mem

/* DOM-NOT_FOR_SDK-BEGIN */

#define gdi_layer_save_jpeg_file                        gdi_image_encode_layer_to_jpeg
extern GDI_RESULT gdi_image_virtualfile_sequence_get_image_size(
            U8 *data_ptr,
            U32 *image_file_size);


extern GDI_RESULT gdi_ipp_process(
            gdi_handle layer_handle,
            gdi_ipp_effect_enum effect_id);
extern GDI_RESULT gdi_ipp_nb_start_process(
            gdi_handle layer_handle,
            gdi_ipp_effect_enum effect_id,
            gdi_handle *ipp_handle);

extern GDI_RESULT gdi_ipp_get_capability(
            gdi_ipp_effect_enum effect_id, 
            MMI_BOOL *ipp_support, 
            MMI_BOOL *ipp_allow_pause);
extern GDI_RESULT gdi_ipp_nb_set_done_callback(void (*done_callback)(GDI_RESULT result, gdi_handle ipp_handle));

extern GDI_RESULT gdi_ipp_nb_stop_process(gdi_handle ipp_handle);

extern GDI_RESULT gdi_capability_decoder_concurrency(
                    U8 image_type, 
                    U32 *no_concurrence_flag);


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to resize
 *  sy1                 [IN]    region in source layer to resize
 *  sx2                 [IN]    region in source layer to resize
 *  sy2                 [IN]    region in source layer to resize
 *  dx1                 [IN]    region in active layer to resize to
 *  dy1                 [IN]    region in active layer to resize to
 *  dx2                 [IN]    region in active layer to resize to
 *  dy2                 [IN]    region in active layer to resize to
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_bitblt_resized(
                    gdi_handle src_layer_handle, 
                    S32 sx1,
                    S32 sy1,
                    S32 sx2,
                    S32 sy2,
                    S32 dx1,
                    S32 dy1,
                    S32 dx2,
                    S32 dy2);


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized_with_resizer
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer by a specified resizer.
 *  If the specified resizer failed, GDI may try other resizer to resize until success.
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to resize
 *  sy1                 [IN]    region in source layer to resize
 *  sx2                 [IN]    region in source layer to resize
 *  sy2                 [IN]    region in source layer to resize
 *  dx1                 [IN]    region in active layer to resize to
 *  dy1                 [IN]    region in active layer to resize to
 *  dx2                 [IN]    region in active layer to resize to
 *  dy2                 [IN]    region in active layer to resize to
 *  resizer             [IN]    resize by this resizer
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_bitblt_resized_with_resizer(
                    gdi_handle src_layer_handle, 
                    S32 sx1,
                    S32 sy1,
                    S32 sx2,
                    S32 sy2,
                    S32 dx1,
                    S32 dy1,
                    S32 dx2,
                    S32 dy2,
                    gdi_resizer_enum resizer);


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized_with_resizer_ext
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer by a specified resizer "expected_resizer".
 *  If try_until_success is true and the specified resizer failed, GDI may try other resizer to resize until success,
 *  and remember the resizer actually used in used_resizer.
 * PARAMETERS
 *  src_layer_handle        [IN]    source layer
 *  sx1                     [IN]    region in source layer to resize
 *  sy1                     [IN]    region in source layer to resize
 *  sx2                     [IN]    region in source layer to resize
 *  sy2                     [IN]    region in source layer to resize
 *  dx1                     [IN]    region in active layer to resize to
 *  dy1                     [IN]    region in active layer to resize to
 *  dx2                     [IN]    region in active layer to resize to
 *  dy2                     [IN]    region in active layer to resize to
 *  expected_resizer        [IN]    resize by this resizer
 *  expected_resizer_result [OUT]   the result of expected_resizer. 
 *  try_until_success       [IN]    if true, GDI would try other resizer to resize until resize success when expected_resizer failed.
 *  used_resizer            [OUT]   if try_until_success is true and expected_resizer failed, this is the resizer GDI actually use.
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_bitblt_resized_with_resizer_ext(
                    gdi_handle src_layer_handle, 
                    S32 sx1,
                    S32 sy1,
                    S32 sx2,
                    S32 sy2,
                    S32 dx1,
                    S32 dy1,
                    S32 dx2,
                    S32 dy2,
                    gdi_resizer_enum expected_resizer,
                    gdi_result *expected_resizer_result,
                    kal_bool try_until_success,
                    gdi_resizer_enum *used_resizer);


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt
 * DESCRIPTION
 *  bitblt the content in src_layer_handle to active layer
 *  The color format of source layer and act layer can be different.
 *  The bitblt reagion (width, height) = (sx2-sx1+1, sy2-sy1+1).
 *  This region out of act layer clipping won't be drawn.
 *  All color on source layer, include source key, will be copy to act layer.
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to bitblt
 *  sy1                 [IN]    region in source layer to bitblt
 *  sx2                 [IN]    region in source layer to bitblt
 *  sy2                 [IN]    region in source layer to bitblt
 *  dx1                 [IN]    region in active layer to bitblt to
 *  dy1                 [IN]    region in active layer to bitblt to
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_bitblt(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1);

/* IMGDEC header */
#include "gdi_imgdec.h"

#if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
extern GDI_RESULT gdi_bltdb_enable(GDI_BLTDB_ENABLE_ENUM enable);
extern GDI_RESULT gdi_bltdb_disable(void);
extern GDI_RESULT gdi_bltdb_set_blt_buffer(
            gdi_handle layer_handle,
            U8* double_buf_ptr1,
            U32 double_buf_size1,
            U8* double_buf_ptr2,
            U32 double_buf_size2);
#endif

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_set_hw_update
 * DESCRIPTION
 *  start hw update or stop hw update.
 *  remeber to set correct hw update layers before starting hw update.
 * PARAMETERS
 *  hw_update  [IN]  true means starting hw update. false means stop hw update.
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_set_hw_update(kal_bool hw_update);

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_hw_update
 * DESCRIPTION
 *  get hw update is on going or not.
 * PARAMETERS
 *  hw_update  [OUT]  true means hw update is on going.
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_get_hw_update(kal_bool *hw_update);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_layer_element
 * DESCRIPTION
 *  return the WFCDevice and WFCContext and WFCElement.
 *  WFCElement and WFCContext handle would be different between MAIN_LCD or SUBLCD.
 *  Remember to set correct active LCD before using this API.
 *
 *  Multimedia APP may need to get layer element, and pass the handle to Multimedia hw.
 *  Becuase Multimedia hw, ex, camera or video, may need to modify the layer element attribute while hw updating.
 * PARAMETERS
 *  blt_layer_index     [IN]    the index of blt layer. usually 0~5
 *  layer_element       [OUT]   return the WFCElement of the specified layer index
 *  blt_ctx             [OUT]   return the blt contex handle. It's needed when calling wfcCommit
 *  blt_dev             [OUT]   return the blt device handle. It's needed when calling wfcSetElementAttribi
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_get_layer_element(U32 blt_layer_index, kal_uint32 *layer_element, kal_uint32 *blt_ctx, kal_uint32 *blt_dev);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_get_actual_rotate_value
 * DESCRIPTION
 *  return the actual rotate value.
 *  GDI user may use "layer rotate" or "lcd rotate+rotate by layer" to rotate a layer.
 *  ("layer rotate" set by gdi_layer_set_rotate)
 *  ("lcd rotate" set by gdi_lcd_set_rotate, "rotate by layer" set by gdi_lcd_get_rotate_by_layer)
 *  If it simply use "layer rotate", we return the layer rotate value.
 *  But if it use "lcd rotate+rotate by layer", we'll return the final rotate value that gdi set to lcd driver.
 *  In DDV2, while "video seek", the hw layer will not blt to lcd, so it's not set to DDv2 element.
 *  But the video driver still have to know the layer actual rotate value to rotate the video content for MDI.
 *  So GDI provide this API to calculate the layer actual rotate value.
 * PARAMETERS
 *  layer_handle                    [IN]    layer handle
 *  layer_actual_rotate_value       [OUT]   return the actual layer rotate value
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern gdi_result gdi_layer_get_actual_rotate_value(gdi_handle layer_handle, kal_uint8 *layer_actual_rotate_value);

/*****************************************************************************
 * FUNCTION
 *  gdi_util_get_lcd_ppi
 * DESCRIPTION
 *  Get pixel per inch of the active LCD.
 * PARAMETERS
 *  ppi         : [OUT] pixel per inch of the active LCD
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if querying the ppi is successful; 
 *  GDI_FAILED if it's not supported.   
 *****************************************************************************/
extern GDI_RESULT gdi_util_get_lcd_ppi(S32 *ppi);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_is_animation
 * DESCRIPTION
 *  Check image is animtion or not from resource
 * PARAMETERS
 *  image_ptr       :[IN] image pointer from resource
 *  is_anim         :[OUT] return whether this image is animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_is_animation(U8 *image_ptr, MMI_BOOL *is_anim);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_is_animation_file
 * DESCRIPTION
 *  Check image is animtion or not from file
 * PARAMETERS
 *  image_ptr       :[IN] image pointer from file
 *  is_anim         :[OUT] return whether this image is animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_is_animation_file(U8 *image_ptr, MMI_BOOL *is_anim);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_is_animation_mem
 * DESCRIPTION
 *  Check image is animtion or not from memory
 * PARAMETERS
 *  image_type      :[IN] image type, ex. GDI_IMAGE_TYPE_GIF
 *  image_ptr       :[IN] image pointer from memory
 *  image_size      :[IN] image size
 *  frame_count     :[OUT] return whether this image is animation
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
extern GDI_RESULT gdi_image_is_animation_mem(
                   U8  image_type,
                   U8  *image_ptr,
                   S32 image_size,
                   MMI_BOOL *is_anim);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_hw_update_layer
 * DESCRIPTION
 *  set the layer as a hw update layer.
 *  hw update layer means the layer content and settings are set by multimedia hw, ex. Camera or video. 
 *  GDI won't set the layer config of hw layer to lcd, except layer offset.
 * PARAMETERS
 *  layer_handle  [IN]  the layer to be set as hw update layer
 *  is_hw_layer   [OUT] the layer is hw layer or not
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_hw_update_layer(gdi_handle layer_handle, kal_bool is_hw_layer);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_is_hw_update_layer
 * DESCRIPTION
 *  query if the layer is hw update layer.
 * PARAMETERS
 *  layer_handle  [IN]  the layer to query
 *  is_hw_layer   [OUT] the layer is hw layer or not
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_is_hw_update_layer(gdi_handle layer_handle, kal_bool *is_hw_layer);

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_blt_counter
 * DESCRIPTION
 *  return the blt counter.
 *  blt counter is the number that lcd update.
 *  UI engine use this to know their previous setting ever blt out or not.
 * PARAMETERS
 *  
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_lcd_get_blt_counter(U32 *blt_counter);

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_set_blt_rect
 * DESCRIPTION
 *  set layer blt region. Display driver will merge blt rect of the layers and
 *  blt roi, so the final blt region may exceed this rect.
 * PARAMETERS
 *  x   [IN]  x coordinate, origin is layer frame buffer
 *  y   [IN]  y coordinate, origin is layer frame buffer
 *  width   [IN] blt rect width
 *  height  [IN] blt rect height
 * RETURNS
 *  void
 *****************************************************************************/
extern GDI_RESULT gdi_layer_set_blt_rect(U16 x, U16 y, U16 width, U16 height);

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_get_refresh_rate
 * DESCRIPTION
 *  Get refresh rate of LCD
 * PARAMETERS
 *  lcd_handle  [IN] LCD handle
 * RETURNS
 *  Refresh rate of LCD; <= 0 means not available
 *****************************************************************************/
extern kal_int32 gdi_lcd_get_refresh_rate(gdi_handle lcd_handle);

/* CABC APIs */
/*****************************************************************************
 * FUNCTION
 *  gdi_cabc_reset
 * DESCRIPTION
 *  Reset the cabc mode to default value.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_cabc_reset(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_cabc_get_mode
 * DESCRIPTION
 *  Get the cabc current mode.
 * PARAMETERS
 *  void
 * RETURNS
 *  gdi_cabc_mode_enum
 *****************************************************************************/
extern gdi_cabc_mode_enum gdi_cabc_get_mode(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_cabc_set_mode
 * DESCRIPTION
 *  Set the cabc mode.
 * PARAMETERS
 *  mode        [IN]: Is the mode to set to LCM.
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_cabc_set_mode(gdi_cabc_mode_enum mode);

/*****************************************************************************
 * FUNCTION
 *  gdi_cabc_enable
 * DESCRIPTION
 *  Enable to set the cabc mode.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_cabc_enable(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_cabc_disable
 * DESCRIPTION
 *  Enable to set the cabc mode.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_cabc_disable(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_waiting_blt_finish
 * DESCRIPTION
 *  Wait last blt finish.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_waiting_blt_finish(void);

#if defined(GDI_LCD_SCANLINE_ROTATION)
/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_scanline_rotation_enable
 * DESCRIPTION
 *  Enable the current LCD scanline rotation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARK
 *  This API will only apply to active LCD.
 *****************************************************************************/
extern void gdi_lcd_scanline_rotation_enable(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_lcd_scanline_rotation_disable
 * DESCRIPTION
 *  Disable the current LCD scanline rotation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARK
 *  This API will only apply to active LCD.
 *****************************************************************************/
extern void gdi_lcd_scanline_rotation_disable(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_scanline_get_buffer
 * DESCRIPTION
 *  To share the scanline GDI buffer with VRT.
 * PARAMETERS
 *  buf_size   [IN/OUT]   The buffer size of shared buffer
 * RETURNS
 *  PU8
 *****************************************************************************/
extern PU8 gdi_scanline_get_buffer(U32* buf_size);
#endif /* GDI_LCD_SCANLINE_ROTATION */


/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt_nb_concurrent_no_blt_lock
 * DESCRIPTION
 *  Blt layers without check blt lock.
 *  
 * PARAMETERS
 *  handle0     [IN]        
 *  handle1     [IN]        
 *  handle2     [IN]        
 *  handle3     [IN]        
 *  handle4     [IN]        
 *  handle5     [IN]        
 *  x1          [IN]        
 *  y1          [IN]        
 *  x2          [IN]        
 *  y2          [IN]        
 * RETURNS
 * BOOL
 *  
 *****************************************************************************/
extern GDI_RESULT gdi_layer_blt_nb_concurrent_no_blt_lock(
                   gdi_handle handle0, 
                   gdi_handle handle1, 
                   gdi_handle handle2, 
                   gdi_handle handle3,
                   gdi_handle handle4, 
                   gdi_handle handle5,
                   S32 x1, 
                   S32 y1, 
                   S32 x2, 
                   S32 y2,
                   void (*blt_finish_callback)(void *param),
                   void *param);

extern GDI_RESULT gdi_layer_flatten_nb_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                #ifdef GDI_NB_BLT_SUPPORT
                    ,void (*finish_callback)(void *param)
                    ,void *param
                #endif
                    );

extern GDI_RESULT gdi_layer_flatten_nb_with_clip_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                #ifdef GDI_NB_BLT_SUPPORT
                    ,void (*finish_callback)(void *param)
                    ,void *param
                #endif
                    );
#ifdef GDI_NB_BLT_SUPPORT
#ifdef GDI_6_LAYERS
#define gdi_layer_flatten_with_flag(h0, h1, h2, h3, flag, nb_callback) \
    gdi_layer_flatten_with_flag_ext(h0, h1, h2, h3, 0, 0, flag, nb_callback)
#else
#define gdi_layer_flatten_with_flag(h0, h1, h2, h3, flag, nb_callback) \
    gdi_layer_flatten_with_flag_ext(h0, h1, h2, h3, flag, nb_callback)
#endif
#endif
extern GDI_RESULT gdi_layer_flatten_with_flag_ext(
                    gdi_handle handle0, 
                    gdi_handle handle1, 
                    gdi_handle handle2, 
                    gdi_handle handle3
                #ifdef GDI_6_LAYERS
                    ,gdi_handle handle4
                    ,gdi_handle handle5
                #endif
                    ,gdi_layer_flatten_flag_bitset flag
                #ifdef GDI_NB_BLT_SUPPORT
                    ,const gdi_callback_struct *nb_callback
                #endif
                    );

extern void gdi_layer_flatten_nb_wait_for_previous_finish(void);

extern kal_bool gdi_layer_flatten_get_waiting_hint(void);

/* Bit set of gdi_layer_blt_flag_enum */
typedef kal_uint32 gdi_layer_blt_flag_bit_set;

/*****************************************************************************
 * FUNCTION
 *  gdi_layer_blt_with_flag
 * DESCRIPTION
 *  Blt with control flags
 * PARAMETERS
 *  flag               : [IN] Composition of gdi_layer_blt_flag_enum
 *  nb_finish_callback : [IN] Should be NULL, not supported yet
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
extern GDI_RESULT gdi_layer_blt_with_flag(
            gdi_handle handle0, 
            gdi_handle handle1, 
            gdi_handle handle2, 
            gdi_handle handle3,
            kal_int32 x1, 
            kal_int32 y1, 
            kal_int32 x2, 
            kal_int32 y2,
            gdi_layer_blt_flag_bit_set flag,
            const gdi_callback_struct *nb_finish_callback);


/*****************************************************************************
 * FUNCTION
 *  gdi_image_9slice_get_dither
 * DESCRIPTION
 *  Get the dither of 9 slice
 * PARAMETERS
 *  void
 * RETURNS
 *  kal_bool
 *****************************************************************************/
extern kal_bool gdi_image_9slice_get_dither(void);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_9slice_set_dither
 * DESCRIPTION
 *  Set the dither of 9 slice
 * PARAMETERS
 *  using_dither    [IN] 9slice using dither or not.
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_image_9slice_set_dither(kal_bool using_dither);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_no_rotate_internal
 * DESCRIPTION
 *  Decode an JPEG image without rotation
 * PARAMETERS
 *  ox                      [IN]        
 *  oy                      [IN]        
 *  resized_width           [IN]        
 *  resized_height          [IN]        
 *  src                     [IN]         
 *  size                    [IN]        
 *  is_file                 [IN]        
 *  is_resized              [IN]        
 * RETURNS
 *  
 *****************************************************************************/
extern GDI_RESULT gdi_image_jpeg_draw_no_rotate_internal(
            S32 ox,
            S32 oy,
            S32 resized_width,
            S32 resized_height,
            U8 *src,
            U32 size,
            BOOL is_file,
            BOOL is_resized);

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_no_rotate
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  src                  : [IN]   source image buffer
 *  size                 : [IN]   source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_no_rotate(ox, oy, src, size)\
         gdi_image_jpeg_draw_no_rotate_internal(        \
                  ox, oy,                    \
                  0, 0,                      \
                  src,size,FALSE,FALSE)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_file_no_rotate
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  filename             : [IN]   image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_file_no_rotate(ox, oy, filename)\
         gdi_image_jpeg_draw_no_rotate_internal(            \
                  ox, oy,                        \
                  0, 0,                          \
                  (U8*)filename,0,TRUE,FALSE)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_no_rotate
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  resized_width        : [IN]   image width want to draw
 *  resized_height       : [IN]   image height want to draw
 *  src                  : [IN]   source image buffer
 *  size                 : [IN]   source image buffer size
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_no_rotate(                        \
                     ox, oy, resized_width, resized_height,\
                     src, size)                            \
         gdi_image_jpeg_draw_no_rotate_internal(                      \
                  ox, oy,                                  \
                  resized_width,resized_height,            \
                  src,size,FALSE,TRUE)

/*****************************************************************************
 * FUNCTION
 *  gdi_image_jpeg_draw_resized_file_no_rotate
 * DESCRIPTION
 *  draw jpeg image
 * PARAMETERS
 *  ox                   : [IN]   image draw x position
 *  oy                   : [IN]   image draw y position
 *  resized_width        : [IN]   image width want to draw
 *  resized_height       : [IN]   image height want to draw
 *  filename             : [IN]   image file name
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if succeed
 *****************************************************************************/
#define gdi_image_jpeg_draw_resized_file_no_rotate(         \
                  ox, oy,                        \
                  resized_width, resized_height, \
                  filename)                      \
         gdi_image_jpeg_draw_no_rotate_internal(            \
                  ox, oy,                        \
                  resized_width, resized_height, \
                  (U8*)filename,0,TRUE,TRUE)

/* DOM-NOT_FOR_SDK-END */


/* DOM-NOT_FOR_SDK-BEGIN */
/*****************************************************************************
 * FUNCTION
 *  gdi_util_adjust_aspect
 * DESCRIPTION
 *  Adjust the aspect by flag
 * PARAMETERS
 *  aspect_flag    : [IN]        Is the flag of aspect mode.
 *  box_x          : [IN]        Is the box x position to fit image
 *  box_y          : [IN]        Is the box y position to fit image
 *  box_width      : [IN]        Is the box width to fit image
 *  box_height     : [IN]        Is the box height to fit image
 *  image_width    : [IN]        Is the image width
 *  image_height   : [IN]        Is the image height
 *  output_x       : [OUT]       Is the output x
 *  output_y       : [OUT]       Is the output y
 *  output_w       : [OUT]       Is the output width
 *  output_h       : [OUT]       Is the output height
 * RETURNS
 *  void
 *****************************************************************************/
extern void gdi_util_adjust_aspect(
             S32 aspect_flag,
             S32 box_x,
             S32 box_y,
             S32 box_width,
             S32 box_height,
             S32 image_width,
             S32 image_height,
             S32 *output_x,
             S32 *output_y,
             S32 *output_w,
             S32 *output_h);

#ifdef __MMI_VUI_ENGINE__
extern GDI_RESULT gdi_image_get_info_from_file(
    const WCHAR *filepath,
    gdi_image_type *image_type,
    kal_int32 *width,
    kal_int32 *height,
    kal_bool *with_alpha);
#endif /* __MMI_VUI_ENGINE__ */
extern GDI_RESULT gdi_image_get_info_from_res_data(
    const kal_uint8 *res_data,
    gdi_image_type *image_type,
    kal_int32 *width,
    kal_int32 *height,
    kal_bool *with_alpha);
    

extern GDI_RESULT gdi_mem_reg_ext_allocator(gdi_mem_allocate_func alloc, gdi_mem_free_func free);

extern GDI_RESULT gdi_mem_dereg_ext_allocator(gdi_mem_allocate_func alloc, gdi_mem_free_func free);

/* DOM-NOT_FOR_SDK-END */

#ifdef __cplusplus
}
#endif

#endif /* _GDI_INCLUDE_H_ */ 


