/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gdi_
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/
#include "gdi_internal.h"
#include "gd_include.h"
#include "gd_primitive_arm.h"

#include "med_global.h"
#include "med_utility.h"

#include "rotator_enum.h"
#include "rgb_rotator_api.h"
#include "yuv_rotator_api.h"

#include "kal_general_types.h"
#include "kal_release.h"
#include "med_smalloc.h"
#include "idp_core.h"
#include "lcd_if.h"
#include "string.h"
#include "MMIDataType.h"

#include "gdi_datatype.h"
#include "gdi_const.h"
#include "gdi_features.h"
#include "gdi_include.h"
#include "gdi_mutex.h"
#include "gdi_primitive.h"
#include "gdi_imgdec_internal.h"
#include "gdi_layer.h"
#include "gdi_lcd.h"
#include "gdi_2d_engine.h"
#include "gdi_util.h"
#include "gfx_cache_switch_behavior_enum.h"
#include "rgb_resizer_api.h"

#include "gdi_image.h"
const S16 gdi_alpha_inverse_table[256] = 
{
    0, /* FORBIDDEN 255 / 0 */
    32640, 16320, 10880, 8160, 6528, 5440, 4662, 4080, 
    3626, 3264, 2967, 2720, 2510, 2331, 2176, 2040, 
    1920, 1813, 1717, 1632, 1554, 1483, 1419, 1360, 
    1305, 1255, 1208, 1165, 1125, 1088, 1052, 1020, 
    989, 960, 932, 906, 882, 858, 836, 816, 
    796, 777, 759, 741, 725, 709, 694, 680, 
    666, 652, 640, 627, 615, 604, 593, 582, 
    572, 562, 553, 544, 535, 526, 518, 510, 
    502, 494, 487, 480, 473, 466, 459, 453, 
    447, 441, 435, 429, 423, 418, 413, 408, 
    402, 398, 393, 388, 384, 379, 375, 370, 
    366, 362, 358, 354, 350, 347, 343, 340, 
    336, 333, 329, 326, 323, 320, 316, 313, 
    310, 307, 305, 302, 299, 296, 294, 291, 
    288, 286, 283, 281, 278, 276, 274, 272, 
    269, 267, 265, 263, 261, 259, 257, 255, 
    253, 251, 249, 247, 245, 243, 241, 240, 
    238, 236, 234, 233, 231, 229, 228, 226, 
    225, 223, 222, 220, 219, 217, 216, 214, 
    213, 211, 210, 209, 207, 206, 205, 204, 
    202, 201, 200, 199, 197, 196, 195, 194, 
    193, 192, 190, 189, 188, 187, 186, 185, 
    184, 183, 182, 181, 180, 179, 178, 177, 
    176, 175, 174, 173, 172, 171, 170, 170, 
    169, 168, 167, 166, 165, 164, 164, 163, 
    162, 161, 160, 160, 159, 158, 157, 156, 
    156, 155, 154, 153, 153, 152, 151, 151, 
    150, 149, 149, 148, 147, 147, 146, 145, 
    145, 144, 143, 143, 142, 141, 141, 140, 
    140, 139, 138, 138, 137, 137, 136, 136, 
    135, 134, 134, 133, 133, 132, 132, 131, 
    131, 130, 130, 129, 129, 128, 128
};


// TODO: bad style of global variables, need to be revised
/* Only gdi_screen_shot_capture can use gdi_screen_shot_info. */
#define GDI_SCREEN_SHOT_BUFFER_CF GDI_COLOR_FORMAT_16

#if defined(GDI_USING_SCREEN_SHOT_BUFFER)
    #define GDI_SCREEN_SHOT_BUFFER_SIZE (((GDI_LCD_WIDTH + 16) * (GDI_LCD_HEIGHT + 16) * GDI_MAINLCD_BIT_PER_PIXEL) >> 3) // default size
#else
    #define GDI_SCREEN_SHOT_BUFFER_SIZE 0
#endif

#if defined(GDI_USING_SCREEN_SHOT_BUFFER)

static gdi_screen_shot_info_struct gdi_screen_shot_info;
U32 gdi_screen_shot_buffer_size = GDI_SCREEN_SHOT_BUFFER_SIZE;

/*  In D-cacheable stage3, the buffer used to create layer should be non-cacheable. */
#if defined(__MTK_TARGET__)
#pragma arm section zidata = "NONCACHEDZI", rwdata = "NONCACHEDRW"
#endif
#ifndef __MTK_TARGET__
#define __align(X)
#endif
__align( __MMI_GDI_LAYER_FRAMEBUF_ALIGNMENT__) U32 gdi_screen_shot_buffer[GDI_SCREEN_SHOT_BUFFER_SIZE/4];
#if defined(__MTK_TARGET__)
#pragma arm section zidata, rwdata
#endif

#endif /* GDI_USING_SCREEN_SHOT_BUFFER */



extern KAL_ADM_ID gdi_layer_buffer_pool_id;

/*****************************************************************************
 * FUNCTION
 *  gdi_fast_semi_crc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src         [?]         
 *  size        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U32 gdi_fast_semi_crc(U8 *src, U32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    register U32 crc, temp, i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    crc = 0;
    for (i = 0; i < size; i++)
    {
        if (crc >> 15)
        {
            temp = 1;
        }
        else
        {
            temp = 0;
        }
        crc = (((crc << 1) & 0x0ffff) + temp) ^ (U32) * src;
        src++;
    }
    return crc;
}

//W06.01 Temp Solution for GDI Rotate
///To Do : Remove this when Rotate is Ready


/*****************************************************************************
 * FUNCTION
 *  gdi_catcher_get_rotate
 * DESCRIPTION
 *  
 * PARAMETERS
 *  rotate_value        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
U8 gdi_catcher_get_rotate(U8 rotate_value)
{
#if defined(GDI_USING_LAYER_ROTATE)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (rotate_value)
    {
        case LCD_LAYER_ROTATE_NORMAL:
        default:
            return GDI_LCD_LAYER_ROTATE_0;
        case LCD_LAYER_ROTATE_90:
            return GDI_LCD_LAYER_ROTATE_90;
        case LCD_LAYER_ROTATE_180:
            return GDI_LCD_LAYER_ROTATE_180;
        case LCD_LAYER_ROTATE_270:
            return GDI_LCD_LAYER_ROTATE_270;
        case LCD_LAYER_MIRROR:
            return GDI_LCD_LAYER_ROTATE_0_MIRROR;
        case LCD_LAYER_MIRROR_ROTATE_90:
            return GDI_LCD_LAYER_ROTATE_90_MIRROR;
        case LCD_LAYER_MIRROR_ROTATE_180:
            return GDI_LCD_LAYER_ROTATE_180_MIRROR;
        case LCD_LAYER_MIRROR_ROTATE_270:
            return GDI_LCD_LAYER_ROTATE_270_MIRROR;
    }
#else /* defined(GDI_USING_LAYER_ROTATE) */ 
    return GDI_LCD_LAYER_ROTATE_0;
#endif /* defined(GDI_USING_LAYER_ROTATE) */ 
}

/* W05.52 GDI Catcher Support */


/*****************************************************************************
 * FUNCTION
 *  gdi_catcher_fill_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  catcher_info        [?]     
 * RETURNS
 *  
 *****************************************************************************/
GDI_RESULT gdi_catcher_fill_info(gdi_catcher_info_struct *catcher_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ENTER_CRITICAL_SECTION(gdi_catcher_fill_info)
    S32 i = 0;

    memset(catcher_info, 0, sizeof(gdi_catcher_info_struct));
    /* W06.03 Temp Solution for GDI_LCD_SUM */
#if defined(__MMI_SUBLCD__)
    catcher_info->lcd_count = 2;    /* gdi_lcd_get_count(); */
#else 
    catcher_info->lcd_count = 1;    /* gdi_lcd_get_count(); */
#endif 
    catcher_info->layer_count = 0;

    for (i = 0; i < GDI_LAYER_TOTAL_LAYER_COUNT; i++)
    {
        if (GDI_LAYER_GET_FLAG(&GDI_LAYERS[i], GDI_LAYER_FLAG_USED))
        {
            catcher_info->layer_array[catcher_info->layer_count].layer_handle = (gdi_handle) & GDI_LAYERS[i];
            catcher_info->layer_array[catcher_info->layer_count].width = GDI_LAYERS[i].width;
            catcher_info->layer_array[catcher_info->layer_count].height = GDI_LAYERS[i].height;
            catcher_info->layer_array[catcher_info->layer_count].clipx1 = GDI_LAYERS[i].clipx1;
            catcher_info->layer_array[catcher_info->layer_count].clipy1 = GDI_LAYERS[i].clipy1;
            catcher_info->layer_array[catcher_info->layer_count].clipx2 = GDI_LAYERS[i].clipx2;
            catcher_info->layer_array[catcher_info->layer_count].clipy2 = GDI_LAYERS[i].clipy2;
            catcher_info->layer_array[catcher_info->layer_count].buf_ptr = GDI_LAYERS[i].buf_ptr;
            catcher_info->layer_array[catcher_info->layer_count].buf_ptr1 = GDI_LAYERS[i].buf_ptr1;
            catcher_info->layer_array[catcher_info->layer_count].cf = GDI_LAYERS[i].cf;
            catcher_info->layer_array[catcher_info->layer_count].bits_per_pixel = GDI_LAYERS[i].bits_per_pixel;
            catcher_info->layer_array[catcher_info->layer_count].layer_size = GDI_LAYERS[i].layer_size;
            catcher_info->layer_array[catcher_info->layer_count].offset_x = GDI_LAYERS[i].offset_x;
            catcher_info->layer_array[catcher_info->layer_count].offset_y = GDI_LAYERS[i].offset_y;
            catcher_info->layer_array[catcher_info->layer_count].source_key_value = gdi_layer_info[i].source_key;
            catcher_info->layer_array[catcher_info->layer_count].background = GDI_LAYERS[i].background;
            catcher_info->layer_array[catcher_info->layer_count].opacity_value = gdi_layer_info[i].opacity_value;
            catcher_info->layer_array[catcher_info->layer_count].rotate_value = GDI_LAYERS[i].rotate_value;
            catcher_info->layer_array[catcher_info->layer_count].opacity_enable = gdi_layer_info[i].opacity_enable;
            catcher_info->layer_array[catcher_info->layer_count].source_key_enable =
                gdi_layer_info[i].source_key_enable;
            catcher_info->layer_count++;
        }
    }
    for (i = 0; i < catcher_info->lcd_count; i++)
    {
        S32 j = 0;

        catcher_info->lcd_array[i].layer_count = 0;
        catcher_info->lcd_array[i].act_width = GDI_LCD_ARRAY[i].act_width;
        catcher_info->lcd_array[i].act_height = GDI_LCD_ARRAY[i].act_height;
        catcher_info->lcd_array[i].cf = GDI_LCD_ARRAY[i].cf;
        catcher_info->lcd_array[i].ROIx1 = GDI_LCD_ARRAY[i].blt_rect.x1;
        catcher_info->lcd_array[i].ROIy1 = GDI_LCD_ARRAY[i].blt_rect.y1;
        catcher_info->lcd_array[i].ROIx2 = GDI_LCD_ARRAY[i].blt_rect.x2;
        catcher_info->lcd_array[i].ROIy2 = GDI_LCD_ARRAY[i].blt_rect.y2;
        catcher_info->lcd_array[i].rotate_value = GDI_LCD_ARRAY[i].rotate_value;
        for (j = 0; j < GDI_LAYER_HW_LAYER_COUNT; j++)
        {
            if (GDI_LCD_ARRAY[i].blt_handle[j] != GDI_ERROR_HANDLE && GDI_LCD_ARRAY[i].blt_handle[j] != GDI_NULL_HANDLE)
            {
                S32 k = 0;

                for (k = 0; k < catcher_info->layer_count; k++)
                {
                    if (GDI_LCD_ARRAY[i].blt_handle[j] == catcher_info->layer_array[k].layer_handle)
                    {
                        catcher_info->lcd_array[i].blt_handle[catcher_info->lcd_array[i].layer_count] = k;
                        catcher_info->lcd_array[i].layer_count++;
                    }
                }
            }
        }
    }
    GDI_EXIT_CRITICAL_SECTION(gdi_catcher_fill_info)
    return GDI_SUCCEED;
}

#ifdef GDI_USING_SCREEN_SHOT_BUFFER
GDI_RESULT gdi_util_get_screenshot_region(
                gdi_screen_shot_info_struct *out_screenshot,
                gdi_handle lcd_handle,
                kal_int32 x,
                kal_int32 y,
                kal_int32 width,
                kal_int32 height,
                void *buffer, /* Should be non-cacheable */
                kal_uint32 buffer_size,
                gdi_color_format expect_cf,
                kal_uint32 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_act_lcd = GDI_NULL_HANDLE;
    kal_uint32 lcd_rotate;
    gdi_handle result_layer;
    gdi_handle layer_hd[6];
    GDI_RESULT result = GDI_FAILED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ASSERT((lcd_handle == GDI_LCD_MAIN_LCD_HANDLE) || (lcd_handle == GDI_LCD_SUB_LCD_HANDLE));
    GDI_ASSERT(out_screenshot != NULL);

    memset(out_screenshot, 0, sizeof(gdi_screen_shot_info_struct));
    
    GDI_ENTER_CRITICAL_SECTION(gdi_util_get_screenshot_region)
    gdi_lcd_get_active(&old_act_lcd);
    gdi_lcd_set_active(lcd_handle);

    do {
        if (!gdi_layer_flatten_is_ready())
        {
            break;
        }
    
        gdi_layer_get_blt_layer_ext(
            &layer_hd[0], &layer_hd[1], &layer_hd[2], &layer_hd[3]
        #ifdef GDI_6_LAYERS
            , &layer_hd[4], &layer_hd[5]
        #endif
            );

        #define REMOVE_UNUSED_LAYERS(layer_hd) \
            do { \
                if (layer_hd != 0 && !GDI_LAYER_GET_FLAG((layer_hd), GDI_LAYER_FLAG_USED)) \
                    layer_hd = 0; \
            } while (0)

            REMOVE_UNUSED_LAYERS(layer_hd[0]);
            REMOVE_UNUSED_LAYERS(layer_hd[1]);
            REMOVE_UNUSED_LAYERS(layer_hd[2]);
            REMOVE_UNUSED_LAYERS(layer_hd[3]);
            REMOVE_UNUSED_LAYERS(layer_hd[4]);
            REMOVE_UNUSED_LAYERS(layer_hd[5]);

        #undef REMOVE_UNUSED_LAYERS

        result = gdi_layer_create_cf_using_outside_memory(
                    expect_cf,
                    x,
                    y,
                    width,
                    height,
                    &result_layer,
                    (U8*)buffer,
                    (S32)buffer_size);
        if (result != GDI_SUCCEED) break;

        lcd_rotate = gdi_lcd_get_rotate();
        gdi_layer_push_and_set_active(result_layer);
            gdi_layer_set_rotate(lcd_rotate);
            result = gdi_layer_flatten_ext(
                layer_hd[0], layer_hd[1], layer_hd[2], layer_hd[3]
            #ifdef GDI_6_LAYERS
                , layer_hd[4], layer_hd[5]
            #endif
                );
        gdi_layer_pop_and_restore_active();

        gdi_layer_free(result_layer);

        if (result == GDI_SUCCEED)
        {
            out_screenshot->header_size = sizeof(gdi_screen_shot_info_struct);
            out_screenshot->buf_width = width;
            out_screenshot->buf_height = height;
            out_screenshot->color_format = expect_cf;
            out_screenshot->buf_ptr = (U8*)buffer;
            out_screenshot->buf_size = buffer_size;
        }
    } while (0);

    gdi_lcd_set_active(old_act_lcd);
    GDI_EXIT_CRITICAL_SECTION(gdi_util_get_screenshot_region)

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_util_get_screenshot
 * DESCRIPTION
 *  Screenshot to given buffer.
 * PARAMETERS
 *  out_screenshot      [OUT] Screenshot info structure
 *                            The buf_ptr field will be given buffer
 *  lcd_handle          [IN]  GDI_LCD_MAIN_LCD_HANDLE or GDI_LCD_SUB_LCD_HANDLE
 *  buffer              [IN]  Buffer. Should be non-cacheable
 *  buffer_size         [IN]  Size of buffer, should be large enough for
 *                            whole screen.
 *  expect_cf           [IN]  Expected color format of snapshot
 *  flag                [IN]  0 for default
 * RETURNS
 *  GDI_SUCCEED if success; otherwise return the cause
 *  To check the return value is mandatory.
 *****************************************************************************/
static GDI_RESULT gdi_util_get_screenshot(
                gdi_screen_shot_info_struct *out_screenshot,
                gdi_handle lcd_handle,
                void *buffer, /* Should be non-cacheable */
                kal_uint32 buffer_size,
                gdi_color_format expect_cf,
                kal_uint32 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 lcd_width, lcd_height;
    GDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ENTER_CRITICAL_SECTION(gdi_util_get_screenshot)
    
        gdi_lcd_get_dimension(&lcd_width, &lcd_height);
    ret = gdi_util_get_screenshot_region(
        out_screenshot,
        lcd_handle,
                    0,
                    0,
                    lcd_width,
                    lcd_height,
        buffer,
        buffer_size,
        expect_cf,
        flag);

    GDI_EXIT_CRITICAL_SECTION(gdi_util_get_screenshot)

    return ret;
}
#endif /* GDI_USING_SCREEN_SHOT_BUFFER */

/*****************************************************************************
 * FUNCTION
 *  gdi_screen_shot_capture
 * DESCRIPTION
 *  output screen capture information
 * PARAMETERS
 *  lcd_handle       [IN]    GDI_LCD_MAIN_LCD_HANDLE or GDI_LCD_SUB_LCD_HANDLE
 *  flag             [IN]    not used currently
 * RETURNS
 *  return gdi_screen_shot_info_struct
 *  NOTE: call GDI_LOCK before calling this API, 
 *        call GDI_UNLOCK after finishing using the buf pointer.
 *****************************************************************************/
gdi_screen_shot_info_struct* gdi_screen_shot_capture(
                				gdi_handle lcd_handle,
                				U32 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(GDI_USING_SCREEN_SHOT_BUFFER)

    /* If return NULL, please check whether GDI_SCREEN_SHOT_BUFFER is
       switched on in the make file */
    return NULL;
    
#else

    {
        GDI_RESULT result;
    
        result = gdi_util_get_screenshot(
                    &gdi_screen_shot_info,
                    lcd_handle,
                    gdi_screen_shot_buffer,
                    gdi_screen_shot_buffer_size,
                    GDI_SCREEN_SHOT_BUFFER_CF,
                    flag);

        if (result == GDI_SUCCEED)
        {
            return (&gdi_screen_shot_info);
        }
    }

    return NULL;

#endif
    
}

/*****************************************************************************
 * FUNCTION
 *  gdi_util_fit_box
 * DESCRIPTION
 *  play animation for certain frame by image ptr
 * PARAMETERS
 *  mode            [IN]        
 *  bbox_width      [IN]        
 *  bbox_height     [IN]        
 *  src_width       [IN]        
 *  src_height      [IN]        
 *  offset_x        [IN]        
 *  offset_y        [IN]        
 *  dest_width      [IN]        
 *  dest_height     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_util_fit_box(
        S32 mode,
        S32 bbox_width,
        S32 bbox_height,
        S32 src_width,
        S32 src_height,
        S32 *offset_x,
        S32 *offset_y,
        S32 *dest_width,
        S32 *dest_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint64 product1 = 0, product2 = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GDI_UTIL_MODE_LONG_SIDE_FIT == mode || GDI_UTIL_MODE_NO_RESIZE_OR_LONG_SIDE_FIT == mode 
        || GDI_UTIL_MODE_SHORT_SIDE_FIT == mode || GDI_UTIL_MODE_NO_RESIZE_OR_SHORT_SIDE_FIT == mode)
    {
        product1 = src_width * bbox_height;
        product2 = src_height * bbox_width;
        if (src_width == 0 || src_height == 0 || bbox_width == 0 || bbox_height == 0)
        {
            *dest_width = 0;
            *dest_height = 0;
        }
        else if ((product1 > product2 && (GDI_UTIL_MODE_LONG_SIDE_FIT == mode || GDI_UTIL_MODE_NO_RESIZE_OR_LONG_SIDE_FIT == mode))
                 || (product1 < product2 && (GDI_UTIL_MODE_SHORT_SIDE_FIT == mode || GDI_UTIL_MODE_NO_RESIZE_OR_SHORT_SIDE_FIT == mode)))
        {
            *dest_width = bbox_width;
            *dest_height = product2 / src_width;
        }
        else
        {
            *dest_width = product1 / src_height;
            *dest_height = bbox_height;
        }
    }

    if (mode == GDI_UTIL_MODE_NO_RESIZE_OR_LONG_SIDE_FIT || mode == GDI_UTIL_MODE_NO_RESIZE_OR_SHORT_SIDE_FIT)
    {
        if (src_width <= bbox_width && src_height <= bbox_height)
        {
            *dest_width = src_width;
            *dest_height = src_height;
        }
    }

    /* non-ratio resize if different is small. */
    {
        int diff;

        diff = GDI_ABS(*dest_height - bbox_height);
        if (diff <= 2 && *dest_width == bbox_width)
        {
            *dest_height = bbox_height;
        }

        diff = GDI_ABS(*dest_width - bbox_width);
        if (diff <= 2 && *dest_height == bbox_height)
        {
            *dest_width = bbox_width;
        }
    }

    *offset_x = (bbox_width - *dest_width) / 2;
    *offset_y = (bbox_height - *dest_height) / 2;

    if(*dest_width==0) *dest_width = 1;
    if(*dest_height==0) *dest_height = 1;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_util_fit_bbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  bbox_width      [IN]        
 *  bbox_height     [IN]        
 *  src_width       [IN]        
 *  src_height      [IN]        
 *  offset_x        [?]         
 *  offset_y        [?]         
 *  dest_width      [?]         
 *  dest_height     [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_util_fit_bbox(
        S32 bbox_width,
        S32 bbox_height,
        S32 src_width,
        S32 src_height,
        S32 *offset_x,
        S32 *offset_y,
        S32 *dest_width,
        S32 *dest_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_util_fit_box(
        GDI_UTIL_MODE_LONG_SIDE_FIT,
        bbox_width,
        bbox_height,
        src_width,
        src_height,
        offset_x,
        offset_y,
        dest_width,
        dest_height);
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_util_check_decoder_cap
 * DESCRIPTION
 *  check gdi decoder's capability
 * PARAMETERS
 *  image_type          [IN]        
 *  image_width         [IN]        
 *  image_height        [IN]        
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
GDI_RESULT gdi_image_util_check_decoder_cap(U16 image_type, S32 image_width, S32 image_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (image_type == GDI_IMAGE_TYPE_JPG_FILE)
    {
    #if defined(GDI_USING_HW_JPEG) || defined(GDI_USING_SW_JPEG)
        return GDI_SUCCEED;
    #else 
        return GDI_FAILED;
    #endif 
    }
    else
    {
        return GDI_SUCCEED;
    }
}

S32 gdi_ucs2_stricmp(U16 *s1,U16 *s2)
{
	GDI_DEBUG_ASSERT(!((U32)s1 & 0x01));
	GDI_DEBUG_ASSERT(!((U32)s2 & 0x01));

	while (1)
	{
        U32 cmp = (U32)*s1 ^ (U32)*s2;
        if(cmp)
            if(cmp != 32 || 'A'>*s1 || *s1>'z' ||  'A'>*s2 || *s2>'z' )
                break;
		s2++;
		if ( *s1++=='\0' )
			return(0);
	}
      
   return( *s1 - *s2 );
}

static U32 gdi_util_convert_cf_from_vcf(U8 vcf)
{
    U32 cf;
    switch(vcf)
    {
        case GDI_COLOR_FORMAT_16:
            cf = RESIZER_COLOR_FORMAT_ENUM_RGB565;
            break;
        case GDI_COLOR_FORMAT_24:
            cf = RESIZER_COLOR_FORMAT_ENUM_RGB888;
            break;
        case GDI_COLOR_FORMAT_32:
            cf = RESIZER_COLOR_FORMAT_ENUM_ARGB8888;
            break;
        case GDI_COLOR_FORMAT_32_PARGB:
            cf = RESIZER_COLOR_FORMAT_ENUM_PARGB8888;
            break;
        case GDI_COLOR_FORMAT_PARGB6666:
            cf = RESIZER_COLOR_FORMAT_ENUM_PARGB6666;
            break;
        default:
            cf = RESIZER_COLOR_FORMAT_ENUM_UNSUPPORTED;
            break;
    }
    return cf;
}
/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized_with_resizer_ext_internal
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer by a specified resizer "expected_resizer".
 *  If try_until_success is true and the specified resizer failed, GDI may try other resizer to resize until success,
 *  and remember the resizer actually used in used_resizer.
 * PARAMETERS
 *  src_layer_handle        [IN]    source layer
 *  sx1                     [IN]    region in source layer to resize
 *  sy1                     [IN]    region in source layer to resize
 *  sx2                     [IN]    region in source layer to resize
 *  sy2                     [IN]    region in source layer to resize
 *  dx1                     [IN]    region in active layer to resize to
 *  dy1                     [IN]    region in active layer to resize to
 *  dx2                     [IN]    region in active layer to resize to
 *  dy2                     [IN]    region in active layer to resize to
 *  expected_resizer        [IN]    resize by this resizer
 *  expected_resizer_result [OUT]   the result of expected_resizer. 
 *  try_until_success       [IN]    if true, GDI would try other resizer to resize until resize success when expected_resizer failed.
 *  used_resizer            [OUT]   if try_until_success is true and expected_resizer failed, this is the resizer GDI actually use.
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
static GDI_RESULT gdi_bitblt_resized_with_resizer_ext_internal(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1,
                S32 dx2,
                S32 dy2,
                RESIZER_MODE_ENUM resizer_mode,
                RESIZER_QUALITY_ENUM resizer_quality)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_layer_struct *src_layer = (gdi_layer_struct*)src_layer_handle;
    gdi_lcd_layer_struct *src_layer_info = &(gdi_layer_info[src_layer->id]);
    U8 *src_buf;
    U32 src_cf = 0;
    U8 *dst_buf;
    U32 dst_cf = 0;
    
    GDI_RESULT ret_value = GDI_SUCCEED;
    
    /* RGB resizer parameters */
    RGB_RESIZER_HANDLE_STRUCT *resizerHandle;
    RESIZER_STATUS_ENUM status = RESIZER_STATUS_OK;
    
    kal_uint32 srcWidth, srcHeight;
    kal_uint32 dstWidth, dstHeight;
    
    kal_int32 src_bufsize, dst_bufsize;
    kal_int32 dstClipX, dstClipY;
    kal_uint32 srcWindowWidth, srcWindowHeight;
    kal_uint32 dstClipWidth, dstClipHeight;
    kal_uint32 dstWindowWidth, dstWindowHeight;
    kal_bool dstClipWindowEnable = KAL_FALSE;

    kal_uint32 intMemBest = 0, intMemMin = 0;
    kal_uint32 extMemBest = 0, extMemMin = 0;
    
    void *intMemAddr = NULL;
    void *extMemAddr = NULL;
    kal_bool intMem_isExt = KAL_FALSE;
	S32 tx1, tx2, ty1, ty2;
	S32 start_time = 0, decode_ms = 0;



    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_TRACE(GDI_TRC_RR, GDI_LAYER_RESIZER_ENTER,//[gdi_bitblt_resized_with_resizer_ext_internal]: Enter - mode:%d quality:%d Src-layer:%x x1:%d y1:%d x2:%d y2:%d Dst-x1:%d y1:%d x2:%d y2:%d
        resizer_mode, resizer_quality,
        sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
    GDI_ENTER_CRITICAL_SECTION(gdi_bitblt_resized_with_resizer_ext_internal)

    do
    {
        src_buf = src_layer->buf_ptr;
        srcWidth = src_layer->width;
        srcHeight = src_layer->height;
        srcWindowWidth = sx2 - sx1 + 1;
        srcWindowHeight = sy2 - sy1 + 1;
        
        dst_buf = gdi_act_layer->buf_ptr;
        dstWidth = gdi_act_layer->width;
        dstHeight = gdi_act_layer->height;
        dstWindowWidth = dx2 - dx1 + 1;
        dstWindowHeight = dy2 - dy1 + 1;

        src_bufsize = src_layer->layer_size;
        dst_bufsize = gdi_act_layer->layer_size;

        /* return GDI_FAILED if area is out of layer region */
        tx1 = sx1;
        tx2 = sx2;
        ty1 = sy1;
        ty2 = sy2;
        GDI_CLIP_TWO_RECT(tx1, ty1, tx2, ty2, 0, 0, srcWidth - 1, srcHeight - 1, GDI_RETURN(GDI_FAILED));
        if ((tx1 != sx1) || (tx2 != sx2) || (ty1 != sy1) || (ty2 != sy2))
        {
            ret_value = GDI_FAILED;
            break;
        }

        src_cf = gdi_util_convert_cf_from_vcf(src_layer->vcf);
        dst_cf = gdi_util_convert_cf_from_vcf(gdi_act_layer->vcf);
        if (0 == src_cf || 0 == dst_cf)
        {
            ret_value = GDI_FAILED;
        }
        
        if (GDI_SUCCEED != ret_value) {break;}

        /* dest clip */
        {
            tx1 = dx1;
            tx2 = dx2;
            ty1 = dy1;
            ty2 = dy2;
            /* return GDI_SUCCEED if dest clip is out of layer clip */
            GDI_CLIP_TWO_RECT(
                    tx1, 
                    ty1, 
                    tx2, 
                    ty2, 
                    gdi_act_layer->clipx1,
                    gdi_act_layer->clipy1, 
                    gdi_act_layer->clipx2, 
                    gdi_act_layer->clipy2, 
                    GDI_RETURN(GDI_SUCCEED));


            dstClipWindowEnable = KAL_TRUE;
            dstClipX = gdi_act_layer->clipx1;
            dstClipY = gdi_act_layer->clipy1;
            dstClipWidth= gdi_act_layer->clipx2 - gdi_act_layer->clipx1 + 1;
            dstClipHeight = gdi_act_layer->clipy2 - gdi_act_layer->clipy1 + 1;
        }

        ///rgb Resizer api flow

        status = rgbResizerGetHandle(&resizerHandle, resizer_mode, resizer_quality);
        if (RESIZER_STATUS_OK != status)
        {
            GDI_TRACE(GDI_TRC_PRIMI_I, GDI_UTIL_RESIZER_FAIL, status, 100);
            ret_value = GDI_FAILED;
                break;
        }

        if (gdi_image_codec_get_flag() & GDI_IMAGE_CODEC_FLAG_DISABLE_CACHE_SWITCH)
        {
            rgbResizerSetDstBufferSwitchBehavior(resizerHandle, GFX_CACHE_SWITCH_BEHAVIOR_NOT_SWITCH);
        }

        rgbResizerSetCallbackFunction(resizerHandle, NULL);

        rgbResizerSetSrcBufferInfo(resizerHandle, (RESIZER_COLOR_FORMAT_ENUM)src_cf, (void *) src_buf, src_bufsize, srcWidth, srcHeight);
        rgbResizerSetDstBufferInfo(resizerHandle, (RESIZER_COLOR_FORMAT_ENUM)dst_cf, (void *) dst_buf, dst_bufsize, dstWidth, dstHeight);

        rgbResizerSetSrcWindow(resizerHandle, sx1, sy1, srcWindowWidth, srcWindowHeight);
        rgbResizerSetDstWindow(resizerHandle, dx1, dy1, dstWindowWidth, dstWindowHeight);
        rgbResizerSetDstClipWindow(resizerHandle, dstClipWindowEnable, dstClipX, dstClipY, dstClipWidth, dstClipHeight);

        rgbResizerSetSrcKey(
            resizerHandle,
            src_layer_info->source_key_enable,
            src_layer_info->source_key);
            
        rgbResizerSetColorReplacement(resizerHandle, KAL_FALSE, 0, 0);
        if (((dstWindowWidth != 1) && (dstWindowHeight != 1)) &&
            (srcWindowWidth != dstWindowWidth || srcWindowHeight != dstWindowHeight || src_cf != dst_cf))
        {
            rgbResizerSetDithering(resizerHandle, KAL_TRUE);
	    }
        rgbResizerCheckAbortFunction(resizerHandle, NULL);

        rgbResizerQueryWorkingMemory(resizerHandle, &intMemBest, &intMemMin, &extMemBest, &extMemMin);

        if (extMemBest)
        {
            while (1)
            {
                extMemAddr= (void *)gdi_alloc_ext_mem(extMemBest);
                if ((extMemAddr!= NULL) || (extMemBest== extMemMin))
                {
                    break;
                }
                extMemBest= extMemBest>> 1;
                if (extMemBest< extMemMin)
                {
                    extMemBest= extMemMin;
                }
            }
        
            if (!extMemAddr)
            {
                ret_value= GDI_IMAGE_ENCODER_ERR_MEMORY_NOT_ENOUGH;
                break;
            }
        }

        /* in general case, intMemBest==0 and MDP take care of alloc int mem */
        if (intMemBest)
        {
            while(1)
            {
                intMemAddr= (void *)med_alloc_int_mem(intMemBest);
                if ((intMemAddr!= NULL) || (intMemBest== intMemMin))
                {
                    break;
                }

                intMemBest = intMemBest>> 1;
                if (intMemBest< intMemMin)
                {
                    intMemBest= intMemMin;
                }
            }

            if (!intMemAddr)
            {
                intMemAddr= (void *)gdi_alloc_ext_mem(intMemBest);
                intMem_isExt = KAL_TRUE;
                if (!intMemAddr)
                {
                    ret_value= GDI_IMAGE_ENCODER_ERR_MEMORY_NOT_ENOUGH;
                    GDI_TRACE(GDI_TRC_PRIMI_I, GDI_UTIL_RESIZER_FAIL, status, 200);
                    break;
                }
            }
        }

        rgbResizerSetWorkingMemory(resizerHandle, intMemAddr, intMemBest, extMemAddr, extMemBest);
    
        start_time = drv_get_current_time();
        status = rgbResizerStart(&resizerHandle);
        if (RESIZER_STATUS_OK != status)
        {
            ret_value = GDI_FAILED;
        }
        else
        {
            status = RESIZER_STATUS_BUSY;
            while(RESIZER_STATUS_BUSY == status)
            {
                status = rgbResizerGetStatus(resizerHandle);
                switch(status)
                {
                    case RESIZER_STATUS_COMPLETE:
                         /// resizing is done
                        ret_value = GDI_SUCCEED;
                        break;

                    default:
                        /// there are some error with this resizing
                        GDI_TRACE(GDI_TRC_PRIMI_I, GDI_UTIL_RESIZER_FAIL, status, 300);
                        ret_value = GDI_FAILED;
                        break;
                }
            }
        }
        decode_ms = drv_get_duration_ms(start_time);

        rgbResizerReleaseHandle(resizerHandle);
    }while(0);

    if (extMemAddr)
    {

        gdi_free_ext_mem(&extMemAddr);
    }

    if (intMemAddr)
    {
        if (intMem_isExt)
        {
            gdi_free_ext_mem(&intMemAddr);
        }
        else
        {
            med_free_int_mem(&intMemAddr);
        }
    }
    
    GDI_EXIT_CRITICAL_SECTION(gdi_bitblt_resized_with_resizer_ext_internal)
    GDI_TRACE(GDI_TRC_RR, GDI_LAYER_RESIZER_LEAVE,//[gdi_bitblt_resized_with_resizer_ext_internal]: Leave - ret:%d duration:%d
        ret_value, decode_ms);
    return ret_value;
    
}


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized_with_resizer_ext
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer by a specified resizer "expected_resizer".
 *  If try_until_success is true and the specified resizer failed, GDI may try other resizer to resize until success,
 *  and remember the resizer actually used in used_resizer.
 * PARAMETERS
 *  src_layer_handle        [IN]    source layer
 *  sx1                     [IN]    region in source layer to resize
 *  sy1                     [IN]    region in source layer to resize
 *  sx2                     [IN]    region in source layer to resize
 *  sy2                     [IN]    region in source layer to resize
 *  dx1                     [IN]    region in active layer to resize to
 *  dy1                     [IN]    region in active layer to resize to
 *  dx2                     [IN]    region in active layer to resize to
 *  dy2                     [IN]    region in active layer to resize to
 *  expected_resizer        [IN]    resize by this resizer
 *  expected_resizer_result [OUT]   the result of expected_resizer. 
 *  try_until_success       [IN]    if true, GDI would try other resizer to resize until resize success when expected_resizer failed.
 *  used_resizer            [OUT]   if try_until_success is true and expected_resizer failed, this is the resizer GDI actually use.
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
GDI_RESULT gdi_bitblt_resized_with_resizer_ext(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1,
                S32 dx2,
                S32 dy2,
                gdi_resizer_enum expected_resizer,
                gdi_result *expected_resizer_result,
                kal_bool try_until_success,
                gdi_resizer_enum *used_resizer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;
    gdi_resizer_enum curr_resizer = expected_resizer;
    gdi_resizer_enum next_resizer;
    RESIZER_MODE_ENUM resizer_mode;
    RESIZER_QUALITY_ENUM resizer_quality;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ENTER_CRITICAL_SECTION(gdi_bitblt_resized_with_resizer_ext)

    /* When GDI_RESIZER_DEFAULT, try each resizer until resize success. Strat from Hw resizer. */
    if (expected_resizer == GDI_RESIZER_DEFAULT)
    {
        try_until_success = KAL_TRUE;
        curr_resizer = GDI_RESIZER_HW_QUALITY_HIGH;
    }

    while(1)
    {
        next_resizer = GDI_RESIZER_DEFAULT;
        
        switch(curr_resizer)
        {
            /* use HW to resize, if no hw, use the GDI_RESIZER_SW_PERFORMANCE_HIGH resizer.*/
            /* No quality parameter for HW */
            case GDI_RESIZER_HW_QUALITY_HIGH:
            case GDI_RESIZER_HW_QUALITY_MEDIUM:
            case GDI_RESIZER_HW_QUALITY_LOW:
                resizer_mode = RESIZER_MODE_HW;
                resizer_quality = RESIZER_QUALITY_HIGH;
                next_resizer = GDI_RESIZER_SW_QUALITY_HIGH;
                break;

            case GDI_RESIZER_SW_QUALITY_HIGH:
                resizer_mode = RESIZER_MODE_SW;
                resizer_quality = RESIZER_QUALITY_HIGH;
                next_resizer = GDI_RESIZER_SW_QUALITY_MEDIUM;
                break;

            case GDI_RESIZER_SW_QUALITY_MEDIUM:
                resizer_mode = RESIZER_MODE_SW;
                resizer_quality = RESIZER_QUALITY_MEDIUM;
                next_resizer = GDI_RESIZER_SW_QUALITY_LOW;
                break;

            case GDI_RESIZER_SW_QUALITY_LOW:
                resizer_mode = RESIZER_MODE_SW;
                resizer_quality = RESIZER_QUALITY_LOW;
                next_resizer = GDI_RESIZER_END;
                break;

            default:
                GDI_ASSERT(0);
                break;
        }
        ret = gdi_bitblt_resized_with_resizer_ext_internal(src_layer_handle, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2, resizer_mode, resizer_quality);
        if (((expected_resizer == GDI_RESIZER_DEFAULT) || (curr_resizer == expected_resizer)) && 
            (expected_resizer_result != NULL))
        {
            /* remeber the return value of expected_reszier to know why we try the next resizer. */
            *expected_resizer_result = ret;
        }

        if(try_until_success && (ret != GDI_SUCCEED) && (next_resizer != GDI_RESIZER_END))
        {
            /* try next resizer */
            curr_resizer = next_resizer;
        }
        else
        {
            if (used_resizer != NULL)
            {
                *used_resizer = curr_resizer;   /* remeber the last resizer that we used. */
                
                /* if (!try_until_success), used_reszier sould equal to expected_reszier */
                if ((!try_until_success) && (expected_resizer != GDI_RESIZER_DEFAULT))
                {
                    GDI_ASSERT(*used_resizer == expected_resizer);
                }
            }
            break;
        }
    }
    
    GDI_EXIT_CRITICAL_SECTION(gdi_bitblt_resized_with_resizer_ext)
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized_with_resizer
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer by a specified resizer.
 *  If the specified resizer failed, GDI may try other resizer to resize until success.
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to resize
 *  sy1                 [IN]    region in source layer to resize
 *  sx2                 [IN]    region in source layer to resize
 *  sy2                 [IN]    region in source layer to resize
 *  dx1                 [IN]    region in active layer to resize to
 *  dy1                 [IN]    region in active layer to resize to
 *  dx2                 [IN]    region in active layer to resize to
 *  dy2                 [IN]    region in active layer to resize to
 *  resizer             [IN]    resize by this resizer
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
GDI_RESULT gdi_bitblt_resized_with_resizer(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1,
                S32 dx2,
                S32 dy2,
                gdi_resizer_enum resizer)
{
    gdi_result ret;
    gdi_resizer_enum used_resizer = GDI_RESIZER_DEFAULT;
    gdi_result expected_result = GDI_SUCCEED;
    
    ret = gdi_bitblt_resized_with_resizer_ext(src_layer_handle, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2, resizer, &expected_result, KAL_TRUE, &used_resizer);
    
    return ret; 
}


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_resized
 * DESCRIPTION
 *  resize the content in src_layer_handle to active layer
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to resize
 *  sy1                 [IN]    region in source layer to resize
 *  sx2                 [IN]    region in source layer to resize
 *  sy2                 [IN]    region in source layer to resize
 *  dx1                 [IN]    region in active layer to resize to
 *  dy1                 [IN]    region in active layer to resize to
 *  dx2                 [IN]    region in active layer to resize to
 *  dy2                 [IN]    region in active layer to resize to
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
GDI_RESULT gdi_bitblt_resized(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1,
                S32 dx2,
                S32 dy2)
{
    return gdi_bitblt_resized_with_resizer(src_layer_handle, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2, GDI_RESIZER_DEFAULT);
}


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt_sw
 * DESCRIPTION
 *  bitblt the content in src_layer_handle to active layer
 *  The color format of source layer and act layer can be different.
 *  The bitblt reagion (width, height) = (sx2-sx1+1, sy2-sy1+1).
 *  This region out of act layer clipping won't be drawn.
 *  All color on source layer, include source key, will be copy to act layer.
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to bitblt
 *  sy1                 [IN]    region in source layer to bitblt
 *  sx2                 [IN]    region in source layer to bitblt
 *  sy2                 [IN]    region in source layer to bitblt
 *  dx1                 [IN]    region in active layer to bitblt to
 *  dy1                 [IN]    region in active layer to bitblt to
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
GDI_RESULT gdi_bitblt_sw(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;
    gdi_layer_struct *src_layer = (gdi_layer_struct*)src_layer_handle;
    gdi_img_buf_struct dst_buf, src_buf;
    gdi_rect_struct dest_area, src_area;
    S32 bitblt_width = sx2 - sx1 + 1;
    S32 bitblt_height = sy2 - sy1 + 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ENTER_CRITICAL_SECTION(gdi_bitblt_sw)
    
    do
    {
        dest_area.x1 = dx1;
        dest_area.y1 = dy1;
        dest_area.x2 = dx1 + bitblt_width - 1;
        dest_area.y2 = dy1 + bitblt_height - 1;
        ret = gdi_img_buf_prepare_img_buf_struct(
                &dst_buf,
                &dest_area,
                gdi_act_layer->buf_ptr,
                (S32)gdi_act_layer->width,
                (S32)gdi_act_layer->bits_per_pixel >> 3,
                (U32)gdi_act_layer->cf,
                (S32)gdi_act_layer->clipx1,
                (S32)gdi_act_layer->clipy1,
                (S32)gdi_act_layer->clipx2,
                (S32)gdi_act_layer->clipy2);
        if (ret == GDI_FAILED)  // null clip
        {
            ret = GDI_SUCCEED;
            break;
        }

        src_area.x1 = sx1 - (dx1 - dest_area.x1);
        src_area.y1 = sy1 - (dy1 - dest_area.y1);
        src_area.x2 = 0;  // don't care
        src_area.y2 = 0;  // don't care
        ret = gdi_img_buf_prepare_img_buf_struct(
                &src_buf,
                &src_area,
                src_layer->buf_ptr,
                (S32)src_layer->width,
                (S32)src_layer->bits_per_pixel >> 3,
                (U32)src_layer->cf,
                -1, -1, -1, -1);

        /* copy from src_layer */
        gdi_img_buf_copy(
            &dst_buf, 
            &src_buf,
            dest_area.x2 - dest_area.x1 + 1,
            dest_area.y2 - dest_area.y1 + 1);

        ret = GDI_SUCCEED;
    } while(0);

    GDI_EXIT_CRITICAL_SECTION(gdi_bitblt_sw)
    return ret;
}


#if defined(GDI_USING_2D_ENGINE_V3)
static GDI_RESULT gdi_bitblt_hw(
                   gdi_handle src_layer_handle, 
                   S32 sx1,
                   S32 sy1,
                   S32 sx2,
                   S32 sy2,
                   S32 dx1,
                   S32 dy1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;
    S32 width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ENTER_CRITICAL_SECTION(gdi_bitblt_hw)

    do
    {
        width = (U16)(sx2 - sx1 + 1);
        height = (U16)(sy2 - sy1 + 1);
        if (width == 0 || height == 0)
        {
            ret = GDI_SUCCEED;
            break;
        }
        gdi_2d_begin();

        do
        {
            ret = gdi_2d_set_layer_as_src_bitblt_buffer(src_layer_handle);
            if (GDI_SUCCEED != ret)
            {
                break;
            }
            ret = gdi_2d_set_src_bitblt_rect(
                sx1,
                sy1,
                width,
                height);
            if (GDI_SUCCEED != ret)
            {
                break;
            }
            gdi_2d_set_dest_bitblt_rect(
                dx1,
                dy1,
                width,
                height);
            gdi_2d_rotate(GDI_TRANSFORM_NONE);
            ret = GDI_SUCCEED;
        }while (0);

        gdi_2d_end();
    }while (0);

    GDI_EXIT_CRITICAL_SECTION(gdi_bitblt_hw)
    return ret;
}
#endif  /* defined(GDI_USING_HW_RESIZER_V2) */


/*****************************************************************************
 * FUNCTION
 *  gdi_bitblt
 * DESCRIPTION
 *  bitblt the content in src_layer_handle to active layer
 *  The color format of source layer and act layer can be different.
 *  The bitblt reagion (width, height) = (sx2-sx1+1, sy2-sy1+1).
 *  This region out of act layer clipping won't be drawn.
 * PARAMETERS
 *  src_layer_handle    [IN]    source layer
 *  sx1                 [IN]    region in source layer to bitblt
 *  sy1                 [IN]    region in source layer to bitblt
 *  sx2                 [IN]    region in source layer to bitblt
 *  sy2                 [IN]    region in source layer to bitblt
 *  dx1                 [IN]    region in active layer to bitblt to
 *  dy1                 [IN]    region in active layer to bitblt to
 * RETURNS
 *  GDI_RESULT
 *****************************************************************************/
GDI_RESULT gdi_bitblt(
                gdi_handle src_layer_handle, 
                S32 sx1,
                S32 sy1,
                S32 sx2,
                S32 sy2,
                S32 dx1,
                S32 dy1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(GDI_USING_2D_ENGINE_V3) || defined(GDI_USING_2D_ENGINE_V2) || defined(GDI_USING_2D_ENGINE)
    ret = gdi_bitblt_hw(
              src_layer_handle,
              sx1,
              sy1,
              sx2,
              sy2,
              dx1,
              dy1);
#endif
    if (ret != GDI_SUCCEED)
    {
        ret = gdi_bitblt_sw(
                  src_layer_handle,
                  sx1,
                  sy1,
                  sx2,
                  sy2,
                  dx1,
                  dy1);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_util_convert_PARGB8888_to_ARGB8888_buf
 * DESCRIPTION
 *  Converts a memory block (ROI: Region Of Interest) from PARGB8888 to ARGB8888.
 * PARAMETERS
 *  buf_p           [IN]    memory buffer pointer
 *  buf_width       [IN]    memory buffer width
 *  x               [IN]    x offset of ROI
 *  y               [IN]    y offset of ROI
 *  width           [IN]    ROI width
 *  height          [IN]    ROI height
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_util_convert_PARGB8888_to_ARGB8888_buf(U8 *buf_p, S32 buf_width, S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 *pixel_p; 
    U32 pixel, out_pixel;
    U32 alpha;
    S32 line_pitch;
    S16 inv;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: assert if buf_p is not 4-byte aligned.
    // GDI_ASSERT(!(buf_p & 3) && (width <= buf_width));
    pixel_p = ((U32*)buf_p) + ((y * buf_width) + x);
    line_pitch = buf_width - width;

    for (y = height - 1; y >= 0; y--)
    {
        for (x = width - 1; x >= 0; x--)
        {
            pixel = *pixel_p;
            alpha = pixel >> 24;
            
            if (alpha)
            {
                inv = gdi_alpha_inverse_table[alpha];

                /* alpha */
                out_pixel = alpha << 24;
                for (i = 2; i >= 0; --i)
                {
                    pixel <<= 8;
                    out_pixel |= ((U32)((S16)(pixel >> 24) * inv) >> GDI_UTIL_INV_ALPHA_MUL_255_PRECISION_BITS) << (i * 8);
                }
                /* output the converted ARGB8888 pixel */
                *pixel_p = out_pixel;
            }

            pixel_p++;
        }

        pixel_p += line_pitch;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_util_convert_ARGB8888_to_PARGB8888_buf
 * DESCRIPTION
 *  Converts a memory block (ROI: Region Of Interest) from ARGB8888 to PARGB8888.
 * PARAMETERS
 *  buf_p           [IN]    memory buffer pointer
 *  buf_width       [IN]    memory buffer width
 *  x               [IN]    x offset of ROI
 *  y               [IN]    y offset of ROI
 *  width           [IN]    ROI width
 *  height          [IN]    ROI height
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_util_convert_ARGB8888_to_PARGB8888_buf(U8 *buf_p, S32 buf_width, S32 x, S32 y, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 *pixel_p; 
    U32 pixel, out_pixel;
    U32 alpha, r, g, b;
    S32 line_pitch;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: assert if buf_p is not 4-byte aligned.
    // GDI_ASSERT(!(buf_p & 3) && (width <= buf_width));
#define GDI_IMAGE_DIV_255(x)        ((((x) + 128) * 257) >> 16)

    pixel_p = ((U32*)buf_p) + y * buf_width + x;
    line_pitch = buf_width - width;

    for (y = height - 1; y >= 0; y--)
    {
        for (x = width - 1; x >= 0; x--)
        {
            pixel = *pixel_p;
            alpha = pixel >> 24;
            
            if (alpha)
            {
                r = ((pixel <<  8) >> 24);
                g = ((pixel <<  16) >> 24);
                b = ((pixel <<  24) >> 24);

                r = GDI_IMAGE_DIV_255(r * alpha);
                g = GDI_IMAGE_DIV_255(g * alpha);
                b = GDI_IMAGE_DIV_255(b * alpha);

                out_pixel = ((alpha << 24) | (r << 16) | (g << 8) | b);
            }
            else
            {
                out_pixel = 0;
            }
            /* output the converted PARGB8888 pixel */
            *pixel_p = out_pixel;
            pixel_p++;
        }

        pixel_p += line_pitch;
    }

#undef GDI_IMAGE_DIV_255

}


static ROTATOR_COLOR_FORMAT_ENUM gdi_util_rotator_get_color_format(U8 gdi_color_format)
{
    ROTATOR_COLOR_FORMAT_ENUM rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_END;
    
    switch(gdi_color_format)
    {
        case GDI_COLOR_FORMAT_16:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_RGB565;
            break;
        case GDI_COLOR_FORMAT_24:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_RGB888;
            break;
        case GDI_COLOR_FORMAT_32:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_ARGB8888;
            break;
        case GDI_COLOR_FORMAT_32_PARGB:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_PARGB8888;
            break;
    #ifdef GDI_COLORFORMAT8_PALETTE
        case GDI_COLOR_FORMAT_8:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_GRAY;
            break;
    #endif /* GDI_COLORFORMAT8_PALETTE */
        case GDI_COLOR_FORMAT_PARGB6666:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_PARGB6666;
            break;
        default:
            rotator_cf = ROTATOR_COLOR_FORMAT_ENUM_END;
            ASSERT(0);
    }
    return rotator_cf;
}


static ROTATOR_CW_ROTATE_ANGLE_ENUM gdi_util_rotator_get_rotate_angle(U8 rotate_angle)
{
    ROTATOR_CW_ROTATE_ANGLE_ENUM angle = ROTATOR_CW_ROTATE_ANGLE_000;
    
    switch(rotate_angle)
    {
        case GDI_LAYER_ROTATE_0:
            angle = ROTATOR_CW_ROTATE_ANGLE_000;
            break;
        case GDI_LAYER_ROTATE_90:
            angle = ROTATOR_CW_ROTATE_ANGLE_090;
            break;
        case GDI_LAYER_ROTATE_180:
            angle = ROTATOR_CW_ROTATE_ANGLE_180;
            break;
        case GDI_LAYER_ROTATE_270:
            angle = ROTATOR_CW_ROTATE_ANGLE_270;
            break;
        case GDI_LAYER_ROTATE_0_MIRROR:
            angle = ROTATOR_CW_ROTATE_ANGLE_MIRROR_000;
            break;
        case GDI_LAYER_ROTATE_90_MIRROR:
            angle = ROTATOR_CW_ROTATE_ANGLE_MIRROR_090;
            break;
        case GDI_LAYER_ROTATE_180_MIRROR:
            angle = ROTATOR_CW_ROTATE_ANGLE_MIRROR_180;
            break;
        case GDI_LAYER_ROTATE_270_MIRROR:
            angle = ROTATOR_CW_ROTATE_ANGLE_MIRROR_270;
            break;
        default:
            angle = ROTATOR_CW_ROTATE_ANGLE_000;
            ASSERT(0);
    }
    return angle;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_yuv_rotator
 * DESCRIPTION
 *  YUV rotator, used for user who want to use YUV buffer content to rotate.
 * PARAMETERS
 *  rotator_type        [IN] type of rotator, is one value of GDI_ROTATOR_ENUM
 *  rotate_angle        [IN] rotate value, is one macro of GDI_LAYER_ROTATE_XXX
 *  src_ptr             [IN] 
 *  src_pitch           [IN] 
 *  src_x               [IN] 
 *  src_y               [IN] 
 *  src_w               [IN] 
 *  src_h               [IN] 
 *  dst_ptr             [IN] 
 *  dst_pitch           [IN] 
 *  dst_x               [IN] 
 *  dst_y               [IN] 
 *  dst_w               [IN] 
 *  dst_h               [IN] 
 * RETURNS
 *  void
 *****************************************************************************/
GDI_RESULT gdi_yuv_rotator(
            GDI_ROTATOR_ENUM rotator_type,
            U8 rotate_angle,
            U8* src_ptr,
            U32 src_pitch,
            U32 src_height,
            S32 src_x,
            S32 src_y,
            U32 src_w,
            U32 src_h,
            U8* dst_ptr,
            U32 dst_pitch,
            U32 dst_height,
            S32 dst_x,
            S32 dst_y,
            U32 dst_w,
            U32 dst_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;
    ROTATOR_STATUS_ENUM rotator_status = ROTATOR_STATUS_OK;
    YUV_ROTATOR_HANDLE_STRUCT *rotator_handle;
    ROTATOR_MODE_ENUM rotator_mode;

    U32 int_mem_best, int_mem_min, int_mem_size;
    U32 ext_mem_best, ext_mem_min, ext_mem_size;
    void* int_mem_addr = NULL, *ext_mem_addr = NULL;
    S32 start_time = 0, decode_ms = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(rotator_type)
    {
        case GDI_ROTATOR_HW:
             rotator_mode = ROTATOR_MODE_HW;
             break;

        case GDI_ROTATOR_SW:
             rotator_mode = ROTATOR_MODE_SW;
             break;

        default:
            rotator_mode = ROTATOR_MODE_AUTO;
            break;
    }

    do
    {
        rotator_status = yuvRotatorGetHandle(&rotator_handle, rotator_mode);
        if (ROTATOR_STATUS_OK != rotator_status)
        {
            break;
        }

        rotator_status = yuvRotatorSetCallbackFunction(
                             rotator_handle,
                             NULL);
        rotator_status = yuvRotatorSetRotation(
                             rotator_handle,
                             gdi_util_rotator_get_rotate_angle(rotate_angle));

        rotator_status = yuvRotatorSetSrcBufferInfo(
                             rotator_handle,
                             ROTATOR_COLOR_FORMAT_ENUM_UYVY422,
                             (void *)src_ptr,
                             NULL,
                             NULL,
                             (src_pitch * src_height * gdi_bits_per_pixel(GDI_COLOR_FORMAT_UYVY422)) >> 3,
                             0,
                             0,
                             src_pitch,
                             src_height);
        rotator_status = yuvRotatorSetDstBufferInfo(
                             rotator_handle,
                             ROTATOR_COLOR_FORMAT_ENUM_UYVY422,
                             (void *)dst_ptr,
                             NULL,
                             NULL,
                             (dst_pitch * dst_height * gdi_bits_per_pixel(GDI_COLOR_FORMAT_UYVY422)) >> 3,
                             0,
                             0,
                             dst_pitch,
                             dst_height);
        rotator_status = yuvRotatorSetSrcWindow(
                             rotator_handle,
                             src_x,
                             src_y,
                             src_w,
                             src_h);
        rotator_status = yuvRotatorSetDstWindow(
                             rotator_handle,
                             dst_x,
                             dst_y,
                             dst_w,
                             dst_h);

        rotator_status = yuvRotatorCheckAbortFunction(rotator_handle, NULL);

        /* Set int memory and ext memory */
        {
            rotator_status = yuvRotatorQueryWorkingMemory(
                                 rotator_handle,
                                 &int_mem_best,
                                 &int_mem_min,
                                 &ext_mem_best,
                                 &ext_mem_min);
            int_mem_size = int_mem_best;
            ext_mem_size = ext_mem_best;
            while(1)
            {
                int_mem_addr = (void *)med_alloc_int_mem(int_mem_size);
                if ((int_mem_addr != NULL) || (int_mem_size == int_mem_min))
                {
                    break;
                }                
                int_mem_size /= 2;
                if (int_mem_size < int_mem_min)
                {
                    int_mem_size = int_mem_min;
                }
            }
            if (!int_mem_addr && 0 != int_mem_size)
            {
                ret = GDI_IMAGE_ERR_FRAME_BUFFER_NOT_ENOUGH;
                break;
            }

            while (1)
            {
                ext_mem_addr = (void *)gdi_alloc_ext_mem_cacheable(ext_mem_size);
                if ((ext_mem_addr != NULL) || (ext_mem_size == ext_mem_min))
                {
                    break;
                }                
                ext_mem_size /= 2;
                if (ext_mem_size < ext_mem_min)
                {
                    ext_mem_size = ext_mem_min;
                }
            }
            if (NULL == ext_mem_addr && 0 != ext_mem_size)
            {
                ret = GDI_IMAGE_ERR_FRAME_BUFFER_NOT_ENOUGH;
                break;
            }
            rotator_status = yuvRotatorSetWorkingMemory(
                                 rotator_handle,
                                 int_mem_addr,
                                 int_mem_size,
                                 ext_mem_addr,
                                 ext_mem_size);
        }

        start_time = drv_get_current_time();
        /* Start to rotate */
        yuvRotatorStart(&rotator_handle);
        do
        {
            rotator_status = yuvRotatorGetStatus(rotator_handle);
            switch(rotator_status)
            {
                case ROTATOR_STATUS_BUSY:
                     kal_sleep_task(1);
                     break;

                case ROTATOR_STATUS_COMPLETE:
                default:
                     break;
            }
        } while(ROTATOR_STATUS_BUSY == rotator_status);
        decode_ms = drv_get_duration_ms(start_time);

        if (ROTATOR_STATUS_COMPLETE == rotator_status)
        {
            ret = GDI_SUCCEED;
        }
    } while(0);

    if (int_mem_addr)
    {
        med_free_int_mem(&int_mem_addr);
    }
    if (ext_mem_addr)
    {
        gdi_free_ext_mem(&ext_mem_addr);
    }
    yuvRotatorReleaseHandle(rotator_handle);
    GDI_TRACE(GDI_TRC_RR, GDI_LAYER_ROTATOR_LEAVE,//[gdi_util_rotator]: Leave - ret:%d duration:%d
        ret, decode_ms);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_util_rotator
 * DESCRIPTION
 *  General rotator, used for user who want to use buffer content to rotate.
 * PARAMETERS
 *  rotator_type        [IN] type of rotator, is one value of GDI_ROTATOR_ENUM
 *  rotate_angle        [IN] rotate value, is one macro of GDI_LAYER_ROTATE_XXX
 *  src_ptr             [IN] 
 *  src_pitch           [IN] 
 *  src_x               [IN] 
 *  src_y               [IN] 
 *  src_w               [IN] 
 *  src_h               [IN] 
 *  dst_ptr             [IN] 
 *  dst_cf              [IN] 
 *  dst_pitch           [IN] 
 *  dst_x               [IN] 
 *  dst_y               [IN] 
 *  dst_w               [IN] 
 *  dst_h               [IN] 
 * RETURNS
 *  void
 *****************************************************************************/
GDI_RESULT gdi_util_rotator(
            GDI_ROTATOR_ENUM rotator_type,
            U8 rotate_angle,
            U8* src_ptr,
            U8  src_cf,
            U32 src_pitch,
            U32 src_height,
            S32 src_x,
            S32 src_y,
            U32 src_w,
            U32 src_h,
            U8* dst_ptr,
            U8  dst_cf, 
            U32 dst_pitch,
            U32 dst_height,
            S32 dst_x,
            S32 dst_y,
            U32 dst_w,
            U32 dst_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;
    ROTATOR_STATUS_ENUM rotator_status = ROTATOR_STATUS_OK;
    RGB_ROTATOR_HANDLE_STRUCT *rotator_handle;
    ROTATOR_MODE_ENUM rotator_mode;

    MMI_BOOL color_replace_enable = MMI_FALSE;
    U32 color_to_avoid = 0, color_to_replace = 0xFFFFFF;

    U32 int_mem_best, int_mem_min, int_mem_size;
    U32 ext_mem_best, ext_mem_min, ext_mem_size;
    void* int_mem_addr = NULL, *ext_mem_addr = NULL;
    S32 start_time = 0, decode_ms = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_TRACE(GDI_TRC_RR, GDI_LAYER_ROTATOR_ENTER,//[gdi_util_rotator]: Enter - type:%d angle:%d Src-cf:%d P:%d H:%d x:%d y:%d w:%d h:%d Dst-cf:%d P:%d H:%d x:%d y:%d w:%d h:%d
        rotator_type, rotate_angle,
        src_cf, src_pitch, src_height, src_x, src_y, src_w, src_h,
        dst_cf, dst_pitch, dst_height, dst_x, dst_y, dst_w, dst_h);
    
    if (src_cf == GDI_COLOR_FORMAT_UYVY422)
    {
        GDI_ASSERT(dst_cf == GDI_COLOR_FORMAT_UYVY422);
        return gdi_yuv_rotator(
                   GDI_ROTATOR_SW,
                   rotate_angle,
                   src_ptr,
                   src_pitch,
                   src_height,
                   src_x,
                   src_y,
                   src_w,
                   src_h,
                   dst_ptr,
                   dst_pitch,
                   dst_height,
                   dst_x,
                   dst_y,
                   dst_w,
                   dst_h);
    }

    switch(rotator_type)
    {
        case GDI_ROTATOR_HW:
             rotator_mode = ROTATOR_MODE_HW;
             break;

        case GDI_ROTATOR_SW:
             rotator_mode = ROTATOR_MODE_SW;
             break;

        default:
            rotator_mode = ROTATOR_MODE_AUTO;
            break;
    }

    do
    {
        rotator_status = rgbRotatorGetHandle(&rotator_handle, rotator_mode);
        if (ROTATOR_STATUS_OK != rotator_status)
        {
            GDI_TRACE(GDI_TRC_PRIMI_I, GDI_UTIL_ROTATOR_FAIL, rotator_status, rotator_type, 100);
            break;
        }

        if (gdi_image_codec_get_flag() & GDI_IMAGE_CODEC_FLAG_DISABLE_CACHE_SWITCH)
        {
            rgbRotatorSetDstBufferSwitchBehavior(rotator_handle, GFX_CACHE_SWITCH_BEHAVIOR_NOT_SWITCH);
        }       

        rotator_status = rgbRotatorSetCallbackFunction(
                             rotator_handle,
                             NULL);
        rotator_status = rgbRotatorSetRotation(
                             rotator_handle,
                             gdi_util_rotator_get_rotate_angle(rotate_angle));

        rotator_status = rgbRotatorSetSrcBufferInfo(
                             rotator_handle,
                             gdi_util_rotator_get_color_format(src_cf),
                             (void *)src_ptr,
                             (src_pitch * src_height * gdi_bits_per_pixel(src_cf)) >> 3,
                             src_pitch,
                             src_height);
        rotator_status = rgbRotatorSetDstBufferInfo(
                             rotator_handle,
                             gdi_util_rotator_get_color_format(dst_cf),
                             (void *)dst_ptr,
                             (dst_pitch * dst_height * gdi_bits_per_pixel(src_cf)) >> 3,
                             dst_pitch,
                             dst_height);
        rotator_status = rgbRotatorSetSrcWindow(
                             rotator_handle,
                             src_x,
                             src_y,
                             src_w,
                             src_h);
        rotator_status = rgbRotatorSetDstWindow(
                             rotator_handle,
                             dst_x,
                             dst_y,
                             dst_w,
                             dst_h);

        rotator_status = rgbRotatorSetColorReplacement(
                             rotator_handle,
                             color_replace_enable,
                             color_to_avoid,
                             color_to_replace);
        rotator_status = rgbRotatorSetDithering(rotator_handle, KAL_FALSE);

        rotator_status = rgbRotatorCheckAbortFunction(rotator_handle, NULL);

        /* Set int memory and ext memory */
        {
            rotator_status = rgbRotatorQueryWorkingMemory(
                                 rotator_handle,
                                 &int_mem_best,
                                 &int_mem_min,
                                 &ext_mem_best,
                                 &ext_mem_min);
            int_mem_size = int_mem_best;
            ext_mem_size = ext_mem_best;
            /* At present, ext mem and int mem are all 0. */
            GDI_DEBUG_ASSERT(int_mem_size == 0);
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* 0 */

            while (1)
            {
                ext_mem_addr = (void *)gdi_alloc_ext_mem_cacheable(ext_mem_size);
                if ((ext_mem_addr != NULL) || (ext_mem_size == ext_mem_min))
                {
                    break;
                }                
                ext_mem_size /= 2;
                if (ext_mem_size < ext_mem_min)
                {
                    ext_mem_size = ext_mem_min;
                }
            }
            if (NULL == ext_mem_addr && 0 != ext_mem_size)
            {
                ret = GDI_IMAGE_ERR_FRAME_BUFFER_NOT_ENOUGH;
                GDI_TRACE(GDI_TRC_PRIMI_I, GDI_UTIL_ROTATOR_FAIL, rotator_status, rotator_type, 200);
                break;
            }
            rotator_status = rgbRotatorSetWorkingMemory(
                                 rotator_handle,
                                 int_mem_addr,
                                 int_mem_size,
                                 ext_mem_addr,
                                 ext_mem_size);
        }

        start_time = drv_get_current_time();
        /* Start to rotate */
        rgbRotatorStart(&rotator_handle);
        do
        {
            rotator_status = rgbRotatorGetStatus(rotator_handle);
            switch(rotator_status)
            {
                case ROTATOR_STATUS_BUSY:
                     kal_sleep_task(1);
                     break;

                case ROTATOR_STATUS_COMPLETE:
                default:
                     break;
            }
        } while(ROTATOR_STATUS_BUSY == rotator_status);
        decode_ms = drv_get_duration_ms(start_time);

        if (ROTATOR_STATUS_COMPLETE == rotator_status)
        {
            ret = GDI_SUCCEED;
        }
    } while(0);

    GDI_DEBUG_ASSERT(int_mem_addr == NULL);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    if (ext_mem_addr)
    {
        gdi_free_ext_mem(&ext_mem_addr);
    }
    rgbRotatorReleaseHandle(rotator_handle);
    GDI_TRACE(GDI_TRC_RR, GDI_LAYER_ROTATOR_LEAVE,//[gdi_util_rotator]: Leave - ret:%d duration:%d
        ret, decode_ms);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_util_layer_rotator
 * DESCRIPTION
 *  General rotator, used for user who want to use layer handle.
 * PARAMETERS
 *  rotator_type        [IN] type of rotator, is one value of GDI_ROTATOR_ENUM
 *  rotate_angle        [IN] rotate value, is one macro of GDI_LAYER_ROTATE_XXX
 *  src_layer_handle    [IN] 
 *  src_x               [IN] 
 *  src_y               [IN] 
 *  src_w               [IN] 
 *  src_h               [IN] 
 *  dst_x               [IN] 
 *  dst_y               [IN] 
 *  dst_w               [IN] 
 *  dst_h               [IN] 
 * RETURNS
 *  void
 *****************************************************************************/
GDI_RESULT gdi_util_layer_rotator(
                   GDI_ROTATOR_ENUM rotator_type,
                   U8 rotate_angle,
                   gdi_handle src_layer_handle,
                   S32 src_x,
                   S32 src_y,
                   U32 src_w,
                   U32 src_h,
                   S32 dst_x,
                   S32 dst_y,
                   U32 dst_w,
                   U32 dst_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_layer_struct *src_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GDI_NULL_HANDLE == src_layer_handle)
    {
        return GDI_FAILED;
    }
    src_layer = (gdi_layer_struct*)src_layer_handle;
    return gdi_util_rotator(
               rotator_type,
               rotate_angle,
               src_layer->buf_ptr,
               src_layer->cf,
               src_layer->width,
               src_layer->height,
               src_x,
               src_y,
               src_w,
               src_h,
               gdi_act_layer->buf_ptr,
               gdi_act_layer->cf,
               gdi_act_layer->width,
               gdi_act_layer->height,
               dst_x,
               dst_y,
               dst_w,
               dst_h);
}

/*****************************************************************************
 * FUNCTION
 *  gdi_util_get_lcd_ppi
 * DESCRIPTION
 *  Get pixel per inch of the active LCD.
 * PARAMETERS
 *  ppi         : [OUT] pixel per inch of the active LCD
 * RETURNS
 *  GDI_RESULT, return GDI_SUCCEED if querying the ppi is successful; 
 *  GDI_FAILED if it's not supported.   
 *****************************************************************************/
GDI_RESULT gdi_util_get_lcd_ppi(S32 *ppi)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_SUCCEED;
    WFCContext ctx;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (ppi == NULL)
    {
        return GDI_FAILED;
    }
    
    GDI_LCD_LOCK_MUTEX;
    
    ctx = gdi_lcd_v2_ctx_array[GDI_LCD_V2_CTX_BLT_MAIN_LCD].ctx_handle;
    #if defined(__MMI_SUBLCD__)
    if (GDI_LCD->act_handle == GDI_LCD_SUB_LCD_HANDLE)
    {
        ctx = gdi_lcd_v2_ctx_array[GDI_LCD_V2_CTX_BLT_SUB_LCD].ctx_handle;
    }
    #endif
    *ppi = wfcGetContextAttribi(gdi_lcd_v2_dev, ctx, WFC_CONTEXT_PPI_MTK);

    GDI_LCD_UNLOCK_MUTEX;
    
    if (*ppi == 0)
    {
        ret = GDI_FAILED;
    }
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_util_adjust_aspect
 * DESCRIPTION
 *  Adjust the aspect by flag
 * PARAMETERS
 *  aspect_flag     [IN]        
 *  box_x           [IN]        
 *  box_y           [IN]        
 *  box_width       [IN]        
 *  box_height      [IN]        
 *  image_width     [IN]        
 *  image_height    [IN]        
 *  output_x        [IN]        
 *  output_y        [IN]        
 *  output_w        [IN]        
 *  output_h        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_util_adjust_aspect(
        S32 aspect_flag,
        S32 box_x,
        S32 box_y,
        S32 box_width,
        S32 box_height,
        S32 image_width,
        S32 image_height,
        S32 *output_x,
        S32 *output_y,
        S32 *output_w,
        S32 *output_h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (aspect_flag & GDI_UTIL_MODE_NO_RESIZE_OR_LONG_SIDE_FIT ||
        aspect_flag & GDI_UTIL_MODE_NO_RESIZE_OR_SHORT_SIDE_FIT ||
        aspect_flag & GDI_UTIL_MODE_LONG_SIDE_FIT ||
        aspect_flag & GDI_UTIL_MODE_SHORT_SIDE_FIT)
    {
        S32 fit_mode = aspect_flag & 0x1F;
        /* Get the output width and height */
        gdi_util_fit_box(
            fit_mode,
            box_width,
            box_height,
            image_width,
            image_height,
            output_x,
            output_y,
            output_w,
            output_h);
    }
    else
    {
        *output_x = (box_width - image_width) / 2;
        *output_y = (box_height - image_height) / 2;
        *output_w = image_width;
        *output_h = image_height;
    }

    /* Calculate the align position */
    if (aspect_flag & GDI_UTIL_MODE_CENTER_ALIGN)
    {
        *output_x = box_x + (box_width - image_width) / 2;
        *output_y = box_y + (box_height - image_height) / 2;
    }
    else
    {
        if (aspect_flag & GDI_UTIL_MODE_TOP_ALIGN)
        {
            *output_y = box_y;
        }
        
        if (aspect_flag & GDI_UTIL_MODE_BOTTOM_ALIGN)
        {
            *output_y = box_y + box_height - image_height;
        }
    
        if (aspect_flag & GDI_UTIL_MODE_LEFT_ALIGN)
        {
            *output_x = box_x;
        }
        if (aspect_flag & GDI_UTIL_MODE_RIGHT_ALIGN)
        {
            *output_x = box_x + box_width - image_width;
        }
    }
}



/* 6260 color engine interfaces */

#if defined (GDI_COLORENGINE_SUPPORT)
#include "color_enum.h"
#include "color_api.h"

COLOR_HANDLE g_colorHandle;


/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Disable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_color_engine_open()
{
    COLOR_STATUS_ENUM color_status = COLOR_STATUS_OK;
    GDI_RESULT ret = GDI_FAILED;
    
    color_status = colorWrapperOpen(&g_colorHandle, COLOR_SCENARIO_IMAGE_PLAYBACK);
    if (color_status == COLOR_STATUS_OK )
    {
        ret = GDI_SUCCEED;
    }
}

/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Disable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_color_engine_enable()
{
    COLOR_STATUS_ENUM color_status = COLOR_STATUS_OK;
    GDI_RESULT ret = GDI_FAILED;
    
    color_status = colorWrapperEnable(g_colorHandle, 0);
    if (color_status == COLOR_STATUS_OK )
    {	
        ret = GDI_SUCCEED;
    }
}

/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Disable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_color_engine_disable()
{
    COLOR_STATUS_ENUM color_status = COLOR_STATUS_OK;
    GDI_RESULT ret = GDI_FAILED;
    
    color_status = colorWrapperDisable(g_colorHandle);
    if (color_status == COLOR_STATUS_OK )
    {
        ret = GDI_SUCCEED;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Disable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_color_engine_close()
{
    COLOR_STATUS_ENUM color_status = COLOR_STATUS_OK;
    GDI_RESULT ret = GDI_FAILED;
    
    color_status = colorWrapperClose(g_colorHandle);
    if (color_status == COLOR_STATUS_OK )
    {
        ret = GDI_SUCCEED;
    }
}



#endif

#ifdef __LCD_COLOR_ENGINE_SUPPORT__
void gdi_color_engine_custom_on(void)
{
	   colorSetCustomEnable(KAL_TRUE);
}
void gdi_color_engine_custom_off(void)        
{
	   colorSetCustomEnable(KAL_FALSE);
}

/*****************************************************************************
 * FUNCTION
 *  gdi_color_engine_enable
 * DESCRIPTION
 *  Disable MM color Engine
 * PARAMETERS   
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_color_engine_get_power_status(kal_bool *enable)
{
    colorGetCustomEnable(enable);
}


#endif

