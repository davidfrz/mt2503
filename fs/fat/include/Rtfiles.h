/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   rtfiles.h
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *    Native api declarations
 *
 * Author:
 * -------
 *
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/**************************************************************************/
/*                                                                        */
/*  File: RTFILES.H                              Copyright (c) 1998,2002  */
/*  Version: 4.0                                 On Time Informatik GmbH  */
/*                                                                        */
/*                                                                        */
/*                                      On Time        /////////////----- */
/*                                    Informatik GmbH /////////////       */
/* --------------------------------------------------/////////////        */
/*                                  Real-Time and System Software         */
/*                                                                        */
/**************************************************************************/

/* RTFiles native API declarations */

#ifndef _RTFILES_H
#define _RTFILES_H

#if (!defined(CURR_MODULE) || (CURR_MODULE != MOD_FS)) && !defined(__FS_CARD_DOWNLOAD__)&&!defined(__FS_FUNET_ENABLE__)
#error "This header is for FS internal use only. Please include fs_gprot.h instead!"
#endif

#include "kal_general_types.h"
#include "kal_public_defs.h"
#include "fs_internal_def.h"
#include "fs_gprot.h"
#include "fs_iprot.h"

/***************** Compile Option definition ***************************/
#undef __FS_DEBUG__   // remove for DEBUG only!!

/************************************************************************/

#ifndef RTTDLL
   #ifdef RTT32DLL
      #if defined(_MSC_VER)
         #define RTTDLL __declspec(dllimport)
         #define RTTDDL __declspec(dllimport)
      #elif defined(__BORLANDC__)
         #define RTTDLL
         #define RTTDDL extern __import
      #else // importing needs no special declaration or is not supported
         #define RTTDLL
         #define RTTDDL extern
      #endif
   #else
      #define RTTDLL
      #define RTTDDL extern
   #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//#define RTFILE_VER 404

#if defined(_WIN32) || defined (WIN32) || defined (__FLAT__)
   #define RTF_32_BIT
   #define RTFAPI __cdecl
#else
   /* #define RTFAPI _cdecl */
   #define RTFAPI
#endif

#if !defined(WIN32)
#undef  _MSC_VER
#endif

#define SECTOR_SIZE   512
#define SECTOR_SHIFT  9

#define LSB(FileName, i) (FileName[2*i])
#define MSB(FileName, i) (FileName[2*i+1])
#define isASCII(FileName, i) ( !((BYTE) MSB(FileName, i)) && (LSB(FileName, i)<0x80) )
#define toASCII(FileName, i) ((BYTE) LSB(FileName, i))
#define isWASCII(wch) (wch < 0x80)
#define setASCII(FileName, i, ch) (LSB(FileName, i)=ch); (MSB(FileName,i)=0)
#define compASCII(FileName, i, c) (isASCII(FileName, i) && (toASCII(FileName, i) == c))

#define RTFRoundUp(N, Multiple)  (((N)+(Multiple)-1) & ~((Multiple)-1))
#define RTFRoundDown(N, Multiple) ((N) & ~((Multiple)-1))

// General FAT related definitions
#define RTF_CHAIN_END_MARK    0x0FFFFFFFL

#define CLUSTER_TO_SECTOR(Drive, Cluster)     ((Drive)->FirstDataSector + (((Cluster)-2L) << (Drive)->SPerCShift))
#define CLUSTER_TO_SECTOR_DIR(Drive, Cluster) (((Cluster) == RTF_ROOT_DIR) ? (Drive)->FirstDirSector : CLUSTER_TO_SECTOR(Drive, Cluster))
#define CLUSTER_TO_SECTOR_OFS(Drive, Cluster, Ofs)     ((Drive)->FirstDataSector + (((Cluster)-2L) << (Drive)->SPerCShift) + ((Ofs) >> (Drive)->Dev->DevData.SectorShift))
#define CLUSTER_TO_SECTOR_DIR_OFS(Drive, Cluster, Ofs) ((((Cluster) == RTF_ROOT_DIR) ? (Drive)->FirstDirSector : CLUSTER_TO_SECTOR(Drive, Cluster)) + ((Ofs) >> (Drive)->Dev->DevData.SectorShift))
#define SECTOR_OFS(Drive, Ofs)                ((Ofs) & ((Drive)->Dev->DevData.SectorSize-1))
#define SAME_DIR_ENTRY(D1, D2)                (((D1).Cluster == (D2).Cluster) && ((D1).Index == (D2).Index))
#define DIRS_PER_SECTOR(Drive)                (Drive->Dev->DevData.SectorSize/sizeof(RTFDOSDirEntry))

#define RTF_DELETED           ((char) -27) // first char in file name of deleted file
#define RTF_LONGNAME_ATTR     (RTF_ATTR_READ_ONLY | RTF_ATTR_HIDDEN | RTF_ATTR_SYSTEM | RTF_ATTR_VOLUME)
#define RTFATUnknown  0
#define RTFAT12      12
#define RTFAT16      16
#define RTFAT32      32

// for FAT12 cross-sector cluster mark
#define FS_FAT12_CLUSTER_CROSSING_SECTOR_OFFSET (512 * 8 / 12)
#define FS_FAT12_CLUSTER_CROSSING_SECTOR_GROUP  (512 * 8 * 3 / 12)

// partition type flags
#define RTF_PARTITION_FIRST_PRIMARY  0x00000001
#define RTF_PARTITION_EXTENDED       0x00000002
#define RTF_PARTITION_OTHER_PRIMARY  0x00000004
#define RTF_PARTITION_ALL            0x00000007 // all of the above

// flag used in GenerateShortName, to specify the handling method for SFN
#define SKIP_MATCH_SFN  0x04000000  // used in SearchFile, to indicate if SFN matching can be skipped to improve search speed.
#define INC_SHORT_NAME  0x08000000  // used in CreateNewDirEntry, to indicate if IncShortName is required for the default filename.

#define FS_GET_CLUSTER_DEFAULT  (0x0)
#define FS_GET_CLUSTER_RAW      (0x1)   // bypass checking input cluster and its value

//#define RTF_MAX_FILES 32

#define RTF_MIN_BUFFER_SIZE       512
#define RTF_MAX_BUFFER_SIZE     32768
#define RTF_MAX_PATH              520   // 260x2=520

// error codes
#define RTF_NO_ERROR                      0
#define RTF_ERROR_RESERVED                -1
#define RTF_PARAM_ERROR                   -2
#define RTF_INVALID_FILENAME              -3
#define RTF_DRIVE_NOT_FOUND               -4
#define RTF_TOO_MANY_FILES                -5
#define RTF_NO_MORE_FILES                 -6
#define RTF_WRONG_MEDIA                   -7
#define RTF_INVALID_FILE_SYSTEM           -8
#define RTF_FILE_NOT_FOUND                -9
#define RTF_INVALID_FILE_HANDLE           -10
#define RTF_UNSUPPORTED_DEVICE            -11
#define RTF_UNSUPPORTED_DRIVER_FUNCTION   -12
#define RTF_CORRUPTED_PARTITION_TABLE     -13
#define RTF_TOO_MANY_DRIVES               -14
#define RTF_INVALID_FILE_POS              -15
#define RTF_ACCESS_DENIED                 -16
#define RTF_STRING_BUFFER_TOO_SMALL       -17
#define RTF_GENERAL_FAILURE               -18
#define RTF_PATH_NOT_FOUND                -19
#define RTF_FAT_ALLOC_ERROR               -20
#define RTF_ROOT_DIR_FULL                 -21
#define RTF_DISK_FULL                     -22
#define RTF_TIMEOUT                       -23
#define RTF_BAD_SECTOR                    -24
#define RTF_DATA_ERROR                    -25
#define RTF_MEDIA_CHANGED                 -26
#define RTF_SECTOR_NOT_FOUND              -27
#define RTF_ADDRESS_MARK_NOT_FOUND        -28
#define RTF_DRIVE_NOT_READY               -29
#define RTF_WRITE_PROTECTION              -30
#define RTF_DMA_OVERRUN                   -31
#define RTF_CRC_ERROR                     -32
#define RTF_DEVICE_RESOURCE_ERROR         -33
#define RTF_INVALID_SECTOR_SIZE           -34
#define RTF_OUT_OF_BUFFERS                -35
#define RTF_FILE_EXISTS                   -36
#define RTF_LONG_FILE_POS                 -37
#define RTF_FILE_TOO_LARGE                -38
#define RTF_BAD_DIR_ENTRY                 -39
#define RTF_ATTR_CONFLICT                 -40 // Recoverable support: Can't specify FS_PROTECTION_MODE and FS_NONBLOCK_MODE
#define RTF_CHECKDISK_RETRY               -41 // Recoverable support: used for CROSSLINK
#define RTF_LACK_OF_PROTECTION_SPACE      -42 // UN-USED

// add for non_blocking write and protection
typedef enum{
  FS_BLOCK_ENUM,
  FS_NON_BLOCK_ENUM,
  FS_BLOCK_PROTECTION_ENUM
}fs_block_type_enum;// file attributes

typedef enum
{
    RTF_SEARCH_RET_FILE,
    RTF_SEARCH_RET_PATH,
    RTF_SEARCH_RET_PARENT,

    RTF_SEARCH_RET_NOT_FOUND
}rtf_search_ret_enum;


// file attributes
#define RTF_ATTR_READ_ONLY      0x01
#define RTF_ATTR_HIDDEN         0x02
#define RTF_ATTR_SYSTEM         0x04
#define RTF_ATTR_VOLUME         0x08
#define RTF_ATTR_DIR            0x10
#define RTF_ATTR_ARCHIVE        0x20
#define RTF_LONGNAME_ATTR       (RTF_ATTR_READ_ONLY | RTF_ATTR_HIDDEN | RTF_ATTR_SYSTEM | RTF_ATTR_VOLUME)
#define RTF_ATTR_ANY            0x3F

// file open flags
// 0x000000XX - attributes
// 0x0000XX00 - sharing
// 0x000X0000 - creation
// 0xXX000000 - caching
// 0x00X00000 - RTFiles internal use

#define RTF_READ_WRITE          0x00000000L
#define RTF_READ_ONLY           0x00000100L
#define RTF_OPEN_SHARED         0x00000200L
#define RTF_OPEN_NO_DIR         0x00000400L
#define RTF_OPEN_DIR            0x00000800L

#define RTF_CREATE              0x00010000L // create if it does not exist
#define RTF_CREATE_ALWAYS       0x00020000L // always create

// defaults:
// DIR and FAT is written at file close
// buffers are written when file pointer leaves the sector
#define RTF_COMMITTED           0x01000000L // commit all buffers after every write
#define RTF_CACHE_DATA          0x02000000L // do not discard data buffers
#define RTF_LAZY_DATA           0x04000000L // do not commit buffer when file pointer leaves sector
// add a new flags for non_blocking write for flash driver
#define FS_NONBLOCK_MODE        0x10000000L // writing while encounter flash erase return immediately
#define FS_NOBUSY_CHECK_MODE    0x40000000L
/* add a new flags for write protection for flash driver.
  *  Note that, currently, we protect a write range of 2 or less sectors.
  *  Originally, only NVRAM files are meant to be protected.
  */
#define FS_PROTECTION_MODE      0x20000000L // Keep old versioned sectors for recovery on unexpected poweroff.

#define FS_FH_INTERNAL_HINT     0x80000000L // indicate if this file handle embeds a internal hint

// note that RTF_DEVICE_LAZY_WRITE is a drive option and applies to all files

// file seek options
#define RTF_FILE_BEGIN          0
#define RTF_FILE_CURRENT        1
#define RTF_FILE_END            2

// format flags, low 8 bits are reserved for media specification
// Use RTF_FPLY_DRIVE_360/1200/720/1440/2880 to force a particular medium
// Default is the highest supported medium

#define RTF_FMT_SINGLE_FAT      0x00000100L
#define RTF_FMT_FORCE_LOW_LEVEL 0x00000200L
#define RTF_FMT_NO_LOW_LEVEL    0x00000400L
#define RTF_FMT_GET_DATA_SECTOR 0x00000800L
#define RTF_FMT_FAT_12          0x00001000L
#define RTF_FMT_FAT_16          0x00002000L
#define RTF_FMT_FAT_32          0x00004000L
#define RTF_FMT_NO_FAT_32       0x00008000L

#define RTF_FMT_PGS_LOW_FMT      1
#define RTF_FMT_PGS_HIGH_FMT     2
#define RTF_FMT_PGS_CLEAR_MEDIUM 5
#define RTF_FMT_PGS_DONE        -1

// check disk flags
#define RTF_CHK_FAT_MISMATCH              0x00000001L
#define RTF_CHK_FAT_MISMATCH_1            0x00000002L
#define RTF_CHK_FAT_MISMATCH_2            0x00000003L
#define RTF_CHK_FAT_MISMATCH_MASK         0x00000003L

#define RTF_CHK_INVALID_DIR               0x00000004L
#define RTF_CHK_INVALID_DIR_DELETE        0x00000008L
#define RTF_CHK_INVALID_DIR_MASK          0x0000000CL

#define RTF_CHK_INVALID_CLUSTER           0x00000010L
#define RTF_CHK_INVALID_CLUSTER_TRUNC     0x00000020L
#define RTF_CHK_INVALID_CLUSTER_DELETE    0x00000030L
#define RTF_CHK_INVALID_CLUSTER_MASK      0x00000030L

#define RTF_CHK_CROSSLINK                 0x00000040L
#define RTF_CHK_CROSSLINK_TRUNC           0x00000080L
#define RTF_CHK_CROSSLINK_DELETE          0x000000C0L
#define RTF_CHK_CROSSLINK_MASK            0x000000C0L

#define RTF_CHK_FILESIZE_SMALL            0x00000100L     // DIR.FileSize < FAT.FileSize
#define RTF_CHK_FILESIZE_SMALL_TRUNC      0x00000200L     // truncate FAT chain
#define RTF_CHK_FILESIZE_SMALL_DELETE     0x00000300L
#define RTF_CHK_FILESIZE_SMALL_MASK       0x00000300L

#define RTF_CHK_FILESIZE_LARGE            0x00000400L     // DIR.FileSize > FAT.FileSize
#define RTF_CHK_FILESIZE_LARGE_TRUNC      0x00000800L     // truncate DIR.FileSize
#define RTF_CHK_FILESIZE_LARGE_DELETE     0x00000C00L
#define RTF_CHK_FILESIZE_LARGE_MASK       0x00000C00L

#define RTF_CHK_LOST_CLUSTER              0x00001000L
#define RTF_CHK_LOST_CLUSTER_FREE         0x00002000L
#define RTF_CHK_LOST_CLUSTER_MASK         0x00003000L

#define RTF_CHK_LONG_FILENAME             0x00004000L
#define RTF_CHK_LONG_FILENAME_REMOVE      0x00008000L
#define RTF_CHK_LONG_FILENAME_DELETE      0x0000C000L
#define RTF_CHK_LONG_FILENAME_MASK        0x0000C000L

#define RTF_CHK_VERBOSE                   0x80000000L

// Flags for RTFCompactDir

#define RTF_CMPCT_READ_ONLY               0x00000001
#define RTF_CMPCT_RECURSIVE               0x00000002

// Flags for RTFDiskInfoEx

#define RTF_DI_BASIC_INFO                 0x00000001L
#define RTF_DI_FREE_SPACE                 0x00000002L  // return FreeClusters
#define RTF_DI_FAT_STATISTICS             0x00000004L  // return BadClusters, Files, FileChains, FreeChains, LargestFreeChain
#define RTF_DI_VOLUME_LABEL               0x00000008L  // return Volume Label
#define RTF_DI_OPT_READ_PERMITTED         0x00000010L  // return Volume Label

// Flags for RTFFileInfoEx

#define RTF_FI_BASIC_INFO                 0x00000001L
#define RTF_FI_ALLOCATED_SIZE             0x00000002L
#define RTF_FI_ALL                        (RTF_FI_BASIC_INFO | RTF_FI_ALLOCATED_SIZE)

// device types

#define RTF_DEVICE_UNKNOWN      0
#define RTF_DEVICE_FLOPPY       1
#define RTF_DEVICE_FDISK        2

// device flags, use only lower 16 bits

#define RTF_DEVICE_SINGLE_FAT       0x0001
#define RTF_DEVICE_LAZY_WRITE       0x0002  // update FAT/DIR/data buffers at last file close of drive
#define RTF_DEVICE_MOUNT_CONTIGUOUS 0x0004
#define RTF_DEVICE_REMOVABLE        0x0008

// device driver flags, may only use upper 16 bits

#define RTF_DEVICE_NO_MEDIA             0x10000
#define RTF_DEVICE_NEW_LOCK             0x20000
#define RTF_DEVICE_BUSY_READ_ONLY       0x40000

// floppy driver flags
#define RTF_CUSTOM_TIMER        0x80000000L
#define RTF_MOTOR_TIMEOUT_1     0x40000000L
#define RTF_MOTOR_TIMEOUT_5     0x20000000L
#define RTF_MOTOR_TIMEOUT_10    0x10000000L
#define RTF_READ_AHEAD_0        0x01000000L
#define RTF_READ_AHEAD_2        0x02000000L
#define RTF_READ_AHEAD_8        0x03000000L
#define RTF_READ_AHEAD_16       0x04000000L

// IDE driver flags
#define RTF_NO_CMOS_RAM         0x80000000L
#define RTF_32_BIT_IO           0x40000000L
#define RTF_16_BIT_IO           0x20000000L
#define RTF_NO_MULTI_SECTOR     0x10000000L
#define RTF_NO_WRITE_CACHE      0x08000000L
#define RTF_CONTIGUOUS_IO       0x04000000L

// Flash driver flags
#define RTF_FLASH_NO_SECTOR_MAP 0x80000000L
#define RTF_FLASH_NO_LOW_FMT    0x40000000L
#define RTF_FLASH_NO_HIGH_FMT   0x20000000L

// Flags for RTFGetPartitionInfo
#define FS_PARTITION_INFO_BASIC     (0x01)
#define FS_PARTITION_INFO_ADVANCED  (0x02)
#define FS_PARTITION_INFO_ALL       (FS_PARTITION_INFO_BASIC | FS_PARTITION_INFO_ADVANCED)

// a few data types
#if !defined(_WINDOWS_) && !defined(__AMNT__)
typedef unsigned int  DWORD;    // keep DWORD type definition inside RTFiles32 (Just in case for capatibility! Please use kal_uint32 instead in any future design)
#endif

typedef int   RTFHANDLE;
typedef kal_uint32 RTFSector;
typedef kal_uint32 RTFCluster;

#if defined(WIN32)
#pragma pack(push,1)
#endif
typedef __fs_packed_prefix struct {
   BYTE  BootIndicator,       // 0x80 for bootable, 0 otherwise
         StartHead,           // 0 based
         StartSector,         // 1 based, bits 0..5, bits 6,7 are bits 8,9 of StartTrack
         StartTrack,          // 0 based, bits 0..7
         OSType,              // FAT-12: 1, FAT-16: 4, 6, 14, FAT-32: 11, 12
         EndHead,             // see StartHead
         EndSector,           // see StartSector
         EndTrack;            // see StartTrack
   RTFSector RelativeSector,  // offset to first sector of partition data
                              // for primary partitions, this is the absolute
                              // LBA of the boot sector
                              // for logical drives, the boot sector is at ExtendedPartition.RelativeSector + Drive.RelativeSector
         Sectors;             // number of sectors in partition
} __fs_packed_postfix RTFPartitionRecord; /* ! Must SYNC ! */

typedef __fs_packed_prefix struct {
   unsigned int Second2:5;
   unsigned int Minute:6;
   unsigned int Hour:5;
   unsigned int Day:5;
   unsigned int Month:4;
   unsigned int Year1980:7;
} __fs_packed_postfix RTFDOSDateTime; /* ! Must SYNC ! */

typedef __fs_packed_prefix struct {
   char  FileName[8];
   char  Extension[3];
   BYTE  Attributes;
   BYTE  NTReserved;
   BYTE  CreateTimeTenthSecond; // range 0..199, not used
   RTFDOSDateTime           CreateDateTime;
   WORD  LastAccessDate;        // not used
   WORD  FirstClusterHi;        // FAT-32 only
   RTFDOSDateTime           DateTime;              // last modification time
   WORD  FirstCluster;
   kal_uint32 FileSize;
} __fs_packed_postfix RTFDOSDirEntry; /* ! Must SYNC ! */

// end of one byte alignment for structure definitions
#if defined(WIN32)
#pragma pack(pop)
#endif

typedef struct {
   const RTFDOSDirEntry * DirEntry;
   kal_uint32             FilePos;
   kal_uint32             AllocatedSize;
   kal_uint32             ClusterChains;
   kal_uint32             VolumeSerialNumber;
   const char           * FullName;
} RTFFileInfo; /* ! Must SYNC ! */

typedef struct {
   char             Label[24];
   char             DriveLetter;

   BYTE             WriteProtect;
   char             Reserved[2];
   kal_uint32       SerialNumber;
   kal_uint32       FirstPhysicalSector;
   UINT             FATType;            // 12 or 16
   UINT             FATCount;
   UINT             MaxDirEntries;
   UINT             BytesPerSector;
   UINT             SectorsPerCluster;
   RTFCluster       TotalClusters;
   RTFCluster       BadClusters;
   RTFCluster       FreeClusters;
   kal_uint32       Files;
   kal_uint32       FileChains;
   kal_uint32       FreeChains;
   RTFCluster       LargestFreeChain;
} RTFDiskInfo; /* ! Must SYNC ! */

// for device CFI information query

typedef enum
{
   MT_DEV_NO_BOOT = 0,
   MT_DEV_DUAL_BOOT,
   MT_DEV_TOP_BOOT,
   MT_DEV_BOTTOM_BOOT
} MT_DEVICE_BOOT_LOCATION_ENUM; /* ! Must SYNC ! */

// FS_NANDDeviceInfo (RTFNANDDeviceInfo) related definition
#define MT_DEVICE_FLAG_VISIBLE   (0x00000001)
#define MT_DEVICE_FLAG_PRESENT   (0x00000010)

typedef struct
{
   BYTE  DeviceID[8];
   UINT  BlockSize;
   UINT  PageSize;
   UINT  DeviceSize;
   UINT  Flag;
} RTFNANDDeviceInfo; /* ! Must SYNC ! */

typedef struct
{
   BYTE  DeviceID[8];
   UINT  DeviceSize;
   BYTE  BootLocation;
} RTFNORDeviceInfo; /* ! Must SYNC ! */

typedef struct
{
   UINT  Flag;
   UINT  PSN;
   kal_uint8   SerialMode;
   kal_uint8   DeferredMount;
} RTFCardDeviceInfo; /* ! Must SYNC ! */

typedef struct
{
   union
   {
      RTFNANDDeviceInfo NAND;
      RTFNORDeviceInfo  NOR;
      RTFCardDeviceInfo Card;
   } DeviceInfo;
} RTFDeviceInfo; /* ! Must SYNC ! */

typedef struct {
   RTFPartitionRecord Partition;
   RTFSector PartitionSector;      // absolute sector containing the partition table (0 for primary partitions and floppies)
   int       PhysicalDiskIndex;    // nth physical hard disk (0 based, -1 for floppies)
   UINT      BytesPerSector;       // usually 512
   BYTE      MediaDescriptor;      // F8 for hard disks, 0 for unknown
   BYTE      Reserved;             // for alignment
   short     DeviceListIndex;      // nth entry in the RTFiles device list (0 based)
} RTFPartitionInfo;

typedef struct {
   kal_uint32   TotalBuffers,             // number of installed sector buffers
                ValidBuffers,             // buffers currently holding valid data
                DirtyBuffers,             // buffers currently holding unflushed data
                MaxDirtyBuffers,          // max number of dirty buffers

                PhysicalBufferReads,      // number of physical buffer reads
                CachedBufferReads,        // number of times data was in the cache
                BuffersDiscarded,         // number of times a valid buffer was discared to make room for a new buffer
                CacheHits,                // 100 * CachedBufferReads / (PhysicalBufferReads+CachedBufferReads)

                PhysicalBufferWrites,     // buffer writes to disk
                CachedBufferWrites,       // updates of a dirty buffer
                AsynchBufferFlushs,       // buffers written in a differen RTFiles API call than the first update to that buffer

                UnbufferedReads,          // sectors read bypassing the buffer cache
                UnbufferedWrites;         // sectors written bypassing the buffer cache
} RTFBufferStatistic;

/*------------------------------
 *          FS Trace
 *------------------------------*/

#define MTPrintSysTrace(x)

typedef void (RTFAPI * RTFFormatCallback)(const char * DeviceName, int Action, kal_uint32 Total, kal_uint32 Completed);

typedef kal_uint32 (RTFAPI * RTFCheckDiskCallback)(kal_uint32 Flag,
                                              const char * Path,
                                              const RTFDOSDirEntry * FileInfo,
                                              kal_uint32 N1,
                                              kal_uint32 N2);
#ifndef _WINDOWS_
typedef struct {
   kal_uint32 Reserved[12];
} CRITICAL_SECTION;
#endif

typedef struct RTFMutex_t {
   kal_semid    rtf_sem;
   kal_taskid   rtf_sem_owner;
   kal_uint32   rtf_sem_owner_lr;
   kal_uint32   rtf_lock_count;

   int DeviceNum_1;
   int DeviceNum_2;

} RTFMutex; /* ! Must SYNC ! */

typedef RTFMutex RTFSemaphore;

typedef struct rtfdriver {
   //UINT Version;
   int  (RTFAPI * MountDevice)    (void * DriveData, int DeviceNumber, int DeviceType, kal_uint32 Flags);
   int  (RTFAPI * ShutDown)       (void * DriveData);
   int  (RTFAPI * ReadSectors)    (void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer);
   int  (RTFAPI * WriteSectors)   (void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer);
   int  (RTFAPI * MediaChanged)   (void * DriveData);
   int  (RTFAPI * DiscardSectors) (void * DriveData, RTFSector Sector, UINT Sectors);
   int  (RTFAPI * GetDiskGeometry)(void * DriveData, RTFPartitionRecord * DiskGeometry, BYTE * MediaDescriptor);
   int  (RTFAPI * LowLevelFormat) (void * DriveData, const char * DeviceName, RTFFormatCallback Progress, kal_uint32 Flags);
   int  (RTFAPI * NonBlockWriteSectors)   (void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer);
   int  (RTFAPI * RecoverableWriteSectors)(void * DriveData, RTFSector Sector, UINT Sectors, void * Buffer); // Recoverable support
   int  (RTFAPI * ResumeSectorStates)     (void  * DriveData); // Recoverable support
   int  (RTFAPI * HighLevelFormat)(void * DriveData, UINT BaseSector); /* for speed up format, WCP_SW , 2007/08/27 */
   int  (RTFAPI * RecoverDisk)    (void * DriveData); /* Support advance disk recover operation, WCP_SW, 2007/08/30 */
   int  (RTFAPI * MessageAck)     (void * DriveData, int type); /* Add for USB OTG Device, 2005/12/13 */
   int  (RTFAPI * CopySectors)    (void * DriveData, RTFSector SrcSector, RTFSector DstSector, UINT Sectors); /* Add for XCOPY Speed up, 2006/06/15 */
   int  (RTFAPI * OTPAccess)      (void * DriveData, int type, UINT Offset, void * BufferPtr, UINT Length); /* Add for OTP device IO, 2006/06/29 */
   int  (RTFAPI * OTPQueryLength) (void * DriveData, UINT *Length); /* Add for OTP device IO, 2006/06/29 */
   int  (RTFAPI * IOCtrl)         (void * DriveData, UINT CtrlAction, void * CtrlData); // For device IO control (like CMMB CAS full card)
} RTFDriver; /* ! Must SYNC ! */

struct _rtfDrive;
struct _rtfBuffer;

#if defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)
typedef struct {
   RTFMutex         * Lock;
   struct _rtfDrive * FirstDrive;
   BYTE               MediaPresent;
   BYTE               MediaRemovedReported; // set to zero when MediaPresent is set to zero
   BYTE               Reserved;
   BYTE               MountState;
   int                SectorSize;
   RTFPartitionRecord Geometry;         // size = 4 kal_uint32
   UINT               SectorShift;
   UINT               AccessCount;
   int                ErrorCondition;   // keep returning this until it is remounted
   int                PhysicalDiskIndex;
   char               FriendlyName[7];  // "Disk X"
   BYTE               MediaDescriptor;
   FS_CacheProfile    CacheProfile;
   struct _rtfBuffer *B;                // temporary buffer
} RTFDeviceData; /* ! Must SYNC ! */

#else // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)
typedef struct {
   RTFMutex         * Lock;
   struct _rtfDrive * FirstDrive;
   BYTE               MediaPresent;
   BYTE               MediaRemovedReported; // set to zero when MediaPresent is set to zero
   BYTE               Reserved;
   BYTE               MountState;
   int                SectorSize;
   RTFPartitionRecord Geometry;         // size = 4 kal_uint32
   UINT               SectorShift;
   UINT               AccessCount;
   struct _rtfBuffer *B;                // temporary buffer
   struct _rtfBuffer *AltBuffer;        // temporary buffer for critical errors
   int                ErrorCondition;   // keep returning this until it is remounted
   int                PhysicalDiskIndex;
   char               FriendlyName[7];  // "Disk X"
   BYTE               MediaDescriptor;
} RTFDeviceData; /* ! Must SYNC ! */
#endif // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)

typedef struct _rtfDevice {
   int                DeviceType;
   int                DeviceNumber;
   kal_uint32         DeviceFlags;
   RTFDriver        * Driver;
   void             * DriverData;       // total size = 5 kal_uint32
   RTFDeviceData      DevData;          // size = 16 kal_uint32
} RTFDevice; /* ! Must SYNC ! */

// driver specific data for well known drivers

// Windows NT driver, do not use for embedded systems
typedef struct {
   int DeviceType;
   kal_uint32 Flags;
   HANDLE FileHandle;
   CRITICAL_SECTION CS;
   // just for diagnostics
   kal_uint32 LastStatus;
   kal_uint32 SectorSize;
   kal_uint32 SectorsPerTrack;
   kal_uint32 Heads;
} RTFDrvNTData;


// ATA-IDE driver

typedef struct {
   void * ReadAheadBuffer;
   UINT ReadAheadBufferSize;
   UINT PortBase;
   UINT InitTimeout;
   UINT DiskTimeout;
   UINT ControllerTimeout;
   UINT IRQ;
   UINT Cylinders;
   UINT Heads;
   UINT SectorsPerTrack;
   UINT MaxSectors;
   UINT DeviceNumber;     // 0 or 1
   UINT Controller;       // 0 to 3
   RTFSector TotalSector;
   RTFSector InBufferSector;
   RTFSector InBufferSectors;
   kal_uint32 ExtraReads;
   kal_uint32 SavedReads;
   kal_uint32 SavedAccesses;
   kal_uint32 Flags;
} RTFDrvIDEData;


// Floppy driver
// these are also used as media identifiers. 0 means unknown.
// drive types never change, but medias can

#define RTF_FPLY_DRIVE_UNKNOWN 0
#define RTF_FPLY_DRIVE_360  1
#define RTF_FPLY_DRIVE_1200 2
#define RTF_FPLY_DRIVE_720  3
#define RTF_FPLY_DRIVE_1440 4
#define RTF_FPLY_DRIVE_2880 5

typedef struct {
   BYTE CommandByte2;     // use 0xDF
   BYTE CommandByte3;     // HeadLoadTime, use 0x02
   BYTE MotorTimeout;     // 55ms timer ticks, use 0x25
   BYTE SectorSize;       // use 2 for 512 bytes
   BYTE LastSector;       // media dependent, don't use
   BYTE GapLength;        // media dependent, don't use
   BYTE CommandByte8;     // DataLength, use 0xFF
   BYTE FormatGapLength;  // media dependent, don't use
   BYTE FormatFillByte;   // use 0xF6
   BYTE HeadSettleTime;   // use 0x0F (milliseconds)
   BYTE MotorStartupTime; // 8th of a second, use 8 (only used from write)
} RTF_FPLY_BIOS_Disk_Parameter;

typedef struct {
   UINT DeviceType;       // 0 to have the driver ask the BIOS CMOS RAM
   RTF_FPLY_BIOS_Disk_Parameter * DPT; // NULL to use default
   UINT DiskTimeout;                   // 0 for default of 2000 milliseconds
   UINT ControllerTimeout;             // 0 for default 500 milliseconds
   UINT Retries;                       // 3 by default
   UINT DeviceNumber;
   UINT Media;
   UINT CurrentTrack;
   UINT RetryCount;
   UINT ReadAheadSectors;
   kal_uint32 ExtraReads;
   kal_uint32 SavedReads;
   kal_uint32 SavedAccesses;
   kal_uint32 Flags;
   BYTE CtrStatus[7];
} RTFDrvFLPYData;


// RAM Disk

typedef struct {
   RTFSector Sectors;
   kal_uint32 Reserved1, Reserved2;
   UINT  SectorsPerSegment;
   void  * * * MasterSegment;
} RTFDrvRAMData;


// BIOS Driver

typedef struct {
   void * ReadAheadBuffer;
   UINT  ReadAheadBufferSize;
   UINT  LockIndex;
   UINT  Retries;
   UINT  DeviceNumber;
   UINT  DeviceType;
   UINT  SectorsPerTrack;
   UINT  Heads;
   UINT  RetryCount;
   UINT  InBufferSectors;
   RTFSector InBufferSector;
   kal_uint32 ExtraReads;
   kal_uint32 SavedReads;
   kal_uint32 SavedAccesses;
   kal_uint32 Flags;
} RTFDrvBIOSData;


// DiskOnChip 2000

typedef struct {
   unsigned DeviceNumber;
} RTFDrvDOCData;


// PCMCIA SRAM card driver

typedef struct {
   RTFSector  Sectors;
   BYTE     * WinAddrP;   // physical address of window
   BYTE     * WinAddrV;   // virtual  address of window
   RTFSector  WinSize;    // in sectors
   RTFSector  CurrSec;
   int        Socket;
   kal_uint32      Flags;
} RTFDrvSRAMData;

// port i/o routines for the drivers

RTTDLL BYTE   RTFAPI RTIn   (UINT Port);
RTTDLL WORD   RTFAPI RTInW  (UINT Port);
RTTDLL kal_uint32  RTFAPI RTInD  (UINT Port);
RTTDLL void   RTFAPI RTOut  (UINT Port, BYTE  val);
RTTDLL void   RTFAPI RTOutW (UINT Port, WORD  val);
RTTDLL void   RTFAPI RTOutD (UINT Port, kal_uint32 val);
RTTDLL void * RTFAPI RTInSW (UINT Port, void * Buffer, UINT Bytes);
RTTDLL void * RTFAPI RTInSD (UINT Port, void * Buffer, UINT Bytes);
RTTDLL void * RTFAPI RTOutSW(UINT Port, void * Buffer, UINT Bytes);
RTTDLL void * RTFAPI RTOutSD(UINT Port, void * Buffer, UINT Bytes);


// 32-bit disk drivers

RTTDDL RTFDriver RTFDrvNT;      // Windows NT driver (not for embedded systems)
RTTDDL RTFDriver RTFDrvIDE;     // ATA-IDE driver
RTTDDL RTFDriver RTFDrvFloppy;  // floppy disk driver
RTTDDL RTFDriver RTFDrvRAM;     // RAM disk driver
RTTDDL RTFDriver RTFDrvDOC;     // M-Systems DiskOnChip 2000 driver
RTTDDL RTFDriver RTFDrvSRAM;    // PCMCIA SRAM card driver
RTTDDL RTFDriver RTFDrvNULL;    // Dummy driver to reserve driver letters
RTTDDL RTFDriver RTFDrvFlash;   // linear flash driver

// 16-bit disk drivers

RTTDDL RTFDriver RTFDrvBIOS;    // BIOS int 13h driver
RTTDDL RTFDriver RTFDrvRAM;     // RAM disk driver
RTTDDL RTFDriver RTFDrvNULL;    // dummy driver to reserve driver letters


// The device list

RTTDDL RTFDevice gFS_DeviceList[];
//RTTDDL RTFDevice RTFDeviceList[];

struct _rtfDevice;
struct _rtfDrive;

#define    RTF_RECOVERABLE_WRITE     1
#define    RTF_NORMAL_WRITE          0

#if defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)
typedef struct _rtfBuffer {
    struct _rtfBuffer   * Next;
    struct _rtfBuffer   * Prev;
    struct _rtfDrive    * Drive;
    struct _rtfDevice   * Dev;
    kal_uint8           * Data;
    kal_uint32          SectorAddress;
    kal_uint32          SectorLength;
    kal_uint32          Flags;
} RTFBuffer; /* ! Must SYNC ! */

#else // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)

typedef struct _rtfBuffer {
   struct _rtfBuffer * Next;
   struct _rtfBuffer * Prev;
   RTFDevice         * Dev;
   BYTE              * Data;
   RTFSector           Sector;
   struct _rtfDrive  * FATSectorInfo;
   UINT                Flags;
   UINT                FirstDirtyTime,
                       LastDirtyTime;
   int                 Num;       // for debugging only

   BYTE                recoverable_flag; // 1 means the buffer needs recoverablewritesector, 0 means not
   BYTE                SectorCount;
   BYTE                SectorOffset; // may not be required
} RTFBuffer; /* ! Must SYNC ! */
#endif // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)

typedef struct _fsBufferList {
    struct _rtfBuffer   * FirstBuffer;
    struct _rtfBuffer   * LastBuffer;
} FS_BufferList;

typedef struct {
   RTFCluster Cluster;                  // zero if none
   UINT Index;                          // undefined if none
} RTFDirLocation; /* ! Must SYNC ! */

// FS external open hint
typedef struct {
   // RTFDirLocation
   UINT Cluster;
   UINT Index;
   // Extension
   UINT Stamp;
   UINT Drive;
   UINT SerialNumber;
} RTFFileOpenHint; /* ! Must SYNC ! */

typedef struct {
   RTFCluster          DirCluster;      // start of dir containing this entry
   RTFDirLocation      LongPos;
   RTFDirLocation      ShortPos;
   RTFDOSDirEntry      Dir;
} RTFDirEntry; /* ! Must SYNC ! */

typedef struct _rtfDrive {
   struct _rtfDevice * Dev;
   struct _rtfDrive  * NextDrive;
   int                 MountState;       // see type MountStates
   RTFPartitionRecord  Geometry;
   RTFCluster          Clusters;         // 1 + last valid cluster value, actual value +2
   UINT                SectorsPerCluster;
   kal_uint32          ClusterSize;      // in bytes
   UINT                ClusterShift;
   UINT                SPerCShift;       // sector per cluster shift
   UINT                FATType;
   UINT                FATCount;
   kal_uint32          SectorsPerFAT;
   kal_uint32          DataRangePerFATSector;
   RTFCluster          ClusterWatermark;
   RTFCluster          FreeClusterCount; // 0xFFFFFFFF if unknown
   RTFSector           InfoSector;       // 0 if none
   kal_uint32          SerialNumber;
   RTFSector           FirstSector;
   RTFSector           FirstFATSector;
   RTFSector           FirstDirSector;   // this is the first root dir cluster on FAT-32
   RTFSector           FirstDataSector;
   UINT                RootDirEntries;   // not used on FAT-32
   RTFDirEntry         CurrDirEntry;
   BYTE                Reserved1[5 * sizeof(UINT)];  // add 5 UINT members to synchronize the size of FS_Drive and _rtfDrive (FS_DOSDirEntry has additional 5 members for hint support in FS_DOSDirEntry than RTFDOSDirEntry)
   char                CurrDir[RTF_MAX_PATH]; // "X:\[Dir]"

#ifdef __FS_QM_SUPPORT__
   BYTE                QuotaMgt;
   BYTE                Reserved2[3];
#endif

} RTFDrive; /* ! Must SYNC ! */

typedef struct
{
   unsigned short       StaticHintCount;
   unsigned short       UsedStaticHintCount; // #static_hint + #classic_hint
   unsigned int         StaticHintRange;
} RTFSeekHintData;

typedef struct {
   RTFDrive     * Drive;        // NULL for physical disk files
   RTFDevice    * Dev;          // redundant for data and volume files

   kal_uint16     SpecialKind;
   kal_uint16     PrivateFlags;
   UINT           Unique;
   kal_uint32     Flags;

   RTFDirEntry    DirEntry;
   BYTE           Reserved1[5 * sizeof(UINT)];  // add 5 UINT members to synchronize the size of FS_File and RTFile (FS_DOSDirEntry has additional 5 members for hint support in FS_DOSDirEntry than RTFDOSDirEntry)

   kal_uint32     FilePointer;
   RTFCluster     LastCluster;  // cluster preceeding Cluster     (A1 and A2 for search handles)
   RTFCluster     Cluster;      // cluster containing FilePointer (RTFDirLocation for search handles)
   kal_uint32     Offset;       // within Cluster                 (ditto)

   char           FullName[RTF_MAX_PATH + 2 * sizeof(WCHAR)];
   void         * Task;         /* for garbage collection */

   UINT           HintNum;
   RTFDirLocation * Seek_Hint;

   fs_job_id      Job;
   fs_tbl_usr_ptr_type usr_ptr_type;
   void               *usr_ptr;

   kal_uint32     OwnerLR;     // Caller address of the file handle creator, ex. FS_Open().

   BYTE           Lock;
   BYTE           Valid;       // The Valid flag MUST be put at the end of the structure to avoid race condition between _rtfLock() & memset().
} RTFile; /* ! Must SYNC ! with FS_File */

typedef struct {
   RTFDrive  * DriveTable;
   RTFile    * FileTable;
   RTFBuffer * BufferTable;
   BYTE      * BufferData;
} RTFTables; /* ! Must SYNC ! */

#if defined(WIN32)
#pragma pack(push,1)
#endif
typedef __fs_packed_prefix struct {
   kal_uint32 Signature1;            // 0x41615252l
   BYTE  Reserved[480];
   kal_uint32 Signature2;            // 0x61417272l
   RTFCluster FreeClusterCount; // 0xFFFFFFFF for unkown, not guaranteed to be correct
   RTFCluster NextFreeCluster;  // 0xFFFFFFFF for unkown, start free cluster search here, not guaranteed to be correct
   BYTE  Reserved2[12];
   kal_uint32 Signature;             // 0xAA550000l
} __fs_packed_postfix RTFFAT32InfoSector;

typedef __fs_packed_prefix struct {
   BYTE     PhysicalDiskNumber; // 0x80, 0x81, etc.
   BYTE     CurrentHead;        // not used
   BYTE     Signature;          // needed by NT
   kal_uint32    SerialNumber;
   BYTE     Label[11];          // not used
   char     SystemID[8];
} __fs_packed_postfix RTFExtendedBIOSParameter; /* ! Must SYNC ! */

typedef __fs_packed_prefix struct {
   char     OEMName[8];
   WORD     BytesPerSector;
   BYTE     SectorsPerCluster;
   WORD     ReservedSectors;    // relative to partition start
   BYTE     NumberOfFATs;
   WORD     DirEntries;         // zero on FAT-32
   WORD     SectorsOnDisk;
   BYTE     MediaDescriptor;
   WORD     SectorsPerFAT;      // zero on FAT-32
   WORD     SectorsPerTrack;
   WORD     NumberOfHeads;
   RTFSector NumberOfHiddenSectors; // OS specific, unreliable
   RTFSector TotalSectors;
   __fs_packed_prefix union {
      __fs_packed_prefix struct {
         RTFExtendedBIOSParameter BPB;
      } __fs_packed_postfix _16;
      __fs_packed_prefix struct {
         RTFCluster SectorsPerFAT;
         WORD     Flags;              // if (Flags & 0x0080) { SingleFAT; ActiveFat = (Flags & 0x000F); }
         WORD     Version;
         RTFCluster RootDirCluster;
         WORD     FSInfoSector;       // relative to start of partition, usually 1, 0xFFFF for none.
         WORD     BackupBootSector;   // usually 6
         BYTE     Reserved[12];       // should be all zero
         RTFExtendedBIOSParameter BPB;
      } __fs_packed_postfix _32;
   } __fs_packed_postfix E;
} __fs_packed_postfix RTFBIOSParameter; /* ! Must SYNC ! */

typedef __fs_packed_prefix struct {
   BYTE BootCode[512-4*sizeof(RTFPartitionRecord)-sizeof(WORD)];
   RTFPartitionRecord PTable[4];
   WORD Signature;
} __fs_packed_postfix RTFMasterBootRecord; /* ! Must SYNC ! */

typedef __fs_packed_prefix struct {
   BYTE NearJump[3];
   RTFBIOSParameter BP;
   BYTE BootCode[512-3-sizeof(RTFBIOSParameter)-sizeof(WORD)];
   WORD Signature;
} __fs_packed_postfix RTFBootRecord; /* ! Must SYNC ! */

#if defined(WIN32)
#pragma pack(pop)
#endif
/*------------------------------
 * FS Internal Hint Management
 *------------------------------*/

typedef enum {
   MT_HINT_MATCH_NONE,
   MT_HINT_MATCH_PERFECT,
   MT_HINT_MATCH_TARGET_END,
   MT_HINT_MATCH_HINT_END,
   MT_HINT_MATCH_OTHER
} RTFOpenHintMatchTypeEnum;

typedef enum {
   MT_HINT_ACTION_NONE = 0,
   MT_HINT_ACTION_PAUSE,
   MT_HINT_ACTION_RESUME,
   MT_HINT_ACTION_OPEN,
   MT_HINT_ACTION_FORCE_NEW,
   MT_HINT_ACTION_FORCE_NO_NEW
} RTFOpenHintActionEnum;

#define MT_HINT_PATH_FREE_SLOT_UNAVAILABLE (0xFF)
/*
 * Hint Stamp Normalization Base
 * (M / N): M is the maximum hint stamp, and N is how many levels are there after normalization.
 * (M / N) should be assigned to a 2^N value to minimize the normalization overhead.
 */
#define MT_HINT_STAMP_NORMALIZE_LEVEL      (8)
#define MT_HINT_STAMP_NORMALIZE_BASE       (256 / MT_HINT_STAMP_NORMALIZE_LEVEL)

#define MT_HINT_FLAG_FIND_FILE       (0x01)
#define MT_HINT_FLAG_OBSOLETE        (0x02)

#define MT_HINT_INTERNAL             (0x80)
#define MT_HINT_NEW                  (0x40)

#define MT_HINT_DISABLE              (0x80000000)

#define MTHintSetLevel(hint, level)    (((FS_OpenHintInt*)(hint))->Level = (level))
#define MTHintGetLevel(hint)           (((FS_OpenHintInt*)(hint))->Level)
#define MTHintGetMatchType(hint)       (((FS_OpenHintInt*)(hint))->MatchType)
#define MTHintGetIndex(hint)           (((FS_OpenHintInt*)(hint))->PathIndex)
#define MTHintGetDirCluster(hint)      (((FS_OpenHintInt*)(hint))->DirCluster)
#define MTIsNewHint(hint)              (((FS_OpenHintInt*)(hint))->Flag & MT_HINT_NEW)
#define MTIsInternalHint(hint)         (((FS_OpenHintInt*)(hint))->Flag & MT_HINT_INTERNAL)

/*-------------------------------
 * FS Smart File Seeker Support
 *      (Internal Use)
 *-------------------------------*/

// hint types
#define FS_SEEKHINT_TYPE_STATIC           (0)
#define FS_SEEKHINT_TYPE_CLASSIC          (1)

// hint operations
#define FS_SEEKHINT_TYPE_MASK             (0x1)
#define FS_SEEKHINT_IS_STATIC(F, I)       (!(F->Seek_Hint[i].Index & FS_SEEKHINT_TYPE_MASK))
#define FS_SEEKHINT_IS_CLASSIC(F, I)      (F->Seek_Hint[i].Index & FS_SEEKHINT_TYPE_MASK)
#define FS_SEEKHINT_SET_STATIC(F, I)      (F->Seek_Hint[i].Index &= ~FS_SEEKHINT_TYPE_MASK)
#define FS_SEEKHINT_SET_CLASSIC(F, I)     (F->Seek_Hint[i].Index |= FS_SEEKHINT_TYPE_MASK)

// for RTFCommit
#define FS_COMMIT_DEFAULT       (0x00000000)    // default: no ResumeSector
#define FS_COMMIT_RESUMESECTOR  (0x00000001)    // ResumeSector will be executed if it is supported.

// API functions

// General File I/O

RTTDLL RTFHANDLE RTFAPI RTFOpenFile(const WCHAR * FileName, kal_uint32 Flags, RTFDirLocation * DSR_Hint, kal_uint32 caller_address);
RTTDLL RTFHANDLE RTFAPI RTFOpen(const WCHAR * FileName, kal_uint32 Flags, kal_uint32 caller_address);
RTTDLL RTFHANDLE RTFAPI RTFReopen(const WCHAR * FileName, kal_uint32 Flags, RTFHANDLE handle);
RTTDLL RTFHANDLE RTFAPI RTFOpenHint(const WCHAR * FileName, kal_uint32 Flags, RTFDirLocation * DSR_Hint, kal_uint32 caller_address);

RTTDLL int       RTFAPI RTFCloseFile(RTFHANDLE File, BYTE freeSlot);
#define RTFKEEPSLOT 0
#define RTFFREESLOT 1
RTTDLL int       RTFAPI RTFClose(RTFHANDLE File);
#define RTFSoftClose(File) RTFCloseFile(File, RTFKEEPSLOT)

RTTDLL int       RTFAPI RTFRead(RTFHANDLE File, void * DataPtr, UINT Length, UINT * Read);
RTTDLL int       RTFAPI RTFWrite(RTFHANDLE File, void * DataPtr, UINT Length, UINT * Written);
RTTDLL kal_int64 RTFAPI RTFSeek(RTFHANDLE File, kal_int64 Offset, int Whence);
RTTDLL int       RTFAPI RTFExtend(RTFHANDLE File, kal_uint32 Length);
RTTDLL int       RTFAPI RTFCommit(RTFHANDLE File, kal_uint32 Flag);
RTTDLL int       RTFAPI RTFTruncate(RTFHANDLE File);

// Information about Files

RTTDLL int       RTFAPI RTFGetFileInfo(RTFHANDLE File, RTFFileInfo * FileInfo, UINT Flags);
RTTDLL int       RTFAPI RTFGetFileSize(RTFHANDLE File, kal_uint32 * Size);
RTTDLL int       RTFAPI RTFGetFilePosition(FS_HANDLE fh, kal_uint32 *position);
RTTDLL int       RTFAPI RTFSetFileTime(RTFHANDLE File, const RTFDOSDateTime * Time);
RTTDLL int       RTFAPI RTFSetFileCreatedTime(RTFHANDLE File, const RTFDOSDateTime * Time);
RTTDLL int       MTCheckMSCard(RTFHANDLE File, RTFBootRecord *BR);

// File Attributes

RTTDLL int       RTFAPI RTFGetAttributes(const WCHAR * FileName);
RTTDLL int       RTFAPI RTFSetAttributes(const WCHAR * FileName, BYTE Attributes);

// Directories

RTTDLL int       RTFAPI RTFGetCurrentDir(WCHAR * DirName, UINT MaxLength);
RTTDLL int       RTFAPI RTFGetCurrentDirByDrive(WCHAR * DirName, UINT MaxLength);
RTTDLL int       RTFAPI RTFSetCurrentDir(const WCHAR * DirName);
RTTDLL int       RTFAPI RTFCreateDir(const WCHAR * DirName, kal_uint32 attributes);
RTTDLL int       RTFAPI RTFRemoveDir(const WCHAR * DirName);
RTTDLL int       RTFAPI RTFCompactDir(const WCHAR * DirName, kal_uint32 Flags);

// Finding Files

RTTDLL RTFHANDLE RTFAPI RTFFindFirstEx (const WCHAR * NamePattern, BYTE Attr, BYTE AttrMask, RTFDOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength, RTFFileOpenHint *OpenHint, kal_uint32 caller_address);
RTTDLL int       RTFAPI RTFFindNextEx (RTFHANDLE File, RTFDOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength, RTFFileOpenHint *OpenHint);
RTTDLL int       RTFAPI RTFFindClose(RTFHANDLE File);
RTTDLL int       RTFAPI RTFGetDiskInfoEx(const WCHAR * DriveName, RTFDiskInfo * DiskInfo, int Flags);

// File Name Operations

RTTDLL int       RTFAPI RTFRename(const WCHAR * FileName, const WCHAR * NewName);
RTTDLL int       RTFAPI RTFDelete(const WCHAR * FileName);
RTTDLL int       RTFAPI RTFMakeTempFileName(const WCHAR * DirName, WCHAR * FileName, UINT MaxLength);
RTTDLL int       RTFAPI RTFMakeFileName(const RTFDOSDirEntry * FileInfo, WCHAR * FileName);
RTTDLL int       RTFAPI RTFExpandName(WCHAR * FileName, UINT MaxLength);

// Disk and Volume Management

RTTDLL int       RTFAPI RTFResetDisk(const WCHAR * DriveName);
RTTDLL int       RTFAPI RTFGetDiskInfoEx(const WCHAR * DriveName, RTFDiskInfo * DiskInfo, int Flags);
RTTDLL int       RTFAPI RTFGetPartitionInfo(const WCHAR * DriveName, RTFPartitionInfo * PartitionInfo, kal_uint32 Option);
RTTDLL int       RTFAPI RTFSetVolumeLabel(const WCHAR * DriveName, const WCHAR * Label);

RTTDLL int       RTFAPI RTFFormat(const WCHAR * DriveName, UINT MinSectorsPerCluster, RTFFormatCallback Progress, kal_uint32 Flags, kal_uint32 caller_address);
RTTDLL int       RTFAPI RTFFormatGetFatType(RTFBootRecord *BR, kal_uint32 *_RootDirSectors, kal_uint32 *_FATSectors, kal_uint32 *_Written);
RTTDLL void      RTFAPI RTFFormatInitFatSector(kal_uint8 MediaDescriptor, kal_int32 FATType, kal_uint8 *Sector);

RTTDLL int       RTFAPI RTFCheckDiskBufferSize(const WCHAR * DriveName);
RTTDLL int       RTFAPI RTFCheckDisk(const WCHAR * DriveName, void * Buffer, UINT BufferSize, RTFCheckDiskCallback ErrorHandler, kal_uint32 Flags);

RTTDLL int       RTFAPI RTFSanityCheck(void);
RTTDLL int       RTFAPI RTFCheckBootUpFlag(void);
RTTDLL int       RTFAPI RTFSetBootUpFlag(kal_bool bSet);

typedef enum {
    FS_BOOTFLAG_CHECK = 0x00,
    FS_BOOTFLAG_SET = 0x01,
    FS_BOOTFLAG_CLEAR = 0x02
} fs_bootflag_enum;

int RTFAPI RTFBootUpFlag(fs_bootflag_enum operation);


// Miscellaneous File Functions

RTTDLL int       RTFAPI RTFCommitAll(const WCHAR * DriveName);
RTTDLL int       RTFAPI RTFCloseAll(void);
RTTDLL int       RTFAPI RTFUnlockAll(void);
RTTDLL void      RTFAPI RTFShutDown(void);
RTTDLL int       RTFAPI RTFCreateMasterBootRecord(void * SectorBuffer, const RTFPartitionRecord * DiskGeometry);
RTTDLL int       RTFAPI RTFSplitPartition(void * MasterBootRecord, RTFSector Sectors);
RTTDLL int       RTFAPI RTFCreateBootSector(void * BootSector, const RTFPartitionRecord * Partition, BYTE MediaDescriptor, UINT MinSectorsPerCluster, kal_uint32 Flags);

// Raw I/O functions
RTTDLL int       RTFAPI RTFRawLowLevelFormat(int DeviceIndex, const WCHAR * DeviceName, RTFFormatCallback Progress, kal_uint32 Flags);

// MTP support
RTTDLL int       RTFAPI RTFMakeFilePathByHint(WCHAR DriveLetter, UINT DirCluster, UINT DirIndex, WCHAR * FileName, UINT MaxLength);
RTFHANDLE RTFAPI RTFOpenFileByHint(WCHAR DriveLetter, UINT DirCluster, UINT DirIndex, kal_uint32 Flags, kal_uint32 caller_address);
RTTDLL int       RTFAPI RTFDeleteByHint(WCHAR DriveLetter, UINT DirCluster, UINT DirIndex);
RTTDLL int       RTFAPI RTFGetAttributesByHint(WCHAR DriveLetter, UINT DirCluster, UINT DirIndex);
RTTDLL int       RTFAPI RTFSetAttributesByHint(WCHAR DriveLetter, UINT DirCluster, UINT DirIndex, BYTE Attributes);
RTTDLL int       RTFAPI RTFHintGetParent(WCHAR DriveLetter, UINT DirCluster, UINT DirIndex, UINT *ParentCluster, UINT *ParentIndex);

// Functions for Debugging

RTTDLL void      RTFAPI RTFBufferInfo(RTFBufferStatistic * BufferInfo);

// Obsolete functions

RTTDLL kal_int32 RTFAPI RTFFindFirst(fs_list_param_struct *param,
                                     FS_DOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength,
                                     UINT Flag, FS_FileLocationHint *Pos, kal_uint32 caller_address);

RTTDLL kal_int32 RTFAPI RTFFindNext(FS_HANDLE handle,
                                    FS_Pattern_Struct * PatternArray, UINT PatternNum,
                                    BYTE ArrayMask,
                                    FS_DOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength,
                                    UINT Flag);


RTTDLL int       RTFAPI RTFGetDiskInfo(const WCHAR * DriveName, RTFDiskInfo * DiskInfo);

#ifdef RTF_32_BIT
#ifdef RTT32_VER
#if RTT32_VER >= 202
RTTDDL RTFileSystemHandlers RTFilesFileSystem;
#endif
#endif
#endif

/*------------- Internal EXTERN -------------*/
#define ParseFileName(FileName) ParseFileName0((const char *)FileName)
#define ParseFileNameWithFlag(FileName, Flags) ParseFileName1((const char *)FileName, Flags)

typedef enum { NotMounted, Initialized, Mounted, Accessible, SizeExceeded, HasFileSystem } MountStates;

typedef enum {NeverUsed, Available, Lfn, InUse} DirEntry;

typedef enum { NormalFile, FileMapFile, Volume, PhysicalDisk } FileKind;

#define SEARCH_FILES           0
#define SEARCH_LABEL           1
#define SEARCH_PARENT          2
#define SEARCH_RELEASE_LOCK    4           // allow release device/system locks while searching.

#define RTF_BAD_CLUSTER       0x0FFFFFF7L
#define RTF_INVALID_CLUSTER   0xFFFFFFFFL
#define RTF_CLUSTER_CHAIN_END 0x0FFFFFF8L  // also 0x0FFFFFF9..0x0FFFFFFF, test for >=, write RTF_CHAIN_END_MARK
#define RTF_ROOT_DIR          0xFFFFFFFFL  // pseudo cluster for the root directory (not for FAT-32)

#define FIRST_FILE_CLUSTER(Dir)               (((RTFCluster)((Dir).FirstClusterHi) << 16) + (Dir).FirstCluster)
#define FIRST_FILE_CLUSTER_LOW_WORD_ONLY(Dir) (Dir).FirstCluster
#define SET_FIRST_FILE_CLUSTER(Dir, Cluster)  (Dir).FirstCluster = (Cluster), (Dir).FirstClusterHi = (Cluster) >> 16
#define CLUSTER_BIT(ClusterMap, C)  ((ClusterMap[C / 8] & (1 << (C % 8))) != 0)
#define SET_CLUSTER_BIT(ClusterMap, C)    ClusterMap[C / 8] |= 1 << (C % 8)
#define CLEAR_CLUSTER_BIT(ClusterMap, C)    ClusterMap[C / 8] &= ~(1 << (C % 8))

#if defined(WIN32)
#pragma pack(push,1)
#endif
typedef __fs_packed_prefix struct {
   BYTE Ord;          // sequency number (backwards, 0x40 set if last record)
   WORD Name1[5];     // name chars 1..5
   BYTE Attributes;   // magic value
   BYTE Type;         // must be zero
   BYTE CheckSum;     // checksum of the short name
   WORD Name2[6];     // name chars 6..11
   WORD FirstCluster; // zero
   WORD Name3[2];     // name chars 12..13
} __fs_packed_postfix LFNDirEntry;
#if defined(WIN32)
#pragma pack(pop)
#endif

RTTDDL RTFTables  gFS_Data;
//RTTDDL RTFTables  RTFData;
RTTDDL const WCHAR dchar_dot[]; /* . */
RTTDDL const WCHAR dchar_dot_dot[]; /* .. */
RTTDDL const WCHAR dchar_start_dot_star[];
RTTDDL const WCHAR dchar_star[];

RTTDDL RTFMutex *RTFLock;

RTTDDL RTFMutex *MTFMLock;

RTTDDL RTFMutex *MTXLock;

RTTDDL RTFMutex *MTMoveLock;

RTTDDL RTFMutex *MTXdelLock;

#ifdef __FS_SORT_SUPPORT__
RTTDDL RTFMutex *MTSortLock;
#endif

RTTDDL RTFMutex *MTDiskInfoLock;

RTTDDL int DrvMappingOld;
RTTDDL int DrvMappingNew;

RTTDLL int        RTFAPI SearchFile(RTFile * f, UINT Flags, const char * FileName, RTFDirLocation * DSR_Hint);
RTTDLL RTFile *   RTFAPI ParseFileName0(const char * FileName);
RTTDLL RTFile *   RTFAPI ParseFileName1(const char * FileName, kal_uint32 Flags);
RTTDLL void       RTFAPI RTFInit(void);
RTTDLL void       RTFAPI DiscardAllBuffers(RTFDevice * Dev);
RTTDLL void       RTFAPI MountLogicalDrive(RTFDrive * Drive, MountStates State);
RTTDLL void       RTFAPI FlushAllBuffers(RTFDevice * Dev);
RTTDLL void       RTFAPI FreeFTSlot(RTFile * f);
RTTDLL RTFile *   RTFAPI ParseFileHandleEx(RTFHANDLE File, kal_uint32 Option);
RTTDLL int        RTFAPI WFNamesMatch(const char * N1, const char * N2);

extern RTFDOSDirEntry *StartDirSearchPrefetch(RTFDrive * Drive, RTFCluster Cluster, UINT Index, RTFDirLocation * DSR, kal_int32 PrefetchSectors);
RTTDLL RTFDOSDirEntry * RTFAPI GetDirPrefetch(RTFDrive * Drive, const RTFDirLocation * Pos, kal_int32 PrefetchSectors);
RTTDLL RTFDOSDirEntry * RTFAPI NextDirPrefetch(RTFDrive * Drive, RTFDirLocation * DSR, kal_int32 PrefetchSectors);
extern int IncDirPrefetch(RTFDrive * Drive, RTFDirLocation * DSR, kal_int32 PrefetchSectors);

#define StartDirSearch(Drive, Cluster, Index, DSR)  StartDirSearchPrefetch(Drive, Cluster, Index, DSR, 0)
#define GetDir(Drive, Pos)     GetDirPrefetch(Drive, Pos, 0)
#define IncDir(Drive, DSR)     IncDirPrefetch(Drive, DSR, 0)
#define NextDir(Drive, DSR)    NextDirPrefetch(Drive, DSR, 0)

RTTDLL DirEntry   RTFAPI EntryType(const RTFDOSDirEntry * D);
RTTDLL int        RTFAPI LFNCharCount(const LFNDirEntry * LD);
RTTDLL void       RTFAPI CopyLFN(char * Name, const LFNDirEntry * LD);

RTTDLL int        RTFAPI MakeShortFileName(const RTFDOSDirEntry * FileInfo, char * FileName, UINT MaxLength);
RTTDLL void       RTFAPI FileNameExtendToWCHAR(char *filename, kal_uint32 max_length);
RTTDLL void       RTFAPI MakePseudoRootDirEntry(RTFDrive * Drive, RTFDirEntry * DirEntry);
RTTDLL void       RTFAPI InitFilePointer(RTFile * f);
RTTDLL RTFHANDLE  RTFAPI MakeNewFileHandle(RTFile * f);
RTTDLL void       RTFAPI FreeFTSlotAndDevice(RTFile * f);
RTTDLL BYTE       RTFAPI ShortNameCheckSum(const BYTE * Name);
RTTDLL int        RTFAPI FileNamesMatch(const WCHAR * p, const WCHAR * n);
RTTDLL void       RTFAPI DeleteDirEntry(RTFile * f);
RTTDLL void       RTFAPI UpdateDirEntry(RTFile * f);
RTTDLL void       RTFAPI ExtendFile(RTFile * f, kal_uint32 Bytes, kal_uint32 Options);
RTTDLL void       RTFAPI CommitBuffer(RTFDevice * Dev);
RTTDLL void       RTFAPI SetClusterValue(RTFDrive * Drive, RTFCluster Cluster, RTFCluster Value);

RTTDLL int        RTFAPI SafeLock(kal_uint32 Lock, RTFDevice * Dev, UINT Timeout);
RTTDLL int        RTFAPI SafeUnlock(kal_uint32 Lock);
RTTDLL void       RTFAPI CheckNotOpen(RTFile * File);
RTTDLL int        RTFAPI UpdateClusterWatermark(RTFDrive * Drive, RTFCluster Watermark, int DeltaFreeClusters);
RTTDLL int        RTFAPI RTFCheckDiskFlag(void);
RTTDLL void       RTFAPI CheckSharing(RTFile * File);
RTTDLL RTFCluster RTFAPI SafeGetClusterValue(RTFDrive * Drive, RTFCluster Cluster);
RTTDLL void       RTFAPI DelDirEntry(RTFDrive * Drive, RTFDirLocation * LongPos, const RTFDirLocation * Pos);
RTTDLL int        RTFAPI IsValidLongNameChar(WCHAR c);
RTTDLL RTFCluster RTFAPI FATDelete(RTFDrive * Drive, RTFCluster Cluster, RTFile * f);
RTTDLL int        RTFAPI FileNameInvalid(const char * Name);
RTTDLL void       RTFAPI UnmountDevice(RTFDevice * Dev, int CloseFiles);
RTTDLL WCHAR*     RTFAPI CheckValidFileName2(const WCHAR * FileName, kal_bool bCheckLeading);
RTTDLL void       RTFAPI CheckValidFileName(const WCHAR * FileName);
RTTDLL int        RTFAPI CheckValidVolumeLabel(const WCHAR * Label);

#if defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)
RTFCluster  fs_srv_get_cluster_value(RTFDrive * Drive, RTFCluster Cluster, kal_uint32 Option, kal_int32 PrefetchSectorLength);
#else  // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)
typedef void * (*fs_func_get_buffer) (RTFDevice * Dev, RTFSector Sector, UINT Flags);
RTFCluster  fs_srv_get_cluster_value(RTFDrive * Drive, RTFCluster Cluster, kal_uint32 Option, fs_func_get_buffer GetBufferFunc);
#endif // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)

/*------------- Internal Use -------------*/
typedef enum {
   MT_ENUM_FH_INVALID,
   MT_ENUM_FH_VALID,
   MT_ENUM_FH_MEDIACHANGED,
   MT_ENUM_FH_ABORTED,
   MT_ENUM_FH_EXPORTED
}MT_FH_ENUM;

//Device Flag (lower 16 bit only; higher 16 bit for driver)
#define MT_DEVICE_NOR_FLASH      0x0040
#define MT_DEVICE_NAND_FLASH     0x0080
#define MT_DEVICE_WRITE_PROTECT  0x0100
#define MT_DEVICE_NO_EXPORT      0x0200
#define MT_DEVICE_EXPORTING      0x0400
#define MT_DEVICE_EXTERNAL       0x0800
#define MT_DEVICE_SIMPLUS        0x1000
#define MT_DEVICE_MEMORY_STICK   0x4000
#define MT_DEVICE_CHECK_PART     0x8000

//Special for function
#define MT_LOCK_RTF              0x00000002           //SafeUnlockDevice
#define MT_LOCK_DEV              0x00000004           //SafeUnlockDevice
#define MT_LOCK_FMT              0x00000008           //SafeUnlockDevice
#define MT_LOCK_EXT              0x00000010           //SafeUnlockDevice
#define MT_LOCK_MOVE             0x00000020           //SafeUnlockDevice
#define MT_LOCK_XDEL             0x00000040           //SafeUnlockDevice
#define MT_LOCK_SORT             0x00000080           //SafeUnlockDevice
#define MT_LOCK_TRACE            0x00000100           //SafeUnlockDevice
#define MT_LOCK_DISKIF           0x00000200           //SafeUnlockDevice
#define MT_LOCK_ALL              0x000001FF           //MT_LOCK_DISKIF, Except MT_LOCK_DISKIF

//drive letter
#define MT_BASE_DRIVE_LETTER     'C'
#define MT_BASE_DRIVE_INDEX      0

//for sanity check
#define MT_CHECKDISK_MAX_DEPTH   10

//Error Code Number
#define MT_SYSTEM_CRASH                -43            //for NAND Bad Block
#define MT_FAIL_GET_MEM                -44            //for get system memory failure
#define MT_READ_ONLY_ERROR             -45            //for access on read only error
#define MT_DEVICE_BUSY                 -46            //for look up device status
#define MT_ABORTED_ERROR               -47            //for abort copy
#define MT_QUOTA_OVER_DISK_SPACE       -48            //for quota management configure check
#define MT_PATH_OVER_LEN_ERROR         -49            //for longh path over 260
#define MT_APP_QUOTA_FULL              -50            //for quota management
#define MT_VF_MAP_ERROR                -51            //for virtual file feature
#define MT_DEVICE_EXPORTED_ERROR       -52            //for usb access in normal mode
#define MT_DISK_FRAGMENT               -53            //for RTF_Extend() user
#define MT_DIRCACHE_EXPIRED            -54            //for dir cache feature
#define MT_QUOTA_USAGE_WARNING         -55            //for quota management run time usage check
#define MT_ERR_DIRDATA_LOCKED          -56            //for dir cache feature

// Error codes that related to device driver feature or system/kernel adadption layer
#define MT_MSDC_MOUNT_ERROR            -100           //for MSDC only
#define MT_MSDC_READ_SECTOR_ERROR      -101           //for MSDC only
#define MT_MSDC_WRITE_SECTOR_ERROR     -102           //for MSDC only
#define MT_MSDC_DISCARD_SECTOR_ERROR   -103           //for MSDC only
#define MT_MSDC_PRESNET_NOT_READY      -104           //for MSDC only
#define MT_MSDC_NOT_PRESENT            -105           //for MSDC only

#define MT_EXTERNAL_DEVICE_NOT_PRESENT -106           //for USB OTG only

#define MT_FLASH_MOUNT_ERROR           -120           //for flash driver
#define MT_FLASH_ERASE_BUSY            -121           //for flash driver
#define MT_NAND_DEVICE_NOT_SUPPORTED   -122           //for flash driver

#define MT_LOCK_MUTEX_FAIL             -141
#define MT_NO_NONBLOCKMODE             -142
#define MT_NO_PROTECTIONMODE           -143

#define MT_DISK_SIZE_TOO_LARGE         (MT_MSDC_MOUNT_ERROR)

//Trace Code Number
#define MT_TRACE_QM_OK                 -500           //for Quota Feature only
#define MT_TRACE_QM_ERR                -501           //for Quota Feature only

//New API
RTTDLL int  RTFAPI MTGetDrive(kal_uint32 Type, kal_uint32 Serial, kal_uint32 AltMask);
RTTDLL int  RTFAPI MTMappingDrive(kal_uint32 UpperOldDrv, kal_uint32 UpperNewDrv);
RTTDLL void RTFAPI MTTraceFS(kal_uint32 TaskId, kal_uint32 FileCode, kal_uint32 Line, int Code, RTFile * f, BYTE * TraceStr);
RTTDLL void * RTFAPI MTProxyGetBuffer (RTFDevice * Dev, RTFSector Sector);
RTTDLL int  RTFAPI MTCopyFileByClusterChain(RTFHANDLE FileDst, RTFCluster *ClustersArray, UINT ClusterNum);
RTTDLL UINT RTFAPI GetFirstSector(WCHAR * FileName, void * SectorContent, UINT *Sector1, UINT *Sector2);
RTTDLL int  RTFAPI SetCopyrightEntry(RTFDirLocation *lFS_CopyrightLongPos, RTFDirLocation *lFS_CopyrightShortPos, RTFDOSDirEntry *lFS_CopyrightDir);
RTTDLL int  RTFAPI BatchCountFreeClusters(RTFDrive * Drive);
RTTDLL kal_int32 RTFAPI MTGetDirCacheValue(RTFDrive * Drive, RTFCluster DirCluster, kal_uint32 * CurrValue);
RTTDLL kal_int32 RTFAPI MTSetDirCacheValue(RTFDrive * Drive, RTFCluster DirCluster, kal_uint32 NewValue);
RTTDLL kal_int32 RTFAPI MTExpireDirCacheValue(RTFDrive * Drive, RTFCluster DirCluster);
RTTDLL void RTFAPI MTExpireDirCacheByDrive(RTFDrive* Drive);
RTTDLL int  RTFAPI CleanUpDataSectors(RTFDrive * Drive, RTFCluster *Start, int MaxClusters);
RTTDLL void RTFAPI MTCheckSharingWithSpecialKindFh(RTFile * File);
RTTDLL void RTFAPI MTToLowerString(WCHAR *FileName, UINT MaxLength);
RTTDLL void RTFAPI MTCheckFileNameCase(WCHAR *FileName, UINT MaxLength, BYTE NTReserved);
RTTDLL WCHAR * RTFAPI TruncateWideWhiteSpacesAndPeriods(const WCHAR *pSrcBuf);
RTTDLL WCHAR * RTFAPI TruncateWideBackSlash(WCHAR *path);
RTTDLL RTFDrive* RTFAPI MTGetRTFDriveByDriveFileName(const WCHAR *DriveName);
RTTDLL void RTFAPI MTClearFileTableByDrive(RTFDrive* drive);
#ifdef __FS_DEDICATED_BUFFER__
RTTDLL void RTFAPI MTBufInit(const kal_uint32 buf_addr, const kal_uint32 buf_size);
RTTDLL int  RTFAPI MTBufAlloc(unsigned int size, unsigned char **buf, unsigned int flag);
RTTDLL void RTFAPI MTBufFree(unsigned int size, unsigned char **buf);
RTTDLL int  RTFAPI MTBufCheckRange(unsigned int addr);
#endif /* __FS_DEDICATED_BUFFER__ */
#ifdef __FS_OPEN_HINT__
RTTDLL void RTFAPI MTHintAlloc(void);
RTTDLL int  RTFAPI MTHintNew(kal_uint8 PathIndex, kal_uint8 Level, RTFDirLocation *Location, RTFile *f, WCHAR *FileName);
RTTDLL void RTFAPI MTHintNewManual(kal_int8 PathIndex, const WCHAR *Path, WCHAR *FileName, RTFDirLocation *Location, UINT DirCluster);
RTTDLL void RTFAPI MTHintExpireByDrive(RTFDrive *Drive);
RTTDLL RTFDirLocation* RTFAPI MTHintGet(const WCHAR *Path, RTFOpenHintActionEnum Action);
RTTDLL void RTFAPI MTHintFinish(FS_OpenHintInt *hint);
RTTDLL void RTFAPI MTHintPause(kal_uint8 PathIndex, RTFOpenHintActionEnum Action);
RTTDLL void RTFAPI MTHintDelete(kal_uint8 PathIndex);
RTTDLL void RTFAPI MTHintFindFirst(FS_OpenHintInt *hint, RTFDirLocation* location, RTFile *f, WCHAR* filename);
RTTDLL void RTFAPI MTHintFindNext(RTFDirLocation* location, RTFHANDLE fh, WCHAR* filename);
RTTDLL void RTFAPI MTHintFindClose(RTFHANDLE fh);
RTTDLL void RTFAPI MTHintDiscard(kal_uint8 path_idx);
#endif /* __FS_OPEN_HINT__ */

#ifdef __FS_SMART_FILE_SEEKER__
RTTDLL void RTFAPI         MTSH_AddSeekHint(RTFile *f, RTFDirLocation *Hint, UINT Type);
RTTDLL void RTFAPI         MTSH_ReCalHintData(RTFile *f);
RTTDLL void RTFAPI         MTSH_DelHintByOffset(RTFile *f);
RTTDLL RTFCluster RTFAPI   MTSH_GetNextStaticMilestone(RTFile *f, kal_uint32 CurrPos);
RTTDLL int RTFAPI          MTSH_SearchHint(RTFile *f, UINT Pos);
#endif // __FS_SMART_FILE_SEEKER__

extern int RTFGetListEntry(FS_HANDLE handle, kal_wchar *path, kal_wchar *FileName, kal_uint32 MaxLength, FS_DOSDirEntry *FileInfo, kal_int32 index);

extern UINT MoveFilePointerSegment(RTFile * f, UINT Offset);
extern void MoveFilePointer(RTFile * f, UINT Offset);
extern int rtf_core_read_sectors(RTFDevice * Dev, void * Data, RTFSector Sector, UINT Sectors, DWORD Flags);
extern int rtf_core_write_sectors(RTFDevice * Dev, void * Data, RTFSector Sector, UINT Sectors, DWORD Flags, BYTE recoverable_flag);
extern void MTHintGen(RTFDirLocation *Hint, RTFDirLocation *DSR_SFN, RTFile *f);
extern int SearchFile(RTFile * f, UINT Flags, const char * FileName, RTFDirLocation * DSR_Hint);
extern void MountLogicalDrive(RTFDrive * Drive, MountStates State);
extern void FreeFTSlot(RTFile * f);
extern RTFHANDLE MakeNewFileHandle(RTFile * f);
extern void InitFilePointer(RTFile * f);

extern void CheckMedia(RTFDevice * Dev);
extern void CheckDirEntry(RTFile *f);
extern RTFDrive * AllocateDrive(char DriveLetter, RTFDevice * Dev);
extern int MountRemovableDevice(RTFDevice *Dev);
extern int rtf_core_mount_device(RTFDevice * Dev, DWORD Flags);
extern void ScanDevices(void);
extern int GenerateShortName(const char * LongName, char * ShortName);
extern int GenerateVolumeLable(const char * LongName, char * ShortName);
extern int RTFAPI fs_srv_findnext(FS_HANDLE handle,
                       FS_Pattern_Struct * PatternArray, UINT PatternNum,
                       BYTE ArrayMask,
                       FS_DOSDirEntry * FileInfo, WCHAR * FileName, UINT MaxLength,
                       UINT Flag,
                       FS_FileLocationHint * FilePos);
extern int FNamesMatch(const char * N1, const char * N2);
extern kal_int32 MTSearchDirData(RTFDrive * drive, RTFCluster dir_cluster);
extern kal_int32 GetFileHandle(RTFile *f);

extern void RTFileCheck_NormalFile_InvalidHandle(RTFile *f);
extern void RTFileCheck_NormalFile_InvalidFilename(RTFile *f);
extern void RTFileCheck_AttrDir_InvalidHandle(RTFile *f);
extern void RTFileCheck_WriteProtect(RTFile *f);
extern void RTFileCheck_Aborted(RTFile *f);
extern void RTFileCheck_Drive(RTFile *f);
extern void RTFileCheck_DirPath(RTFile *f);
extern void RTFHandle_MediaChange(RTFDevice *Dev);


//MTGetDrive Parameter
#define MT_NO_ALT_DRIVE       0x00000001
#define MT_ONLY_ALT_SERIAL    0x00000002
#define MT_DRIVE_I_SYSTEM     0x00000004
#define MT_DRIVE_V_NORMAL     0x00000008
#define MT_DRIVE_V_REMOVABLE  0x00000010
#define MT_DRIVE_V_EXTERNAL   0x00000020
#define MT_DRIVE_V_SIMPLUS    0x00000040

//NTReserved for Find series
typedef enum{
   MT_ENUM_FIND_NONE,
   MT_ENUM_FIND_LFN,
   MT_ENUM_FIND_SFN,
   MT_ENUM_LOWERCASE_MARK = 0x08,
   MT_ENUM_EXT_LOWERCASE_MARK = 0x10
}MT_FIND_ENUM;

//MTSetTrace Parameter
#define MT_TRACE_API          0x00000001
#define MT_TRACE_ERROR        0x00000002
#define MT_TRACE_DISABLE      0x00000004
#define MT_TRACE_ALL_TASK     0x00000008

#ifdef __FS_QM_SUPPORT__

typedef FS_QuotaStruct QuotaStruct;

typedef struct __InternQuotaStruct
{
   UINT        Qmin;
   UINT        Qmax;
   UINT        Qnow;
}InternQuotaStruct;

typedef enum
{
   MT_QP_HIG_ENUM,
   MT_QP_MID_ENUM,
   MT_QP_LOW_ENUM,
   MT_QP_DEL_ENUM
}MT_QP_ENUM;

extern FS_QuotaStruct *gFS_IntQuotaSet;
extern UINT    FS_MAX_QSET;
extern WCHAR NvramName[6];

#endif // __FS_QM_SUPPORT__


extern const UINT     FS_MAX_DRIVES;
extern UINT           FS_MAX_FILES;
extern const UINT     FS_MAX_BUFFERS;
extern const UINT     FS_MAX_THREAD;
extern kal_taskid     gFS_TaskList[];
extern fs_tls_struct  _gfs_tls[];

extern const int      gFS_DeviceNumOfSYSDRV;
extern const UINT     FS_MAX_CHECK_BUFFER;
extern BYTE           gFS_SanityCheckBuffer[];

extern int            SysLockFAT;  // for USB mode

extern int            SysBlockFAT; // for single bank

extern char           gFS_Export; // for USB normal mode
extern kal_taskid     gFS_ExportOwnerTaskID;

extern int            CardBusyCheck;

extern kal_bool       COPYRIGHT_USB_ON;

#ifdef __FS_OPEN_HINT__

extern FS_OpenHintPath     gFS_OpenHintPath[];
extern FS_OpenHintInt      gFS_OpenHint[];
extern BYTE                gFS_OpenHintLocationData[];

extern const UINT          FS_MAX_OPEN_HINT_PATH;
extern const UINT          FS_MAX_OPEN_HINT_LOCATION_PER_HINT;

#endif /* __FS_OPEN_HINT_ */

#define FS_DIRDATA_MASK_TIME    (0x3FFFFFFF)
#define FS_DIRDATA_MASK_LOCKED  (0x80000000)
#define FS_DIRDATA_MASK_EXPIRED (0x40000000)

typedef struct _fsDirData {
   RTFDrive   * Drive;
   RTFCluster Cluster;
   kal_uint32 Value;
   kal_uint32 Status;
} FS_DirDataStruct;

extern FS_DirDataStruct    _gfs_dir_data[];

#ifdef __EMMC_BOOTING__

extern kal_uint32 _gfs_system_drive_size;

#endif // __EMMC_BOOTING__

/**
 * Macro Definitions
 */

#if !defined(__FS_SLIM_RTFINIT__)
    #define fs_init() do {if (RTFLock == NULL) RTFInit(); } while (0)
#else
    #define fs_init()
#endif  // __FS_SLIM_RTFINIT__

#if defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)&&!defined(__FS_FUNET_ENABLE__)
#define GetClusterValue(drive, cluster, fat_prefetch_size)   fs_srv_get_cluster_value(drive, cluster, FS_GET_CLUSTER_DEFAULT, fat_prefetch_size)
#else  // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)
extern RTFCluster GetClusterValue(RTFDrive * Drive, RTFCluster Cluster, kal_int32 PrefetchSectorLength);
#endif // defined(__FS_CACHE_SUPPORT__) && !defined(__FS_CARD_DOWNLOAD__)

#define ParseFileHandle(a)      ParseFileHandleEx(a, 0)

#ifdef  __cplusplus
}
#endif

#endif


