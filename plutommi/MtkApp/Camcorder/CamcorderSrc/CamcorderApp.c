/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  CamcorderApp.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  Camcorder Applications v1.0
 *
 * Author:
 * -------
 * -------
 *                      
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
#include "MMI_include.h"
#ifdef __MMI_CAMCORDER__
#include "lcd_if.h"     /* LCD layer enable flag */
#include "lcd_sw_rnd.h" /* for LCD size */
#include "MMI_features_camcorder.h"     /* features */

#include "nvram_data_items.h"   /* ID to store file path */

/* framework related headers */
#include "SettingDefs.h"        /* ST_NOTIFYDURATION define */
#include "SettingProfile.h"     /* SUCCESS_TONE define */
#include "GpioSrvGprot.h"    /* LED */
#include "wgui_softkeys.h"
#include "FileManagerDef.h"
#include "FileMgrGProt.h"
#include "FileMgrSrvGProt.h"
#include "FileMgr.h"
#include "mmiapi_enum.h"        /* Stop LED */
#include "MainMenuDef.h"        /* Multimedia icon */
#include "ProfilesSrvGprot.h"      /* playRequestedTone */
#include "AudioInc.h"   /* Play record tone */
#include "UCMGProt.h"
#include "AlarmFrameworkProt.h"
#include "MmsAdp.h"
#include "CommonScreens.h"      /* Popup */

#if defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__)
#include "MediaAppGProt.h"
#endif 

#ifdef __MMI_PHOTOEDITOR__
#include "PhotoEditorGprot.h"
#endif 

/* gdi, mid, camera app headers */
#include "gdi_image_jpeg.h"     /* jpeg decoder */
#include "mdi_datatype.h"
#include "mdi_camera.h"
#include "mdi_audio.h"
#include "mdi_video.h"  /* mdi video library */
#include "mdi_include.h"
#include "SoundEffect.h"

#include "resource_camcorder_skins.h"
#include "CamcorderGprot.h"
#include "CamcorderApp.h"       /* camcorder app data */
#include "CamcorderResDef.h"    /* resource ID def */
#include "CamcorderSetting.h"
#ifdef __MMI_CAMCO_FTE__
#include "CamcorderFTEOSD.h"
#else 
#include "CamcorderOSD.h"
#endif 
#include "FileMgrGProt.h"
#include "FileManagerMenuItems.h"
#include "SettingProfileEnum.h"
#include "custom_events_notify.h"
#include "EngineerModeCamGprot.h"

#ifdef __MMI_IMAGE_VIEWER__
#include "ImageViewerGprot.h"
#include "ImageViewCuiGprot.h"
#include "mmi_rp_app_imageviewer_def.h"
#endif /* __MMI_IMAGE_VIEWER__ */ 

#ifdef __MMI_SUBLCD_CAMCO_CAM__
#include "IdleAppProt.h"
#endif 

#ifdef __MMI_USB_SUPPORT__
#include "USBDeviceGprot.h"
#include "USBSrvGProt.h"
#endif

#include "ConnectManageGProt.h"
#if defined(__MMI_FTS_SUPPORT__) || defined(__MMI_OPP_SUPPORT__)
#include "BTMMIScrGprots.h"
#endif 

#if defined(__MMI_FTS_SUPPORT__) || defined(__MMI_OPP_SUPPORT__) || defined(__MMI_BIP_SUPPORT__)
#include "BTMMIObexGprots.h"
#endif 

#ifdef __MMI_PICT_BRIDGE_SUPPORT__
#include "PictBridgeProt.h"
#endif 

#include "CameraCuiGprot.h"
#include "VdoRecCuiGprot.h"
#include "CamcorderCuiGprot.h"

#include "CbmSrvGprot.h"
#include "cbm_api.h"
#include "gdi_include.h"

#ifdef __MMI_MMS_2__
#include "mmi_rp_srv_mms_def.h"
#endif

// for alarm check
#include "ReminderSrvGprot.h"

#include "Resource_audio.h"
#include "mmi_rp_srv_filemanager_def.h"

#include "MMI_features.h"
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "GlobalConstants.h"
#include "mmi_frm_events_gprot.h"
#include "string.h"
#include "Unicodexdcl.h"
#include "mmi_rp_app_camco_def.h"
#include "mmi_frm_scenario_gprot.h"
#include "gdi_datatype.h"
#include "lcd_sw_inc.h"
#include "gdi_const.h"
#include "GpioSrvGprot.h"
#include "wgui_categories_util.h"
#include "device.h"
#include "mmi_frm_input_gprot.h"
#include "gui.h"
#include "GlobalResDef.h"
#include "app_mem.h"
#include "med_api.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "fs_func.h"
#include "MMI_media_app_trc.h"
#include "mmi_media_app_trc.h"
#include "kal_trace.h"
#include "mmi_frm_nvram_gprot.h"
#include "custom_mmi_default_value.h"
#include "fs_type.h"
#include "stdio.h"
#include "cal_comm_def.h"
#include "jpeg_enum.h"
#include "fs_errcode.h"
#include "FileMgrType.h"
#include "UcmSrvGprot.h"
#include "gpiosrvgprot.h"
#include "PixcomFontEngine.h"
#include "mmi_frm_history_gprot.h"
#include "gui_effect_oem.h"
#include "wgui_categories_list.h"
#include "AlertScreen.h"
#include "CustDataRes.h"
#include "mmi_frm_mem_gprot.h"
#include "gdi_features.h"
#include "gui_data_types.h"
#include "wgui_inputs.h"
#include "mms_api.h"
#include "img_common_enum.h"
#include "CustMenuRes.h"
#include "ImageViewerAdvGprot.h"
#include "mmi_res_range_def.h"
#include "MediaPlayerGProt.h"
#include "FileMgrResDef.h"
#include "mmi_rp_srv_filemanager_def.h"
#include "mmi_rp_file_type_def.h"
#include "FileMgrCuiGProt.h"
#include "CommonScreensResDef.h"

// for check if on power off process
#include "ShutdownSrvGprot.h"

// for panno define
#include "feature_comm_def.h"
#if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )

#include "SensorSrvGport.h"
//------------------motion
#endif
#include "mmi_frm_app_launcher_gprot.h"

#include "ScrLockerGprot.h"
#include "mav_comm_def.h"
#include "iul_csc_y2r.h"
/***************************************************************************** 
* Define
*****************************************************************************/
#define MMI_DUMMY_COMMAND                   (0)
#define MMI_CAMCO_ERR_CORRUPT_FAT           (-1)
#define MMI_CAMCO_ERR_PHONE_DISK_FULL       (-2)
#define MMI_CAMCO_ERR_CARD_DISK_FULL        (-3)
#define MMI_CAMCO_ERR_WRITE_PROTECT         (-4)
#define MMI_CAMCO_ERR_ROOT_DIR_FULL         (-5)
#define MMI_CAMCO_ERR_SAVE_FAIL             (-6)
#define MMI_CAMCO_ERR_BT_IS_WORKING         (-7)
#define MMI_CAMCO_ERR_STORAGE_CHANGE        (-8)
#define MMI_CAMCO_ERR_FILE_NOT_FOUND        (-9)
#define MMI_CAMCO_ERR_SET_CARD_AND_NO_CARD (-10)
#define MMI_CAMCO_ERR_SET_OTG_AND_NO_OTG    (-11)

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
#define MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR   (2000)
#endif 
#define MMI_CAMCO_ERROR_TIMER_DUR           (1000)      /* 1000 ms */
#define MMI_CAMCO_CONTSHOT_TIMER_DUR        (100)       /* 100 ms */
#define MMI_CAMCO_RECORDER_TIMER_DUR        (300)       /* 300 ms*/
#define MMI_CAMCO_FACEDETECT_POLLING_TIMER_DUR  (50)    /* 50 ms */

#define MMI_CAMCO_ASD_POLLING_TIMER_DUR  (200)    /* 200 ms */
#define MMI_CAMCO_AUTORAMA_DETECT_TIME (50)    /*50 ms */
#if defined(__MTK_INTERNAL__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if defined (__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined (__MTK_TARGET__) */ 
#endif /* defined(__MTK_INTERNAL__) */ 

//#define __MMI_CAMCO_EVB_AF_TEST__

/****************************************************************************
* Setting command map                                                                
*****************************************************************************/
/* mapping mmi settings to mdi command. */

/***************************************************************************** 
* Local Variable
*****************************************************************************/
/* camcorder contex */
mmi_camco_cntx_struct g_mmi_camco_cntx;
mmi_camco_cam_cntx_struct *const mmi_camco_cam_p = &g_mmi_camco_cntx.cam;
mmi_camco_rec_cntx_struct *const mmi_camco_rec_p = &g_mmi_camco_cntx.rec;
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
static volatile kal_timerid resz_cp_ESD_timeout_timer = NULL;
volatile kal_bool resz_esd_check_flag = KAL_TRUE;
#endif
/* CUI interface: App variables */
mmi_id g_mmi_camco_app_id;
mmi_id g_mmi_camco_partial_app_id;

#ifdef __MMI_CAMCO_DEBUG_ON__
MMI_BOOL mmi_camco_is_pano_log_file = MMI_FALSE;
#endif 

/*****************************************************************************
* Local Function 
*****************************************************************************/
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
static void resz_cp_ESD_timeout_timer_hdlr(void);
static void mmi_camco_app_reset_watchdog_callback(void);
static void mmi_camco_app_reset_watchdog_ESD(void);
#endif
void mmi_camco_hilight_app(void);

//#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
//static void mmi_camco_app_mem_stop_callback(void);
//#endif 
#ifdef __MMI_MMS__
static void mmi_camco_send_to_mms(void);
#endif 
static void mmi_camco_set_quickview_color_format(void);
static void mmi_camco_check_storage_path(U16 storage, CHAR **storage_filepath_pp);
static BOOL mmi_camco_get_storage_file_path(U16 storage, CHAR* filepath_p);
static BOOL mmi_camco_get_storage_disk_path(U16 storage, CHAR* drv_buf_p);
static BOOL mmi_camco_check_and_restore_valid_drv(U16 storage);
static S32 mmi_camco_create_file_dir(U16 storage, CHAR* filepath_p);
//static void mmi_camco_config_layer_orientation(void);

static void mmi_camco_update_cam_storage(U16 storage);
static void mmi_camco_update_rec_storage(U16 storage);

static void mmi_camco_exit_app_screen(void);

/* camera */
static void mmi_camco_cam_exit_app_screen(void);
static void mmi_camco_cam_entry_app_screen_internal(void);
static U8 mmi_camco_del_scr_callback(void *ptr);
static void mmi_camco_error_hdlr(void);

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
static void mmi_camco_preview_terminate_hdlr(void);
#endif 
static void mmi_camco_need_restart_preview(void);
static void mmi_camco_cam_check_filename(void);
static void mmi_camco_cam_get_next_filename(CHAR* filepath_buf_p);
static void mmi_camco_cam_restore_filename_seq_no(void);
static void mmi_camco_cam_set_framework_environment(void);
static void mmi_camco_cam_recover_framework_environment(void);
static void mmi_camco_cam_delete_confirm(void);
static void mmi_camco_cam_forward_menu(void);

#ifdef __MMI_IMAGE_VIEWER_ADV__
static void mmi_camco_cam_entry_imgadv_pan_zoom(void);
#endif 
#ifdef __MMI_PHOTOEDITOR__
static void mmi_camco_cam_entry_photoeditor(void);
#endif 
static void mmi_camco_cam_get_preview_window(mmi_camco_cam_preview_lcd_enum lcd);

static void mmi_camco_recover_state(mmi_camco_state_enum current_state);
static void mmi_camco_enter_state(mmi_camco_state_enum next_state);
static void mmi_camco_enter_exit_state(void);
static void mmi_camco_enter_cam_preview_state(void);
static void mmi_camco_enter_cam_preview_failed_state(void);
static void mmi_camco_enter_cam_setting_menu_state(void);

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_enter_cam_add_frame_state(void);
#endif 
static void mmi_camco_enter_cam_focusing_state(void);
static void mmi_camco_enter_cam_focused_state(void);
static void mmi_camco_enter_cam_countdown_state(void);
static void mmi_camco_enter_cam_capture_state(void);
static void mmi_camco_enter_cam_save_done_state(void);
static void mmi_camco_enter_cam_contshot_state(void);

#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_enter_cam_burstshot_state(void);
static void mmi_camco_enter_cam_burstshot_select_state(void);
static void mmi_camco_exit_cam_burstshot_state(void);
static void mmi_camco_exit_cam_burstshot_select_state(void);

static MDI_RESULT mmi_camco_cam_burstshot_start(void);
static void mmi_camco_cam_burstshot_stop(void);
static void mmi_camco_cam_burstshot_result_hdlr(MDI_RESULT ret, U16 captured_count, void* user_data);

static void mmi_camco_cam_burstshot_select_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_burstshot_select_lsk_options_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_burstshot_select_lsk_save_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_burstshot_select_option_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_burstshot_select_option_rsk_released(mmi_key_types_enum key_type);
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static void mmi_camco_enter_cam_aebshot_state(void);
static void mmi_camco_enter_cam_aebshot_select_state(void);
static void mmi_camco_exit_cam_aebshot_state(void);
static void mmi_camco_exit_cam_aebshot_select_state(void);

static MDI_RESULT mmi_camco_cam_aebshot(void);
static void mmi_camco_cam_aebshot_select_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_aebshot_select_lsk_options_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_aebshot_select_lsk_save_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_aebshot_select_option_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_aebshot_select_option_rsk_released(mmi_key_types_enum key_type);
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
static void mmi_camco_enter_cam_autorama_shot_state(void);
static void mmi_camco_enter_cam_autorama_stitch_state(void);
static void mmi_camco_enter_cam_autorama_done_state(void);

static void mmi_camco_exit_cam_autorama_shot_state(void);
static void mmi_camco_exit_cam_autorama_stitch_state(void);
static void mmi_camco_exit_cam_autorama_done_state(void);

static MDI_RESULT mmi_camco_cam_autorama_shot(void);
static MDI_RESULT mmi_camco_cam_autorama_stitch(void);
static MDI_RESULT mmi_camco_cam_autorama_stitch_stop(void);
static MDI_RESULT mmi_camco_cam_autorama_save_capture_image(PU8 image_buf_ptr, U32 image_buf_size);
static MDI_RESULT mmi_camco_cam_reset_autorama_3a(void);
static void mmi_camco_cam_autorama_shot_camera_key_pressed(void);
static void mmi_camco_cam_autorama_shot_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_shot_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_stitch_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_done_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_done_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_done_csk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_done_option_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_autorama_done_option_rsk_released(mmi_key_types_enum key_type);

#ifndef __MMI_CAMCO_FTE__
static void mmi_camco_cam_autorama_shot_set_key_hdlr(void);
static void mmi_camco_cam_autorama_stitch_set_key_hdlr(void);
static void mmi_camco_cam_autorama_done_set_key_hdlr(void);
#endif /* __MMI_CAMCO_FTE__ */ 
static void mmi_camco_cam_autorama_stitch_result_hdlr(mdi_camera_panorama_stitch_result_struct *result_ind_p, void* user_data);
static void mmi_camco_cam_autorama_quickview_result_hdlr(mdi_camera_panorama_stitch_quickview_struct *result_ind_p, void* user_data);
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
static void mmi_camco_enter_cam_hdr_shot_state(void);
static void mmi_camco_enter_cam_hdr_done_state(void);
static void mmi_camco_exit_cam_hdr_shot_state(void);
static void mmi_camco_exit_cam_hdr_done_state(void);

static MDI_RESULT mmi_camco_cam_hdrshot_start(void);
static void mmi_camco_cam_hdrshot_stop(void);
static MDI_RESULT mmi_camco_cam_hdrshot_save(void);

void mmi_camco_cam_hdrshot_result_hdlr(mdi_camera_hdr_result_struct* result_ind, void* user_data);
#endif

static void mmi_camco_restore_confirm_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_restore_confirm_rsk_released(mmi_key_types_enum key_type);

static void mmi_camco_enter_restore_confirm_state(void);
static void mmi_camco_exit_restore_confirm_state(void);
static void mmi_camco_exit_current_state(void);
static void mmi_camco_exit_cam_preview_state(void);
static void mmi_camco_exit_cam_setting_menu_state(void);

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_exit_cam_add_frame_state(void);
#endif 
#ifdef __SMILE_SHUTTER_SUPPORT__
static void mmi_camco_enter_cam_smile_dect_state(void);
void mmi_camco_cam_smile_detect_stop(void);
static void mmi_camco_cam_smiledetec_camera_key_pressed(void);
#endif /* __SMILE_SHUTTER_SUPPORT__ */ 
static void mmi_camco_exit_cam_focus_state(void);
static void mmi_camco_exit_cam_countdown_state(void);
static void mmi_camco_exit_cam_capture_state(void);
static void mmi_camco_exit_cam_save_done_state(void);
static void mmi_camco_exit_cam_contshot_state(void);
static MDI_RESULT mmi_camco_cam_power_on(void);
static void mmi_camco_cam_power_off(void);
static BOOL mmi_camco_cam_preview_start(void);
static void mmi_camco_cam_preview_stop(void);
static void mmi_camco_cam_autofocus_start(void);
static void mmi_camco_cam_autofocus_stop(void);
extern void mmi_camco_cam_scene_detect_start(void);
extern void mmi_camco_cam_scene_detect_stop(void);
static void mmi_camco_cam_scene_detect_cyclic(void);
static void mmi_camco_cam_capture(void);
static MDI_RESULT mmi_camco_cam_normal_shot(void);
static MDI_RESULT mmi_camco_cam_addframe_shot(void);
static MDI_RESULT mmi_camco_cam_bestshot(void);
static void mmi_camco_cam_contshot_cyclic(void);
static MDI_RESULT mmi_camco_cam_save_capture_image(void);

static void mmi_camco_cam_countdown_cyclic(void);

#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__)
static U8 mmi_camco_clam_close_event_hdlr(mmi_frm_int_event_type interrupt_event);
#endif 
static void mmi_camco_face_detect_result_cyclic(void);

#ifndef __MMI_CAMCO_FTE__
static void mmi_camco_cam_preview_set_key_hdlr(void);
static void mmi_camco_cam_preview_no_card_set_key_hdlr(void);
static void mmi_camco_cam_preview_failed_set_key_hdlr(void);
static void mmi_camco_cam_setting_menu_set_key_hdlr(void);

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_cam_add_frame_set_key_hdlr(void);
#endif 
static void mmi_camco_cam_countdown_set_key_hdlr(void);
static void mmi_camco_cam_save_done_set_key_hdlr(void);
//static void mmi_camco_cam_save_done_storage_fail_set_key_hdlr(void);
static void mmi_camco_cam_contshot_set_key_hdlr(void);

#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_cam_burstshot_select_set_key_hdlr(void);
#endif 
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static void mmi_camco_cam_aebshot_select_set_key_hdlr(void);
#endif 
static void mmi_camco_restore_confirm_set_key_hdlr(void);
#endif /* __MMI_CAMCO_FTE__ */ 
static void mmi_camco_cam_focus_set_key_hdlr(void);
static void mmi_camco_cam_preview_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_preview_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_preview_no_card_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_preview_csk_pressed(mmi_key_types_enum key_type);
static void mmi_camco_cam_preview_autofocus_button_pressed(void);
static void mmi_camco_cam_focus_autofocus_button_released(void);
static void mmi_camco_cam_capture_button_pressed(void);
static void mmi_camco_cam_capture_button_released(void);
static void mmi_camco_cam_capture_button_preview_pressed(void);
static void mmi_camco_cam_capture_csk_button_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_setting_menu_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_setting_menu_rsk_released(mmi_key_types_enum key_type);

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_cam_add_frame_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_add_frame_rsk_released(mmi_key_types_enum key_type);
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
static void mmi_camco_cam_preview_failed_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_countdown_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_save_done_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_save_done_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_save_done_csk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_delete_confirm_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_multishot_delete_confirm_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_delete_confirm_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_forward_menu_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_forward_menu_rsk_released(mmi_key_types_enum key_type);

static void mmi_camco_cam_save_done_option_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_save_done_option_lsk_released(mmi_key_types_enum key_type);

static void mmi_camco_cam_draw_capture_img_from_memory(void);
static MDI_RESULT mmi_camco_cam_save_image(CHAR* buff_filename_p, PU8 image_buf_ptr, U32 image_buf_size);

static void mmi_camco_cam_autofocus_result_hdlr(mdi_camera_af_result_struct result_ind, void* user_data);

#ifdef __MMI_SUBLCD__
static void mmi_camco_init_sublcd(void);
static void mmi_camco_deinit_sublcd(void);
static void mmi_camco_entry_sublcd_screen(void);
static void mmi_camco_exit_sublcd_screen(void);
static void mmi_camco_sublcd_draw_icon(void);
#endif /* __MMI_SUBLCD__ */ 
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
static BOOL mmi_camco_cam_sublcd_preview_start(void);
void mmi_camco_cam_switch_to_sublcd(void);
static void mmi_camco_mainlcd_draw_icon(void);
static void mmi_camco_enter_cam_sub_preview_state(void);
static void mmi_camco_exit_cam_sub_preview_state(void);

#ifndef __MMI_CAMCO_FTE__
static void mmi_camco_cam_sub_preview_set_key_hdlr(void);
#endif 
static void mmi_camco_cam_sub_preview_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_cam_sublcd_preview_csk_pressed(mmi_key_types_enum key_type);
static void mmi_camco_cam_sublcd_capture_button_pressed(void);
static void mmi_camco_cam_sub_preview_switch_button_released(void);
#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
static void mmi_camco_countdown_led_turn_on(void);
static void mmi_camco_countdown_led_turn_off(void);

/* video recorder */
static void mmi_camco_rec_exit_app_screen(void);
static void mmi_camco_rec_entry_app_screen_internal(void);
//static void mmi_camco_resize_preview_layer(void);
static void mmi_camco_rec_set_framework_environment(void);
static void mmi_camco_rec_recover_framework_environment(void);
static void mmi_camco_rec_get_preview_window(void);
static void mmi_camco_rec_check_filename(void);
static void mmi_camco_rec_get_next_filename(CHAR* filepath_buf_p);
static void mmi_camco_rec_restore_filename_seq_no(void);

static void mmi_camco_enter_rec_preview_state(void);
static void mmi_camco_enter_rec_preview_failed_state(void);
static void mmi_camco_enter_rec_setting_menu_state(void);
static void mmi_camco_enter_rec_focusing_state(void);
static void mmi_camco_enter_rec_focused_state(void);
static void mmi_camco_enter_rec_recording_state(void);
static void mmi_camco_enter_rec_pause_state(void);
static void mmi_camco_enter_rec_saving_state(void);
static void mmi_camco_enter_rec_save_done_state(void);
static void mmi_camco_enter_rec_saving_prev_state(void);
static void mmi_camco_exit_rec_preview_state(void);
static void mmi_camco_exit_rec_preview_failed_state(void);
static void mmi_camco_exit_rec_setting_menu_state(void);
static void mmi_camco_exit_rec_focus_state(void);
static void mmi_camco_exit_rec_recording_state(void);
static void mmi_camco_exit_rec_pause_state(void);
static void mmi_camco_exit_rec_saving_state(void);
static void mmi_camco_exit_rec_save_done_state(void);
static void mmi_camco_exit_rec_saving_prev_state(void);

#ifndef __MMI_CAMCO_FTE__
static void mmi_camco_rec_preview_set_key_hdlr(void);
static void mmi_camco_rec_preview_no_card_set_key_hdlr(void);
static void mmi_camco_rec_setting_menu_set_key_hdlr(void);
static void mmi_camco_rec_preview_failed_set_key_hdlr(void);
static void mmi_camco_rec_recording_set_key_hdlr(void);
static void mmi_camco_rec_pause_set_key_hdlr(void);
static void mmi_camco_rec_save_done_set_key_hdlr(void);
//static void mmi_camco_rec_save_done_storage_fail_set_key_hdlr(void);
#endif /* __MMI_CAMCO_FTE__ */ 
static void mmi_camco_rec_focus_set_key_hdlr(void);
static MDI_RESULT mmi_camco_rec_power_on(void);
static void mmi_camco_rec_power_off(void);
static BOOL mmi_camco_rec_preview_start(void);
static void mmi_camco_rec_preview_stop(void);
static void mmi_camco_rec_autofocus_start(void);
static void mmi_camco_rec_autofocus_stop(void);
static MDI_RESULT mmi_camco_rec_record_start(void);
static MDI_RESULT mmi_camco_rec_record_pause(void);
static MDI_RESULT mmi_camco_rec_record_resume(void);
static void mmi_camco_rec_record_stop(void);
static void mmi_camco_rec_save_file(void);
static void mmi_camco_rec_record_tone_finish_hdlr(void);
static void mmi_camco_rec_record_timer_cyclic(void);

static void mmi_camco_rec_preview_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_preview_no_card_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_preview_csk_pressed(mmi_key_types_enum key_type);
static void mmi_camco_rec_preview_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_preview_autofocus_button_pressed(void);
static void mmi_camco_rec_record_button_pressed(void);
static void mmi_camco_rec_preview_failed_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_setting_menu_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_setting_menu_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_preview_autofocus_button_pressed(void);
static void mmi_camco_rec_preview_autofocus_button_released(void);
static void mmi_camco_rec_recording_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_recording_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_pause_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_pause_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_save_done_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_save_done_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_save_done_csk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_save_done_option_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_save_done_option_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_delete_confirm_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_delete_confirm_rsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_forward_menu_lsk_released(mmi_key_types_enum key_type);
static void mmi_camco_rec_forward_menu_rsk_released(mmi_key_types_enum key_type);

static void mmi_camco_rec_delete_confirm(void);
static void mmi_camco_rec_forward_menu(void);
static void mmi_camco_rec_entry_playing(void);

#ifdef __MMI_CAMCO_FTE__
void mmi_camco_cam_preview_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_preview_failed_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_setting_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_save_done_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_countdown_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_save_done_storage_fail_evt_hdlr(
        mmi_cameco_evt_type_enum evt_type,
        mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_contshot_select_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_burstshot_select_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_aebshot_select_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_smile_dect_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_hdr_shot_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_hdr_done_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_restore_confirm_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_sub_preview_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_preview_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_setting_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_preview_failed_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_recording_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_pause_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_save_done_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_save_done_storage_fail_evt_hdlr(
        mmi_cameco_evt_type_enum evt_type,
        mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_add_frame_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_forward_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_forward_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_cam_delete_confirm_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
void mmi_camco_rec_delete_confirm_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param);
#endif /* __MMI_CAMCO_FTE__ */ 

static void mmi_camco_rec_autofocus_result_hdlr(mdi_video_rec_af_result_struct result_ind, void* user_data);

static void mmi_camco_rec_record_result_hdlr_callback(MDI_RESULT result, void* user_data);
static void mmi_camco_rec_save_result_hdlr_callback(MDI_RESULT result, void* user_data);
static void mmi_camco_rec_timelimit_hdlr(void);

static void mmi_camco_show_error_msg(MDI_RESULT result);
static U16 mmi_camco_mapping_error_string(MDI_RESULT result, mmi_event_notify_enum *popup_type);

static void mmi_camco_resume_from_cui(void);
static void mmi_camco_ext_resume_from_cui(void);

void mmi_camco_browse_recorded_file(void);
#if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )
static void mmi_camco_motion_tilt_hdlr(srv_sensor_type_enum sensor_type, 
               void *sensor_data, void *user_data);
#endif
#ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
void mmi_camco_enter_cam_mav_shot_state(void);
void mmi_camco_exit_cam_mav_shot_state(void);
MDI_RESULT mmi_camco_cam_mav_shot(void);
static void mmi_camco_cam_mav_capture_result_hdlr(mdi_camera_mav_capture_struct* result_ind, void* user_data);
static void mmi_camco_cam_mav_save_result_hdlr(mdi_camera_mav_result_struct* result_ind, void* user_data);
mmi_ret mmi_camco_cam_view_group_proc(mmi_event_struct *evt);
static void mmi_camco_cam_entry_image_view_cui(void);

#endif

#ifdef __MMI_INTERACTIVE_PROFILNG__
U32 start_ticks = 0;
U32 end_ticks = 0;
double tick_elapsed;
extern MMI_BOOL mmi_frm_profiling_interactive_is_enabled(void);
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
static mmi_ret mmi_camcorder_launch_app(mmi_event_struct *evt);

CHAR g_mmi_camco_ext_calling_save_file[SRV_FMGR_PATH_BUFFER_SIZE] = {0};
typedef struct
{
    MMI_EVT_PARAM_HEADER
    MMI_ID app_id;
} mmi_camco_app_post_launch_event_struct;

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_profiling_log
 * DESCRIPTION
 *  EM save capture profiling log
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_notify_storage_change_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  notify_flag     [IN]        
 *  para            [IN]        
 * RETURNS
 *  
 *****************************************************************************/
//BOOL mmi_camco_notify_storage_change_hdlr(U32 notify_flag, void *para)
mmi_ret mmi_camco_notify_storage_change_hdlr(mmi_event_struct *evt)
{
#ifdef __MMI_FMGR_SUPPORT_DEFAULT_STORAGE__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 drv;
    srv_fmgr_notification_set_def_storage_event_struct *storage_evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
    {
        case EVT_ID_SRV_FMGR_NOTIFICATION_SET_DEF_STORAGE:
            storage_evt = (srv_fmgr_notification_set_def_storage_event_struct*)evt;
            if(storage_evt->state ==SRV_FMGR_NOTIFICATION_STATE_AFTER )
            {
                drv = (U8)storage_evt->drv_letter;
                mmi_camco_set_storage(drv);
            }                                
            break;
    }    
#endif /* __MMI_FMGR_SUPPORT_DEFAULT_STORAGE__ */ 
    return MMI_RET_OK;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_app
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_exit_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_from_external())
    {
        app = mmi_camco_setting_get_active_app();
        if (app == MMI_CAMCO_SETTING_APP_CAMERA)
        {
            cui_camera_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_CAMERA_EVENT_RESULT_FAILED;
            evt.file_path = NULL;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }
        else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
        {
            cui_vdorec_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_vdorec_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_VDOREC_RECORD_EVENT_RESULT_FAILED;
            evt.file_path = NULL;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }
    }
    else
    {
        cui_camco_event_struct evt;

        MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camco_event_struct), SCR_GROUP_ID_CAMCO_INT_APP);
        evt.evt_id = CUI_CAMCO_EVENT_RESULT_SUCCESS;
        mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_INT_APP, (mmi_group_event_struct*) & evt);

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_slient_mode
 * DESCRIPTION
 *  mmi_camco_is_slient_mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_camco_is_slient_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_SILENT_MODE_SUPPORT__
    if (srv_prof_is_profile_activated(SRV_PROF_SILENT_MODE) == TRUE)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
#else /* __MMI_CAMCO_SILENT_MODE_SUPPORT__ */ 
    return MMI_FALSE;
#endif /* __MMI_CAMCO_SILENT_MODE_SUPPORT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_set_base_layer
 * DESCRIPTION
 *  mmi_camco_set_base_layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/ 
static void mmi_camco_set_base_layer(gdi_handle *handle, MMI_BOOL is_non_preview_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base;
    S32 width, height;
    S32 x, y;    
    U8* dst_p;
    S32 x1, y1, x2, y2;
    mdi_util_create_hw_layer_extmemory_in_struct  layer_in;
    mdi_util_create_hw_layer_out_struct layer_out;   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!g_mmi_camco_cntx.has_got_base_layer)
    {
        gdi_layer_get_base_handle(&base);

        gdi_layer_push_and_set_active(base);     
        gdi_layer_clear(GDI_COLOR_BLACK);   
        gdi_layer_pop_and_restore_active();         

        /*add get preview_base_layer_handle by HW layer here */
        layer_in.buffer = g_mmi_camco_cntx.app_preview_mem_buf_p;
        layer_in.buffer_size = LCD_WIDTH*LCD_HEIGHT*2;        
        layer_in.offset_x = 0;
        layer_in.offset_y = 0;
        layer_in.width = LCD_WIDTH;
        layer_in.height = LCD_HEIGHT;

        g_mmi_camco_cntx.preview_base_layer_handle = mdi_util_hw_layer_create_with_extmemory(&layer_in, &layer_out);
        
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.preview_base_layer_handle);
        gdi_layer_get_dimension(&width, &height);
        gdi_layer_get_position(&x, &y);           
        gdi_layer_get_buffer_ptr(&dst_p);
        gdi_layer_get_clip(&x1, &y1, &x2, &y2);        
        gdi_layer_set_background(GDI_COLOR_BLACK);        
        gdi_layer_pop_and_restore_active(); 
                
        gdi_layer_create_cf_using_outside_memory(
            GDI_COLOR_FORMAT_16,
            0,
            0,
            width, 
            height, 
            &g_mmi_camco_cntx.non_preview_base_layer_handle,
            (U8*) dst_p,
            (width * height * MMI_CAMCO_OSD_BYTE_PER_PIXEL));    
        
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_set_background(GDI_COLOR_BLACK);        
        gdi_layer_set_position(x, y);        
        gdi_layer_set_rotate(0);
        gdi_layer_set_clip(x1, y1, x2, y2);            
        gdi_layer_pop_and_restore_active();              
        
        g_mmi_camco_cntx.is_priview_layer_active = is_non_preview_layer;
        g_mmi_camco_cntx.has_got_base_layer = MMI_TRUE;    

    }
    else
    {
        if(is_non_preview_layer)
        {   
            if(g_mmi_camco_cntx.is_priview_layer_active )
            {
                gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
				gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);
                gdi_layer_clear(GDI_COLOR_BLACK);      
                gdi_layer_pop_and_restore_active();                  
            }
            g_mmi_camco_cntx.is_priview_layer_active = MMI_FALSE;                    
        }
        else
        {        
            if(!g_mmi_camco_cntx.is_priview_layer_active )
            {
                gdi_layer_push_and_set_active(g_mmi_camco_cntx.preview_base_layer_handle);
                gdi_layer_clear(GDI_COLOR_BLACK);      
                gdi_layer_pop_and_restore_active();                  
            }        
            g_mmi_camco_cntx.is_priview_layer_active = MMI_TRUE;            
        }        
    }    

    if(is_non_preview_layer)
    {
        (*handle) = g_mmi_camco_cntx.non_preview_base_layer_handle;
        mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.non_preview_base_layer_handle);
        mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.preview_base_layer_handle);        
    }
    else
    {
        (*handle) = g_mmi_camco_cntx.preview_base_layer_handle;    
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_turn_on_lcd_backlight
 * DESCRIPTION
 *  mmi_camco_turn_on_lcd_backlight
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_turn_on_lcd_backlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_turn_off_lcd_backlight
 * DESCRIPTION
 *  mmi_camco_turn_off_lcd_backlight
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_turn_off_lcd_backlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_backlight_turn_off();
    srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_init_countdown_mma
 * DESCRIPTION
 *  mmi_camco_init_countdown_mma
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_init_countdown_mma(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set flag */
    if (!mmi_camco_is_slient_mode())
    {
        /* open and play a dummy midi at backgroup - this is a must do to play multi-channel sound */
        #if !defined(__AUDIO_ULTRA_SLIM__)
            mmi_camco_cam_p->multi_sound_dummy_bg = mdi_audio_mma_open_string(0, (void*)camco_sound_dummy_bg, CAMCO_SOUND_DUMMY_BG_LEN, MDI_FORMAT_SMF, 0, NULL, NULL);
            mdi_audio_mma_play(mmi_camco_cam_p->multi_sound_dummy_bg);
        #endif
        mmi_camco_cam_p->countaud_data = get_audio((U16) (AUD_ID_CAMCO_COUNTDOWN), &mmi_camco_cam_p->countaud_type, &mmi_camco_cam_p->countaud_len);

        mmi_camco_cam_p->multi_sound_countdown = mdi_audio_mma_open_string(
                                                    0,
                                                    (void*)camco_sound_countdown,
                                                    (U32) CAMCO_SOUND_COUNTDOWN_LEN,
                                                    MDI_FORMAT_WAV,
                                                    1,
                                                    NULL,
                                                    NULL);
    }        
}


static void mmi_camco_play_autofocus_success_sound_callback(mdi_result result, void* user_data)
{
    g_mmi_camco_cntx.is_playing_focused_wav = MMI_FALSE;

    if (g_mmi_camco_cntx.is_capture_when_focused == MMI_TRUE)
    {
        g_mmi_camco_cntx.is_capture_when_focused = MMI_FALSE;
        mmi_camco_cam_capture_button_pressed();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_play_autofocus_success_sound
 * DESCRIPTION
 *  play shutter sound
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_play_autofocus_success_sound(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_slient_mode())
    {
        return;
    }

    g_mmi_camco_cntx.is_playing_focused_wav = MMI_TRUE;
    g_mmi_camco_cntx.is_camera_key_release = MMI_FALSE;

    mdi_audio_play_string_with_vol_path(
        (void*)camco_af_succeed,
        688,
        MDI_FORMAT_WAV,
        DEVICE_AUDIO_PLAY_ONCE,
        mmi_camco_play_autofocus_success_sound_callback,
        NULL,
        MDI_AUD_VOL_4,
        MDI_DEVICE_SPEAKER_BOTH);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_deinit_countdown_mma
 * DESCRIPTION
 *  mmi_camco_deinit_countdown_mma
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_deinit_countdown_mma(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_is_slient_mode())
    {    
    	  #if !defined(__AUDIO_ULTRA_SLIM__)
            mdi_audio_mma_stop(mmi_camco_cam_p->multi_sound_dummy_bg);
            mdi_audio_mma_close(mmi_camco_cam_p->multi_sound_dummy_bg);
        #endif
        mdi_audio_mma_stop(mmi_camco_cam_p->multi_sound_countdown);
        mdi_audio_mma_close(mmi_camco_cam_p->multi_sound_countdown);

        mmi_camco_cam_p->multi_sound_countdown = 0;
        mmi_camco_cam_p->multi_sound_dummy_bg = 0;
    }        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_error_hdlr_timer_start
 * DESCRIPTION
 *  mmi_camco_error_hdlr_timer_start
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_error_hdlr_timer_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearAllKeyHandler();
    gui_start_timer(MMI_CAMCO_ERROR_TIMER_DUR, mmi_camco_error_hdlr);
    g_mmi_camco_cntx.is_errortimer_start = MMI_TRUE;

    mmi_camco_highlight_turn_off();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_error_hdlr_timer_stop
 * DESCRIPTION
 *  mmi_camco_error_hdlr_timer_stop
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_error_hdlr_timer_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_error_hdlr);
    g_mmi_camco_cntx.is_errortimer_start = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_hilight_app
 * DESCRIPTION
 *  app menu item hilight hdlr
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_hilight_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(mmi_camco_launch, KEY_EVENT_UP);    
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetCenterSoftkeyFunction(mmi_camco_launch, KEY_EVENT_UP);     
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_switch_main_camera
 * DESCRIPTION
 *  switch to main cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_switch_main_camera(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switchto_maincamera = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_switch_sub_camera
 * DESCRIPTION
 *  switch to sub cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_switch_sub_camera(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switchto_subcamera = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_switch_app
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_switch_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switching_app = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_switch_to_imgviewer
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_camco_switch_non_avaiable_storage(MMI_BOOL is_not_avaiable)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switchto_non_avaiable_storage = is_not_avaiable;

}    


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_switch_to_imgviewer
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_switch_to_imgviewer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->is_switchto_imgviewer = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_switch_to_vdoply
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_switch_to_vdoply(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_p->is_switchto_vdoply = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_unswitch_main_camera
 * DESCRIPTION
 *  switch to main cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_unswitch_main_camera(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switchto_maincamera = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_unswitch_sub_camera
 * DESCRIPTION
 *  switch to sub cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_unswitch_sub_camera(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switchto_subcamera = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_unswitch_app
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_unswitch_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_switching_app = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_unswitch_to_imgviewer
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_unswitch_to_imgviewer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->is_switchto_imgviewer = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_unswitch_to_vdoply
 * DESCRIPTION
 *  switch to cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_unswitch_to_vdoply(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_p->is_switchto_vdoply = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_if_need_restart_preview
 * DESCRIPTION
 *  restart camera preview for setting change
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_camco_if_need_restart_preview(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_mmi_camco_cntx.is_restart_preview;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_need_restart_preview
 * DESCRIPTION
 *  restart camera preview for setting change
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_need_restart_preview(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_record_time
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  record time
 *****************************************************************************/
U64 mmi_camco_get_record_time(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_camco_rec_p->rec_time;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_record_frame
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  record time
 *****************************************************************************/
U64 mmi_camco_get_record_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_camco_rec_p->rec_frame;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_predict_record_time
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  record time
 *****************************************************************************/
U64 mmi_camco_get_predict_record_time(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_camco_rec_p->predict_rec_time;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_record_progress_ratio
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  ratio
 *****************************************************************************/
U16 mmi_camco_get_record_progress_ratio(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_camco_rec_p->rec_progress_ratio;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_set_option_menulist_highlight_idx
 * DESCRIPTION
 *  
 * PARAMETERS
 *  value       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_set_option_menulist_highlight_idx(S32 value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.highlight_idx = value;
}

#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_multiselect_img_info
 * DESCRIPTION
 *  
 * PARAMETERS
 *  img_num                 [IN]        
 *  img_p                   [OUT]       Image array pointer
 *  cache_imgdata_pp        [OUT]       Image cache array pointer
 *  save_flag_p             [OUT]       Image save flag array pointer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_get_multiselect_img_info(
        U8 *img_num,
        mdi_camera_jpegs_struct **img_p,
        U8 ***cache_imgdata_pp,
        MMI_BOOL **save_flag_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)
    {
    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
        *img_num = MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT;
        *img_p = &mmi_camco_cam_p->burstshot.jpeg_data;
        *cache_imgdata_pp = mmi_camco_cam_p->burstshot.cache_img_p;
        *save_flag_p = mmi_camco_cam_p->burstshot.is_saved;
    #endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
        *img_num = MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT;
        *img_p = &mmi_camco_cam_p->aebshot.jpeg_data;
        *cache_imgdata_pp = mmi_camco_cam_p->aebshot.cache_img_p;
        *save_flag_p = mmi_camco_cam_p->aebshot.is_saved;
    #endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_multishot_delete_confirm_lsk_released
 * DESCRIPTION
 *  camera delete confirm option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_multishot_delete_confirm_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 idx;
    CHAR* buf_filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);

    FS_Delete((U16*) buf_filename);
    memset(buf_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_TRUE);
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)    
    {        
    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__        
        mmi_camco_cam_p->burstshot.is_saved[idx] = MMI_FALSE;    
    #endif
    }        
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)      
    {   
    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__             
        mmi_camco_cam_p->aebshot.is_saved[idx] = MMI_FALSE;          
    #endif        
    }        
#endif 
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)
    {
    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
        mmi_camco_cam_p->burstshot.is_saved[idx] = MMI_FALSE;

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);        
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_burstshot_select_set_key_hdlr();
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #endif /* __MMI_CAMCO_FTE__ */ 
    #endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
        mmi_camco_cam_p->aebshot.is_saved[idx] = MMI_FALSE;

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);            
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_aebshot_select_set_key_hdlr();
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #endif /* __MMI_CAMCO_FTE__ */ 
    #endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 
    }
    mmi_camco_osd_draw_osd();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_updata_key_handler
 * DESCRIPTION
 *  change key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_updata_key_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)
    {
    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);        
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_burstshot_select_set_key_hdlr();
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #endif /* __MMI_CAMCO_FTE__ */ 
    #endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);            
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_aebshot_select_set_key_hdlr();
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #endif /* __MMI_CAMCO_FTE__ */ 
    #endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 
    }
    else
    {
        MMI_ASSERT(0);
    }

}
#endif /* defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_preview_region
 * DESCRIPTION
 *  get preview region coordinate
 * PARAMETERS
 *  offset_x_p      [OUT]       
 *  offset_y_p      [OUT]       
 *  width_p         [OUT]       
 *  height_p        [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_get_preview_region(S32 *offset_x_p, S32 *offset_y_p, S32 *width_p, S32 *height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *offset_x_p = g_mmi_camco_cntx.preview_wnd.offset_x;
    *offset_y_p = g_mmi_camco_cntx.preview_wnd.offset_y;
    *width_p = g_mmi_camco_cntx.preview_wnd.width;
    *height_p = g_mmi_camco_cntx.preview_wnd.height;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_config_base_layer
 * DESCRIPTION
 *  mmi_camco_cam_config_base_layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_config_base_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_resize(LCD_HEIGHT, LCD_WIDTH);
        gdi_layer_set_position(0, 0);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    
        gdi_layer_set_background(GDI_COLOR_BLACK);       
    }
    else
#endif        
    {
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_resize(LCD_WIDTH, LCD_HEIGHT);
        gdi_layer_set_position(0, 0);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    
        gdi_layer_set_background(GDI_COLOR_BLACK);            
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);        
    }    
    gdi_layer_pop_and_restore_active();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_config_preview_layer
 * DESCRIPTION
 *  mmi_camco_cam_config_preview_layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_config_preview_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_get_preview_window(MMI_CAMCO_CAM_PREVIEW_MAINLCD);

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.preview_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.preview_wnd.width, g_mmi_camco_cntx.preview_wnd.height);
    gdi_layer_set_position(g_mmi_camco_cntx.preview_wnd.offset_x, g_mmi_camco_cntx.preview_wnd.offset_y);
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    
    gdi_layer_set_background(GDI_COLOR_BLACK);   
#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);        
    }
    else
#endif
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);        
    }    
    gdi_layer_pop_and_restore_active();

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.quickview_wnd.width, g_mmi_camco_cntx.quickview_wnd.height);
    gdi_layer_set_position( g_mmi_camco_cntx.quickview_wnd.offset_x,g_mmi_camco_cntx.quickview_wnd.offset_y);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    
    gdi_layer_set_background(GDI_COLOR_BLACK);
   
    gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);          
    gdi_layer_pop_and_restore_active();
          
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_config_preview_layer
 * DESCRIPTION
 *  mmi_camco_rec_config_preview_layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_config_preview_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_get_preview_window();

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.preview_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.preview_wnd.width, g_mmi_camco_cntx.preview_wnd.height);
    gdi_layer_set_position(g_mmi_camco_cntx.preview_wnd.offset_x, g_mmi_camco_cntx.preview_wnd.offset_y);
    gdi_layer_clear(GDI_COLOR_BLACK);
	  gdi_layer_set_color_format(GDI_COLOR_FORMAT_UYVY422);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    
    gdi_layer_set_background(GDI_COLOR_BLACK);  
#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);        
    }
    else
#endif
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);        
    }    
    gdi_layer_pop_and_restore_active();

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.quickview_wnd.width, g_mmi_camco_cntx.quickview_wnd.height);
    gdi_layer_set_position(g_mmi_camco_cntx.quickview_wnd.offset_x, g_mmi_camco_cntx.quickview_wnd.offset_y);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    

    gdi_layer_set_background(GDI_COLOR_BLACK);
    
    gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);        
    gdi_layer_pop_and_restore_active();

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_check_filename
 * DESCRIPTION
 *  get the first file name for jpeg image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_check_filename(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    U16 filename_seq_no;
    U32 start_to_check = 0;
    U32 end_to_check = 0;
    float duration;
    U32 tick_elapsed_fraction;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_get_time(&start_to_check);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);
    kal_get_time(&end_to_check);

    duration = (end_to_check - start_to_check);
    duration = ((float)duration * 4.615);   /* msec */
    tick_elapsed_fraction = (end_to_check - start_to_check) * 4615 - ((int)duration) * 1000;

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_CHECK_FILENAME, (int)duration, tick_elapsed_fraction);

    ReadValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
    filename_seq_no--;
    WriteValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_get_next_filename
 * DESCRIPTION
 *  get next file name for jpeg image
 * PARAMETERS
 *  filepath_buf_p      [OUT]       Next filename
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_get_next_filename(CHAR* filepath_buf_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define CAMCO_TEMP_BUFFER_LENGTH    (50)
#define CAMCO_MAX_FILE_NUM          (20000)

    CHAR buffer[CAMCO_TEMP_BUFFER_LENGTH];
    CHAR ucs2_buffer[CAMCO_TEMP_BUFFER_LENGTH];
    CHAR ucs2_testname[CAMCO_TEMP_BUFFER_LENGTH];
    S16 error = 0;
    U16 filename_seq_no;
    FS_HANDLE file_handle;
    U32 left = 0;
    U32 right = 0;
    U32 mid = 0;
    S32 last_file_exist_num = -1;

    MMI_BOOL is_binary_search = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get/store sequentail number */
    ReadValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
    if (filename_seq_no == 0xffff)
    {
        filename_seq_no = 1;    /* init value */
    }
    else
    {
        filename_seq_no++;

        if (filename_seq_no > 20000)    /* more than 4 digits */
        {
            filename_seq_no = 1;
        }
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_GET_NEXT_FILENAME, (int)filename_seq_no);

    sprintf(buffer, "IMG%05d", filename_seq_no);
    mmi_asc_to_ucs2( ucs2_buffer,  buffer);

    mmi_ucs2cpy(ucs2_testname, ucs2_buffer);
#ifdef __MMI_CAMCO_FEATURE_CAM_MAV_MODE__
	if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE)==MMI_CAMCO_CAPMODE_MAV)
	{
		mmi_ucs2cat(ucs2_testname, (const CHAR*) L".mav");
	
	}
	else
#endif
	{
		mmi_ucs2cat(ucs2_testname, (const CHAR*) L".jpg");
	}

    mmi_ucs2cpy(filepath_buf_p, (const CHAR*) mmi_camco_cam_p->storage_filepath_p);
    mmi_ucs2cat(filepath_buf_p, (const CHAR*) ucs2_testname);

    file_handle = FS_GetAttributes((WCHAR*) filepath_buf_p);
    if (file_handle >= 0)
    {
        /* file exist */
        is_binary_search = MMI_TRUE;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_FILE_EXIT);
    }
    else
    {
        /* file not exist */
        WriteValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_FILE_NOT_EXIT);
        return;
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_IS_BINARY_SEARCH, is_binary_search);

    if (is_binary_search)
    {
        left = filename_seq_no + 1;
        right = CAMCO_MAX_FILE_NUM;

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_BINARY_SEARCH_INFO, left, right);

        while (left < right)
        {
            mid = (left + right) / 2;

            sprintf( buffer, "IMG%05d", mid);
            mmi_asc_to_ucs2(ucs2_buffer,  buffer);

            mmi_ucs2cpy(ucs2_testname, ucs2_buffer);
	    #ifdef __MMI_CAMCO_FEATURE_CAM_MAV_MODE__
             if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE)==MMI_CAMCO_CAPMODE_MAV)
             {
				 mmi_ucs2cat(ucs2_testname, (const CHAR*) L".mav");

			 }
			 else
		#endif
			{
			    mmi_ucs2cat(ucs2_testname, (const CHAR*) L".jpg");
			}

            mmi_ucs2cpy( filepath_buf_p,  mmi_camco_cam_p->storage_filepath_p);
            mmi_ucs2cat( filepath_buf_p,  ucs2_testname);

            file_handle = FS_GetAttributes((U16*) filepath_buf_p);
            if (file_handle >= 0)
            {
                /* file exist */
                left = mid + 1;
                last_file_exist_num = mid;
            }
            else
            {
                /* file not exit. return */
                right = mid - 1;
                if (mid == last_file_exist_num + 1)
                {
                    WriteValue(NVRAM_CAM_FILENAME_SEQ_NO, &mid, DS_SHORT, &error);
                    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_FILE_NAME_WRITE_MID, mid);
                    return;
                }
            }
        }

        if (right <= left)
        {
            WriteValue(NVRAM_CAM_FILENAME_SEQ_NO, &right, DS_SHORT, &error);

            sprintf( buffer, "IMG%05d", right);
            mmi_asc_to_ucs2( ucs2_buffer,  buffer);

            mmi_ucs2cpy(ucs2_testname,ucs2_buffer);
        #ifdef __MMI_CAMCO_FEATURE_CAM_MAV_MODE__
             if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE)==MMI_CAMCO_CAPMODE_MAV)
             {
				 mmi_ucs2cat(ucs2_testname, (const CHAR*) L".mav");

			 }
			 else
        #endif
			{
			    mmi_ucs2cat(ucs2_testname, (const CHAR*) L".jpg");
			}

            mmi_ucs2cpy( filepath_buf_p,  mmi_camco_cam_p->storage_filepath_p);
            mmi_ucs2cat( filepath_buf_p,  ucs2_testname);

            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_FILE_NAME_WRITE_RIGHT, right);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_restore_filename_seq_no
 * DESCRIPTION
 *  get next file name for jpeg image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_restore_filename_seq_no(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    U16 filename_seq_no;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);

    if (filename_seq_no == 1)
    {
        filename_seq_no = 9999;
    }
    else
    {
        filename_seq_no--;
    }
    WriteValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_camscenemode
 * DESCRIPTION
 *  mmi_camco_get_cmd_camscenemode
 * PARAMETERS
 *  capmode     [IN]        Capmode setting value
 * RETURNS
 *  mdi camera scenemode value
 *****************************************************************************/
static U32 mmi_camco_get_cmd_camscenemode(U16 capmode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (capmode)
    {
        case MMI_CAMCO_CAMSCENEMODE_AUTO:
            return MDI_CAMERA_SCENE_MODE_AUTO;
           // break;

        case MMI_CAMCO_CAMSCENEMODE_PORTRAIT:
            return MDI_CAMERA_SCENE_MODE_PORTRAIT;
            //break;

        case MMI_CAMCO_CAMSCENEMODE_LANDSCAPE:
            return MDI_CAMERA_SCENE_MODE_LANDSCAPE;
            //break;

        case MMI_CAMCO_CAMSCENEMODE_SPORT:
            return MDI_CAMERA_SCENE_MODE_SPORT;
            //break;

        case MMI_CAMCO_CAMSCENEMODE_NIGHT:
            return MDI_CAMERA_SCENE_MODE_NIGHT;
            //break;

        case MMI_CAMCO_CAMSCENEMODE_DOCUMENT:
            return MDI_CAMERA_SCENE_MODE_DOCUMENT;
            //break;

        case MMI_CAMCO_CAMSCENEMODE_ANTI_SHAKE:
            return MDI_CAMERA_SCENE_MODE_ISO_ANTI_HAND_SHAKE;
            //break;
        case MMI_CAMCO_CAMSCENEMODE_FLOWER:
            return MDI_CAMERA_SCENE_MODE_FLOWER;
            //break;
            
        case MMI_CAMCO_CAMSCENEMODE_BACKLIGHT_PORTRAIT:
            return MDI_CAMERA_SCENE_MODE_BACKLIGHT_PORTRAIT;
            //break;
            
        case MMI_CAMCO_CAMSCENEMODE_NIGHT_PORTRAIT:
            return MDI_CAMERA_SCENE_MODE_NIGHT_PORTRAIT;
           // break;

        case MMI_CAMCO_CAMSCENEMODE_BACKLIGHT:  
            return MDI_CAMERA_SCENE_MODE_BACKLIGHT;
           // break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_capsize
 * DESCRIPTION
 *  mmi_camco_get_cmd_capsize
 * PARAMETERS
 *  width_p         [OUT]       Capture width
 *  height_p        [OUT]       Capture height
 * RETURNS
 *  void
 *****************************************************************************/
extern U16 mmi_camco_get_cmd_capsize(U16 *width_p, U16 *height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_capsize_enum capsize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    capsize =(mmi_camco_capsize_enum)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE);

	mmi_camco_cam_setting_get_setting_dimention((U16)capsize, width_p, height_p);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_iso
 * DESCRIPTION
 *  mmi_camco_get_cmd_iso
 * PARAMETERS
 *  iso     [IN]        Iso setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_iso(U16 iso)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (iso)
    {
        case MMI_CAMCO_ISO_AUTO:
            return MDI_CAMERA_ISO_AUTO;
            //break;

        case MMI_CAMCO_ISO_100:
            return MDI_CAMERA_ISO_100;
            //break;

        case MMI_CAMCO_ISO_200:
            return MDI_CAMERA_ISO_200;
            //break;

        case MMI_CAMCO_ISO_400:
            return MDI_CAMERA_ISO_400;
            //break;

        case MMI_CAMCO_ISO_800:
            return MDI_CAMERA_ISO_800;
            //break;

        case MMI_CAMCO_ISO_1600:
            return MDI_CAMERA_ISO_1600;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_capqty
 * DESCRIPTION
 *  mmi_camco_get_cmd_capqty
 * PARAMETERS
 *  capqty      [IN]        Capqty setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_capqty(U16 capqty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (capqty)
    {
        case MMI_CAMCO_CAPQTY_FINE:
            return MDI_CAMERA_JPG_QTY_HIGH;
            //break;

        case MMI_CAMCO_CAPQTY_GOOD:
            return MDI_CAMERA_JPG_QTY_NORMAL;
            //break;

        case MMI_CAMCO_CAPQTY_NORMAL:
            return MDI_CAMERA_JPG_QTY_LOW;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_flash
 * DESCRIPTION
 *  mmi_camco_get_cmd_flash
 * PARAMETERS
 *  flash       [IN]        Flash setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_flash(U16 flash)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (flash)
    {
        case MMI_CAMCO_FLASH_AUTO:
            return MDI_CAMERA_FLASH_AUTO;
            //break;

        case MMI_CAMCO_FLASH_OFF:
            return MDI_CAMERA_FLASH_OFF;
            //break;

        case MMI_CAMCO_FLASH_FORCE_ON:
            return MDI_CAMERA_FLASH_ON;
            //break;

        case MMI_CAMCO_FLASH_RED_EYE:
            return MDI_CAMERA_FLASH_REDEYE;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_afrange
 * DESCRIPTION
 *  mmi_camco_get_cmd_autofocus_range
 * PARAMETERS
 *  afrange     [IN]        Afrange setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_afrange(U16 afrange)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (afrange)
    {
        case MMI_CAMCO_AFRANGE_AUTO:
            return MDI_CAMERA_AF_RANGE_AUTO;
            //break;

        case MMI_CAMCO_AFRANGE_MACRO:
            return MDI_CAMERA_AF_RANGE_MACRO;
            //break;

        case MMI_CAMCO_AFRANGE_INFINTE:
            return MDI_CAMERA_AF_RANGE_LANDSCAPE;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_ev
 * DESCRIPTION
 *  mmi_camco_get_cmd_ev
 * PARAMETERS
 *  ev      [IN]        Ev setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_ev(U16 ev)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (ev)
    {
        case MMI_CAMCO_EV_N4:
            return MDI_CAMERA_EV_N4;
            //break;

        case MMI_CAMCO_EV_N3:
            return MDI_CAMERA_EV_N3;
            //break;

        case MMI_CAMCO_EV_N2:
            return MDI_CAMERA_EV_N2;
            //break;

        case MMI_CAMCO_EV_N1:
            return MDI_CAMERA_EV_N1;
            //break;

        case MMI_CAMCO_EV_0:
            return MDI_CAMERA_EV_0;
            //break;

        case MMI_CAMCO_EV_P1:
            return MDI_CAMERA_EV_P1;
            //break;

        case MMI_CAMCO_EV_P2:
            return MDI_CAMERA_EV_P2;
            //break;

        case MMI_CAMCO_EV_P3:
            return MDI_CAMERA_EV_P3;
            //break;

        case MMI_CAMCO_EV_P4:
            return MDI_CAMERA_EV_P4;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_wb
 * DESCRIPTION
 *  mmi_camco_get_cmd_wb
 * PARAMETERS
 *  wb      [IN]        Wb setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_wb(U16 wb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (wb)
    {
        case MMI_CAMCO_WB_AUTO:
            return MDI_CAMERA_WB_AUTO;
            //break;

        case MMI_CAMCO_WB_DAYLIGHT:
            return MDI_CAMERA_WB_DAYLIGHT;
            //break;

        case MMI_CAMCO_WB_TUNGSTEN:
            return MDI_CAMERA_WB_TUNGSTEN;
            //break;

        case MMI_CAMCO_WB_FLUORESCENT:
            return MDI_CAMERA_WB_FLUORESCENT;
            //break;

        case MMI_CAMCO_WB_CLOUDY:
            return MDI_CAMERA_WB_CLOUD;
            //break;

        case MMI_CAMCO_WB_INCANDESCENT:
            return MDI_CAMERA_WB_INCANDESCENCE;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_camera_id
 * DESCRIPTION
 *  mmi_camco_get_cmd_camera_id
 * PARAMETERS
 *  cam_id      [IN]        
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_camera_id(U16 cam_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (cam_id)
    {
        case MMI_CAMCO_SETTING_CAM_MAIN:
            return MDI_CAMERA_MAIN;
            //break;

        case MMI_CAMCO_SETTING_CAM_SUB:
            return MDI_CAMERA_SUB;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
           // break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_effect
 * DESCRIPTION
 *  mmi_camco_get_cmd_effect
 * PARAMETERS
 *  effect      [IN]        Effect setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_effect(U16 effect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (effect)
    {
        case MMI_CAMCO_EFFECT_NORMAL:
            return MDI_CAMERA_EFFECT_NOMRAL;
            //break;
		case MMI_CAMCO_EFFECT_LOMO:
			return MDI_CAMERA_EFFECT_LOMO;
				//break;
		case MMI_CAMCO_EFFECT_RED_ACCENT:
			return MDI_CAMERA_EFFECT_COLOR_RED;
					//break;
        case MMI_CAMCO_EFFECT_BLUE_ACCENT:
            return MDI_CAMERA_EFFECT_COLOR_BLUE;
            //break;
        case MMI_CAMCO_EFFECT_GREEN_ACCENT:
            return MDI_CAMERA_EFFECT_COLOR_GREEN;
            //break;
        case MMI_CAMCO_EFFECT_YELLOW_ACCENT:
            return MDI_CAMERA_EFFECT_COLOR_YELLOW;
            //break;

        case MMI_CAMCO_EFFECT_GRAYSCALE:
            return MDI_CAMERA_EFFECT_GRAYSCALE;
            //break;

        case MMI_CAMCO_EFFECT_SEPIA:
            return MDI_CAMERA_EFFECT_SEPIA;
            //break;

        case MMI_CAMCO_EFFECT_SEPIA_GREEN:
            return MDI_CAMERA_EFFECT_SEPIA_GREEN;
            //break;

        case MMI_CAMCO_EFFECT_SEPIA_BLUE:
            return MDI_CAMERA_EFFECT_SEPIA_BLUE;
            //break;

        case MMI_CAMCO_EFFECT_COLOR_INVERT:
            return MDI_CAMERA_EFFECT_COLOR_INVERT;
           // break;

        case MMI_CAMCO_EFFECT_GRAY_INVERT:
            return MDI_CAMERA_EFFECT_GRAY_INVERT;
            //break;

        case MMI_CAMCO_EFFECT_BLACKBOARD:
            return MDI_CAMERA_EFFECT_BLACKBOARD;
            //break;

        case MMI_CAMCO_EFFECT_WHITEBOARD:
            return MDI_CAMERA_EFFECT_WHITEBOARD;
            //break;

        case MMI_CAMCO_EFFECT_COPPER_CARVING:
            return MDI_CAMERA_EFFECT_COPPER_CARVING;
           // break;

        case MMI_CAMCO_EFFECT_BLUE_CARVING:
            return MDI_CAMERA_EFFECT_BLUE_CARVING;
            //break;

        case MMI_CAMCO_EFFECT_EMBOSSMENT:
            return MDI_CAMERA_EFFECT_EMBOSSMENT;
            //break;

        case MMI_CAMCO_EFFECT_CONTRAST:
            return MDI_CAMERA_EFFECT_CONTRAST;
            //break;

        case MMI_CAMCO_EFFECT_JEAN:
            return MDI_CAMERA_EFFECT_JEAN;
            //break;

        case MMI_CAMCO_EFFECT_SKETCH:
            return MDI_CAMERA_EFFECT_SKETCH;
            //break;

        case MMI_CAMCO_EFFECT_OIL:
            return MDI_CAMERA_EFFECT_OIL;
           // break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_sharpness
 * DESCRIPTION
 *  mmi_camco_get_cmd_sharpness
 * PARAMETERS
 *  sharpness       [IN]        Sharpness setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_sharpness(U16 sharpness)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (sharpness)
    {
        case MMI_CAMCO_SHARPNESS_ENHANCE:
            return MDI_CAMERA_IE_LEVEL_HIGH;
            //break;

        case MMI_CAMCO_SHARPNESS_NORMAL:
            return MDI_CAMERA_IE_LEVEL_MEDIUM;
            //break;

        case MMI_CAMCO_SHARPNESS_REDUCE:
            return MDI_CAMERA_IE_LEVEL_LOW;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
           // break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_contrast
 * DESCRIPTION
 *  mmi_camco_get_cmd_contrast
 * PARAMETERS
 *  contrast        [IN]        Contrast setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_contrast(U16 contrast)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (contrast)
    {
        case MMI_CAMCO_CONTRAST_ENHANCE:
            return MDI_CAMERA_IE_LEVEL_HIGH;
           // break;

        case MMI_CAMCO_CONTRAST_NORMAL:
            return MDI_CAMERA_IE_LEVEL_MEDIUM;
           // break;

        case MMI_CAMCO_CONTRAST_REDUCE:
            return MDI_CAMERA_IE_LEVEL_LOW;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_saturation
 * DESCRIPTION
 *  mmi_camco_get_cmd_saturation
 * PARAMETERS
 *  saturation      [IN]        Saturation setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_saturation(U16 saturation)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (saturation)
    {
        case MMI_CAMCO_SATURATION_ENHANCE:
            return MDI_CAMERA_IE_LEVEL_HIGH;
           // break;

        case MMI_CAMCO_SATURATION_NORMAL:
            return MDI_CAMERA_IE_LEVEL_MEDIUM;
            //break;

        case MMI_CAMCO_SATURATION_REDUCE:
            return MDI_CAMERA_IE_LEVEL_LOW;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_banding
 * DESCRIPTION
 *  mmi_camco_get_cmd_banding
 * PARAMETERS
 *  banding     [IN]        Banding setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_banding(U16 banding)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (banding)
    {
        case MMI_CAMCO_BANDING_50HZ:
            return MDI_CAMERA_BANDING_50HZ;
            //break;

        case MMI_CAMCO_BANDING_60HZ:
            return MDI_CAMERA_BANDING_60HZ;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_capmode
 * DESCRIPTION
 *  mmi_camco_get_cmd_capmopde
 * PARAMETERS
 *  capmode     [IN]        capmode setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_capmode(U16 aemeter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (aemeter)
    {
        case MMI_CAMCO_CAPMODE_NORMAL:
            return MDI_CAMERA_CAP_MODE_NORMAL;
            //break;
    
        case MMI_CAMCO_CAPMODE_CONT_SHOT:
            return MDI_CAMERA_CAP_MODE_CONT_SHOT;
            //break;
    
        case MMI_CAMCO_CAPMODE_BEST_SHOT:
            return MDI_CAMERA_CAP_MODE_BEST_SHOT;
           // break;
    
        case MMI_CAMCO_CAPMODE_BURST_SHOT_SEL:
            return MDI_CAMERA_CAP_MODE_BURST_SHOT;
            //break;
        case MMI_CAMCO_CAPMODE_EV_BRACKET_SEL:
            return MDI_CAMERA_CAP_MODE_EV_BRACKETING;
           // break;

        case MMI_CAMCO_CAPMODE_AUTORAMA:
            return MDI_CAMERA_CAP_MODE_PANORAMA;
            //break;
        case MMI_CAMCO_CAPMODE_ADD_FRAME:
            return MDI_CAMERA_CAP_MODE_ADD_FRAME;
            //break;

        case MMI_CAMCO_CAPMODE_HDR_SHOT:
            return MDI_CAMERA_CAP_MODE_HDR;
            //break;
        case MMI_CAMCO_CAPMODE_SMILE_SHOT:
            return MDI_CAMERA_CAP_MODE_SMILE_SHOT;
           // break;
            
        case MMI_CAMCO_CAPMODE_ZSD_SHOT:
            return MDI_CAMERA_CAP_MODE_ZSD;
            //break;
        case MMI_CAMCO_CAPMODE_ASD_SHOT:
            return MDI_CAMERA_CAP_MODE_ASD;
           // break;
        case MMI_CAMCO_CAPMODE_MAV:
			return MDI_CAMERA_CAP_MODE_MAV;
			//break;
		case MMI_CAMCO_CAPMODE_3D_IMAGE:
			return MDI_CAMERA_CAP_MODE_3D_IMAGE;
			//break;
        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_aemeter
 * DESCRIPTION
 *  mmi_camco_get_cmd_aemeter
 * PARAMETERS
 *  aemeter     [IN]        Aemeter setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_aemeter(U16 aemeter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (aemeter)
    {
        case MMI_CAMCO_AEMETER_AUTO:
            return MDI_CAMERA_AE_METER_AUTO;
           // break;

        case MMI_CAMCO_AEMETER_SPOT:
            return MDI_CAMERA_AE_METER_SPOT;
            //break;

        case MMI_CAMCO_AEMETER_CENTER_WEIGHT:
            return MDI_CAMERA_AE_METER_CENTER;
            //break;

        case MMI_CAMCO_AEMETER_AVERAGE:
            return MDI_CAMERA_AE_METER_AVERAGE;
           // break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_afzone
 * DESCRIPTION
 *  mmi_camco_get_cmd_afzone
 * PARAMETERS
 *  afzone      [IN]        Afzone setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_afzone(U16 afzone)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (afzone)
    {
        case MMI_CAMCO_AFZONE_SINGLE:
            return MDI_CAMERA_AF_OPERATION_MODE_SINGLE_ZONE;
           // break;

        case MMI_CAMCO_AFZONE_MULTI:
            return MDI_CAMERA_AF_OPERATION_MODE_MULTI_ZONE;
           // break;

        case MMI_CAMCO_AFZONE_CONTINUE:
            return MDI_CAMERA_AF_OPERATION_MODE_CONTINUOUS;
            //break;            
            
        default:
            MMI_CAMCO_ASSERT(0);
           // break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_afmode
 * DESCRIPTION
 *  mmi_camco_get_cmd_afmode
 * PARAMETERS
 *  afmode      [IN]        Afmode setting value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_afmode(U16 afmode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (afmode)
    {
        case MMI_CAMCO_AFMODE_OFF:
            return MDI_CAMERA_AF_OPERATION_MODE_OFF;
            //break;

        case MMI_CAMCO_AFMODE_SINGLE:
            return MDI_CAMERA_AF_OPERATION_MODE_SINGLE_ZONE;
            //break;

        case MMI_CAMCO_AFMODE_CONT:
            return MDI_CAMERA_AF_OPERATION_MODE_CONTINUOUS;
            //break;
            
        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_capmode
 * DESCRIPTION
 *  Get the current camera capture mode
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_capmode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 capmode;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    capmode = (U32)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE);

    return capmode;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_camzoom
 * DESCRIPTION
 *  mmi_camco_get_camzoom
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_camzoom(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 zoomstep;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    zoomstep = mmi_camco_setting_get_camzoom_step();

    return zoomstep;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_vdozoom
 * DESCRIPTION
 *  mmi_camco_get_vdozoom
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_vdozoom(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 zoomstep;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    zoomstep = mmi_camco_setting_get_vdozoom_step();

    return zoomstep;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_selftimer
 * DESCRIPTION
 *  mmi_camco_get_selftimer
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_selftimer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 selftimer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    selftimer =(U32) mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SELFTIMER);

    return selftimer;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_shuttersound
 * DESCRIPTION
 *  mmi_camco_get_shuttersound
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_shuttersound(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 shuttersound;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    shuttersound = (U32)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SHUTTERSOUND);

    return shuttersound;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_vdoscenemode
 * DESCRIPTION
 *  mmi_camco_get_cmd_vdoscenemode
 * PARAMETERS
 *  vdoscenemode        [IN]        Vdoscenemode value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_vdoscenemode(U16 vdoscenemode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (vdoscenemode)
    {
        case MMI_CAMCO_VDOSCENEMODE_AUTO:
            return MDI_VIDEO_SCENE_MODE_AUTO;
            //break;

        case MMI_CAMCO_VDOSCENEMODE_NIGHT:
            return MDI_VIDEO_SCENE_MODE_NIGHT; 
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_visqty
 * DESCRIPTION
 *  mmi_camco_get_cmd_visqty
 * PARAMETERS
 *  visqty      [IN]        Video quality value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_visqty(U16 visqty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (visqty)
    {
        case MMI_CAMCO_VISQTY_FINE:
            return MDI_VIDEO_REC_QTY_FINE;
            //break;

        case MMI_CAMCO_VISQTY_GOOD:
            return MDI_VIDEO_REC_QTY_HIGH;
            //break;

        case MMI_CAMCO_VISQTY_NORMAL:
            return MDI_VIDEO_REC_QTY_NORMAL;
            //break;

        case MMI_CAMCO_VISQTY_LOW:
            return MDI_VIDEO_REC_QTY_LOW;
           // break;
    #ifdef MMI_CAMCO_WALLPAPER
		case MMI_CAMCO_VISQTY_LCD:
			return MDI_VIDEO_REC_QTY_FINE;
			  // break;
    #endif
        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_vdosize
 * DESCRIPTION
 *  mmi_camco_get_cmd_vdosize
 * PARAMETERS
 *  width_p         [OUT]       Record file width
 *  height_p        [OUT]       Record file height
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_vdosize(U16 *width_p, U16 *height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 vdosize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    vdosize = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE);
    switch (vdosize)
    {
    
        case MMI_CAMCO_RECSIZE_SQCIF:
            *width_p = 128;
            *height_p = 96;
            return MDI_VIDEO_VIDEO_SIZE_SQCIF;
            
        case MMI_CAMCO_RECSIZE_QQVGA:
            *width_p = 160;
            *height_p = 120;
            return MDI_VIDEO_VIDEO_SIZE_QQVGA;
            
        case MMI_CAMCO_RECSIZE_QCIF:
            *width_p = 176;
            *height_p = 144;
            return MDI_VIDEO_VIDEO_SIZE_QCIF;
            //break;
        
        case MMI_CAMCO_RECSIZE_QVGA:
            *width_p = 320;
            *height_p = 240;
            return MDI_VIDEO_VIDEO_SIZE_QVGA;
            //break;            
        
        case MMI_CAMCO_RECSIZE_CIF:
            *width_p = 352;
            *height_p = 288;
            return MDI_VIDEO_VIDEO_SIZE_CIF;
            //break;
        
        case MMI_CAMCO_RECSIZE_WQVGA:
            *width_p = 400;
            *height_p = 240;
            return MDI_VIDEO_VIDEO_SIZE_WQVGA;
            //break;
        
        case MMI_CAMCO_RECSIZE_CIF2:
            *width_p = 432;
            *height_p = 240;
            return MDI_VIDEO_VIDEO_SIZE_CIF_2;
            //break;            
        
        case MMI_CAMCO_RECSIZE_HVGA:
            *width_p = 320;
            *height_p = 480;
            return MDI_VIDEO_VIDEO_SIZE_HVGA;
           // break;
        
        case MMI_CAMCO_RECSIZE_NHD:           
            *width_p = 640;
            *height_p = 368;
            return MDI_VIDEO_VIDEO_SIZE_NHD;
            //break;
            
        case MMI_CAMCO_RECSIZE_VGA:
            *width_p = 640;
            *height_p =  480;
            return MDI_VIDEO_VIDEO_SIZE_VGA;
            //break;
        
        case MMI_CAMCO_RECSIZE_D1:
            *width_p = 720;
            *height_p = 480;
            return MDI_VIDEO_VIDEO_SIZE_D1;
            //break;

        case MMI_CAMCO_RECSIZE_D12:
            *width_p = 720;
            *height_p = 576;
            return MDI_VIDEO_VIDEO_SIZE_D1_2;
            //break;
            
        case MMI_CAMCO_RECSIZE_WVGA:
            *width_p = 800;
            *height_p = 480;
            return MDI_VIDEO_VIDEO_SIZE_WVGA;
            //break;

        case MMI_CAMCO_RECSIZE_SVGA:
            *width_p = 848;
            *height_p = 608;
            return MDI_VIDEO_VIDEO_SIZE_SVGA;
            //break;
            
        case MMI_CAMCO_RECSIZE_WVGA2:
            *width_p = 848;
            *height_p = 480;
            return MDI_VIDEO_VIDEO_SIZE_WVGA_2;
            //break;        
                              
        case MMI_CAMCO_RECSIZE_XGA:
            *width_p = 1024;
            *height_p = 768;
            return MDI_VIDEO_VIDEO_SIZE_XGA;
            //break;             
            
        case MMI_CAMCO_RECSIZE_720P:
            *width_p = 1280;
            *height_p = 720;
            return MDI_VIDEO_VIDEO_SIZE_720P;
            //break;              
            
        case MMI_CAMCO_RECSIZE_4VGA:
            *width_p = 1280;
            *height_p = 960;
            return MDI_VIDEO_VIDEO_SIZE_4VGA;
            //break;              
            
        case MMI_CAMCO_RECSIZE_SXGA:
            *width_p = 1280;
            *height_p = 1024;
            return MDI_VIDEO_VIDEO_SIZE_SXGA;
            //break;              
            
        case MMI_CAMCO_RECSIZE_16CIF:
            *width_p = 1408;
            *height_p = 1152;
            return MDI_VIDEO_VIDEO_SIZE_16CIF;
            //break;               
            
        case MMI_CAMCO_RECSIZE_4SVGA:
            *width_p = 1600;
            *height_p = 1200;
            return MDI_VIDEO_VIDEO_SIZE_4SVGA;
           // break;              
            
        case MMI_CAMCO_RECSIZE_FHD:   
            *width_p = 1920;
            *height_p = 1088;
            return MDI_VIDEO_VIDEO_SIZE_FHD;
            //break;
        case MMI_CAMCO_RECSIZE_4CIF:
            *width_p = 704;
            *height_p = 576;
            return MDI_VIDEO_VIDEO_SIZE_4CIF;
            //break;
            
        case MMI_CAMCO_RECSIZE_FWVGA:
            *width_p = 864;
            *height_p = 480;
            return MDI_VIDEO_VIDEO_SIZE_FWVGA;
            //break; 
    #ifdef MMI_CAMCO_WALLPAPER
         case MMI_CAMCO_RECSIZE_WALLPAPER:
			if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_QVGA )
			{ 
				*width_p = 240;
				*height_p = 320;
				return MDI_VIDEO_VIDEO_SIZE_WP_QVGA;
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_QVGA)
			{
				*width_p = 320;
				*height_p = 240;
				return MDI_VIDEO_VIDEO_SIZE_QVGA;
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_WQVGA)
			{
				*width_p = 240;
				*height_p = 400;
				return MDI_VIDEO_VIDEO_SIZE_WP_WQVGA;
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_HVGA)
			{
				*width_p = 320;
				*height_p = 480;
				return MDI_VIDEO_VIDEO_SIZE_WP_HVGA;
				
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_WVGA)
			{
				*width_p = 480;
				*height_p = 800;
				return MDI_VIDEO_VIDEO_SIZE_WP_WVGA;
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_QCIF)
			{
				*width_p = 176;
				*height_p = 208;
				return MDI_VIDEO_VIDEO_SIZE_WP_QCIF;
			}
    #endif
        default:
            MMI_CAMCO_ASSERT(0);
           // break;
    }

}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_reclimit
 * DESCRIPTION
 *  mmi_camco_get_cmd_reclimit
 * PARAMETERS
 *  limit       [IN]        Mmi limitation value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_reclimit(U16 limit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (limit)
    {
        case MMI_CAMCO_LIMIT_NO_LIMIT:
            return MMI_CAMCO_REC_TIME_LIMIT_NO_LIMIT;
            //break;

        case MMI_CAMCO_LIMIT_TIME_15S:
            return MMI_CAMCO_REC_TIME_LIMIT_1;
            //break;

        case MMI_CAMCO_LIMIT_TIME_30S:
            return MMI_CAMCO_REC_TIME_LIMIT_2;
            //break;

        case MMI_CAMCO_LIMIT_TIME_60S:
            return MMI_CAMCO_REC_TIME_LIMIT_3;
            //break;

        case MMI_CAMCO_LIMIT_SIZE_95K:
            return MMI_CAMCO_REC_SIZE_LIMIT_1;
            //break;

        case MMI_CAMCO_LIMIT_SIZE_195K:
            return MMI_CAMCO_REC_SIZE_LIMIT_2;
            //break;

        case MMI_CAMCO_LIMIT_SIZE_295K:
            return MMI_CAMCO_REC_SIZE_LIMIT_3;
			
		case MMI_CAMCO_LIMIT_TIME_5MIN:
			return MMI_CAMCO_REC_TIME_LIMIT_5;
			
		case MMI_CAMCO_LIMIT_TIME_10MIN:
			return MMI_CAMCO_REC_TIME_LIMIT_10;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_visformat
 * DESCRIPTION
 *  mmi_camco_get_cmd_visformat
 * PARAMETERS
 *  visformat       [IN]        Mmi video format value
 * RETURNS
 *  U16
 *****************************************************************************/
static U32 mmi_camco_get_cmd_visformat(U16 visformat)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (visformat)
    {
        case MMI_CAMCO_VISCODEC_MP4:
            return MDI_VIDEO_VIDEO_FORMAT_MP4;
            //break;

        case MMI_CAMCO_VISCODEC_3GP:
            return MDI_VIDEO_VIDEO_FORMAT_3GP;
            //break;

        case MMI_CAMCO_VISCODEC_MJPG:
            return MDI_VIDEO_VIDEO_FORMAT_MJPEG;
            //break;

        case MMI_CAMCO_VISCODEC_H264:
            return MDI_VIDEO_VIDEO_FORMAT_H264;
            //break;

        default:
            MMI_CAMCO_ASSERT(0);
            //break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_recaud
 * DESCRIPTION
 *  mmi_camco_get_cmd_recaud
 * PARAMETERS
 *  recaud      [IN]        Recaud value
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_camco_get_cmd_recaud(U16 recaud)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (recaud)
    {
        case MMI_CAMCO_RECAUD_OFF:
            return MMI_FALSE;
            //break;

        case MMI_CAMCO_RECAUD_ON:
            return MMI_TRUE;
            //break;

        default:
            MMI_ASSERT(0);
           // break;
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_free_space
 * DESCRIPTION
 *  mmi_camco_get_free_space
 * PARAMETERS
 *  void
 * RETURNS
 *  U64
 *****************************************************************************/
U64 mmi_camco_get_free_space(void)
{
    U8 drive_str[32];
    int ret;
    FS_DiskInfo diskinfo;
    U64 disk_size = 0;
    U8 m_drive = 0;

    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        m_drive = srv_fmgr_drv_get_type((U8)(mmi_camco_cam_p->storage));    
        kal_wsprintf((U16*) drive_str, "%c:\\", mmi_camco_cam_p->storage);
    }
    else if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        m_drive = srv_fmgr_drv_get_type((U8)(mmi_camco_rec_p->storage));        
        kal_wsprintf((U16*) drive_str, "%c:\\", mmi_camco_rec_p->storage);
    }
    
    ret = FS_GetDevStatus(m_drive, FS_FEATURE_STATE_ENUM);
    if (ret >= FS_NO_ERROR)
    {
        ret = FS_GetDiskInfo((U16*) drive_str, &diskinfo, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE);
	    if (ret >= FS_NO_ERROR)
	    {
            disk_size = diskinfo.FreeClusters * diskinfo.SectorsPerCluster * diskinfo.BytesPerSector;
	    }
    }

    return disk_size;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_storage_count
 * DESCRIPTION
 *  mmi_camco_get_storage_count
 * PARAMETERS
 *  void
 * RETURNS
 *  S32
 *****************************************************************************/
static S32 mmi_camco_get_storage_count(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 drv_num;
    SRV_FMGR_DRVLIST_HANDLE drvlist;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
    drv_num = srv_fmgr_drivelist_count(drvlist);
    srv_fmgr_drivelist_destroy(drvlist);
    
    /* card should not be a choice of storage selection list */
    /* temp solution for FS and fmgr not sync issue */
    if(srv_fmgr_drv_is_accessible((U8)SRV_FMGR_CARD_DRV) && drv_num == 2)
        return 1;
    
    return drv_num;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_storage_letter
 * DESCRIPTION
 *  mmi_camco_get_storage_enum
 * PARAMETERS
 *  storage_enum        [IN]        
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static U16 mmi_camco_get_storage_letter(U16 storage_enum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //U8 drv_array[SRV_FMGR_DRV_TOTAL];
    //U8 drv_num;
    //U8 drv_enum;
    //U8 idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (U16)srv_fmgr_drv_get_letter_by_type((srv_fmgr_drv_type_enum)storage_enum);    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_cmd_autorama_direction
 * DESCRIPTION
 *  mmi_camco_get_cmd_autorama_direction
 * PARAMETERS
 *  direction       [IN]        Direction
 * RETURNS
 *  mdi value
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
static U32 mmi_camco_get_cmd_autorama_direction(U16 direction)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (direction)
    {
        case MMI_CAMCO_AUTORAMA_DIRECTION_UP:
            return MDI_CAMERA_PANO_UP_DIR;
            //break;

        case MMI_CAMCO_AUTORAMA_DIRECTION_DOWN:
            return MDI_CAMERA_PANO_DOWN_DIR;
            //break;

        case MMI_CAMCO_AUTORAMA_DIRECTION_LEFT:
            return MDI_CAMERA_PANO_LEFT_DIR;
            //break;

        case MMI_CAMCO_AUTORAMA_DIRECTION_RIGHT:
            return MDI_CAMERA_PANO_RIGHT_DIR;
            //break;

        default:
            return MMI_CAMCO_AUTORAMA_DIRECTION_RIGHT;
            //break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_autorama_capture_count
 * DESCRIPTION
 *  mmi_camco_get_autorama_capture_count
 * PARAMETERS
 *  void
 * RETURNS
 *  capture_count   [U8]
 *****************************************************************************/
U8 mmi_camco_get_autorama_capture_count(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_camco_cam_p->autorama_shot.capture_count;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_autorama_capture_image
 * DESCRIPTION
 *  mmi_camco_get_autorama_capture_image
 * PARAMETERS
 *  image_buf_pp            [OUT]       
 *  image_buf_size_p        [OUT]       
 *  image_width_p           [OUT]       
 *  image_height_p          [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_get_autorama_capture_image(
        U8 **image_buf_pp,
        U32 *image_buf_size_p,
        U32 *image_width_p,
        U32 *image_height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *image_buf_pp = mmi_camco_cam_p->autorama_shot.capture_buffer_p[mmi_camco_cam_p->autorama_shot.capture_count];
    *image_buf_size_p = mmi_camco_cam_p->autorama_shot.capture_img_size[mmi_camco_cam_p->autorama_shot.capture_count];
    *image_width_p = mmi_camco_cam_p->image_width;
    *image_height_p = mmi_camco_cam_p->image_height;
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_camscenemode
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  camscenemode        [IN]        Setting module camscenemode value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_camscenemode(U16 camscenemode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_update_capability();

    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_capsize
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_capsize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //float old_width, old_height;
    //float old_ratio, new_ratio;

   // mmi_camco_capsize_enum capsize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_CAMZOOM);

    //old_width = (float)mmi_camco_cam_p->image_width;
   // old_height = (float)mmi_camco_cam_p->image_height;

   // capsize = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE);

    mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);

    //old_ratio = old_width / (float)old_height;
    //new_ratio = (float)mmi_camco_cam_p->image_width / (float)mmi_camco_cam_p->image_height;

    mmi_camco_cam_p->is_reset_zoom = MMI_TRUE;
    mmi_camco_need_restart_preview();

    mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width, mmi_camco_cam_p->image_height);
    mdi_camera_update_para_zoom(0);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_iso
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  iso     [IN]        Mmi iso value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_iso(U16 iso)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_capqty
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  capqty      [IN]        Mmi capqty value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_capqty(U16 capqty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_capqty;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_capqty = mmi_camco_get_cmd_capqty(capqty);
    mdi_camera_update_para_image_qty(mdi_capqty);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_capmode
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  capmode     [IN]        Mmi capmode value
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_camco_update_capmode(U16 capmode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_capsize_enum capsize;
    S16 error;
    U16 last_capmode;
    MMI_BOOL is_prev_ledflash_support = MMI_FALSE;
    MMI_BOOL is_curr_ledflash_support = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    capsize =(mmi_camco_capsize_enum) mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE);
    mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_CAPSIZE);

    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_TIMESTAMP);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_SELFTIMER);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_FACEDETECT);

    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_CAMSCENEMODE);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_WB);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_CAMEV);                
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_EFFECT);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_CONTRAST);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_SHARPNESS);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_SATURATION);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_AFRANGE);
    #ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_SHUTTERSOUND);
    mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_CAPQTY);
	mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_WB);
	mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_EFFECT);
	#endif
    //mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_AFZONE);
    mmi_camco_check_flash_capmode_capability();
    mmi_camco_update_camscenemode_capability();

    if (capmode == MMI_CAMCO_CAPMODE_BURST_SHOT_SEL)
    { 
        if (capsize > MMI_CAMCO_CAPSIZE_3MP)
        {
            capsize = MMI_CAMCO_CAPSIZE_3MP;
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
            mmi_camco_update_capsize();
        }
    
    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_TIMESTAMP) == MMI_CAMCO_TIMESTAMP_ON)
        {
            mmi_camco_osd_set_time_stamp_enable(MMI_TRUE);
        }
    #endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
    }
	else if(capmode == MMI_CAMCO_CAPMODE_MAV || capmode == MMI_CAMCO_CAPMODE_3D_IMAGE)
	{ 
	    #ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
		#if defined(HORIZONTAL_CAMERA)
        if (capsize != MMI_CAMCO_CAPSIZE_WALLPAPER && capsize != MMI_CAMCO_CAPSIZE_HLCD)
		#else
        if (capsize != MMI_CAMCO_CAPSIZE_WALLPAPER)
		#endif
        {
            capsize = MMI_CAMCO_CAPSIZE_WALLPAPER;
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
            mmi_camco_update_capsize();		
        }
		    mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_CAMZOOM); 	  
		    mmi_camco_cam_p->is_reset_zoom = MMI_TRUE;
			mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAMSCENEMODE,MMI_CAMCO_CAMSCENEMODE_AUTO);
			mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAMSCENEMODE);
			mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_SHUTTERSOUND);
			mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAPQTY);
			
		    #ifdef __FACE_DETECTION_SUPPORT__
			mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_OFF);
			mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_FACEDETECT);
		    #endif /* __FACE_DETECTION_SUPPORT__ */ 
			if(capmode == MMI_CAMCO_CAPMODE_3D_IMAGE)
			{
			
			    mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_WB, MMI_CAMCO_WB_AUTO);
				mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_WB);
				
				mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_EFFECT, MMI_CAMCO_EFFECT_NORMAL);
			    mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_EFFECT);

			}
		#endif

	}
    else if (capmode == MMI_CAMCO_CAPMODE_ADD_FRAME || capmode == MMI_CAMCO_CAPMODE_AUTORAMA)
    {
        mmi_camco_cam_p->is_reset_zoom = MMI_FALSE;
        WriteValue(NRRAM_CAMCO_BEFORE_SWITCH_CAPSIZE, &capsize, DS_BYTE, &error);

    #ifdef PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA
        if (capsize != MMI_CAMCO_CAPSIZE_VGA)
        {
            capsize = MMI_CAMCO_CAPSIZE_VGA;
        }

        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
        if(capmode != MMI_CAMCO_CAPMODE_ADD_FRAME)
            mmi_camco_update_capsize();
        mmi_camco_cam_p->is_reset_zoom = MMI_TRUE;
    #else /* PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA */ 

    #if defined(HORIZONTAL_CAMERA)
        if (capsize == MMI_CAMCO_CAPSIZE_WALLPAPER || capsize == MMI_CAMCO_CAPSIZE_HLCD ||
            capsize > MMI_CAMCO_CAPSIZE_2MP)
    #else /* defined(HORIZONTAL_CAMERA) */ 
        if (capsize == MMI_CAMCO_CAPSIZE_WALLPAPER || capsize > MMI_CAMCO_CAPSIZE_2MP)
    #endif /* defined(HORIZONTAL_CAMERA) */ 
        {
            if (capsize > MMI_CAMCO_CAPSIZE_2MP)
            {
                capsize = MMI_CAMCO_CAPSIZE_2MP;
            }
            else
            {
                capsize = MMI_CAMCO_CAPSIZE_VGA;
            }
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
            mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_CAMZOOM);       
            mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);
            mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width, mmi_camco_cam_p->image_height);
            mmi_camco_cam_p->is_reset_zoom = MMI_TRUE;
        }
    #endif /* PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA */ 

    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        if (mmi_camco_osd_is_time_stamp_enable())
        {
            mmi_camco_osd_set_time_stamp_enable(MMI_FALSE);
        }

        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_TIMESTAMP);
    #endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
    #ifdef __FACE_DETECTION_SUPPORT__
        if (mmi_camco_setting_is_facedetect_on())
        {
            mmi_camco_cam_face_detect_stop();
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_OFF);
            mmi_camco_update_facedetect(MMI_CAMCO_FACEDETECT_OFF);
        }
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_FACEDETECT);
    #endif /* __FACE_DETECTION_SUPPORT__ */ 
    }
    else
    {
    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_TIMESTAMP) == MMI_CAMCO_TIMESTAMP_ON)
        {
            mmi_camco_osd_set_time_stamp_enable(MMI_TRUE);
        }
    #endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 

    }

    mmi_camco_update_effect_capability();    
    
    if (capmode == MMI_CAMCO_CAPMODE_CONT_SHOT || capmode == MMI_CAMCO_CAPMODE_AUTORAMA || capmode == MMI_CAMCO_CAPMODE_MAV ||capmode == MMI_CAMCO_CAPMODE_3D_IMAGE)
    {
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_SELFTIMER);
		mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_SELFTIMER,MMI_CAMCO_SELFTIMER_OFF);
    }

    mmi_camco_config_capsize_capability();

#ifdef __SMILE_SHUTTER_SUPPORT__
    if(capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT)
    {
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_FACEDETECT);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_SELFTIMER);
    }
#endif /* __SMILE_SHUTTER_SUPPORT__ */ 

    last_capmode = mmi_camco_get_last_capmode();

#if defined( __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__) ||defined( __SMILE_SHUTTER_SUPPORT__)
    if((last_capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT||last_capmode == MMI_CAMCO_CAPMODE_ASD_SHOT)&&(capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT || capmode == MMI_CAMCO_CAPMODE_ASD_SHOT) )
    {
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_OFF)
        {
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_ON);
            mmi_camco_update_facedetect(MMI_CAMCO_FACEDETECT_ON);     
        }

	}
	else if(capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT || capmode == MMI_CAMCO_CAPMODE_ASD_SHOT)
    {
        mmi_camco_set_last_FD((mmi_camco_setting_face_detect_enum)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT));

        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_OFF)
        {
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_ON);
            mmi_camco_update_facedetect(MMI_CAMCO_FACEDETECT_ON);     
        }
    }
    else if((last_capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT || last_capmode == MMI_CAMCO_CAPMODE_ASD_SHOT)&&
       (capmode != MMI_CAMCO_CAPMODE_SMILE_SHOT &&capmode != MMI_CAMCO_CAPMODE_ASD_SHOT&&capmode != MMI_CAMCO_CAPMODE_3D_IMAGE))
    {

        if (mmi_camco_get_last_FD() == MMI_CAMCO_FACEDETECT_OFF)
        {
            mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_OFF);
            mmi_camco_update_facedetect(MMI_CAMCO_FACEDETECT_OFF);
        }

    }
        
#endif

#ifdef __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__
    if (capmode == MMI_CAMCO_CAPMODE_ASD_SHOT)
    {
            
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAMSCENEMODE, MMI_CAMCO_CAMSCENEMODE_AUTO);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAMSCENEMODE);
            
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_WB, MMI_CAMCO_WB_AUTO);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_WB);
    
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CAMEV, MMI_CAMCO_EV_0);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAMEV); 
            
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_FACEDETECT);    
            
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_EFFECT, MMI_CAMCO_EFFECT_NORMAL);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_EFFECT);
    
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_CONTRAST, MMI_CAMCO_CONTRAST_NORMAL);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CONTRAST);
            
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_SHARPNESS, MMI_CAMCO_SHARPNESS_NORMAL);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_SHARPNESS);
    
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_SATURATION, MMI_CAMCO_SATURATION_NORMAL);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_SATURATION);
            
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_AFRANGE, MMI_CAMCO_AFRANGE_AUTO);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_AFRANGE);
            
        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_AFZONE, MMI_CAMCO_AFZONE_SINGLE);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_AFZONE);

        mmi_camco_cam_p->is_hide_iso = mmi_camco_setting_is_hide(MMI_CAMCO_SETTING_ISO);

        mmi_camco_setting_set_current_value(MMI_CAMCO_SETTING_ISO, MDI_CAMERA_ISO_AUTO);
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_ISO);		               
    }
    else
    {
        if (last_capmode == MMI_CAMCO_CAPMODE_ASD_SHOT)
        {
            if (mmi_camco_cam_p->is_hide_iso == MMI_TRUE)
            {
                mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_ISO);
            }
            else
            {
                mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_ISO);
            }
        }
        //mmi_camco_update_iso_capability();
    }
#endif

        if (mmi_camco_get_flash_type() == MMI_CAMCO_FLASH_TYPE_LED)
    {
        if (mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_EV_BRACKET_SEL &&
            mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_SMILE_SHOT &&            
            mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_HDR_SHOT &&                        
            mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_AUTORAMA)
        {
            is_prev_ledflash_support = MMI_TRUE;
        }

        if (capmode != MMI_CAMCO_CAPMODE_EV_BRACKET_SEL && capmode != MMI_CAMCO_CAPMODE_AUTORAMA &&
            capmode != MMI_CAMCO_CAPMODE_SMILE_SHOT && capmode != MMI_CAMCO_CAPMODE_HDR_SHOT)
        {
            is_curr_ledflash_support = MMI_TRUE;
        }

        if (is_prev_ledflash_support ^ is_curr_ledflash_support)
        {
            if (is_curr_ledflash_support)
            {
                mmi_camco_update_flash(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FLASH));
            }
            else
            {
                mmi_camco_update_flash(MMI_CAMCO_FLASH_OFF);
            }
        }
        else if (is_prev_ledflash_support & is_curr_ledflash_support)
        {
            mmi_camco_update_flash(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FLASH));
        }
    }

        mmi_camco_need_restart_preview();
        mmi_camco_setting_store_to_nvram();
	mmi_camco_makeup_capture_mode_mainlist_index();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_flash
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  flash       [IN]        Mmi flash value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_flash(U16 flash)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_flash;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_flash = mmi_camco_get_cmd_flash(flash);
    mdi_camera_update_para_flash(mdi_flash);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_afrange
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  afrange     [IN]        Mmi afrange value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_afrange(U16 afrange)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_facedetect
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  facedetect      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_facedetect(U16 facedetect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_camco_update_effect_capability();
    mmi_camco_update_facedetect_capability();
    mmi_camco_update_camscenemode_capability();
    if (mmi_camco_is_from_external())
    {
        mmi_camco_set_external_capmode_capability();
    }
    mmi_camco_need_restart_preview();

#if defined (__MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__) && defined(__MMI_CAMCO_FEATURE_FD_PAUSE_PREVIEW_WATCHDOG__)

    /* the face update may called in exit process in SSD mode */
    /* in this case, timer should not be start again  or it will time out on others screen and assert! */
#ifdef __SMILE_SHUTTER_SUPPORT__
    if (g_mmi_camco_cntx.app_state >= MMI_CAMCO_STATE_CAM_INT_PREVIEW)
        return;
#endif /* __SMILE_SHUTTER_SUPPORT__ */ 

    mmi_camco_reset_preview_terminate_timer();
#endif /* defined (__MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__) && defined(__MMI_CAMCO_FEATURE_FD_PAUSE_PREVIEW_WATCHDOG__) */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_wb
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  wb      [IN]        Mmi wb value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_wb(U16 wb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_wb;
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
    mdi_wb = mmi_camco_get_cmd_wb(wb);
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mdi_camera_update_para_wb(mdi_wb);
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        mdi_video_rec_update_para_wb(mdi_wb);
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_sharpness
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  sharpness       [IN]        Mmi sharpness value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_sharpness(U16 sharpness)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_sharpness;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_sharpness = mmi_camco_get_cmd_sharpness(sharpness);
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {    
        mdi_camera_update_para_sharpness(mdi_sharpness); 
    }
    else
    {    
        mdi_video_rec_update_para_sharpness(mdi_sharpness); 
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_contrast
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  contrast        [IN]        Mmi contrast value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_contrast(U16 contrast)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_contrast;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_contrast = mmi_camco_get_cmd_contrast(contrast);
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {      
        mdi_camera_update_para_contrast(mdi_contrast);
    }
    else
    {      
        mdi_video_rec_update_para_contrast(mdi_contrast);
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_saturation
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  saturation      [IN]        Mmi saturation value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_saturation(U16 saturation)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_saturation;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_saturation = mmi_camco_get_cmd_saturation(saturation);
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {    
        mdi_camera_update_para_saturation(mdi_saturation);
    }
    else
    {    
        mdi_video_rec_update_para_saturation(mdi_saturation);
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_effect
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  effect      [IN]        Mmi effect value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_effect(U16 effect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_effect;
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
    mdi_effect = mmi_camco_get_cmd_effect(effect);
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mdi_camera_update_para_effect(mdi_effect);
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        mdi_video_rec_update_para_effect(mdi_effect);
    }
    else
    {
        MMI_ASSERT(0);
    }
    mmi_camco_setting_update_imgadjust_capability();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_zoom_factor
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_camco_update_zoom_factor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 current_idx = 100;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mdi_camera_get_fast_zoom_factor(&current_idx);
    }
    else
    {
        mdi_video_rec_get_fast_zoom_factor(&current_idx);
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_UPDATE_ZOOM_FACTOR, current_idx);

    return (U16) current_idx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_zoom_step
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_camco_update_zoom_step(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 current_idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {

        mdi_camera_get_fast_zoom_step(&current_idx);
    }
    else
    {
        mdi_video_rec_get_fast_zoom_step(&current_idx);
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_UPDATE_ZOOM_STEP, current_idx);

    return (U16) current_idx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_ev
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  ev      [IN]        Mmi ev value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_ev(U16 ev)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_ev;
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
    mdi_ev = mmi_camco_get_cmd_ev(ev);
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mdi_camera_update_para_ev(mdi_ev);
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        mdi_video_rec_update_para_ev(mdi_ev);
    }
    else
    {
        MMI_ASSERT(0);
    }

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_afzone
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  afzone      [IN]        Mmi afzone value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_afzone(U16 afzone)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_aemeter
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  aemeter     [IN]        Mmi aemeter value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_aemeter(U16 aemeter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_afmode
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  afmode      [IN]        Mmi afmode value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_afmode(U16 afmode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE) == MMI_CAMCO_AFMODE_CONT)
    {
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_AFRANGE);
    }
    else
    {
        mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_AFRANGE);
    }
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_banding
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  banding     [IN]        Mmi banding value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_banding(U16 banding)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_removeable_storage_plug_out
 * DESCRIPTION
 *  this function is handle the evevt of otg and memory card plug out
 * PARAMETERS
 *  banding     [IN]        Mmi banding value
 * RETURNS
 *  void
 *****************************************************************************/
extern mmi_ret mmi_camco_removeable_storage_plug_out(mmi_event_struct *evt)
{
	srv_fmgr_notification_dev_plug_event_struct* event;
    U8 i = 0; 
	U8 drive = 0;

	switch (evt->evt_id)
	{
		case EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_OUT:
		{
			event = (srv_fmgr_notification_dev_plug_event_struct*)evt;
			drive = mmi_camco_get_storage_letter(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
		
			for ( i = 0; i < event->count; i++)
			{
				if(g_mmi_camco_cntx.app_state== MMI_CAMCO_STATE_REC_RECORDING || g_mmi_camco_cntx.app_state== MMI_CAMCO_STATE_REC_PAUSE)
				{
				    mmi_camco_check_storage_capability();
				    if (event->drv_letters[i] == drive)
				    {
					    if(g_mmi_camco_cntx.app_state== MMI_CAMCO_STATE_REC_RECORDING )
					    {  
					       gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
						    mmi_camco_rec_record_stop();
						    mmi_camco_osd_set_bg_black();
						    g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
						    mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
						    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
					    }
					    else if(g_mmi_camco_cntx.app_state== MMI_CAMCO_STATE_REC_PAUSE)
					    {   
						    mmi_camco_rec_record_stop();
					        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
					      g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
							mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
					    }
					    return MMI_RET_OK;
				    }
			    }
			}
		}
		break;	

	}
	return MMI_RET_OK;
}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_storage
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  storage     [IN]        Mmi storage value
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_camco_update_storage(U16 storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();

    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mmi_camco_update_cam_storage(storage);
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        mmi_camco_update_rec_storage(storage);
    }
    else
    {
        MMI_ASSERT(0);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_cam_storage
 * DESCRIPTION
 *  mmi_camco_update_cam_storage
 * PARAMETERS
 *  storage     [IN]        Mmi storage value
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_update_cam_storage(U16 storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (storage == SRV_FMGR_DRV_CARD_TYPE)
    {
        mmi_camco_cam_p->storage = FS_GetDrive(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE);
    }
    else
    {
        mmi_camco_cam_p->storage = mmi_camco_get_storage_letter(storage);
    }
    mmi_camco_check_storage_path(mmi_camco_cam_p->storage, &mmi_camco_cam_p->storage_filepath_p);
    mmi_camco_cam_p->is_storage_change = MMI_TRUE;

#ifdef __MMI_IMAGE_VIEWER__
    mmi_imgview_set_storage(mmi_camco_cam_p->storage);
#endif 
#ifdef __MMI_VIDEO_PLAYER__
    mmi_vdoply_set_storage(mmi_camco_cam_p->storage);
#endif 

}
	
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_timelaps
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  visformat       [IN]        Mmi visformat value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_timelaps(U16 timelaps)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_camco_update_timelaps_capability();

    mmi_camco_need_restart_preview();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_rec_storage
 * DESCRIPTION
 *  mmi_camco_update_rec_storage
 * PARAMETERS
 *  storage     [IN]        Mmi storage value
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_update_rec_storage(U16 storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (storage == SRV_FMGR_DRV_CARD_TYPE)
    {
        mmi_camco_rec_p->storage = FS_GetDrive(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE);
    }
    else
    {
        mmi_camco_rec_p->storage = mmi_camco_get_storage_letter(storage);
    }
    mmi_camco_check_storage_path(mmi_camco_rec_p->storage, &mmi_camco_rec_p->storage_filepath_p);
    mmi_camco_rec_p->is_storage_change = MMI_TRUE;

#ifdef __MMI_IMAGE_VIEWER__
    mmi_imgview_set_storage(mmi_camco_rec_p->storage);
#endif 
#ifdef __MMI_VIDEO_PLAYER__
    mmi_vdoply_set_storage(mmi_camco_rec_p->storage);
#endif 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_vdosize
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  vdosize     [IN]        Mmi vdosize value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_vdosize(U16 vdosize)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
    mmi_camco_update_codecsize_cap_value();	
    mmi_camco_update_limit_capability();
    mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_VDOZOOM);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_recsizelimit
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  sizelimit       [IN]        Mmi recsizelimit value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_recsizelimit(U16 sizelimit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_rectimelimit
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  timelimit       [IN]        Mmi rectimelimit value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_rectimelimit(U16 timelimit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_reclimit
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  limit       [IN]        Mmi reclimit value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_reclimit(U16 limit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_recaud
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  recaud      [IN]        Mmi recaud value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_recaud(U16 recaud)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_visformat
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  visformat       [IN]        Mmi visformat value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_visformat(U16 visformat)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_camco_update_viscodec_cap_value();
    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_visqty
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  visqty      [IN]        Mmi visqty value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_visqty(U16 visqty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_camco_update_visqty_cap_value();
    mmi_camco_update_limit_capability();

    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_vdoscenemode
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  vdoscenemode        [IN]        Mmi vdoscenemode value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_vdoscenemode(U16 vdoscenemode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_update_capability();
    mmi_camco_setting_store_to_nvram();

    mmi_camco_need_restart_preview();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_timestamp
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  timestamp       [IN]        Mmi timestamp value
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_timestamp(U16 timestamp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (timestamp == MMI_CAMCO_TIMESTAMP_OFF)
    {
        mmi_camco_osd_set_time_stamp_enable(MMI_FALSE);
    }
    else if (timestamp == MMI_CAMCO_TIMESTAMP_ON)
    {
        mmi_camco_osd_set_time_stamp_enable(MMI_TRUE);
    }
    else
    {
        MMI_ASSERT(0);
    }
    mmi_camco_need_restart_preview();
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_update_restore_default_setting
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  restoredefault      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_update_restore_default_setting(U16 restoredefault)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_restore_default = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_reset_restore_default_setting
 * DESCRIPTION
 *  this function is called by camco setting module
 * PARAMETERS
 *  restoredefault      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_reset_restore_default_setting(U16 restoredefault)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_restore_default = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_start_zoom_in_one_step
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_start_zoom_in_one_step(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 zoom_step = 0;
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();

    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        zoom_step = mmi_camco_get_camzoom();
        if (zoom_step < mmi_camco_setting_get_camzoom_maxstep())
        {
            mmi_camco_setting_set_camzoom_step(zoom_step + 1);
            mdi_camera_update_para_zoom(zoom_step + 1);

            mmi_camco_setting_set_camzoom_value(mmi_camco_update_zoom_factor());
        }
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        zoom_step = mmi_camco_get_vdozoom();
        if (zoom_step < mmi_camco_setting_get_vdozoom_maxstep())
        {
            mmi_camco_setting_set_vdozoom_step(zoom_step + 1);
            mdi_video_rec_update_para_zoom(zoom_step + 1);

            mmi_camco_setting_set_vdozoom_value(mmi_camco_update_zoom_factor());
        }
    }
    else
    {
        MMI_ASSERT(0);
    }

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_start_zoom_out_one_step
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_start_zoom_out_one_step(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 zoom_step = 0;
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();

    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        zoom_step = mmi_camco_get_camzoom();
        if (zoom_step > mmi_camco_setting_get_camzoom_minstep())
        {
            mmi_camco_setting_set_camzoom_step(zoom_step - 1);
            mdi_camera_update_para_zoom(zoom_step - 1);

            mmi_camco_setting_set_camzoom_value(mmi_camco_update_zoom_factor());
        }
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        zoom_step = mmi_camco_get_vdozoom();
        if (zoom_step > mmi_camco_setting_get_vdozoom_minstep())
        {
            mmi_camco_setting_set_vdozoom_step(zoom_step - 1);
            mdi_video_rec_update_para_zoom(zoom_step - 1);

            mmi_camco_setting_set_vdozoom_value(mmi_camco_update_zoom_factor());
        }
    }
    else
    {
        MMI_ASSERT(0);
    }

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_start_fast_zoom_in
 * DESCRIPTION
 *  start fast zoom operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_start_fast_zoom_in(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {    
        mdi_camera_start_fast_zoom(TRUE, (U8) mmi_camco_setting_get_max_zoom(), 1, 1);
    }
    else
    {
        mdi_video_rec_start_fast_zoom(TRUE, (U8) mmi_camco_setting_get_max_zoom(), 1, 1); 
    }

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_start_fast_zoom_out
 * DESCRIPTION
 *  start fast zoom operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_start_fast_zoom_out(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {        
        mdi_camera_start_fast_zoom(FALSE, (U8) mmi_camco_setting_get_max_zoom(), 1, 1);
    }
    else
    {
        mdi_video_rec_start_fast_zoom(FALSE, (U8) mmi_camco_setting_get_max_zoom(), 1, 1);                 
    }

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_stop_fast_zoom
 * DESCRIPTION
 *  stop fast zoom operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_stop_fast_zoom(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {           
        mdi_camera_stop_fast_zoom();
    }
    else
    {
        mdi_video_rec_stop_fast_zoom();
    }    
}



/*****************************************************************************
 * FUNCTION
 *  mmi_camco_init_app
 * DESCRIPTION
 *  Init camcorder application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_init_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* initialize camera app-based memory */
    applib_mem_ap_register(APPLIB_MEM_AP_ID_CAMCO, STR_ID_CAMCO_APP_NAME, IMG_ID_CAMCO_APP_ICON, NULL);

    mmi_camco_setting_load_from_nvram();

    app = mmi_camco_setting_get_active_app();

    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_CAMERA);
    }
    else
    {
        mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_VIDEO);
    }

    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_EXIT;

    mmi_camco_cam_p->storage = (U16) SRV_FMGR_PUBLIC_DRV;
    mmi_camco_rec_p->storage = (U16) SRV_FMGR_PUBLIC_DRV;

    mmi_camco_cam_p->external_request.is_enable = MMI_FALSE;
    mmi_camco_rec_p->external_request.is_enable = MMI_FALSE;
    memset(&g_mmi_camco_cntx.partial_app, 0, sizeof(mmi_camco_partial_request_struct));

    mmi_camco_cam_p->cache_mem_pool = NULL;
    mmi_camco_cam_p->multishot_mem_pool = NULL;

    mmi_camco_cam_p->storage_filepath_p = NULL;
    mmi_camco_cam_p->buf_filename_p = NULL;

    mmi_camco_rec_p->storage_filepath_p = NULL;
    mmi_camco_rec_p->buf_filename_p = NULL;

    mmi_camco_cam_p->is_reset_zoom = MMI_FALSE;
    mmi_camco_rec_p->is_saving_prev = MMI_FALSE;
    mmi_camco_rec_p->is_save_success = MMI_FALSE;
#if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )
	g_mmi_camco_cntx.rotate = MDI_CAMERA_UI_ROTATE_0;
#endif
    g_mmi_camco_cntx.app_mem_buf_p = NULL;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.is_highlight_on = MMI_FALSE;

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ADD_FRAME)
    {
        mmi_camco_osd_set_add_frame_highlighted_idx(0);
        mmi_camco_cam_p->addframe_coloridx_index = 0;
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);

        mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
    }
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    mmi_camco_cam_p->is_switchto_sublcd = MMI_FALSE;
#endif 
    g_mmi_camco_cntx.is_disable_tvout = MMI_FALSE;
	g_mmi_camco_cntx.is_color_engine_enable = MMI_FALSE;

#ifdef __SMILE_SHUTTER_SUPPORT__
    mmi_camco_osd_set_zoom_ev_enable(MMI_TRUE);
#endif 

    custom_rec_init_table();
    custom_rec_set_table();
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	resz_cp_ESD_timeout_timer = kal_create_timer("MDP_ESD_CP_CRZ_TIMEOUT");
#endif

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_set_camera_id
 * DESCRIPTION
 *  set camera id
 * PARAMETERS
 *  cam_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_camco_set_camera_id(U16 cam_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 mdi_cam_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_cam_id = (U16) mmi_camco_get_cmd_camera_id(cam_id);
    mdi_camera_set_camera_id(mdi_cam_id);
    mdi_video_set_camera_id(mdi_cam_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_set_storage
 * DESCRIPTION
 *  set storage
 * PARAMETERS
 *  storage     [IN]        Storage location enum
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_set_storage(U16 storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 drv_enum;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->storage = storage;
    mmi_camco_rec_p->storage = storage;

    drv_enum = srv_fmgr_drv_get_type((U8)(storage));
    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_STORAGE, drv_enum);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_storage
 * DESCRIPTION
 *  get storage
 * PARAMETERS
 *  void
 * RETURNS
 *  U16
 *****************************************************************************/
U16 mmi_camco_get_storage(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();

    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        return mmi_camco_cam_p->storage;
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        return mmi_camco_rec_p->storage;
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_drive_avaiable
 * DESCRIPTION
 *  mmi_camco_is_drive_avaiable
 * PARAMETERS
 *  storage                 [IN]        Storage value
 *  storage_filepath_pp     [OUT]       Storage filepath pointer to pointer
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_camco_is_drive_avaiable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();

    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        return (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough);
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        return (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough);
    }
    else
    {
        MMI_ASSERT(0);    
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_check_storage_path
 * DESCRIPTION
 *  mmi_camco_check_storage_path
 * PARAMETERS
 *  storage                 [IN]        Storage value
 *  storage_filepath_pp     [OUT]       Storage filepath pointer to pointer
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_check_storage_path(U16 storage, CHAR **storage_filepath_pp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 create_result;
    MMI_BOOL is_drive_available = MMI_FALSE;
    MMI_BOOL is_space_enough = MMI_FALSE;
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* allocate storage path buffer */
    if (*storage_filepath_pp == NULL)
    {
        *storage_filepath_pp = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
        MMI_ASSERT(*storage_filepath_pp != NULL);
    }

    app = mmi_camco_setting_get_active_app();

    memset(*storage_filepath_pp, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    if (mmi_camco_check_and_restore_valid_drv(storage))
    {
        mmi_camco_get_storage_file_path(storage, *storage_filepath_pp);
        create_result = mmi_camco_create_file_dir(storage, *storage_filepath_pp);
        /* create directory failed */
        if (create_result == FS_WRITE_PROTECTION)
        {
            is_drive_available = MMI_FALSE;
            is_space_enough = MMI_FALSE;
        }
        else if (create_result == FS_DISK_FULL)
        {
            is_drive_available = MMI_TRUE;
            is_space_enough = MMI_FALSE;
        }
        else if (create_result == FS_ROOT_DIR_FULL)
        {
            is_drive_available = MMI_TRUE;
            is_space_enough = MMI_FALSE;
        }
        else
        {
            is_drive_available = MMI_TRUE;
            is_space_enough = MMI_TRUE;
        }

        if (!is_drive_available || !is_space_enough)
        {
            if (MMI_CAMCO_SETTING_APP_CAMERA == app)
            {
                mmi_camco_cam_p->err_str_id = srv_fmgr_fs_error_get_string(create_result);
            }
            else
            {
                mmi_camco_rec_p->err_str_id = srv_fmgr_fs_error_get_string(create_result);
            }
        }

    }
    else
    {
        if (MMI_CAMCO_SETTING_APP_CAMERA == app)
        {
            if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE)
            {
                mmi_camco_cam_p->err_str_id = STR_ID_CAMCO_MEM_CARD_INSERT;
            }
			else if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_OTG_TYPE)
			{		    
                mmi_camco_cam_p->err_str_id = STR_ID_CAMCO_OTG_INSERT;
			}
			else
            {
                mmi_camco_cam_p->err_str_id = srv_fmgr_fs_error_get_string(FS_FAT_ALLOC_ERROR);
            }
        }
        else
        {
            if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE)
            {
                mmi_camco_rec_p->err_str_id = STR_ID_CAMCO_MEM_CARD_INSERT;
            }
			else if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_OTG_TYPE)
			{		    
                mmi_camco_rec_p->err_str_id = STR_ID_CAMCO_OTG_INSERT;
            }
            else
            {
                mmi_camco_rec_p->err_str_id = srv_fmgr_fs_error_get_string(FS_FAT_ALLOC_ERROR);
            }
        }
    }

    if (MMI_CAMCO_SETTING_APP_CAMERA == app)
    {
        mmi_camco_cam_p->is_drive_available = is_drive_available;
        mmi_camco_cam_p->is_space_enough = is_space_enough;
    }
    else
    {
        mmi_camco_rec_p->is_drive_available = is_drive_available;
        mmi_camco_rec_p->is_space_enough = is_space_enough;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_storage_file_path
 * DESCRIPTION
 *  get current active storage file path.
 * PARAMETERS
 *  storage         [IN]        
 *  filepath_p      [OUT]       File path
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_camco_get_storage_file_path(U16 storage, CHAR* filepath_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR drv_buf[8];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_get_storage_disk_path(storage, drv_buf))
    {
        mmi_ucs2cpy( filepath_p,  drv_buf);
        if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
        {
            mmi_ucs2cat(filepath_p, (const CHAR*) MMI_CAMCO_STORAGE_CAM_FILEPATH);
        }
        else
        {
            mmi_ucs2cat(filepath_p, (const CHAR*) MMI_CAMCO_STORAGE_REC_FILEPATH);
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_storage_disk_path
 * DESCRIPTION
 *  get current active storage disk path.
 * PARAMETERS
 *  storage         [IN]        Storage value
 *  drv_buf_p       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static BOOL mmi_camco_get_storage_disk_path(U16 storage, CHAR* drv_buf_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf[64];
    int error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (FS_NO_ERROR == FS_GetDevStatus(storage, FS_MOUNT_STATE_ENUM))
    {
        sprintf(buf, "%c:\\", (U8) storage);
        mmi_asc_to_ucs2(drv_buf_p, buf);
        return TRUE;
    }
    else
    {
        storage = (U16) SRV_FMGR_PUBLIC_DRV;
        error = FS_GetDevStatus(storage, FS_MOUNT_STATE_ENUM);

        if (FS_NO_ERROR == error)
        {
            sprintf(buf, "%c:\\", (U8) storage);
            mmi_asc_to_ucs2(drv_buf_p, buf);
            return TRUE;
        }
        else
        {
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_GET_STORAGE_FAILED);
            return FALSE;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_check_and_restore_valid_drv
 * DESCRIPTION
 *  Check if desired path is ready or not. If not, will restore to valid path.
 * PARAMETERS
 *  storage     [IN]        Storage value
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_camco_check_and_restore_valid_drv(U16 storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (FS_NO_ERROR == FS_GetDevStatus(storage, FS_MOUNT_STATE_ENUM))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_create_file_dir
 * DESCRIPTION
 *  create directly from a file path (resursivly)
 * PARAMETERS
 *  storage         [IN]        Storage
 *  filepath_p      [IN]        File path to create
 * RETURNS
 *  S32
 *****************************************************************************/
static S32 mmi_camco_create_file_dir(U16 storage, CHAR* filepath_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fs_ret;
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fs_ret = 0;

    file_handle = FS_Open((kal_uint16*) filepath_p, FS_OPEN_DIR | FS_READ_ONLY);

    /* path already exist */
    if (file_handle >= 0)
    {
        FS_Close(file_handle);
        return 0;   /* already exist , 0 measn success in FS */
    }

#ifdef __MMI_MY_FAVORITE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_MY_FAVORITE__ */ 

    /* create directory if it is not there */
    fs_ret = FS_CreateDir((PU16) filepath_p);

    if (fs_ret < 0)
    {
        return fs_ret;
    }

    return fs_ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_file_exist
 * DESCRIPTION
 *  
 * PARAMETERS
 *  filepath_p      [IN]        File path to
 * RETURNS
 *  S32
 *****************************************************************************/
static MMI_BOOL mmi_camco_is_file_exist(CHAR* filepath_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    file_handle = FS_GetAttributes((U16*) filepath_p);

    if (file_handle < 0)
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_switching_maincamera
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  is_switchto_maincamera  [OUT]
 *****************************************************************************/
MMI_BOOL mmi_camco_is_switching_maincamera(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_mmi_camco_cntx.is_switchto_maincamera;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_switching_subcamera
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  is_switchto_subcamera  [OUT]
 *****************************************************************************/
MMI_BOOL mmi_camco_is_switching_subcamera(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_mmi_camco_cntx.is_switchto_subcamera;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_from_external
 * DESCRIPTION
 *  check if camcorder is supporting external app
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_camco_is_from_external(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        if (mmi_camco_cam_p->external_request.is_enable || g_mmi_camco_cntx.partial_app.is_only_camera)
        {
            ret = MMI_TRUE;
        }
    }
    else if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        if (mmi_camco_rec_p->external_request.is_enable || g_mmi_camco_cntx.partial_app.is_only_recorder)
        {
            ret = MMI_TRUE;
        }
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_gobackfromhistory
 * DESCRIPTION
 *  clear external flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_camco_is_gobackfromhistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SAVE_DONE ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_BURSTSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AEBSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_SHOT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_ADD_FRAME ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SUB_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVING ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVE_DONE ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVING_PREV)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_preview
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  is_preview  [OUT]
 *****************************************************************************/
MMI_BOOL mmi_camco_is_preview(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_preview_start)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_incall
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  is_incall  [OUT]
 *****************************************************************************/
MMI_BOOL mmi_camco_is_incall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(__RF_DESENSE_TEST__)
    if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) > 0 ||
        srv_ucm_query_call_count(SRV_UCM_OUTGOING_STATE, SRV_UCM_CALL_TYPE_DATA_CSD_ALL, NULL) > 0 ||
        srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)
    {
        return MMI_TRUE;
    }
    else
#endif /* !defined(__RF_DESENSE_TEST__) */ 
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_is_usb_in_CDC
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE/MMI_FALSE      [OUT]
 *****************************************************************************/
static MMI_BOOL mmi_camco_is_usb_in_CDC(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_USB_SUPPORT__
    if (srv_usb_get_status() == SRV_USBSTATUS_CDCACM)
    {
        return MMI_TRUE;
    }
    else
#endif /* __MMI_USB_SUPPORT__ */ 
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_clear_external_request
 * DESCRIPTION
 *  clear external flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_clear_external_request(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->external_request.callback = NULL;
    mmi_camco_cam_p->external_request.is_enable = MMI_FALSE;
    mmi_camco_rec_p->external_request.callback = NULL;
    mmi_camco_rec_p->external_request.is_enable = MMI_FALSE;
    memset(&g_mmi_camco_cntx.partial_app, 0, sizeof(mmi_camco_partial_request_struct));
    g_mmi_camco_cntx.is_to_media_editor = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_file_deleted_hdlr
 * DESCRIPTION
 *  Show error message and re-start to preview
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_file_deleted_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();

    mmi_camco_osd_set_bg_black();

    mmi_camco_show_error_msg(MMI_CAMCO_ERR_FILE_NOT_FOUND);
    mmi_camco_error_hdlr_timer_start();

    /* Prepare to enter camera preview state, otherwise screen sometimes shows noises */
    kal_sleep_task(500);
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
        if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {
            #ifdef AF_SUPPORT
				SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
            #endif

            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
        #ifdef __MMI_CAMCO_EVB_AF_TEST__

		#ifdef AF_SUPPORT
            SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
        #endif

        #endif /* __MMI_CAMCO_EVB_AF_TEST__ */             
            g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
        }
        else
        {
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
        }
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_preview_set_key_hdlr();

    #endif /* __MMI_CAMCO_FTE__ */ 
    }
    else
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
        if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
        {

            #ifdef AF_SUPPORT	
			if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
			{
				SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
			}
			#endif
            SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
            g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
        }
        else
        {
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
        }
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_rec_preview_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
    }
    mmi_camco_osd_draw_osd();

    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_image
 * DESCRIPTION
 *  Save image by MMI not MED
 * PARAMETERS
 *  buff_filename_p     [IN]        
 *  image_buf_ptr       [IN]        
 *  image_buf_size      [IN]        
 * RETURNS
 *  MDI_RESULT          [OUT]       the save result
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_save_image(CHAR* buff_filename_p, PU8 image_buf_ptr, U32 image_buf_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;
    U32 written;
    //U16 idx;
    //CHAR* buf_filename;
    S32 fs_ret = 0;
    MMI_BOOL is_error_handle_done = MMI_FALSE;
    MDI_RESULT result = MMI_CAMCO_ERR_SAVE_FAIL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    file_handle = FS_Open((U16*) buff_filename_p, FS_CREATE | FS_READ_WRITE);

    if (file_handle > 0)
    {
        fs_ret = FS_Write(file_handle, (void*)image_buf_ptr, image_buf_size, (U32*) & written);
        FS_Close(file_handle);

        if(fs_ret == FS_MSDC_READ_SECTOR_ERROR || fs_ret == FS_MSDC_WRITE_SECTOR_ERROR  || fs_ret == FS_MEDIA_CHANGED)
        {
            
        }        	
        /* cant write in whole file, must be disk full */
        else if (image_buf_size != written)
        {
            /* delete the file that is not save complete */
            FS_Delete((U16*) buff_filename_p);

            result = MDI_RES_CAMERA_ERR_DISK_FULL;
            is_error_handle_done = MMI_TRUE;
        }
        else if (fs_ret == 0)
        {
            result = MDI_RES_CAMERA_SUCCEED;
        }
    }

    if (file_handle < 0 || (fs_ret < 0 && !is_error_handle_done))
    {

        if (file_handle == FS_DISK_FULL)
        {
            result = MDI_RES_CAMERA_ERR_DISK_FULL;
        }
        else if (file_handle == FS_ROOT_DIR_FULL)
        {
            result = MMI_CAMCO_ERR_ROOT_DIR_FULL;
        }
        else if (file_handle == FS_WRITE_PROTECTION)
        {
            result = MDI_RES_CAMERA_ERR_WRITE_PROTECTION;
        }
        else
        {
            result = MMI_CAMCO_ERR_SAVE_FAIL;
        }
    }

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_set_framework_environment
 * DESCRIPTION
 *  set framework environment
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_set_framework_environment(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* entry full screen app */
    entry_full_screen();

    gdi_layer_reset_clip();

    /* stop bg music */
    mdi_audio_suspend_background_play();

    mmi_settings_turn_off_sound_effects();
    
    /* stop MMI sleep */
    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

    /* force all playing keypad tone off */
    srv_prof_stop_tone(SRV_PROF_TONE_KEYPAD);

    /* disable key pad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);

    /* disalbe align timer  */
    UI_disable_alignment_timers();

    /* stop LED patten */
    srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_STOP);

    /* because we wont use base in our App, we clean it to prevent popup use previous AP as base */
    gdi_layer_get_base_handle(&base_layer);
    gdi_layer_push_and_set_active(base_layer);
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active();

#ifdef __MMI_VECTOR_FONT_SUPPORT__
    mmi_fe_set_antialias(MMI_FALSE);
#endif 

#ifdef __MMI_SUBLCD__
    mmi_camco_init_sublcd();
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_recover_framework_environment
 * DESCRIPTION
 *  recover framework environment
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_recover_framework_environment(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_settings_turn_on_sound_effects();

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);

    gdi_layer_resize(UI_device_width, UI_device_height);

    gdi_layer_set_position(0, 0);

    gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);

    gdi_layer_pop_and_restore_active();

    /* resume alignment timer */
    UI_enable_alignment_timers();

    /* resume LED patten */
    srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_START);

    /* let MMI can sleep */
    srv_backlight_turn_off();

    /* enable multi-layer */
    gdi_layer_multi_layer_disable();

    /* resume background audio */
    mdi_audio_resume_background_play();

    /* re-enable keypad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);

#ifdef __MMI_VECTOR_FONT_SUPPORT__
    mmi_fe_set_antialias(MMI_TRUE);
#endif 

#ifdef __MMI_SUBLCD__
    if (!g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_deinit_sublcd();
    }
#endif /* __MMI_SUBLCD__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_entry_app_screen
 * DESCRIPTION
 *  entry camcorder application screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_entry_app_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;
    //srv_cbm_result_error_enum ret;
    U8 *temp_p = NULL;
    U16 idx;
    //U32 appmem_size = 0;
    #if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )
		srv_sensor_motion_direct_cfg_struct sensitive;
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (mmi_is_redrawing_bk_screens() == TRUE)
    {        
        if (!mmi_frm_scrn_enter(SCR_GROUP_ID_CAMCO_INT_APP, SCR_ID_CAMCO_APP, NULL, mmi_camco_entry_app_screen, MMI_FRM_FG_ONLY_SCRN))        	
            return;
    
        /* disable SSE */
        gui_screen_switch_effect_block(MMI_TRUE);
        
        gdi_layer_get_base_handle(&g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_clear(GDI_COLOR_BLACK);
        gdi_layer_pop_and_restore_active();
        return;
    }
//#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 


    /* ============================================================================= */
    /*                       check camcorder execute condition                       */
    /* ============================================================================= */
    {
        MMI_ID current_group_id;
        MMI_ID current_screen_id;  
        FuncPtr entry_proc;
        mmi_popup_property_struct arg;      
        
        if (mmi_camco_is_from_external())
        {       
            current_group_id = SCR_GROUP_ID_CAMCO_EXT_APP;
            current_screen_id = SCR_ID_CAMCO_EXT_APP;
            entry_proc = mmi_camco_ext_resume_from_cui;
        }
        else
        {       
            current_group_id = SCR_GROUP_ID_CAMCO_INT_APP;
            current_screen_id = SCR_ID_CAMCO_APP;
            entry_proc = mmi_camco_resume_from_cui;

        }
        mmi_popup_property_init(&arg);
        arg.parent_id = current_group_id;
        
    #ifdef __MMI_BT_SUPPORT__
        /* can't concurrent with background BT action */
        if (mmi_bt_is_receiving())
        {
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_ENTRY_FAIL, 0);
            mmi_frm_scrn_enter(current_group_id, current_screen_id, NULL, entry_proc, MMI_FRM_UNKNOW_SCRN);
            mmi_frm_scrn_clear_attribute(current_group_id, current_screen_id, MMI_SCRN_ATTRIB_ADD_HISTORY);
            mmi_popup_display((WCHAR *) GetString(STR_ID_CAMCO_NOTIFY_BT_IS_WORKING), MMI_EVENT_FAILURE, &arg);
        
            if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT || g_mmi_camco_cntx.is_to_media_editor)
            {
                mmi_camco_clear_external_request();
                /* Must call clear external request firstly */
                mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
            }
            else
            {
                mmi_camco_clear_external_request();
            }
            if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
            {
            #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
                mmi_camco_osd_set_init_mem(NULL);
                g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);      	
            #endif

                g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
                g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);      	
                
            #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
                g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
                g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
            #endif        
                //applib_mem_ap_free((void*)g_mmi_camco_cntx.app_mem_buf_p);
               mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);
                g_mmi_camco_cntx.app_mem_buf_p = NULL;
                mmi_camco_cam_p->multishot_mem_pool = NULL;
                mmi_camco_cam_p->cache_mem_pool = NULL;
                mmi_camco_cam_p->cache_layer_pool = NULL;
            }
            return;
        }
    #endif /* __MMI_BT_SUPPORT__ */ 


    #ifdef __MTK_TARGET__
    #ifdef __MMI_PICT_BRIDGE_SUPPORT__
        if (mmi_pict_is_dps_device_present())
        {
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_ENTRY_FAIL, 2);    
            mmi_frm_scrn_enter(current_group_id, current_screen_id, NULL, entry_proc, MMI_FRM_UNKNOW_SCRN);
            mmi_frm_scrn_clear_attribute(current_group_id, current_screen_id, MMI_SCRN_ATTRIB_ADD_HISTORY);
            mmi_popup_display((WCHAR *) GetString(STR_ID_CAMCO_NOTIFY_PICT_IS_WORKING), MMI_EVENT_FAILURE, &arg);
               
            mmi_camco_clear_external_request();
            if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
            }
            if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
            {
            #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
                mmi_camco_osd_set_init_mem(NULL);
                g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);
            #endif

                g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
                g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);       
                                
            #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
                g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
                g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
            #endif                   
                mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);
                //applib_mem_ap_free((void*)g_mmi_camco_cntx.app_mem_buf_p);
                g_mmi_camco_cntx.app_mem_buf_p = NULL;
                mmi_camco_cam_p->multishot_mem_pool = NULL;
                mmi_camco_cam_p->cache_mem_pool = NULL;
                mmi_camco_cam_p->cache_layer_pool = NULL;
            }
            return;
        }
    #endif /* __MMI_PICT_BRIDGE_SUPPORT__ */ 
    #endif /* __MTK_TARGET__ */ 


        if (mmi_camco_is_incall() && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
        {
            if (!g_mmi_camco_cntx.is_to_media_editor)
            {
                mmi_ucm_app_entry_error_message();
                mmi_frm_group_close(current_group_id);
                if (!mmi_camco_is_from_external())
                {                 
                    mmi_frm_group_close(APPLIB_MEM_AP_ID_CAMCO);
                }
                mmi_camco_clear_external_request();
                if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
                {
                #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
                    mmi_camco_osd_set_init_mem(NULL);
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);               
                #endif

                    g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);       
                                    
                #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
                    g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
                #endif         
                    mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);
                    //applib_mem_ap_free((void*)g_mmi_camco_cntx.app_mem_buf_p);
                    g_mmi_camco_cntx.app_mem_buf_p = NULL;
                    mmi_camco_cam_p->multishot_mem_pool = NULL;
                    mmi_camco_cam_p->cache_mem_pool = NULL;
                    mmi_camco_cam_p->cache_layer_pool = NULL;
                }                
                return;
            }
        }
    
    #ifdef __USB_IN_NORMAL_MODE__
        if (srv_usb_is_in_mass_storage_mode())
        {
            MMI_STR_ID string_id = 0;
            mmi_event_notify_enum event_type = MMI_EVENT_DEFAULT;            
            
            /* in mass storage mode */   
            if (srv_usb_check_path_exported((WCHAR*) MMI_CAMCO_STORAGE_CAM_FILEPATH))
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_ENTRY_FAIL, 3);                	
                /* phone drive is exported, cant use this app */
                string_id = mmi_usb_get_error_info(SRV_USB_ERROR_UNAVAILABLE, &event_type);
                
                mmi_frm_scrn_enter(current_group_id, current_screen_id, NULL, entry_proc, MMI_FRM_UNKNOW_SCRN);
                mmi_frm_scrn_clear_attribute(current_group_id, current_screen_id, MMI_SCRN_ATTRIB_ADD_HISTORY);
                mmi_popup_display((WCHAR *) GetString(string_id), event_type, &arg);

                mmi_camco_clear_external_request();
                if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT)
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
                }
                if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
                {
                #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
                    mmi_camco_osd_set_init_mem(NULL);
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);     	        	
                #endif

                    g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);       
                                                        
                #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
                    g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
                #endif
                        mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);

                    //applib_mem_ap_free((void*)g_mmi_camco_cntx.app_mem_buf_p);
                    g_mmi_camco_cntx.app_mem_buf_p = NULL;
                    mmi_camco_cam_p->multishot_mem_pool = NULL;
                    mmi_camco_cam_p->cache_mem_pool = NULL;
                    mmi_camco_cam_p->cache_layer_pool = NULL;
                }                
                return;
            }
    
            if (srv_usb_check_path_exported((WCHAR*)MMI_CAMCO_STORAGE_REC_FILEPATH))
            {
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_ENTRY_FAIL, 4);                  	
                /* phone drive is exported, cant use this app */
                string_id = mmi_usb_get_error_info(SRV_USB_ERROR_UNAVAILABLE, &event_type);
                
                mmi_frm_scrn_enter(current_group_id, current_screen_id, NULL, entry_proc, MMI_FRM_UNKNOW_SCRN);
                mmi_frm_scrn_clear_attribute(current_group_id, current_screen_id, MMI_SCRN_ATTRIB_ADD_HISTORY);
                mmi_popup_display((WCHAR *) GetString(string_id), event_type, &arg);
                
                mmi_camco_clear_external_request();
                if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT)
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
                }
                if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
                {
                #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
                    mmi_camco_osd_set_init_mem(NULL);
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);                  
                #endif

                    g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (GDI_LCD_WIDTH * GDI_LCD_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);                                           
                    
                #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
                    g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
                    g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
                #endif                     
                    //applib_mem_ap_free((void*)g_mmi_camco_cntx.app_mem_buf_p);
                    mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);
                    g_mmi_camco_cntx.app_mem_buf_p = NULL;
                    mmi_camco_cam_p->multishot_mem_pool = NULL;
                    mmi_camco_cam_p->cache_mem_pool = NULL;
                    mmi_camco_cam_p->cache_layer_pool = NULL;
                }                  
                return;
            }
    
        }
    #endif /* __USB_IN_NORMAL_MODE__ */ 
    
    
  
    }
    /* ============================================================================= */
    /*                     check camcorder execute condition end                     */
    /* ============================================================================= */

    /* entry screen in SG may fial, so we don't need to initialize the parameter or resource until entry successly */
    app = mmi_camco_setting_get_active_app();

    if (MMI_CAMCO_SETTING_APP_CAMERA == app)
    {
        if (mmi_camco_cam_p->external_request.is_enable)
        {
            if (!mmi_frm_scrn_enter(SCR_GROUP_ID_CAMCO_EXT_APP, SCR_ID_CAMCO_EXT_APP, mmi_camco_exit_app_screen, mmi_camco_ext_resume_from_cui, MMI_FRM_UNKNOW_SCRN))
                return;
        }
        else
        {
            if (!mmi_frm_scrn_enter(SCR_GROUP_ID_CAMCO_INT_APP, SCR_ID_CAMCO_APP, mmi_camco_exit_app_screen, mmi_camco_resume_from_cui, MMI_FRM_UNKNOW_SCRN))
                return;
        }

    }
    else if (MMI_CAMCO_SETTING_APP_VIDEO == app)
    {
        if (mmi_camco_rec_p->external_request.is_enable || g_mmi_camco_cntx.partial_app.is_only_recorder)
        {
            if (!mmi_frm_scrn_enter(SCR_GROUP_ID_CAMCO_EXT_APP, SCR_ID_CAMCO_EXT_APP, mmi_camco_exit_app_screen, mmi_camco_ext_resume_from_cui, MMI_FRM_UNKNOW_SCRN))
                return;
        }
        else
        {
            if (!mmi_frm_scrn_enter(SCR_GROUP_ID_CAMCO_INT_APP, SCR_ID_CAMCO_APP, mmi_camco_exit_app_screen, mmi_camco_resume_from_cui, MMI_FRM_UNKNOW_SCRN))
                return;
        }
    }
    /* disable SSE */
    gui_screen_switch_effect_block(MMI_TRUE);
        
    /* set ther blt mode to make osd blt immediate */
    mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);

    /* entry success, start to initialize paramter and resource */

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

    g_mmi_camco_cntx.is_power_on = MMI_FALSE;
    g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
    g_mmi_camco_cntx.is_sublcd_display = MMI_FALSE;
    g_mmi_camco_cntx.is_restart_preview = MMI_FALSE;
    g_mmi_camco_cntx.is_osd_init = MMI_FALSE;
    g_mmi_camco_cntx.is_capture_when_focused = MMI_FALSE;
    g_mmi_camco_cntx.is_playing_focused_wav = MMI_FALSE;
    g_mmi_camco_cntx.is_switching_app = MMI_FALSE;
    g_mmi_camco_cntx.is_switchto_maincamera = MMI_FALSE;
    g_mmi_camco_cntx.is_switchto_subcamera = MMI_FALSE;
    g_mmi_camco_cntx.is_restore_default = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_FALSE;
    g_mmi_camco_cntx.preview_timeout_count = 0;
    g_mmi_camco_cntx.is_preemptable = MMI_TRUE;
    g_mmi_camco_cntx.is_post_process_pause= MMI_FALSE;

    mmi_camco_cam_p->is_drive_available = MMI_FALSE;
    mmi_camco_cam_p->is_space_enough = MMI_FALSE;
    mmi_camco_cam_p->is_continue_capture = MMI_FALSE;
    mmi_camco_cam_p->is_burstshot_finish = MMI_FALSE;
    mmi_camco_cam_p->is_hdr_shot_process = MMI_FALSE;    
    mmi_camco_cam_p->is_takepic_failed = MMI_FALSE;
    mmi_camco_cam_p->is_storage_change = MMI_TRUE;
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    mmi_camco_cam_p->is_sublcd_capture = MMI_FALSE;
#endif 
    mmi_camco_cam_p->is_facedetect_start = MMI_FALSE;

    mmi_camco_rec_p->is_drive_available = MMI_FALSE;
    mmi_camco_rec_p->is_space_enough = MMI_FALSE;
    mmi_camco_rec_p->is_save_done_when_mt = MMI_FALSE;
    mmi_camco_rec_p->is_record_start = MMI_FALSE;
    mmi_camco_rec_p->is_record_failed = MMI_FALSE;
    mmi_camco_rec_p->is_storage_change = MMI_TRUE;

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
    {

        if (!mmi_camco_cam_p->external_request.is_enable &&
            !mmi_camco_rec_p->external_request.is_enable && !g_mmi_camco_cntx.partial_app.is_only_recorder)
        {

		    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
                temp_p =
                    (U8*) g_mmi_camco_cntx.app_mem_buf_p + MMI_CAMCO_OSD_LAYER_DB_BUF_SIZE +
                    MMI_CAMCO_SUBLCD_OSD_LAYER_DB_BUF_SIZE;
            #else /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
                temp_p = (U8*) g_mmi_camco_cntx.app_mem_buf_p + MMI_CAMCO_OSD_LAYER_DB_BUF_SIZE;
            #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */

			    // the additional size for align 
                temp_p += 64;   
			
        #if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)|| defined(__MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__)
            
                mmi_camco_cam_p->cache_mem_pool = NULL;
                mmi_camco_cam_p->multishot_mem_pool = NULL;
                mmi_camco_cam_p->cache_layer_pool = NULL;
                mmi_camco_cam_p->cache_layer_pool = (void*)(temp_p);
                #if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
                    mmi_camco_osd_imageselect_set_cache_layer_buf_p(mmi_camco_cam_p->cache_layer_pool);
                #endif
				
				#ifdef  __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
				    mmi_camco_osd_autorama_set_cache_layer_buf_p(mmi_camco_cam_p->cache_layer_pool);
                #endif

                mmi_camco_cam_p->cache_mem_pool = (void*)((U8*) mmi_camco_cam_p->cache_layer_pool +
                                                           MMI_CAMCO_OSD_CACHE_LAYER_BUF_SIZE + 64);

            #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
                temp_p = (U8*) mmi_camco_cam_p->cache_mem_pool;

                for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; idx++)
                {
                    mmi_camco_cam_p->burstshot.cache_img_p[idx] = temp_p;
                    temp_p += MMI_CAMCO_CAM_CACHE_IMAGE_SIZE;
                }
            #endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
            #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
                temp_p = (U8*) mmi_camco_cam_p->cache_mem_pool;

                for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; idx++)
                {
                    mmi_camco_cam_p->aebshot.cache_img_p[idx] = temp_p;
                    temp_p += MMI_CAMCO_CAM_CACHE_IMAGE_SIZE;
                }
            #endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 
		    #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
                temp_p = (U8*) mmi_camco_cam_p->cache_mem_pool;

                    mmi_camco_cam_p->autorama_shot.cache_buffer_p = temp_p;
                    temp_p += MMI_CAMCO_CAM_AUTORAMA_CACHE_IMAGE_SIZE;
            #endif

            
        #endif /* defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__) */ 

        #if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)||defined(__MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__)
            mmi_camco_cam_p->multishot_mem_pool =
                (void*)((U8*) mmi_camco_cam_p->cache_mem_pool +
                         MMI_CAMCO_CAM_CACHE_MEM_SIZE);
		
        #elif defined(__MMI_CAMCO_FEATURE_CAM_BESTSHOT__)
            mmi_camco_cam_p->multishot_mem_pool = (void*)(temp_p);
        #endif 

        }

        MMI_ASSERT(mmi_camco_cam_p->buf_filename_p == NULL);
        MMI_ASSERT(mmi_camco_cam_p->storage_filepath_p == NULL);

        MMI_ASSERT(mmi_camco_rec_p->buf_filename_p == NULL);
        MMI_ASSERT(mmi_camco_rec_p->storage_filepath_p == NULL);

        mmi_camco_cam_p->buf_filename_p = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
        MMI_ASSERT(mmi_camco_cam_p->buf_filename_p != NULL);
            memset(mmi_camco_cam_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);

        mmi_camco_rec_p->buf_filename_p = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
        MMI_ASSERT(mmi_camco_rec_p->buf_filename_p != NULL);
            memset(mmi_camco_rec_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    #ifdef __MMI_CAMCO_FEATURE_OSD_IMAGE_SELECT__
        if (!mmi_camco_cam_p->external_request.is_enable &&
            !mmi_camco_rec_p->external_request.is_enable && !g_mmi_camco_cntx.partial_app.is_only_recorder)
        {
            MMI_ASSERT(mmi_camco_cam_p->multishot_mem_pool != NULL);
            temp_p = ((U8*) mmi_camco_cam_p->multishot_mem_pool + MMI_CAMCO_CAM_MULTISHOT_MEM_SIZE);
            mmi_camco_osd_init_image_select_filename_buffer((CHAR*) temp_p);
        }
    #endif /* __MMI_CAMCO_FEATURE_OSD_IMAGE_SELECT__ */ 

        if (!g_mmi_camco_cntx.is_to_media_editor)
        {
            mmi_camco_osd_set_default();
            mmi_camco_setting_set_default();
        }
    }

#ifdef __MMI_BT_SUPPORT__
    mmi_bt_disable_receiving();  
#endif 
#if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )
		sensitive.angle_threshold = 30;
		g_mmi_camco_cntx.tilt_handle = srv_sensor_start_listen(SRV_SENSOR_MOTION_DIRECT, &sensitive, mmi_camco_motion_tilt_hdlr,NULL);
#endif

    if (MMI_CAMCO_SETTING_APP_CAMERA == app)
    {
        mmi_camco_cam_entry_app_screen_internal();
    }
    else if (MMI_CAMCO_SETTING_APP_VIDEO == app)
    {
        mmi_camco_rec_entry_app_screen_internal();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_app_screen
 * DESCRIPTION
 *  entry camcorder application screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_app_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
#if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )	
	srv_sensor_stop_listen(g_mmi_camco_cntx.tilt_handle);
	g_mmi_camco_cntx.tilt_handle = -1; 
#endif
#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    gui_cancel_timer(mmi_camco_preview_terminate_hdlr);
    g_mmi_camco_cntx.preview_timeout_count = 0;
#endif /* __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__ */ 
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
#endif

    if (g_mmi_camco_cntx.is_errortimer_start)
    {
        mmi_camco_error_hdlr_timer_stop();
    }
	/*disable and close color engine for quickview image when in preview state*/
	if(g_mmi_camco_cntx.is_color_engine_enable)
	{
		mdi_camera_color_engine_disable();
		mdi_camera_color_engine_close();
		g_mmi_camco_cntx.is_color_engine_enable = MMI_FALSE;
	}

    if (MMI_CAMCO_SETTING_APP_CAMERA == app)
    {
        mmi_camco_cam_exit_app_screen();
    }
    else if (MMI_CAMCO_SETTING_APP_VIDEO == app)
    {
        mmi_camco_rec_exit_app_screen();
    }

    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);      
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);     
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active(); 
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);     
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_pop_and_restore_active(); 
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_EXIT);
    mmi_camco_osd_reset_environment();

    if (g_mmi_camco_cntx.preview_base_layer_handle)
    {
        mdi_util_hw_layer_free(g_mmi_camco_cntx.preview_base_layer_handle);
        gdi_layer_free(g_mmi_camco_cntx.non_preview_base_layer_handle);            
        g_mmi_camco_cntx.preview_base_layer_handle = NULL;
        g_mmi_camco_cntx.has_got_base_layer = MMI_FALSE;
    }

    mmi_camco_setting_store_to_nvram();

#if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
    gdi_bltdb_disable();
#endif

    ClearKeyEvents();

#ifdef __MMI_BT_SUPPORT__
    mmi_bt_enable_receiving();  
#endif 
    srv_backlight_turn_off();

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 
if(g_mmi_camco_cntx.is_to_media_editor)
 {
  mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
 }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_exit_app_screen
 * DESCRIPTION
 *  exit camcorder application screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_exit_app_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_EXIT);

    mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_CAMERA);

    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT)
    {
        mmi_camco_exit_current_state();
    }

    switch (g_mmi_camco_cntx.app_state)
    {
        case MMI_CAMCO_STATE_CAM_PREVIEW:
    #ifdef __SMILE_SHUTTER_SUPPORT__
        case MMI_CAMCO_STATE_CAM_SMILE_DECT:
    #endif 
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_PREVIEW_FAILED:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_SETTING_MENU:
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
            if (mmi_camco_cam_p->is_switchto_sublcd && !g_mmi_camco_cntx.is_preview_start)
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            }
            else
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_SETTING_MENU;
            }
            break;

        case MMI_CAMCO_STATE_CAM_COUNTDOWN:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_FOCUSING:
        case MMI_CAMCO_STATE_CAM_FOCUSED:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_CAPTURE:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_CONTSHOT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_ADD_FRAME:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_ADD_FRAME;
            break;

        case MMI_CAMCO_STATE_CAM_SAVE_DONE:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_SAVE_DONE;
            break;

        case MMI_CAMCO_STATE_CAM_BURSTSHOT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;
        case MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_BURSTSHOT_SELECT;
            break;

        case MMI_CAMCO_STATE_CAM_AEBSHOT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_AEBSHOT_SELECT;
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH:
        #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
        #endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_DONE:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE;
            break;

        case MMI_CAMCO_STATE_CAM_HDR_SHOT:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_HDR_DONE:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_SAVE_DONE;
            break;
		case MMI_CAMCO_STATE_CAM_MAV_SHOT:
			g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_CAM_SUB_PREVIEW:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_SUB_PREVIEW;
            break;

        case MMI_CAMCO_STATE_RESTORE_CONFIRM:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_INT_RESTORE_CONFIRM;
            break;

        case MMI_CAMCO_STATE_EXIT:  /* From DelCallback handing, exit the app */
            break;

        default:
        #ifndef __MMI_BACKGROUND_CALL__
            if(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CSD_CALL_TYPE_ALL, NULL) <= 0)
            {            	
                MMI_ASSERT(0);
            }    
        #endif 
            break;

    }

    mmi_camco_cam_recover_framework_environment();

    mmi_camco_cam_power_off();


    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CURRENT_STATE, g_mmi_camco_cntx.app_state);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_del_scr_callback
 * DESCRIPTION
 *  camera delete screen callback handler
 * PARAMETERS
 *  ptr     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static U8 mmi_camco_del_scr_callback(void *ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_capsize_enum capsize;
    mmi_camco_capsize_enum original_capsize = MMI_CAMCO_CAPSIZE_WALLPAPER;
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_DEL_CB, g_mmi_camco_cntx.app_state);

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_ADD_FRAME ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_ADD_FRAME )
    {
        /***************************************************************************/
        /* Restore the previous capture to recover the previous capsize capability */
        /* Need to do this before changing the capsize to the previous capsize     */
        /***************************************************************************/
        mmi_camco_update_capmode(mmi_camco_get_last_capmode());
        if (mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_ADD_FRAME &&
            mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_AUTORAMA)
        {
            ReadValue(NRRAM_CAMCO_BEFORE_SWITCH_CAPSIZE, &original_capsize, DS_BYTE, &error);
            if (original_capsize != mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE))
            {
                capsize = original_capsize;
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
                mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);
                mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width, mmi_camco_cam_p->image_height);
            }
        }
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, mmi_camco_get_last_capmode());
    #ifdef __SMILE_SHUTTER_SUPPORT__
        /* the FD will be off when state switch, the SD mode cannot be maintain or it will cause error when back to camco and capture */
        if (mmi_camco_get_last_capmode() == MMI_CAMCO_CAPMODE_SMILE_SHOT)
        {
            mmi_camco_update_capmode(MMI_CAMCO_CAPMODE_NORMAL);
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);
        }
    #endif /* __SMILE_SHUTTER_SUPPORT__ */ 
        mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_TIMESTAMP);
    }

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ADD_FRAME)
    {
        mmi_camco_osd_set_add_frame_highlighted_idx(0);
        mmi_camco_cam_p->addframe_coloridx_index = 0;
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);

        mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
    }
    mmi_camco_cam_p->is_reset_zoom = MMI_FALSE;
#ifdef DUAL_CAMERA_SUPPORT
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        if (mmi_camco_setting_cam_id_get_setting_value(MMI_CAMCO_SETTING_CAM_SUB, MMI_CAMCO_SETTING_CAPMODE) ==
            MMI_CAMCO_CAPMODE_ADD_FRAME)
        {
            mmi_camco_setting_cam_id_set_setting_value(
                MMI_CAMCO_SETTING_CAM_SUB,
                MMI_CAMCO_SETTING_CAPMODE,
                MMI_CAMCO_CAPMODE_NORMAL);
        }
    }
    else
    {
        if (mmi_camco_setting_cam_id_get_setting_value(MMI_CAMCO_SETTING_CAM_MAIN, MMI_CAMCO_SETTING_CAPMODE) ==
            MMI_CAMCO_CAPMODE_ADD_FRAME)
        {
            mmi_camco_setting_cam_id_set_setting_value(
                MMI_CAMCO_SETTING_CAM_MAIN,
                MMI_CAMCO_SETTING_CAPMODE,
                MMI_CAMCO_CAPMODE_NORMAL);
        }
    }
    mmi_camco_osd_set_add_frame_highlighted_idx(0);
    mmi_camco_cam_p->addframe_coloridx_index = 0;
    mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
#endif /* DUAL_CAMERA_SUPPORT */ 
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 

    if (mmi_camco_setting_is_highlight_on())
    {
        mmi_camco_highlight_turn_off();
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_HIGHLIGHT, MMI_CAMCO_HIGHLIGHT_OFF);
    }
#ifdef __MMI_CAMCO_FEATURE_OSD_IMAGE_SELECT__
    mmi_camco_osd_deinit_image_select_filename_buffer();
    mmi_camco_osd_imageselect_set_cache_layer_buf_p((void*)NULL);
#endif /* __MMI_CAMCO_FEATURE_OSD_IMAGE_SELECT__ */ 
    g_mmi_camco_cntx.is_to_media_editor = MMI_FALSE;

    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT)
    {
        if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_RECORDING ||
            g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PAUSE)
        {
            mmi_camco_rec_p->is_saving_prev = MMI_TRUE;
        }
        else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVING ||
                 g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SAVING)
        {
            mdi_video_rec_stop_save();
            mmi_camco_rec_p->is_saving_prev = MMI_FALSE;
        }

        mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
    }
    else
    {
        if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
        {
        #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
            mmi_camco_osd_set_init_mem(NULL);
            g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);                   
        #endif

            g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
            g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);       
                                        
        #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
            g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
            g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
        #endif                             
            mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);
            g_mmi_camco_cntx.app_mem_buf_p = NULL;
            mmi_camco_cam_p->multishot_mem_pool = NULL;
            mmi_camco_cam_p->cache_mem_pool = NULL;
            mmi_camco_cam_p->cache_layer_pool = NULL;
        }    	
        mmi_camco_osd_set_default();
        mmi_camco_setting_set_default();
        mmi_camco_cam_p->external_request.is_enable = MMI_FALSE;
        mmi_camco_cam_p->external_request.callback = NULL;

        mmi_camco_rec_p->external_request.is_enable = MMI_FALSE;
        mmi_camco_rec_p->external_request.callback = NULL;
        memset(&g_mmi_camco_cntx.partial_app, 0, sizeof(mmi_camco_partial_request_struct));
    }
    /********************************************************************************************/
    /* mmi_camco_osd_set_default will re-change the mdi_camera cam_id after cam has powered off */
    /* Therefore, we need to re-set cam id to main.                                             */
    /********************************************************************************************/
    mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_MAIN);
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    mmi_camco_cam_p->is_switchto_sublcd = MMI_FALSE;
#endif 
    if(!srv_shutdown_is_running())
    {
        mmi_camco_turn_off_lcd_backlight();
    }
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_entry_app_screen_internal
 * DESCRIPTION
 *  entry camcorder application screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_entry_app_screen_internal(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_INTERNAL);
    if (!mmi_camco_is_from_external())
        guiBuffer = mmi_frm_scrn_get_gui_buf(g_mmi_camco_cntx.memory_group_id, SCR_ID_CAMCO_APP);
    else
        guiBuffer = mmi_frm_scrn_get_gui_buf(g_mmi_camco_cntx.memory_group_id, SCR_ID_CAMCO_EXT_APP);

    /* check if there is small screen above camera */

    mmi_camco_cam_set_framework_environment();
    /*
     * Internal switch capability rule:
     *    1. switch capability
     *    2. update only cam capability
     */

    /*
     * External request switch capability rule:
     *    1. init setting pointer
     *    2. default capability without calling update capability
     *    3. switch capability
     *    4. update capability
     */
    if (g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_cam_p->storage = mmi_camco_rec_p->storage;
        mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_CAMERA);
        mmi_camco_setting_switch_capability();
        mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_CAMZOOM);
        mmi_camco_setting_unhide_capability(MMI_CAMCO_SETTING_AFRANGE);
        //mmi_camco_update_flash_capability();
        //mmi_camco_update_iso_capability();
        mmi_camco_update_facedetect_capability();
        //mmi_camco_update_camscenemode_capability();
        mmi_camco_setting_update_capability();
    }

    if (!g_mmi_camco_cntx.is_osd_init)
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);

        /* Initial setting */
        if (!mmi_camco_is_gobackfromhistory() && !g_mmi_camco_cntx.is_to_media_editor)
        {
            mmi_camco_setting_init();
            mmi_camco_setting_load_from_nvram();
            mmi_camco_setting_default_capability();
        }
        else
        {
            mmi_camco_check_storage_capability();
        }

        if (guiBuffer != NULL && g_mmi_camco_cntx.is_to_media_editor && !mmi_camco_cam_p->external_request.is_enable)
        {
            if (!mmi_camco_is_incall())
            {
                g_mmi_camco_cntx.is_to_media_editor = MMI_FALSE;
            }
        }

        if (mmi_camco_is_from_external())
        {
            /* 
             * Switch action have to do before update capability for preventing from 
             * setting value being changed.
             */
            if (mmi_camco_cam_p->external_request.is_switch_app)
            {
                mmi_camco_setting_switch_capability();
                mmi_camco_cam_p->external_request.is_switch_app = MMI_FALSE;
            }
            mmi_camco_setting_update_capability();
            mmi_camco_update_facedetect_capability();

            mmi_camco_set_external_capmode_capability();
            if (!mmi_camco_is_gobackfromhistory())
            {
                U16 capmode = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE);

                if (capmode != MMI_CAMCO_CAPMODE_NORMAL && capmode != MMI_CAMCO_CAPMODE_ADD_FRAME)
                {
                    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);
                #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
                    mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
                #endif 
                    mmi_camco_update_capmode(MMI_CAMCO_CAPMODE_NORMAL);

                    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_OFF);
                    mmi_camco_update_facedetect(MMI_CAMCO_FACEDETECT_OFF);
                }
            }
            
            if(mmi_camco_cam_p->external_request.is_capsize_lcd_limit)
            {
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPSIZE, MMI_CAMCO_CAPSIZE_WALLPAPER);            
                mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAPSIZE);                
            }
            
        #ifdef DUAL_CAMERA_SUPPORT
            mmi_camco_set_external_camswitchto_capability();
        #else 
            mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAMSWITCHTO);
        #endif 
        }

        mmi_camco_osd_init();
    #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)        
        gdi_bltdb_enable(GDI_BLTDB_ENABLE_ONLY_WHEN_HW_UPDATE);    
    #endif
        mmi_camco_osd_setup_environment(g_mmi_camco_cntx.app_mem_buf_p);
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        mmi_camco_osd_set_sublcd_base_layer(g_mmi_camco_cntx.sublcd_base_layer_handle);
    #endif 
        g_mmi_camco_cntx.is_osd_init = MMI_TRUE;
    }

    mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
   // mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE);

    mmi_camco_update_capmode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE));

    mmi_camco_cam_config_preview_layer();

    if (mmi_camco_is_incall())
    {
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL));
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
    #else /* __MMI_CAMCO_FTE__ */ 
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_preview_rsk_released);
        #else
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_preview_rsk_released);
        #endif
    #else 
        mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_preview_rsk_released);
    #endif 
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();

        if (g_mmi_camco_cntx.is_to_media_editor)
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_INT_PREVIEW;
        }
        return;
    }

    /* error handling, reset camera state */
    if (g_mmi_camco_cntx.app_state > MMI_CAMCO_STATE_EXIT &&
        g_mmi_camco_cntx.app_state < MMI_CAMCO_STATE_CAM_INT_PREVIEW)
    {
        if (!g_mmi_camco_cntx.is_switching_app)
        {
            mmi_camco_exit_app();
            return;
        }
    }

    /* Draw OSD first before init camera driver */
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_PREVIEW || g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
        if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {

		#ifdef AF_SUPPORT
		    SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
        #endif

            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
        #ifdef __MMI_CAMCO_EVB_AF_TEST__
		#ifdef AF_SUPPORT
            SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
		#endif

        #endif /* __MMI_CAMCO_EVB_AF_TEST__ */             
            g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
        }
        else
        {
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
        }
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_preview_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();
    }

    if (!g_mmi_camco_cntx.is_power_on)
    {
        if (MDI_RES_CAMERA_SUCCEED == mmi_camco_cam_power_on())
        {
            if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
            }
            else if (g_mmi_camco_cntx.is_switching_app)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
                g_mmi_camco_cntx.is_switching_app = MMI_FALSE;
            }
            else
            {
                mmi_camco_recover_state(g_mmi_camco_cntx.app_state);
            }
        }
        else
        {
            if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT ||
                g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_PREVIEW ||
                (g_mmi_camco_cntx.is_switching_app && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW)||
                (g_mmi_camco_cntx.is_switching_app && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SETTING_MENU)||
                g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SETTING_MENU)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
            }
            else    /* Some int state doesn't need sensor output image, it still can be recoverd */
            {
                mmi_camco_recover_state(g_mmi_camco_cntx.app_state);
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_recover_state
 * DESCRIPTION
 *  recover the original state
 * PARAMETERS
 *  current_state       [IN]        Camcorder state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_recover_state(mmi_camco_state_enum current_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_RECOVER_STATE, current_state);

    switch (current_state)
    {
        case MMI_CAMCO_STATE_CAM_INT_PREVIEW:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
            break;

        case MMI_CAMCO_STATE_CAM_INT_SETTING_MENU:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SETTING_MENU);
            break;

        case MMI_CAMCO_STATE_CAM_INT_SAVE_DONE:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SAVE_DONE);
            break;

        case MMI_CAMCO_STATE_CAM_INT_BURSTSHOT_SELECT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT);
            break;

        case MMI_CAMCO_STATE_CAM_INT_AEBSHOT_SELECT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT);
            break;

        case MMI_CAMCO_STATE_CAM_INT_AUTORAMA_SHOT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT);
            break;

        case MMI_CAMCO_STATE_CAM_INT_AUTORAMA_STITCH:
    #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
            if (mmi_camco_cam_p->autorama_shot.is_stitch_done &&
                mmi_camco_cam_p->autorama_shot.stitch_result == MDI_RES_CAMERA_SUCCEED)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_DONE);
            }
            else if (mmi_camco_cam_p->autorama_shot.is_stitch_done)
            {
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                mmi_camco_osd_set_bg_black();
                mmi_camco_show_error_msg(mmi_camco_cam_p->autorama_shot.stitch_result);
                /* sleep 300 tick for letting users see the saving msg for a while */
                kal_sleep_task(300);

                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);

            #ifdef __MMI_CAMCO_FTE__
                mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
                if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
                {
					#ifdef AF_SUPPORT
						SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
					#endif

                    SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                    SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
                #ifdef __MMI_CAMCO_EVB_AF_TEST__
				#ifdef AF_SUPPORT
					SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
                    SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
				#endif

                #endif /* __MMI_CAMCO_EVB_AF_TEST__ */                     
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
                }
                else
                {
                    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
                }

            #else /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_cam_preview_set_key_hdlr();
            #endif /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_osd_draw_osd();

                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
            }
            else
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
            }
    #endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
            break;

        case MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_DONE);
            break;

        case MMI_CAMCO_STATE_CAM_INT_ADD_FRAME:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_ADD_FRAME);
            break;

        case MMI_CAMCO_STATE_REC_INT_PREVIEW:
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
            break;

        case MMI_CAMCO_STATE_REC_INT_SETTING_MENU:
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SETTING_MENU);
            break;

        case MMI_CAMCO_STATE_REC_INT_SAVING:
            if (mmi_camco_rec_p->is_save_result_back && mmi_camco_rec_p->save_result == MDI_RES_VDOREC_SUCCEED)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVE_DONE);
            }
            else if (mmi_camco_rec_p->is_save_result_back)
            {
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_FAILED_TO_SAVE));
                mmi_camco_osd_draw_osd();
                /* sleep 200 tick for letting users see the saving msg for a while */
                kal_sleep_task(200);

                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);

            #ifdef __MMI_CAMCO_FTE__
                mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
                if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
                {

				    #ifdef AF_SUPPORT
					if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
					{
						SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
					}
				   #endif

                    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
                }
                else
                {
                    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
                }
            #else /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_rec_preview_set_key_hdlr();
            #endif /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_osd_draw_osd();

                mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
            }
            else
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_SAVING;
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
                mmi_camco_osd_draw_osd();

                /* sleep 500 tick for letting users see the saving msg for a while */
                kal_sleep_task(500);
            }
            break;

        case MMI_CAMCO_STATE_REC_INT_SAVE_DONE:
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVE_DONE);
            break;

        case MMI_CAMCO_STATE_REC_INT_SAVING_PREV:
            if (mmi_camco_rec_p->is_saving_prev)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING_PREV);
            }
            else
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
            }
            break;

        #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        case MMI_CAMCO_STATE_CAM_INT_SUB_PREVIEW:
        {
            if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SUB_PREVIEW);
            }
            else
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
            }
            break;
        }
        #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 

        case MMI_CAMCO_STATE_INT_RESTORE_CONFIRM:
            mmi_camco_enter_state(MMI_CAMCO_STATE_RESTORE_CONFIRM);
            break;

        default:
            MMI_ASSERT(0);
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_state
 * DESCRIPTION
 *  enter the next state
 * PARAMETERS
 *  next_state      [IN]        Camcorder state
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_state(mmi_camco_state_enum next_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_ENTER_STATE, g_mmi_camco_cntx.app_state, next_state);

    /* error handling */
    if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        if (next_state > MMI_CAMCO_STATE_CAM_INT_SUB_PREVIEW && !g_mmi_camco_cntx.is_switching_app)
        {
            /* The current app is camera, the state shouldn't belong to the recorder state */
            if (next_state != MMI_CAMCO_STATE_RESTORE_CONFIRM && next_state != MMI_CAMCO_STATE_INT_RESTORE_CONFIRM)
            {
                MMI_ASSERT(0);
            }
        }
    }
    else
    {
        if ((next_state > MMI_CAMCO_STATE_EXIT &&
             next_state < MMI_CAMCO_STATE_REC_PREVIEW) && !g_mmi_camco_cntx.is_switching_app)
        {
            /* The current app is recorder, the state shouldn't belong to the camera state */
            if (next_state != MMI_CAMCO_STATE_RESTORE_CONFIRM && next_state != MMI_CAMCO_STATE_INT_RESTORE_CONFIRM)
            {
                MMI_ASSERT(0);
            }
        }
    }

    ClearKeyHandler(KEY_CAMERA, KEY_HALF_PRESS_UP);
    ClearKeyHandler(KEY_CAMERA, KEY_HALF_PRESS_DOWN);
    ClearKeyHandler(KEY_CAMERA, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_CAMERA, KEY_EVENT_UP);
    if(next_state != MMI_CAMCO_STATE_EXIT ||
       (mmi_frm_scrn_get_active_id() == SCR_GROUP_ID_CAMCO_EXT_APP || mmi_frm_scrn_get_active_id() == SCR_GROUP_ID_CAMCO_INT_APP) )
    {			 
        ClearKeyHandler(KEY_CSK, KEY_EVENT_DOWN);
    }        
    SetKeyHandler(mmi_camco_dummy_func, KEY_CAMERA, KEY_EVENT_REPEAT);
#ifdef __MMI_CAMCO_EVB_AF_TEST__
    ClearKeyHandler(KEY_1, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_2, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_3, KEY_EVENT_DOWN);
#endif /* __MMI_CAMCO_EVB_AF_TEST__ */ 

    if(!srv_shutdown_is_running())
    {    
        mmi_camco_turn_on_lcd_backlight();
    }
    
    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_ADD_FRAME ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT ||
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SUB_PREVIEW ||
#endif 
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_RESTORE_CONFIRM)
    {
        gui_cancel_timer(mmi_camco_preview_terminate_hdlr);
        g_mmi_camco_cntx.preview_timeout_count = 0;
    }
#endif /* __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__ */ 

#ifdef __SMILE_SHUTTER_SUPPORT__
    mmi_camco_cam_smile_detect_stop();
#endif 
    mmi_camco_cam_scene_detect_stop();
    mmi_camco_cam_face_detect_stop();
    if(!g_mmi_camco_cntx.is_preemptable)
    {
        mmi_frm_end_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION); 
        g_mmi_camco_cntx.is_preemptable = MMI_TRUE;
    } 
     if(g_mmi_camco_cntx.is_post_process_pause == MMI_TRUE)
     {
	     mdi_camera_resume_preview_post_process();
		 g_mmi_camco_cntx.is_post_process_pause = MMI_FALSE;
	 }

    if(next_state == MMI_CAMCO_STATE_CAM_SETTING_MENU)
    {
		mdi_camera_pause_preview_post_process();
		g_mmi_camco_cntx.is_post_process_pause = MMI_TRUE;

	}
    /* Enter the next state */
    switch (next_state)
    {
        case MMI_CAMCO_STATE_EXIT:
            mmi_camco_enter_exit_state();
            break;

        case MMI_CAMCO_STATE_CAM_PREVIEW:
            mmi_camco_enter_cam_preview_state();
            break;

        case MMI_CAMCO_STATE_CAM_PREVIEW_FAILED:
            mmi_camco_enter_cam_preview_failed_state();
            break;

        case MMI_CAMCO_STATE_CAM_SETTING_MENU:
            mmi_camco_enter_cam_setting_menu_state();
            break;

        case MMI_CAMCO_STATE_CAM_FOCUSING:
            mmi_camco_enter_cam_focusing_state();
            break;

        case MMI_CAMCO_STATE_CAM_FOCUSED:
            mmi_camco_enter_cam_focused_state();
            break;

        case MMI_CAMCO_STATE_CAM_COUNTDOWN:
            mmi_camco_enter_cam_countdown_state();
            break;

        case MMI_CAMCO_STATE_CAM_CAPTURE:
            mmi_camco_enter_cam_capture_state();
            break;

        case MMI_CAMCO_STATE_CAM_SAVE_DONE:
            mmi_camco_enter_cam_save_done_state();
            break;

        case MMI_CAMCO_STATE_CAM_CONTSHOT:
            mmi_camco_enter_cam_contshot_state();
            break;

    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
        case MMI_CAMCO_STATE_CAM_BURSTSHOT:
            mmi_camco_enter_cam_burstshot_state();
            break;

        case MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT:
            mmi_camco_enter_cam_burstshot_select_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 

    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
        case MMI_CAMCO_STATE_CAM_AEBSHOT:
            mmi_camco_enter_cam_aebshot_state();
            break;

        case MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT:
            mmi_camco_enter_cam_aebshot_select_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 

    #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
        case MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT:
            mmi_camco_enter_cam_autorama_shot_state();
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH:
            mmi_camco_enter_cam_autorama_stitch_state();
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_DONE:
            mmi_camco_enter_cam_autorama_done_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
    #ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
        case MMI_CAMCO_STATE_CAM_MAV_SHOT:
			mmi_camco_enter_cam_mav_shot_state();
			break;

	#endif
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        case MMI_CAMCO_STATE_CAM_SUB_PREVIEW:
            mmi_camco_enter_cam_sub_preview_state();
            break;
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 

    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        case MMI_CAMCO_STATE_CAM_ADD_FRAME:
            mmi_camco_enter_cam_add_frame_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
    #ifdef __SMILE_SHUTTER_SUPPORT__
        case MMI_CAMCO_STATE_CAM_SMILE_DECT:
            mmi_camco_enter_cam_smile_dect_state();
            break;
    #endif /* __SMILE_SHUTTER_SUPPORT__ */ /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */

    #ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
        case MMI_CAMCO_STATE_CAM_HDR_SHOT:
            mmi_camco_enter_cam_hdr_shot_state();
            break;

        case MMI_CAMCO_STATE_CAM_HDR_DONE:
            mmi_camco_enter_cam_hdr_done_state();
            break;            
    #endif
    
        case MMI_CAMCO_STATE_REC_PREVIEW:
            mmi_camco_enter_rec_preview_state();
            break;

        case MMI_CAMCO_STATE_REC_PREVIEW_FAILED:
            mmi_camco_enter_rec_preview_failed_state();
            break;

        case MMI_CAMCO_STATE_REC_SETTING_MENU:
            mmi_camco_enter_rec_setting_menu_state();
            break;

        case MMI_CAMCO_STATE_REC_FOCUSING:
            mmi_camco_enter_rec_focusing_state();
            break;

        case MMI_CAMCO_STATE_REC_FOCUSED:
            mmi_camco_enter_rec_focused_state();
            break;

        case MMI_CAMCO_STATE_REC_RECORDING:
            mmi_camco_enter_rec_recording_state();
            break;

        case MMI_CAMCO_STATE_REC_PAUSE:
            mmi_camco_enter_rec_pause_state();
            break;

        case MMI_CAMCO_STATE_REC_SAVING:
            mmi_camco_enter_rec_saving_state();
            break;

        case MMI_CAMCO_STATE_REC_SAVE_DONE:
            mmi_camco_enter_rec_save_done_state();
            break;

        case MMI_CAMCO_STATE_REC_SAVING_PREV:
            mmi_camco_enter_rec_saving_prev_state();
            break;

        case MMI_CAMCO_STATE_RESTORE_CONFIRM:
            mmi_camco_enter_restore_confirm_state();
            break;

        default:
            MMI_ASSERT(0);
            break;

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_exit_state
 * DESCRIPTION
 *  enter camera exit state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_exit_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_capsize_enum capsize;
    mmi_camco_capsize_enum original_capsize = MMI_CAMCO_CAPSIZE_WALLPAPER;
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_exit_current_state();

#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_SHOT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_STITCH)
    {
        mmi_camco_cam_reset_autorama_3a();
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_ADD_FRAME ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_ADD_FRAME)
    {
        /***************************************************************************/
        /* Restore the previous capture to recover the previous capsize capability */
        /* Need to do this before changing the capsize to the previous capsize     */
        /***************************************************************************/
        mmi_camco_update_capmode(mmi_camco_get_last_capmode());
        if (mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_ADD_FRAME &&
            mmi_camco_get_last_capmode() != MMI_CAMCO_CAPMODE_AUTORAMA)
        {
            ReadValue(NRRAM_CAMCO_BEFORE_SWITCH_CAPSIZE, &original_capsize, DS_BYTE, &error);
            if (original_capsize != mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE))
            {
                capsize = original_capsize;
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
                mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);
                mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width, mmi_camco_cam_p->image_height);
            }
        }
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, mmi_camco_get_last_capmode());

        /* because FD will be OFF when state switch, the SSD cannot be hold when back again */
        /* or the capmode wont be update and open FD when back again and will cause error */
    #ifdef __SMILE_SHUTTER_SUPPORT__
        if (mmi_camco_get_last_capmode() == MMI_CAMCO_CAPMODE_SMILE_SHOT)
        {
            mmi_camco_update_capmode(MMI_CAMCO_CAPMODE_NORMAL);
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);
        }
    #endif /* __SMILE_SHUTTER_SUPPORT__ */ 
        mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_TIMESTAMP);
    }
	mmi_camco_set_last_capmode((mmi_camco_capmode_enum)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE));
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ADD_FRAME &&
        !g_mmi_camco_cntx.is_to_media_editor)
    {
        mmi_camco_osd_set_add_frame_highlighted_idx(0);
        mmi_camco_cam_p->addframe_coloridx_index = 0;
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);

        mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
    }
    mmi_camco_cam_p->is_reset_zoom = MMI_FALSE;
#ifdef DUAL_CAMERA_SUPPORT
    if (!g_mmi_camco_cntx.is_to_media_editor)
    {
        if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
        {
            if (mmi_camco_setting_cam_id_get_setting_value(MMI_CAMCO_SETTING_CAM_SUB, MMI_CAMCO_SETTING_CAPMODE) ==
                MMI_CAMCO_CAPMODE_ADD_FRAME)
            {
                mmi_camco_setting_cam_id_set_setting_value(
                    MMI_CAMCO_SETTING_CAM_SUB,
                    MMI_CAMCO_SETTING_CAPMODE,
                    MMI_CAMCO_CAPMODE_NORMAL);
            }
        }
        else
        {
            if (mmi_camco_setting_cam_id_get_setting_value(MMI_CAMCO_SETTING_CAM_MAIN, MMI_CAMCO_SETTING_CAPMODE) ==
                MMI_CAMCO_CAPMODE_ADD_FRAME)
            {
                mmi_camco_setting_cam_id_set_setting_value(
                    MMI_CAMCO_SETTING_CAM_MAIN,
                    MMI_CAMCO_SETTING_CAPMODE,
                    MMI_CAMCO_CAPMODE_NORMAL);
            }
        }
        mmi_camco_osd_set_add_frame_highlighted_idx(0);
        mmi_camco_cam_p->addframe_coloridx_index = 0;
        mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
    }
#endif /* DUAL_CAMERA_SUPPORT */ 
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 

    if (mmi_camco_setting_is_highlight_on() && !g_mmi_camco_cntx.is_to_media_editor)
    {
        mmi_camco_highlight_turn_off();
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_HIGHLIGHT, MMI_CAMCO_HIGHLIGHT_OFF);
    }

#ifdef __MMI_CAMCO_FEATURE_OSD_IMAGE_SELECT__
    mmi_camco_osd_deinit_image_select_filename_buffer();
    mmi_camco_osd_imageselect_set_cache_layer_buf_p((void*)NULL);
#endif /* __MMI_CAMCO_FEATURE_OSD_IMAGE_SELECT__ */ 

    if (!g_mmi_camco_cntx.is_to_media_editor)
    {
        mmi_camco_osd_set_default();
        mmi_camco_setting_set_default();
    }
    /* free camera app memory */
    if (g_mmi_camco_cntx.app_mem_buf_p != NULL)
    {
    #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
        mmi_camco_osd_set_init_mem(NULL);
        g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);  	    	
    #endif

        g_mmi_camco_cntx.app_preview_mem_buf_p = NULL;
        g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);                               
        
    #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
        g_mmi_camco_cntx.app_med_mem_buf_p = NULL;
        g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p - MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
    #endif          
        //applib_mem_ap_free((void*)g_mmi_camco_cntx.app_mem_buf_p);
        //mmi_frm_asm_free_r(APP_CAMCO,(void*)g_mmi_camco_cntx.app_mem_buf_p);
        mmi_frm_asm_free_r(g_mmi_camco_cntx.memory_group_id,(void*)g_mmi_camco_cntx.app_mem_buf_p);
        g_mmi_camco_cntx.app_mem_buf_p = NULL;
        mmi_camco_cam_p->multishot_mem_pool = NULL;
        mmi_camco_cam_p->cache_mem_pool = NULL;
        mmi_camco_cam_p->cache_layer_pool = NULL;
    }

    /* for External Request */
    if (!g_mmi_camco_cntx.is_to_media_editor)
    {
        mmi_camco_cam_p->external_request.is_enable = MMI_FALSE;
        mmi_camco_cam_p->external_request.callback = NULL;

        mmi_camco_rec_p->external_request.is_enable = MMI_FALSE;
        mmi_camco_rec_p->external_request.callback = NULL;
        memset(&g_mmi_camco_cntx.partial_app, 0, sizeof(mmi_camco_partial_request_struct));
    }

    if (mmi_camco_cam_p->storage_filepath_p != NULL)
    {
        gui_free(mmi_camco_cam_p->storage_filepath_p);
        mmi_camco_cam_p->storage_filepath_p = NULL;
    }
    if (mmi_camco_cam_p->buf_filename_p != NULL)
    {
        gui_free(mmi_camco_cam_p->buf_filename_p);
        mmi_camco_cam_p->buf_filename_p = NULL;
    }

    if (mmi_camco_rec_p->storage_filepath_p != NULL)
    {
        gui_free(mmi_camco_rec_p->storage_filepath_p);
        mmi_camco_rec_p->storage_filepath_p = NULL;
    }
    if (mmi_camco_rec_p->buf_filename_p != NULL)
    {
        gui_free(mmi_camco_rec_p->buf_filename_p);
        mmi_camco_rec_p->buf_filename_p = NULL;

    }

#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    mmi_camco_cam_p->is_switchto_sublcd = MMI_FALSE;
#endif 
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_EXIT;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_preview_state
 * DESCRIPTION
 *  enter camera preview state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_preview_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
	/*disable and close color engine for quickview image when in preview state*/
	if(g_mmi_camco_cntx.is_color_engine_enable)
	{
		mdi_camera_color_engine_disable();
		mdi_camera_color_engine_close();
		g_mmi_camco_cntx.is_color_engine_enable = MMI_FALSE;
	}
     
    if (!g_mmi_camco_cntx.is_preview_start || g_mmi_camco_cntx.is_restart_preview)
    {

        if (g_mmi_camco_cntx.is_restart_preview)
        {
            mmi_camco_cam_face_detect_stop();
            mmi_camco_cam_scene_detect_stop();
            mmi_camco_cam_preview_stop();
			mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
			mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle); 

            mmi_camco_osd_set_bg_black();

            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
            if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {
            
            #ifdef AF_SUPPORT
			    SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
			#endif

                SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
            #ifdef __MMI_CAMCO_EVB_AF_TEST__
			#ifdef AF_SUPPORT
				SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
                SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
			#endif

            #endif /* __MMI_CAMCO_EVB_AF_TEST__ */                 
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
            }
            else
            {
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
            }
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_preview_set_key_hdlr();
        #endif /* __MMI_CAMCO_FTE__ */ 

            mmi_camco_osd_draw_osd();
        #ifndef __MTK_TARGET__
            kal_sleep_task(500);
        #endif 

        }
        else
        {
            mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
			mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle); 
            mmi_camco_osd_set_bg_black();
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
            if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {
            
            #ifdef AF_SUPPORT
			    SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
			#endif

                SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
            #ifdef __MMI_CAMCO_EVB_AF_TEST__
			#ifdef AF_SUPPORT
				SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
                SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
			#endif

            #endif /* __MMI_CAMCO_EVB_AF_TEST__ */                 
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
            }
            else
            {
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
            }

        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_preview_set_key_hdlr();
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
		mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
		mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);  

        if (TRUE == mmi_camco_cam_preview_start())
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_PREVIEW;
            g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
            g_mmi_camco_cntx.is_restart_preview = MMI_FALSE;

            if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);
            }
            else if (g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
            { 
                U16 drv_enum;             
                
                g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
                mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                
                mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_CARD_AND_NO_CARD);
                mmi_camco_error_hdlr_timer_start(); 
                return;                            
            }
			else if (g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
            {    
            
			    U16 drv_enum;			  
                g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
                mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
				mmi_camco_check_storage_capability();
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                    
                mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_OTG_AND_NO_OTG);
                mmi_camco_error_hdlr_timer_start(); 
                return;                            
            }            
            else
            {
                if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE &&
                    !mmi_camco_cam_p->is_drive_available)
                {
                    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);
                }
                else
                {
                    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                }
                g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            }

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
            if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {
            
            #ifdef AF_SUPPORT
				SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
			#endif

                SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
            #ifdef __MMI_CAMCO_EVB_AF_TEST__

			#ifdef AF_SUPPORT
				SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
            #endif

            #endif /* __MMI_CAMCO_EVB_AF_TEST__ */                 
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
            }
            else if (mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
            {
                if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
                {
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_STORAGE_SELECTION);                            
                }
                if(mmi_camco_get_storage_count() == 0) 
                {         
                    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                }                
                else
                {                
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                }                
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
            }
            else
            {
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;            
            }
        #else /* __MMI_CAMCO_FTE__ */ 
            if (((mmi_camco_cam_p->err_str_id != STR_ID_CAMCO_MEM_CARD_INSERT)&&
				(mmi_camco_cam_p->err_str_id != STR_ID_CAMCO_OTG_INSERT)) ||
				mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {        
                mmi_camco_cam_preview_set_key_hdlr();
            }
            else
            { 
                if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
                {
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_STORAGE_SELECTION);  
                    mmi_camco_cam_preview_no_card_set_key_hdlr();                        
                }
                if(mmi_camco_get_storage_count() == 0) 
                {         
                    mmi_camco_cam_preview_failed_set_key_hdlr();
                }                 
                else if(mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
                {                
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                    mmi_camco_cam_preview_no_card_set_key_hdlr();                        
                }else if(mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
                {
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_OTG_REMOVED_USE_PHONE));                             
                    mmi_camco_cam_preview_no_card_set_key_hdlr();  
				}     
        
            }
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();

        #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 
        }
        else
        {
            g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
            mmi_camco_enter_cam_preview_failed_state();
        }
    }
    else
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_PREVIEW;
        if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);
        }
        else if (g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
        { 
            U16 drv_enum;             
            
            g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
            do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
            mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
            
            mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_CARD_AND_NO_CARD);
            mmi_camco_error_hdlr_timer_start(); 
            return;                            
        }
		else if (g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
        {       
        
		    U16 drv_enum;			  
            g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
            do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
            mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
            mmi_camco_check_storage_capability();
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                    
            mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_OTG_AND_NO_OTG);
            mmi_camco_error_hdlr_timer_start(); 
            return;                            
        }
        else if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE &&
                 !mmi_camco_cam_p->is_drive_available)
        {
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);
            g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_MEM_CARD_INSERT));
        }
        else
        {
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
        }

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_evt_hdlr);
        if ( mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {
            #ifdef AF_SUPPORT
				SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
            #endif

            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
        #ifdef __MMI_CAMCO_EVB_AF_TEST__
		#ifdef AF_SUPPORT
			SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);

		#endif

        #endif /* __MMI_CAMCO_EVB_AF_TEST__ */             
            g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
        }
        else if(mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
        {
            if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
            {
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_STORAGE_SELECTION);                            
            }
            if(mmi_camco_get_storage_count() == 0) 
            {         
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
            }             
            else
            {                
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
		    }     
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
        }
        else
        {
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;        
        }
    #else /* __MMI_CAMCO_FTE__ */ 
        if ((mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE||
			mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_OTG_TYPE) &&
            !mmi_camco_cam_p->is_drive_available)
        {     
            if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
            {
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_STORAGE_SELECTION);                            
                mmi_camco_cam_preview_no_card_set_key_hdlr();                     
            }  
            if(mmi_camco_get_storage_count() == 0) 
            {         
                mmi_camco_cam_preview_failed_set_key_hdlr();
            }                    
            else if(mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
            {                
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                mmi_camco_cam_preview_no_card_set_key_hdlr(); 
             
			}else if(mmi_camco_cam_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
            {
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_OTG_REMOVED_USE_PHONE));                             
                mmi_camco_cam_preview_no_card_set_key_hdlr();                     
            }            
           
        }
        else
        { 
            mmi_camco_cam_preview_set_key_hdlr();
        }
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();
    }

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW)
    {
        mmi_camco_cam_p->is_takepic_failed = MMI_FALSE;
        mmi_camco_cam_p->is_burstshot_finish = MMI_FALSE;
        mmi_camco_cam_p->is_switchto_imgviewer = MMI_FALSE;
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        mmi_camco_cam_p->is_switchto_sublcd = MMI_FALSE;
    #endif 

    #ifdef __SMILE_SHUTTER_SUPPORT__
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_SMILE_SHOT)
        {
            mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_FACEDETECT);
        }
    #endif /* __SMILE_SHUTTER_SUPPORT__ */ 

        // during autorama shot, it may storage change and no popup, so update it
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_AUTORAMA)
        {
            mmi_camco_check_storage_capability();
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
        }    


        if (mmi_camco_cam_p->is_storage_change && mmi_camco_cam_p->is_drive_available)
        {
            mmi_camco_cam_check_filename();
            mmi_camco_cam_p->is_storage_change = MMI_FALSE;
        }
    #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
        gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
    #endif 
        kal_get_time(&mmi_camco_cam_p->preview_start_ticks);

        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_ON)
        {
            mmi_camco_cam_face_detect_start();
        }

        if (mmi_camco_setting_is_highlight_on())
        {
            mmi_camco_highlight_turn_on();
        }
        else
        {
            mmi_camco_highlight_turn_off();            
        }            
        if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ASD_SHOT)
        {
            mmi_camco_cam_scene_detect_start();
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_preview_failed_state
 * DESCRIPTION
 *  enter camera preview failed state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_preview_failed_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
  
    /* OSD draw "Preview Failed" */
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_PREVIEW_FAILED;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_PREVIEW_FAILED));

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_preview_failed_evt_hdlr);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_UP);  
#else 
    mmi_camco_cam_preview_failed_set_key_hdlr();  
#endif 
    mmi_camco_osd_draw_osd();

#ifdef __MMI_SUBLCD__
    /* draw sublcd icon */
    mmi_camco_sublcd_draw_icon();
#endif /* __MMI_SUBLCD__ */ 
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    mmi_camco_cam_p->is_switchto_sublcd = MMI_FALSE;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_setting_menu_state
 * DESCRIPTION
 *  enter camera setting menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_setting_menu_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 cur_mainlist_setting = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
     
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_RESTORE_CONFIRM)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_SETTING_MENU;

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_SETTING);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_setting_menu_evt_hdlr);
    #else 
        mmi_camco_cam_setting_menu_set_key_hdlr();
    #endif 
        mmi_camco_osd_draw_osd();

    #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
        gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
    #endif 
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SETTING_MENU)
    {
        mmi_camco_osd_set_setting_menulist_interrupt(MMI_TRUE);
    #ifdef __MMI_CAMCO_FTE__        
        mmi_camco_update_storage_capability();
    #endif
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_SETTING);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_setting_menu_evt_hdlr);
    #else 
        mmi_camco_cam_setting_menu_set_key_hdlr();
    #endif 
        mmi_camco_osd_draw_osd();

        cur_mainlist_setting = mmi_camco_setting_get_mainlist_setting();
        if (cur_mainlist_setting == MMI_CAMCO_SETTING_EFFECT ||
            cur_mainlist_setting == MMI_CAMCO_SETTING_WB ||
            cur_mainlist_setting == MMI_CAMCO_SETTING_SHARPNESS ||
            cur_mainlist_setting == MMI_CAMCO_SETTING_CONTRAST || cur_mainlist_setting == MMI_CAMCO_SETTING_SATURATION)
        {
            mmi_camco_setting_set_current_setting_hilite((mmi_camco_setting_enum)cur_mainlist_setting, MMI_TRUE);
        }

        if (TRUE == mmi_camco_cam_preview_start())
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_SETTING_MENU;
            g_mmi_camco_cntx.is_preview_start = MMI_TRUE;

            mmi_camco_osd_set_setting_menulist_interrupt(MMI_TRUE);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_SETTING);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_setting_menu_evt_hdlr);
        #else 
            mmi_camco_cam_setting_menu_set_key_hdlr();
        #endif 
            mmi_camco_osd_draw_osd();

        #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
            gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
        #endif 
        }
        else
        {
            g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
            mmi_camco_enter_cam_preview_failed_state();
        }

        if (mmi_camco_setting_is_highlight_on())
        {
            mmi_camco_highlight_turn_on();
        }
        else
        {
            mmi_camco_highlight_turn_off();            
        }  
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_add_frame_state
 * DESCRIPTION
 *  enter camera add frame state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_enter_cam_add_frame_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
     
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_ADD_FRAME)
    {
        BOOL ret = TRUE;

        mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
        if (!g_mmi_camco_cntx.is_preview_start)
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_ADD_FRAME_SELECTION);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_add_frame_evt_hdlr);
        #else 
            mmi_camco_cam_add_frame_set_key_hdlr();
        #endif 
            mmi_camco_osd_draw_osd();
            ret = mmi_camco_cam_preview_start();
        }

        if (ret == TRUE)
        {
            g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_ADD_FRAME;

            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_ADD_FRAME_SELECTION);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_add_frame_evt_hdlr);
        #else 
            mmi_camco_cam_add_frame_set_key_hdlr();
        #endif 
            mmi_camco_osd_draw_osd();
        #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
            gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
        #endif 
        }
        else
        {
            mmi_camco_enter_cam_preview_failed_state();
        }
    }
}
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_focusing_state
 * DESCRIPTION
 *  enter camera focusing state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_focusing_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #ifdef AF_SUPPORT
	    U8 idx;
        U16 region_idx;
        U16 w, h;
        U16 center_x, center_y;
        U32 af_active_zone = 0;
        S32 af_zone_count = 0;
    #endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW);

    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_FOCUSING;

    mmi_camco_cam_autofocus_start();
    
    mdi_camera_get_focus_zone(&mmi_camco_cam_p->af_zone);
    
    g_mmi_camco_cntx.is_autofocus_success = MMI_FALSE;

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_FOCUSE);

#ifdef AF_SUPPORT
    af_active_zone = mmi_camco_cam_p->af_zone.af_active_zone;

    for (idx = MMI_CAMCO_OSD_FOCUS_REGION_1; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
    {
        af_zone_count += af_active_zone & 0x00000001;
        af_active_zone = af_active_zone >> 1;
    }

    MMI_ASSERT(af_zone_count <= MMI_CAMCO_OSD_FOCUS_REGION_END);
    mmi_camco_cam_p->af_zone_count = af_zone_count;

    af_active_zone = mmi_camco_cam_p->af_zone.af_active_zone;
    for (idx = MMI_CAMCO_OSD_FOCUS_REGION_1; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
    {
        if (af_active_zone & 0x00000001)
        {
            region_idx = MMI_CAMCO_OSD_FOCUS_REGION_1 + idx;

            w = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_w;
            h = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_h;
            center_x = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
            center_y = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;

            mmi_camco_osd_set_focus((mmi_camco_osd_focus_region_enum)region_idx, MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSING, center_x, center_y, w, h);
        }
        af_active_zone = af_active_zone >> 1;
    }
#endif 
    mmi_camco_cam_focus_set_key_hdlr();

    mmi_camco_osd_draw_osd();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_focused_state
 * DESCRIPTION
 *  enter camera focused state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_focused_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 is_success = 0x00;
    U8 idx;
    U16 region_idx;
    U16 w, h;
    U16 center_x, center_y;
    U32 af_success_zone = 0;
    U32 af_active_zone = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSING);

    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_FOCUSED;

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_FOCUSE);

    g_mmi_camco_cntx.is_autofocus_success = MMI_TRUE;

    af_active_zone = mmi_camco_cam_p->af_zone.af_active_zone;
    af_success_zone = mmi_camco_cam_p->af_result.af_success_zone;

    for (idx = 0; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
    {
        region_idx = MMI_CAMCO_OSD_FOCUS_REGION_1 + idx;

        is_success = af_success_zone & 0x00000001;

        if (is_success)
        {
            w = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_w;
            h = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_h;
            center_x = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
            center_y = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;

            mmi_camco_osd_set_focus((mmi_camco_osd_focus_region_enum)region_idx, MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSED, center_x, center_y, w, h);
        }
        else if (af_active_zone & 0x00000001)
        {
            w = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_w;
            h = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_h;
            center_x = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
            center_y = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;
            mmi_camco_osd_set_focus((mmi_camco_osd_focus_region_enum)region_idx, MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSING, center_x, center_y, w, h);
        }

        af_success_zone = af_success_zone >> 1;
        af_active_zone = af_active_zone >> 1;
    }
    mmi_camco_cam_focus_set_key_hdlr();

    mmi_camco_osd_draw_osd();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_countdown_state
 * DESCRIPTION
 *  enter camera countdown state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_countdown_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_COUNTDOWN;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_countdown_evt_hdlr);
#else 
    mmi_camco_cam_countdown_set_key_hdlr();
#endif 
    mmi_camco_osd_draw_osd();

    mmi_camco_init_countdown_mma();

    kal_get_time(&g_mmi_camco_cntx.start_ticks);

    mmi_camco_cam_countdown_cyclic();

}
#ifdef __CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ 
static U8 mmi_camco_get_capture_value()
{
    mmi_camco_cam_p->capture_rotate = g_mmi_camco_cntx.rotate;
    return mmi_camco_cam_p->capture_rotate;
}
extern U8 mmi_camco_get_capture_rotate_value(void)
{
	return mmi_camco_cam_p->capture_rotate;

}
#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_capture_state
 * DESCRIPTION
 *  enter camera capture state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_capture_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    mmi_camco_capmode_enum capmode;

#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    MMI_BOOL is_sublcd_capture = MMI_FALSE;
#endif 
#ifdef __MMI_INTERACTIVE_PROFILNG__
    U32 tempticks;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* According to the capture mode, call the corresponding function */
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW ||
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SUB_PREVIEW ||
#endif 
#ifdef __SMILE_SHUTTER_SUPPORT__
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SMILE_DECT ||
#endif 
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSING ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSED ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_COUNTDOWN)
    {

    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SUB_PREVIEW)
        {
            capmode = MMI_CAMCO_CAPMODE_NORMAL;
            is_sublcd_capture = MMI_TRUE;
        }
        else
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
        {
            capmode =(mmi_camco_capmode_enum) mmi_camco_get_capmode();
        }

        mdi_camera_pause_preview_post_process();


        memset(mmi_camco_cam_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);
        mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);

    #ifdef __MMI_INTERACTIVE_PROFILNG__
        if (mmi_frm_profiling_interactive_is_enabled())
        {
            kal_get_time(&tempticks);
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_PRE_DUR, (U32) ((tempticks - start_ticks) * 4.615));
        }
    #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

        MMI_CAMCO_STOP_LOGGING("PRE");

        if (capmode == MMI_CAMCO_CAPMODE_NORMAL
    #ifdef __SMILE_SHUTTER_SUPPORT__
            || capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT
    #endif 
            || capmode == MMI_CAMCO_CAPMODE_ZSD_SHOT
            || capmode == MMI_CAMCO_CAPMODE_ASD_SHOT
            )
        {
            MMI_CAMCO_START_LOGGING("NOS");
            ret = mmi_camco_cam_normal_shot();
            MMI_CAMCO_STOP_LOGGING("NOS");
        }
    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        else if (capmode == MMI_CAMCO_CAPMODE_ADD_FRAME)
        {
            MMI_CAMCO_START_LOGGING("AFS");
            ret = mmi_camco_cam_addframe_shot();
            MMI_CAMCO_STOP_LOGGING("AFS");
        }
    #endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
        else
        {
            MMI_CAMCO_START_LOGGING("BSS");
            ret = mmi_camco_cam_bestshot();
            MMI_CAMCO_STOP_LOGGING("BSS");
        }
        if (ret == MDI_RES_CAMERA_SUCCEED)
            mmi_camco_cam_play_shuttersound(mmi_camco_get_shuttersound());
            mdi_camera_resume_preview_post_process();

        // quick will be layer buffer, just trans base layer, no need to clean bufer
         if (capmode == MMI_CAMCO_CAPMODE_BEST_SHOT)
        {      
            mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);	
			mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);	
        }
		else
		{
			g_mmi_camco_cntx.is_priview_layer_active = MMI_FALSE;
			g_mmi_camco_cntx.base_layer_handle = g_mmi_camco_cntx.non_preview_base_layer_handle;
			mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);	
			mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.non_preview_base_layer_handle);
			mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.preview_base_layer_handle); 

		}
	#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ 	
   		if(is_sublcd_capture)
		mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.sublcd_base_layer_handle);
    #endif    
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
		/*open and enable color engine for quickview image*/
		if(!g_mmi_camco_cntx.is_color_engine_enable)
		{
			mdi_camera_color_engine_open();
			mdi_camera_color_engine_enable();
			g_mmi_camco_cntx.is_color_engine_enable = MMI_TRUE;
		}

        /* when capture fail, always clean screen */
        if(ret != MDI_RES_CAMERA_SUCCEED)
        {
            mmi_camco_osd_set_bg_black();          
        }  

        // best shot not provide quick view now, go old decode path to show image, so clean black here

        mmi_camco_osd_draw_osd();    
        g_mmi_camco_cntx.is_preview_start = MMI_FALSE;

        if (mmi_camco_cam_p->external_request.is_enable)
        {
            CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];

            memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);
            mmi_ucs2cpy(g_mmi_camco_ext_calling_save_file, mmi_camco_cam_p->buf_filename_p);

            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_CAPTURE;

            if (ret == MDI_RES_CAMERA_SUCCEED)
            {
                ret = mmi_camco_cam_save_capture_image();
            }

            if (ret == MDI_RES_CAMERA_SUCCEED)
            {
                cui_camera_event_struct evt;

                MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
                evt.evt_id = CUI_CAMERA_EVENT_RESULT_SUCCESS;
                /* evt.file_path = ucs2_filename; */
                /* temp return camco path */
                /* need to provide a metehod to AP for get non-local path */
                /* camera cui also need to provide the same interface */
                evt.file_path = g_mmi_camco_ext_calling_save_file;
                mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
            }
            else
            {
                /* when capture fail, always clean screen */

                mmi_camco_osd_set_bg_black();                     
                if (!(mmi_camco_is_incall() &&
                      !(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CSD_CALL_TYPE_ALL, NULL) > 0)) &&
                    !(srv_reminder_is_expiring()))
                {
                    mmi_camco_show_error_msg(ret);
                    kal_sleep_task(500);
                }

                {
                    cui_camera_event_struct evt;

                    MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
                    evt.evt_id = CUI_CAMERA_EVENT_RESULT_FAILED;
                    /* evt.file_path = ucs2_filename; */
                    /* temp return camco path */
                    /* need to provide a metehod to AP for get non-local path */
                    /* camera cui also need to provide the same interface */
                    evt.file_path = NULL;
                    mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
                }
                mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;
                mmi_camco_cam_restore_filename_seq_no();
            }

            if (!((srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0) &&
                  !(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CSD_CALL_TYPE_ALL, NULL) > 0)) &&
                !(srv_reminder_is_expiring()))
            {
                /* Return to previous application which asks the requst */
                return;
            }
        }
        else
        {
            if (ret == MDI_RES_CAMERA_SUCCEED)
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_CAPTURE;
            #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
                if (is_sublcd_capture)
                {
                    mmi_camco_osd_set_sublcd_bg_black();
                #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
                    mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
                #endif 

                    mmi_camco_cam_get_preview_window(MMI_CAMCO_CAM_PREVIEW_MAINLCD);

                    if (capmode == MMI_CAMCO_CAPMODE_BEST_SHOT)
                        mmi_camco_cam_draw_capture_img_from_memory();

                    mmi_camco_osd_draw_osd();

                    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
                    mmi_camco_osd_draw_osd();

                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_SUBLCD_CAMERA_STOP_HINT);
                    mmi_camco_sublcd_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
                    mmi_camco_osd_draw_osd();

                #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 
                #ifndef __MTK_TARGET__
                    /* sleep 500 tick for MoDIS, to mimic capture latency */
                    kal_sleep_task(500);
                #endif /* __MTK_TARGET__ */ 
                    mmi_camco_sublcd_draw_icon();
                }
                else
            #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
                {
                #ifdef __MMI_INTERACTIVE_PROFILNG__
                    CHAR log[50];
                    CHAR str[50];
                #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
                
                    if (capmode == MMI_CAMCO_CAPMODE_BEST_SHOT)
                        mmi_camco_cam_draw_capture_img_from_memory();

                    mmi_camco_osd_draw_osd();

                #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

                    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
                    mmi_camco_osd_draw_osd();
                    
                #ifdef __MMI_INTERACTIVE_PROFILNG__
                    if (mmi_frm_profiling_interactive_is_enabled())
                    {
                        memset(log, 0, sizeof(log));
                        memset(str, 0, sizeof(str));
                        kal_get_time(&end_ticks);
                        tick_elapsed = (end_ticks - start_ticks);
                        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */

                        sprintf(log, "%.3f ms", tick_elapsed);
                        mmi_asc_to_ucs2((CHAR*) str, (CHAR*) log);
                        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
                        gui_move_text_cursor(0, 100);
                        gui_set_text_color(gui_color(255, 0, 0));
                        gui_set_text_border_color(gui_color(255, 255, 255));
                        gui_print_bordered_text((UI_string_type) str);
                        gdi_layer_pop_and_restore_active();
                        mmi_camco_osd_draw_osd();
                        kal_get_time(&tempticks);
                        start_ticks += (tempticks - end_ticks);
                    }
                #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

                #ifndef __MTK_TARGET__
                    /* sleep 500 tick for MoDIS, to mimic capture latency */
                    kal_sleep_task(500);
                #endif /* __MTK_TARGET__ */ 

                }
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SAVE_DONE);
            }
            else
            {
                /*
                 * Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or MMI_CAMCO_STATE_CAM_FOCUSING or 
                 * MMI_CAMCO_STATE_CAM_FOCUSED or MMI_CAMCO_STATE_CAM_COUNTDOWN or 
                 * MMI_CAMCO_STATE_CAM_SUB_PREVIEW
                 */

                mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;
            #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
                mmi_camco_cam_p->is_sublcd_capture = MMI_FALSE;

                if (is_sublcd_capture)
                {
                    mmi_camco_osd_set_sublcd_bg_black();
                    mmi_camco_osd_set_bg_black();
                    mmi_camco_sublcd_draw_icon();
                }
            #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
                mmi_camco_show_error_msg(ret);
                mmi_camco_cam_restore_filename_seq_no();

                mmi_camco_error_hdlr_timer_start();

                mmi_camco_osd_draw_osd();
            #if 0
/* under construction !*/
            #endif /* 0 */ 
            }
        }

        mmi_camco_highlight_turn_off();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_save_done_state
 * DESCRIPTION
 *  enter camera save done state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_save_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 result;
    S32 offset_x;
    S32 offset_y;
    S32 resized_offset_x;
    S32 resized_offset_y;
    S32 resized_width;
    S32 resized_height;
	S32 quickview_width;
	S32 quickview_height;
    mmi_camco_state_enum prev_state;
    MDI_RESULT ret;
    U8* temp_ptr; 
	GDI_HANDLE temp_layer_handlr;
#ifdef __MMI_INTERACTIVE_PROFILNG__
    U32 tempticks;
    CHAR log[50];
    CHAR str[50];
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SAVE_DONE)
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
    }

    prev_state = g_mmi_camco_cntx.app_state;
    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_FALSE);
#endif 
	/*open and enable color engine for quickview image*/
	if(!g_mmi_camco_cntx.is_color_engine_enable && prev_state != MMI_CAMCO_STATE_CAM_MAV_SHOT)
	{
		mdi_camera_color_engine_open();
		mdi_camera_color_engine_enable();
		g_mmi_camco_cntx.is_color_engine_enable = MMI_TRUE;
	}
    if (prev_state == MMI_CAMCO_STATE_CAM_INT_SAVE_DONE || prev_state == MMI_CAMCO_STATE_CAM_MAV_SHOT)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_SAVE_DONE;
    }

    if (prev_state != MMI_CAMCO_STATE_CAM_INT_SAVE_DONE)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }

    if (prev_state == MMI_CAMCO_STATE_CAM_INT_SAVE_DONE && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
    }
    else if (prev_state == MMI_CAMCO_STATE_CAM_CAPTURE)
    {
        if ((mmi_camco_capmode_enum)mmi_camco_get_capmode() == MMI_CAMCO_CAPMODE_BEST_SHOT)
        {
            ret = mmi_camco_cam_save_image(
                    mmi_camco_cam_p->buf_filename_p,
                    mmi_camco_cam_p->capture_buf_ptr,
                    mmi_camco_cam_p->capture_size);
        }
        else
        {
            ret = mmi_camco_cam_save_capture_image();
        }

    #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

        if (ret == MDI_RES_CAMERA_SUCCEED)
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_SAVE_DONE;
            mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                              (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));

        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_cam_save_done_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_save_done_lsk_released(KEY_EVENT_UP);
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_save_done_evt_hdlr);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
        else
        {
            // capture sound may still play
            kal_sleep_task(200);
            mmi_camco_cam_restore_filename_seq_no();

            mmi_camco_show_error_msg(ret);
            mmi_camco_error_hdlr_timer_start();
            return;
        }
    }
    else if ((prev_state == MMI_CAMCO_STATE_CAM_INT_SAVE_DONE && mmi_camco_cam_p->is_drive_available) ||prev_state == MMI_CAMCO_STATE_CAM_MAV_SHOT)
    {
        mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                          (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));

        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_clear_background(GDI_COLOR_BLACK);

    #ifdef __MTK_TARGET__
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        if (mmi_camco_cam_p->is_sublcd_capture)
        {
            mmi_camco_cam_get_preview_window(MMI_CAMCO_CAM_PREVIEW_MAINLCD);
        }
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 

        MMI_CAMCO_START_LOGGING("DEC");

        /* show the capture image */
        result = gdi_image_jpeg_get_dimension_no_rotate(mmi_camco_cam_p->buf_filename_p,0, &image_width, &image_height);
        quickview_width = g_mmi_camco_cntx.quickview_wnd.width;
		quickview_height = g_mmi_camco_cntx.quickview_wnd.height;
		#ifdef HORIZONTAL_CAMERA
	    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	    {
			temp_ptr = mmi_camco_osd_get_init_mem();
	        gdi_layer_create_cf_using_outside_memory(2,0,0,quickview_height,quickview_width,&temp_layer_handlr,temp_ptr,quickview_height*quickview_width*2);
			gdi_layer_push_and_set_active(temp_layer_handlr);
			gdi_layer_clear(GDI_COLOR_BLACK);
	    }
		#endif
        if (result >= 0)
        {
            if ((g_mmi_camco_cntx.preview_wnd.width >= image_width) && (g_mmi_camco_cntx.preview_wnd.height >= image_height))
            {
                /* align preview window at the center of screen */
                offset_x = ((g_mmi_camco_cntx.preview_wnd.width - image_width) >> 1);
                offset_y = ((g_mmi_camco_cntx.preview_wnd.height - image_height) >> 1);

                gdi_image_jpeg_draw_file_no_rotate(offset_x, offset_y, mmi_camco_cam_p->buf_filename_p);
            }
            else
            {
                gdi_image_util_fit_bbox(
                    g_mmi_camco_cntx.preview_wnd.width,
                    g_mmi_camco_cntx.preview_wnd.height,
                    image_width,
                    image_height,
                    &resized_offset_x,
                    &resized_offset_y,
                    &resized_width,
                    &resized_height);

                gdi_image_jpeg_draw_resized_file_no_rotate(
                    resized_offset_x,
                    resized_offset_y,
                    resized_width,
                    resized_height,
                    mmi_camco_cam_p->buf_filename_p);
            }

            MMI_CAMCO_STOP_LOGGING("DEC");
        }
    #endif /* __MTK_TARGET__ */ 
	#ifdef HORIZONTAL_CAMERA
	    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	    {
			gdi_layer_pop_and_restore_active();
		    mmi_camco_osd_rotate_for_hw_rotate(temp_layer_handlr,g_mmi_camco_cntx.non_preview_base_layer_handle);
            gdi_layer_free(temp_layer_handlr);
	    }
	#endif

        gdi_layer_pop_and_restore_active();

        if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
        {
            mmi_camco_cam_save_done_lsk_released(KEY_EVENT_UP);
        }
        else if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
        {
            g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_TRUE;
            mmi_camco_cam_save_done_option_lsk_released(KEY_EVENT_UP);
        }
        else
        {
        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_cam_save_done_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_save_done_lsk_released(KEY_EVENT_UP);
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_save_done_evt_hdlr);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
    }

    mmi_camco_turn_off_lcd_backlight();

	#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
        mmi_scr_locker_stop_timer();
	    mmi_scr_locker_start_timer();
	#endif

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&tempticks);

        memset(log, 0, sizeof(log));
        memset(str, 0, sizeof(str));
        end_ticks = tempticks;
        tick_elapsed = (end_ticks - start_ticks);
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */

        sprintf(log, "%.3f ms", tick_elapsed);
        mmi_asc_to_ucs2((CHAR*) str, (CHAR*) log);
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gui_move_text_cursor(0, 200);
        gui_set_text_color(gui_color(0, 0, 160));
        gui_set_text_border_color(gui_color(255, 255, 255));
        gui_print_bordered_text((UI_string_type) str);
        gdi_layer_pop_and_restore_active();
        mmi_camco_osd_draw_osd();
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    mmi_camco_sublcd_draw_icon();
    mmi_camco_cam_p->is_sublcd_capture = MMI_FALSE;
#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_contshot_state
 * DESCRIPTION
 *  enter camera contshot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_contshot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_CONTSHOT;

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_CONTSHOT);

#ifndef __MMI_CAMCO_FTE__
    if (!mmi_camco_is_from_external())
	{    	
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_CAMERA,
            IMG_ID_CAMCO_CAMERA,
            mmi_camco_cam_capture_csk_button_released,
            KEY_EVENT_UP);
    }
    else
    {
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_CAMERA_ONLY,
            IMG_ID_CAMCO_CAMERA_ONLY,
            mmi_camco_cam_capture_csk_button_released,
            KEY_EVENT_UP);
        
    }        
    mmi_camco_osd_set_csk_press();
#else
    mmi_camco_osd_csk_set_press(MMI_TRUE);    
#endif /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_osd_draw_osd();

    mmi_camco_cam_contshot_cyclic();

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_contshot_select_evt_hdlr);
    SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
#else /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_cam_contshot_set_key_hdlr();
#endif /* __MMI_CAMCO_FTE__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_burstshot_state
 * DESCRIPTION
 *  enter camera burstshot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_enter_cam_burstshot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;
    U16 i;

#ifdef __MMI_INTERACTIVE_PROFILNG__
    U32 tempticks;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&tempticks);
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_PRE_DUR, (U32) ((tempticks - start_ticks) * 4.615));
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    MMI_CAMCO_STOP_LOGGING("PRE");

    MMI_CAMCO_START_LOGGING("BUS");

    result = mmi_camco_cam_burstshot_start();
    if (result == MDI_RES_CAMERA_SUCCEED)
        mmi_camco_cam_play_shuttersound(mmi_camco_get_shuttersound());

    g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
	mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);	
	mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);	

    if (result == MDI_RES_CAMERA_SUCCEED)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_BURSTSHOT;
        mmi_camco_cam_p->is_burstshot_finish = MMI_FALSE;
        for (i = 0; i < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; i++)
        {
            mmi_camco_cam_p->burstshot.is_saved[i] = MMI_FALSE;
        }
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));
        // no quick view for burst shot, peview layer content may rotate, so clean it
        mmi_camco_osd_set_bg_black();     
        mmi_camco_osd_draw_osd();
    }
    else
    {
        /*
         * Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or 
         * MMI_CAMCO_STATE_CAM_FOCUSING or MMI_CAMCO_STATE_CAM_FOCUSED or
         * MMI_CAMCO_STATE_CAM_COUNTDOWN 
         */
        mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;

        mmi_camco_show_error_msg(result);

        mmi_camco_error_hdlr_timer_start();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_burstshot_select_state
 * DESCRIPTION
 *  enter camera burstshot select state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_burstshot_select_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;
    PU8 image_buf_ptr;
    U32 image_buf_size;
    S32 image_width = 0;
    S32 image_height = 0;
    U16 shown_image_width = 0;
    U16 shown_image_height = 0;    
    S32 resized_offset_x;
    S32 resized_offset_y;
    S32 resized_width;
    S32 resized_height;
    gdi_handle cache_layer_handle;
    gdi_color bg_color = gdi_act_color_from_rgb(255, 0, 0, 0);

#ifdef __MMI_INTERACTIVE_PROFILNG__
    CHAR log[50];
    CHAR str[50];
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
	/*open and enable color engine for quickview image*/
	if(!g_mmi_camco_cntx.is_color_engine_enable)
	{
		mdi_camera_color_engine_open();
		mdi_camera_color_engine_enable();
		g_mmi_camco_cntx.is_color_engine_enable = MMI_TRUE;
	}

    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_INT_BURSTSHOT_SELECT)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT;

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
        mmi_camco_osd_set_imgselect_highlight_idx(0);
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_set_captured_mode(MMI_TRUE);
    #endif 

        image_width = mmi_camco_cam_p->image_width;
        image_height = mmi_camco_cam_p->image_height;

        mmi_camco_osd_get_imgselect_shown_size(&shown_image_width, &shown_image_height);

        memset(
            mmi_camco_cam_p->cache_mem_pool,
            bg_color,
            MMI_CAMCO_CAM_CACHE_IMAGE_SIZE * MMI_CAMCO_CAM_CACHE_IMAGE_COUNT);

        for (index = 0; index < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; index++)
        {
            image_buf_ptr = (PU8) mmi_camco_cam_p->burstshot.jpeg_data.file_address[index];
            image_buf_size = (U32) mmi_camco_cam_p->burstshot.jpeg_data.file_size[index];

            MMI_CAMCO_START_LOGGING("SUB");

            gdi_layer_create_cf_using_outside_memory(
                GDI_COLOR_FORMAT_16,
                0,
                0,
                shown_image_width,
                shown_image_height,
                &cache_layer_handle,
                mmi_camco_cam_p->burstshot.cache_img_p[index],
                MMI_CAMCO_CAM_CACHE_IMAGE_SIZE);

            gdi_layer_push_and_set_active(cache_layer_handle);
            gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
        #ifdef __MMI_CAMCO_FTE__
            gdi_layer_clear(gdi_act_color_from_rgb(255, 100, 100, 100));
        #else 
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        #endif 

            gdi_image_util_fit_bbox(
                shown_image_width,
                shown_image_height,
                image_width,
                image_height,
                &resized_offset_x,
                &resized_offset_y,
                &resized_width,
                &resized_height);

            gdi_image_jpeg_draw_resized_no_rotate(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height,
                image_buf_ptr,
                image_buf_size);

            MMI_CAMCO_STOP_LOGGING("SUB");

            gdi_layer_pop_and_restore_active();
            gdi_layer_free(cache_layer_handle);

            mmi_camco_osd_set_redraw_image_select_cache(MMI_TRUE);
            mmi_camco_osd_set_draw_image_select_cache_count(index + 1);

            mmi_camco_osd_imageselect_set_cache_img_info(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height);

            mmi_camco_osd_draw_osd();

        }

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_burstshot_select_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
        mmi_camco_osd_draw_osd();

    #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_BURSTSHOT_SELECT ||
             g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)
    {
        mmi_camco_state_enum prev_state = g_mmi_camco_cntx.app_state;
        U16 idx;
        CHAR* buf_filename;

        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT;

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_set_captured_mode(MMI_TRUE);
    #endif 
        mmi_camco_osd_set_redraw_image_select_cache(MMI_TRUE);
        mmi_camco_osd_set_draw_image_select_cache_count(MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT);

    #ifndef __MMI_CAMCO_FTE__
        if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
        {
            mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
            if (!mmi_camco_is_file_exist(buf_filename))
            {
                g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
                for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; idx++)
                {
                    mmi_camco_cam_p->burstshot.is_saved[idx] = MMI_FALSE;
                }
				mmi_camco_osd_set_bg_black();
                mmi_camco_show_error_msg(MMI_CAMCO_ERR_FILE_NOT_FOUND);
                mmi_camco_error_hdlr_timer_start();
                return;
            }
        }
        else
    #endif /* __MMI_CAMCO_FTE__ */ 
        if (prev_state == MMI_CAMCO_STATE_CAM_INT_BURSTSHOT_SELECT)
        {
            U16 prev_highlight_idx;
            MMI_BOOL is_found = MMI_FALSE;

            mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);

            prev_highlight_idx = idx;
            for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; idx++)
            {
                if (mmi_camco_cam_p->burstshot.is_saved[idx] == MMI_TRUE)
                {
                    is_found = MMI_TRUE;
                    break;
                }
            }

            if (is_found)
            {
                mmi_camco_osd_set_imgselect_highlight_idx(idx);
                mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
                mmi_camco_osd_set_imgselect_highlight_idx(prev_highlight_idx);
                if (!mmi_camco_is_file_exist(buf_filename))
                {
                    for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; idx++)
                    {
                        mmi_camco_cam_p->burstshot.is_saved[idx] = MMI_FALSE;
                    }
					mmi_camco_osd_set_bg_black();
                    mmi_camco_show_error_msg(MMI_CAMCO_ERR_FILE_NOT_FOUND);
                    mmi_camco_error_hdlr_timer_start();
                    return;
                }
            }
            else
            {
                mmi_camco_osd_set_imgselect_highlight_idx(prev_highlight_idx);
            }
        }

        if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
        {
            /* Draw the background highlighted image */
            mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
            mmi_camco_osd_set_redraw_image_select_highlight_osd(MMI_FALSE);
            mmi_camco_osd_draw_image_select();

            mmi_camco_cam_burstshot_select_lsk_options_released(KEY_EVENT_UP);
        }
        else if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
        {
            g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_TRUE;

            /* Draw the background highlighted image */
            mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
            mmi_camco_osd_set_redraw_image_select_highlight_osd(MMI_FALSE);
            mmi_camco_osd_draw_image_select();

            mmi_camco_cam_burstshot_select_option_lsk_released(KEY_EVENT_UP);
        }
        else
        {
        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_cam_burstshot_select_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);
            mmi_camco_cam_burstshot_select_lsk_options_released(KEY_EVENT_UP);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }

        mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
    }
    else
    {
        MMI_ASSERT(0);
    }

    mmi_camco_turn_off_lcd_backlight();
	#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
        mmi_scr_locker_stop_timer();
	    mmi_scr_locker_start_timer();
	#endif

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&end_ticks);

        memset(log, 0, sizeof(log));
        memset(str, 0, sizeof(str));
        tick_elapsed = (end_ticks - start_ticks);
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */

        sprintf(log, "%.3f ms", tick_elapsed);
        mmi_asc_to_ucs2((CHAR*) str, (CHAR*) log);
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gui_move_text_cursor(40, 200);
        gui_set_text_color(gui_color(0, 0, 160));
        gui_set_text_border_color(gui_color(255, 255, 255));
        gui_print_bordered_text((UI_string_type) str);
        gdi_layer_pop_and_restore_active();
        mmi_camco_osd_draw_osd();
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_aebshot_state
 * DESCRIPTION
 *  enter camera aeb shot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static void mmi_camco_enter_cam_aebshot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;
    U8 i = 0;

#ifdef __MMI_INTERACTIVE_PROFILNG__
    U32 tempticks;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&tempticks);
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_PRE_DUR, (U32) ((tempticks - start_ticks) * 4.615));
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    MMI_CAMCO_STOP_LOGGING("PRE");

    MMI_CAMCO_START_LOGGING("EBS");

    result = mmi_camco_cam_aebshot();
	mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);	
	mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);	
    MMI_CAMCO_STOP_LOGGING("EBS");
    if (result == MDI_RES_CAMERA_SUCCEED)
        mmi_camco_cam_play_shuttersound(mmi_camco_get_shuttersound());

    g_mmi_camco_cntx.is_preview_start = MMI_FALSE;

    if (result == MDI_RES_CAMERA_SUCCEED)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AEBSHOT;
        for (i = 0; i < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; i++)
        {
            mmi_camco_cam_p->aebshot.is_saved[i] = MMI_FALSE;
        }
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT);

        mmi_camco_highlight_turn_off();
    }
    else
    {
        /* 
         * Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or 
         * MMI_CAMCO_STATE_CAM_FOCUSING or MMI_CAMCO_STATE_CAM_FOCUSED or
         * MMI_CAMCO_STATE_CAM_COUNTDOWN 
         */
        mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;

        mmi_camco_osd_set_bg_black();
        mmi_camco_show_error_msg(result);

        mmi_camco_error_hdlr_timer_start();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_aebshot_select_state
 * DESCRIPTION
 *  enter camera aeb shot select state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_aebshot_select_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;
    PU8 image_buf_ptr;
    U32 image_buf_size;
    S32 image_width = 0;
    S32 image_height = 0;
    U16 shown_image_width = 0;
    U16 shown_image_height = 0;        
    S32 resized_offset_x;
    S32 resized_offset_y;
    S32 resized_width;
    S32 resized_height;
    gdi_handle cache_layer_handle;
    gdi_color bg_color = gdi_act_color_from_rgb(255, 0, 0, 0);

#ifdef __MMI_INTERACTIVE_PROFILNG__
    CHAR log[50];
    CHAR str[50];
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    

    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_INT_AEBSHOT_SELECT)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT;

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_set_captured_mode(MMI_TRUE);
    #endif 
        mmi_camco_osd_set_imgselect_highlight_idx(0);


        memset(
            mmi_camco_cam_p->cache_mem_pool,
            bg_color,
            MMI_CAMCO_CAM_CACHE_IMAGE_SIZE * MMI_CAMCO_CAM_CACHE_IMAGE_COUNT);

        image_width = mmi_camco_cam_p->image_width;
        image_height = mmi_camco_cam_p->image_height;

        mmi_camco_osd_get_imgselect_shown_size(&shown_image_width, &shown_image_height);

        for (index = 0; index < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; index++)
        {
            image_buf_ptr = (PU8) mmi_camco_cam_p->aebshot.jpeg_data.file_address[index];
            image_buf_size = (U32) mmi_camco_cam_p->aebshot.jpeg_data.file_size[index];

            MMI_CAMCO_START_LOGGING("SUB");

            gdi_layer_create_cf_using_outside_memory(
                GDI_COLOR_FORMAT_16,
                0,
                0,
                shown_image_width,
                shown_image_height,
                &cache_layer_handle,
                mmi_camco_cam_p->aebshot.cache_img_p[index],
                MMI_CAMCO_CAM_CACHE_IMAGE_SIZE);

            gdi_layer_push_and_set_active(cache_layer_handle);
            gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);

        #ifdef __MMI_CAMCO_FTE__
            gdi_layer_clear(gdi_act_color_from_rgb(255, 100, 100, 100));
        #else 
            gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        #endif 

            gdi_image_util_fit_bbox(
                shown_image_width,
                shown_image_height,
                image_width,
                image_height,
                &resized_offset_x,
                &resized_offset_y,
                &resized_width,
                &resized_height);

            gdi_image_jpeg_draw_resized_no_rotate(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height,
                image_buf_ptr,
                image_buf_size);

            MMI_CAMCO_STOP_LOGGING("SUB");

            gdi_layer_pop_and_restore_active();
            gdi_layer_free(cache_layer_handle);

            mmi_camco_osd_set_redraw_image_select_cache(MMI_TRUE);
            mmi_camco_osd_set_draw_image_select_cache_count(index + 1);

            mmi_camco_osd_imageselect_set_cache_img_info(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height);

            mmi_camco_osd_draw_osd();

        }
        mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);            
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_aebshot_select_set_key_hdlr();
        SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();

    #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AEBSHOT_SELECT ||
             g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
        mmi_camco_state_enum prev_state = g_mmi_camco_cntx.app_state;
        U16 idx;
        CHAR* buf_filename;

        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT;

        mmi_camco_osd_set_redraw_image_select_cache(MMI_TRUE);
        mmi_camco_osd_set_draw_image_select_cache_count(MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_set_captured_mode(MMI_TRUE);
    #endif 

    #ifndef __MMI_CAMCO_FTE__
        if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
        {
            mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
            if (!mmi_camco_is_file_exist(buf_filename))
            {
                g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
                for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; idx++)
                {
                    mmi_camco_cam_p->aebshot.is_saved[idx] = MMI_FALSE;
                }
				mmi_camco_osd_set_bg_black();
                mmi_camco_show_error_msg(MMI_CAMCO_ERR_FILE_NOT_FOUND);
                mmi_camco_error_hdlr_timer_start();
                return;
            }
        }
        else
    #endif /* __MMI_CAMCO_FTE__ */ 
        if (prev_state == MMI_CAMCO_STATE_CAM_INT_AEBSHOT_SELECT)
        {
            U16 prev_highlight_idx;
            MMI_BOOL is_found = MMI_FALSE;

            mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);

            prev_highlight_idx = idx;
            for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; idx++)
            {
                if (mmi_camco_cam_p->aebshot.is_saved[idx] == MMI_TRUE)
                {
                    is_found = MMI_TRUE;
                    break;
                }
            }

            if (is_found)
            {
                mmi_camco_osd_set_imgselect_highlight_idx(idx);
                mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
                mmi_camco_osd_set_imgselect_highlight_idx(prev_highlight_idx);
                if (!mmi_camco_is_file_exist(buf_filename))
                {
                    for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; idx++)
                    {
                        mmi_camco_cam_p->aebshot.is_saved[idx] = MMI_FALSE;
                    }
					mmi_camco_osd_set_bg_black();
                    mmi_camco_show_error_msg(MMI_CAMCO_ERR_FILE_NOT_FOUND);
                    mmi_camco_error_hdlr_timer_start();
                    return;
                }
            }
            else
            {
                mmi_camco_osd_set_imgselect_highlight_idx(prev_highlight_idx);
            }
        }

        if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
        {
            /* Draw the background highlighted image */
            mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
            mmi_camco_osd_set_redraw_image_select_highlight_osd(MMI_FALSE);
            mmi_camco_osd_draw_image_select();

            mmi_camco_cam_aebshot_select_lsk_options_released(KEY_EVENT_UP);
        }
        else if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
        {
            g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_TRUE;

            /* Draw the background highlighted image */
            mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
            mmi_camco_osd_set_redraw_image_select_highlight_osd(MMI_FALSE);
            mmi_camco_osd_draw_image_select();

            mmi_camco_cam_aebshot_select_option_lsk_released(KEY_EVENT_UP);
        }
        else
        {

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);
            mmi_camco_cam_aebshot_select_lsk_options_released(KEY_EVENT_UP);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);            
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_aebshot_select_set_key_hdlr();
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }

        mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
    }
    else
    {
        MMI_ASSERT(0);
    }

    mmi_camco_turn_off_lcd_backlight();
	#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
        mmi_scr_locker_stop_timer();
	    mmi_scr_locker_start_timer();
	#endif

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&end_ticks);

        memset(log, 0, sizeof(log));
        memset(str, 0, sizeof(str));
        tick_elapsed = (end_ticks - start_ticks);
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */

        sprintf(log, "%.3f ms", tick_elapsed);
        mmi_asc_to_ucs2((CHAR*) str, (CHAR*) log);
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gui_move_text_cursor(40, 200);
        gui_set_text_color(gui_color(0, 0, 160));
        gui_set_text_border_color(gui_color(255, 255, 255));
        gui_print_bordered_text((UI_string_type) str);
        gdi_layer_pop_and_restore_active();
        mmi_camco_osd_draw_osd();
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_detect_capinfo_cyclic
 * DESCRIPTION
 *  get autorama info in cyclic
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

void mmi_camco_cam_autorama_detect_capinfo_cyclic(void)
{


    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mdi_camera_panorama_cap_info_struct cap_info;
    kal_uint32 durition;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    cap_info.ready_to_shot = KAL_FALSE; 
    cap_info.mv_x = 0;
    cap_info.mv_y = 0;
    cap_info.overlap_ratio = 0;
    cap_info.stitch_dir = AUTOCAP_DIR_NO;
    cap_info.move_hint_dir = 0;
    durition = 0;
    
    mdi_camera_get_panorama_cap_info(&cap_info);
    
    if(cap_info.stitch_dir == AUTOCAP_DIR_NO &&g_mmi_camco_cntx.cam.autorama_shot.capture_count == 1)
    { 
        g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_END;
    }
    else if(cap_info.stitch_dir != AUTOCAP_DIR_NO &&
		    g_mmi_camco_cntx.cam.autorama_shot.direction == MMI_CAMCO_AUTORAMA_DIRECTION_END)
    {
         if(cap_info.stitch_dir == AUTOCAP_DIR_RIGHT)
             g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_RIGHT;
         else if(cap_info.stitch_dir == AUTOCAP_DIR_LEFT)
             g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_LEFT;
         else if(cap_info.stitch_dir == AUTOCAP_DIR_UP)
             g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_UP;
         else if(cap_info.stitch_dir == AUTOCAP_DIR_DOWN)
             g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_DOWN;   

         mmi_camco_osd_set_autorama_shot_osd_info(cap_info.mv_x,cap_info.mv_y,cap_info.overlap_ratio,g_mmi_camco_cntx.cam.autorama_shot.direction);
         mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_AUTORAMA_SHOT);
         mmi_camco_cam_autorama_shot_set_key_hdlr();
		 mmi_camco_osd_draw_osd();
    }
	else
    {
        mmi_camco_osd_set_autorama_shot_osd_info(
            cap_info.mv_x,
            cap_info.mv_y,
            cap_info.overlap_ratio,
            g_mmi_camco_cntx.cam.autorama_shot.direction);
        mmi_camco_osd_draw_osd();
    }
    
	if(cap_info.ready_to_shot  == KAL_TRUE &&(g_mmi_camco_cntx.cam.autorama_shot.direction != MMI_CAMCO_AUTORAMA_DIRECTION_END))
    {   
       gui_cancel_timer(mmi_camco_cam_autorama_detect_capinfo_cyclic);
       mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT);	   
	   SetKeyHandler(mmi_camco_cam_autorama_shot_camera_key_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
       return;
    }
    durition = drv_get_duration_ms(g_mmi_camco_cntx.cam.autorama_shot.last_capture_time);

    if(durition > 30000)
    {
        if(g_mmi_camco_cntx.cam.autorama_shot.direction == MMI_CAMCO_AUTORAMA_DIRECTION_END)
        {
			g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_RIGHT;

		}
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH);
        return;
    }
    gui_start_timer(MMI_CAMCO_AUTORAMA_DETECT_TIME,mmi_camco_cam_autorama_detect_capinfo_cyclic);     

}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_autorama_shot_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_autorama_shot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 
    
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW || 
		g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT||
		g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSING||
		g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSED)
    {
        if (mmi_camco_cam_p->autorama_shot.capture_count == 0)
        {
            U8 idx = 0;
            U8 *temp_p = NULL;
            U32 buffer_size = MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_MEM_SIZE / MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_IMAGE_COUNT;

            temp_p = (U8*) mmi_camco_cam_p->multishot_mem_pool;

            for (idx = 0; idx < MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_IMAGE_COUNT; idx++)
            {
                mmi_camco_cam_p->autorama_shot.capture_buffer_p[idx] = temp_p;
                temp_p += buffer_size;
            }
            
            #ifdef __MMI_CAMCO_MED_AUTORAMA_STITCH_SHARE_ASM__   
                mdi_camera_set_panorama_stitch_memory(g_mmi_camco_cntx.app_med_mem_buf_p, MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE);
            #endif
        }

        if (mmi_camco_cam_p->autorama_shot.capture_count < MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_IMAGE_COUNT)
        {
            result = mmi_camco_cam_autorama_shot();
            if (result == MDI_RES_CAMERA_SUCCEED)
                mmi_camco_cam_play_shuttersound(mmi_camco_get_shuttersound());        
            g_mmi_camco_cntx.is_preview_start = MMI_FALSE;

            #ifndef  __MTK_TARGET__
                result =MDI_RES_CAMERA_SUCCEED;
            #endif
            if (result == MDI_RES_CAMERA_SUCCEED)
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT;
                mmi_camco_cam_p->autorama_shot.capture_count++;
                mmi_camco_osd_set_autorama_cache_image(mmi_camco_cam_p->autorama_shot.cache_buffer_p,mmi_camco_cam_p->autorama_shot.capture_count);
				mmi_camco_osd_autorama_cache_draw_enable(MMI_TRUE);

                if (mmi_camco_cam_p->autorama_shot.capture_count < MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_IMAGE_COUNT)
                {
                    if(mmi_camco_cam_p->autorama_shot.capture_count == 1)
                    {
                        g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_END;
                        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_AUTORAMA_DIRECTION);   			
						mmi_camco_cam_autorama_shot_set_key_hdlr();
						mmi_camco_osd_draw_osd();
                    }
					
                    if (mmi_camco_cam_preview_start() == TRUE)
                    {
                        g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
                        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                        #endif /* __MMI_CAMCO_DEBUG_ON__ */                     
                       mmi_camco_cam_autorama_detect_capinfo_cyclic();
                    }
                    else
                    {
                        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                        mmi_camco_osd_set_center_hint_str(GetString(STR_ID_CAMCO_PREVIEW_FAILED));
                        mmi_camco_osd_draw_osd();

                        kal_sleep_task(200);

                        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH);
                    }
                }
                else
                {
                #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                #endif /* __MMI_CAMCO_DEBUG_ON__ */ 

                #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

                    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH);
                }
            }
        }
        else
        {
            if (mmi_camco_cam_p->autorama_shot.capture_count == 0)
            {
                /*
                 * Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or 
                 * MMI_CAMCO_STATE_CAM_FOCUSING or MMI_CAMCO_STATE_CAM_FOCUSED or
                 * MMI_CAMCO_STATE_CAM_COUNTDOWN 
                 */
                mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;

                mmi_camco_show_error_msg(result);

                mmi_camco_error_hdlr_timer_start();
            }
            else
            {
                mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH);
            }
        }
    
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_autorama_stitch_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_autorama_stitch_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT)
        mmi_camco_cam_preview_stop();
    
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
    MMI_CAMCO_STOP_LOGGING("PAN");

    mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 
    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));

    mmi_camco_cam_autorama_stitch_set_key_hdlr();
    mmi_camco_osd_draw_osd();
    
    #ifdef __MMI_INTERACTIVE_PROFILNG__
        if (mmi_frm_profiling_interactive_is_enabled())
        {
            kal_get_time(&start_ticks);
        }
    #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

        MMI_CAMCO_START_LOGGING("STI");

        mmi_camco_cam_p->autorama_shot.is_stitch_done = MMI_FALSE;
        ret = mmi_camco_cam_autorama_stitch();

    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH;
    if (ret == MDI_RES_CAMERA_SUCCEED)
    {
        /*mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));

        mmi_camco_cam_autorama_stitch_set_key_hdlr();
        mmi_camco_osd_draw_osd();*/
    }
    else
    {
        mmi_camco_show_error_msg(ret);
        mmi_camco_error_hdlr_timer_start();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_autorama_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_autorama_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 result;
    S32 offset_x;
    S32 offset_y;
    S32 resized_offset_x;
    S32 resized_offset_y;
    S32 resized_width;
    S32 resized_height;
    mmi_camco_state_enum prev_state;
    MDI_RESULT ret;
	U8* temp_ptr; 
    GDI_HANDLE temp_layer_handlr;
	S32 quickview_width;
	S32 quickview_height;

#ifdef __MMI_INTERACTIVE_PROFILNG__
    U32 tempticks;
    CHAR log[50];
    CHAR str[50];
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE)
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
    }
    prev_state = g_mmi_camco_cntx.app_state;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_FALSE);
#endif 

    if (prev_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AUTORAMA_DONE;
    }
    else if (prev_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_STITCH)
    {
        mmi_camco_cam_p->capture_buf_ptr = (PU8) mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_address;
        mmi_camco_cam_p->capture_size = mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_size;
        mmi_camco_cam_draw_capture_img_from_memory();

        /* when the stich is too fast, pause pano will no effect, so that dont show it to prevent it shown on captured screen */
    #ifndef AUTORAMA_MAX_INPUT_IMAGE_SIZE_VGA
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
    #endif 
        mmi_camco_osd_draw_osd();

        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH;
    }

    if (prev_state != MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }

    if (prev_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE &&
        !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
    }
    else if (prev_state == MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH || prev_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_STITCH)
    {
    #ifdef __MTK_TARGET__
        ret = mmi_camco_cam_autorama_save_capture_image(
                (PU8) mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_address,
                (U32) mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_size);
    #else /* __MTK_TARGET__ */ 
        ret = MDI_RES_CAMERA_SUCCEED;
    #endif /* __MTK_TARGET__ */ 
        if (ret == MDI_RES_CAMERA_SUCCEED)
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_AUTORAMA_DONE;
            mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                              (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));

        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_cam_autorama_done_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_autorama_done_lsk_released(KEY_EVENT_UP);
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_autorama_done_evt_hdlr);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
        else
        {
            /* in the case of pano stitch, the memory card remove popup wont appear */
            /* so wee need to check if fai cause is card is removed after stitch and result is fail */
            if((ret ==  MMI_CAMCO_ERR_SAVE_FAIL || ret ==MDI_RES_VDOREC_ERR_SAVE_FILE_FAILED)  &&
                (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE) &&
                !srv_fmgr_drv_is_accessible(SRV_FMGR_CARD_DRV))
            {
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
            }
            else
            {   
                /* in the case of pano stitch, the OTG card remove popup wont appear */
                mmi_camco_check_storage_capability();
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));                
            }            
            mmi_camco_need_restart_preview();
            mmi_camco_show_error_msg(ret);
            mmi_camco_error_hdlr_timer_start();
            return;
        }
    }
    else if (prev_state == MMI_CAMCO_STATE_CAM_INT_AUTORAMA_DONE && mmi_camco_cam_p->is_drive_available)
    {
        /* the pic decorde will take long time, show string to prevent from see the previous screen for a long time */
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));
        mmi_camco_osd_draw_osd();
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
        mmi_camco_osd_set_center_hint_str(NULL);

        mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                          (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));

        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_clear_background(GDI_COLOR_BLACK);

    #ifdef __MTK_TARGET__
        /* show the capture image */
        result = gdi_image_jpeg_get_dimension_file(mmi_camco_cam_p->buf_filename_p, &image_width, &image_height);
    #ifdef HORIZONTAL_CAMERA
	    quickview_width = g_mmi_camco_cntx.quickview_wnd.width;
		quickview_height = g_mmi_camco_cntx.quickview_wnd.height;
		if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
		{
			temp_ptr = mmi_camco_osd_get_init_mem();
			gdi_layer_create_cf_using_outside_memory(2,0,0,quickview_height,quickview_width,&temp_layer_handlr,temp_ptr,quickview_height*quickview_width*2);
			gdi_layer_push_and_set_active(temp_layer_handlr);
			gdi_layer_clear(GDI_COLOR_BLACK);
		}
    #endif

        if (result >= 0)
        {
            if ((g_mmi_camco_cntx.preview_wnd.width >= image_width) && (g_mmi_camco_cntx.preview_wnd.height >= image_height))
            {
                /* align preview window at the center of screen */
                offset_x = ((g_mmi_camco_cntx.preview_wnd.width - image_width) >> 1);
                offset_y = ((g_mmi_camco_cntx.preview_wnd.height - image_height) >> 1);

                gdi_image_jpeg_draw_file(offset_x, offset_y, mmi_camco_cam_p->buf_filename_p);
            }
            else
            {
                gdi_image_util_fit_bbox(
                    g_mmi_camco_cntx.preview_wnd.width,
                    g_mmi_camco_cntx.preview_wnd.height,
                    image_width,
                    image_height,
                    &resized_offset_x,
                    &resized_offset_y,
                    &resized_width,
                    &resized_height);

                gdi_image_jpeg_draw_resized_file(
                    resized_offset_x,
                    resized_offset_y,
                    resized_width,
                    resized_height,
                    mmi_camco_cam_p->buf_filename_p);
            }
        }
	#ifdef HORIZONTAL_CAMERA
	    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	    {
			gdi_layer_pop_and_restore_active();
		    mmi_camco_osd_rotate_for_hw_rotate(temp_layer_handlr,g_mmi_camco_cntx.non_preview_base_layer_handle);
            gdi_layer_free(temp_layer_handlr);
	    }
    #endif
    #endif /* __MTK_TARGET__ */ 

        gdi_layer_pop_and_restore_active();

        if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
        {
            mmi_camco_cam_autorama_done_lsk_released(KEY_EVENT_UP);
        }
        else if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
        {
            g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_TRUE;
            mmi_camco_cam_autorama_done_option_lsk_released(KEY_EVENT_UP);
        }
        else
        {
        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_cam_autorama_done_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_autorama_done_lsk_released(KEY_EVENT_UP);
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_autorama_done_evt_hdlr);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
    }

    mmi_camco_turn_off_lcd_backlight();
	#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
        mmi_scr_locker_stop_timer();
	    mmi_scr_locker_start_timer();
	#endif

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&tempticks);

        memset(log, 0, sizeof(log));
        memset(str, 0, sizeof(str));
        end_ticks = tempticks;
        tick_elapsed = (end_ticks - start_ticks);
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */

        sprintf(log, "%.3f ms", tick_elapsed);
        mmi_asc_to_ucs2((CHAR*) str, (CHAR*) log);
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gui_move_text_cursor(0, 200);
        gui_set_text_color(gui_color(0, 0, 160));
        gui_set_text_border_color(gui_color(255, 255, 255));
        gui_print_bordered_text((UI_string_type) str);
        gdi_layer_pop_and_restore_active();
        mmi_camco_osd_draw_osd();
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
#ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_mav_shot_set_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_mav_shot_rsk_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_camera_stop_non_blocking_mav_shot();
	mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
	mmi_camco_need_restart_preview();
	mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_mav_shot_set_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_mav_shot_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	 mmi_camco_set_csk_action_mode(MMI_FALSE);		
		/* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
		mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_mav_shot_rsk_released);
    #else
		mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_mav_shot_rsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
		mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_mav_shot_rsk_released);	
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
		mmi_camco_set_csk_action_mode(MMI_TRUE); 


}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_autorama_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_mav_capture_result_hdlr(mdi_camera_mav_capture_struct* result_ind, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_camco_cam_mav_shot_struct param;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    param.total_count = result_ind->total_count;
    param.captured_count = result_ind->capture_count;
    if(param.captured_count <= param.total_count)
    {
        mmi_camco_set_captured_count(param.captured_count,param.total_count);
	    mmi_camco_osd_draw_osd();
	}
    if(param.captured_count == param.total_count)
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);	
	    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);
		mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
		mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
		mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));
		// no quick view for burst shot, peview layer content may rotate, so clean it
		mmi_camco_osd_set_bg_black();	  
		mmi_camco_osd_draw_osd();
	}
	
	/*if error code added handle error code*/
	/*else
	{
        mmi_camco_enter_state();
	}*/
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_autorama_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 ***************************************************************************/
static void mmi_camco_cam_mav_save_result_hdlr(mdi_camera_mav_result_struct* result_ind, void* user_data)
{

    S32 ret=0;
    if(result_ind->result == MDI_RES_CAMERA_SUCCEED)
    {	  
		ret = mdi_camera_save_captured_image();
	    if(ret ==  MDI_RES_CAMERA_SUCCEED)
		{
		  if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_MAV)
		  {
		   /* enter imgview to see the image */
      	      g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_PREVIEW;
		      mmi_camco_cam_entry_image_view_cui();
		  }else
		  {
		     /*enter save done state */
              mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SAVE_DONE);
		  }
	  
		}
		else
		{
            if((ret ==  MMI_CAMCO_ERR_SAVE_FAIL || ret ==MDI_RES_VDOREC_ERR_SAVE_FILE_FAILED)  &&
                (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE) &&
                !srv_fmgr_drv_is_accessible(SRV_FMGR_CARD_DRV))
            {
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
            }
            else
            {   
                /* in the case of pano stitch, the OTG card remove popup wont appear */
                mmi_camco_check_storage_capability();
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));                
            }            
            mmi_camco_need_restart_preview();
            mmi_camco_show_error_msg(ret);
            mmi_camco_error_hdlr_timer_start();
            return;

		}
	}
	else
    {
		mmi_camco_show_error_msg(result_ind->result);
		mmi_camco_error_hdlr_timer_start();
		return;
	}

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_autorama_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

MDI_RESULT mmi_camco_cam_mav_shot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#if defined(__MTK_TARGET__)
    return mdi_camera_capture_mav_shot(
            mmi_camco_cam_p->buf_filename_p,
            mmi_camco_cam_mav_capture_result_hdlr,
            mmi_camco_cam_mav_save_result_hdlr,
            NULL);
#else
    return MDI_RES_CAMERA_SUCCEED;
#endif
}

void mmi_camco_enter_cam_mav_shot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MDI_RESULT result;

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 
    
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW || 
		g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSING||
		g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSED)
    {
    
	    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);
        result = mmi_camco_cam_mav_shot();  
		g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
		if (result == MDI_RES_CAMERA_SUCCEED)
		{
			g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_MAV_SHOT;
			
			if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_MAV)
			{
			    mmi_camco_set_captured_count(0,MAV_IMAGE_NUM);
		    }
			else
			{
			    mmi_camco_set_captured_count(0,2);
			}
			mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_MAV_SHOT);
			mmi_camco_cam_mav_shot_set_key_hdlr();
			mmi_camco_osd_draw_osd();
		}
		else
		{
			/*
			 * Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or 
			 * MMI_CAMCO_STATE_CAM_FOCUSING or MMI_CAMCO_STATE_CAM_FOCUSED or
			 * MMI_CAMCO_STATE_CAM_COUNTDOWN 
			 */
			mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;
		
			mmi_camco_show_error_msg(result);
		
			mmi_camco_error_hdlr_timer_start();
		}

    
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_mav_shot_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void        [IN]       void
 * RETURNS
 *  void
 *****************************************************************************/

void mmi_camco_exit_cam_mav_shot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_camera_stop_non_blocking_mav_shot();
    mmi_frm_end_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
	mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
    g_mmi_camco_cntx.is_preemptable = MMI_TRUE;    

}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_hdr_shit_rsk_released
 * DESCRIPTION
 *  
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_hdr_shot_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_cam_p->is_hdr_shot_process)
    {
        mmi_camco_cam_hdrshot_stop();     
    }
    
    if (g_mmi_camco_cntx.is_power_on)
    {
        /*  
         * Before enter preview from non-preview state, re-draw osd in advance.
         * Otherwise, there will some noise in screen when driver blt in first time.
         */
        g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {

        mmi_camco_osd_set_bg_black();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_hdr_shot_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_hdr_shot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    //mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);

    MMI_CAMCO_STOP_LOGGING("PRE");

    MMI_CAMCO_START_LOGGING("HDR");

    memset(mmi_camco_cam_p->mmi_camco_hdr_file_name, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->mmi_camco_hdr_file_name);

    result = mmi_camco_cam_hdrshot_start();

   // mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
   // mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);  
    g_mmi_camco_cntx.is_priview_layer_active = MMI_FALSE;
	g_mmi_camco_cntx.base_layer_handle = g_mmi_camco_cntx.non_preview_base_layer_handle;
	mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);	
	mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.non_preview_base_layer_handle);
	mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.preview_base_layer_handle); 
    if (result == MDI_RES_CAMERA_SUCCEED)
        mmi_camco_cam_play_shuttersound(mmi_camco_get_shuttersound());

    g_mmi_camco_cntx.is_preview_start = MMI_FALSE;    

    if (result == MDI_RES_CAMERA_SUCCEED)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_HDR_SHOT;

        mmi_camco_cam_p->is_hdr_shot_process = MMI_TRUE;

        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));
        // no quick view for burst shot, peview layer content may rotate, so clean it

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_hdr_shot_evt_hdlr);
    #else 
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_hdr_shot_rsk_released);
        #else
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_hdr_shot_rsk_released);
        #endif
    #else 
        mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_hdr_shot_rsk_released);
    #endif
    #endif 
    
         
        //mmi_camco_osd_set_bg_black();     
        //mmi_camco_osd_draw_osd();
    }
    else
    {
        /*
         * Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or 
         * MMI_CAMCO_STATE_CAM_FOCUSING or MMI_CAMCO_STATE_CAM_FOCUSED or
         * MMI_CAMCO_STATE_CAM_COUNTDOWN 
         */
        mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;
        mmi_camco_cam_restore_filename_seq_no();
		mmi_camco_osd_set_bg_black();

        mmi_camco_show_error_msg(result);

        mmi_camco_error_hdlr_timer_start();
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_hdr_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_hdr_done_state(void)
{
    mmi_camco_state_enum prev_state;
    MDI_RESULT ret;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev_state = g_mmi_camco_cntx.app_state;
    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_FALSE);
#endif 

    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    if (prev_state == MMI_CAMCO_STATE_CAM_HDR_SHOT)
    {
        ret = mmi_camco_cam_hdrshot_save();
        
        if (ret == MDI_RES_CAMERA_SUCCEED)
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_HDR_DONE;
            mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                              (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));
        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_cam_save_done_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_cam_save_done_lsk_released(KEY_EVENT_UP);
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_hdr_done_evt_hdlr);
            SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
        else
        {
            mmi_camco_cam_restore_filename_seq_no();

            mmi_camco_show_error_msg(ret);
            mmi_camco_error_hdlr_timer_start();
            return;
        }
    }

    mmi_camco_turn_off_lcd_backlight();
	#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
        mmi_scr_locker_stop_timer();
	    mmi_scr_locker_start_timer();
	#endif

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_hdr_shot_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_hdr_shot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_camco_cam_p->is_hdr_shot_process)
    {
        mmi_camco_cam_hdrshot_stop();     
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_hdr_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_hdr_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

}

#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_restore_confirm_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_restore_confirm_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;
    BOOL ret = TRUE;
    srv_prof_tone_enum tone_type = SRV_PROF_TONE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
     
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_INT_RESTORE_CONFIRM)
    {
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_DEFAULT_COMFIRM));

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_restore_confirm_evt_hdlr);
    #else 
        mmi_camco_restore_confirm_set_key_hdlr();
    #endif 
        mmi_camco_osd_draw_osd();

        app = mmi_camco_setting_get_active_app();
        if (app == MMI_CAMCO_SETTING_APP_CAMERA)
        {
            ret = mmi_camco_cam_preview_start();
        }
        else
        {
            ret = mmi_camco_rec_preview_start();
        }
    }
    else
    {
        tone_type = mmi_get_event_based_sound(MMI_EVENT_QUERY);
        if (tone_type != NONE_TONE)
        {
            srv_prof_play_tone(tone_type, NULL);
        }
    }

    if (ret)
    {
        g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_RESTORE_CONFIRM;

        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_DEFAULT_COMFIRM));

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_restore_confirm_evt_hdlr);
    #else 
        mmi_camco_restore_confirm_set_key_hdlr();
    #endif 
        mmi_camco_osd_draw_osd();
        
        if (mmi_camco_setting_is_highlight_on())
        {
            mmi_camco_highlight_turn_on();
        }
        else
        {
            mmi_camco_highlight_turn_off();            
        }          
    }
    else
    {
        if (app == MMI_CAMCO_SETTING_APP_CAMERA)
        {
            mmi_camco_enter_cam_preview_failed_state();
        }
        else
        {
            mmi_camco_enter_rec_preview_failed_state();
        }
    }
    g_mmi_camco_cntx.is_restore_default = MMI_FALSE;

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_current_state
 * DESCRIPTION
 *  exit the current state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_current_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_EXIT_CURRENT_STATE, g_mmi_camco_cntx.app_state);
    switch (g_mmi_camco_cntx.app_state)
    {
        case MMI_CAMCO_STATE_CAM_PREVIEW:
    #ifdef __SMILE_SHUTTER_SUPPORT__
        case MMI_CAMCO_STATE_CAM_SMILE_DECT:
    #endif 
            mmi_camco_exit_cam_preview_state();
            break;

        case MMI_CAMCO_STATE_CAM_PREVIEW_FAILED:
            break;

        case MMI_CAMCO_STATE_CAM_SETTING_MENU:
            mmi_camco_exit_cam_setting_menu_state();
            break;

        case MMI_CAMCO_STATE_CAM_FOCUSING:
        case MMI_CAMCO_STATE_CAM_FOCUSED:
            mmi_camco_exit_cam_focus_state();
            break;

        case MMI_CAMCO_STATE_CAM_COUNTDOWN:
            mmi_camco_exit_cam_countdown_state();
            break;

        case MMI_CAMCO_STATE_CAM_CAPTURE:
            mmi_camco_exit_cam_capture_state();
            break;

        case MMI_CAMCO_STATE_CAM_SAVE_DONE:
            mmi_camco_exit_cam_save_done_state();
            break;

        case MMI_CAMCO_STATE_CAM_CONTSHOT:
            mmi_camco_exit_cam_contshot_state();
            break;

    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
        case MMI_CAMCO_STATE_CAM_BURSTSHOT:
            mmi_camco_exit_cam_burstshot_state();
            break;

        case MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT:
            mmi_camco_exit_cam_burstshot_select_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 

    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
        case MMI_CAMCO_STATE_CAM_AEBSHOT:
            mmi_camco_exit_cam_aebshot_state();
            break;

        case MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT:
            mmi_camco_exit_cam_aebshot_select_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 

    #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
        case MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT:
            mmi_camco_exit_cam_autorama_shot_state();
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH:
            mmi_camco_exit_cam_autorama_stitch_state();
            break;

        case MMI_CAMCO_STATE_CAM_AUTORAMA_DONE:
            mmi_camco_exit_cam_autorama_done_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
    #ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
	    case MMI_CAMCO_STATE_CAM_MAV_SHOT:
			 mmi_camco_exit_cam_mav_shot_state();
			 break;
	#endif

    #ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
        case MMI_CAMCO_STATE_CAM_HDR_SHOT:
            mmi_camco_exit_cam_hdr_shot_state();
            break;            

        case MMI_CAMCO_STATE_CAM_HDR_DONE:
            mmi_camco_exit_cam_hdr_done_state();
            break;              
    #endif
    
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        case MMI_CAMCO_STATE_CAM_SUB_PREVIEW:
            mmi_camco_exit_cam_sub_preview_state();
            break;
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 

    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        case MMI_CAMCO_STATE_CAM_ADD_FRAME:
            mmi_camco_exit_cam_add_frame_state();
            break;
    #endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
        case MMI_CAMCO_STATE_REC_PREVIEW:
            mmi_camco_exit_rec_preview_state();
            break;

        case MMI_CAMCO_STATE_REC_PREVIEW_FAILED:
            mmi_camco_exit_rec_preview_failed_state();
            break;

        case MMI_CAMCO_STATE_REC_SETTING_MENU:
            mmi_camco_exit_rec_setting_menu_state();
            break;

        case MMI_CAMCO_STATE_REC_FOCUSING:
        case MMI_CAMCO_STATE_REC_FOCUSED:
            mmi_camco_exit_rec_focus_state();
            break;

        case MMI_CAMCO_STATE_REC_RECORDING:
            mmi_camco_exit_rec_recording_state();
            break;

        case MMI_CAMCO_STATE_REC_PAUSE:
            mmi_camco_exit_rec_pause_state();
            break;

        case MMI_CAMCO_STATE_REC_SAVING:
            mmi_camco_exit_rec_saving_state();
            break;

        case MMI_CAMCO_STATE_REC_SAVE_DONE:
            mmi_camco_exit_rec_save_done_state();
            break;

        case MMI_CAMCO_STATE_REC_SAVING_PREV:
            mmi_camco_exit_rec_saving_prev_state();
            break;

        case MMI_CAMCO_STATE_RESTORE_CONFIRM:
            mmi_camco_exit_restore_confirm_state();
            break;

        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_preview_state
 * DESCRIPTION
 *  exit camera preview state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_preview_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_takepic_failed)
    {
        mmi_camco_cam_preview_stop();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_setting_menu_state
 * DESCRIPTION
 *  exit camera setting menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_setting_menu_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_mmi_camco_cntx.is_post_process_pause == MMI_TRUE)
    {
	     mdi_camera_resume_preview_post_process();
		 g_mmi_camco_cntx.is_post_process_pause = MMI_FALSE;
	}
    mmi_camco_cam_preview_stop();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_add_frame_state
 * DESCRIPTION
 *  exit camera setting menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_exit_cam_add_frame_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_update_zoom_step() == 0 && mmi_camco_setting_get_camzoom_step() != mmi_camco_update_zoom_step())
    {
        mmi_camco_cam_p->is_reset_zoom = MMI_TRUE;
    }

    mmi_camco_cam_preview_stop();
}
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_focus_state
 * DESCRIPTION
 *  exit camera focus state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_focus_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_takepic_failed)
    {
        mmi_camco_cam_autofocus_stop();
        mmi_camco_cam_preview_stop();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_countdown_state
 * DESCRIPTION
 *  exit camera countdown state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_countdown_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_takepic_failed)
    {
        gui_cancel_timer(mmi_camco_cam_countdown_cyclic);
        gui_cancel_timer(mmi_camco_countdown_led_turn_off);
        mmi_camco_countdown_led_turn_off();
        mmi_camco_deinit_countdown_mma();

        if (mmi_camco_cam_p->is_autofocus_on)
        {
            mmi_camco_cam_autofocus_stop();
        }
        mmi_camco_cam_preview_stop();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_capture_state
 * DESCRIPTION
 *  exit camera contshot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_capture_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_save_done_state
 * DESCRIPTION
 *  exit camera save done state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_save_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_contshot_state
 * DESCRIPTION
 *  exit camera contshot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_contshot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_cam_contshot_cyclic);
    if (mmi_camco_cam_p->is_autofocus_on)
    {
        mmi_camco_cam_autofocus_stop();
    }
    mmi_camco_cam_preview_stop();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_burstshot_state
 * DESCRIPTION
 *  exit camera burstshot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_exit_cam_burstshot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* cancel osd timer if need */
    if (!mmi_camco_cam_p->is_burstshot_finish)
    {
        mmi_camco_cam_burstshot_stop();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_burstshot_select_state
 * DESCRIPTION
 *  exit camera burstshot_select state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_burstshot_select_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */

}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_aebshot_state
 * DESCRIPTION
 *  exit camera aebtshot state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static void mmi_camco_exit_cam_aebshot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_aebshot_select_state
 * DESCRIPTION
 *  exit camera aebtshot_select state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_aebshot_select_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_autorama_shot_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_autorama_shot_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_reset_autorama_3a();
    mmi_camco_cam_preview_stop();

    mmi_frm_end_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_TRUE;    

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_autorama_stitch_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_autorama_stitch_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_autorama_stitch_stop();

    mmi_frm_end_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_autorama_done_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_autorama_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_restore_confirm_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_restore_confirm_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mmi_camco_cam_preview_stop();
    }
    else
    {
        mmi_camco_rec_preview_stop();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_clam_close_event_hdlr
 * DESCRIPTION
 *  handle clam close event
 * PARAMETERS
 *  interrupt_event     [IN]        Interrupt event type
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__)
static U8 mmi_camco_clam_close_event_hdlr(mmi_frm_int_event_type interrupt_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (interrupt_event & MMI_FRM_INT_CLAM)
    {
        if (interrupt_event == MMI_FRM_INT_CLAM_CLOSE)
        {
        #ifndef __MMI_CLAMCLOSE_BACK2IDLE__
            mmi_camco_exit_app();
        #endif 
            return FALSE;
        }
    }

    /* return false means will pass this interrut to default handler */
    return FALSE;
}
#endif /* defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_draw_capture_img_from_memory
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_draw_capture_img_from_memory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 result;
    S32 offset_x;
    S32 offset_y;
    S32 resized_offset_x;
    S32 resized_offset_y;
    S32 resized_width;
    S32 resized_height;
    U8* temp_ptr; 
	GDI_HANDLE temp_layer_handlr;
	S32 quickview_width;
    S32 quickview_height;

#ifdef __MMI_INTERACTIVE_PROFILNG__
    U32 tempticks_start = 0;
    U32 tempticks_end = 0;
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);

    gdi_layer_clear(GDI_COLOR_BLACK);

    result = gdi_image_jpeg_get_dimension_no_rotate(
                mmi_camco_cam_p->capture_buf_ptr,
                mmi_camco_cam_p->capture_size,
                &image_width,
                &image_height);

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&tempticks_start);
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    MMI_CAMCO_START_LOGGING("DEC");
    quickview_width = g_mmi_camco_cntx.quickview_wnd.width;
    quickview_height = g_mmi_camco_cntx.quickview_wnd.height;

#ifdef HORIZONTAL_CAMERA
	if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	{
		temp_ptr = mmi_camco_osd_get_init_mem();
		gdi_layer_create_cf_using_outside_memory(2,0,0,quickview_height,quickview_width,&temp_layer_handlr,temp_ptr,quickview_height*quickview_width*2);
		gdi_layer_push_and_set_active(temp_layer_handlr);
		gdi_layer_clear(GDI_COLOR_BLACK);
	}
#endif
    if (result >= 0)
    {
        if ((g_mmi_camco_cntx.preview_wnd.width >= image_width) && (g_mmi_camco_cntx.preview_wnd.height >= image_height))
        {
            /* align preview window at the center of screen */
            offset_x = ((g_mmi_camco_cntx.preview_wnd.width - image_width) >> 1);
            offset_y = ((g_mmi_camco_cntx.preview_wnd.height - image_height) >> 1);

            gdi_image_jpeg_draw_no_rotate(offset_x, offset_y, mmi_camco_cam_p->capture_buf_ptr, mmi_camco_cam_p->capture_size);
        }
        else
        {
            gdi_image_util_fit_bbox(
                g_mmi_camco_cntx.preview_wnd.width,
                g_mmi_camco_cntx.preview_wnd.height,
                image_width,
                image_height,
                &resized_offset_x,
                &resized_offset_y,
                &resized_width,
                &resized_height);

            gdi_image_jpeg_draw_resized_no_rotate(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height,
                mmi_camco_cam_p->capture_buf_ptr,
                mmi_camco_cam_p->capture_size);
        }
    }
#ifdef HORIZONTAL_CAMERA
	    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	    {
			gdi_layer_pop_and_restore_active();
		    mmi_camco_osd_rotate_for_hw_rotate(temp_layer_handlr,g_mmi_camco_cntx.non_preview_base_layer_handle);
            gdi_layer_free(temp_layer_handlr);
	    }
#endif

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&tempticks_end);
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_DEC_DUR, (U32) ((tempticks_end - tempticks_start) * 4.615));
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ /* __MMI_INTERACTIVE_PROFILNG_ */

    MMI_CAMCO_STOP_LOGGING("DEC");

    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_get_preview_window
 * DESCRIPTION
 *  According to LCM, get the preview window
 * PARAMETERS
 *  lcd     [IN]        Lcd option
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_get_preview_window(mmi_camco_cam_preview_lcd_enum lcd)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 temp_width = 0;
    U16 temp_height = 0;
    U16 temp_factor = 0;
    U16 lcd_width = 0;
    U16 lcd_height = 0;
    mmi_camco_capsize_enum capsize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    capsize =(mmi_camco_capsize_enum)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE);

#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    if (lcd == MMI_CAMCO_CAM_PREVIEW_SUBLCD)
    {
    #ifdef HORIZONTAL_CAMERA
        if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
        {
            lcd_width = SUBLCD_HEIGHT;
            lcd_height = SUBLCD_WIDTH;
        }
    #ifdef DUAL_CAMERA_SUPPORT
        else
        {
            lcd_width = SUBLCD_WIDTH;
            lcd_height = SUBLCD_HEIGHT;
        }
    #endif /* DUAL_CAMERA_SUPPORT */ 
    #else /* HORIZONTAL_CAMERA */ 
        lcd_width = SUBLCD_WIDTH;
        lcd_height = SUBLCD_HEIGHT;
    #endif /* HORIZONTAL_CAMERA */ 
    }
    else
#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
    {
    #ifdef HORIZONTAL_CAMERA
        if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
        {
            lcd_width = LCD_HEIGHT;
            lcd_height = LCD_WIDTH;
        }
    #ifdef DUAL_CAMERA_SUPPORT
        else
        {
            lcd_width = LCD_WIDTH;
            lcd_height = LCD_HEIGHT;
        }
    #endif /* DUAL_CAMERA_SUPPORT */ 
    #else /* HORIZONTAL_CAMERA */ 
        lcd_width = LCD_WIDTH;
        lcd_height = LCD_HEIGHT;
    #endif /* HORIZONTAL_CAMERA */ 
    }

    /* Wallpaper */
    if (capsize == MMI_CAMCO_CAPSIZE_WALLPAPER)
    {
    #if defined(HORIZONTAL_CAMERA)
        /*
         * If the capture image resolution is wallpaper, the preview window need to be calculated
         * by the proportion of LCD. 
         */

        /* (3/5) is WQVGA LCD proportion */
        /* In order to make the window is multiple of 4, using 20[=5*4] and 12[=3*4] */
        if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
        {
            /* if ((LCD_WIDTH/LCD_HEIGHT) == (3/5)) integer div will always return 0 */
            if ((LCD_WIDTH * 5) == (LCD_HEIGHT * 3))
            {
                temp_factor = (lcd_height / 20);
                temp_width = temp_factor * 12;
                while (temp_width > lcd_width)
                {
                    temp_factor--;
                    temp_width = temp_factor * 12;
                }
                temp_height = temp_factor * 20;
            }
            /* else if ((LCD_WIDTH/LCD_HEIGHT) == (2/3)) */
            else if ((LCD_WIDTH * 3) == (LCD_HEIGHT * 2))
            {
                /* (2/3) is HVVGA LCD proportion */
                /* In order to make the window is multiple of 4, using 12[=3*4] and 8[=2*4] */
                temp_factor = (lcd_height / 12);
                temp_width = temp_factor * 8;
                while (temp_width > lcd_width)
                {
                    temp_factor--;
                    temp_width = temp_factor * 8;
                }
                temp_height = temp_factor * 12;
            }
            else
            {
                /* this part is QVGA LCD proportion */
                /* In order to make the window is multiple of 4, using 16[=4*4] and 12[=3*4] */
                temp_factor = (lcd_height / 16);
                temp_width = temp_factor * 12;
                while (temp_width > lcd_width)
                {
                    temp_factor--;
                    temp_width = temp_factor * 12;
                }
                temp_height = temp_factor * 16;
            }
        }
    #ifdef DUAL_CAMERA_SUPPORT
        else
        {
            temp_width = LCD_WIDTH;
            temp_height = LCD_HEIGHT;
        }
    #endif /* DUAL_CAMERA_SUPPORT */ 
    #else /* defined(HORIZONTAL_CAMERA) */ 
        temp_width = lcd_width;
        temp_height = lcd_height;
    #endif /* defined(HORIZONTAL_CAMERA) */ 
    }
#if defined(HORIZONTAL_CAMERA)
    else if (capsize == MMI_CAMCO_CAPSIZE_HLCD)
    {
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        if (lcd == MMI_CAMCO_CAM_PREVIEW_SUBLCD)
        {
        #if defined(__MMI_MAINLCD_240X400__)
            temp_factor = (lcd_height / 12);
            temp_width = temp_factor * 20;
            while (temp_width > lcd_width)
            {
                temp_factor--;
                temp_width = temp_factor * 20;
            }
            temp_height = temp_factor * 12;
        #elif defined(__MMI_MAINLCD_320X480__)
            temp_factor = (lcd_height / 8);
            temp_width = temp_factor * 12;
            while (temp_width > lcd_width)
            {
                temp_factor--;
                temp_width = temp_factor * 12;
            }
            temp_height = temp_factor * 8;
        #else 
            temp_factor = (lcd_height / 12);
            temp_width = temp_factor * 16;
            while (temp_width > lcd_width)
            {
                temp_factor--;
                temp_width = temp_factor * 16;
            }
            temp_height = temp_factor * 12;
        #endif 
        }
        else if (lcd == MMI_CAMCO_CAM_PREVIEW_MAINLCD)
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
        {
            /* WQVGA */
            temp_width = lcd_width;
            temp_height = lcd_height;
        }
    }
#endif /* defined(HORIZONTAL_CAMERA) */ /* defined(__MMI_MAINLCD_240X400__) && defined(HORIZONTAL_CAMERA) */
    else
    {
        temp_factor = (lcd_height / 6);
        temp_width = temp_factor * 8;
        while (temp_width > lcd_width)
        {
            temp_factor--;
            temp_width = temp_factor * 8;
        }
        temp_height = temp_factor * 6;
    }
    if(temp_width > MDI_CAMERA_MAX_HW_LAYER_SIZE || temp_height > MDI_CAMERA_MAX_HW_LAYER_SIZE)
	  {
        if(temp_width > temp_height)
        {
			      temp_height = temp_height *  MDI_CAMERA_MAX_HW_LAYER_SIZE / temp_width ;
			      temp_width = MDI_CAMERA_MAX_HW_LAYER_SIZE;
		    }
		    else
		    {
			      temp_width = temp_width * MDI_CAMERA_MAX_HW_LAYER_SIZE / temp_height;	
			      temp_height = MDI_CAMERA_MAX_HW_LAYER_SIZE;	
		    } 
		}
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    if (lcd == MMI_CAMCO_CAM_PREVIEW_SUBLCD)
    {
        g_mmi_camco_cntx.sublcd_preview_wnd.height = temp_height;
        g_mmi_camco_cntx.sublcd_preview_wnd.width = temp_width;
        g_mmi_camco_cntx.sublcd_preview_wnd.offset_x = (lcd_width - temp_width) >> 1;
        g_mmi_camco_cntx.sublcd_preview_wnd.offset_y = (lcd_height - temp_height) >> 1;

    }
    else
#endif
    {        
        g_mmi_camco_cntx.preview_wnd.height = temp_height;
        g_mmi_camco_cntx.preview_wnd.width = temp_width;
        g_mmi_camco_cntx.preview_wnd.offset_x = (lcd_width - temp_width) >> 1;
        g_mmi_camco_cntx.preview_wnd.offset_y = (lcd_height - temp_height) >> 1;
		g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.width;
		g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.height;

		#ifdef HORIZONTAL_CAMERA
		
		if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
		{
		    g_mmi_camco_cntx.quickview_wnd.offset_x = g_mmi_camco_cntx.preview_wnd.offset_y;
			g_mmi_camco_cntx.quickview_wnd.offset_y = g_mmi_camco_cntx.preview_wnd.offset_x;
			g_mmi_camco_cntx.quickview_wnd.height = g_mmi_camco_cntx.preview_wnd.width;
			g_mmi_camco_cntx.quickview_wnd.width = g_mmi_camco_cntx.preview_wnd.height;
		}
		#ifdef DUAL_CAMERA_SUPPORT
		else
		{
			g_mmi_camco_cntx.quickview_wnd.offset_x = g_mmi_camco_cntx.preview_wnd.offset_x;
			g_mmi_camco_cntx.quickview_wnd.offset_y = g_mmi_camco_cntx.preview_wnd.offset_y;
			g_mmi_camco_cntx.quickview_wnd.height = g_mmi_camco_cntx.preview_wnd.height;
			g_mmi_camco_cntx.quickview_wnd.width = g_mmi_camco_cntx.preview_wnd.width;
		}
		#endif
		#else
    		g_mmi_camco_cntx.quickview_wnd.offset_x = g_mmi_camco_cntx.preview_wnd.offset_x;
			g_mmi_camco_cntx.quickview_wnd.offset_y = g_mmi_camco_cntx.preview_wnd.offset_y;
			g_mmi_camco_cntx.quickview_wnd.height = g_mmi_camco_cntx.preview_wnd.height;
			g_mmi_camco_cntx.quickview_wnd.width = g_mmi_camco_cntx.preview_wnd.width;
		#endif
    }
}

#ifndef __MMI_CAMCO_FTE__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_no_card_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_no_card_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_preview_rsk_released);
    mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_preview_no_card_lsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_preview_rsk_released);
    mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_preview_no_card_lsk_released);  
    #endif


#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_preview_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_preview_no_card_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_preview_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SETTINGS, IMG_ID_CAMCO_SETTINGS_SEL, mmi_camco_cam_preview_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_preview_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SETTINGS, IMG_ID_CAMCO_SETTINGS, mmi_camco_cam_preview_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_preview_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_SETTINGS, mmi_camco_cam_preview_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
    {

        if (!mmi_camco_is_from_external())
    	{    	
            mmi_camco_osd_set_csk_img(
                IMG_ID_CAMCO_CAMERA,
                IMG_ID_CAMCO_CAMERA,
                mmi_camco_cam_preview_csk_pressed,
                KEY_EVENT_DOWN);
        }
        else
        {
            mmi_camco_osd_set_csk_img(
                IMG_ID_CAMCO_CAMERA_ONLY,
                IMG_ID_CAMCO_CAMERA_ONLY,
                mmi_camco_cam_preview_csk_pressed,
                KEY_EVENT_DOWN);                        
        } 
        #ifdef AF_SUPPORT
            SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
        #endif
        SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
    #ifdef __MMI_CAMCO_EVB_AF_TEST__
        #ifdef AF_SUPPORT
        {
            SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_1, KEY_EVENT_DOWN);
            SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
        }
        #endif
    #endif /* __MMI_CAMCO_EVB_AF_TEST__ */ 

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_failed_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_failed_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_preview_failed_rsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_preview_failed_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_preview_failed_rsk_released);
#endif 

    SetKeyHandler(NULL, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_setting_menu_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_setting_menu_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
    
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    }    
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_setting_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_setting_menu_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_setting_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_setting_menu_lsk_released);    
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_setting_menu_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_setting_menu_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE); 	
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_add_frame_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_cam_add_frame_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_add_frame_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_add_frame_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_add_frame_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_add_frame_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_setting_menu_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_add_frame_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

}
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_countdown_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_countdown_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_countdown_rsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_countdown_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_countdown_rsk_released);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_save_done_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_save_done_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OPTIONS, IMG_ID_CAMCO_OPTIONS_SEL, mmi_camco_cam_save_done_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_save_done_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OPTIONS, IMG_ID_CAMCO_OPTIONS, mmi_camco_cam_save_done_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_ID_CAMCO_CONTINUE, mmi_camco_cam_save_done_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OPTIONS, mmi_camco_cam_save_done_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

#ifdef __MMI_MMS__
    if (mms_is_ready())
    {
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_FORWARD_TO_MMS,
            IMG_ID_CAMCO_FORWARD_TO_MMS,
            mmi_camco_cam_save_done_csk_released,
            KEY_EVENT_UP);
    }
    else
#endif /* __MMI_MMS__ */ 

    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
    #else
/* under construction !*/
    #endif
#else 
/* under construction !*/
#endif 
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_contshot_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_contshot_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
    SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);

    if (!mmi_camco_is_from_external())
	{    	
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_CAMERA,
            IMG_ID_CAMCO_CAMERA,
            mmi_camco_cam_capture_csk_button_released,
            KEY_EVENT_UP);
    }
    else
    {
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_CAMERA_ONLY,
            IMG_ID_CAMCO_CAMERA_ONLY,
            mmi_camco_cam_capture_csk_button_released,
            KEY_EVENT_UP);                              
    } 
    mmi_camco_osd_set_csk_press();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_cam_burstshot_select_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get the highlight index */
    index = mmi_camco_osd_get_imgselect_hilite_idx();
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_burstshot_select_rsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_burstshot_select_rsk_released);
    #endif
    
#else 
    mmi_camco_osd_set_rsk_str(STR_ID_CAMCO_CONTINUE, mmi_camco_cam_burstshot_select_rsk_released);
#endif 

    if (mmi_camco_cam_p->burstshot.is_saved[index])
    {
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_lsk_img(
                IMG_ID_CAMCO_OPTIONS,
                IMG_ID_CAMCO_OPTIONS_SEL,
                mmi_camco_cam_burstshot_select_lsk_options_released);
        #else
            mmi_camco_osd_set_lsk_img(
                IMG_ID_CAMCO_OPTIONS,
                IMG_ID_CAMCO_OPTIONS,
                mmi_camco_cam_burstshot_select_lsk_options_released);
        #endif
    #else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_osd_set_lsk_str(STR_GLOBAL_OPTIONS, mmi_camco_cam_burstshot_select_lsk_options_released);
    #endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    }
    else
    {
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_lsk_img(
            IMG_ID_CAMCO_SAVE,
            IMG_ID_CAMCO_SAVE_SEL,
            mmi_camco_cam_burstshot_select_lsk_save_released);
        #else
        mmi_camco_osd_set_lsk_img(
            IMG_ID_CAMCO_SAVE,
            IMG_ID_CAMCO_SAVE,
            mmi_camco_cam_burstshot_select_lsk_save_released);        
        #endif
    #else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_osd_set_lsk_str(STR_GLOBAL_SAVE, mmi_camco_cam_burstshot_select_lsk_save_released);
    #endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    }

    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static void mmi_camco_cam_aebshot_select_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get the highlight index */
    index = mmi_camco_osd_get_imgselect_hilite_idx();
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_aebshot_select_rsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_aebshot_select_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_ID_CAMCO_CONTINUE, mmi_camco_cam_aebshot_select_rsk_released);
#endif 
    if (mmi_camco_cam_p->aebshot.is_saved[index])
    {
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
           mmi_camco_osd_set_lsk_img(
               IMG_ID_CAMCO_OPTIONS,
               IMG_ID_CAMCO_OPTIONS_SEL,
               mmi_camco_cam_aebshot_select_lsk_options_released);
        #else
           mmi_camco_osd_set_lsk_img(
               IMG_ID_CAMCO_OPTIONS,
               IMG_ID_CAMCO_OPTIONS,
               mmi_camco_cam_aebshot_select_lsk_options_released);
        #endif
    #else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_osd_set_lsk_str(STR_GLOBAL_OPTIONS, mmi_camco_cam_aebshot_select_lsk_options_released);
    #endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    }
    else
    {
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SAVE, IMG_ID_CAMCO_SAVE_SEL, mmi_camco_cam_aebshot_select_lsk_save_released);
        #else
            mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SAVE, IMG_ID_CAMCO_SAVE, mmi_camco_cam_aebshot_select_lsk_save_released);
        #endif
    #else 
        mmi_camco_osd_set_lsk_str(STR_GLOBAL_SAVE, mmi_camco_cam_aebshot_select_lsk_save_released);
    #endif 

    }

    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_select_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_shot_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_shot_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
  
    
    mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_autorama_shot_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_autorama_shot_lsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_autorama_shot_rsk_released);
    mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_autorama_shot_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_autorama_shot_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_autorama_shot_lsk_released);  

#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_set_csk_action_mode(MMI_TRUE); 
    SetKeyHandler(mmi_camco_cam_autorama_shot_camera_key_pressed, KEY_CAMERA, KEY_EVENT_DOWN);



}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_stitch_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_stitch_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_autorama_stitch_rsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_autorama_stitch_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_autorama_stitch_rsk_released);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_done_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_done_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_autorama_done_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OPTIONS, IMG_ID_CAMCO_OPTIONS_SEL, mmi_camco_cam_autorama_done_lsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_autorama_done_rsk_released);
    mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OPTIONS, IMG_ID_CAMCO_OPTIONS, mmi_camco_cam_autorama_done_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_autorama_done_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_autorama_done_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

#ifdef __MMI_MMS__
    if (mms_is_ready())
    {
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_FORWARD_TO_MMS,
            IMG_ID_CAMCO_FORWARD_TO_MMS,
            mmi_camco_cam_autorama_done_csk_released,
            KEY_EVENT_UP);
    }
    else
#endif /* __MMI_MMS__ */ 

    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_restore_confirm_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_restore_confirm_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_restore_confirm_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_restore_confirm_lsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_restore_confirm_rsk_released);
    mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_restore_confirm_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_NO, mmi_camco_restore_confirm_rsk_released);
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_YES, mmi_camco_restore_confirm_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

}

#endif /* __MMI_CAMCO_FTE__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_focus_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_focus_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(mmi_camco_cam_focus_autofocus_button_released, KEY_CAMERA, KEY_HALF_PRESS_UP);
    SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CSK, KEY_EVENT_DOWN);
#ifdef __MMI_CAMCO_EVB_AF_TEST__
    if (mmi_camco_setting_get_setting_capability(MMI_CAMCO_SETTING_AFRANGE) != MMI_CAMCO_SETTING_CAP_DRV_NOT_SUPPORT &&
        mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFRANGE) != MMI_CAMCO_AFRANGE_INFINTE)
    {
        SetKeyHandler(mmi_camco_cam_focus_autofocus_button_released, KEY_2, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_3, KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_EVB_AF_TEST__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_xenon_flash_callback
 * DESCRIPTION
 *  xenon flash light indicator (from MED) hdlr
 * PARAMETERS
 *  result      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_xenon_flash_callback(mdi_result result, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 ticks;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#define MMI_CAMCO_XENON_STATUS_TIMEOUT_DUR  (60000)

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_XENON_FLASH_RESULT, result);

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_ADD_FRAME)
    {
        kal_get_time(&ticks);

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CURRENT_STATE, g_mmi_camco_cntx.app_state);

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_XENON_FLASH_TIMING, mmi_camco_cam_p->preview_start_ticks, ticks);
        
        switch (result)
        {
            case MDI_RES_CAMERA_SUCCEED:
                mmi_camco_osd_set_xenon_flash_state(MMI_CAMCO_OSD_XENON_FLASH_STATE_SUCCESS);
                break;

            case MDI_RES_CAMERA_XENONFLASH_CHARGING:
                mmi_camco_osd_set_xenon_flash_state(MMI_CAMCO_OSD_XENON_FLASH_STATE_CHARGING);
                break;

            case MDI_RES_CAMERA_ERR_XENONFLASH_TIMEOUT:
                mmi_camco_osd_set_xenon_flash_state(MMI_CAMCO_OSD_XENON_FLASH_STATE_TIMEOUT);
                break;

            case MDI_RES_CAMERA_ERR_XENONFLASH_LOW_BATTERY:
                mmi_camco_osd_set_xenon_flash_state(MMI_CAMCO_OSD_XENON_FLASH_STATE_LOW_BATTERY);
                break;
        }

        if (result == MDI_RES_CAMERA_SUCCEED)
        {
            if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW)
            {
                mmi_camco_osd_draw_osd();
            }
        }
        else
        {
            if ((ticks - mmi_camco_cam_p->preview_start_ticks) * 4.615 > MMI_CAMCO_XENON_STATUS_TIMEOUT_DUR)
            {
                if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW)
                {
                    mmi_camco_osd_draw_osd();
                }
            }
            else
            {
                mmi_camco_osd_set_xenon_flash_state(MMI_CAMCO_OSD_XENON_FLASH_STATE_EXIT);
            }
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_face_detect_result_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_face_detect_result_cyclic(void)
{
#ifdef __FACE_DETECTION_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 idx = 0;
    U16 region_idx;
    mdi_camera_fd_result_struct fd_info;
    MMI_BOOL previous_found = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_FD_CYCLIC);
    mmi_camco_osd_clear_facedetect_region();

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW
#ifdef __SMILE_SHUTTER_SUPPORT__
        || g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SMILE_DECT
#endif 
        )
    {
        mdi_camera_get_fd_result(&fd_info);

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_FD_RESULT, fd_info.fd_result, fd_info.fd_searched_num);

        if (fd_info.fd_result == MDI_RES_CAMERA_SUCCEED)
        {
            mmi_camco_osd_set_facedetect_enable(MMI_TRUE);

            for (idx = 0; idx < fd_info.fd_searched_num; idx++)
            {
                region_idx = idx;
           
                if(idx == 0)
                {
                    mmi_camco_osd_set_facedetect_region(
                        region_idx,
                        MMI_CAMCO_OSD_FACEDETECT_TYPE_FOCUSED,
                        fd_info.fd_zone[idx].fd_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x,
                        fd_info.fd_zone[idx].fd_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y,
                        fd_info.fd_zone[idx].fd_zone_w,
                        fd_info.fd_zone[idx].fd_zone_h);
                }                    
                else
                {
                    mmi_camco_osd_set_facedetect_region(
                        region_idx,
                        MMI_CAMCO_OSD_FACEDETECT_TYPE_TRACKING,
                        fd_info.fd_zone[idx].fd_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x,
                        fd_info.fd_zone[idx].fd_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y,
                        fd_info.fd_zone[idx].fd_zone_w,
                        fd_info.fd_zone[idx].fd_zone_h);                
                }
            }
        }
        else
        {
            previous_found = mmi_camco_osd_get_facedetect_enable();
            mmi_camco_osd_set_facedetect_enable(MMI_FALSE);
        }

        if(!(!previous_found && !mmi_camco_osd_get_facedetect_enable()))
            mmi_camco_osd_draw_osd();
        gui_start_timer(MMI_CAMCO_FACEDETECT_POLLING_TIMER_DUR + 100, mmi_camco_face_detect_result_cyclic);
    }
    else
    {
        mmi_camco_osd_set_facedetect_enable(MMI_FALSE);
    }
#endif /* __FACE_DETECTION_SUPPORT__ */ 
}

#ifdef __FACE_DETECTION_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_face_detect_callback
 * DESCRIPTION
 *  face detect light indicator (from MED) hdlr
 * PARAMETERS
 *  result_ind      [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_face_detect_callback(mdi_camera_fd_result_ind_struct *result_ind, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 idx = 0;
    U16 region_idx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW)
    {
        if (result_ind->fd_result == MDI_RES_CAMERA_SUCCEED)
        {
            mmi_camco_osd_set_facedetect_enable(MMI_TRUE);

            for (idx = 0; idx < result_ind->fd_searched_num; idx++)
            {
                region_idx = idx;
                mmi_camco_osd_set_facedetect_region(
                    region_idx,
                    MMI_CAMCO_OSD_FACEDETECT_TYPE_TRACKING,
                    result_ind->fd_zone[idx].fd_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x,
                    result_ind->fd_zone[idx].fd_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y,
                    result_ind->fd_zone[idx].fd_zone_w,
                    result_ind->fd_zone[idx].fd_zone_h);
            }
        }
        else
        {
            mmi_camco_osd_set_facedetect_enable(MMI_FALSE);
        }

        mmi_camco_osd_draw_osd();
    }
    else
    {
        mmi_camco_osd_set_facedetect_enable(MMI_FALSE);
    }

}
#endif /* __FACE_DETECTION_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_face_detect_start
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * BOOL
 *****************************************************************************/
void mmi_camco_cam_face_detect_start(void)
{
#ifdef __FACE_DETECTION_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_facedetect_start)
    {
        mmi_camco_cam_p->is_facedetect_start = MMI_TRUE;
    }

    if (mmi_camco_cam_p->is_facedetect_start)
    {
        gui_start_timer(MMI_CAMCO_FACEDETECT_POLLING_TIMER_DUR, mmi_camco_face_detect_result_cyclic);
    }
#endif /* __FACE_DETECTION_SUPPORT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_face_detect_stop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * BOOL
 *****************************************************************************/
void mmi_camco_cam_face_detect_stop(void)
{
#ifdef __FACE_DETECTION_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_cam_p->is_facedetect_start)
    {
        gui_cancel_timer(mmi_camco_face_detect_result_cyclic);
        mmi_camco_cam_p->is_facedetect_start = MMI_FALSE;
     
    }
    mmi_camco_osd_set_facedetect_enable(MMI_FALSE);
#endif /* __FACE_DETECTION_SUPPORT__ */ 
}

#ifdef __SMILE_SHUTTER_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_smile_detect_result_cyclic
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_smile_detect_result_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 idx = 0;
    U16 region_idx;
    mdi_camera_fd_result_struct fd_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_osd_clear_smiledetect_region();

    /* to do: set region */

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SMILE_DECT)
    {
        mdi_camera_get_fd_result(&fd_info);

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_FD_RESULT, fd_info.fd_result, fd_info.fd_searched_num);

        if (fd_info.sd_end_flag)
        {
            mmi_camco_osd_set_smiledetect_enable(MMI_TRUE);

            for (idx = 0; idx < fd_info.sd_searched_num; idx++)
            {
                region_idx = idx;
                mmi_camco_osd_set_smiledetect_region(
                    region_idx,
                    MMI_CAMCO_OSD_FACEDETECT_TYPE_TRACKING,
                    fd_info.fd_zone[idx].sd_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x,
                    fd_info.fd_zone[idx].sd_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y,
                    fd_info.fd_zone[idx].sd_zone_w,
                    fd_info.fd_zone[idx].sd_zone_h);
            }
        }
        else
        {
            mmi_camco_osd_set_smiledetect_enable(MMI_FALSE);
        }

        mmi_camco_osd_draw_osd();

        if (fd_info.sd_end_flag)
        {
            mmi_camco_cam_smiledetec_camera_key_pressed();
        }
        else
        {
            gui_start_timer(MMI_CAMCO_FACEDETECT_POLLING_TIMER_DUR, mmi_camco_smile_detect_result_cyclic);
        }
    }
    else
    {
        mmi_camco_osd_set_facedetect_enable(MMI_FALSE);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_sd_dummy_cb
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sd_event_p      [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_sd_dummy_cb(mdi_camera_sd_event_struct *sd_event_p, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smile_detect_start
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * BOOL
 *****************************************************************************/
void mmi_camco_cam_smile_detect_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_smiledetect_start)
    {

        ret = mdi_camera_start_sd(mmi_camco_sd_dummy_cb, NULL);
        if (ret == MDI_RES_CAMERA_SUCCEED)
        {
            mmi_camco_cam_p->is_smiledetect_start = MMI_TRUE;
        }
    }

    if (mmi_camco_cam_p->is_smiledetect_start)
    {
        gui_start_timer(MMI_CAMCO_FACEDETECT_POLLING_TIMER_DUR, mmi_camco_smile_detect_result_cyclic);
    }
    mmi_camco_osd_set_zoom_ev_enable(MMI_FALSE);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smile_detect_stop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * BOOL
 *****************************************************************************/
void mmi_camco_cam_smile_detect_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_cam_p->is_smiledetect_start)
    {
        ret = mdi_camera_stop_sd();
        if (ret == MDI_RES_CAMERA_SUCCEED)
        {
            gui_cancel_timer(mmi_camco_smile_detect_result_cyclic);
            mmi_camco_cam_p->is_smiledetect_start = MMI_FALSE;
        }
    }
    mmi_camco_osd_set_smiledetect_enable(MMI_FALSE);
    mmi_camco_osd_set_zoom_ev_enable(MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smiledetec_camera_key_pressed
 * DESCRIPTION
 *  recorder record botton pressed handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_smiledetec_camera_key_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FTE__    

    mmi_camco_osd_csk_set_press(MMI_TRUE);     
    mmi_camco_osd_draw_osd();    
#endif

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);    
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
#ifndef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_csk_img(
        IMG_ID_CAMCO_CAMERA_ONLY,
        IMG_ID_CAMCO_CAMERA_ONLY,
        mmi_camco_cam_capture_csk_button_released,
        KEY_EVENT_UP);                                   

    mmi_camco_osd_set_csk_press();
    mmi_camco_osd_draw_osd();
#else    
    mmi_camco_osd_draw_osd();    
#endif /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_cam_capture();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smiledetect_capture_button_pressed
 * DESCRIPTION
 *  camera capture botton pressed handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_smiledetect_capture_button_pressed(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_smiledetec_camera_key_pressed();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smileshot_rsk_released
 * DESCRIPTION
 *  rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_smileshot_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
}

#ifndef __MMI_CAMCO_FTE__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smiledetect_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_smiledetect_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_smileshot_rsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_smileshot_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_smileshot_rsk_released);
#endif 

    if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
    {        
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_CAMERA_ONLY,
            IMG_ID_CAMCO_CAMERA_ONLY,
            mmi_camco_cam_smiledetect_capture_button_pressed,
            KEY_EVENT_DOWN);                                                       
        SetKeyHandler(mmi_camco_cam_smiledetec_camera_key_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_UP);

    }
}
#endif /* __MMI_CAMCO_FTE__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_smile_dect_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_smile_dect_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_ON)
    {
        mmi_camco_cam_face_detect_start();
    }
    mmi_camco_cam_smile_detect_start();
    mmi_camco_need_restart_preview();
    if (mmi_camco_cam_p->is_smiledetect_start)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_SMILE_DECT;

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_smile_dect_evt_hdlr);
        if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {
            SetKeyHandler(mmi_camco_cam_smiledetec_camera_key_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
            SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_UP);
            g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
        }
        else
        {
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
        }
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_smiledetect_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();
    }
    else
    {
        mmi_camco_show_error_msg(MDI_RES_CAMERA_ERR_CAPTURE_FAILED);    /* to do : change the error id */
        mmi_camco_error_hdlr_timer_start();
    }
}
#endif /* __SMILE_SHUTTER_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_power_on
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_power_on(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    U16 cam_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cam_id = (U16) mmi_camco_get_cmd_camera_id(mmi_camco_setting_get_active_cam());
    mdi_camera_set_camera_id(cam_id);

    ret = mdi_camera_power_on(g_mmi_camco_cntx.memory_group_id);

    if (ret == MDI_RES_CAMERA_SUCCEED)
    {
        g_mmi_camco_cntx.is_power_on = MMI_TRUE;
    }
    else
    {
        g_mmi_camco_cntx.is_power_on = MMI_FALSE;
    }

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_power_off
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * BOOL
 *****************************************************************************/
static void mmi_camco_cam_power_off(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_highlight_turn_off();
    if (g_mmi_camco_cntx.is_power_on)
    {
        mdi_camera_power_off();
        g_mmi_camco_cntx.is_power_on = MMI_FALSE;
    }


}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_start
 * DESCRIPTION
 *  start previewing on main LCD
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_camco_cam_preview_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = FALSE;
    MDI_RESULT result;
    U8 capmode;
    mdi_camera_setting_struct camera_setting_data;
    mdi_camera_preview_struct camera_preview_data;
    U32 preview_layer_flag = 0;
    U32 blt_layer_flag = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    camera_setting_data.image_resolution = mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);

    mmi_camco_cam_config_preview_layer();

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT)
    {
        mmi_camco_osd_set_blt_layer(MMI_CAMCO_OSD_STATE_AUTORAMA_SHOT);
    }
    else
    {
        mmi_camco_osd_set_blt_layer(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);
        mmi_camco_osd_draw_osd();
    }
    

    /* preview parametes */
    camera_setting_data.zoom = mmi_camco_get_camzoom();
    camera_setting_data.wb = mmi_camco_get_cmd_wb(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_WB));
    camera_setting_data.ev = mmi_camco_get_cmd_ev(mmi_camco_setting_get_camev_value());
    camera_setting_data.banding = mmi_camco_get_cmd_banding(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_BANDING));
    if(mmi_camco_setting_flash_is_enable())
    {
        camera_setting_data.flash = mmi_camco_get_cmd_flash(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FLASH));
    }        
    else
    {
        if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_HIGHLIGHT) == MMI_CAMCO_HIGHLIGHT_OFF)
            camera_setting_data.flash = mmi_camco_get_cmd_flash(MMI_CAMCO_FLASH_OFF);        
        else
            camera_setting_data.flash = mmi_camco_get_cmd_flash(MMI_CAMCO_FLASH_FORCE_ON);                
    }   

    camera_setting_data.iso = mmi_camco_get_cmd_iso(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_ISO));
    camera_setting_data.ae_meter = mmi_camco_get_cmd_aemeter(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AEMETER));
    camera_setting_data.scene_mode = mmi_camco_get_cmd_camscenemode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAMSCENEMODE));
    camera_setting_data.effect = mmi_camco_get_cmd_effect(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_EFFECT));
    camera_setting_data.saturation = mmi_camco_get_cmd_saturation(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SATURATION));
    camera_setting_data.contrast = mmi_camco_get_cmd_contrast(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CONTRAST));
    camera_setting_data.hue = 0;

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (mmi_camco_osd_is_add_frame_enable() && !mmi_camco_osd_is_time_stamp_enable())
    {
        U8 overlay_palette_size = 0;
        U32 *overlay_palette_addr = NULL;

        mmi_camco_osd_draw_add_frame_color_idx_on_layer(&overlay_palette_size, &overlay_palette_addr);

        camera_setting_data.overlay_frame_mode = TRUE;
        camera_setting_data.overlay_frame_depth = MDI_CAMERA_OVERLAY_8BPP;
        camera_setting_data.overlay_frame_width = g_mmi_camco_cntx.preview_wnd.width;
        camera_setting_data.overlay_frame_height = g_mmi_camco_cntx.preview_wnd.height;
        camera_setting_data.overlay_frame_source_key = gdi_image_gif_get_transparent_index();
        camera_setting_data.overlay_frame_buffer_address = (U32) mmi_camco_osd_get_overlay_frame_buf();

        camera_setting_data.overlay_palette_size = 255;
        camera_setting_data.overlay_palette_addr = overlay_palette_addr;
    }
    else
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
    {
        camera_setting_data.overlay_frame_mode = FALSE;
        camera_setting_data.overlay_frame_depth = 0;
        camera_setting_data.overlay_frame_width = 0;
        camera_setting_data.overlay_frame_height = 0;
        camera_setting_data.overlay_frame_source_key = 0;
        camera_setting_data.overlay_frame_buffer_address = 0;

        camera_setting_data.overlay_palette_size = 0;
        camera_setting_data.overlay_palette_addr = NULL;
    }
    camera_setting_data.preview_width = g_mmi_camco_cntx.preview_wnd.width;
    camera_setting_data.preview_height = g_mmi_camco_cntx.preview_wnd.height;

    /* capture parameters */
    camera_setting_data.image_qty = mmi_camco_get_cmd_capqty(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPQTY));
    camera_setting_data.image_width = mmi_camco_cam_p->image_width;
    camera_setting_data.image_height = mmi_camco_cam_p->image_height;

    if (mmi_camco_get_flash_type() == MMI_CAMCO_FLASH_TYPE_XENON)
    {
        camera_setting_data.xenon_flash_status_callback = mmi_camco_xenon_flash_callback;
    }
    else
    {
        camera_setting_data.xenon_flash_status_callback = NULL;
    }

    if (mmi_camco_get_flash_type() == MMI_CAMCO_FLASH_TYPE_LED &&
        mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_EV_BRACKET_SEL)
    {
        camera_setting_data.flash = mmi_camco_get_cmd_flash(MMI_CAMCO_FLASH_OFF);
    }
    else if (mmi_camco_get_flash_type() == MMI_CAMCO_FLASH_TYPE_XENON &&
             mmi_camco_setting_get_setting_capability(MMI_CAMCO_SETTING_FLASH) != MMI_CAMCO_SETTING_CAP_ENABLED)
    {
        camera_setting_data.flash = mmi_camco_get_cmd_flash(MMI_CAMCO_FLASH_OFF);
    }
#ifdef __FACE_DETECTION_SUPPORT__
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_ON)
    {
        camera_setting_data.fd_enable = TRUE;
        camera_setting_data.fd_callback = mmi_camco_face_detect_callback;
    }
    else
    {
        camera_setting_data.fd_enable = FALSE;
        camera_setting_data.fd_callback = NULL;
    }
#endif /* __FACE_DETECTION_SUPPORT__ */ 
    camera_setting_data.lcm = MDI_CAMERA_PREVIEW_LCM_MAINLCD;

//    camera_setting_data.continue_capture = mmi_camco_cam_p->is_continue_capture;
    camera_setting_data.af_range = mmi_camco_get_cmd_afrange(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFRANGE));
    camera_setting_data.af_operation_mode = mmi_camco_get_cmd_afzone(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFZONE));
    camera_setting_data.sharpness = mmi_camco_get_cmd_sharpness(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SHARPNESS));
        
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT)
    {
        blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1 | GDI_LAYER_ENABLE_LAYER_2;
    }
    else
    {
        blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1;
    }

    preview_layer_flag = GDI_LAYER_ENABLE_LAYER_0;

    camera_preview_data.preview_layer_handle = g_mmi_camco_cntx.base_layer_handle;
    camera_preview_data.blt_layer_flag = blt_layer_flag;
    camera_preview_data.preview_layer_flag = preview_layer_flag;
    camera_preview_data.is_lcd_update = TRUE;
    camera_preview_data.src_key_color = GDI_COLOR_TRANSPARENT;
    camera_preview_data.is_tvout = FALSE;

    if (mmi_camco_cam_p->is_reset_zoom)
    {
        camera_setting_data.zoom = mmi_camco_setting_get_camzoom_minstep();
        mmi_camco_cam_p->is_reset_zoom = MMI_FALSE;
    }
    capmode = mmi_camco_get_cmd_capmode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE));
    //result = mdi_camera_preview_start(&camera_preview_data, &camera_setting_data, NULL);
    result = mdi_camera_preview_start_with_capmode(&camera_preview_data,&camera_setting_data,capmode,NULL);

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_CAM_PREVIEW_START, result);
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__) 
	kal_set_timer(resz_cp_ESD_timeout_timer, (kal_timer_func_ptr)resz_cp_ESD_timeout_timer_hdlr,NULL, KAL_TICKS_3_SEC, 0);
#endif

    if (result == MDI_RES_CAMERA_SUCCEED)
    {
        ret = TRUE;
    }
    return ret;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_stop
 * DESCRIPTION
 *  stop previewing on main LCD
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_preview_start)
    {
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_ON)
        {
            mmi_camco_cam_face_detect_stop();
        }
    #ifdef __SMILE_SHUTTER_SUPPORT__
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_SMILE_SHOT)
        {
            mmi_camco_cam_smile_detect_stop();
        }
    #endif /* __SMILE_SHUTTER_SUPPORT__ */ 
       if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ASD_SHOT)
        {
            mmi_camco_cam_scene_detect_stop();
        }
	   #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
        gui_cancel_timer(mmi_camco_cam_autorama_detect_capinfo_cyclic);
	   #endif
        mdi_camera_preview_stop();
        g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
	#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
 		kal_cancel_timer(resz_cp_ESD_timeout_timer);  
	#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autofocus_start
 * DESCRIPTION
 *  camera start to focus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autofocus_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_camera_start_autofocus_process(mmi_camco_cam_autofocus_result_hdlr, NULL);

    mmi_camco_cam_p->is_autofocus_on = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autofocus_stop
 * DESCRIPTION
 *  camera stop to focus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autofocus_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_cam_p->is_autofocus_on)
    {
        mdi_camera_stop_autofocus_process();

        mmi_camco_cam_p->is_autofocus_on = MMI_FALSE;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_scene_detect_start
 * DESCRIPTION
 *  camera start to detect scene for asd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

 void mmi_camco_cam_scene_detect_start(void)
{
#ifdef __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_asd_start)
    {
        mmi_camco_cam_p->is_asd_start = MMI_TRUE;
    }

    if (mmi_camco_cam_p->is_asd_start)
    {
        gui_start_timer(MMI_CAMCO_ASD_POLLING_TIMER_DUR, mmi_camco_cam_scene_detect_cyclic);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__ */ 

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_scene_detect_stop
 * DESCRIPTION
 *  camera stop to detect scene
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/    
 void mmi_camco_cam_scene_detect_stop(void)
{
#ifdef __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_cam_p->is_asd_start)
    {
        gui_cancel_timer(mmi_camco_cam_scene_detect_cyclic);

        mmi_camco_cam_p->is_asd_start = MMI_FALSE;
    }        
#endif /* __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__ */ 

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_scene_detect_cyclic
 * DESCRIPTION
 *  camera detect scene in a cyclic
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_scene_detect_cyclic(void)
{
#ifdef __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 scene_mode;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ASD_SHOT)
    {
        scene_mode = MDI_CAMERA_SCENE_MODE_AUTO;
        scene_mode = mdi_camera_get_detected_scene_mode();

        switch (scene_mode)
        {
            case MDI_CAMERA_SCENE_MODE_AUTO:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_AUTO;
                break;

            case MDI_CAMERA_SCENE_MODE_PORTRAIT:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_PORTRAIT;
                break;

            case MDI_CAMERA_SCENE_MODE_LANDSCAPE:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_LANDSCAPE;
                break;

            case MDI_CAMERA_SCENE_MODE_NIGHT:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_NIGHT;
                break; 

            case MDI_CAMERA_SCENE_MODE_BACKLIGHT:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_BACKLIGHT;
                 break;

            case MDI_CAMERA_SCENE_MODE_NIGHT_PORTRAIT:
                 scene_mode = MMI_CAMCO_CAMSCENEMODE_NIGHT_PORTRAIT;
                 break;

            case MDI_CAMERA_SCENE_MODE_SPORT:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_SPORT;
                break;
                
            case MDI_CAMERA_SCENE_MODE_FLOWER:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_FLOWER;
                break;           
                
            case MDI_CAMERA_SCENE_MODE_BACKLIGHT_PORTRAIT:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_BACKLIGHT_PORTRAIT;
                break;
                
            case MDI_CAMERA_SCENE_MODE_DOCUMENT:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_DOCUMENT;
                break;

            case MDI_CAMERA_SCENE_MODE_ISO_ANTI_HAND_SHAKE:
                scene_mode = MMI_CAMCO_CAMSCENEMODE_ANTI_SHAKE;
                break;

            default: 
                MMI_ASSERT(0);
                break;
        }
        
        
        mmi_camco_setting_set_camscene_mode(scene_mode);
       
        mmi_camco_osd_gen_camera_status_icon();

        mmi_camco_osd_draw_osd();        
    }      
    if (mmi_camco_cam_p->is_asd_start)
    {
        gui_start_timer(MMI_CAMCO_ASD_POLLING_TIMER_DUR, mmi_camco_cam_scene_detect_cyclic);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_ASD_SHOT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_capture
 * DESCRIPTION
 *  camera start to capture
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_capture(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 capmode;
    U8 rotate;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_PREVIEW &&
#ifdef __SMILE_SHUTTER_SUPPORT__
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_SMILE_DECT &&
#endif 
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_SUB_PREVIEW &&
#endif 
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_FOCUSING &&
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_FOCUSED &&
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_COUNTDOWN)
    {
        return;
    }
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
#endif
    capmode = mmi_camco_get_capmode();
	mmi_camco_set_quickview_color_format();
	rotate = 0;
	#ifdef HORIZONTAL_CAMERA
	 if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	 {
		 rotate = 1;
	 }
	#endif
#ifdef __CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__
    if(capmode != MMI_CAMCO_CAPMODE_AUTORAMA && capmode != MMI_CAMCO_CAPMODE_MAV&& capmode != MMI_CAMCO_CAPMODE_3D_IMAGE)
    {
    rotate = mmi_camco_get_capture_value();
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.preview_base_layer_handle);
    if(gdi_layer_get_rotate()==GDI_LAYER_ROTATE_90)
    {
		if(rotate == MDI_CAMERA_UI_ROTATE_0||rotate == MDI_CAMERA_UI_ROTATE_180)
		{
			mdi_camera_update_para_image_size(mmi_camco_cam_p->image_height,mmi_camco_cam_p->image_width);
			g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.height;
			g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.width;

		}
		else
		{

		    mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width,mmi_camco_cam_p->image_height);
		    g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.width;
		    g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.height;

		}
	}
	else
	{
		if(rotate == MDI_CAMERA_UI_ROTATE_90||rotate == MDI_CAMERA_UI_ROTATE_270)
		{
			mdi_camera_update_para_image_size(mmi_camco_cam_p->image_height,mmi_camco_cam_p->image_width);
			g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.height;
			g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.width;
		}
		else
		{
		    mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width,mmi_camco_cam_p->image_height);
		    g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.width;
		    g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.height;
		}
			
	}
	gdi_layer_pop_and_restore_active();
    }
#endif
    mdi_camera_set_capture_rotation(rotate);

    /* 
     * Add frame doesn't support timestamp and 
     * Continue shot will add timestamp in cyclic later.
     */
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (mmi_camco_osd_is_time_stamp_enable() &&
        capmode != MMI_CAMCO_CAPMODE_ADD_FRAME && capmode != MMI_CAMCO_CAPMODE_CONT_SHOT)
    {
        U8 overlay_palette_size = 0;
        U32 *overlay_palette_addr = NULL;
        mdi_camera_overlay_struct timestamp_overlay;
        S32 overlay_width = 0;
        S32 overlay_height = 0;

        mmi_camco_osd_draw_time_stamp_color_idx_on_layer(
            &overlay_palette_size,
            &overlay_palette_addr,
            &overlay_width,
            &overlay_height);

        timestamp_overlay.overlay_frame_mode = TRUE;
        timestamp_overlay.overlay_frame_depth = MDI_CAMERA_OVERLAY_8BPP;
        timestamp_overlay.overlay_frame_width = overlay_width;
        timestamp_overlay.overlay_frame_height = overlay_height;
        timestamp_overlay.overlay_frame_source_key = gdi_image_bmp_get_transparent_index();
        timestamp_overlay.overlay_frame_buffer_address = (U32) mmi_camco_osd_get_overlay_frame_buf();

        timestamp_overlay.overlay_palette_size = 255;
        timestamp_overlay.overlay_palette_addr = overlay_palette_addr;

        mdi_camera_update_overlay_data(&timestamp_overlay);

    }
    else if (mmi_camco_osd_is_add_frame_enable() && capmode == MMI_CAMCO_CAPMODE_ADD_FRAME)
    {
            U8 overlay_palette_size = 0;
            U32 *overlay_palette_addr = NULL;
            mdi_camera_overlay_struct addframe_overlay;
            S32 overlay_width = 0;
            S32 overlay_height = 0;

            mmi_camco_osd_draw_add_frame_color_idx_cap_on_layer(&overlay_palette_size, &overlay_palette_addr);
			mmi_camco_osd_get_add_frame_size(&overlay_width,&overlay_height);

            addframe_overlay.overlay_frame_mode = TRUE;
            addframe_overlay.overlay_frame_depth = MDI_CAMERA_OVERLAY_8BPP;
            addframe_overlay.overlay_frame_width = overlay_width;
            addframe_overlay.overlay_frame_height = overlay_height;
            addframe_overlay.overlay_frame_source_key = gdi_image_gif_get_transparent_index();
            addframe_overlay.overlay_frame_buffer_address = (U32) mmi_camco_osd_get_overlay_frame_cap_buf();

            addframe_overlay.overlay_palette_size = 255;
            addframe_overlay.overlay_palette_addr = overlay_palette_addr;

            mdi_camera_update_overlay_data(&addframe_overlay);

    }
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
    switch (capmode)
    {
    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
        case MMI_CAMCO_CAPMODE_ADD_FRAME:
    #endif 
        case MMI_CAMCO_CAPMODE_NORMAL:
        case MMI_CAMCO_CAPMODE_BEST_SHOT:
    #ifdef __SMILE_SHUTTER_SUPPORT__
        case MMI_CAMCO_CAPMODE_SMILE_SHOT:
    #endif 
        case MMI_CAMCO_CAPMODE_ZSD_SHOT:
        case MMI_CAMCO_CAPMODE_ASD_SHOT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_CAPTURE);
            break;

        case MMI_CAMCO_CAPMODE_CONT_SHOT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_CONTSHOT);
            break;

        case MMI_CAMCO_CAPMODE_BURST_SHOT_SEL:
    #ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_BURSTSHOT);
    #endif 
            break;

        case MMI_CAMCO_CAPMODE_EV_BRACKET_SEL:
    #ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AEBSHOT);
    #endif 
            break;

        case MMI_CAMCO_CAPMODE_AUTORAMA:
    #ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
            mmi_camco_cam_p->autorama_shot.capture_count = 0;
            g_mmi_camco_cntx.cam.autorama_shot.direction = MMI_CAMCO_AUTORAMA_DIRECTION_RIGHT;
            g_mmi_camco_cntx.cam.autorama_shot.last_capture_time = 0;
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT);
    #endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
            break;

        case MMI_CAMCO_CAPMODE_HDR_SHOT:
    #ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_HDR_SHOT);    
    #endif
	        break;
	    case MMI_CAMCO_CAPMODE_MAV:
		case MMI_CAMCO_CAPMODE_3D_IMAGE:
	#ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__
	       mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_MAV_SHOT);
    #endif
            break;
        default:
            MMI_ASSERT(0);
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_normal_shot
 * DESCRIPTION
 *  camera capture [general]
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_normal_shot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;
    U8 *dst_p;
    S32 width, height, buf_size;
    //S32 offset_x, offset_y;
#ifdef __CAMCO_QUICK_VIEW_ROTATE_SHRAE_APP_MEM__
    U8* temp_ptr;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MTK_TARGET__
    if (mdi_camera_is_ready_to_capture())
#endif 
    {  
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
        gdi_layer_resize(g_mmi_camco_cntx.quickview_wnd.width, g_mmi_camco_cntx.quickview_wnd.height);
        gdi_layer_set_position(g_mmi_camco_cntx.quickview_wnd.offset_x, g_mmi_camco_cntx.quickview_wnd.offset_y);
        gdi_layer_pop_and_restore_active();

        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_get_dimension(&width, &height);
        buf_size = (width * height * gdi_layer_get_bit_per_pixel()) >> 3;
        gdi_layer_get_buffer_ptr(&dst_p);
   
        mdi_camera_set_quickview_rotation(0);
    #ifdef __CAMCO_QUICK_VIEW_ROTATE_SHRAE_APP_MEM__
        temp_ptr = mmi_camco_osd_get_init_mem();
        mdi_camera_set_quickview_extra_buffer((U32)temp_ptr,buf_size);
    #endif
        ret = mdi_camera_capture_with_quickview(
                (U32)dst_p,
                buf_size,
                g_mmi_camco_cntx.quickview_image_width,
                g_mmi_camco_cntx.quickview_image_height,
                mmi_camco_cam_p->buf_filename_p);
        if (ret == MDI_RES_CAMERA_SUCCEED)
            ret = mdi_camera_encode_capture_image(&mmi_camco_cam_p->capture_buf_ptr, &mmi_camco_cam_p->capture_size); 


		gdi_layer_pop_and_restore_active();
    }
    return ret;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_addframe_shot
 * DESCRIPTION
 *  camera capture [add frame]
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static MDI_RESULT mmi_camco_cam_addframe_shot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MMI_CAMCO_CAM_NOT_READY;
    U8 *dst_p;
    S32 width, height, buf_size;
    //S32 offset_x, offset_y;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MTK_TARGET__
    if (mdi_camera_is_ready_to_capture())
#endif 
    {
        /* Improve capture precedure */

        gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
        gdi_layer_resize(g_mmi_camco_cntx.quickview_wnd.width, g_mmi_camco_cntx.quickview_wnd.height);
        gdi_layer_set_position(g_mmi_camco_cntx.quickview_wnd.offset_x, g_mmi_camco_cntx.quickview_wnd.offset_y);
        gdi_layer_pop_and_restore_active();

        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_get_dimension(&width, &height);
        buf_size = (width * height * gdi_layer_get_bit_per_pixel()) >> 3;
        gdi_layer_get_buffer_ptr(&dst_p);
		mdi_camera_set_quickview_rotation(0);

        ret = mdi_camera_capture_with_quickview(
                (U32)dst_p,
                buf_size,
                g_mmi_camco_cntx.quickview_wnd.width,
                g_mmi_camco_cntx.quickview_wnd.height,
                mmi_camco_cam_p->buf_filename_p);


        if (ret == MDI_RES_CAMERA_SUCCEED)
            ret = mdi_camera_encode_capture_image(&mmi_camco_cam_p->capture_buf_ptr, &mmi_camco_cam_p->capture_size);

		gdi_layer_pop_and_restore_active();

}
    return ret;
}
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_bestshot
 * DESCRIPTION
 *  camera capture [bestshot]
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_bestshot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MMI_CAMCO_CAM_NOT_READY;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mdi_camera_is_ready_to_capture())
    {
        ret = mdi_camera_capture_to_memory_best_shot(
                &mmi_camco_cam_p->capture_buf_ptr,
                &mmi_camco_cam_p->capture_size,
                (U8*) mmi_camco_cam_p->multishot_mem_pool,
                MMI_CAMCO_CAM_MULTISHOT_MEM_SIZE);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_contshot
 * DESCRIPTION
 *  camera capture [contshot]
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_contshot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MMI_CAMCO_CAM_NOT_READY;
    //U8 *capimg_ptr;
    //U32 captured_size;
    U8 *dst_p;
    S32 width, height;
		U8 rotate;

    S32 buf_size;
    //S32 offset_x, offset_y; 
#ifdef __CAMCO_QUICK_VIEW_ROTATE_SHRAE_APP_MEM__
		U8* temp_ptr;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
    gdi_layer_get_dimension(&width, &height);
    buf_size = (width * height * gdi_layer_get_bit_per_pixel()) >> 3;
    gdi_layer_get_buffer_ptr(&dst_p);

    rotate = 0;
#ifdef HORIZONTAL_CAMERA
	 if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	 {
		 rotate = 1;
	 }
#endif
#ifdef __CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__
	rotate = mmi_camco_get_capture_value();
	gdi_layer_push_and_set_active(g_mmi_camco_cntx.preview_base_layer_handle);
    if(gdi_layer_get_rotate()==GDI_LAYER_ROTATE_90)
    {
		if(rotate == MDI_CAMERA_UI_ROTATE_0||rotate == MDI_CAMERA_UI_ROTATE_180)
		{
			mdi_camera_update_para_image_size(mmi_camco_cam_p->image_height,mmi_camco_cam_p->image_width);
			g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.height;
			g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.width;

		}
		else
		{

		    mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width,mmi_camco_cam_p->image_height);
		    g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.width;
		    g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.height;

		}
	}
	else
	{
		if(rotate == MDI_CAMERA_UI_ROTATE_90||rotate == MDI_CAMERA_UI_ROTATE_270)
		{
			mdi_camera_update_para_image_size(mmi_camco_cam_p->image_height,mmi_camco_cam_p->image_width);
			g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.height;
			g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.width;
		}
		else
		{
		    mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width,mmi_camco_cam_p->image_height);
		    g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.width;
		    g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.height;
		}
			
	}
	gdi_layer_pop_and_restore_active();
#endif
	mdi_camera_set_capture_rotation(rotate);
	mdi_camera_set_quickview_rotation(0);
#ifdef __CAMCO_QUICK_VIEW_ROTATE_SHRAE_APP_MEM__
    temp_ptr = mmi_camco_osd_get_init_mem();
    mdi_camera_set_quickview_extra_buffer((U32)temp_ptr,buf_size);
#endif

    ret = mdi_camera_capture_continuous_shot_with_quickview(
                (U32)dst_p,
                (U32)buf_size,
				g_mmi_camco_cntx.quickview_image_width,
				g_mmi_camco_cntx.quickview_image_height,
                mmi_camco_cam_p->buf_filename_p);



    if (ret == MDI_RES_CAMERA_SUCCEED)
    {
        ret = mmi_camco_cam_save_capture_image();
	}

    gdi_layer_pop_and_restore_active();

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_contshot_cyclic
 * DESCRIPTION
 *  camera continuous shot
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_contshot_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_CONTSHOT);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    if (mmi_camco_osd_is_time_stamp_enable())
    {
        U8 overlay_palette_size = 0;
        U32 *overlay_palette_addr = NULL;
        mdi_camera_overlay_struct timestamp_overlay;
        S32 overlay_width = 0;
        S32 overlay_height = 0;

        mmi_camco_osd_draw_time_stamp_color_idx_on_layer(
            &overlay_palette_size,
            &overlay_palette_addr,
            &overlay_width,
            &overlay_height);

        timestamp_overlay.overlay_frame_mode = TRUE;
        timestamp_overlay.overlay_frame_depth = MDI_CAMERA_OVERLAY_8BPP;
        timestamp_overlay.overlay_frame_width = overlay_width;
        timestamp_overlay.overlay_frame_height = overlay_height;
        timestamp_overlay.overlay_frame_source_key = gdi_image_bmp_get_transparent_index();
        timestamp_overlay.overlay_frame_buffer_address = (U32) mmi_camco_osd_get_overlay_frame_buf();

        timestamp_overlay.overlay_palette_size = 255;
        timestamp_overlay.overlay_palette_addr = overlay_palette_addr;

        mdi_camera_update_overlay_data(&timestamp_overlay);

    }
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


    result = mmi_camco_cam_contshot();
    if (result == MDI_RES_CAMERA_SUCCEED)    
        mmi_camco_cam_play_shuttersound(mmi_camco_get_shuttersound());

    if (result != MDI_RES_CAMERA_SUCCEED)
    {
        U16 string_id;
        mmi_event_notify_enum popup_type;
        srv_prof_tone_enum tone_type;

        /* Camco is in MMI_CAMCO_STATE_CAM_PREVIEW or MMI_CAMCO_STATE_CAM_FOCUSING or 
           MMI_CAMCO_STATE_CAM_FOCUSED or MMI_CAMCO_STATE_CAM_CONTSHOT */
        mmi_camco_cam_p->is_takepic_failed = MMI_TRUE;

        if (mmi_camco_cam_p->is_autofocus_on)
        {
            mmi_camco_cam_autofocus_stop();
        }
        mmi_camco_cam_restore_filename_seq_no();

        mmi_camco_cam_preview_stop();


        string_id = mmi_camco_mapping_error_string(result, &popup_type);
        tone_type = mmi_get_event_based_sound(popup_type);
        if (tone_type != NONE_TONE)
        {
            srv_prof_play_tone(tone_type, NULL);
        }
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle,MMI_TRUE);
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);  
        mmi_camco_osd_set_bg_black(); 
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);        
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_CONTSHOT);

        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(string_id));
        mmi_camco_osd_draw_osd();

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_contshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_contshot_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_need_restart_preview();

        kal_sleep_task(300);
    }
    else
    {
    	/*open and enable color engine for quickview image*/
		if(!g_mmi_camco_cntx.is_color_engine_enable)
		{
			mdi_camera_color_engine_open();
			mdi_camera_color_engine_enable();
			g_mmi_camco_cntx.is_color_engine_enable = MMI_TRUE;
		}
        // quick view will be layer buffer, just change base layer, no need to clear buffer            
        g_mmi_camco_cntx.is_priview_layer_active = MMI_FALSE;
        g_mmi_camco_cntx.base_layer_handle = g_mmi_camco_cntx.non_preview_base_layer_handle;
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);   
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_CONTSHOT);
        mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.non_preview_base_layer_handle);
        mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.preview_base_layer_handle);           

    #ifndef __MMI_CAMCO_FTE__
        if (!mmi_camco_is_from_external())
    	{    	
            mmi_camco_osd_set_csk_img(
                IMG_ID_CAMCO_CAMERA,
                IMG_ID_CAMCO_CAMERA,
                mmi_camco_cam_capture_csk_button_released,
                KEY_EVENT_UP);
        }
        else
        {
            mmi_camco_osd_set_csk_img(
                IMG_ID_CAMCO_CAMERA_ONLY,
                IMG_ID_CAMCO_CAMERA_ONLY,
                mmi_camco_cam_capture_csk_button_released,
                KEY_EVENT_UP);
        }        
        mmi_camco_osd_set_csk_press();
    #else
        mmi_camco_osd_csk_set_press(MMI_TRUE);    
    #endif /* __MMI_CAMCO_FTE__ */             
        mmi_camco_osd_draw_osd();

        // change to preview layer for the next cont shot (will start preview)
        g_mmi_camco_cntx.is_priview_layer_active = MMI_TRUE;
        g_mmi_camco_cntx.base_layer_handle = g_mmi_camco_cntx.preview_base_layer_handle;
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);   
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_CONTSHOT);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_contshot_select_evt_hdlr);
        SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_cam_contshot_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 


    #ifdef MMI_CAMCO_CONTINUE_SHOT_AEAWB_ENABLE
        if (TRUE == mmi_camco_cam_preview_start())
        {
            g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
        }
        else
        {
            g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
            mmi_camco_enter_cam_preview_failed_state();
        }
    #endif /* MMI_CAMCO_CONTINUE_SHOT_AEAWB_ENABLE */ 

    if(g_mmi_camco_cntx.is_camera_key_release == MMI_TRUE )
     {
         mmi_camco_cam_capture_button_released();
     }
      else
     {
          gui_start_timer(MMI_CAMCO_CONTSHOT_TIMER_DUR, mmi_camco_cam_contshot_cyclic);
    
     }

    #if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 
    }
}

#ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_hdrshot_result_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static void mmi_camco_cam_hdrshot_result_hdlr(mdi_camera_hdr_result_struct* result_ind, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	//S32 width, height;
    //U8 *dst_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(result_ind->buffer_type == MDI_CAMERA_HDR_CAPTURE_QUICKVIEW)
    {
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_STITCHING));    

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_hdr_shot_evt_hdlr);
    #else 
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_hdr_shot_rsk_released);
        #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_hdr_shot_rsk_released);
        #endif
    #else 
        mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_hdr_shot_rsk_released);
    #endif
    #endif 
    
        mmi_camco_osd_draw_osd();
    }
    else if(result_ind->buffer_type == MDI_CAMERA_HDR_PROCESSED_QUICKVIEW)
    {
        U8 *dst_p;
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
        gdi_layer_get_buffer_ptr(&dst_p);
		gdi_layer_pop_and_restore_active(); 

        memcpy((void*)dst_p, (void*)result_ind->buffer_address, result_ind->buffer_size);  

        mmi_camco_osd_draw_osd();        
    }
    else if(result_ind->buffer_type == MDI_CAMERA_HDR_PROCESSED_MAINIMAGE)
    {
        mmi_camco_cam_p->is_hdr_shot_process = MMI_TRUE;      
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_HDR_DONE);        
    }
    else
    {
        return;    
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_hdrshot_start
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_hdrshot_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;
    U8 *dst_p;
	U8 bit;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.quickview_wnd.width, g_mmi_camco_cntx.quickview_wnd.height);
	bit = gdi_layer_get_bit_per_pixel();
    gdi_layer_set_position(g_mmi_camco_cntx.quickview_wnd.offset_x, g_mmi_camco_cntx.quickview_wnd.offset_y);
    gdi_layer_pop_and_restore_active();
    
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
    gdi_layer_get_buffer_ptr(&dst_p);
    gdi_layer_pop_and_restore_active();    
	mdi_camera_set_quickview_rotation(0);

    ret = mdi_camera_capture_hdr_shot_with_quickview(
            (U32)dst_p,
            ((g_mmi_camco_cntx.quickview_image_width * g_mmi_camco_cntx.quickview_image_height * bit) >> 3),
			g_mmi_camco_cntx.quickview_image_width,
			g_mmi_camco_cntx.quickview_image_height,
            mmi_camco_cam_hdrshot_result_hdlr,
            NULL);

    return ret;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_hdrshot_stop
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static void mmi_camco_cam_hdrshot_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ret = mdi_camera_stop_non_blocking_hdr_shot(mmi_camco_cam_p->mmi_camco_hdr_file_name);
    if(ret != MDI_RES_CAMERA_SUCCEED)
    {
      mmi_camco_cam_restore_filename_seq_no();
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_hdrshot_save
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_hdrshot_save(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(mmi_camco_cam_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);

    ret = mdi_camera_save_hdr_images(mmi_camco_cam_p->mmi_camco_hdr_file_name, mmi_camco_cam_p->buf_filename_p);

    if(ret != MDI_RES_CAMERA_SUCCEED)
    {
        mmi_camco_cam_restore_filename_seq_no();
    }
    
    return ret;
}

#endif    

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_start
 * DESCRIPTION
 *  camera burstshot
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static MDI_RESULT mmi_camco_cam_burstshot_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MMI_CAMCO_CAM_NOT_READY;
    U8 *dst_p;
    S32 width, height, buf_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MTK_TARGET__
    if (mdi_camera_is_ready_to_capture())
#endif 
    {
        width = g_mmi_camco_cntx.quickview_wnd.width;
        height = g_mmi_camco_cntx.quickview_wnd.height;
        gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
        /*use gdi mem*/
        gdi_layer_get_buffer_ptr(&dst_p);
        gdi_layer_pop_and_restore_active();
        buf_size = (width * height * 2) >> 3;
		mdi_camera_set_quickview_rotation(0);
        ret = mdi_camera_capture_to_memory_burst_shot_with_quickview(
                MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT,
                &mmi_camco_cam_p->burstshot.jpeg_data,
                mmi_camco_cam_burstshot_result_hdlr,
                (U8*) mmi_camco_cam_p->multishot_mem_pool,
                MMI_CAMCO_CAM_MULTISHOT_MEM_SIZE,
                (U32)dst_p,
                buf_size,
                width,
                height,
                NULL);
    }
    return ret;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_stop
 * DESCRIPTION
 *  camera burstshot
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_burstshot_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_camera_stop_non_block_burst_capture();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_is_file_exist
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_camco_cam_burstshot_select_is_file_exist(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 highlight_idx;
    CHAR* buf_filename;
    U16 i = 0;
    MMI_BOOL ret = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_osd_get_imgselect_cur_img_info(&highlight_idx, &buf_filename);

    if (!mmi_camco_is_file_exist(buf_filename))
    {
        mmi_camco_cam_p->burstshot.is_saved[highlight_idx] = MMI_FALSE;
        ret = MMI_FALSE;
    }

    for (i = 0; i < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT; i++)
    {
        if (i != highlight_idx && mmi_camco_cam_p->burstshot.is_saved[i])
        {
            buf_filename = mmi_camco_osd_get_imgselect_filepath(i);
            if (!mmi_camco_is_file_exist(buf_filename))
            {
                mmi_camco_cam_p->burstshot.is_saved[i] = MMI_FALSE;
            }
        }
    }
    /* Recover the highlight idx */
    mmi_camco_osd_set_imgselect_highlight_idx(highlight_idx);

    if (!ret)
    {
        mmi_camco_file_deleted_hdlr();
    }

    return ret;
}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot
 * DESCRIPTION
 *  camera auto exposure bracketing
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static MDI_RESULT mmi_camco_cam_aebshot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MMI_CAMCO_CAM_NOT_READY;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MTK_TARGET__
    if (mdi_camera_is_ready_to_capture())
#endif 
    {
        ret = mdi_camera_capture_to_memory_bracketing(
                &mmi_camco_cam_p->aebshot.jpeg_data,
                (U8*) mmi_camco_cam_p->multishot_mem_pool,
                MMI_CAMCO_CAM_MULTISHOT_MEM_SIZE);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_is_file_exist
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_camco_cam_aebshot_select_is_file_exist(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 highlight_idx;
    CHAR* buf_filename;
    U16 i = 0;
    MMI_BOOL ret = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_osd_get_imgselect_cur_img_info(&highlight_idx, &buf_filename);

    if (!mmi_camco_is_file_exist(buf_filename))
    {
        mmi_camco_cam_p->aebshot.is_saved[highlight_idx] = MMI_FALSE;
        ret = MMI_FALSE;
    }

    for (i = 0; i < MMI_CAMCO_FEATURE_CAM_AEBSHOT_IMAGE_COUNT; i++)
    {
        if (i != highlight_idx && mmi_camco_cam_p->aebshot.is_saved[i])
        {
            buf_filename = mmi_camco_osd_get_imgselect_filepath(i);
            if (!mmi_camco_is_file_exist(buf_filename))
            {
                mmi_camco_cam_p->aebshot.is_saved[i] = MMI_FALSE;
            }
        }
    }
    /* Recover the highlight idx */
    mmi_camco_osd_set_imgselect_highlight_idx(highlight_idx);

    if (!ret)
    {
        mmi_camco_file_deleted_hdlr();
    }

    return ret;
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 



#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_get_preview_size
 * DESCRIPTION
 *  mmi_camco_cam_get_preview_size
 * PARAMETERS
 *  width_p  [OUT]
 * height_p  [OUT]
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/

extern mmi_camco_cam_get_preview_size(S32* width_p, S32* height_p)
{
    *width_p = g_mmi_camco_cntx.preview_wnd.width;
    *height_p = g_mmi_camco_cntx.preview_wnd.height;
}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_shot
 * DESCRIPTION
 *  camera autorama capture
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/

static MDI_RESULT mmi_camco_cam_autorama_shot(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MMI_CAMCO_CAM_NOT_READY;
    U32 buffer_size = MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_MEM_SIZE / MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_IMAGE_COUNT;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
	g_mmi_camco_cntx.cam.autorama_shot.last_capture_time = 0;
	mdi_camera_set_quickview_rotation(1);
    if (mmi_camco_cam_p->autorama_shot.capture_count < MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_IMAGE_COUNT - 1 )
    {
       
        ret = mdi_camera_capture_to_memory_panorama_with_quickview(
                mmi_camco_cam_p->autorama_shot.capture_buffer_p[mmi_camco_cam_p->autorama_shot.capture_count],
                buffer_size,
                &mmi_camco_cam_p->autorama_shot.capture_buffer_p[mmi_camco_cam_p->autorama_shot.capture_count],
                &mmi_camco_cam_p->autorama_shot.capture_img_size[mmi_camco_cam_p->autorama_shot.capture_count],
                mmi_camco_cam_p->autorama_shot.capture_count + 1,
                mmi_camco_get_cmd_autorama_direction(mmi_camco_cam_p->autorama_shot.direction),
                (U32)mmi_camco_cam_p->autorama_shot.cache_buffer_p,
                MMI_CAMCO_CAM_AUTORAMA_CACHE_IMAGE_WIDTH * MMI_CAMCO_CAM_AUTORAMA_CACHE_IMAGE_HEIGHT * 2,
                MMI_CAMCO_CAM_AUTORAMA_CACHE_IMAGE_WIDTH,
                MMI_CAMCO_CAM_AUTORAMA_CACHE_IMAGE_HEIGHT); 

    }
	else
    {  
        /* the last one don,t need quick view,after capture always enter stitch state*/
        ret = mdi_camera_capture_to_memory_panorama_with_quickview(
                mmi_camco_cam_p->autorama_shot.capture_buffer_p[mmi_camco_cam_p->autorama_shot.capture_count],
                buffer_size,
                &mmi_camco_cam_p->autorama_shot.capture_buffer_p[mmi_camco_cam_p->autorama_shot.capture_count],
                &mmi_camco_cam_p->autorama_shot.capture_img_size[mmi_camco_cam_p->autorama_shot.capture_count],
                mmi_camco_cam_p->autorama_shot.capture_count + 1,
                mmi_camco_get_cmd_autorama_direction(mmi_camco_cam_p->autorama_shot.direction),
                NULL,
                0,
                0,
                0); 

	}
    
	g_mmi_camco_cntx.cam.autorama_shot.last_capture_time = drv_get_current_time();
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_stitch
 * DESCRIPTION
 *  camera autorama stitch
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_autorama_stitch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;
    mdi_camera_panorama_struct autorama_data;
    U8 idx = 0;
    U8 *dst_p;
    S32 width, height, buf_size;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.preview_wnd.width, g_mmi_camco_cntx.preview_wnd.height);
    gdi_layer_set_position(g_mmi_camco_cntx.preview_wnd.offset_x, g_mmi_camco_cntx.preview_wnd.offset_y);
	gdi_layer_set_color_format(GDI_COLOR_FORMAT_16);
	#ifdef HORIZONTAL_CAMERA
	if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	{
	    gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);
	}
	#endif
	gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
    gdi_layer_get_dimension(&width, &height);
    buf_size = (width * height * gdi_layer_get_bit_per_pixel()) >> 3;
    gdi_layer_get_buffer_ptr(&dst_p);
    gdi_layer_pop_and_restore_active();

    autorama_data.image_num = mmi_camco_cam_p->autorama_shot.capture_count;
    autorama_data.direction = (mdi_camera_panorama_direciton_enum)mmi_camco_get_cmd_autorama_direction(mmi_camco_cam_p->autorama_shot.direction);
    autorama_data.dest_jpeg_buffer_address = (U32) mmi_camco_cam_p->multishot_mem_pool;
    autorama_data.dest_jpeg_buffer_size = MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT_MEM_SIZE;

    for (idx = 0; idx < autorama_data.image_num; idx++)
    {
        autorama_data.src_jpeg_buffer_address[idx] = (U32) mmi_camco_cam_p->autorama_shot.capture_buffer_p[idx];
        autorama_data.src_jpeg_buffer_size[idx] = mmi_camco_cam_p->autorama_shot.capture_img_size[idx];
    }
    ret = mdi_camera_start_stitching_panorama_with_quickview(
              &autorama_data,
              mmi_camco_cam_autorama_quickview_result_hdlr,
              mmi_camco_cam_autorama_stitch_result_hdlr,
              (U32)dst_p,
              buf_size,
              width,
              height,
              MMI_FALSE,
              NULL);

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_stitch_stop
 * DESCRIPTION
 *  mmi_camco_cam_autorama_stitch_stop
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_autorama_stitch_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = mdi_camera_stop_stitching_panorama();
    return ret;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_save_capture_image
 * DESCRIPTION
 *  mmi_camco_cam_autorama_save_capture_image
 * PARAMETERS
 *  image_buf_ptr       [IN]        
 *  image_buf_size      [IN]        
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_autorama_save_capture_image(PU8 image_buf_ptr, U32 image_buf_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_drive_available)
    {
        return MMI_CAMCO_ERR_SAVE_FAIL;
    }
    memset(mmi_camco_cam_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);

#ifdef PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA
#ifdef __MMI_CAMCO_DEBUG_ON__
    if (mmi_camco_is_pano_log_file)
    {
        S32 len = mmi_ucs2strlen((CHAR*) mmi_camco_cam_p->buf_filename_p);
        CHAR ucs2_buffer[50];

        mmi_ucs2ncpy(ucs2_buffer, mmi_camco_cam_p->buf_filename_p, len - 4);
        mmi_ucs2cat(ucs2_buffer, (CHAR*) L".yuv");
        mmi_ucs2cpy(mmi_camco_cam_p->buf_filename_p, ucs2_buffer);
    }
#endif /* __MMI_CAMCO_DEBUG_ON__ */ 
#endif /* PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA */ 
    MMI_CAMCO_START_LOGGING("SAV");

    ret = mmi_camco_cam_save_image(mmi_camco_cam_p->buf_filename_p, image_buf_ptr, image_buf_size);

    if (ret != MDI_RES_CAMERA_SUCCEED)
    {
        mmi_camco_cam_restore_filename_seq_no();
    }

    MMI_CAMCO_STOP_LOGGING("SAV");
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_reset_autorama_3a
 * DESCRIPTION
 *  mmi_camco_cam_reset_autorama_3a
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_reset_autorama_3a(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret = MDI_RES_CAMERA_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = mdi_camera_reset_panorama_3a();
    return ret;
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_capture_image
 * DESCRIPTION
 *  save image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MDI_RESULT mmi_camco_cam_save_capture_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = mdi_camera_save_captured_image();

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_play_shuttersound
 * DESCRIPTION
 *  play shutter sound
 * PARAMETERS
 *  shuttersound        [IN]        Shuttersound enum
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_play_shuttersound(U16 shuttersound)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 aud_len;
    U8 *aud_data = NULL;
    U8 aud_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_slient_mode())
    {
        return;
    }

    switch (shuttersound)
    {
        case MMI_CAMCO_SHUTTERSOUND_OFF:
            break;

        case MMI_CAMCO_SHUTTERSOUND_SOUND_1:
            aud_data = get_audio((U16) (AUD_ID_CAMCO_CAPTURE_1), &aud_type, &aud_len);
            break;

        case MMI_CAMCO_SHUTTERSOUND_SOUND_2:
            aud_data = get_audio((U16) (AUD_ID_CAMCO_CAPTURE_2), &aud_type, &aud_len);
            break;

        case MMI_CAMCO_SHUTTERSOUND_SOUND_3:
            aud_data = get_audio((U16) (AUD_ID_CAMCO_CAPTURE_3), &aud_type, &aud_len);
            break;

        default:
            MMI_ASSERT(0);
            break;

    }

    if (aud_data != NULL)
    {
        mdi_audio_play_string_with_vol_path(
            (void*)aud_data,
            aud_len,
            aud_type,
            DEVICE_AUDIO_PLAY_ONCE,
            NULL,
            NULL,
            MDI_AUD_VOL_4,
            MDI_DEVICE_SPEAKER_BOTH);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_countdown_cyclic
 * DESCRIPTION
 *  count down delay timer cyclic loop
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_countdown_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 highlight;
    double tick_elapsed;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_COUNTDOWN);

    highlight = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_HIGHLIGHT);

    if (mmi_camco_cam_p->countdown_duration >= 0)
    {
        if (mmi_camco_cam_p->countaud_data != NULL)
        {
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* 0 */ 
            if (!mmi_camco_is_slient_mode())
            {
                mdi_audio_set_headset_mode_output_path(MDI_DEVICE_SPEAKER_BOTH);
                mdi_audio_set_volume(VOL_TYPE_MEDIA, MDI_AUD_VOL_4);
                mdi_audio_mma_stop(mmi_camco_cam_p->multi_sound_countdown);
                mdi_audio_mma_play(mmi_camco_cam_p->multi_sound_countdown);
            }
        }
    }

    if (mmi_camco_cam_p->countdown_duration > 6000)
    {
        kal_get_time(&g_mmi_camco_cntx.end_ticks);
        tick_elapsed = (g_mmi_camco_cntx.end_ticks - g_mmi_camco_cntx.start_ticks);
        g_mmi_camco_cntx.start_ticks = g_mmi_camco_cntx.end_ticks;
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */    
        if (highlight == MMI_CAMCO_HIGHLIGHT_ON)
        {
            mmi_camco_countdown_led_turn_on();
        }
        gui_start_timer(100, mmi_camco_countdown_led_turn_off);
        gui_start_timer(1000, mmi_camco_cam_countdown_cyclic);
        mmi_camco_cam_p->countdown_duration -= tick_elapsed;
    }
    else if (mmi_camco_cam_p->countdown_duration > 2000)
    {
        kal_get_time(&g_mmi_camco_cntx.end_ticks);
        tick_elapsed = (g_mmi_camco_cntx.end_ticks - g_mmi_camco_cntx.start_ticks);
        g_mmi_camco_cntx.start_ticks = g_mmi_camco_cntx.end_ticks;    
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */           
        if (highlight == MMI_CAMCO_HIGHLIGHT_ON)
        {
            mmi_camco_countdown_led_turn_on();
        }
        gui_start_timer(100, mmi_camco_countdown_led_turn_off);
        gui_start_timer(500, mmi_camco_cam_countdown_cyclic);
        mmi_camco_cam_p->countdown_duration -= tick_elapsed;
    }
    else if (mmi_camco_cam_p->countdown_duration >= 0)
    {
        kal_get_time(&g_mmi_camco_cntx.end_ticks);
        tick_elapsed = (g_mmi_camco_cntx.end_ticks - g_mmi_camco_cntx.start_ticks);
        g_mmi_camco_cntx.start_ticks = g_mmi_camco_cntx.end_ticks;    
        tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */           
        if (highlight == MMI_CAMCO_HIGHLIGHT_ON)
        {
            mmi_camco_countdown_led_turn_on();
        }
        gui_start_timer(100, mmi_camco_countdown_led_turn_off);
        gui_start_timer(200, mmi_camco_cam_countdown_cyclic);
        mmi_camco_cam_p->countdown_duration -= tick_elapsed;
    }
    else
    {
        gui_cancel_timer(mmi_camco_countdown_led_turn_off);
        if (highlight == MMI_CAMCO_HIGHLIGHT_ON)
        {
            mmi_camco_countdown_led_turn_on();
        }
        mmi_camco_deinit_countdown_mma();
        mmi_camco_cam_capture();
        return;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_no_card_lsk_released
 * DESCRIPTION
 *  camera preview state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_no_card_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 drv_enum;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(mmi_camco_get_storage_count() > 1) /* there are more than one choose to select */
    {
        S32 drv_enum = mmi_camco_osd_get_selected_storage();

        mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
      
        if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW); 
            mmi_camco_cam_preview_set_key_hdlr();
        }
        else
        {
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            mmi_camco_cam_preview_set_key_hdlr();
        }    
         mmi_camco_osd_draw_osd();     

    }
    else
    {
        drv_enum = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV));
        mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));


        if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);     
            mmi_camco_cam_preview_set_key_hdlr();
        }
        else
        {
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            mmi_camco_cam_preview_set_key_hdlr();
        }    
         mmi_camco_osd_draw_osd();             
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_lsk_released
 * DESCRIPTION
 *  camera preview state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_exit_current_state();

        mmi_camco_cam_power_off();

        /* Clear background */
        mmi_camco_osd_set_bg_black();

        mmi_camco_cam_recover_framework_environment();

        mmi_camco_rec_entry_app_screen_internal();
    }
    else
    {
        mmi_camco_osd_set_setting_menulist_interrupt(MMI_FALSE);
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SETTING_MENU);
       
    }        
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_csk_pressed
 * DESCRIPTION
 *  camera preview state csk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_csk_pressed(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_capture_button_pressed();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_rsk_released
 * DESCRIPTION
 *  camera preview state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_exit_app();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_autofocus_button_pressed
 * DESCRIPTION
 *  press AF key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_autofocus_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_camco_setting_get_active_cam() != MMI_CAMCO_SETTING_CAM_SUB)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_FOCUSING);
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_focus_autofocus_button_released
 * DESCRIPTION
 *  release AF key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_focus_autofocus_button_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_autofocus_stop();
    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_capture_button_pressed
 * DESCRIPTION
 *  camera capture botton pressed handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_capture_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_selftimer_enum selftimer = MMI_CAMCO_SELFTIMER_OFF;
    U16 capmode;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_mmi_camco_cntx.is_capture_when_focused == MMI_TRUE)
	    return;

    if (g_mmi_camco_cntx.is_playing_focused_wav == MMI_TRUE && g_mmi_camco_cntx.is_capture_when_focused == MMI_FALSE)
    {
        g_mmi_camco_cntx.is_capture_when_focused = MMI_TRUE;
        return;
    }
    
    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_PREVIEW &&
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_SUB_PREVIEW &&
#endif 
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_FOCUSING &&
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_FOCUSED &&
        g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_COUNTDOWN)
    {
        return;
    }

#ifdef __MMI_INTERACTIVE_PROFILNG__
    if (mmi_frm_profiling_interactive_is_enabled())
    {
        kal_get_time(&start_ticks);

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_BOTTON_PRESS, start_ticks);
    }
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

    MMI_CAMCO_START_LOGGING("PRE");

    capmode = mmi_camco_get_capmode();

    if (capmode != MMI_CAMCO_CAPMODE_CONT_SHOT &&
#ifdef __SMILE_SHUTTER_SUPPORT__
        capmode != MMI_CAMCO_CAPMODE_SMILE_SHOT &&
#endif 
        capmode != MMI_CAMCO_CAPMODE_AUTORAMA)
    {
        selftimer =(mmi_camco_selftimer_enum)mmi_camco_get_selftimer();
    }

    if (selftimer == MMI_CAMCO_SELFTIMER_OFF)
    {
    #ifdef __SMILE_SHUTTER_SUPPORT__
        if (capmode == MMI_CAMCO_CAPMODE_SMILE_SHOT)
        {
            /* start SD */
        #ifdef __MMI_CAMCO_FTE__      
            mmi_camco_osd_csk_set_press(MMI_TRUE);     
            mmi_camco_osd_draw_osd();    
        #endif
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SMILE_DECT);
        }
        else
    #endif /* __SMILE_SHUTTER_SUPPORT__ */ 
        {
        #ifdef __MMI_CAMCO_FTE__        
            mmi_camco_osd_csk_set_press(MMI_TRUE);           
            mmi_camco_osd_draw_osd();   
        #endif             
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

        #ifndef __MMI_CAMCO_FTE__
            if (!mmi_camco_is_from_external())
        	{    	
                mmi_camco_osd_set_csk_img(
                    IMG_ID_CAMCO_CAMERA,
                    IMG_ID_CAMCO_CAMERA,
                    mmi_camco_cam_capture_csk_button_released,
                    KEY_EVENT_UP);
            }
            else
            {
                mmi_camco_osd_set_csk_img(
                    IMG_ID_CAMCO_CAMERA_ONLY,
                    IMG_ID_CAMCO_CAMERA_ONLY,
                    mmi_camco_cam_capture_csk_button_released,
                    KEY_EVENT_UP);                                                               
            } 
            mmi_camco_osd_set_csk_press();
            mmi_camco_osd_draw_osd();
        #endif /* __MMI_CAMCO_FTE__ */             
            mmi_camco_cam_capture();
        }
    }
    else if (selftimer != MMI_CAMCO_SELFTIMER_END)
    {
        mmi_camco_cam_p->countdown_duration = (S32) selftimer *5 * 1000;

        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_COUNTDOWN);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_capture_button_released
 * DESCRIPTION
 *  camera capture botton released handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_capture_button_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_csk_release();
#else
    mmi_camco_osd_csk_set_press(MMI_FALSE);    
#endif 
    if(g_mmi_camco_cntx.is_capture_when_focused == MMI_TRUE)
    g_mmi_camco_cntx.is_camera_key_release = MMI_TRUE;
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_CONTSHOT)
    {
        gui_cancel_timer(mmi_camco_cam_contshot_cyclic);
        mmi_camco_cam_autofocus_stop();
        mmi_camco_need_restart_preview();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_capture_button_preview_pressed
 * DESCRIPTION
 *  camera capture botton released handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_capture_button_preview_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SAVE_DONE ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_DONE||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_HDR_DONE)
    {
        /*  
         * Before enter preview from non-preview state, re-draw osd in advance.
         * Otherwise, there will some noise in screen when driver blt in first time.
         */
        g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_capture_csk_button_released
 * DESCRIPTION
 *  camera capture botton released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_capture_csk_button_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_CONTSHOT)
    {
        gui_cancel_timer(mmi_camco_cam_contshot_cyclic);
        mmi_camco_need_restart_preview();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_setting_menu_lsk_released
 * DESCRIPTION
 *  camera setting menu state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_setting_menu_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 

    if (g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_exit_current_state();

        mmi_camco_cam_power_off();

        /* Clear background */
        mmi_camco_osd_set_bg_black();

        mmi_camco_cam_recover_framework_environment();

        mmi_camco_rec_entry_app_screen_internal();
    }
#ifdef __MMI_IMAGE_VIEWER__
    else if (mmi_camco_cam_p->is_switchto_imgviewer)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_PREVIEW;
        g_mmi_camco_cntx.is_to_media_editor = MMI_TRUE;
        mmi_imgview_set_storage(mmi_camco_cam_p->storage);
        mmi_imgview_launch();
    }
#endif /* __MMI_IMAGE_VIEWER__ */ 
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    else if (mmi_camco_cam_p->is_switchto_sublcd)
    {
        mmi_camco_exit_current_state();

        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FACEDETECT) == MMI_CAMCO_FACEDETECT_ON)
        {
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_FACEDETECT, MMI_CAMCO_FACEDETECT_OFF);
            mmi_camco_update_facedetect(MMI_CAMCO_FACEDETECT_OFF);
        }
        /* Clear background */
        mmi_camco_osd_set_bg_black();

        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SUB_PREVIEW);
    }
#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    else if (mmi_camco_setting_get_mainlist_setting() == MMI_CAMCO_SETTING_CAPMODE &&
             mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ADD_FRAME)
    {

        /* it may has been reset in setting menu and not back yet, so always restart */
        if (mmi_camco_cam_p->is_reset_zoom || mmi_camco_osd_is_add_frame_enable())
        {
            mmi_camco_cam_preview_stop();
            mmi_camco_osd_set_bg_black();
            mmi_camco_osd_set_add_frame_enable(MMI_FALSE);

            mmi_camco_cam_get_preview_window(MMI_CAMCO_CAM_PREVIEW_MAINLCD);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_ADD_FRAME_SELECTION);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_add_frame_evt_hdlr);
        #else 
            mmi_camco_cam_add_frame_set_key_hdlr();
        #endif 
            mmi_camco_osd_draw_osd();
            if (mmi_camco_cam_preview_start())
            {
                g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
            }
        }

        if (g_mmi_camco_cntx.is_preview_start)
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_ADD_FRAME);
        }
        else
        {
            MMI_ASSERT(0);
        }
    }
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
#ifdef DUAL_CAMERA_SUPPORT
    else if (g_mmi_camco_cntx.is_switchto_maincamera || g_mmi_camco_cntx.is_switchto_subcamera)
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_EXIT);
        mmi_camco_osd_reset_environment();

        mmi_camco_exit_current_state();

        mmi_camco_cam_power_off();

        /* Clear background */
        mmi_camco_osd_set_bg_black();

    #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
        gdi_bltdb_disable();
    #endif

        if (g_mmi_camco_cntx.is_switchto_maincamera)
        {
            mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_MAIN);
            mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_MAIN);
        }
        else
        {
            mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_SUB);
            mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_SUB);
        }

        mmi_camco_osd_set_default();
        mmi_camco_osd_init();
    #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)        
        gdi_bltdb_enable(GDI_BLTDB_ENABLE_ONLY_WHEN_HW_UPDATE);    
    #endif        
        mmi_camco_osd_setup_environment(g_mmi_camco_cntx.app_mem_buf_p);

        mmi_camco_setting_init();
        mmi_camco_setting_load_from_nvram();
        mmi_camco_setting_default_capability();

        /* Must call this to correct to the right scenemode setting */
        if (mmi_camco_setting_get_last_active_app() != mmi_camco_setting_get_active_app())
        {
            mmi_camco_setting_switch_capability();
            mmi_camco_setting_update_capability();
            mmi_camco_update_facedetect_capability();
        }

        if (mmi_camco_is_from_external())
        {
            U16 capmode = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE);

            mmi_camco_setting_update_capability();
            mmi_camco_update_facedetect_capability();
            mmi_camco_set_external_camswitchto_capability();
            mmi_camco_set_external_capmode_capability();

            if (capmode != MMI_CAMCO_CAPMODE_NORMAL && capmode != MMI_CAMCO_CAPMODE_ADD_FRAME)
            {
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);
            #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
                mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
            #endif 
                mmi_camco_update_capmode(MMI_CAMCO_CAPMODE_NORMAL);
            }

        }

        mmi_camco_need_restart_preview();
        mmi_camco_cam_power_on();
        if (g_mmi_camco_cntx.is_power_on)
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
        }
        else
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
        }

        g_mmi_camco_cntx.is_switchto_maincamera = MMI_FALSE;
        g_mmi_camco_cntx.is_switchto_subcamera = MMI_FALSE;
    }
#endif /* DUAL_CAMERA_SUPPORT */ 
    

    else if (g_mmi_camco_cntx.is_restore_default)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_RESTORE_CONFIRM);
    }
    else
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_setting_menu_rsk_released
 * DESCRIPTION
 *  camera setting menu state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_setting_menu_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_restart_preview = MMI_FALSE;
    g_mmi_camco_cntx.is_switching_app = MMI_FALSE;

#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 

    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_add_frame_lsk_released
 * DESCRIPTION
 *  camera picking add frame lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
static void mmi_camco_cam_add_frame_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->addframe_coloridx_index = mmi_camco_osd_get_add_frame_idx();

    mmi_camco_osd_set_add_frame_enable(MMI_TRUE);
    mmi_camco_need_restart_preview();
    mmi_camco_setting_set_camzoom_step(mmi_camco_update_zoom_step());
    mmi_camco_setting_set_camzoom_value(mmi_camco_update_zoom_factor());

    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_add_frame_rsk_released
 * DESCRIPTION
 *  camera picking add frame rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_add_frame_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_capsize_enum capsize;
    mmi_camco_capsize_enum original_capsize = MMI_CAMCO_CAPSIZE_WALLPAPER;
    S16 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->is_reset_zoom = MMI_FALSE;
    mmi_camco_need_restart_preview();
    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE) == MMI_CAMCO_CAPMODE_ADD_FRAME)
    {
        mmi_camco_osd_set_add_frame_enable(MMI_TRUE);
    }
#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
    else
    {
        ReadValue(NRRAM_CAMCO_BEFORE_SWITCH_CAPSIZE, &original_capsize, DS_BYTE, &error);
        if (original_capsize != mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPSIZE))
        {
            capsize = original_capsize;
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPSIZE, capsize);
            mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);
            mdi_camera_update_para_image_size(mmi_camco_cam_p->image_width, mmi_camco_cam_p->image_height);

            mmi_camco_config_capsize_capability();
        }
        mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_TIMESTAMP);
        mmi_camco_update_capmode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE));
    }
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 
    mmi_camco_osd_set_add_frame_highlighted_idx(mmi_camco_cam_p->addframe_coloridx_index);

    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);

}
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_failed_rsk_released
 * DESCRIPTION
 *  camera preview failed state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_preview_failed_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_exit_app();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_countdown_rsk_released
 * DESCRIPTION
 *  camera countdown state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_countdown_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_cam_countdown_cyclic);
    gui_cancel_timer(mmi_camco_countdown_led_turn_off);
    mmi_camco_countdown_led_turn_off();

    mmi_camco_deinit_countdown_mma();

    if (mmi_camco_cam_p->is_autofocus_on)
    {
        mmi_camco_cam_autofocus_stop();
    }
    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_lsk_released
 * DESCRIPTION
 *  camera save done state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_save_done_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
    {
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }
#ifdef __MMI_CAMCO_FTE__
    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
    {
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
        mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                          (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));
        mmi_camco_osd_set_captured_mode(MMI_FALSE);
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_save_done_evt_hdlr);
    }
#endif /* __MMI_CAMCO_FTE__ */ 
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0;
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_save_done_evt_hdlr);
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#endif /* __MMI_CAMCO_FTE__ */ 
#ifndef __MMI_CAMCO_FTE__
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 

#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_save_done_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_save_done_option_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_save_done_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_save_done_option_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_save_done_option_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_save_done_option_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 
#endif /* __MMI_CAMCO_FTE__ */ 

    mmi_camco_osd_set_option_title(STR_GLOBAL_OPTIONS);

    mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_DELETE, STR_GLOBAL_DELETE);

    if (srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*) mmi_camco_cam_p->buf_filename_p) > 0)
    {
        mmi_camco_cam_p->is_forward = MMI_TRUE;
        mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_FORWARD, STR_GLOBAL_FORWARD);
    }
    else
    {
        mmi_camco_cam_p->is_forward = MMI_FALSE;
    }

#ifdef __MMI_PHOTOEDITOR__
    mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_PHOTOEDITOR, STR_ID_CAMCO_CAM_PHOTO_EDITOR);
#endif 
    mmi_camco_osd_insert_option_done();

    if (!g_mmi_camco_cntx.option_menulist.is_rollback)
    {
        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);
    }
    mmi_camco_osd_draw_osd();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_rsk_released
 * DESCRIPTION
 *  camera save done state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_save_done_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_power_on)
    {
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        if (mmi_camco_cam_p->is_switchto_sublcd)
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SUB_PREVIEW);
        }
        else
    #endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
        {

            /*  
             * Before enter preview from non-preview state, re-draw osd in advance.
             * Otherwise, there will some noise in screen when driver blt in first time.
             */
            g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
        }
    }
    else
    {

        mmi_camco_osd_set_bg_black();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_csk_released
 * DESCRIPTION
 *  camera preview state csk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_save_done_csk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_send_to_mms();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_option_rsk_released
 * DESCRIPTION
 *  camera save done state option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_save_done_option_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

    mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                      (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_save_done_evt_hdlr);
#else /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_cam_save_done_set_key_hdlr();
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#endif /* __MMI_CAMCO_FTE__ */ 

    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    mmi_camco_osd_draw_osd();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_option_lsk_released
 * DESCRIPTION
 *  camera save done state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_save_done_option_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    U32 current_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
        current_idx = mmi_camco_osd_get_option_hilite_idx();
        current_item = mmi_camco_osd_get_option_item_id(current_idx);
    }
    else
    {
        current_item = g_mmi_camco_cntx.option_menulist.option;
    }

    switch (current_item)
    {
        case MMI_CAMCO_CAM_OPTION_DELETE:
            mmi_camco_cam_delete_confirm();
            break;

        case MMI_CAMCO_CAM_OPTION_FORWARD:
            mmi_camco_cam_forward_menu();
            break;

    #ifdef __MMI_PHOTOEDITOR__
        case MMI_CAMCO_CAM_OPTION_PHOTOEDITOR:
            mmi_camco_cam_entry_photoeditor();
            break;
    #endif /* __MMI_PHOTOEDITOR__ */ 

        default:
            break;
    }

    g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_delete_confirm_lsk_released
 * DESCRIPTION
 *  camera delete confirm option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_delete_confirm_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    FS_Delete((U16*) mmi_camco_cam_p->buf_filename_p);
    mmi_camco_cam_restore_filename_seq_no();

    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    /*  
     * Before enter preview from non-preview state, re-draw osd in advance.
     * Otherwise, there will some noise in screen when driver blt in first time.
     */
    g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    if (mmi_camco_cam_p->is_switchto_sublcd)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SUB_PREVIEW);
    }
    else
#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 
	{

	    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
	}

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_delete_confirm_rsk_released
 * DESCRIPTION
 *  camera delete confirm option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_delete_confirm_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.highlight_idx = MMI_CAMCO_REC_OPTION_DELETE;

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SAVE_DONE||g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_HDR_DONE)
    {
        mmi_camco_cam_save_done_lsk_released(KEY_EVENT_DOWN);
    }
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)
    {
        mmi_camco_cam_burstshot_select_lsk_options_released(KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
        mmi_camco_cam_aebshot_select_lsk_options_released(KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 
#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_DONE)
    {
        mmi_camco_cam_autorama_done_lsk_released(KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_forward_menu_lsk_released
 * DESCRIPTION
 *  mmi_camco_cam_forward_lsk_released
 * PARAMETERS
 *  key_type        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_forward_menu_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];
#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
    U16 idx;
    CHAR* buf_filename;
#endif
    S32 menu_id;

	#ifdef PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA
	mmi_camco_setting_app_enum app;
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    current_idx = mmi_camco_osd_get_option_hilite_idx();

    memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);

#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
        mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
        mmi_ucs2cpy( ucs2_filename,  buf_filename);
        menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*) ucs2_filename);
    }
    else
#endif /* defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__) */ 
    {
        mmi_ucs2cpy( ucs2_filename,  mmi_camco_cam_p->buf_filename_p);
        menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*) mmi_camco_cam_p->buf_filename_p);
    }

    if (menu_id > 0)
    {

        /* if mms need to resize pic, camco need to let MED free memory */
#ifdef __MMI_MMS_2__        
    #ifdef PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA
	app = mmi_camco_setting_get_active_app();

    if (MMI_CAMCO_SETTING_APP_CAMERA == app)
    {
        if (g_mmi_camco_cntx.fowarditem_idlist[current_idx] == MENU_ID_FMGR_FWD_MMS)
        {
            mmi_camco_cam_power_off();
        }
        }
    #endif /* PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA */ 
#endif
        srv_fmgr_types_launch_option((WCHAR*)ucs2_filename, g_mmi_camco_cntx.fowarditem_idlist[current_idx]);
    }
    else
    {
        mmi_camco_file_deleted_hdlr();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_forward_menu_rsk_released
 * DESCRIPTION
 *  mmi_camco_cam_forward_rsk_released
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_forward_menu_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.highlight_idx = MMI_CAMCO_CAM_OPTION_FORWARD;
    mmi_camco_osd_set_option_hilite_idx(MMI_CAMCO_CAM_OPTION_FORWARD);
    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_TRUE;

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SAVE_DONE||g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_HDR_DONE)
    {
        mmi_camco_cam_save_done_lsk_released(KEY_EVENT_DOWN);
    }
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT)
    {
        mmi_camco_cam_burstshot_select_lsk_options_released(KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
        mmi_camco_cam_aebshot_select_lsk_options_released(KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 
#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_DONE)
    {
        mmi_camco_cam_autorama_done_lsk_released(KEY_EVENT_DOWN);
    }
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_rsk_released
 * DESCRIPTION
 *  camera burstshot select state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_cam_burstshot_select_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_power_on)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_lsk_options_released
 * DESCRIPTION
 *  camera save done state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_burstshot_select_lsk_options_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 idx;
    CHAR* buf_filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
    if (mmi_camco_cam_p->burstshot.is_saved[idx])
    {
#endif /* __MMI_CAMCO_FTE__ */ 
        if (mmi_camco_is_usb_in_CDC() && !mmi_camco_cam_burstshot_select_is_file_exist())
        {
            g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
            return;
        }
    #ifdef __MMI_CAMCO_FTE__
    }
    #endif 

    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
    {
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }
#ifdef __MMI_CAMCO_FTE__
    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
    {

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
        mmi_camco_osd_set_captured_mode(MMI_TRUE);
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);

        mmi_camco_osd_set_redraw_image_select_cache(MMI_TRUE);
        mmi_camco_osd_set_redraw_image_select_highlight_osd(MMI_TRUE);
        /* mmi_camco_osd_draw_image_select(); */
    }
#endif /* __MMI_CAMCO_FTE__ */ 
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0;
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#endif /* __MMI_CAMCO_FTE__ */ 
#ifndef __MMI_CAMCO_FTE__
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
    
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_burstshot_select_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_burstshot_select_option_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_burstshot_select_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_burstshot_select_option_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_burstshot_select_option_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_burstshot_select_option_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 
#endif /* __MMI_CAMCO_FTE__ */ 

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
    if (mmi_camco_cam_p->burstshot.is_saved[idx])
    {
#endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_set_option_title(STR_GLOBAL_OPTIONS);

    #ifdef __MMI_CAMCO_FTE__
        if (mmi_camco_is_file_exist(buf_filename))
        {
    #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_DELETE, STR_GLOBAL_DELETE);
        #ifdef __MMI_CAMCO_FTE__
        }
        #endif 

        mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
        if (srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)buf_filename) > 0)
        {
            mmi_camco_cam_p->is_forward = MMI_TRUE;
            mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_FORWARD, STR_GLOBAL_FORWARD);
        }
        else
        {
            mmi_camco_cam_p->is_forward = MMI_FALSE;
        }

        mmi_camco_osd_insert_option_done();

    #ifdef __MMI_CAMCO_FTE__
    }
    #endif 

    if (!g_mmi_camco_cntx.option_menulist.is_rollback)
    {
        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);
    }

    mmi_camco_osd_draw_osd();
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_lsk_save_released
 * DESCRIPTION
 *  camera save done state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_burstshot_select_lsk_save_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 image_buf_ptr;
    U32 image_buf_size;
    FS_HANDLE file_handle;
    U32 written;
    U16 idx;
    CHAR* buf_filename;
    S32 fs_ret = 0;
    MMI_BOOL is_error_handle_done = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_drive_available)
    {
        mmi_camco_show_error_msg(MMI_CAMCO_ERR_SAVE_FAIL);
        mmi_camco_error_hdlr_timer_start();
        return;
    }

    mmi_camco_cam_p->multishot_save_index = mmi_camco_osd_get_imgselect_hilite_idx();

    memset(mmi_camco_cam_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);

    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
    memset(buf_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_ucs2cpy( buf_filename,  mmi_camco_cam_p->buf_filename_p);

    image_buf_ptr = (PU8) mmi_camco_cam_p->burstshot.jpeg_data.file_address[mmi_camco_cam_p->multishot_save_index];
    image_buf_size = (U32) mmi_camco_cam_p->burstshot.jpeg_data.file_size[mmi_camco_cam_p->multishot_save_index];

    file_handle = FS_Open((U16*) mmi_camco_cam_p->buf_filename_p, FS_CREATE | FS_READ_WRITE);

    if (file_handle > 0)
    {
        fs_ret = FS_Write(file_handle, (void*)image_buf_ptr, image_buf_size, (U32*) & written);
        FS_Close(file_handle);

        /* cant write in whole file, must be disk full */
        if (image_buf_size != written)
        {
            /* delete the file that is not save complete */
            FS_Delete((U16*) mmi_camco_cam_p->buf_filename_p);
            mmi_camco_cam_restore_filename_seq_no();

            mmi_camco_show_error_msg(MDI_RES_CAMERA_ERR_DISK_FULL);
            mmi_camco_error_hdlr_timer_start();
            is_error_handle_done = MMI_TRUE;
        }
        else if (fs_ret == 0)
        {
            mmi_camco_cam_p->burstshot.is_saved[mmi_camco_cam_p->multishot_save_index] = MMI_TRUE;
            mmi_camco_updata_key_handler();
            mmi_camco_osd_draw_osd();
        }
    }

    if (file_handle < 0 || (fs_ret < 0 && !is_error_handle_done))
    {
        MDI_RESULT result;

        if (file_handle == FS_DISK_FULL)
        {
            result = MDI_RES_CAMERA_ERR_DISK_FULL;
        }
        else if (file_handle == FS_ROOT_DIR_FULL)
        {
            result = MMI_CAMCO_ERR_ROOT_DIR_FULL;
        }
        else if (file_handle == FS_WRITE_PROTECTION)
        {
            result = MDI_RES_CAMERA_ERR_WRITE_PROTECTION;
        }
        else
        {
            result = MMI_CAMCO_ERR_SAVE_FAIL;
        }

        mmi_camco_show_error_msg(result);
        mmi_camco_error_hdlr_timer_start();

    }

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_option_lsk_released
 * DESCRIPTION
 *  camera burstshot select state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_burstshot_select_option_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    U32 current_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_cam_burstshot_select_is_file_exist())
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
        current_idx = mmi_camco_osd_get_option_hilite_idx();
        current_item = mmi_camco_osd_get_option_item_id(current_idx);
    }
    else
    {
        current_item = g_mmi_camco_cntx.option_menulist.option;
    }

    switch (current_item)
    {
        case MMI_CAMCO_CAM_OPTION_DELETE:
            mmi_camco_cam_delete_confirm();
            break;

        case MMI_CAMCO_CAM_OPTION_FORWARD:
            mmi_camco_cam_forward_menu();
            break;

        default:
            break;
    }
    g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_option_rsk_released
 * DESCRIPTION
 *  camera burstshot select state option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_burstshot_select_option_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_cam_burstshot_select_is_file_exist())
    {
        return;
    }

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_TRUE);
#endif 

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_burstshot_select_evt_hdlr);
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);    
#else /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_cam_burstshot_select_set_key_hdlr();
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#endif /* __MMI_CAMCO_FTE__ */ 

    mmi_camco_osd_draw_osd();
}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_rsk_released
 * DESCRIPTION
 *  camera aebshot select state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__
static void mmi_camco_cam_aebshot_select_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_power_on)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_lsk_options_released
 * DESCRIPTION
 *  aebshot select state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_aebshot_select_lsk_options_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 idx;
    CHAR* buf_filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
    if (mmi_camco_cam_p->aebshot.is_saved[idx])
    {
#endif /* __MMI_CAMCO_FTE__ */ 
        if (mmi_camco_is_usb_in_CDC() && !mmi_camco_cam_aebshot_select_is_file_exist())
        {
            g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
            return;
        }
    #ifdef __MMI_CAMCO_FTE__
    }
    #endif 

    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
    {
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }
#ifdef __MMI_CAMCO_FTE__
    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
    {

        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
        mmi_camco_osd_set_captured_mode(MMI_TRUE);
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);

        mmi_camco_osd_set_redraw_image_select_cache(MMI_TRUE);
        mmi_camco_osd_set_redraw_image_select_highlight_osd(MMI_TRUE);
        /* mmi_camco_osd_draw_image_select(); */
    }
#endif /* __MMI_CAMCO_FTE__ */ 
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0;
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);    
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);            
#endif /* __MMI_CAMCO_FTE__ */ 
#ifndef __MMI_CAMCO_FTE__
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_aebshot_select_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_aebshot_select_option_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_aebshot_select_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_aebshot_select_option_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_aebshot_select_option_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_aebshot_select_option_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 

#endif /* __MMI_CAMCO_FTE__ */ 

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
    if (mmi_camco_cam_p->aebshot.is_saved[idx])
    {
#endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_set_option_title(STR_GLOBAL_OPTIONS);

    #ifdef __MMI_CAMCO_FTE__
        if (mmi_camco_is_file_exist(buf_filename))
        {
    #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_DELETE, STR_GLOBAL_DELETE);
        #ifdef __MMI_CAMCO_FTE__
        }
        #endif 

        mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
        if (srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)buf_filename) > 0)
        {
            mmi_camco_cam_p->is_forward = MMI_TRUE;
            mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_FORWARD, STR_GLOBAL_FORWARD);
        }
        else
        {
            mmi_camco_cam_p->is_forward = MMI_FALSE;
        }

        mmi_camco_osd_insert_option_done();

    #ifdef __MMI_CAMCO_FTE__
    }
    #endif 

    if (!g_mmi_camco_cntx.option_menulist.is_rollback)
    {
        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);
    }
    mmi_camco_osd_draw_osd();
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_redraw_image_select_cache(MMI_FALSE);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_lsk_save_released
 * DESCRIPTION
 *  aebshot select state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_aebshot_select_lsk_save_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 image_buf_ptr;
    U32 image_buf_size;
    FS_HANDLE file_handle;
    U32 written;
    U16 idx;
    CHAR* buf_filename;
    S32 fs_ret = 0;
    MMI_BOOL is_error_handle_done = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_drive_available)
    {
        mmi_camco_show_error_msg(MMI_CAMCO_ERR_SAVE_FAIL);
        mmi_camco_error_hdlr_timer_start();
        return;
    }

    mmi_camco_cam_p->multishot_save_index = mmi_camco_osd_get_imgselect_hilite_idx();

    memset(mmi_camco_cam_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_camco_cam_get_next_filename(mmi_camco_cam_p->buf_filename_p);

    mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
    memset(buf_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_ucs2cpy( buf_filename,  mmi_camco_cam_p->buf_filename_p);

    image_buf_ptr = (PU8) mmi_camco_cam_p->aebshot.jpeg_data.file_address[mmi_camco_cam_p->multishot_save_index];
    image_buf_size = (U32) mmi_camco_cam_p->aebshot.jpeg_data.file_size[mmi_camco_cam_p->multishot_save_index];

    file_handle = FS_Open((U16*) mmi_camco_cam_p->buf_filename_p, FS_CREATE | FS_READ_WRITE);

    if (file_handle > 0)
    {
        fs_ret = FS_Write(file_handle, (void*)image_buf_ptr, image_buf_size, (U32*) & written);
        FS_Close(file_handle);

        /* cant write in whole file, must be disk full */
        if (image_buf_size != written)
        {
            /* delete the file that is not save complete */
            FS_Delete((U16*) mmi_camco_cam_p->buf_filename_p);
            mmi_camco_cam_restore_filename_seq_no();

            mmi_camco_show_error_msg(MDI_RES_CAMERA_ERR_DISK_FULL);
            mmi_camco_error_hdlr_timer_start();
            is_error_handle_done = MMI_TRUE;
        }
        else if (fs_ret == 0)
        {
            mmi_camco_cam_p->aebshot.is_saved[mmi_camco_cam_p->multishot_save_index] = MMI_TRUE;
            mmi_camco_updata_key_handler();
            mmi_camco_osd_draw_osd();
        }
    }

    if (file_handle < 0 || (fs_ret < 0 && !is_error_handle_done))
    {
        MDI_RESULT result;

        if (file_handle == FS_DISK_FULL)
        {
            result = MDI_RES_CAMERA_ERR_DISK_FULL;
        }
        else if (file_handle == FS_ROOT_DIR_FULL)
        {
            result = MMI_CAMCO_ERR_ROOT_DIR_FULL;
        }
        else if (file_handle == FS_WRITE_PROTECTION)
        {
            result = MDI_RES_CAMERA_ERR_WRITE_PROTECTION;
        }
        else
        {
            result = MMI_CAMCO_ERR_SAVE_FAIL;
        }

        mmi_camco_show_error_msg(result);
        mmi_camco_error_hdlr_timer_start();

    }

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_option_lsk_released
 * DESCRIPTION
 *  camera aebshot select state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_aebshot_select_option_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    U32 current_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_cam_aebshot_select_is_file_exist())
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
        current_idx = mmi_camco_osd_get_option_hilite_idx();
        current_item = mmi_camco_osd_get_option_item_id(current_idx);
    }
    else
    {
        current_item = g_mmi_camco_cntx.option_menulist.option;
    }

    switch (current_item)
    {
        case MMI_CAMCO_CAM_OPTION_DELETE:
            mmi_camco_cam_delete_confirm();
            break;

        case MMI_CAMCO_CAM_OPTION_FORWARD:
            mmi_camco_cam_forward_menu();
            break;

        default:
            break;
    }
    g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_option_rsk_released
 * DESCRIPTION
 *  camera aebshot select state option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_aebshot_select_option_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_cam_aebshot_select_is_file_exist())
    {
        return;
    }

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_IMAGE_SELECTION);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_TRUE);
#endif 

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_aebshot_select_evt_hdlr);
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);    
#else /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_cam_aebshot_select_set_key_hdlr();
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#endif /* __MMI_CAMCO_FTE__ */ 

    mmi_camco_osd_draw_osd();
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 


#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_shot_lsk_released
 * DESCRIPTION
 *  mmi_camco_cam_autorama_shot_lsk_released
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/

static void mmi_camco_cam_autorama_shot_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_preview_stop();

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);
    mmi_camco_osd_set_bg_black();
    mmi_camco_osd_draw_osd();

    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_shot_lsk_released
 * DESCRIPTION
 *  mmi_camco_cam_autorama_shot_lsk_released
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/

static void mmi_camco_cam_autorama_shot_camera_key_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_preview_stop();

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);
    mmi_camco_osd_set_bg_black();
    mmi_camco_osd_draw_osd();

    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_shot_rsk_released
 * DESCRIPTION
 *  camera autorama shot state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_shot_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_cam_autorama_detect_capinfo_cyclic);


    if (g_mmi_camco_cntx.is_power_on)
    {    
        /* pano wont popup memory card remove screen, so update storage if error to update the disk status */
        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
        
        mmi_camco_cam_reset_autorama_3a();
        mmi_camco_need_restart_preview();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {
        mmi_camco_osd_set_bg_black();

        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }

}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_stitch_rsk_released
 * DESCRIPTION
 *  camera autorama stitch state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_stitch_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_autorama_stitch_stop();
    if (g_mmi_camco_cntx.is_power_on)
    {
        /*  
         * Before enter preview from non-preview state, re-draw osd in advance.
         * Otherwise, there will some noise in screen when driver blt in first time.
         */
        g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;

        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {

        mmi_camco_osd_set_bg_black();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_done_lsk_released
 * DESCRIPTION
 *  camera autorama done state option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_done_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
    {
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0;
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_autorama_done_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_autorama_done_option_lsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_autorama_done_option_rsk_released);
    mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_autorama_done_option_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_autorama_done_option_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_autorama_done_option_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 


    mmi_camco_osd_set_option_title(STR_GLOBAL_OPTIONS);

    mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_DELETE, STR_GLOBAL_DELETE);

    if (srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)mmi_camco_cam_p->buf_filename_p) > 0)
    {
        mmi_camco_cam_p->is_forward = MMI_TRUE;
        mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_FORWARD, STR_GLOBAL_FORWARD);
    }
    else
    {
        mmi_camco_cam_p->is_forward = MMI_FALSE;
    }
#ifdef __MMI_PHOTOEDITOR__
    mmi_camco_osd_insert_option_item(MMI_CAMCO_CAM_OPTION_PHOTOEDITOR, STR_ID_CAMCO_CAM_PHOTO_EDITOR);
#endif 


    mmi_camco_osd_insert_option_done();

    if (!g_mmi_camco_cntx.option_menulist.is_rollback)
    {
        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);
    }
    mmi_camco_osd_draw_osd();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_done_rsk_released
 * DESCRIPTION
 *  camera autorama done state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_done_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_power_on)
    {
        /*  
         * Before enter preview from non-preview state, re-draw osd in advance.
         * Otherwise, there will some noise in screen when driver blt in first time.
         */
        g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {
        mmi_camco_osd_set_bg_black();
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_done_csk_released
 * DESCRIPTION
 *  csk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_done_csk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_send_to_mms();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_done_option_lsk_released
 * DESCRIPTION
 *  camera autorama done option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_done_option_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    U32 current_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
        current_idx = mmi_camco_osd_get_option_hilite_idx();
        current_item = mmi_camco_osd_get_option_item_id(current_idx);
    }
    else
    {
        current_item = g_mmi_camco_cntx.option_menulist.option;
    }

    switch (current_item)
    {
        case MMI_CAMCO_CAM_OPTION_DELETE:
            mmi_camco_cam_delete_confirm();
            break;

        case MMI_CAMCO_CAM_OPTION_FORWARD:
            mmi_camco_cam_forward_menu();
            break;

    #ifdef __MMI_PHOTOEDITOR__
        case MMI_CAMCO_CAM_OPTION_PHOTOEDITOR:
            mmi_camco_cam_entry_photoeditor();
            break;
    #endif /* __MMI_PHOTOEDITOR__ */ 

    #ifdef __MMI_IMAGE_VIEWER_ADV__
        case MMI_CAMCO_CAM_OPTION_PAN_AND_ZOOM:
            mmi_camco_cam_entry_image_view_cui();
            break;
    #endif /* __MMI_IMAGE_VIEWER_ADV__ */ 

        default:
            break;
    }

    g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_done_option_rsk_released
 * DESCRIPTION
 *  camera autorama done option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_done_option_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_cam_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

    mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_cam_p->buf_filename_p +
                                      (2 * mmi_ucs2strlen(mmi_camco_cam_p->storage_filepath_p)));

    mmi_camco_cam_autorama_done_set_key_hdlr();
    SetKeyHandler(mmi_camco_cam_capture_button_preview_pressed, KEY_CAMERA, KEY_EVENT_DOWN);

    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    mmi_camco_osd_draw_osd();
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_restore_confirm_lsk_released
 * DESCRIPTION
 *  
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_restore_confirm_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_restore_default();

    mmi_camco_cam_face_detect_stop();
    
    mmi_camco_cam_p->addframe_coloridx_index = 0;

    if (mmi_camco_cam_p->external_request.is_enable)
    {
        mmi_camco_set_external_capmode_capability();
    #ifdef DUAL_CAMERA_SUPPORT
        mmi_camco_set_external_camswitchto_capability();
    #else 
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_CAMSWITCHTO);
    #endif 
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);
    }
    else if (mmi_camco_rec_p->external_request.is_enable)
    {
    #ifdef DUAL_CAMERA_SUPPORT
        mmi_camco_set_external_vdoswitchto_capability();
    #else 
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_VDOSWITCHTO);
    #endif 
        mmi_camco_set_external_visqty_capability();
        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) > MMI_CAMCO_RECSIZE_CIF)
        {
        #ifdef __MMI_OP02_LEMEI__   
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);      
        #else             
            if (mmi_camco_setting_get_itemlist_capability(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF) ==
                MMI_CAMCO_SETTING_CAP_ENABLED)
            {
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF);
            }
            else
            {
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);
            }
        #endif            
			mmi_camco_update_vdosize(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE));
        }
    }
    else if (g_mmi_camco_cntx.partial_app.is_only_recorder)
    {
    #ifdef DUAL_CAMERA_SUPPORT
        mmi_camco_set_external_vdoswitchto_capability();
    #else 
        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_VDOSWITCHTO);
    #endif 
    }

    mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
    mmi_camco_highlight_turn_off();

    mmi_camco_need_restart_preview();

    app = mmi_camco_setting_get_active_app();
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
    else
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_restore_confirm_rsk_released
 * DESCRIPTION
 *  
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_restore_confirm_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    app = mmi_camco_setting_get_active_app();
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_SETTING_MENU);
    }
    else
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SETTING_MENU);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_delete_confirm
 * DESCRIPTION
 *  camera save done state option lsk released handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_delete_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_prof_tone_enum tone_type = SRV_PROF_TONE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.option = MMI_CAMCO_CAM_OPTION_DELETE;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_DELETE_QUERY));

#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_delete_confirm_evt_hdlr);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_set_csk_action_mode(MMI_FALSE);
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_delete_confirm_rsk_released);
            mmi_camco_osd_set_lsk_img(
                IMG_ID_CAMCO_OK,
                IMG_ID_CAMCO_OK_SEL,
                mmi_camco_cam_multishot_delete_confirm_lsk_released);
        #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_delete_confirm_rsk_released);
        mmi_camco_osd_set_lsk_img(
            IMG_ID_CAMCO_OK,
            IMG_ID_CAMCO_OK,
            mmi_camco_cam_multishot_delete_confirm_lsk_released);
        #endif
    #else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_osd_set_rsk_str(STR_GLOBAL_NO, mmi_camco_cam_delete_confirm_rsk_released);
        mmi_camco_osd_set_lsk_str(STR_GLOBAL_YES, mmi_camco_cam_multishot_delete_confirm_lsk_released);
    #endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_set_csk_action_mode(MMI_TRUE);

    #endif /* __MMI_CAMCO_FTE__ */ 

    }
    else
#endif /* defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__) */ 
    {

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_delete_confirm_evt_hdlr);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_set_csk_action_mode(MMI_FALSE);    
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_delete_confirm_rsk_released);
            mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_delete_confirm_lsk_released);
        #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_delete_confirm_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_delete_confirm_lsk_released);
        #endif
    #else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_osd_set_rsk_str(STR_GLOBAL_NO, mmi_camco_cam_delete_confirm_rsk_released);
        mmi_camco_osd_set_lsk_str(STR_GLOBAL_YES, mmi_camco_cam_delete_confirm_lsk_released);
    #endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        mmi_camco_set_csk_action_mode(MMI_TRUE);

    #endif /* __MMI_CAMCO_FTE__ */ 

    }

    mmi_camco_osd_draw_osd();

    if (!g_mmi_camco_cntx.option_menulist.is_fromhistory)
    {
        tone_type = mmi_get_event_based_sound(MMI_EVENT_QUERY);
        if (tone_type != NONE_TONE)
        {
            srv_prof_play_tone(tone_type, NULL);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_forward_menu
 * DESCRIPTION
 *  mmi_camco_cam_forward_menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_forward_menu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_id;
    U16 item_strlist[MMI_CAMCO_FORWARD_ITEM_NUM];
    U16 i = 0;
#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
    U16 idx;
    CHAR* buf_filename;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.option = MMI_CAMCO_CAM_OPTION_FORWARD;

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_forward_menu_evt_hdlr);
#else /* __MMI_CAMCO_FTE__ */ 
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_forward_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_cam_forward_menu_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_forward_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_cam_forward_menu_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_forward_menu_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_cam_forward_menu_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 
#endif /* __MMI_CAMCO_FTE__ */ 

    for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
    {
        item_strlist[i] = 0;
    }

#if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT)
    {
        mmi_camco_osd_get_imgselect_cur_img_info(&idx, &buf_filename);
        menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)buf_filename);
    }
    else
#endif /* defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__) */ 
    {
        menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)mmi_camco_cam_p->buf_filename_p);
    }

    if (menu_id > 0)
    {
        GetSequenceStringIds_Ext(menu_id, item_strlist);
        GetSequenceItemIds_Ext(menu_id, g_mmi_camco_cntx.fowarditem_idlist);

        mmi_camco_osd_set_option_title(STR_GLOBAL_FORWARD);

        for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
        {
            if (item_strlist[i] != 0)
            {
                mmi_camco_osd_insert_option_item(g_mmi_camco_cntx.fowarditem_idlist[i], (MMI_ID_TYPE) item_strlist[i]);
            }
            else
            {
                break;
            }
        }

        mmi_camco_osd_insert_option_done();

        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);

        mmi_camco_osd_draw_osd();
    }
    else
    {
        mmi_camco_file_deleted_hdlr();
    }

}


#ifdef __MMI_CAMCO_FEATURE_CAM_MULTI_ANGLE_VIEW_SHOT__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_view_group_proc
 * DESCRIPTION
 *  FMGR image view process
 * PARAMETERS
 *  evt     [OUT]       Event pointer
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_camco_cam_view_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_GROUP_ENTER:
            /* enter group ToDo1 */
            break;
        case EVT_ID_GROUP_ACTIVE:
            /* enter group ToDo2 */
            break;
        case EVT_ID_GROUP_FOCUSED:
            /* enter group ToDo3 */
            break;
        case EVT_ID_GROUP_GOBACK:
            /* gobackhistory ToDo1 */
            break;
        case EVT_ID_GROUP_INACTIVE:
            /* gobackhistory ToDo2 */
            break;
        case EVT_ID_GROUP_EXIT:
            /* gobackhistory ToDo3 */
            break;
        case EVT_ID_GROUP_DEINIT:
            /* gobackhistory ToDo4 */
            break;
        case EVT_ID_IMGVIEW_CLOSE_GID:
            /* closegroup ToDo1 */
        {
            mmi_group_event_struct *cui_evt;

            cui_evt = (mmi_group_event_struct*) evt;
            cui_imgview_close(cui_evt->sender_id);
            break;
        }
        default:
            break;
    }
    return MMI_RET_OK;
}


/* Imgview CUI using start */

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_view_run_imgview_cui
 * DESCRIPTION
 *  Run image view CUI
 * PARAMETERS
 *  file_path       [IN]        
 *  file_info       [IN]        
 *  app_id          [IN]        
 *  string          [IN]        
 *  icon            [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_view_run_imgview_cui(CHAR* file_path, U16 app_id, U16 string, U16 icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id temp_parent_gid;
    mmi_id imgview_gid;
    cui_imgview_ui_direction_enum rotate;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef HORIZONTAL_CAMERA
		if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
		{
			rotate = CUI_IMGVIEW_UI_DIRECTION_HORIZONTAL;
		}
		else
		{
	
			rotate = CUI_IMGVIEW_UI_DIRECTION_VERTICAL;
	
		}
#else 
    rotate = CUI_IMGVIEW_UI_DIRECTION_VERTICAL;
#endif 
	temp_parent_gid = mmi_frm_group_create(g_mmi_camco_cntx.memory_group_id, GRP_ID_AUTO_GEN, mmi_camco_cam_view_group_proc, NULL);
    mmi_frm_group_enter(temp_parent_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    if ((imgview_gid = cui_imgview_create(temp_parent_gid)) != GRP_ID_INVALID)
    {
        cui_imgview_set_mode_filename(imgview_gid, file_path);
        cui_imgview_set_app_id(imgview_gid, app_id);
        //cui_imgview_set_title(imgview_gid, NULL, icon);
        cui_imgview_set_ui_direction(imgview_gid, rotate);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_ALL, MMI_TRUE);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_FILENAME, MMI_FALSE);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_COUNTER, MMI_FALSE);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_SLIDESHOW, MMI_FALSE);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_TITLE, MMI_FALSE);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_DB, MMI_FALSE);
        cui_imgview_run(imgview_gid);
    }
    else
    {
        mmi_frm_group_close(temp_parent_gid);
        /* TODO: add trace */
    }
}

/* Imgview CUI using end */


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_entry_imgadv_pan_zoom
 * DESCRIPTION
 *  mmi_camco_cam_entry_imgadv_pan_zoom
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_entry_image_view_cui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    mmi_ucs2cpy( ucs2_filename,  mmi_camco_cam_p->buf_filename_p);

    g_mmi_camco_cntx.is_to_media_editor = MMI_TRUE;
    mmi_camco_cam_view_run_imgview_cui(
        ucs2_filename,
        APP_IMAGEVIEWER,
        NULL,
        GetRootTitleIcon(MENU_ID_IMGVIEW_APP));
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_entry_photoeditor
 * DESCRIPTION
 *  mmi_camco_cam_entry_photoeditor
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_PHOTOEDITOR__
static void mmi_camco_cam_entry_photoeditor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.option = MMI_CAMCO_CAM_OPTION_PHOTOEDITOR;

    memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    mmi_ucs2cpy( ucs2_filename,  mmi_camco_cam_p->buf_filename_p);

    g_mmi_camco_cntx.is_to_media_editor = MMI_TRUE;
    mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
    mmi_phoedt_entry_from_fmgr((const WCHAR *)ucs2_filename);

}
#endif /* __MMI_PHOTOEDITOR__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autofocus_result_hdlr
 * DESCRIPTION
 *  focus result handler
 * PARAMETERS
 *  result_ind      [IN]        Auto focus indication
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autofocus_result_hdlr(mdi_camera_af_result_struct result_ind, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_AF_RESULT, result_ind.af_result);

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSING && !mmi_camco_cam_p->is_takepic_failed)
    {
        if (result_ind.af_result == MDI_AF_SEARCH_STATUS_FOUND_SUCCESS)
        {
            mmi_camco_cam_p->af_result.af_result = result_ind.af_result;
            mmi_camco_cam_p->af_result.af_success_zone = result_ind.af_success_zone;

            mmi_camco_play_autofocus_success_sound();
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_FOCUSED);                      
        }
        else if (result_ind.af_result == MDI_AF_SEARCH_STATUS_SWITCH_MACRO)
        {
            /* Camera is still in MMI_CAMCO_STATE_CAM_FOCUSING */
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_FOCUSE_HINT);
            mmi_camco_osd_set_center_focus_process_hint_img(IMG_ID_CAMCO_AFRANGE_MACRO);
        }
        else
        {
            U8 idx;
            U16 region_idx;
            U16 w, h;
            U16 center_x, center_y;
            U32 af_active_zone = 0;

            af_active_zone = mmi_camco_cam_p->af_zone.af_active_zone;

            for (idx = MMI_CAMCO_OSD_FOCUS_REGION_1; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
            {
                if (af_active_zone & 0x00000001)
                {
                    region_idx = MMI_CAMCO_OSD_FOCUS_REGION_1 + idx;

                    w = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_w;
                    h = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_h;
                    center_x = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
                    center_y = mmi_camco_cam_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;

                    mmi_camco_osd_set_focus(
                        (mmi_camco_osd_focus_region_enum)region_idx,
                        MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSING_FAIL,
                        center_x,
                        center_y,
                        w,
                        h);
                }
                af_active_zone = af_active_zone >> 1;
            }

        }

        mmi_camco_osd_draw_osd();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_result_hdlr
 * DESCRIPTION
 *  no block burst shot capture result handler
 * PARAMETERS
 *  ret                 [IN]        Burst shot result
 *  captured_count      [IN]        Capture count
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__
static void mmi_camco_cam_burstshot_result_hdlr(MDI_RESULT ret, U16 captured_count, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_BURSTSHOT_RESULT, ret, captured_count);
    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_CAM_BURSTSHOT)
    {
        return;
    }

    if (captured_count < MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT && ret == MDI_RES_CAMERA_SUCCEED)
    {
        return;
    }
    else if (ret != MDI_RES_CAMERA_SUCCEED)
    {
        mmi_camco_osd_set_bg_black();
        mmi_camco_show_error_msg(ret);
        mmi_camco_error_hdlr_timer_start();

        return;
    }

    MMI_CAMCO_STOP_LOGGING("BUS");

    if (captured_count == MMI_CAMCO_FEATURE_CAM_BURSTSHOT_IMAGE_COUNT && ret == MDI_RES_CAMERA_SUCCEED)
    {
        mmi_camco_highlight_turn_off();
        mmi_camco_cam_p->is_burstshot_finish = MMI_TRUE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT);
    }

}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 
#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_quickview_result_hdlr
 * DESCRIPTION
 *  autorama quick stitch result back ,and set image stitch  info
 * PARAMETERS
 *  result_ind_p        [IN]        autorama quickview stitch result
 *  user_data           [IN]        
 * RETURNS
 *  void
 *****************************************************************************/

static void mmi_camco_cam_autorama_quickview_result_hdlr(mdi_camera_panorama_stitch_quickview_struct *result_ind_p, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    mdi_camera_panorama_stitch_encode_struct encode_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_STITCH_RESULT, g_mmi_camco_cntx.app_state);

    MMI_CAMCO_STOP_LOGGING("STI");
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH)
    {
        if (result_ind_p->result == MDI_RES_CAMERA_SUCCEED)
        {
            mmi_camco_highlight_turn_off();
            encode_info.quickview_roi_x = result_ind_p->quickview_start_x;
            encode_info.quickview_roi_y = result_ind_p->quickview_start_y;
            encode_info.quickview_roi_width = result_ind_p->quickview_width;
            encode_info.quickview_roi_height = result_ind_p->quickview_height;  
            encode_info.is_quickview_centred = MMI_TRUE;// quick view image data is in the center of quick view buffer. 
            mdi_camera_encode_panorama_stitch_image(&encode_info);
            mmi_camco_osd_draw_osd();
            
        }
        else
        {
            mmi_camco_osd_set_bg_black();
            mmi_camco_show_error_msg(result_ind_p->result);
            mmi_camco_error_hdlr_timer_start();
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_autorama_stitch_result_hdlr
 * DESCRIPTION
 *  no block burst shot capture mmi_camco_cam_autorama_stitch_result_hdlr handler
 * PARAMETERS
 *  result_ind_p        [IN]        autorama stitch result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_autorama_stitch_result_hdlr(mdi_camera_panorama_stitch_result_struct *result_ind_p, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_INTERACTIVE_PROFILNG__
    CHAR log[50];
    CHAR str[50];
    U32 tempticks;
#endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAM_STITCH_RESULT, g_mmi_camco_cntx.app_state);

    MMI_CAMCO_STOP_LOGGING("STI");

    mmi_camco_cam_p->autorama_shot.is_stitch_done = MMI_TRUE;
    mmi_camco_cam_p->autorama_shot.stitch_result = result_ind_p->result;

    if (result_ind_p->result == MDI_RES_CAMERA_SUCCEED)
    {
        mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_address = result_ind_p->jpeg_buffer_address;
        mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_size = result_ind_p->jpeg_buffer_size;
        mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_image_width = result_ind_p->jpeg_image_width;
        mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_image_height = result_ind_p->jpeg_image_height;

        mmi_camco_cam_p->capture_buf_ptr = (PU8) mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_address;
        mmi_camco_cam_p->capture_size = mmi_camco_cam_p->autorama_shot.stitch_ind.jpeg_buffer_size;
    }

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH)
    {
        if (mmi_camco_cam_p->autorama_shot.stitch_result == MDI_RES_CAMERA_SUCCEED)
        {
            mmi_camco_highlight_turn_off();

        #ifdef __MMI_INTERACTIVE_PROFILNG__
            if (mmi_frm_profiling_interactive_is_enabled())
            {
                memset(log, 0, sizeof(log));
                memset(str, 0, sizeof(str));
                kal_get_time(&end_ticks);
                tick_elapsed = (end_ticks - start_ticks);
                tick_elapsed = ((double)tick_elapsed * 4.615);  /* msec */

                sprintf(log, "%.3f ms", tick_elapsed);
                mmi_asc_to_ucs2((CHAR*) str, (CHAR*) log);
                gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
                gui_move_text_cursor(0, 100);
                gui_set_text_color(gui_color(255, 0, 0));
                gui_set_text_border_color(gui_color(255, 255, 255));
                gui_print_bordered_text((UI_string_type) str);
                gdi_layer_pop_and_restore_active();
                mmi_camco_osd_draw_osd();
                kal_get_time(&tempticks);
                start_ticks += (tempticks - end_ticks);
            }
        #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);

            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
            mmi_camco_osd_draw_osd();
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AUTORAMA_DONE);
        }
        else
        {
            mmi_camco_osd_set_bg_black();
            mmi_camco_show_error_msg(result_ind_p->result);
            mmi_camco_error_hdlr_timer_start();
        }
    }

}
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_error_hdlr
 * DESCRIPTION
 *  camera error handling
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_error_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_ERROR_HDLR, g_mmi_camco_cntx.app_state);

    ClearKeyEvents();

    g_mmi_camco_cntx.is_errortimer_start = MMI_FALSE;
    switch (g_mmi_camco_cntx.app_state)
    {
        case MMI_CAMCO_STATE_CAM_PREVIEW:
        case MMI_CAMCO_STATE_CAM_COUNTDOWN:
        case MMI_CAMCO_STATE_CAM_FOCUSING:
        case MMI_CAMCO_STATE_CAM_FOCUSED:
        case MMI_CAMCO_STATE_CAM_BURSTSHOT:
        case MMI_CAMCO_STATE_CAM_SETTING_MENU:
        case MMI_CAMCO_STATE_CAM_SUB_PREVIEW:
        case MMI_CAMCO_STATE_CAM_CAPTURE:
        case MMI_CAMCO_STATE_CAM_SAVE_DONE:
        case MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT:
        case MMI_CAMCO_STATE_CAM_AUTORAMA_STITCH:
        case MMI_CAMCO_STATE_CAM_AUTORAMA_DONE:
        case MMI_CAMCO_STATE_CAM_SMILE_DECT: 
        case MMI_CAMCO_STATE_CAM_HDR_SHOT:
        case MMI_CAMCO_STATE_CAM_HDR_DONE:
		case MMI_CAMCO_STATE_CAM_MAV_SHOT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
            break;

        case MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_BURSTSHOT_SELECT);
            break;

        case MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT:
            mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_AEBSHOT_SELECT);
            break;

        case MMI_CAMCO_STATE_REC_PREVIEW:
        case MMI_CAMCO_STATE_REC_SAVING:
        case MMI_CAMCO_STATE_REC_FOCUSING:
        case MMI_CAMCO_STATE_REC_FOCUSED:
        case MMI_CAMCO_STATE_REC_SAVE_DONE:
            /*during error msg shown, the memory card may be removed and no popup because still in rec state */
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));                        
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
            break;

        case MMI_CAMCO_STATE_REC_RECORDING:
            gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
            /*during error msg shown, the memory card may be removed and no popup because still in rec state */
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
            break;

        case MMI_CAMCO_STATE_REC_PAUSE:
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
            break;

        default:
            MMI_ASSERT(0);
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_preview_terminate_hdlr
 * DESCRIPTION
 *  camera preview terminate handling
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
static void mmi_camco_preview_terminate_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT);

    g_mmi_camco_cntx.preview_timeout_count += MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR;

#ifdef __MMI_CAMCO_FEATURE_FD_PAUSE_PREVIEW_WATCHDOG__
    if (mmi_camco_setting_is_facedetect_on() &&
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW &&
        mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
    {
        g_mmi_camco_cntx.preview_timeout_count = 0;
    }
#endif /* __MMI_CAMCO_FEATURE_FD_PAUSE_PREVIEW_WATCHDOG__ */ 

    if (g_mmi_camco_cntx.preview_timeout_count < MMI_CAMCO_PREVIEW_WATCHDOG_TIMEOUT_DUR)
    {
        gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
        return;
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_TIMEOUT);
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_ADD_FRAME ||
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SUB_PREVIEW ||
#endif 
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SETTING_MENU ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_RESTORE_CONFIRM)
    {
        mmi_camco_exit_app();
    }
    else
    {
        gui_cancel_timer(mmi_camco_preview_terminate_hdlr);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_reset_preview_terminate_timer
 * DESCRIPTION
 *  stop camera preview terminate timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_reset_preview_terminate_timer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_preview_terminate_hdlr);
    g_mmi_camco_cntx.preview_timeout_count = 0;
    gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
}
#endif /* __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_highlight_turn_on
 * DESCRIPTION
 *  turn on LED
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_highlight_turn_on(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_camco_cntx.is_highlight_on)
    {
        if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
        {   
             mdi_camera_flash_setting(TRUE);
        }
        else
        {
             mdi_video_flash_setting(TRUE);	 
        }
        g_mmi_camco_cntx.is_highlight_on = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_highlight_turn_off
 * DESCRIPTION
 *  turn on LED
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_highlight_turn_off(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_highlight_on)
    {
        if (mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
        {    
            mdi_camera_flash_setting(FALSE);
        }
        else
        {
            mdi_video_flash_setting(FALSE);	 
        }
        g_mmi_camco_cntx.is_highlight_on = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_countdown_led_turn_on
 * DESCRIPTION
 *  turn on LED
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_countdown_led_turn_on(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_camco_setting_is_highlight_on())
    {
        mmi_camco_highlight_turn_on();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_countdown_led_turn_off
 * DESCRIPTION
 *  turn off LED
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_countdown_led_turn_off(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_camco_highlight_turn_off();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_get_max_capture_resolution
 * DESCRIPTION
 *  for External Request
 * PARAMETERS
 *  width_p         [OUT]       
 *  height_p        [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_get_max_capture_resolution(S32 *width_p, S32 *height_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FEATURE_CAM_IMGSZIE_SUPPORT_5M__
    *width_p = 2592;
    *height_p = 1944;
#else /* __MMI_CAMCO_FEATURE_CAM_IMGSZIE_SUPPORT_5M__ */ 
    *width_p = 2048;
    *height_p = 1536;
#endif /* __MMI_CAMCO_FEATURE_CAM_IMGSZIE_SUPPORT_5M__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__
    *width_p = 4092;
    *height_p = 3070;
#endif /* __MMI_CAMCO_FEATURE_CAM_AUTORAMA_SHOT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_send_to_mms
 * DESCRIPTION
 *  send to mms
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_MMS__
static void mmi_camco_send_to_mms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE];

	#ifdef PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA
	    mmi_camco_setting_app_enum app;
    #endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(buf_filepath, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    if (MMI_CAMCO_SETTING_APP_CAMERA == mmi_camco_setting_get_active_app())
    {
        mmi_ucs2cat((CHAR*) buf_filepath, (CHAR*) mmi_camco_cam_p->buf_filename_p);
    }
    else
    {
        mmi_ucs2cat((CHAR*) buf_filepath, (CHAR*) mmi_camco_rec_p->buf_filename_p);
    }

    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(buf_filepath))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    /* if mms need to resize pic, camco need to let MED free memory */
#ifdef PANORAMA_MAX_INPUT_IMAGE_SIZE_VGA
	app = mmi_camco_setting_get_active_app();

    if (MMI_CAMCO_SETTING_APP_CAMERA == app)
    {
        mmi_camco_cam_power_off();
    }
#endif 

    mms_content_insert_hdlr((CHAR*) buf_filepath);
}
#endif /* __MMI_MMS__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_init_sublcd
 * DESCRIPTION
 *  init sublcd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_SUBLCD__
static void mmi_camco_init_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
    gdi_layer_get_base_handle(&g_mmi_camco_cntx.sublcd_base_layer_handle);
    gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

    if (!g_mmi_camco_cntx.is_sublcd_display)
    {
        ForceSubLCDScreen(mmi_camco_entry_sublcd_screen);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_deinit_sublcd
 * DESCRIPTION
 *  init sublcd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_deinit_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.sublcd_base_layer_handle);
    gdi_layer_set_rotate(CAMCO_LCM_ROTATE_0);
    mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.sublcd_base_layer_handle);
	g_mmi_camco_cntx.sublcd_base_layer_handle = NULL;
    gdi_layer_pop_and_restore_active();
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

    /* exit sublcd */
    if (g_mmi_camco_cntx.is_sublcd_display)
    {
        GoBackSubLCDHistory();
        g_mmi_camco_cntx.is_sublcd_display = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_entry_sublcd_screen
 * DESCRIPTION
 *  entry sublcd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_entry_sublcd_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_mmi_camco_cntx.is_sublcd_display)
    {
        ExecSubLCDCurrExitHandler();
        ShowCategory331Screen();
        SetSubLCDExitHandler(mmi_camco_exit_sublcd_screen);

        mmi_camco_sublcd_draw_icon();

        g_mmi_camco_cntx.is_sublcd_display = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_sublcd_screen
 * DESCRIPTION
 *  exit sublcd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_sublcd_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    SubLCDHistoryNode sub_history;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.is_sublcd_display = MMI_FALSE;

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */ 
    sub_history.entryFuncPtr = mmi_camco_entry_sublcd_screen;
    AddSubLCDHistory(&sub_history);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_sublcd_draw_icon
 * DESCRIPTION
 *  draw icon on sublcd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_sublcd_draw_icon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 lcd_width;
    S32 lcd_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.sublcd_base_layer_handle);
    gdi_lcd_set_rotate_by_layer(TRUE);
#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);
    }
#endif /* HORIZONTAL_CAMERA */ 
    gdi_lcd_get_dimension(&lcd_width, &lcd_height);

    gdi_layer_reset_clip();

    gdi_layer_clear_background(GDI_COLOR_WHITE);
    gdi_image_get_dimension_id(IMG_ID_CAMCO_PREVIEW_SUBLCD_ICON, &image_width, &image_height);
    gdi_image_draw_id(
        (lcd_width - image_width) >> 1,
        (lcd_height - image_height) >> 1,
        IMG_ID_CAMCO_PREVIEW_SUBLCD_ICON);
    gdi_layer_blt_base_layer(0, 0, lcd_width - 1, lcd_height - 1);
#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
    }
#endif /* HORIZONTAL_CAMERA */ 
    gdi_layer_pop_and_restore_active();
    gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
}
#endif /* __MMI_SUBLCD__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_switch_to_sublcd
 * DESCRIPTION
 *  switch to sublcd cam
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
void mmi_camco_cam_switch_to_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->is_switchto_sublcd = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_unswitch_to_sublcd
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_unswitch_to_sublcd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->is_switchto_sublcd = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_mainlcd_draw_icon
 * DESCRIPTION
 *  draw icon on mainlcd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_mainlcd_draw_icon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width;
    S32 image_height;
    S32 lcd_width;
    S32 lcd_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
    gdi_lcd_get_dimension(&lcd_width, &lcd_height);
    gdi_layer_resize(lcd_width, lcd_height);
    gdi_layer_set_position(0, 0);
    gdi_layer_clear_background(GDI_COLOR_BLACK);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */ 
    gdi_layer_pop_and_restore_active();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_cam_sub_preview_state
 * DESCRIPTION
 *  enter camera sub preview state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_cam_sub_preview_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SETTING_MENU ||
               g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SAVE_DONE ||
               g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_INT_SUB_PREVIEW);

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
    mmi_camco_mainlcd_draw_icon();
    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_CAM_SUBLCD_SWITCH));

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_sub_preview_evt_hdlr);
#else 
    mmi_camco_cam_sub_preview_set_key_hdlr();
#endif 
    mmi_camco_osd_draw_osd();

    if (!g_mmi_camco_cntx.is_preview_start)
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_SUBLCD_CAMERA_PREVIEW);

        gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
        gdi_layer_clear_background(GDI_COLOR_BLACK);
        gdi_lcd_set_rotate(GDI_LAYER_ROTATE_0);
        gdi_layer_blt_base_layer(0, 0, SUBLCD_WIDTH - 1, SUBLCD_HEIGHT - 1);

        if (TRUE == mmi_camco_cam_sublcd_preview_start())
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_SUB_PREVIEW;
            g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
            g_mmi_camco_cntx.is_restart_preview = MMI_FALSE;

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_cam_sub_preview_evt_hdlr);
        #else 
            mmi_camco_cam_sub_preview_set_key_hdlr();
        #endif 
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);

        #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
            gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
        #endif 

        }
        else
        {
            /* Camco is in MMI_CAMCO_STATE_CAM_SETTING_MENU */
            ClearAllKeyHandler();
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_SUBLCD_CAMERA_STOP_HINT);
            mmi_camco_sublcd_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_PREVIEW_FAILED));
            mmi_camco_osd_draw_osd();

            g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
            /* show preview fail on osd */

            mmi_camco_error_hdlr_timer_start();
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_cam_sub_preview_state
 * DESCRIPTION
 *  exit camera sub preview state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_cam_sub_preview_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_camco_cam_p->is_takepic_failed)
    {
        mmi_camco_cam_preview_stop();
    }
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.sublcd_base_layer_handle);
    mdi_util_hw_layer_switch_to_sw_layer(g_mmi_camco_cntx.sublcd_base_layer_handle);
    gdi_layer_resize(SUBLCD_WIDTH, SUBLCD_HEIGHT);
    gdi_layer_set_position(0, 0);
    gdi_layer_pop_and_restore_active();	
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_resize_preview_sublcd_layer
 * DESCRIPTION
 *  resize preview layer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_resize_preview_sublcd_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.sublcd_base_layer_handle);
    gdi_layer_resize(g_mmi_camco_cntx.sublcd_preview_wnd.width, g_mmi_camco_cntx.sublcd_preview_wnd.height);
    gdi_layer_set_position(g_mmi_camco_cntx.sublcd_preview_wnd.offset_x, g_mmi_camco_cntx.sublcd_preview_wnd.offset_y);
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);    

    gdi_layer_set_background(GDI_COLOR_BLACK);
     
#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);        
    }
    else
#endif
    {
        gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);        
    }    
    gdi_layer_pop_and_restore_active();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sublcd_preview_start
 * DESCRIPTION
 *  start previewing on main LCD
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_camco_cam_sublcd_preview_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = FALSE;
    MDI_RESULT result;
    mdi_camera_setting_struct camera_setting_data;
    mdi_camera_preview_struct camera_preview_data;
    S32 sublcd_width;
    S32 sublcd_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    camera_setting_data.image_resolution = mmi_camco_get_cmd_capsize(&mmi_camco_cam_p->image_width, &mmi_camco_cam_p->image_height);
    
    mmi_camco_cam_get_preview_window(MMI_CAMCO_CAM_PREVIEW_SUBLCD);
    mmi_camco_resize_preview_sublcd_layer();

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_SUBLCD_CAMERA_PREVIEW);

    camera_setting_data.zoom = mmi_camco_get_camzoom();
    camera_setting_data.wb = mmi_camco_get_cmd_wb(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_WB));
    camera_setting_data.ev = mmi_camco_get_cmd_ev(mmi_camco_setting_get_camev_value());
    camera_setting_data.banding = mmi_camco_get_cmd_banding(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_BANDING));
    if(mmi_camco_setting_flash_is_enable())
    {
        camera_setting_data.flash = mmi_camco_get_cmd_flash(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FLASH));
    }        
    else
    {
        if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_HIGHLIGHT) == MMI_CAMCO_HIGHLIGHT_OFF)
            camera_setting_data.flash = mmi_camco_get_cmd_flash(MMI_CAMCO_FLASH_OFF);        
        else
            camera_setting_data.flash = mmi_camco_get_cmd_flash(MMI_CAMCO_FLASH_FORCE_ON);                
    }   

    camera_setting_data.iso = mmi_camco_get_cmd_iso(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_ISO));
    camera_setting_data.ae_meter = mmi_camco_get_cmd_aemeter(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AEMETER));
    camera_setting_data.scene_mode = mmi_camco_get_cmd_camscenemode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAMSCENEMODE));

    camera_setting_data.effect = mmi_camco_get_cmd_effect(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_EFFECT));
    camera_setting_data.saturation = mmi_camco_get_cmd_saturation(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SATURATION));
    camera_setting_data.contrast = mmi_camco_get_cmd_contrast(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CONTRAST));
    camera_setting_data.hue = 0;

    camera_setting_data.overlay_frame_mode = FALSE;
    camera_setting_data.overlay_frame_depth = 0;
    camera_setting_data.overlay_frame_width = 0;
    camera_setting_data.overlay_frame_height = 0;
    camera_setting_data.overlay_frame_source_key = 0;
    camera_setting_data.overlay_frame_buffer_address = 0;

    camera_setting_data.preview_width = g_mmi_camco_cntx.sublcd_preview_wnd.width;
    camera_setting_data.preview_height = g_mmi_camco_cntx.sublcd_preview_wnd.height;

    /* capture parameters */
    camera_setting_data.image_qty = mmi_camco_get_cmd_capqty(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPQTY));
    camera_setting_data.image_width = mmi_camco_cam_p->image_width;
    camera_setting_data.image_height = mmi_camco_cam_p->image_height;

    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_FLASH) != MMI_CAMCO_FLASH_OFF &&
        mmi_camco_setting_get_setting_capability(MMI_CAMCO_SETTING_FLASH) == MMI_CAMCO_SETTING_CAP_ENABLED)
    {
        camera_setting_data.xenon_flash_status_callback = mmi_camco_xenon_flash_callback;
    }
    else
    {
        camera_setting_data.xenon_flash_status_callback = NULL;
    }

    camera_setting_data.lcm = MDI_CAMERA_PREVIEW_LCM_SUBLCD;

    camera_setting_data.af_operation_mode = mmi_camco_get_cmd_afmode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE));
    camera_setting_data.af_range = mmi_camco_get_cmd_afrange(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFRANGE));
    camera_setting_data.sharpness = mmi_camco_get_cmd_sharpness(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SHARPNESS));

    camera_preview_data.preview_layer_handle = g_mmi_camco_cntx.sublcd_base_layer_handle;
    camera_preview_data.blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
    camera_preview_data.preview_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
    camera_preview_data.is_lcd_update = TRUE;
    camera_preview_data.src_key_color = GDI_COLOR_TRANSPARENT;
    camera_preview_data.is_tvout = TRUE;

    result = mdi_camera_preview_start(&camera_preview_data, &camera_setting_data, NULL);
    if (result == MDI_RES_CAMERA_SUCCEED)
    {
        ret = TRUE;
        if (mmi_camco_setting_is_highlight_on())
        {
            mmi_camco_highlight_turn_on();
        }
    }
    return ret;
}

#ifndef __MMI_CAMCO_FTE__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sub_preview_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_sub_preview_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_cam_sub_preview_rsk_released);
    #else
    mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_cam_sub_preview_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_cam_sub_preview_rsk_released);
#endif 
    SetKeyHandler(mmi_camco_cam_sub_preview_switch_button_released, KEY_STAR, KEY_EVENT_UP);

    if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
    {
        SetKeyHandler(mmi_camco_cam_sublcd_capture_button_pressed, KEY_CSK, KEY_EVENT_DOWN);
        SetKeyHandler(mmi_camco_cam_sublcd_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    }
}
#endif /* __MMI_CAMCO_FTE__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sublcd_preview_csk_pressed
 * DESCRIPTION
 *  camera preview state csk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_sublcd_preview_csk_pressed(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_sublcd_capture_button_pressed();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sublcd_capture_button_pressed
 * DESCRIPTION
 *  camera sublcd capture botton press handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_sublcd_capture_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_cam_p->is_sublcd_capture = MMI_TRUE;
    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_CAPTURE);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sub_preview_rsk_released
 * DESCRIPTION
 *  camera sub preview state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_sub_preview_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_exit_app();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sub_preview_switch_button_released
 * DESCRIPTION
 *  camera sublcd switch botton released handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_cam_sub_preview_switch_button_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SUB_PREVIEW)
    {
        mmi_camco_exit_cam_sub_preview_state();

        mmi_camco_sublcd_draw_icon();

        /*  
         * Before enter preview from non-preview state, re-draw osd in advance.
         * Otherwise, there will some noise in screen when driver blt in first time.
         */
        g_mmi_camco_cntx.is_restart_preview = MMI_TRUE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
    }
}
#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_check_filename
 * DESCRIPTION
 *  get the first file name for jpeg image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_check_filename(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    U16 filename_seq_no;
    U32 start_to_check = 0;
    U32 end_to_check = 0;
    float duration;
    U32 tick_elapsed_fraction;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_get_time(&start_to_check);
    mmi_camco_rec_get_next_filename(mmi_camco_rec_p->buf_filename_p);
    kal_get_time(&end_to_check);

    duration = (end_to_check - start_to_check);
    duration = ((float)duration * 4.615);   /* msec */
    tick_elapsed_fraction = (end_to_check - start_to_check) * 4615 - ((int)duration) * 1000;

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_CHECK_FILENAME, (int)duration, tick_elapsed_fraction);

    ReadValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
    filename_seq_no--;
    WriteValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_get_next_filename
 * DESCRIPTION
 *  get next file name for jpeg image
 * PARAMETERS
 *  filepath_buf_p      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_get_next_filename(CHAR* filepath_buf_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#define CAMCO_TEMP_BUFFER_LENGTH    (50)
#define CAMCO_MAX_FILE_NUM          (20000)

    CHAR buffer[CAMCO_TEMP_BUFFER_LENGTH];
    CHAR ucs2_buffer[CAMCO_TEMP_BUFFER_LENGTH];
    CHAR ucs2_testname[CAMCO_TEMP_BUFFER_LENGTH];
    S16 error = 0;
    U16 filename_seq_no;
    FS_HANDLE file_handle;
    U32 left = 0;
    U32 right = 0;
    U32 mid = 0;
    S32 last_file_exist_num = -1;
    U16 video_format;
    MMI_BOOL is_binary_search = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	  video_format = (mmi_camco_viscodec_enum)mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VISCODEC);
    /* get/store sequentail number */
    ReadValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
    if (filename_seq_no == 0xffff)
    {
        filename_seq_no = 1;    /* init value */
    }
    else
    {
        filename_seq_no++;

        if (filename_seq_no > 20000)    /* more than 4 digits */
        {
            filename_seq_no = 1;
        }
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_GET_NEXT_FILENAME, (int)filename_seq_no);

    sprintf( buffer, "MOV%05d", filename_seq_no);
    mmi_asc_to_ucs2( ucs2_buffer,  buffer);

    mmi_ucs2cpy(ucs2_testname, ucs2_buffer);
    if (video_format == MMI_CAMCO_VISCODEC_MP4)
    {
        mmi_ucs2cat(ucs2_testname, (CHAR*) L".mp4");
    }
    else if (video_format == MMI_CAMCO_VISCODEC_3GP)
    {
        mmi_ucs2cat(ucs2_testname, (CHAR*) L".3gp");
    }
    else if (video_format == MMI_CAMCO_VISCODEC_MJPG)
    {
        mmi_ucs2cat(ucs2_testname, (CHAR*) L".avi");
    }else if(video_format == MMI_CAMCO_VISCODEC_H264)
    {
    	mmi_ucs2cat(ucs2_testname, (CHAR*) L".3gp");	
    }

    mmi_ucs2cpy( filepath_buf_p,  mmi_camco_rec_p->storage_filepath_p);
    mmi_ucs2cat( filepath_buf_p,  ucs2_testname);

    file_handle = FS_GetAttributes((U16*) filepath_buf_p);
    if (file_handle >= 0)
    {
        /* file exist */
        is_binary_search = MMI_TRUE;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_FILE_EXIT);
    }
    else
    {
        /* file not exist */
        WriteValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_FILE_NOT_EXIT);
        return;
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_IS_BINARY_SEARCH, is_binary_search);

    if (is_binary_search)
    {
        left = filename_seq_no + 1;
        right = CAMCO_MAX_FILE_NUM;

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_BINARY_SEARCH_INFO, left, right);

        while (left < right)
        {
            mid = (left + right) / 2;

            sprintf((CHAR*) buffer, "MOV%05d", mid);
            mmi_asc_to_ucs2( ucs2_buffer,  buffer);

            mmi_ucs2cpy(ucs2_testname, ucs2_buffer);
            if (video_format == MMI_CAMCO_VISCODEC_MP4)
            {
                mmi_ucs2cat(ucs2_testname, (CHAR*) L".mp4");
            }
            else if (video_format == MMI_CAMCO_VISCODEC_3GP)
            {
                mmi_ucs2cat(ucs2_testname, (CHAR*) L".3gp");
            }
            else if (video_format == MMI_CAMCO_VISCODEC_MJPG)
            {
                mmi_ucs2cat(ucs2_testname, (CHAR*) L".avi");
            }

            mmi_ucs2cpy( filepath_buf_p,  mmi_camco_rec_p->storage_filepath_p);
            mmi_ucs2cat( filepath_buf_p,  ucs2_testname);

            file_handle = FS_GetAttributes((WCHAR*) filepath_buf_p);
            if (file_handle >= 0)
            {
                /* file exist */
                left = mid + 1;
                last_file_exist_num = mid;
            }
            else
            {
                /* file not exit. return */
                right = mid - 1;
                if (mid == last_file_exist_num + 1)
                {
                    WriteValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &mid, DS_SHORT, &error);
                    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_FILE_NAME_WRITE_MID, mid);
                    return;
                }
            }
        }

        if (right <= left)
        {
            WriteValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &right, DS_SHORT, &error);

            sprintf((CHAR*) buffer, "MOV%05d", right);
            mmi_asc_to_ucs2( ucs2_buffer,  buffer);

            mmi_ucs2cpy(ucs2_testname, ucs2_buffer);
            if (video_format == MMI_CAMCO_VISCODEC_MP4)
            {
                mmi_ucs2cat(ucs2_testname, (CHAR*) L".mp4");
            }
            else if (video_format == MMI_CAMCO_VISCODEC_3GP)
            {
                mmi_ucs2cat(ucs2_testname, (CHAR*) L".3gp");
            }
            else if (video_format == MMI_CAMCO_VISCODEC_MJPG)
            {
                mmi_ucs2cat(ucs2_testname, (CHAR*) L".avi");
            }

            mmi_ucs2cpy( filepath_buf_p,  mmi_camco_rec_p->storage_filepath_p);
            mmi_ucs2cat( filepath_buf_p,  ucs2_testname);

            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_FILE_NAME_WRITE_RIGHT, right);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_restore_filename_seq_no
 * DESCRIPTION
 *  get next file name for jpeg image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_restore_filename_seq_no(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error = 0;
    U16 filename_seq_no;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);

    if (filename_seq_no == 1)
    {
        filename_seq_no = 9999;
    }
    else
    {
        filename_seq_no--;
    }

    WriteValue(NVRAM_VDOREC_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_get_preview_window
 * DESCRIPTION
 *  According to LCM, get the preview window
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_get_preview_window(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 temp_width = 0;
    U16 temp_height = 0;
    //U16 temp_factor = 0;
    U16 lcd_width = 0;
    U16 lcd_height = 0;
    U16 vdosize;
    U16 height_base = 0;
    U16 width_base = 0;
    double f_temp_factor = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    vdosize = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE);

#ifdef HORIZONTAL_CAMERA
    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        lcd_width = LCD_HEIGHT;
        lcd_height = LCD_WIDTH;
    }
#ifdef DUAL_CAMERA_SUPPORT
    else
    {
        lcd_width = LCD_WIDTH;
        lcd_height = LCD_HEIGHT;
    }
#endif /* DUAL_CAMERA_SUPPORT */ 
#else /* HORIZONTAL_CAMERA */ 
    lcd_width = LCD_WIDTH;
    lcd_height = LCD_HEIGHT;
#endif /* HORIZONTAL_CAMERA */ 

    switch (vdosize)
    {
        case MMI_CAMCO_RECSIZE_SQCIF:
            width_base = 16;
            height_base = 12;
            break;

        case MMI_CAMCO_RECSIZE_QQVGA:
            width_base = 16;
            height_base = 12;
            break;
            
        case MMI_CAMCO_RECSIZE_QCIF:                
            width_base = 44;
            height_base = 36;
            break;

        case MMI_CAMCO_RECSIZE_QVGA:
            width_base = 16;
            height_base = 12;
            break;
            
        case MMI_CAMCO_RECSIZE_CIF:
            width_base = 44;
            height_base = 36;
            break;

        case MMI_CAMCO_RECSIZE_WQVGA:
            width_base = 10;
            height_base = 6;          
            break; 

        case MMI_CAMCO_RECSIZE_CIF2:
            width_base = 54;
            height_base = 30;
            break;                

        case MMI_CAMCO_RECSIZE_HVGA:
            width_base = 12;
            height_base = 8;
            break;

        case MMI_CAMCO_RECSIZE_NHD:  
            width_base = 16;
            height_base = 9;
            break;
            
        case MMI_CAMCO_RECSIZE_VGA:
            width_base = 16;
            height_base = 12;
            break;
            
        case MMI_CAMCO_RECSIZE_D1:
            width_base = 9;
            height_base = 6;
            break;

        case MMI_CAMCO_RECSIZE_D12:
            width_base = 30;
            height_base = 24;
            break;    

        case MMI_CAMCO_RECSIZE_WVGA:
            width_base = 10;
            height_base = 6;          
            break; 


        case MMI_CAMCO_RECSIZE_SVGA:
            width_base = 50;
            height_base = 38;          
            break;    

        case MMI_CAMCO_RECSIZE_WVGA2:
            width_base = 53;
            height_base = 30;          
            break;                    
 
        case MMI_CAMCO_RECSIZE_XGA:
            width_base = 32;
            height_base = 24;          
            break;   

		case MMI_CAMCO_RECSIZE_4CIF:
			width_base = 32;
			height_base = 24;		   
			break;	 

		case MMI_CAMCO_RECSIZE_FWVGA:
			width_base = 9;
			height_base = 5;		   
			break;	 
        case MMI_CAMCO_RECSIZE_720P:
            width_base = 16;
            height_base = 9;          
            break;  

        case MMI_CAMCO_RECSIZE_4VGA:
            width_base = 32;
            height_base = 24;          
            break; 

        case MMI_CAMCO_RECSIZE_SXGA:
            width_base = 40;
            height_base = 32;          
            break; 

        case MMI_CAMCO_RECSIZE_16CIF:
            width_base = 44;
            height_base = 36;          
            break; 

        case MMI_CAMCO_RECSIZE_4SVGA:
            width_base = 16;
            height_base = 12;          
            break; 

        case MMI_CAMCO_RECSIZE_FHD:
            width_base = 60;
            height_base = 34;          
            break;  
	#ifdef MMI_CAMCO_WALLPAPER
		case MMI_CAMCO_RECSIZE_WALLPAPER:
			if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_QVGA )
			{ 
				width_base = 12;
				height_base = 16;
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_QVGA)
			{
				width_base = 16;
				height_base = 12;

			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_WQVGA)
			{
				width_base = 12;
				height_base = 20;

			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_HVGA)
			{
				width_base = 16;
				height_base = 24;				
			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_WVGA)
			{
				width_base = 12;
				height_base = 20;

			}
			else if(mmi_camco_setting_get_wallpaper_size() == MDI_VIDEO_VIDEO_SIZE_WP_QCIF)
			{
				width_base = 22;
				height_base = 26;
			}
            break;
    #endif
        default:
            break;
    }

    /* w is key size */
    if ((width_base * lcd_height) > height_base * lcd_width)
    {
        f_temp_factor = (1.0 * lcd_width / width_base);
        temp_height = (U16) (f_temp_factor * height_base);
        if (temp_height > lcd_height)
            temp_height = lcd_height;
        if ((temp_height % 2) != 0)
            temp_height--;
        temp_width = lcd_width;
    }
    /* h is key size */
    else
    {
        f_temp_factor = (1.0 * lcd_height / height_base);
        temp_width = (U16) (f_temp_factor * width_base);
        if (temp_width > lcd_width)
            temp_width = lcd_width;
        if ((temp_width % 2) != 0)
            temp_width--;
        temp_height = lcd_height;
    }
    if(temp_width > MDI_VDOREC_MAX_HW_LAYER_SIZE || temp_height > MDI_VDOREC_MAX_HW_LAYER_SIZE)
	  {
        if(temp_width > temp_height)
        {

			      temp_height = temp_height * MDI_VDOREC_MAX_HW_LAYER_SIZE / temp_width ;
			      temp_width = MDI_VDOREC_MAX_HW_LAYER_SIZE;
		    }
		    else
		    {

			      temp_width = temp_width * MDI_VDOREC_MAX_HW_LAYER_SIZE / temp_height;	
			      temp_height = MDI_VDOREC_MAX_HW_LAYER_SIZE;	
		    } 
		}
    g_mmi_camco_cntx.preview_wnd.height = temp_height;
    g_mmi_camco_cntx.preview_wnd.width = temp_width;
    g_mmi_camco_cntx.preview_wnd.offset_x = (lcd_width - temp_width) >> 1;
    g_mmi_camco_cntx.preview_wnd.offset_y = (lcd_height - temp_height) >> 1;
	g_mmi_camco_cntx.quickview_image_width = g_mmi_camco_cntx.preview_wnd.width;
	g_mmi_camco_cntx.quickview_image_height = g_mmi_camco_cntx.preview_wnd.height;

	#ifdef HORIZONTAL_CAMERA
		
	if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
	{
	    g_mmi_camco_cntx.quickview_wnd.offset_x = g_mmi_camco_cntx.preview_wnd.offset_y;
		g_mmi_camco_cntx.quickview_wnd.offset_y = g_mmi_camco_cntx.preview_wnd.offset_x;
		g_mmi_camco_cntx.quickview_wnd.height = g_mmi_camco_cntx.preview_wnd.width;
		g_mmi_camco_cntx.quickview_wnd.width = g_mmi_camco_cntx.preview_wnd.height;
	}
	#ifdef DUAL_CAMERA_SUPPORT
	else
	{
	    g_mmi_camco_cntx.quickview_wnd.offset_x = g_mmi_camco_cntx.preview_wnd.offset_x;
		g_mmi_camco_cntx.quickview_wnd.offset_y = g_mmi_camco_cntx.preview_wnd.offset_y;
		g_mmi_camco_cntx.quickview_wnd.height = g_mmi_camco_cntx.preview_wnd.height;
		g_mmi_camco_cntx.quickview_wnd.width = g_mmi_camco_cntx.preview_wnd.width;

	}
	#endif
	#else

		g_mmi_camco_cntx.quickview_wnd.offset_x = g_mmi_camco_cntx.preview_wnd.offset_x;
		g_mmi_camco_cntx.quickview_wnd.offset_y = g_mmi_camco_cntx.preview_wnd.offset_y;
		g_mmi_camco_cntx.quickview_wnd.height = g_mmi_camco_cntx.preview_wnd.height;
		g_mmi_camco_cntx.quickview_wnd.width = g_mmi_camco_cntx.preview_wnd.width;

	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_set_framework_environment
 * DESCRIPTION
 *  set framework environment
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_set_framework_environment(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    entry_full_screen();

    srv_prof_stop_tone(SRV_PROF_TONE_KEYPAD);    

    /* disable key pad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);

    /* suspend background play */
    mdi_audio_suspend_background_play();

    /* disalbe align timer */
    UI_disable_alignment_timers();

    /* stop LED patten */
    srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_STOP);

    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

#ifdef __MMI_VECTOR_FONT_SUPPORT__
    mmi_fe_set_antialias(MMI_FALSE);
#endif 

#ifdef __MMI_SUBLCD__
    mmi_camco_init_sublcd();
#endif 

   /***************************************************************************** 
   * register interrupt event hdlr
   *****************************************************************************/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_recover_framework_environment
 * DESCRIPTION
 *  set framework environment
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_recover_framework_environment(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
    gdi_layer_resize(UI_device_width, UI_device_height);
    gdi_layer_set_position(0, 0);
    gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);

    gdi_layer_pop_and_restore_active();

    gdi_layer_multi_layer_disable();
    /* resume alignment timer */
    UI_disable_alignment_timers();

    /* resume LED patten */
    srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_START);

    /* let MMI can sleep */
    srv_backlight_turn_off();

    /* resume background audio */
    mdi_audio_resume_background_play();

    /* re-enable keypad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);

#ifdef __MMI_VECTOR_FONT_SUPPORT__
    mmi_fe_set_antialias(MMI_TRUE);
#endif 

#ifdef __MMI_SUBLCD__
    if (!g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_deinit_sublcd();
    }
#endif /* __MMI_SUBLCD__ */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_entry_app_screen_internal
 * DESCRIPTION
 *  entry recorder application screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_entry_app_screen_internal(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_RECORDER_INTERNAL);
    if (!mmi_camco_is_from_external())
        guiBuffer = mmi_frm_scrn_get_gui_buf(g_mmi_camco_cntx.memory_group_id, SCR_ID_CAMCO_APP);
    else
        guiBuffer = mmi_frm_scrn_get_gui_buf(g_mmi_camco_cntx.memory_group_id, SCR_ID_CAMCO_EXT_APP);

    /*
     * Internal switch capability rule:
     *    1. switch capability
     *    2. update only rec capability
     */

    /*
     * External request switch capability rule:
     *    1. init setting pointer
     *    2. default capability without calling update capability
     *    3. switch capability
     *    4. update capability
     */
    if (g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_rec_p->storage = mmi_camco_cam_p->storage;
        mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_VIDEO);
        mmi_camco_setting_switch_capability();
        mmi_camco_setting_set_default_capability(MMI_CAMCO_SETTING_VDOZOOM);
    }

    mmi_camco_rec_set_framework_environment();

    if (!g_mmi_camco_cntx.is_osd_init)
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);        
    
        /* Initial setting */
        if (!mmi_camco_is_gobackfromhistory() && !g_mmi_camco_cntx.is_to_media_editor)
        {
            mmi_camco_setting_init();
            mmi_camco_setting_load_from_nvram();
            mmi_camco_setting_default_capability();
        }
        else
        {
            mmi_camco_check_storage_capability();
        }

        if (guiBuffer != NULL && g_mmi_camco_cntx.is_to_media_editor && !mmi_camco_rec_p->external_request.is_enable)
        {
            if (!mmi_camco_is_incall())
            {
                g_mmi_camco_cntx.is_to_media_editor = MMI_FALSE;
            }
        }

        mmi_camco_osd_init();
    #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)        
        gdi_bltdb_enable(GDI_BLTDB_ENABLE_ONLY_WHEN_HW_UPDATE);    
    #endif        
        mmi_camco_osd_setup_environment(g_mmi_camco_cntx.app_mem_buf_p);
        mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);
    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
        mmi_camco_osd_set_sublcd_base_layer(g_mmi_camco_cntx.sublcd_base_layer_handle);
    #endif 

        g_mmi_camco_cntx.is_osd_init = MMI_TRUE;

        if (mmi_camco_rec_p->external_request.is_enable)
        {
            /* 
             * Switch action have to do before update capability for preventing from 
             * setting value being changed.
             */
            if (mmi_camco_rec_p->external_request.is_switch_app)
            {
                mmi_camco_setting_switch_capability();
                mmi_camco_rec_p->external_request.is_switch_app = MMI_FALSE;
            }


        #ifdef DUAL_CAMERA_SUPPORT
            mmi_camco_set_external_vdoswitchto_capability();
        #else 
            mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_VDOSWITCHTO);
        #endif 
            mmi_camco_set_external_visqty_capability();

        #ifdef __MMI_OP02_LEMEI__ 
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_LIMIT, MMI_CAMCO_LIMIT_NO_LIMIT);        
            mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_LIMIT);        
        #endif    
        #ifdef __MMI_OP02_LEMEI__   
            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);
            mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_QCIF);
            mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_RECSIZE);                  
            mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
            mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);                   
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_NOTIFY_CHANGE_LOW_RECSIZE));
            mmi_camco_osd_draw_osd();
            /* sleep 300 tick for letting users see the msg for a while */
            kal_sleep_task(300);        
            mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
            mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);                 
        #else        
            if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) > MMI_CAMCO_RECSIZE_CIF)
            {
                if (mmi_camco_setting_get_itemlist_capability(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF) ==
                    MMI_CAMCO_SETTING_CAP_ENABLED)
                {
                    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF);
                    mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_CIF);
                }
                else
                {
                    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);
                    mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_QCIF);
                }
                mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
                mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);                   
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_NOTIFY_CHANGE_LOW_RECSIZE));
                mmi_camco_osd_draw_osd();
                /* sleep 300 tick for letting users see the msg for a while */
                kal_sleep_task(300);
                mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
                mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);                 
            }
        #endif    
        }
        else if (g_mmi_camco_cntx.partial_app.is_only_recorder)
        {
            if (g_mmi_camco_cntx.partial_app.is_switch_app)
            {
                mmi_camco_setting_switch_capability();
                g_mmi_camco_cntx.partial_app.is_switch_app = MMI_FALSE;
            }
            mmi_camco_update_facedetect_capability();
        #ifdef DUAL_CAMERA_SUPPORT
            mmi_camco_set_external_vdoswitchto_capability();
        #else 
            mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_VDOSWITCHTO);
        #endif 
        }
		mmi_camco_setting_update_capability();
        mmi_camco_update_facedetect_capability();
    }

    mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
    
    //mmi_camco_config_base_layer();
    mmi_camco_rec_config_preview_layer();

    if (mmi_camco_is_incall())
    {
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);

        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL));
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
    #else /* __MMI_CAMCO_FTE__ */ 
    #ifdef MMI_CAMCO_OSD_ICON_SWKEY
        #ifdef __MMI_FTE_SUPPORT__
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_preview_rsk_released);
        #else
            mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_preview_rsk_released);
        #endif
    #else 
        mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_preview_rsk_released);
    #endif 
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();

        if (g_mmi_camco_cntx.is_to_media_editor)
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_PREVIEW;
        }
        return;
    }

    /* error handling, reset video rec state */
    if (g_mmi_camco_cntx.app_state >= MMI_CAMCO_STATE_REC_PREVIEW &&
        g_mmi_camco_cntx.app_state < MMI_CAMCO_STATE_REC_INT_PREVIEW)
    {
        if (!g_mmi_camco_cntx.is_switching_app)
        {
            mmi_camco_exit_app();
            return;
        }
    }
    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
    
    if (mmi_camco_rec_p->is_saving_prev &&
        mmi_camco_rec_p->is_save_success && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING_PREV);
        /* 
         * Because pseudo merge will spend a quite long time, 
         * we need to wait that med video finishes the saving.
         */
    }
    else
    {
        /* Draw OSD first before init camera driver */
        if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT ||
            g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_PREVIEW || g_mmi_camco_cntx.is_switching_app)
        {
            //mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
            //mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);   
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
            if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
            {
                #ifdef AF_SUPPORT
				if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
				{
					SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
				}
                #endif

                SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
            }
            else
            {
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
            }
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_rec_preview_set_key_hdlr();
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
        else
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_HIDE);
        }

        if (!g_mmi_camco_cntx.is_power_on)
        {
            if (MDI_RES_VDOREC_SUCCEED == mmi_camco_rec_power_on())
            {
                if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
                }
                else if (g_mmi_camco_cntx.is_switching_app)
                {
                    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
                    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle); 
                    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
                    g_mmi_camco_cntx.is_switching_app = MMI_FALSE;
                }
                else
                {
                    mmi_camco_recover_state(g_mmi_camco_cntx.app_state);
                }
            }
            else
            {
                if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT ||
                    g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_PREVIEW ||
                    (g_mmi_camco_cntx.is_switching_app && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW)||
                    g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SETTING_MENU)
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW_FAILED);
                }
                else    /* Some int state doesn't need sensor output image, it still can be recoverd */
                {
                    mmi_camco_recover_state(g_mmi_camco_cntx.app_state);
                }
            }
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_exit_app_screen
 * DESCRIPTION
 *  exit recorder application screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_exit_app_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_RECORDER_EXIT);

    mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_VIDEO);

   // gui_cancel_timer(mmi_camco_rec_timelimit_hdlr);

    /* Just be interrupted, not delet app */
    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT)
    {
        mmi_camco_exit_current_state();
    }

    switch (g_mmi_camco_cntx.app_state)
    {
        case MMI_CAMCO_STATE_REC_PREVIEW:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_REC_PREVIEW_FAILED:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_REC_SETTING_MENU:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_SETTING_MENU;
            break;

        case MMI_CAMCO_STATE_REC_FOCUSING:
        case MMI_CAMCO_STATE_REC_FOCUSED:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_PREVIEW;
            break;

        case MMI_CAMCO_STATE_REC_RECORDING:
        case MMI_CAMCO_STATE_REC_PAUSE:
            if (mmi_camco_rec_p->is_save_success)
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_SAVING;
            }
            else
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_PREVIEW;
            }
            break;

        case MMI_CAMCO_STATE_REC_SAVING:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_SAVING;
            break;

        case MMI_CAMCO_STATE_REC_SAVE_DONE:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_SAVE_DONE;
            break;

        case MMI_CAMCO_STATE_REC_SAVING_PREV:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_SAVING_PREV;
            break;

        case MMI_CAMCO_STATE_RESTORE_CONFIRM:
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_INT_RESTORE_CONFIRM;
            break;

        case MMI_CAMCO_STATE_EXIT:  /* From DelCallback handing, exit the app */
            break;

        default:
        #ifndef __MMI_BACKGROUND_CALL__
            MMI_ASSERT(0);
        #endif 
            break;

    }
 

    mmi_camco_rec_recover_framework_environment();

    mmi_camco_rec_power_off();


    
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CURRENT_STATE, g_mmi_camco_cntx.app_state);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_preview_state
 * DESCRIPTION
 *  enter recorder preview state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_preview_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
	/*disable and close color engine for quickview image when in preview state*/
	if(g_mmi_camco_cntx.is_color_engine_enable)
	{
		mdi_camera_color_engine_disable();
		mdi_camera_color_engine_close();
		g_mmi_camco_cntx.is_color_engine_enable = MMI_FALSE;
	}
     
    /*
     * Once use mdi_vid to open file for show the first frame, 
     * camera will be powered off.Therefore, need to repower on camera
     * againe before preview                                          
     */
    if (!g_mmi_camco_cntx.is_power_on)
    {
        mmi_camco_rec_power_on();
    }

    if (g_mmi_camco_cntx.is_power_on)
    {
        if (!g_mmi_camco_cntx.is_preview_start || g_mmi_camco_cntx.is_restart_preview)
        {
            if (g_mmi_camco_cntx.is_restart_preview)
            {
                mmi_camco_rec_preview_stop();

                mmi_camco_osd_set_bg_black();

                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);

            #ifdef __MMI_CAMCO_FTE__
                mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
                if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
                {
		            #ifdef AF_SUPPORT
					if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
					{
						SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
					}
	                #endif
                    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
                }
                else
                {
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
                }
            #else /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_rec_preview_set_key_hdlr();
            #endif /* __MMI_CAMCO_FTE__ */ 

                mmi_camco_osd_draw_osd();
            #ifndef __MTK_TARGET__
                /* sleep 500 tick for MoDIS, to mimic restart latency */
                kal_sleep_task(500);
            #endif /* __MTK_TARGET__ */ 
            }
            else
            {
                mmi_camco_osd_set_bg_black();
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);

            #ifdef __MMI_CAMCO_FTE__
                mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
                if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
                {

				#ifdef AF_SUPPORT
				if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
				{
					SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
				}
                #endif
                    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
                }
                else
                {
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
                }

            #else /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_rec_preview_set_key_hdlr();
            #endif /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_osd_draw_osd();
            }

            if (TRUE == mmi_camco_rec_preview_start())
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_PREVIEW;
                g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
                g_mmi_camco_cntx.is_restart_preview = MMI_FALSE;

                if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
                {
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);
                }
                else if (g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
                { 
                    U16 drv_enum;            
                    
                    g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                    do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
                    mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
                    mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                    
                    mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_CARD_AND_NO_CARD);
                    mmi_camco_error_hdlr_timer_start();       
                    return;                
                }
				else if(g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
                {       
                    U16 drv_enum; 
                    g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                    do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
                    mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
					mmi_camco_check_storage_capability();
                    mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                    
                    mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_OTG_AND_NO_OTG);
                    mmi_camco_error_hdlr_timer_start();       
                    return;  
				}
                else
                {
                    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE &&
                        !mmi_camco_rec_p->is_drive_available)
                    {
                        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);
                    }
                    else
                    {
                        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                    }
                    g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_rec_p->err_str_id));
                }

            #ifdef __MMI_CAMCO_FTE__
                mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
                if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
                {
                
                    #ifdef AF_SUPPORT
					if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
					{
						SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
					}
                    #endif

                    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
                }
                else if(mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT) 
                {
                    if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
                    {
                        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_STORAGE_SELECTION);                                                    
                    }   
                    if(mmi_camco_get_storage_count() == 0) 
                    {         
                        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                    }                       
                    else
                    {                
                        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                    }                    
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
                }
                else
                {
                    g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;                
                }
            #else /* __MMI_CAMCO_FTE__ */ 
                if (((mmi_camco_rec_p->err_str_id != STR_ID_CAMCO_MEM_CARD_INSERT)&&
					( mmi_camco_rec_p->err_str_id != STR_ID_CAMCO_OTG_INSERT)) ||
					mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
                {   
                    mmi_camco_rec_preview_set_key_hdlr();
                }
                else
                {
                    if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
                    {
                        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_STORAGE_SELECTION);                         
                        mmi_camco_rec_preview_no_card_set_key_hdlr();                        
                    }       
                    if(mmi_camco_get_storage_count() == 0) 
                    {         
                        mmi_camco_rec_preview_failed_set_key_hdlr();
                    }                            
                    else if(mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT) 
                    {                
                        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                        mmi_camco_rec_preview_no_card_set_key_hdlr();                        
                    }
			        else if(mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
                    {
                        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_OTG_REMOVED_USE_PHONE));                             
                        mmi_camco_rec_preview_no_card_set_key_hdlr();    
			        }                    

                }
            #endif /* __MMI_CAMCO_FTE__ */ 
                mmi_camco_osd_draw_osd();

                if (mmi_camco_rec_p->is_drive_available)
                {
                    if (mdi_video_rec_has_unsaved_file(mmi_camco_rec_p->storage_filepath_p) == TRUE)
                    {
                        mdi_video_rec_delete_unsaved_file(mmi_camco_rec_p->storage_filepath_p);
                    }
                }

            }
            else
            {
                g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
                mmi_camco_enter_rec_preview_failed_state();
            }
        }
        else
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_PREVIEW;
            if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
            {
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);
            }
            else if (g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
            { 
                U16 drv_enum;            
                
                g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
                mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                
                mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_CARD_AND_NO_CARD);
                mmi_camco_error_hdlr_timer_start();       
                return;                
            }
			else if(g_mmi_camco_cntx.is_switchto_non_avaiable_storage && mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
            {    
               U16 drv_enum; 
                g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                do { if(&drv_enum) *(&drv_enum) = srv_fmgr_drv_get_type((U8)(SRV_FMGR_PUBLIC_DRV)); } while(0);           
                mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
				mmi_camco_check_storage_capability();
                mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
                    
                mmi_camco_show_error_msg(MMI_CAMCO_ERR_SET_OTG_AND_NO_OTG);
                mmi_camco_error_hdlr_timer_start();       
                return;                
            }
            else if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE &&
                     !mmi_camco_rec_p->is_drive_available)
            {
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITHOUT_BAR);
                g_mmi_camco_cntx.is_switchto_non_avaiable_storage = MMI_FALSE;
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_MEM_CARD_INSERT));
            }
            else
            {
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_rec_p->err_str_id));
            }

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
            if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
            {
                #ifdef AF_SUPPORT
				if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
				{
					SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
				}
                #endif

                SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
            }
            else if( mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT)
            {
                if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
                {
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_STORAGE_SELECTION);        
                }  
                if(mmi_camco_get_storage_count() == 0) 
                {         
                    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                }                   
                else
                {                
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                }
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
            }
            else
            {
                g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;            
            }
        #else /* __MMI_CAMCO_FTE__ */ 
            if ((mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE||
				mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_OTG_TYPE ) &&
                !mmi_camco_rec_p->is_drive_available)
            {   
                if(mmi_camco_get_storage_count() > 1) /* there are more than one choose for select storage */
                {
                    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_STORAGE_SELECTION);                            
                    mmi_camco_rec_preview_no_card_set_key_hdlr();            
                }
                if(mmi_camco_get_storage_count() == 0) 
                {         
                    mmi_camco_rec_preview_failed_set_key_hdlr();
                }                  
                else if(mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_MEM_CARD_INSERT) 
                {                
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_MC_REMOVED_USE_PHONE));                             
                    mmi_camco_rec_preview_no_card_set_key_hdlr();                        
                }
			    else if(mmi_camco_rec_p->err_str_id == STR_ID_CAMCO_OTG_INSERT)
                {
                    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_OTG_REMOVED_USE_PHONE));                             
                    mmi_camco_rec_preview_no_card_set_key_hdlr();            
                }                
            }
            else
            {
                mmi_camco_rec_preview_set_key_hdlr();
            }
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }

        if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW)
        {
            mmi_camco_rec_p->is_record_failed = MMI_FALSE;
            mmi_camco_rec_p->is_save_success = MMI_FALSE;
            mmi_camco_rec_p->is_file_delete = MMI_FALSE;
            mmi_camco_rec_p->is_switchto_vdoply = MMI_FALSE;

            if (mmi_camco_rec_p->is_storage_change && mmi_camco_rec_p->is_drive_available)
            {
                mmi_camco_rec_check_filename();
                mmi_camco_rec_p->is_storage_change = MMI_FALSE;
            }

            if (mmi_camco_setting_is_highlight_on())
            {
                mmi_camco_highlight_turn_on();
            }
            else
            {
                mmi_camco_highlight_turn_off();            
            }  

        #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
            gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
        #endif 
        }
    }
    else
    {
        g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
        mmi_camco_enter_rec_preview_failed_state();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_preview_failed_state
 * DESCRIPTION
 *  enter recorder preview failed state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_preview_failed_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);       
  
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_PREVIEW_FAILED;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_PREVIEW_FAILED));

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_failed_evt_hdlr);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_UP);    
#else 
    mmi_camco_rec_preview_failed_set_key_hdlr();
#endif 
    mmi_camco_osd_draw_osd();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_setting_menu_state
 * DESCRIPTION
 *  enter recorder setting menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_setting_menu_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 cur_mainlist_setting = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
    
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_RESTORE_CONFIRM)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_SETTING_MENU;
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_SETTING);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_setting_menu_evt_hdlr);
    #else 
        mmi_camco_rec_setting_menu_set_key_hdlr();
    #endif 
        mmi_camco_osd_draw_osd();

    #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
        gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
    #endif 
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SETTING_MENU)
    {
        mmi_camco_osd_set_setting_menulist_interrupt(MMI_TRUE);
    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_update_storage_capability();
    #endif
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_SETTING);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_setting_menu_evt_hdlr);
    #else 
        mmi_camco_rec_setting_menu_set_key_hdlr();
    #endif 
        mmi_camco_osd_draw_osd();

        cur_mainlist_setting = mmi_camco_setting_get_mainlist_setting();
        if (cur_mainlist_setting == MMI_CAMCO_SETTING_EFFECT ||
            cur_mainlist_setting == MMI_CAMCO_SETTING_WB ||
            cur_mainlist_setting == MMI_CAMCO_SETTING_SHARPNESS ||
            cur_mainlist_setting == MMI_CAMCO_SETTING_CONTRAST || cur_mainlist_setting == MMI_CAMCO_SETTING_SATURATION)
        {
            mmi_camco_setting_set_current_setting_hilite((mmi_camco_setting_enum)cur_mainlist_setting, MMI_TRUE);
        }
		

        if (TRUE == mmi_camco_rec_preview_start())
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_SETTING_MENU;
            g_mmi_camco_cntx.is_preview_start = MMI_TRUE;

            mmi_camco_osd_set_setting_menulist_interrupt(MMI_TRUE);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_SETTING);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_setting_menu_evt_hdlr);
        #else 
            mmi_camco_rec_setting_menu_set_key_hdlr();
        #endif 
            mmi_camco_osd_draw_osd();
        #ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
            gui_start_timer(MMI_CAMCO_PREVIEW_TIMEOUT_POLLING_DUR, mmi_camco_preview_terminate_hdlr);
        #endif 
        }
        else
        {
            g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
            mmi_camco_enter_rec_preview_failed_state();
        }
        if (mmi_camco_setting_is_highlight_on())
        {
            mmi_camco_highlight_turn_on();
        }
        else
        {
            mmi_camco_highlight_turn_off();            
        }           
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_focusing_state
 * DESCRIPTION
 *  enter recorder focusing state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_focusing_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 idx;
    U16 region_idx;
    U16 w, h;
    U16 center_x, center_y;
    U32 af_active_zone = 0;
    S32 af_zone_count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_FOCUSING;
    g_mmi_camco_cntx.is_autofocus_success = MMI_FALSE;
    mmi_camco_rec_autofocus_start();

    mdi_video_rec_get_focus_zone(&mmi_camco_rec_p->af_zone);
    
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_FOCUSE);

    af_active_zone = mmi_camco_rec_p->af_zone.af_active_zone;

    for (idx = MMI_CAMCO_OSD_FOCUS_REGION_1; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
    {
        af_zone_count += af_active_zone & 0x00000001;
        af_active_zone = af_active_zone >> 1;
    }

    MMI_ASSERT(af_zone_count <= MMI_CAMCO_OSD_FOCUS_REGION_END);
    mmi_camco_rec_p->af_zone_count = af_zone_count;

    af_active_zone = mmi_camco_rec_p->af_zone.af_active_zone;
    for (idx = MMI_CAMCO_OSD_FOCUS_REGION_1; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
    {
        if (af_active_zone & 0x00000001)
        {
            region_idx = MMI_CAMCO_OSD_FOCUS_REGION_1 + idx;

            w = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_w;
            h = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_h;
            center_x = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
            center_y = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;

            mmi_camco_osd_set_focus((mmi_camco_osd_focus_region_enum)region_idx, MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSING, center_x, center_y, w, h);
        }
        af_active_zone = af_active_zone >> 1;
    }

    mmi_camco_rec_focus_set_key_hdlr();

    mmi_camco_osd_draw_osd();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_focused_state
 * DESCRIPTION
 *  enter recorder focused state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_focused_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 is_success = 0x00;
    U8 idx;
    U16 region_idx;
    U16 w, h;
    U16 center_x, center_y;
    U32 af_success_zone = 0;
    U32 af_active_zone = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSING);

    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_FOCUSED;

    af_active_zone = mmi_camco_rec_p->af_zone.af_active_zone;
    af_success_zone = mmi_camco_rec_p->af_result.af_success_zone;

    for (idx = 0; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
    {
        region_idx = MMI_CAMCO_OSD_FOCUS_REGION_1 + idx;

        is_success = af_success_zone & 0x00000001;

        if (is_success)
        {
            w = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_w;
            h = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_h;
            center_x = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
            center_y = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;

            mmi_camco_osd_set_focus((mmi_camco_osd_focus_region_enum)region_idx, MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSED, center_x, center_y, w, h);
        }
        else if (af_active_zone & 0x00000001)
        {
            w = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_w;
            h = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_h;
            center_x = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
            center_y = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;
            mmi_camco_osd_set_focus((mmi_camco_osd_focus_region_enum)region_idx, MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSING, center_x, center_y, w, h);
        }

        af_success_zone = af_success_zone >> 1;
        af_active_zone = af_active_zone >> 1;
    }

    mmi_camco_rec_focus_set_key_hdlr();

    mmi_camco_osd_draw_osd();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_recording_state
 * DESCRIPTION
 *  enter recorder recording state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_recording_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;
    U8 bl_level;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
	if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_TIMELAPS) == MMI_CAMCO_TIMELAPS_ON)
	{
	   bl_level = srv_backlight_get_level(SRV_BACKLIGHT_TYPE_MAINLCD);
	   if(bl_level >3)
	   {
	       bl_level -= 2;

	   }else if(bl_level>1)
	   {
           bl_level = 2;
	   }
	    srv_gpio_setting_set_bl_level(bl_level,MMI_FALSE);//for time lapse 
	}
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PAUSE)
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_RECORDING);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_recording_evt_hdlr);
        SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_rec_recording_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();

        result = mmi_camco_rec_record_resume();
        g_mmi_camco_cntx.is_preview_start = MMI_FALSE;

        if (MDI_RES_VDOREC_SUCCEED == result)
        {
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_RECORDING;

            mmi_camco_rec_record_timer_cyclic();
            mmi_camco_osd_draw_osd();
        }
        else if (result == MDI_RES_VDOREC_RECORD_ALREADY_STOP)
        {
             if (mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_NO_LIMIT ||
                 mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_15S ||
                 mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_30S || mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_60S)
             {
                mmi_camco_rec_p->rec_progress_ratio = 100;
                mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
                mmi_camco_osd_draw_osd();
                kal_sleep_task(100);

                mmi_camco_show_error_msg(MDI_RES_VDOREC_REACH_TIME_LIMIT);
                /* sleep 500 tick for letting users see the msg for a while */
                kal_sleep_task(500);

                mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
             }
             else
             {
                 mmi_camco_rec_p->rec_progress_ratio = 100;
                 mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
                 mmi_camco_osd_draw_osd();
                 kal_sleep_task(100);
            mmi_camco_show_error_msg(MDI_RES_VDOREC_REACH_SIZE_LIMIT);
            /* sleep 500 tick for letting users see the msg for a while */
            kal_sleep_task(500);

            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
             }
        }
        else if (result == MDI_RES_VDOREC_DISK_FULL)
        {
            mmi_camco_show_error_msg(result);
            mmi_camco_highlight_turn_off();

            kal_sleep_task(500);

            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
        }
        else
        {
            /* Camcorder is in MMI_CAMCO_STATE_REC_PAUSE */
            mmi_camco_rec_p->is_record_start = MMI_FALSE;
            mmi_camco_show_error_msg(result);
            mmi_camco_error_hdlr_timer_start();
        }

    }
    else
    {
        mdi_video_rec_query_bitrate_struct spec;
        U32 bitrate;
        
        mmi_camco_rec_p->rec_time = 0;
		 mmi_camco_rec_p->rec_frame = 0;
        mmi_camco_rec_p->rec_progress_ratio = 0;


        spec.quality = mmi_camco_get_cmd_visqty(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VISQTY));
        spec.video_size = mmi_camco_get_cmd_vdosize(&mmi_camco_rec_p->video_width, &mmi_camco_rec_p->video_height);
        if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE)
        {
            spec.storage = MDI_VIDEO_REC_STORAGE_SD;
        }
        else
        {
            spec.storage = MDI_VIDEO_REC_STORAGE_PHONE;    
        }
        spec.video_format = mmi_camco_get_cmd_visformat(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VISCODEC));
        mdi_video_rec_query_bitrate(&spec, &bitrate);

        if (mmi_camco_rec_p->external_request.is_enable)
        {
        #ifdef __MMI_OP02_LEMEI__    
            mmi_camco_rec_p->predict_rec_time = 20;
        #else
            mmi_camco_rec_p->predict_rec_time = (mmi_camco_rec_p->external_request.req_size * 1024 * 8) / bitrate;
        #endif
        }
        else
        {
            mmi_camco_rec_p->predict_rec_time = (mmi_camco_get_free_space() * 8) / bitrate;
        }
        
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_RECORDING);

    #ifdef __MMI_CAMCO_FTE__
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_recording_evt_hdlr);
        SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    #else /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_rec_recording_set_key_hdlr();
    #endif /* __MMI_CAMCO_FTE__ */ 
        mmi_camco_osd_draw_osd();

        MMI_CAMCO_STOP_LOGGING("PRE");

        MMI_CAMCO_START_LOGGING("REC");

        mmi_camco_rec_p->rec_size = 0;
        mmi_camco_rec_p->rec_frame = 0;
        mmi_camco_rec_p->is_record_failed = MMI_FALSE;
        result = mmi_camco_rec_record_start();
        g_mmi_camco_cntx.is_preview_start = MMI_FALSE;

        if (MDI_RES_VDOREC_SUCCEED == result)
        {
            mmi_camco_rec_p->is_record_start = MMI_TRUE;
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_RECORDING;

            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_RECORDING);

        #ifdef __MMI_CAMCO_FTE__
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_recording_evt_hdlr);
            SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_rec_recording_set_key_hdlr();
        #endif /* __MMI_CAMCO_FTE__ */ 

            mmi_camco_rec_record_timer_cyclic();

            mmi_camco_osd_draw_osd();

        }
        else
        {
            /* 
             * Camcorder is in MMI_CAMCO_STATE_REC_PREVIEW or 
             * MMI_CAMCO_STATE_REC_FOCUSING or MMI_CAMCO_STATE_REC_FOCUSED
             */
            mmi_camco_rec_p->is_record_failed = MMI_TRUE;
            mmi_camco_show_error_msg(result);
            if (mmi_camco_rec_p->external_request.is_enable)
            {
                kal_sleep_task(500);
                if (!((srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0) &&
                      !(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CSD_CALL_TYPE_ALL, NULL) > 0)) &&
                    !(srv_reminder_is_expiring()))
                {
                    /* Return to previous application which asks the requst */
                    mmi_camco_exit_app();
                    return;
                }
            }
            else
            {
                mmi_camco_error_hdlr_timer_start();
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_pause_state
 * DESCRIPTION
 *  enter recorder pause state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_pause_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PAUSE);

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_pause_evt_hdlr);
#else 
    mmi_camco_rec_pause_set_key_hdlr();
#endif 
    mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
    mmi_camco_osd_draw_osd();

    result = mmi_camco_rec_record_pause();

    if (result == MDI_RES_VDOREC_SUCCEED)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_PAUSE;
        g_mmi_camco_cntx.is_preview_start = MMI_TRUE;
    }
    else if (result == MDI_RES_VDOREC_RECORD_ALREADY_STOP)
    {
       if (mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_NO_LIMIT ||
           mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_15S ||
           mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_30S || mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_60S)
       {
        mmi_camco_rec_p->rec_progress_ratio = 100;
        mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
        mmi_camco_osd_draw_osd();
        kal_sleep_task(100);

           mmi_camco_show_error_msg(MDI_RES_VDOREC_REACH_TIME_LIMIT);
           /* sleep 500 tick for letting users see the msg for a while */
           kal_sleep_task(500);

           mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
       }
       else
       {
           mmi_camco_rec_p->rec_progress_ratio = 100;
           mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
           mmi_camco_osd_draw_osd();
           kal_sleep_task(100);

           mmi_camco_show_error_msg(MDI_RES_VDOREC_REACH_SIZE_LIMIT);
           /* sleep 500 tick for letting users see the msg for a while */
           kal_sleep_task(500);

           mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);

       }
    }
    else if (result == MDI_RES_VDOREC_REACH_SIZE_LIMIT )
    {
        mmi_camco_rec_p->rec_progress_ratio = 100;
        mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
        mmi_camco_osd_draw_osd();
        kal_sleep_task(100);

        mmi_camco_show_error_msg(MDI_RES_VDOREC_REACH_TIME_LIMIT);
        /* sleep 500 tick for letting users see the msg for a while */
        kal_sleep_task(500);

        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);

    }
    else if(result == MDI_RES_VDOREC_REACH_TIME_LIMIT)
    {
        mmi_camco_rec_p->rec_progress_ratio = 100;
        mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);
        mmi_camco_osd_draw_osd();
        kal_sleep_task(100);

        mmi_camco_show_error_msg(MDI_RES_VDOREC_REACH_TIME_LIMIT);
                   /* sleep 500 tick for letting users see the msg for a while */
        kal_sleep_task(500);

        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);


    }
    else if (result == MDI_RES_VDOREC_DISK_FULL)
    {
        mmi_camco_show_error_msg(result);
        mmi_camco_highlight_turn_off();

        kal_sleep_task(500);

        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
    }
    else
    {
        /* MMI_CAMCO_STATE_REC_RECORDING */
        mmi_camco_rec_p->is_record_start = MMI_FALSE;
        mmi_camco_show_error_msg(result);
        mmi_camco_error_hdlr_timer_start();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_saving_state
 * DESCRIPTION
 *  enter recorder saving state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_saving_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 
	#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
 	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
	#endif
    mmi_camco_rec_record_stop();

    mmi_camco_osd_set_bg_black();

    MMI_CAMCO_STOP_LOGGING("REC");

    MMI_CAMCO_START_LOGGING("SAV");

    mmi_camco_rec_save_file();

    mmi_camco_highlight_turn_off();

    mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);      

    g_mmi_camco_cntx.is_preview_start = MMI_FALSE;

    if (mmi_camco_rec_p->is_save_success)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_SAVING;

        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
        mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
        mmi_camco_osd_draw_osd();

        /* sleep 500 tick for letting users see the saving msg for a while */
        kal_sleep_task(500);

    }
    else
    {
        /* camcorder is in MMI_CAMCO_STATE_REC_RECORDING or MMI_CAMCO_STATE_REC_PAUSE */
        mmi_camco_show_error_msg(MDI_RES_VDOREC_ERR_SAVE_FILE_FAILED);
        mmi_camco_error_hdlr_timer_start();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_save_done_state
 * DESCRIPTION
 *  enter recorder save done state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_save_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    mmi_camco_state_enum prev_state;
    mdi_video_info_struct video_info;
	
    S32 offset_x,offset_y;
    U32 width;
	U32 height;

    U32 color_format;
    U8 rotate;
    U8*  temp_ptr; 
	GDI_HANDLE temp_layer;
	U32 temp_width;
	U32 temp_height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
        
	//MDP not support RGB565 need to set layer format to UYVY422 

    prev_state = g_mmi_camco_cntx.app_state;

    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_SAVE_DONE;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_set_captured_mode(MMI_FALSE);
#endif 

    if (prev_state != MMI_CAMCO_STATE_REC_INT_SAVE_DONE)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }

    if ((prev_state == MMI_CAMCO_STATE_REC_INT_SAVE_DONE ||
         prev_state == MMI_CAMCO_STATE_REC_INT_SAVING) && !mmi_camco_is_file_exist(mmi_camco_rec_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
    }
    else
    {

        mmi_camco_osd_set_bg_black();



        mmi_camco_rec_config_preview_layer();

        MMI_CAMCO_START_LOGGING("DEC");

        mmi_camco_rec_p->is_openfile_hdlr_back = MMI_FALSE;

    #ifdef __MTK_TARGET__
        ret = mdi_video_ply_open_clip_file(0, mmi_camco_rec_p->buf_filename_p, &video_info);

        if (ret != MDI_RES_VDOPLY_SUCCEED)
        {
            mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
		    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle); 
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);        
            mmi_camco_osd_set_bg_black();				    
            
            mmi_camco_show_error_msg(ret);
            mmi_camco_error_hdlr_timer_start();
            return;
        }

		mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
		gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
		color_format = mdi_video_ply_get_default_frame_color_format();
		gdi_layer_set_color_format(color_format);
		gdi_layer_clear(GDI_COLOR_BLACK);
		gdi_layer_get_dimension(&temp_width,&temp_height);
		
	    #ifdef __RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ 
		if(mmi_camco_rec_p->rec_rotate == MDI_CAMERA_UI_ROTATE_90)
		{
			if(gdi_layer_get_rotate()== GDI_LAYER_ROTATE_0)
			{
				gdi_layer_get_position(&offset_x,&offset_y);
				gdi_layer_set_position(offset_y,offset_x);
				gdi_layer_get_dimension(&width,&height);
				gdi_layer_resize(height,width);
				
			}
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);

		}
		else if(mmi_camco_rec_p->rec_rotate == MDI_CAMERA_UI_ROTATE_270)
		{
			if(gdi_layer_get_rotate()== GDI_LAYER_ROTATE_0)
			{
				gdi_layer_get_position(&offset_x,&offset_y);
				gdi_layer_set_position(offset_y,offset_x);
				gdi_layer_get_dimension(&width,&height);
				gdi_layer_resize(height,width);
			}
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_270);

		}
		else if(mmi_camco_rec_p->rec_rotate == MDI_CAMERA_UI_ROTATE_180)
		{

			if(gdi_layer_get_rotate()== GDI_LAYER_ROTATE_90)
			{
				gdi_layer_get_position(&offset_x,&offset_y);
				gdi_layer_set_position(offset_y,offset_x);
				gdi_layer_get_dimension(&width,&height);
				gdi_layer_resize(height,width);
			}
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_180);

		}
		else
		{
			if(gdi_layer_get_rotate()== GDI_LAYER_ROTATE_90)
			{
				gdi_layer_get_position(&offset_x,&offset_y);
				gdi_layer_set_position(offset_y,offset_x);
				gdi_layer_get_dimension(&width,&height);
				gdi_layer_resize(height,width);
			}
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);

		}
		#endif
		#ifdef HORIZONTAL_CAMERA
		  gdi_layer_get_dimension(&temp_width,&temp_height);
		  gdi_layer_get_position(&offset_x,&offset_y);
		  rotate = gdi_layer_get_rotate();
		  temp_ptr = mmi_camco_osd_get_init_mem();
		  gdi_layer_create_cf_using_outside_memory(color_format,0,0,temp_width,temp_height,&temp_layer,temp_ptr,temp_width*temp_height*2);
		  gdi_layer_set_hw_update_layer(temp_layer, KAL_TRUE);
		
		ret = mdi_video_ply_seek_and_get_frame(0, temp_layer);
		if(rotate == GDI_LAYER_ROTATE_90)
		{
             width = temp_height;
			 height = temp_width;
			 gdi_layer_set_position(UI_DEVICE_WIDTH - offset_y - temp_height, offset_x);
			 
		}
		else if(rotate == GDI_LAYER_ROTATE_270)
		{
		     width = temp_height;
			 height = temp_width;
			 
			 gdi_layer_set_position(offset_y, UI_DEVICE_HEIGHT - offset_x - temp_width);
		}
		else if(rotate == GDI_LAYER_ROTATE_180)
		{
       		width = temp_width;
			height = temp_height;
			gdi_layer_set_position(UI_DEVICE_WIDTH - offset_x - temp_width,UI_DEVICE_HEIGHT - offset_y - temp_height);

		}
		else
		{
       		width = temp_width;
			height = temp_height;
		}

		gdi_layer_set_rotate(0);
		gdi_layer_resize(width, height);

		mmi_camco_rotate_for_hw_rotate(temp_layer,g_mmi_camco_cntx.base_layer_handle,rotate);
		gdi_layer_free(temp_layer);
		#else
		ret = mdi_video_ply_seek_and_get_frame(0, g_mmi_camco_cntx.base_layer_handle);
		#endif
	    mdi_video_ply_close_clip_file();

		mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);
		gdi_layer_pop_and_restore_active();
		mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
    #endif /* __MTK_TARGET__ */ 
        mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_rec_p->buf_filename_p +
                                          (2 * mmi_ucs2strlen(mmi_camco_rec_p->storage_filepath_p)));
        MMI_CAMCO_STOP_LOGGING("DEC");

        mmi_camco_rec_p->is_openfile_hdlr_back = MMI_TRUE;

        if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
        {
            mmi_camco_rec_save_done_lsk_released(KEY_EVENT_UP);
        }
        else if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
        {
            g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_TRUE;
            mmi_camco_rec_save_done_option_lsk_released(KEY_EVENT_UP);
        }
        else
        {
        #ifndef __MMI_CAMCO_FTE__
            mmi_camco_rec_save_done_set_key_hdlr();
        #else /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_rec_save_done_lsk_released(KEY_EVENT_UP);
        #endif /* __MMI_CAMCO_FTE__ */ 
            mmi_camco_osd_draw_osd();
        }
    }
    mmi_camco_turn_off_lcd_backlight();
	#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
	    mmi_scr_locker_stop_timer();
	    mmi_scr_locker_start_timer();
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_rec_saving_prev_state
 * DESCRIPTION
 *  enter recorder saving prev state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_enter_rec_saving_prev_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_start_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_FALSE; 
     
    g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_SAVING_PREV;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
    mmi_camco_osd_set_bg_black();
    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
    mmi_camco_osd_draw_osd();

    /* sleep 500 tick for letting users see the saving msg for a while */
    kal_sleep_task(500);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_preview_state
 * DESCRIPTION
 *  exit recorder preview state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_preview_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_rec_record_tone_finish_hdlr);
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_rec_set_recording_start(KAL_FALSE);
#endif 
    if (!mmi_camco_rec_p->is_record_failed)
    {
        mmi_camco_rec_preview_stop();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_preview_failed_state
 * DESCRIPTION
 *  exit recorder preview failed state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_preview_failed_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_setting_menu_state
 * DESCRIPTION
 *  exit recorder setting menu state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_setting_menu_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_preview_stop();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_focus_state
 * DESCRIPTION
 *  exit recorder focusing state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_focus_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_rec_record_tone_finish_hdlr);
#ifdef __MMI_CAMCO_FTE__    
    mmi_camco_rec_set_recording_start(KAL_FALSE);
#endif 
    if (!mmi_camco_rec_p->is_record_failed)
    {
        mmi_camco_rec_autofocus_stop();
        mmi_camco_rec_preview_stop();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_recording_state
 * DESCRIPTION
 *  exit recorder recording state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_recording_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_end_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_TRUE;
    gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
 	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
#endif
    mmi_camco_rec_record_stop();
    mmi_camco_rec_save_file();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_pause_state
 * DESCRIPTION
 *  exit recorder pause state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_pause_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_record_stop();
    mmi_camco_rec_preview_stop();
     mmi_camco_rec_save_file();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_saving_state
 * DESCRIPTION
 *  exit recorder saving state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_saving_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */
    mmi_frm_end_scenario(MMI_SCENARIO_ID_CAMCO_NONPREEMPTION);
    g_mmi_camco_cntx.is_preemptable = MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_save_done_state
 * DESCRIPTION
 *  exit recorder save done state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_save_done_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);
    gdi_layer_set_rotate(GDI_LCD_LAYER_ROTATE_0);
    gdi_layer_resize(LCD_WIDTH, LCD_HEIGHT);
    gdi_layer_pop_and_restore_active();

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_exit_rec_saving_prev_state
 * DESCRIPTION
 *  exit recorder saving prev state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_exit_rec_saving_prev_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Do nothing */
}


#ifndef __MMI_CAMCO_FTE__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_no_card_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_no_card_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_preview_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_rec_preview_no_card_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_preview_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_rec_preview_no_card_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_preview_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_rec_preview_no_card_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_preview_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SETTINGS, IMG_ID_CAMCO_SETTINGS_SEL, mmi_camco_rec_preview_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_preview_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SETTINGS, IMG_ID_CAMCO_SETTINGS, mmi_camco_rec_preview_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_preview_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_SETTINGS, mmi_camco_rec_preview_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
    {
        if (!mmi_camco_is_from_external())
    	{    	
            mmi_camco_osd_set_csk_img(
                IMG_ID_CAMCO_RECORDER,
                IMG_ID_CAMCO_RECORDER,
                mmi_camco_rec_preview_csk_pressed,
                KEY_EVENT_DOWN);
        }
        else
        {
            mmi_camco_osd_set_csk_img(
                IMG_ID_CAMCO_RECORDER_ONLY,
                IMG_ID_CAMCO_RECORDER_ONLY,
                mmi_camco_rec_preview_csk_pressed,
                KEY_EVENT_DOWN);                                                                              
        } 

        #ifdef AF_SUPPORT
		
		if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
        {
		    SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
		}
		#endif

        SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_setting_menu_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_setting_menu_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
        
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_setting_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_rec_setting_menu_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_setting_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_rec_setting_menu_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_setting_menu_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_rec_setting_menu_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_failed_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_failed_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_preview_failed_rsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_preview_failed_rsk_released);
    #endif
#else 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_preview_failed_rsk_released);
#endif 

    SetKeyHandler(NULL, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_DOWN);
    SetKeyHandler(NULL, KEY_CAMERA, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_recording_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_recording_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_STOP, IMG_ID_CAMCO_STOP_SEL, mmi_camco_rec_recording_rsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_STOP, IMG_ID_CAMCO_STOP, mmi_camco_rec_recording_rsk_released);
    #endif
#ifdef __MMI_OP02_LEMEI__ 
    if (!mmi_camco_is_from_external())
    {
#endif
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_PAUSE, IMG_ID_CAMCO_PAUSE_SEL, mmi_camco_rec_recording_lsk_released);
    #else
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_PAUSE, IMG_ID_CAMCO_PAUSE, mmi_camco_rec_recording_lsk_released);
    #endif
#ifdef __MMI_OP02_LEMEI__ 
    }
#endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_STOP, mmi_camco_rec_recording_rsk_released);
#ifdef __MMI_OP02_LEMEI__ 
    if (!mmi_camco_is_from_external())
    {
#endif  
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_PAUSE, mmi_camco_rec_recording_lsk_released);
#ifdef __MMI_OP02_LEMEI__ 
    }
#endif
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_pause_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_pause_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_STOP, IMG_ID_CAMCO_STOP_SEL, mmi_camco_rec_pause_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_RESUME, IMG_ID_CAMCO_RESUME_SEL, mmi_camco_rec_pause_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_STOP, IMG_ID_CAMCO_STOP, mmi_camco_rec_pause_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_RESUME, IMG_ID_CAMCO_RESUME, mmi_camco_rec_pause_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_STOP, mmi_camco_rec_pause_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_ID_CAMCO_CONTINUE, mmi_camco_rec_pause_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_done_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Draw LSK, RSK and register callback */
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_save_done_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OPTIONS, IMG_ID_CAMCO_OPTIONS_SEL, mmi_camco_rec_save_done_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_save_done_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OPTIONS, IMG_ID_CAMCO_OPTIONS, mmi_camco_rec_save_done_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_ID_CAMCO_CONTINUE, mmi_camco_rec_save_done_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OPTIONS, mmi_camco_rec_save_done_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

#ifdef __MMI_MMS__
    if (mms_is_ready() && (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) <= MMI_CAMCO_RECSIZE_CIF))
    {
        mmi_camco_osd_set_csk_img(
            IMG_ID_CAMCO_FORWARD_TO_MMS,
            IMG_ID_CAMCO_FORWARD_TO_MMS,
            mmi_camco_rec_save_done_csk_released,
            KEY_EVENT_UP);
    }
    else
#endif /* __MMI_MMS__ */ 

    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
    #else
/* under construction !*/
    #endif
#else 
/* under construction !*/
#endif 
/* under construction !*/
/* under construction !*/
#endif

#endif /* __MMI_CAMCO_FTE__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_focus_set_key_hdlr
 * DESCRIPTION
 *  set key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_focus_set_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetKeyHandler(mmi_camco_rec_preview_autofocus_button_released, KEY_CAMERA, KEY_HALF_PRESS_UP);
    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CSK, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_power_on
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MDI_RESULT mmi_camco_rec_power_on(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;
    U16 cam_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cam_id = (U16) mmi_camco_get_cmd_camera_id(mmi_camco_setting_get_active_cam());
    mdi_video_set_camera_id(cam_id);
    ret = mdi_video_rec_power_on(g_mmi_camco_cntx.memory_group_id);
    if (ret == MDI_RES_VDOREC_SUCCEED)
    {
        g_mmi_camco_cntx.is_power_on = MMI_TRUE;
    }
    else
    {
        g_mmi_camco_cntx.is_power_on = MMI_FALSE;
    }

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_power_off
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_power_off(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_highlight_turn_off();
    if (g_mmi_camco_cntx.is_power_on)
    {
        mdi_video_rec_power_off();
        g_mmi_camco_cntx.is_power_on = MMI_FALSE;
    }

    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_start
 * DESCRIPTION
 *  start previewing on main LCD
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
static BOOL mmi_camco_rec_preview_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    BOOL ret = FALSE;
    MDI_RESULT result;
    mdi_video_setting_struct video_preview_data;
    U32 blt_layer_falg;
    U32 preview_layer_flag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    

    mmi_camco_osd_set_blt_layer(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);
    mmi_camco_osd_draw_osd();
    mmi_camco_rec_config_preview_layer();

    video_preview_data.wb = mmi_camco_get_cmd_wb(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_WB));
    video_preview_data.ev = mmi_camco_get_cmd_ev(mmi_camco_setting_get_vdoev_value());
    video_preview_data.banding = mmi_camco_get_cmd_banding(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_BANDING));
    video_preview_data.video_qty = mmi_camco_get_cmd_visqty(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VISQTY));
    video_preview_data.video_format = mmi_camco_get_cmd_visformat(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VISCODEC));
    video_preview_data.effect = mmi_camco_get_cmd_effect(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_EFFECT));

    video_preview_data.video_size = mmi_camco_get_cmd_vdosize(&mmi_camco_rec_p->video_width, &mmi_camco_rec_p->video_height);
    video_preview_data.user_def_width = 0;
    video_preview_data.user_def_height = 0;

    video_preview_data.zoom = mmi_camco_get_vdozoom();
    video_preview_data.dsc_mode = mmi_camco_get_cmd_vdoscenemode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VDOSCENEMODE));

    video_preview_data.contrast = mmi_camco_get_cmd_contrast(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CONTRAST));
    video_preview_data.saturation = mmi_camco_get_cmd_saturation(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SATURATION));
    video_preview_data.sharpness = mmi_camco_get_cmd_sharpness(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_SHARPNESS));
    video_preview_data.hue = 0;
    video_preview_data.time_limit = 0;
    video_preview_data.size_limit = 0; 
    if (MMI_CAMCO_VDOSCENEMODE_NIGHT == mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_VDOSCENEMODE))
    {
        video_preview_data.night = 1;
    }
    else
    {
        video_preview_data.night = 0;
    }

    if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
    {
        video_preview_data.preview_rotate = CAMCO_PREVIEW_MAINLCD_ROTATE;
    }
#ifdef DUAL_CAMERA_SUPPORT
    else
    {
        video_preview_data.preview_rotate = CAMCO_PREVIEW_MAINLCD_SUBCAM_ROTATE;
    }
#endif /* DUAL_CAMERA_SUPPORT */ 

    video_preview_data.af_range = mmi_camco_get_cmd_afrange(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFRANGE));
    video_preview_data.af_operation_mode = mmi_camco_get_cmd_afmode(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE));
    video_preview_data.overlay_frame_mode = FALSE;
    video_preview_data.overlay_frame_depth = 0;
    video_preview_data.overlay_frame_width = 0;
    video_preview_data.overlay_frame_height = 0;
    video_preview_data.overlay_frame_source_key = 0;
    video_preview_data.overlay_frame_buffer_address = 0;

#if defined(HORIZONTAL_CAMERA)
    video_preview_data.ui_rotate = CAMCO_LCM_ROTATE_90;
#else
    video_preview_data.ui_rotate = CAMCO_LCM_ROTATE_0;
#endif

    mmi_camco_rec_p->limit = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_LIMIT);

    if (mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_15S ||
        mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_30S || 
        mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_60S ||
        mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_10MIN|| mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_TIME_5MIN)
    {
        video_preview_data.time_limit = mmi_camco_get_cmd_reclimit(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_LIMIT)) * 1000;
    }
    else if(mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_SIZE_195K || mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_SIZE_95K || mmi_camco_rec_p->limit == MMI_CAMCO_LIMIT_SIZE_295K )
    {
        video_preview_data.size_limit = mmi_camco_get_cmd_reclimit(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_LIMIT));
    }

    if (mmi_camco_rec_p->external_request.is_enable)
    {
        if (video_preview_data.size_limit == 0)
        {
            video_preview_data.size_limit = mmi_camco_rec_p->external_request.req_size;
        }
        else
        {
            if (mmi_camco_rec_p->external_request.req_size < video_preview_data.size_limit)
            {
                video_preview_data.size_limit = mmi_camco_rec_p->external_request.req_size;
            }
        }
    }
    if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE) == SRV_FMGR_DRV_CARD_TYPE)
    {
        video_preview_data.storage = MDI_VIDEO_REC_STORAGE_SD;
    }
    else
    {
        video_preview_data.storage = MDI_VIDEO_REC_STORAGE_PHONE;    
    }
	#ifdef __CAMCO_TIME_LAPS_VIDEO_RECORDER__
    if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_TIMELAPS) == MMI_CAMCO_TIMELAPS_ON)
    {
		video_preview_data.encode_one_frame_duration = RECORDER_TIME_LAPSE_SAMPLE_PERIOD * 1000;
	}
	else
	{
		video_preview_data.encode_one_frame_duration = 0;

	}
	#endif
    video_preview_data.record_aud = mmi_camco_get_cmd_recaud(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECAUD));

    blt_layer_falg = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1;
    preview_layer_flag = GDI_LAYER_ENABLE_LAYER_0;

    result = mdi_video_rec_preview_start(
                g_mmi_camco_cntx.base_layer_handle,
                blt_layer_falg,
                preview_layer_flag,
                MMI_TRUE,
                &video_preview_data);

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_CAMERA_REC_PREVIEW_START, result);
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__) 
	kal_set_timer(resz_cp_ESD_timeout_timer, (kal_timer_func_ptr)resz_cp_ESD_timeout_timer_hdlr,NULL, KAL_TICKS_3_SEC, 0);
#endif

    if (result == MDI_RES_VDOREC_SUCCEED)
    {
        ret = TRUE;
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_stop
 * DESCRIPTION
 *  stop previewing on main LCD
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * BOOL
 *****************************************************************************/
static void mmi_camco_rec_preview_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_preview_start)
    {
        mdi_video_rec_preview_stop();
        g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
    }
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
 	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
#endif

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_autofocus_start
 * DESCRIPTION
 *  start autofocus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_autofocus_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_video_rec_start_autofocus_process(mmi_camco_rec_autofocus_result_hdlr, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_autofocus_stop
 * DESCRIPTION
 *  stop autofocus
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_autofocus_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mdi_video_rec_stop_autofocus_process();
}

#ifdef __RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__
U8 mmi_camco_rec_get_rotate_value()
{
    mmi_camco_rec_p->rec_rotate = g_mmi_camco_cntx.rotate;
	return mmi_camco_rec_p->rec_rotate;
}

#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_start
 * DESCRIPTION
 *  start to record
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_rec_record_start(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;
	#ifdef __RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ 
    U8 rec_rotate;
	#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(mmi_camco_rec_p->buf_filename_p, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_camco_rec_p->rec_time = 0;

    if (mmi_camco_rec_p->external_request.is_enable && mmi_camco_rec_p->external_request.is_use_ext_req_path)
    {
        //mmi_fmgr_util_load_filepath(mmi_camco_rec_p->buf_filename_p, FMGR_PATH_ID_VIDEO);
        memcpy(mmi_camco_rec_p->buf_filename_p, mmi_camco_rec_p->external_request.ext_path, SRV_FMGR_PATH_BUFFER_SIZE);        
    }
    else
    {
        mmi_camco_rec_get_next_filename(mmi_camco_rec_p->buf_filename_p);
    }
	#ifdef __RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ 
	    rec_rotate = mmi_camco_rec_get_rotate_value();
		mdi_video_rec_set_record_rotation(rec_rotate);
	
		if(rec_rotate == MDI_CAMERA_UI_ROTATE_0 || rec_rotate == MDI_CAMERA_UI_ROTATE_180)
		{
		    mdi_video_rec_update_rec_size(mmi_camco_rec_p->video_width,mmi_camco_rec_p->video_height);
		}
		else
		{
			mdi_video_rec_update_rec_size(mmi_camco_rec_p->video_height,mmi_camco_rec_p->video_width);

		}
	#endif
    result = mdi_video_rec_record_start(mmi_camco_rec_p->buf_filename_p, mmi_camco_rec_record_result_hdlr_callback, NULL);

    return result;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_pause
 * DESCRIPTION
 *  pause recording
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_rec_record_pause(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = mdi_video_rec_record_pause(KAL_FALSE);
	srv_gpio_setting_bl_restore();

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_resume
 * DESCRIPTION
 *  pause recording
 * PARAMETERS
 *  void
 * RETURNS
 *  MDI_RESULT
 *****************************************************************************/
static MDI_RESULT mmi_camco_rec_record_resume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = mdi_video_rec_record_resume();

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_stop
 * DESCRIPTION
 *  stop to record
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_record_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_rec_p->is_record_start)
    {
        /* Stop zoom if zoom is processing */
        if (mmi_camco_osd_is_zooming())
        {
            mmi_camco_osd_stop_zoom();
        }
        mdi_video_rec_record_stop();
        mmi_camco_rec_p->is_record_start = MMI_FALSE;
		srv_gpio_setting_bl_restore();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_file
 * DESCRIPTION
 *  save file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MDI_RESULT result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_p->is_save_result_back = MMI_FALSE;

    if (!mmi_camco_rec_p->is_file_delete)
    {
        result = mdi_video_rec_save_file(mmi_camco_rec_p->buf_filename_p, mmi_camco_rec_save_result_hdlr_callback, NULL);
        if (result == MDI_RES_VDOREC_SUCCEED)
        {
            mmi_camco_rec_p->is_save_success = MMI_TRUE;

            if (mmi_camco_rec_p->is_saving_prev == MMI_TRUE)
            {
                /* 
                 * Camcorder is going to remove from history, 
                 * call stop saving for blocking it 
                 */
                mmi_camco_osd_set_bg_black();

                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_GLOBAL_SAVING));
                mmi_camco_osd_draw_osd();

                mdi_video_rec_stop_save();
                mmi_camco_rec_p->is_saving_prev = MMI_FALSE;
            }
        }
        else
        {
            mmi_camco_rec_p->is_save_success = MMI_FALSE;
            mdi_video_rec_delete_unsaved_file(mmi_camco_rec_p->storage_filepath_p);
            mmi_camco_rec_restore_filename_seq_no();
            mmi_camco_rec_p->is_file_delete = MMI_TRUE;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_tone_finish_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_record_tone_finish_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW ||
               g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSING ||
               g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSED);

#ifdef __MMI_CAMCO_FTE__
    g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;
    mmi_camco_rec_set_recording_start(KAL_FALSE);
#endif 
    ClearKeyEvents();
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_RECORDING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_timer_cyclic
 * DESCRIPTION
 *  record timer cyclic to get
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_record_timer_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 time_in_sec = 0;
    U64 rec_size;
    U64 rec_time;
	U64 rec_frame;
	MMI_BOOL update_screen;
#ifdef __MMI_CAMCO_FTE__
    MMI_BOOL is_only_update_time = MMI_FALSE;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#define MMI_CAMCO_REC_REACH_LIMIT_HDLR_DUR (1200)
#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_rec_time_update(MMI_TRUE);
#endif 
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_RECORDING);
    MMI_CAMCO_START_LOGGING("TIM");
    update_screen = MMI_FALSE;
	if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_TIMELAPS) == MMI_CAMCO_TIMESTAMP_ON)
	{
	    mdi_video_rec_get_record_frame_num(&rec_frame);

		if(mmi_camco_rec_p->rec_frame != rec_frame)
	    {
            update_screen = MMI_TRUE;
			mmi_camco_rec_p->rec_frame = rec_frame;
	    }
    }else
    {
		mdi_video_rec_get_cur_record_time(&rec_time);
		time_in_sec = (U32) (rec_time / 1000);
		if(time_in_sec != (U32) (mmi_camco_rec_p->rec_time / 1000))
		{
		  mmi_camco_rec_p->rec_time = rec_time;
		  update_screen = MMI_TRUE;
		}

	}



    rec_size = mdi_video_rec_get_record_file_size();
    /* 
     * Sometimes, MED clears the record size after sending the reaching size limitation indication to MMI, 
     * but MMI doesn't receive it yet. However, record timer timeout and then get the record size  = 0. 
     * Therefore, MMI needs to cover this case.
     */
    if (rec_size < mmi_camco_rec_p->rec_size)
    {
        rec_size = mmi_camco_rec_p->rec_size;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_SWITCH);
    }
    else
    {
        mmi_camco_rec_p->rec_size = rec_size;
    }

    switch (mmi_camco_rec_p->limit)
    {
        case MMI_CAMCO_LIMIT_NO_LIMIT:
    #ifdef __MMI_CAMCO_FTE__
            is_only_update_time = MMI_TRUE;
    #endif 
            break;

        case MMI_CAMCO_LIMIT_TIME_15S:
                mmi_camco_rec_p->rec_progress_ratio = (U16) (time_in_sec * 100) / MMI_CAMCO_REC_TIME_LIMIT_1;
            break;

        case MMI_CAMCO_LIMIT_TIME_30S:
                mmi_camco_rec_p->rec_progress_ratio = (U16) (time_in_sec * 100) / MMI_CAMCO_REC_TIME_LIMIT_2;
            break;

        case MMI_CAMCO_LIMIT_TIME_60S:
                mmi_camco_rec_p->rec_progress_ratio = (U16) (time_in_sec * 100) / MMI_CAMCO_REC_TIME_LIMIT_3;
            break;

        case MMI_CAMCO_LIMIT_SIZE_95K:
            mmi_camco_rec_p->rec_progress_ratio = (U16) ((rec_size / 1000) * 100) / MMI_CAMCO_REC_SIZE_LIMIT_1;
            break;

        case MMI_CAMCO_LIMIT_SIZE_195K:
            mmi_camco_rec_p->rec_progress_ratio = (U16) ((rec_size / 1000) * 100) / MMI_CAMCO_REC_SIZE_LIMIT_2;
            break;

        case MMI_CAMCO_LIMIT_SIZE_295K:
            mmi_camco_rec_p->rec_progress_ratio = (U16) ((rec_size / 1000) * 100) / MMI_CAMCO_REC_SIZE_LIMIT_3;
            break;
		case MMI_CAMCO_LIMIT_TIME_5MIN:
		case MMI_CAMCO_LIMIT_TIME_10MIN:
			break;

        default:
            MMI_ASSERT(0);
            break;
    }
#ifdef __MMI_OP02_LEMEI__ 
    if (mmi_camco_rec_p->external_request.is_enable)      
    {

            mmi_camco_rec_p->rec_progress_ratio = (U16) (time_in_sec * 100) / 20;
    }
#endif 
    
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_RECORDING_CYCLIC, mmi_camco_rec_p->rec_progress_ratio);
    MMI_CAMCO_STOP_LOGGING("TIM");
    if (mmi_camco_rec_p->is_record_start)
    {
		if(update_screen == TRUE)
		{
            if (mmi_camco_rec_p->rec_progress_ratio > 0 || time_in_sec > 0)
            {
            #if defined(HORIZONTAL_CAMERA) && defined(__MMI_CAMCO_FTE__)
                if (mmi_camco_setting_get_active_cam() == MMI_CAMCO_SETTING_CAM_MAIN)
                    if (is_only_update_time)
                        mmi_camco_osd_draw_record_time_only();
                    else
                        mmi_camco_osd_draw_osd();
                else
            #endif /* defined(HORIZONTAL_CAMERA) && defined(__MMI_CAMCO_FTE__) */ 
                mmi_camco_osd_draw_osd();
            }else if(mmi_camco_rec_p->rec_frame > 0)
            {
			    mmi_camco_osd_draw_osd();

		     }
		}
        gui_start_timer(MMI_CAMCO_RECORDER_TIMER_DUR, mmi_camco_rec_record_timer_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_no_card_lsk_released
 * DESCRIPTION
 *  recorder preview state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_no_card_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 drv_enum;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(mmi_camco_get_storage_count() > 1) /* there are more than one choose to select */
    {
        S32 drv_enum = mmi_camco_osd_get_selected_storage();

        mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
   
        if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);        
            mmi_camco_rec_preview_set_key_hdlr(); 
        }
        else
        {
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            mmi_camco_rec_preview_set_key_hdlr(); 
        }
        mmi_camco_osd_draw_osd();        

    }
    else
    {    
        drv_enum = srv_fmgr_drv_get_type((U8)SRV_FMGR_PUBLIC_DRV);
        mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE)); 
        
      
        if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
        {
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);        
            mmi_camco_rec_preview_set_key_hdlr(); 
        }
        else
        {
            mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
            mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            mmi_camco_rec_preview_set_key_hdlr(); 
        }

       
  
        mmi_camco_osd_draw_osd();                
    }        

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_lsk_released
 * DESCRIPTION
 *  recorder preview state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_exit_current_state();

        mmi_camco_rec_power_off();

        /* Clear background */
        mmi_camco_osd_set_bg_black();

        mmi_camco_rec_recover_framework_environment();

        mmi_camco_cam_entry_app_screen_internal();
    }
    else
    {

        mmi_camco_osd_set_setting_menulist_interrupt(MMI_FALSE);
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SETTING_MENU);
    }        

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_csk_pressed
 * DESCRIPTION
 *  recorder preview state csk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_csk_pressed(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_record_button_pressed();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_rsk_released
 * DESCRIPTION
 *  recorder preview state rsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_exit_app();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_autofocus_button_pressed
 * DESCRIPTION
 *  press AF key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_autofocus_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mmi_camco_setting_get_active_cam() != MMI_CAMCO_SETTING_CAM_SUB)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_FOCUSING);
    }    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_autofocus_button_released
 * DESCRIPTION
 *  press AF key
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_autofocus_button_released(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_rec_autofocus_stop();
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_button_pressed
 * DESCRIPTION
 *  recorder record botton pressed handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_record_button_pressed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#define MMI_CAMCO_RECORD_TONE_PALY_DUR  (300)

    ClearAllKeyHandler();

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSING ||
        g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSED)
    {
        MMI_CAMCO_START_LOGGING("PRE");
		if(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSING)
		{
	        mmi_camco_rec_autofocus_stop();
		}
    #ifndef __MMI_CAMCO_FTE__
        mmi_camco_osd_set_csk_press();
        mmi_camco_osd_draw_osd();
        mmi_camco_osd_set_csk_release();
    #else
        mmi_camco_osd_csk_set_press(MMI_TRUE);                       
        mmi_camco_osd_draw_osd();
        mmi_camco_osd_csk_set_press(MMI_FALSE);               
    #endif /* __MMI_CAMCO_FTE__ */ 
        if (mmi_camco_is_slient_mode())
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_RECORDING);
        }
        else
        {
            /* Avoid recording the tone */
            gui_start_timer(MMI_CAMCO_RECORD_TONE_PALY_DUR, mmi_camco_rec_record_tone_finish_hdlr);

            mdi_audio_play_id(TONE_WARNING1,DEVICE_AUDIO_PLAY_ONCE);                
            /* Camco is in MMI_CAMCO_STATE_REC_PREVIEW state */

        #ifdef __MMI_CAMCO_FTE__                
            mmi_camco_rec_set_recording_start(KAL_TRUE);
        #endif                    
            /* Clear touch key handler */
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);

        #ifdef __MMI_CAMCO_FTE__
            g_mmi_camco_cntx.is_camerakey_valid = MMI_FALSE;
            mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_preview_evt_hdlr);
        #else /* __MMI_CAMCO_FTE__ */ 
        #ifdef MMI_CAMCO_OSD_ICON_SWKEY
            #ifdef __MMI_FTE_SUPPORT__
                mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, NULL);
                mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SETTINGS, IMG_ID_CAMCO_SETTINGS_SEL, NULL);
            #else
                mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, NULL);
                mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_SETTINGS, IMG_ID_CAMCO_SETTINGS, NULL);    
            #endif
        #else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
            mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, NULL);
            mmi_camco_osd_set_lsk_str(STR_GLOBAL_SETTINGS, NULL);
        #endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
        #endif /* __MMI_CAMCO_FTE__ */ 
        }
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_RECORDING)
    {
        //gui_cancel_timer(mmi_camco_rec_timelimit_hdlr);
        gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);

        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SAVE_DONE)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_failed_rsk_released
 * DESCRIPTION
 *  video preview failed state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_preview_failed_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_exit_app();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_setting_menu_lsk_released
 * DESCRIPTION
 *  recorder setting menu state lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_setting_menu_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 

    if (g_mmi_camco_cntx.is_switching_app)
    {
        mmi_camco_exit_current_state();

        mmi_camco_rec_power_off();

        /* Clear background */
        mmi_camco_osd_set_bg_black();

        mmi_camco_rec_recover_framework_environment();

        mmi_camco_cam_entry_app_screen_internal();
    }
    else if (mmi_camco_rec_p->is_switchto_vdoply)
    {
        g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_PREVIEW;

    #ifdef __MMI_VIDEO_PLAYER__
        mmi_vdoply_set_storage(mmi_camco_rec_p->storage);
        mmi_vdoply_entry_app();
    #endif /* __MMI_VIDEO_PLAYER__ */ 
    }
#ifdef DUAL_CAMERA_SUPPORT
    else if (g_mmi_camco_cntx.is_switchto_maincamera || g_mmi_camco_cntx.is_switchto_subcamera)
    {
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_EXIT);
        mmi_camco_osd_reset_environment();

        mmi_camco_exit_current_state();

        mmi_camco_rec_power_off();

        /* Clear background */
        mmi_camco_osd_set_bg_black();

    #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
        gdi_bltdb_disable();
    #endif        

        if (g_mmi_camco_cntx.is_switchto_maincamera)
        {
            mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_MAIN);
            mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_MAIN);
        }
        else
        {
            mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_SUB);
            mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_SUB);
        }

        mmi_camco_osd_set_default();
        mmi_camco_osd_init();
    #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)        
        gdi_bltdb_enable(GDI_BLTDB_ENABLE_ONLY_WHEN_HW_UPDATE);    
    #endif        
        mmi_camco_osd_setup_environment(g_mmi_camco_cntx.app_mem_buf_p);

        mmi_camco_setting_init();
        mmi_camco_setting_load_from_nvram();
        mmi_camco_setting_default_capability();

        /* Must call this to correct to the right scenemode setting */
        if (mmi_camco_setting_get_last_active_app() != mmi_camco_setting_get_active_app())
        {
            mmi_camco_setting_switch_capability();
            mmi_camco_setting_update_capability();
            mmi_camco_update_facedetect_capability();
        }

        if (mmi_camco_rec_p->external_request.is_enable)
        {
            if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) > MMI_CAMCO_RECSIZE_CIF)
            {
            #ifdef __MMI_OP02_LEMEI__   
                mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);      
                mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_QCIF);
                mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_RECSIZE);                      
            #else             
                if (mmi_camco_setting_get_itemlist_capability(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF) ==
                    MMI_CAMCO_SETTING_CAP_ENABLED)
                {
                    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF);
                    mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_CIF);
                }
                else
                {
                    mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);
                    mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_QCIF);
                }
            #endif    
            }
        }

        if (mmi_camco_is_from_external())
        {
            mmi_camco_set_external_vdoswitchto_capability();
            mmi_camco_setting_update_capability();
            mmi_camco_update_facedetect_capability();
        }

        mmi_camco_need_restart_preview();
        mmi_camco_rec_power_on();
        if (g_mmi_camco_cntx.is_power_on)
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
        }
        else
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW_FAILED);
        }

        g_mmi_camco_cntx.is_switchto_maincamera = MMI_FALSE;
        g_mmi_camco_cntx.is_switchto_subcamera = MMI_FALSE;
    }
#endif /* DUAL_CAMERA_SUPPORT */ 
    else if (g_mmi_camco_cntx.is_restore_default)
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_RESTORE_CONFIRM);
    }
    else
    {
        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_setting_menu_rsk_released
 * DESCRIPTION
 *  recorder setting menu state rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_setting_menu_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CAMCO_FEATURE_PREVIEW_WATCHDOG_TIMEOUT__
    mmi_camco_reset_preview_terminate_timer();
#endif 

    g_mmi_camco_cntx.is_restart_preview = MMI_FALSE;
    g_mmi_camco_cntx.is_switching_app = MMI_FALSE;

    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_recording_lsk_released
 * DESCRIPTION
 *  recorder recording state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_recording_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PAUSE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_recording_rsk_released
 * DESCRIPTION
 *  recorder preview state rsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_recording_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_pause_lsk_released
 * DESCRIPTION
 *  recorder pause state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_pause_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_RECORDING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_pause_rsk_released
 * DESCRIPTION
 *  recorder pause state rsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_pause_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_lsk_released
 * DESCRIPTION
 *  recorder pause state lsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_done_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_id;
    U16 item_strlist[MMI_CAMCO_FORWARD_ITEM_NUM];
    U16 i = 0;
    U16 j = 0;
    MMI_BOOL is_found = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_rec_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_EXIT)
    {
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
    }
#ifdef __MMI_CAMCO_FTE__
    if (g_mmi_camco_cntx.option_menulist.state == MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0)
    {
        mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
        mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
        mmi_camco_osd_set_captured_mode(MMI_FALSE);
        mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_rec_p->buf_filename_p +
                                          (2 * mmi_ucs2strlen(mmi_camco_rec_p->storage_filepath_p)));
        mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_save_done_evt_hdlr);
        SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);        
    }
#endif /* __MMI_CAMCO_FTE__ */ 
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_0;

#ifndef __MMI_CAMCO_FTE__
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);
#endif 

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_save_done_evt_hdlr);
    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#else /* __MMI_CAMCO_FTE__ */ 
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_save_done_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_rec_save_done_option_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_save_done_option_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_rec_save_done_option_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_save_done_option_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_rec_save_done_option_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 
#endif /* __MMI_CAMCO_FTE__ */ 

    mmi_camco_osd_set_option_title(STR_GLOBAL_OPTIONS);

    mmi_camco_osd_insert_option_item(MMI_CAMCO_REC_OPTION_DELETE, STR_GLOBAL_DELETE);

    menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)mmi_camco_rec_p->buf_filename_p);
    if (menu_id > 0)
    {
        for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
        {
            item_strlist[i] = 0;
        }

        GetSequenceStringIds_Ext(menu_id, item_strlist);
        GetSequenceItemIds_Ext(menu_id, g_mmi_camco_cntx.fowarditem_idlist);

        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) > MMI_CAMCO_RECSIZE_CIF)
        {
            for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
            {
            #ifdef __MMI_MMS_2__	
                if (g_mmi_camco_cntx.fowarditem_idlist[i] == MENU_ID_FMGR_FWD_MMS)
                {
                    is_found = MMI_TRUE;
                    break;
                }
            #endif    
            }

            if (is_found)
            {
                for (j = i + 1; j < MMI_CAMCO_FORWARD_ITEM_NUM; j++)
                {
                    item_strlist[j - 1] = item_strlist[j];
                    g_mmi_camco_cntx.fowarditem_idlist[j - 1] = g_mmi_camco_cntx.fowarditem_idlist[j];
                }

                item_strlist[MMI_CAMCO_FORWARD_ITEM_NUM - 1] = 0;
                g_mmi_camco_cntx.fowarditem_idlist[MMI_CAMCO_FORWARD_ITEM_NUM - 1] = 0;
            }

        }

        if (item_strlist[0] != 0)
        {
            mmi_camco_rec_p->is_forward = MMI_TRUE;
            mmi_camco_osd_insert_option_item(MMI_CAMCO_REC_OPTION_FORWARD, STR_GLOBAL_FORWARD);
        }
        else
        {
            mmi_camco_rec_p->is_forward = MMI_FALSE;
        }
    }
    else
    {
        mmi_camco_rec_p->is_forward = MMI_FALSE;
    }
#if defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__)
    mmi_camco_osd_insert_option_item(MMI_CAMCO_REC_OPTION_PLAY, STR_GLOBAL_PLAY);
#endif 
    mmi_camco_osd_insert_option_done();

    if (!g_mmi_camco_cntx.option_menulist.is_rollback)
    {
        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);
    }

    mmi_camco_osd_draw_osd();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_rsk_released
 * DESCRIPTION
 *  recorder pause state rsk release handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_done_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_csk_released
 * DESCRIPTION
 *  camera preview state csk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_done_csk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_camco_send_to_mms();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_option_lsk_released
 * DESCRIPTION
 *  camera save done state option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_done_option_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    U32 current_item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_rec_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    if (g_mmi_camco_cntx.option_menulist.state != MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1)
    {
        g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_LEVEL_1;
        g_mmi_camco_cntx.option_menulist.highlight_idx = 0;
        current_idx = mmi_camco_osd_get_option_hilite_idx();
        current_item = mmi_camco_osd_get_option_item_id(current_idx);
    }
    else
    {
        current_item = g_mmi_camco_cntx.option_menulist.option;
    }

    switch (current_item)
    {
        case MMI_CAMCO_REC_OPTION_DELETE:
            mmi_camco_rec_delete_confirm();
            break;

        case MMI_CAMCO_REC_OPTION_FORWARD:
            mmi_camco_rec_forward_menu();
            break;

    #if defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__)
        case MMI_CAMCO_REC_OPTION_PLAY:
            mmi_camco_rec_entry_playing();
            break;
    #endif /* defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__) */ 

        default:
            MMI_ASSERT(0);
            break;
    }

    g_mmi_camco_cntx.option_menulist.is_fromhistory = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_option_rsk_released
 * DESCRIPTION
 *  camera save done state option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_done_option_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_rec_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);

    mmi_camco_osd_set_corner_hint_str((CHAR*) mmi_camco_rec_p->buf_filename_p +
                                      (2 * mmi_ucs2strlen(mmi_camco_rec_p->storage_filepath_p)));

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_save_done_evt_hdlr);
    SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
#else /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_rec_save_done_set_key_hdlr();
#endif /* __MMI_CAMCO_FTE__ */ 

    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_FALSE;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    mmi_camco_osd_draw_osd();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_delete_confirm_lsk_released
 * DESCRIPTION
 *  camera delete confirm option lsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_delete_confirm_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_is_usb_in_CDC() && !mmi_camco_is_file_exist(mmi_camco_rec_p->buf_filename_p))
    {
        mmi_camco_file_deleted_hdlr();
        return;
    }

    FS_Delete((U16*) mmi_camco_rec_p->buf_filename_p);
    mmi_camco_rec_restore_filename_seq_no();

    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    g_mmi_camco_cntx.option_menulist.highlight_idx = 0;

    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_delete_confirm_rsk_released
 * DESCRIPTION
 *  camera delete confirm option rsk released handler
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_delete_confirm_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.highlight_idx = MMI_CAMCO_REC_OPTION_DELETE;
    mmi_camco_rec_save_done_lsk_released(KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_forward_menu_lsk_released
 * DESCRIPTION
 *  mmi_camco_rec_forward_menu_lsk_released
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_forward_menu_lsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 current_idx;
    CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];
    S32 menu_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;
    menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)mmi_camco_rec_p->buf_filename_p);

    if (menu_id > 0)
    {
        current_idx = mmi_camco_osd_get_option_hilite_idx();

        memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);
        mmi_ucs2cpy(ucs2_filename,  mmi_camco_rec_p->buf_filename_p);

        srv_fmgr_types_launch_option((WCHAR*)ucs2_filename, g_mmi_camco_cntx.fowarditem_idlist[current_idx]);
    }
    else
    {
        mmi_camco_file_deleted_hdlr();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_forward_menu_rsk_released
 * DESCRIPTION
 *  mmi_camco_rec_forward_menu_rsk_released
 * PARAMETERS
 *  key_type        [IN]        Key type
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_forward_menu_rsk_released(mmi_key_types_enum key_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.highlight_idx = MMI_CAMCO_CAM_OPTION_FORWARD;
    mmi_camco_osd_set_option_hilite_idx(MMI_CAMCO_CAM_OPTION_FORWARD);
    g_mmi_camco_cntx.option_menulist.is_rollback = MMI_TRUE;

    mmi_camco_rec_save_done_lsk_released(KEY_EVENT_DOWN);
}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_delete_confirm
 * DESCRIPTION
 *  mmi_camco_rec_delete_confirm
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_delete_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_prof_tone_enum tone_type = SRV_PROF_TONE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.option = MMI_CAMCO_REC_OPTION_DELETE;

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_CONFIRM_WITH_BAR);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);

    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(STR_ID_CAMCO_DELETE_QUERY));

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_delete_confirm_evt_hdlr);
#else /* __MMI_CAMCO_FTE__ */ 
    mmi_camco_set_csk_action_mode(MMI_FALSE);
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_delete_confirm_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_rec_delete_confirm_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_delete_confirm_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_rec_delete_confirm_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_NO, mmi_camco_rec_delete_confirm_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_YES, mmi_camco_rec_delete_confirm_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_set_csk_action_mode(MMI_TRUE);

#endif /* __MMI_CAMCO_FTE__ */ 

    mmi_camco_osd_draw_osd();

    if (!g_mmi_camco_cntx.option_menulist.is_fromhistory)
    {
        tone_type = mmi_get_event_based_sound(MMI_EVENT_QUERY);
        if (tone_type != NONE_TONE)
        {
            srv_prof_play_tone(tone_type, NULL);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_forward_menu
 * DESCRIPTION
 *  mmi_camco_rec_forward_menu
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_forward_menu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 menu_id;
    U16 item_strlist[MMI_CAMCO_FORWARD_ITEM_NUM];
    U16 i = 0;
    U16 j = 0;
    MMI_BOOL is_found = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.option = MMI_CAMCO_REC_OPTION_FORWARD;

    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_OPTION_MENU);

#ifdef __MMI_CAMCO_FTE__
    mmi_camco_osd_reg_evt_hdlr(mmi_camco_rec_forward_menu_evt_hdlr);
#else /* __MMI_CAMCO_FTE__ */ 
    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_FALSE);    	
    } 
#ifdef MMI_CAMCO_OSD_ICON_SWKEY
    #ifdef __MMI_FTE_SUPPORT__
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK_SEL, mmi_camco_rec_forward_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK_SEL, mmi_camco_rec_forward_menu_lsk_released);
    #else
        mmi_camco_osd_set_rsk_img(IMG_ID_CAMCO_BACK, IMG_ID_CAMCO_BACK, mmi_camco_rec_forward_menu_rsk_released);
        mmi_camco_osd_set_lsk_img(IMG_ID_CAMCO_OK, IMG_ID_CAMCO_OK, mmi_camco_rec_forward_menu_lsk_released);
    #endif
#else /* MMI_CAMCO_OSD_ICON_SWKEY */ 
    mmi_camco_osd_set_rsk_str(STR_GLOBAL_BACK, mmi_camco_rec_forward_menu_rsk_released);
    mmi_camco_osd_set_lsk_str(STR_GLOBAL_OK, mmi_camco_rec_forward_menu_lsk_released);
#endif /* MMI_CAMCO_OSD_ICON_SWKEY */ 

    if (r2lMMIFlag)
    {
        mmi_camco_set_csk_action_mode(MMI_TRUE);    	
    } 
#endif /* __MMI_CAMCO_FTE__ */ 

    mmi_camco_osd_set_option_title(STR_GLOBAL_FORWARD);

    for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
    {
        item_strlist[i] = 0;
    }

    menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)mmi_camco_rec_p->buf_filename_p);
    if (menu_id > 0)
    {
        GetSequenceStringIds_Ext(menu_id, item_strlist);
        GetSequenceItemIds_Ext(menu_id, g_mmi_camco_cntx.fowarditem_idlist);

        if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) > MMI_CAMCO_RECSIZE_CIF)
        {
            for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
            {
            #ifdef __MMI_MMS_2__	
                if (g_mmi_camco_cntx.fowarditem_idlist[i] == MENU_ID_FMGR_FWD_MMS)
                {
                    is_found = MMI_TRUE;
                    break;
                }
            #endif    
            }

            if (is_found)
            {
                for (j = i + 1; j < MMI_CAMCO_FORWARD_ITEM_NUM; j++)
                {
                    item_strlist[j - 1] = item_strlist[j];
                    g_mmi_camco_cntx.fowarditem_idlist[j - 1] = g_mmi_camco_cntx.fowarditem_idlist[j];
                }

                item_strlist[MMI_CAMCO_FORWARD_ITEM_NUM - 1] = 0;
                g_mmi_camco_cntx.fowarditem_idlist[MMI_CAMCO_FORWARD_ITEM_NUM - 1] = 0;
            }

        }

        mmi_camco_osd_set_option_title(STR_GLOBAL_FORWARD);

        for (i = 0; i < MMI_CAMCO_FORWARD_ITEM_NUM; i++)
        {
            if (item_strlist[i] != 0)
            {
                mmi_camco_osd_insert_option_item(g_mmi_camco_cntx.fowarditem_idlist[i], (MMI_ID_TYPE) item_strlist[i]);
            }
            else
            {
                break;
            }
        }

        mmi_camco_osd_insert_option_done();

        mmi_camco_osd_set_option_hilite_idx(g_mmi_camco_cntx.option_menulist.highlight_idx);

        mmi_camco_osd_draw_osd();
    }
    else
    {
        mmi_camco_file_deleted_hdlr();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_entry_playing
 * DESCRIPTION
 *  mmi_camco_rec_entry_playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__)
static void mmi_camco_rec_entry_playing(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_camco_cntx.option_menulist.option = MMI_CAMCO_REC_OPTION_PLAY;
    g_mmi_camco_cntx.option_menulist.state = MMI_CAMCO_OPTION_MENULIST_STATE_EXIT;

    memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);

    mmi_ucs2cpy( ucs2_filename,  mmi_camco_rec_p->buf_filename_p);

    mmi_media_app_play_video(ucs2_filename, MMI_FALSE);
}
#endif /* defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__) */ 

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_autofocus_result_hdlr
 * DESCRIPTION
 *  focus result handler
 * PARAMETERS
 *  result_ind      [IN]        Af result indication
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_autofocus_result_hdlr(mdi_video_rec_af_result_struct result_ind, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_AF_RESULT, result_ind.af_result);

    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSING && !mmi_camco_rec_p->is_record_failed)
    {
        if (result_ind.af_result == MDI_AF_SEARCH_STATUS_FOUND_SUCCESS)
        {
            mmi_camco_rec_p->af_result.af_result = result_ind.af_result;
            mmi_camco_rec_p->af_result.af_success_zone = result_ind.af_success_zone;

            mmi_camco_play_autofocus_success_sound();

            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_FOCUSED);
        }
        else if (result_ind.af_result == MDI_AF_SEARCH_STATUS_SWITCH_MACRO)
        {
            /* Camera is still in MMI_CAMCO_STATE_CAM_FOCUSING */
            mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_FOCUSE_HINT);
            mmi_camco_osd_set_center_focus_process_hint_img(IMG_ID_CAMCO_AFRANGE_MACRO);
        }
        else
        {
            U8 idx;
            U16 region_idx;
            U16 w, h;
            U16 center_x, center_y;
            U32 af_active_zone = 0;

            af_active_zone = mmi_camco_rec_p->af_zone.af_active_zone;

            for (idx = MMI_CAMCO_OSD_FOCUS_REGION_1; idx < MMI_CAMCO_OSD_FOCUS_REGION_END; idx++)
            {
                if (af_active_zone & 0x00000001)
                {
                    region_idx = MMI_CAMCO_OSD_FOCUS_REGION_1 + idx;

                    w = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_w;
                    h = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_h;
                    center_x = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_x + g_mmi_camco_cntx.preview_wnd.offset_x;
                    center_y = mmi_camco_rec_p->af_zone.af_zone[idx].af_zone_y + g_mmi_camco_cntx.preview_wnd.offset_y;

                    mmi_camco_osd_set_focus(
                        (mmi_camco_osd_focus_region_enum)region_idx,
                        MMI_CAMCO_OSD_FOCUS_TYPE_FOCUSING_FAIL,
                        center_x,
                        center_y,
                        w,
                        h);
                }
                af_active_zone = af_active_zone >> 1;
            }
        }

        mmi_camco_osd_draw_osd();
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_record_result_hdlr_callback
 * DESCRIPTION
 *  record result callback hdlr
 * PARAMETERS
 *  result      [IN]        Record result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_record_result_hdlr_callback(MDI_RESULT result, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_RECORD_RESULT_CB, result);
    mmi_camco_rec_p->is_record_start = MMI_FALSE;
    srv_gpio_setting_bl_restore();//for time lapse record
    gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
#endif

    if (result == MDI_RES_VDOREC_REACH_SIZE_LIMIT || result == MDI_RES_VDOREC_REACH_TIME_LIMIT)
    {
        mmi_camco_rec_p->rec_progress_ratio = 100;
        mdi_video_rec_get_cur_record_time(&mmi_camco_rec_p->rec_time);    
        gdi_layer_push_and_set_active(g_mmi_camco_cntx.base_layer_handle);     
        gdi_layer_clear(GDI_COLOR_BLACK);   
        gdi_layer_pop_and_restore_active();              
        mmi_camco_osd_draw_osd();
        kal_sleep_task(100);
    }

    if (result != MDI_RES_VDOREC_RECORD_ALREADY_STOP && result != MDI_RES_VDOREC_SUCCEED)
    {
        mmi_camco_show_error_msg(result);
        mmi_camco_highlight_turn_off();
    }

    if (result >= MDI_RES_VDOREC_SUCCEED)
    {
        /* sleep 500 tick for showing reaching limit msg */
        kal_sleep_task(500);

        mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
    }
    else
    {
        /* rec wont popup memory card remove screen, so update storage if error to update the disk status */
        mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));
        mmi_camco_error_hdlr_timer_start();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_result_hdlr_callback
 * DESCRIPTION
 *  callback function when save is done
 * PARAMETERS
 *  result      [IN]        Save result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_save_result_hdlr_callback(MDI_RESULT result, void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_SAVE_RESULT_CB, result);

    mmi_camco_rec_p->is_save_result_back = MMI_TRUE;
    mmi_camco_rec_p->is_saving_prev = MMI_FALSE;

    if (mmi_camco_rec_p->external_request.is_enable)
    {
        CHAR ucs2_filename[SRV_FMGR_PATH_BUFFER_SIZE];

    #ifdef __MMI_OP02_LEMEI__ 
        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_LIMIT, MMI_CAMCO_LIMIT_NO_LIMIT);        
    #endif   

        memset(ucs2_filename, 0, SRV_FMGR_PATH_BUFFER_SIZE);
        mmi_ucs2cpy(g_mmi_camco_ext_calling_save_file,  mmi_camco_rec_p->buf_filename_p);

        if (result >= MDI_RES_VDOREC_SUCCEED)
        {
            cui_vdorec_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_vdorec_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_VDOREC_RECORD_EVENT_RESULT_SUCCESS;
            /* evt.file_path = ucs2_filename; */
            /* temp return camco path */
            /* need to provide a metehod to AP for get non-local path */
            /* camera cui also need to provide the same interface */
            evt.file_path = g_mmi_camco_ext_calling_save_file;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }
        else
        {
            if (!((srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0) &&
                  !(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CSD_CALL_TYPE_ALL, NULL) > 0)) &&
                !(srv_reminder_is_expiring()))
            {
                if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SAVING)
                {
                    mmi_camco_show_error_msg(result);
                    kal_sleep_task(500);
                }
            }

            {
                cui_vdorec_event_struct evt;

                MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_vdorec_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
                evt.evt_id = CUI_VDOREC_RECORD_EVENT_RESULT_FAILED;
                /* evt.file_path = ucs2_filename; */
                /* temp return camco path */
                /* need to provide a metehod to AP for get non-local path */
                /* camera cui also need to provide the same interface */
                evt.file_path = NULL;
                mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
            }
            mmi_camco_rec_p->is_record_failed = MMI_TRUE;
            mmi_camco_rec_restore_filename_seq_no();
        }

        if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVING)
        {
            /* For avoiding calling mdi_video_rec_stop_save() in del_scr_callback */
            g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_INT_SAVE_DONE;
        }

        /* is in call or alarm, they have higher priority, do not show popup */
        if (!(mmi_camco_is_incall() &&
              !(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CSD_CALL_TYPE_ALL, NULL) > 0)) &&
            !(srv_reminder_is_expiring()))
        {
            /* Return to previous application which asks the requst */
            return;
        }
    }
    else
    {
        mmi_camco_rec_p->save_result = result;

        MMI_CAMCO_STOP_LOGGING("SAV");

        if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SAVING)
        {
            if (result == MDI_RES_VDOREC_SUCCEED)
            {
                ClearKeyEvents();
                mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVE_DONE);
            }
            else
            {
                /* Camcorder is in MMI_CAMCO_STATE_REC_SAVING */
                mmi_camco_show_error_msg(result);
                mmi_camco_error_hdlr_timer_start();
            }
        }
        else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SAVING_PREV)
        {
            mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_timelimit_hdlr
 * DESCRIPTION
 *  recorder timelimit hdlr.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_rec_timelimit_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_RECORDING);

    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_SAVING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_show_error_msg
 * DESCRIPTION
 *  record result callback hdlr
 * PARAMETERS
 *  result      [IN]        MDI return value
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_show_error_msg(MDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 string_id;
    mmi_event_notify_enum popup_type;
    srv_prof_tone_enum tone_type = SRV_PROF_TONE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_ERROR_MSG, g_mmi_camco_cntx.app_state, result);

    if(!g_mmi_camco_cntx.is_preview_start)
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_TRUE);
    }
    else
    {
        mmi_camco_set_base_layer(&g_mmi_camco_cntx.base_layer_handle, MMI_FALSE);
    }        
    mmi_camco_osd_set_base_layer(g_mmi_camco_cntx.base_layer_handle);    
    string_id = mmi_camco_mapping_error_string(result, &popup_type);
    tone_type = mmi_get_event_based_sound(popup_type);
    if (tone_type != NONE_TONE)
    {
        srv_prof_play_tone(tone_type, NULL);
    }

    mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_ONLY);
    mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);

    mmi_camco_osd_set_center_hint_str((CHAR*) GetString(string_id));
    mmi_camco_osd_draw_osd();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_mapping_error_string
 * DESCRIPTION
 *  record result callback hdlr
 * PARAMETERS
 *  result          [IN]        MDI return value
 *  popup_type      [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
static U16 mmi_camco_mapping_error_string(MDI_RESULT result, mmi_event_notify_enum *popup_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (result)
    {
        case MDI_RES_CAMERA_ERR_DISK_FULL:
        case MDI_RES_VDOREC_ERR_DISK_FULL:
        case MDI_RES_VDOREC_DISK_FULL:
        case MDI_RES_VDOREC_ERR_STORAGE_INSUFFICIENT:
	    case MDI_RES_VDOREC_ERR_MEMORY_INSUFFICIENT:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_GLOBAL_NOT_ENOUGH_MEMORY;
            //break;

        case MMI_CAMCO_ERR_ROOT_DIR_FULL:
            *popup_type = MMI_EVENT_FAILURE;
            return FMGR_FS_ROOT_DIR_FULL_TEXT;
            //break;
        case MDI_RES_VDOREC_ERR_NO_FRAME_ENCODED:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_GLOBAL_FAILED_TO_SAVE;
            //break;
        case MDI_RES_CAMERA_ERR_NO_DISK:
        case MDI_RES_CAMERA_ERR_CAPTURE_FAILED:
        case MDI_RES_CAMERA_ERR_MEMORY_NOT_ENOUGH:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_CAPTURE_FAILED;
            //break;

        case MMI_CAMCO_CAM_NOT_READY:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_NOTIFY_HW_NOT_READY;
            //break;

        case MDI_RES_VDOREC_REACH_SIZE_LIMIT:
            *popup_type = MMI_EVENT_INFO;
            return STR_ID_CAMCO_NOTIFY_REACH_SIZE_LIMIT;
            //break;

        case MDI_RES_VDOREC_REACH_TIME_LIMIT:
            *popup_type = MMI_EVENT_INFO;
            return STR_ID_CAMCO_NOTIFY_REACH_TIME_LIMIT;
            //break;

        case MDI_RES_VDOREC_ERR_NO_DISK:
	    case MDI_RES_CAMERA_ERR_HW_NOT_READY:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_NOTIFY_STORAGE_NOT_READY;
            //break;

        case MDI_RES_CAMERA_ERR_WRITE_PROTECTION:
        case MDI_RES_VDOREC_ERR_WRITE_PROTECTION:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_NOTIFY_WRITE_PROTECT;
            //break;

        case MDI_RES_VDOREC_ERR_RESUME_FAILED:
        case MDI_RES_VDOREC_ERR_RECORD_FAILED:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_NOTIFY_ERROR;
           // break;

        case MDI_RES_VDOREC_ERR_PAUSE_FAILED:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_PAUSE_FAILED;
            //break;

        case MMI_CAMCO_ERR_SAVE_FAIL:
        case MDI_RES_CAMERA_ERR_SAVE_FAILED:
        case MDI_RES_VDOREC_ERR_SAVE_FILE_FAILED:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_GLOBAL_FAILED_TO_SAVE;
            //break;

        case MMI_CAMCO_ERR_STORAGE_CHANGE:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_ID_CAMCO_SWITCH_TO_MEM_CARD;
            //break;

        case MMI_CAMCO_ERR_FILE_NOT_FOUND:
            *popup_type = MMI_EVENT_FAILURE;
            return FMGR_FS_FILE_NOT_FOUND_TEXT;
            //break;

        case MMI_CAMCO_ERR_SET_CARD_AND_NO_CARD:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_GLOBAL_MC_REMOVED;
            //break;
            
        default:
            *popup_type = MMI_EVENT_FAILURE;
            return STR_GLOBAL_ERROR;
            //break;

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_get_min_external_request_size
 * DESCRIPTION
 *  get minal external request size (in K), reasonal size for 1 sec
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
U32 mmi_camco_rec_get_min_external_request_size(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef MJPG_ENCODE
    /* Motion JPEG */
    return 60;
#else /* MJPG_ENCODE */ 
    /* MPEG4 */
    return 30;
#endif /* MJPG_ENCODE */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_error_string_by_error_enum
 * DESCRIPTION
 *  Get error string by error code.
 * PARAMETERS
 *  err_code        [IN]        
 * RETURNS
 *  error string id
 *****************************************************************************/
MMI_ID_TYPE mmi_camco_get_error_string_by_error_enum(S32 err_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID_TYPE string_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (err_code)
    {
        case MDI_RES_CAMERA_ERR_DISK_FULL:
            string_id = STR_GLOBAL_NOT_ENOUGH_MEMORY;
            break;

        case MDI_RES_CAMERA_ERR_NO_DISK:
            string_id = STR_ID_CAMCO_MEM_CARD_REMOVE;
            break;

        case MDI_RES_CAMERA_ERR_WRITE_PROTECTION:
            string_id = STR_ID_CAMCO_NOTIFY_WRITE_PROTECT;
            break;

        case MDI_RES_CAMERA_ERR_CAPTURE_FAILED:
            string_id = STR_ID_CAMCO_CAPTURE_FAILED;
            break;

        case MDI_RES_CAMERA_ERR_HW_NOT_READY:
            string_id = STR_ID_CAMCO_NOTIFY_HW_NOT_READY;
            break;

        default:
            string_id = STR_ID_CAMCO_NOTIFY_ERROR;
            break;
    }

    return string_id;

}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_set_quickview_color_format
 * DESCRIPTION
 *  
 * PARAMETERS    
 *  void    
 * RETURNS
 *  void
 *****************************************************************************/
 void mmi_camco_set_quickview_color_format(void)
{

	g_mmi_camco_cntx.cam.qvi_color_format = mdi_camera_get_quickview_color_format();
	gdi_layer_push_and_set_active(g_mmi_camco_cntx.non_preview_base_layer_handle);
	gdi_layer_set_color_format(g_mmi_camco_cntx.cam.qvi_color_format);
	gdi_layer_pop_and_restore_active();
	mmi_camco_osd_set_qvi_color_format(g_mmi_camco_cntx.cam.qvi_color_format);
}
/*****************************************************************************
* Camcorder App V.S. OSD event handler
*****************************************************************************/
#ifdef __MMI_CAMCO_FTE__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_preview_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_cam_preview_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_preview_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CAPTURE:
        {
            if (g_mmi_camco_cntx.is_camerakey_valid)
                mmi_camco_cam_preview_csk_pressed(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_SWITCH_APP:
        {
            if (g_mmi_camco_cntx.is_switching_app)
            {
                mmi_camco_exit_current_state();

                mmi_camco_cam_power_off();

                /* Clear background */
                mmi_camco_osd_set_bg_black();

                mmi_camco_cam_recover_framework_environment();

                mmi_camco_rec_entry_app_screen_internal();
            }

            break;
        }
        case MMI_CAMCO_EVT_SWITCH_SENSOR:
        {        
        #ifdef DUAL_CAMERA_SUPPORT
            if (g_mmi_camco_cntx.is_switchto_maincamera || g_mmi_camco_cntx.is_switchto_subcamera)
            {
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_EXIT);
                mmi_camco_osd_reset_environment();

                mmi_camco_exit_current_state();

                mmi_camco_cam_power_off();

                /* Clear background */
                mmi_camco_osd_set_bg_black();

            #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
                gdi_bltdb_disable();
            #endif

                if (g_mmi_camco_cntx.is_switchto_maincamera)
                {
                    mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_MAIN);
                    mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_MAIN);
                }
                else
                {
                    mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_SUB);
                    mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_SUB);
                }

                mmi_camco_osd_set_default();
                mmi_camco_osd_init();
            #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)        
                gdi_bltdb_enable(GDI_BLTDB_ENABLE_ONLY_WHEN_HW_UPDATE);    
            #endif        
                mmi_camco_osd_setup_environment(g_mmi_camco_cntx.app_mem_buf_p);

                mmi_camco_setting_init();
                mmi_camco_setting_load_from_nvram();
                mmi_camco_setting_default_capability();

                /* Must call this to correct to the right scenemode setting */
                if (mmi_camco_setting_get_last_active_app() != mmi_camco_setting_get_active_app())
                {
                    mmi_camco_setting_switch_capability();
                    mmi_camco_setting_update_capability();
                    mmi_camco_update_facedetect_capability();
                }

                if (mmi_camco_is_from_external())
                {
                    U16 capmode = mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_CAPMODE);

                    mmi_camco_setting_update_capability();
                    mmi_camco_update_facedetect_capability();
                    mmi_camco_set_external_camswitchto_capability();
                    mmi_camco_set_external_capmode_capability();

                    if (capmode != MMI_CAMCO_CAPMODE_NORMAL && capmode != MMI_CAMCO_CAPMODE_ADD_FRAME)
                    {
                        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_CAPMODE, MMI_CAMCO_CAPMODE_NORMAL);
                    #ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__
                        mmi_camco_osd_set_add_frame_enable(MMI_FALSE);
                    #endif 
                        mmi_camco_update_capmode(MMI_CAMCO_CAPMODE_NORMAL);
                    }

                }

                mmi_camco_need_restart_preview();
                mmi_camco_cam_power_on();
                if (g_mmi_camco_cntx.is_power_on)
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW);
                }
                else
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_CAM_PREVIEW_FAILED);
                }

                g_mmi_camco_cntx.is_switchto_maincamera = MMI_FALSE;
                g_mmi_camco_cntx.is_switchto_subcamera = MMI_FALSE;
            }        
        #endif /* DUAL_CAMERA_SUPPORT */         
            break;
        }            
        case MMI_CAMCO_EVT_ENTER_IMGVIEWER:
        {
        #ifdef __MMI_IMAGE_VIEWER__
            if (mmi_camco_cam_p->is_switchto_imgviewer)
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_CAM_PREVIEW;
                g_mmi_camco_cntx.is_to_media_editor = MMI_TRUE;
                mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
                mmi_imgview_set_storage(mmi_camco_cam_p->storage);
                mmi_imgview_launch();
            }
        #endif /* __MMI_IMAGE_VIEWER__ */ 
            break;
        }
        case MMI_CAMCO_EVT_CONFIRM_YES:
        {
            /* mmi_camco_check_storage_capability(); */
            U16 drv_enum;

            drv_enum = srv_fmgr_drv_get_type((U8)SRV_FMGR_PUBLIC_DRV);
            mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));

            if (mmi_camco_cam_p->is_drive_available && mmi_camco_cam_p->is_space_enough)
            {
				#ifdef AF_SUPPORT
					SetKeyHandler(mmi_camco_cam_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
				#endif

                SetKeyHandler(mmi_camco_cam_capture_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                SetKeyHandler(mmi_camco_cam_capture_button_released, KEY_CAMERA, KEY_EVENT_UP);
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;

                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_PREVIEW);
            }
            else
            {

                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_CAMERA_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            }
            mmi_camco_osd_draw_osd();
            break;
        }
        case MMI_CAMCO_EVT_CONFIRM_NO:
        {
            mmi_camco_cam_preview_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CHANGE_STORAGE:
        {
            mmi_camco_cam_preview_no_card_lsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_preview_failed_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_preview_failed_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {

        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_preview_failed_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_setting_menu_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_setting_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_cam_setting_menu_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_setting_menu_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}

#ifdef __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_add_frame_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_add_frame_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_cam_add_frame_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_add_frame_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}
#endif /* __MMI_CAMCO_FEATURE_ADD_FRAME_COLOR_IDX__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_countdown_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_countdown_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_countdown_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_save_done_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {

        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_save_done_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CAPTURED_IMGVIEWER:
        {
        #ifdef __MMI_PHOTOEDITOR__
            mmi_camco_cam_entry_photoeditor();
        #endif 

            break;
        }
        case MMI_CAMCO_EVT_CAPTURED_DEL:
        {
            mmi_camco_cam_delete_confirm();
            break;
        }
        case MMI_CAMCO_EVT_CAPTURED_FORWARD:
        {
            mmi_camco_cam_forward_menu();
            break;
        }

        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_save_done_storage_fail_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_save_done_storage_fail_evt_hdlr(
        mmi_cameco_evt_type_enum evt_type,
        mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {

        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_save_done_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_contshot_select_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_contshot_select_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_CAPTURE:
        {
            if (g_mmi_camco_cntx.is_camerakey_valid)
                mmi_camco_cam_capture_csk_button_released(KEY_EVENT_UP);
            break;
        }
    }

}

#ifdef __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_burstshot_select_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_burstshot_select_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = mmi_camco_osd_get_imgselect_hilite_idx();

    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            if (mmi_camco_cam_p->burstshot.is_saved[index])
            {
                mmi_camco_cam_burstshot_select_lsk_options_released(KEY_EVENT_UP);
            }
            else
            {
                mmi_camco_cam_burstshot_select_lsk_save_released(KEY_EVENT_UP);
            }
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_burstshot_select_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_IMG_SELECT_DEL:
        {
            mmi_camco_cam_delete_confirm();
            break;
        }
        case MMI_CAMCO_EVT_IMG_SELECT_FORWARD:
        {
            mmi_camco_cam_forward_menu();
            break;
        }
        default:
            ASSERT(0);
    }
}
#endif /* __MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_aebshot_select_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_aebshot_select_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = mmi_camco_osd_get_imgselect_hilite_idx();

    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            if (mmi_camco_cam_p->aebshot.is_saved[index])
            {
                mmi_camco_cam_aebshot_select_lsk_options_released(KEY_EVENT_UP);
            }
            else
            {
                mmi_camco_cam_aebshot_select_lsk_save_released(KEY_EVENT_UP);
            }
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_aebshot_select_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_IMG_SELECT_DEL:
        {
            mmi_camco_cam_delete_confirm();
            break;
        }
        case MMI_CAMCO_EVT_IMG_SELECT_FORWARD:
        {
            mmi_camco_cam_forward_menu();
            break;
        }

        default:
            ASSERT(0);
    }
}
#endif /* __MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__ */ 

#ifdef __SMILE_SHUTTER_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_smile_dect_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_smile_dect_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_smileshot_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CAPTURE:
        {
            if (g_mmi_camco_cntx.is_camerakey_valid)
                mmi_camco_cam_smiledetec_camera_key_pressed();
            break;
        }
        default:
            ASSERT(0);
    }
}
#endif /* __SMILE_SHUTTER_SUPPORT__ */ 

#ifdef __MMI_CAMCO_FEATURE_CAM_HDRSHOT__
void mmi_camco_cam_hdr_shot_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{

}

void mmi_camco_cam_hdr_done_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{

}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_forward_menu_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_forward_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OPTION_BACK:
        {
            mmi_camco_cam_forward_menu_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_OPTION_BT:
        case MMI_CAMCO_EVT_OPTION_EMAIL:
        case MMI_CAMCO_EVT_OPTION_MMS:
        {
            mmi_camco_cam_forward_menu_lsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_forward_menu_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_forward_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OPTION_BACK:
        {
            mmi_camco_rec_forward_menu_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_OPTION_BT:
        case MMI_CAMCO_EVT_OPTION_EMAIL:
        case MMI_CAMCO_EVT_OPTION_MMS:
        {
            mmi_camco_rec_forward_menu_lsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_restore_confirm_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_restore_confirm_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_CONFIRM_YES:
        {
            mmi_camco_restore_confirm_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CONFIRM_NO:
        {
            mmi_camco_restore_confirm_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}

#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_sub_preview_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_sub_preview_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            ;
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_cam_sub_preview_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}

#endif /* __MMI_CAMCO_CAM_SUBLCD_CAPTURE__ */ 


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_preview_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_rec_preview_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_preview_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_RECORD:
        {
            if (g_mmi_camco_cntx.is_camerakey_valid)
                mmi_camco_rec_preview_csk_pressed(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_SWITCH_APP:
        {
            if (g_mmi_camco_cntx.is_switching_app)
            {
                mmi_camco_exit_current_state();

                mmi_camco_rec_power_off();

                /* Clear background */
                mmi_camco_osd_set_bg_black();

                mmi_camco_rec_recover_framework_environment();

                mmi_camco_cam_entry_app_screen_internal();
            }
            break;
        }
        case MMI_CAMCO_EVT_SWITCH_SENSOR:
        {        
        #ifdef DUAL_CAMERA_SUPPORT
            if (g_mmi_camco_cntx.is_switchto_maincamera || g_mmi_camco_cntx.is_switchto_subcamera)
            {
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_EXIT);
                mmi_camco_osd_reset_environment();

                mmi_camco_exit_current_state();

                mmi_camco_rec_power_off();

                /* Clear background */
                mmi_camco_osd_set_bg_black();

            #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)
                gdi_bltdb_disable();
            #endif        

                if (g_mmi_camco_cntx.is_switchto_maincamera)
                {
                    mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_MAIN);
                    mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_MAIN);
                }
                else
                {
                    mmi_camco_setting_set_active_cam(MMI_CAMCO_SETTING_CAM_SUB);
                    mmi_camco_set_camera_id(MMI_CAMCO_SETTING_CAM_SUB);
                }

                mmi_camco_osd_set_default();
                mmi_camco_osd_init();
            #if defined(__GDI_BLT_WITH_DOUBLE_BUF_SUPPORT__)        
                gdi_bltdb_enable(GDI_BLTDB_ENABLE_ONLY_WHEN_HW_UPDATE);    
            #endif        
                mmi_camco_osd_setup_environment(g_mmi_camco_cntx.app_mem_buf_p);

                mmi_camco_setting_init();
                mmi_camco_setting_load_from_nvram();
                mmi_camco_setting_default_capability();

                /* Must call this to correct to the right scenemode setting */
                if (mmi_camco_setting_get_last_active_app() != mmi_camco_setting_get_active_app())
                {
                    mmi_camco_setting_switch_capability();
                    mmi_camco_setting_update_capability();
                    mmi_camco_update_facedetect_capability();
                }

                if (mmi_camco_rec_p->external_request.is_enable)
                {
                    if (mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_RECSIZE) > MMI_CAMCO_RECSIZE_CIF)
                    {
                    #ifdef __MMI_OP02_LEMEI__   
                        mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);      
                        mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_QCIF);
                        mmi_camco_setting_hide_capability(MMI_CAMCO_SETTING_RECSIZE);                      
                    #else             
                        if (mmi_camco_setting_get_itemlist_capability(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF) ==
                            MMI_CAMCO_SETTING_CAP_ENABLED)
                        {
                            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_CIF);
                            mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_CIF);
                        }
                        else
                        {
                            mmi_camco_setting_set_current_setting_value(MMI_CAMCO_SETTING_RECSIZE, MMI_CAMCO_RECSIZE_QCIF);
                            mmi_camco_update_vdosize(MMI_CAMCO_RECSIZE_QCIF);
                        }
                    #endif    
                    }
                }

                if (mmi_camco_is_from_external())
                {
                    mmi_camco_set_external_vdoswitchto_capability();
                    mmi_camco_setting_update_capability();
                    mmi_camco_update_facedetect_capability();
                }

                mmi_camco_need_restart_preview();
                mmi_camco_rec_power_on();
                if (g_mmi_camco_cntx.is_power_on)
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW);
                }
                else
                {
                    mmi_camco_enter_state(MMI_CAMCO_STATE_REC_PREVIEW_FAILED);
                }

                g_mmi_camco_cntx.is_switchto_maincamera = MMI_FALSE;
                g_mmi_camco_cntx.is_switchto_subcamera = MMI_FALSE;
            }
        #endif /* DUAL_CAMERA_SUPPORT */    
            break;
        }
        case MMI_CAMCO_EVT_ENTER_VDOPLER:
        {
            if (mmi_camco_rec_p->is_switchto_vdoply)
            {
                g_mmi_camco_cntx.app_state = MMI_CAMCO_STATE_REC_PREVIEW;

                mmi_camco_browse_recorded_file();
            }
            break;
        }
        case MMI_CAMCO_EVT_CONFIRM_YES:
        {
            /* mmi_camco_check_storage_capability(); */
            U16 drv_enum;

            drv_enum = srv_fmgr_drv_get_type((U8)SRV_FMGR_PUBLIC_DRV);
            mmi_camco_set_storage(mmi_camco_get_storage_letter(drv_enum));
            mmi_camco_update_storage(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_STORAGE));

            if (mmi_camco_rec_p->is_drive_available && mmi_camco_rec_p->is_space_enough)
            {

                #ifdef AF_SUPPORT
				if(mmi_camco_setting_get_setting_value(MMI_CAMCO_SETTING_AFMODE)!= MMI_CAMCO_AFMODE_OFF)
				{
					SetKeyHandler(mmi_camco_rec_preview_autofocus_button_pressed, KEY_CAMERA, KEY_HALF_PRESS_DOWN);
				}
                #endif

                SetKeyHandler(mmi_camco_rec_record_button_pressed, KEY_CAMERA, KEY_EVENT_DOWN);
                g_mmi_camco_cntx.is_camerakey_valid = MMI_TRUE;

                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_PREVIEW);
            }
            else
            {
                mmi_camco_osd_hint_set_mode(MMI_CAMCO_OSD_STOP_HINT_MODE_HINT_WITHOUT_BAR);
                mmi_camco_osd_enter_state(MMI_CAMCO_OSD_STATE_VIDEO_HINT);
                mmi_camco_osd_set_center_hint_str((CHAR*) GetString(mmi_camco_cam_p->err_str_id));
            }

            mmi_camco_osd_draw_osd();
            break;
        }
        case MMI_CAMCO_EVT_CONFIRM_NO:
        {
            mmi_camco_rec_preview_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CHANGE_STORAGE:
        {
            mmi_camco_rec_preview_no_card_lsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_setting_menu_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_setting_menu_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_rec_setting_menu_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_setting_menu_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_preview_failed_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_preview_failed_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_preview_failed_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_recording_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_recording_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_rec_recording_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_recording_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_pause_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_pause_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_OK:
        {
            mmi_camco_rec_pause_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_pause_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_save_done_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {

        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_save_done_rsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_RECORDED_DEL:
        {
            mmi_camco_rec_delete_confirm();
            break;
        }
        case MMI_CAMCO_EVT_RECORDED_FORWARD:
        {
            mmi_camco_rec_forward_menu();
            break;
        }
        case MMI_CAMCO_EVT_RECORDED_VDOPLYER:
        {
        #if defined(__MMI_VIDEO_PLAYER__) || defined(__MMI_MEDIA_PLAYER_VIDEO__)
            mmi_camco_rec_entry_playing();
        #endif 
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_save_done_storage_fail_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_save_done_storage_fail_evt_hdlr(
        mmi_cameco_evt_type_enum evt_type,
        mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {
        case MMI_CAMCO_EVT_CANCEL:
        {
            mmi_camco_rec_save_done_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_delete_confirm_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_delete_confirm_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_osd_get_captured_mode())
    {
    #if defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__)
        switch (evt_type)
        {

            case MMI_CAMCO_EVT_CONFIRM_YES:
            {
                mmi_camco_cam_multishot_delete_confirm_lsk_released(KEY_EVENT_UP);
                break;
            }
            case MMI_CAMCO_EVT_CONFIRM_NO:
            {
                mmi_camco_cam_delete_confirm_rsk_released(KEY_EVENT_UP);
                break;
            }
            default:
                ASSERT(0);
        }
    #endif /* defined(__MMI_CAMCO_FEATURE_CAM_BURSTSHOT_SELECT__) || defined(__MMI_CAMCO_FEATURE_CAM_AEBSHOT_SELECT__) */ 
    }
    else
    {
        switch (evt_type)
        {

            case MMI_CAMCO_EVT_CONFIRM_YES:
            {
                mmi_camco_cam_delete_confirm_lsk_released(KEY_EVENT_UP);
                break;
            }
            case MMI_CAMCO_EVT_CONFIRM_NO:
            {
                mmi_camco_cam_delete_confirm_rsk_released(KEY_EVENT_UP);
                break;
            }
            default:
                ASSERT(0);
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_delete_confirm_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_delete_confirm_evt_hdlr(mmi_cameco_evt_type_enum evt_type, mmi_camco_osd_evt_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt_type)
    {

        case MMI_CAMCO_EVT_CONFIRM_YES:
        {
            mmi_camco_rec_delete_confirm_lsk_released(KEY_EVENT_UP);
            break;
        }
        case MMI_CAMCO_EVT_CONFIRM_NO:
        {
            mmi_camco_rec_delete_confirm_rsk_released(KEY_EVENT_UP);
            break;
        }
        default:
            ASSERT(0);

    }

}

#endif /* __MMI_CAMCO_FTE__ */ 
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_delete_confirm_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_RET mmi_camco_common_proc(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static MMI_BOOL is_first_active = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_ID app_id =	GET_APP_ID(evt);

	switch (evt->evt_id)
	{
		case EVT_ID_APP_ENTER:
		{
			is_first_active = MMI_TRUE;
			break;
		}

		case EVT_ID_APP_TOP_ACTIVE:
		{
			if (is_first_active == MMI_TRUE)
			{
				//mmi_camcorder_launch_app();
				mmi_camco_app_post_launch_event_struct event;
				MMI_FRM_INIT_EVENT(&event, 0);
				event.app_id = app_id;
				MMI_FRM_POST_EVENT(&event, mmi_camcorder_launch_app, NULL);
			}
			is_first_active = MMI_FALSE;
			break;
		}

	}
	return MMI_RET_OK;

}
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_delete_confirm_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt_type        [IN]        
 *  param           [OUT]       
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_launch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	mmi_frm_app_launch(APP_CAMCO, 0, 0, mmi_camco_common_proc, NULL, MMI_FRM_APP_SKIP_SIZE_CHECK | MMI_FRM_APP_SKIP_RESVERVE_CHECK);

}

/*****************************************************************************
 * FUNCTION
 *  mmi_camco_check_and_display_popup
 * DESCRIPTION
 *  check if can launch camcorder.
 *  interface for CUI caller.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL [OUT] can launch camcorde or not
 *****************************************************************************/
MMI_BOOL mmi_camco_check_and_display_popup(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_get_ext_memory_usage
 * DESCRIPTION
 *  
 * PARAMETERS
 *  is_external     [IN]        
 *  cur_id          [IN]        
 * RETURNS
 *  MMI_BOOL [OUT] can launch camcorde or not
 *****************************************************************************/
U32 mmi_camco_get_ext_memory_usage(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 appmem_size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    appmem_size = MMI_CAMCO_OSD_LAYER_DB_BUF_SIZE;

#ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    appmem_size += MMI_CAMCO_SUBLCD_OSD_LAYER_DB_BUF_SIZE;
#endif 

    // OSD speed up buffer
    appmem_size += 128;
    appmem_size += (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);

#if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
    appmem_size += MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;
#endif

    return appmem_size;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_check_and_allocate_asm
 * DESCRIPTION
 *  check if ASM is avaiable.
 * PARAMETERS
 *  is_external     [IN]        
 *  cur_id          [IN]        
 * RETURNS
 *  MMI_BOOL [OUT] can launch camcorde or not
 *****************************************************************************/
MMI_BOOL mmi_camco_check_and_allocate_asm(MMI_BOOL is_external, mmi_id cur_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 appmem_size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!is_external)
    {
	    appmem_size = ((MMI_CAMCO_APP_MEM_SIZE) +( MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE )+ (((GDI_LCD_WIDTH*GDI_LCD_HEIGHT*GDI_MAINLCD_BIT_PER_PIXEL)>>3)+256));
    }
    else
    {
    #ifndef __MMI_CAMCO_LOW_COST__
    appmem_size = MMI_CAMCO_OSD_LAYER_DB_BUF_SIZE;
	#endif

    #ifdef __MMI_CAMCO_CAM_SUBLCD_CAPTURE__
    appmem_size += MMI_CAMCO_SUBLCD_OSD_LAYER_DB_BUF_SIZE;
    #endif 

    appmem_size += 128;
	
	#ifdef MMI_CAMCO_FEATURE_ROTATE_ON
	appmem_size += (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);
	#endif
	
    appmem_size += (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);

    }


    g_mmi_camco_cntx.app_mem_buf_p = mmi_frm_asm_alloc_nc_r(cur_id, appmem_size);
    g_mmi_camco_cntx.memory_group_id = cur_id;
    if (g_mmi_camco_cntx.app_mem_buf_p == NULL)
    {
        return MMI_FALSE;
    }
    else
    {
    #ifdef MMI_CAMCO_FEATURE_ROTATE_ON
        //mem for rotate source layer
        mmi_camco_osd_set_init_mem((void*)g_mmi_camco_cntx.app_mem_buf_p);
        g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p + (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);
    #endif

        g_mmi_camco_cntx.app_preview_mem_buf_p = g_mmi_camco_cntx.app_mem_buf_p;
        g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p + (UI_DEVICE_WIDTH * UI_DEVICE_HEIGHT * MMI_CAMCO_OSD_BYTE_PER_PIXEL + 32 + 32);
        
    #if defined(__MMI_CAMCO_MED_PANO_STITCH_SHARE_ASM__) 
        g_mmi_camco_cntx.app_med_mem_buf_p = g_mmi_camco_cntx.app_mem_buf_p;
        g_mmi_camco_cntx.app_mem_buf_p = (U8*)g_mmi_camco_cntx.app_mem_buf_p + MMI_CAMCO_MED_STITCH_EXT_MEM_SIZE;        
    #endif

        return MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_asm_is_allocated
 * DESCRIPTION
 *  check if ASM is allocated.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL [OUT] ASM is allocated or not
 *****************************************************************************/
MMI_BOOL mmi_camco_asm_is_allocated(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_mem_buf_p == NULL)
    {
        return MMI_FALSE;
    }
    else
    {
        return MMI_TRUE;
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_browse_recorded_file
 * DESCRIPTION
 *  select the greeting file
 * PARAMETERS
 *  drv_letter      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_browse_recorded_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILTER filter;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    srv_fmgr_types_filter_set_group(&filter, FMGR_GROUP_VIDEO);   
    if((mmi_camco_rec_p->all_videos_screen_id =  cui_folder_browser_create(APPLIB_MEM_AP_ID_CAMCO, (WCHAR *)mmi_camco_rec_p->storage_filepath_p, &filter, 0, 0, 0)) != GRP_ID_INVALID)
    {      
        cui_folder_browser_set_title(mmi_camco_rec_p->all_videos_screen_id, STR_ID_CAMCO_ALL_VIDEOS, GetRootTitleIcon(MENU_ID_CAMCORDER_APP));	
        cui_folder_browser_run(mmi_camco_rec_p->all_videos_screen_id);
    }


}

/* =================================================================================== */
/*                              CUI version camcorder APP                              */
/* =================================================================================== */


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_app_group_proc
 * DESCRIPTION
 *  the proc function for camcorder App.
 * PARAMETERS
 *  evt     [IN]        The event pass in
 * RETURNS
 *  mmi_ret [OUT] the result of event handling
 *****************************************************************************/
mmi_ret mmi_camco_app_group_proc(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {

        case EVT_ID_MEM_FREE_ASM:
        case CUI_CAMCO_EVENT_RESULT_FAILED:
        case CUI_CAMCO_EVENT_RESULT_SUCCESS:
            cui_camco_close(g_mmi_camco_app_id);
            mmi_frm_group_close(APPLIB_MEM_AP_ID_CAMCO);
            break;
            
        case EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT:
            cui_folder_browser_close(mmi_camco_rec_p->all_videos_screen_id);
            break;
    }

    if (evt->evt_id == EVT_ID_MEM_FREE_ASM)
        return MMI_MEM_FREED;
    else
        return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_launch
 * DESCRIPTION
 *  Camcorder App.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_camcorder_launch_app(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_camco_run_struct camera_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check if can launch or not */
    if (cui_camco_check_and_display_popup())
    {
        /* init param */
        cui_camco_struct_init(&camera_struct);

        /* create camcorder App screen group */
        /* attach proc mmi_camco_app_group_proc */
        mmi_frm_group_close(APPLIB_MEM_AP_ID_CAMCO);
        mmi_frm_group_create(((mmi_camco_app_post_launch_event_struct*) evt)->app_id, APPLIB_MEM_AP_ID_CAMCO, mmi_camco_app_group_proc, NULL);

        /* enter camcorder App screen group */
        mmi_frm_group_enter(APPLIB_MEM_AP_ID_CAMCO, MMI_FRM_NODE_NONE_FLAG);

        /* create camcorder CUI */
        g_mmi_camco_app_id = cui_camco_create(APPLIB_MEM_AP_ID_CAMCO);

        /* excute camcorder CUI */
        cui_camco_run(g_mmi_camco_app_id, &camera_struct);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_vdorec_group_proc
 * DESCRIPTION
 *  the proc function for camcorder App.
 * PARAMETERS
 *  evt     [IN]        The event pass in
 * RETURNS
 *  mmi_ret [OUT] the result of event handling
 *****************************************************************************/
mmi_ret mmi_camco_vdorec_group_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_MEM_FREE_ASM:
        case CUI_VDOREC_RECORD_EVENT_RESULT_SUCCESS:
        case CUI_VDOREC_RECORD_EVENT_RESULT_FAILED:
            cui_camco_close(g_mmi_camco_partial_app_id);
            mmi_frm_group_close(APPLIB_MEM_AP_ID_CAMCO);
            break;

    }

    if (evt->evt_id == EVT_ID_MEM_FREE_ASM)
        return MMI_MEM_FREED;
    else
        return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_vdorec_launch
 * DESCRIPTION
 *  Vdorec App.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_vdorec_launch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_vdorec_run_struct vdorec_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cui_vdorec_check_and_display_popup())
    {
        /* init param */
        cui_vdorec_struct_init(&vdorec_struct);

        vdorec_struct.is_partial = 1;

        /* create vdorec App screen group */
        /* attach proc mmi_camco_vdorec_group_proc */
        mmi_frm_group_close(APPLIB_MEM_AP_ID_CAMCO);
        mmi_frm_group_create(GRP_ID_ROOT, APPLIB_MEM_AP_ID_CAMCO, mmi_camco_vdorec_group_proc, NULL);

        /* enter vdorec App screen group */
        mmi_frm_group_enter(APPLIB_MEM_AP_ID_CAMCO, MMI_FRM_NODE_SMART_CLOSE_FLAG);

        /* create video recorder CUI */
        g_mmi_camco_partial_app_id = cui_vdorec_create(APPLIB_MEM_AP_ID_CAMCO);

        /* execute video recorder CUI */
        cui_vdorec_run(g_mmi_camco_partial_app_id, &vdorec_struct);
    }
}

/* =================================================================================== */
/*                                  camcorder CUI                                      */
/* =================================================================================== */


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_resume_from_cui
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_resume_from_cui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_mem_buf_p == NULL && !mmi_is_redrawing_bk_screens())
    {
        if (mmi_camco_check_and_allocate_asm(MMI_FALSE, SCR_GROUP_ID_CAMCO_INT_APP))
        {
            mmi_camco_entry_app_screen();
        }
    }
    else
    {
        mmi_camco_entry_app_screen();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_enter_from_cui
 * DESCRIPTION
 *  Camcorder CUI enter function.
 * PARAMETERS
 *  cur_gid     [IN]        The camcorder CUI id
 *  p_args      [IN]        The excute param for camcorder CUI
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_enter_from_cui(mmi_id cur_gid, p_cui_camera_run_struct p_args)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_check_and_allocate_asm(MMI_FALSE, cur_gid))
    {
        mmi_frm_group_enter(cur_gid, MMI_FRM_NODE_NONE_FLAG);
        mmi_camco_entry_app_screen();
    }
}
#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_notify_screen_lock_hdlr
 * DESCRIPTION
 *  Camcorder handle screen  lock function.
 * PARAMETERS
 *  evt     [IN]        The event for lock screen
 * RETURNS
 *  mmi_ret event handle result
 *****************************************************************************/
extern mmi_ret mmi_camco_notify_screen_lock_hdlr(mmi_event_struct *evt)
{
   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING:
			if(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_RECORDING ||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PAUSE ||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PREVIEW ||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_PREVIEW||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_AUTORAMA_SHOT||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SMILE_DECT||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_COUNTDOWN||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SETTING_MENU||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_SETTING_MENU||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_FOCUSING||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_FOCUSING||
				g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_CAM_SUB_PREVIEW)
            {
                mmi_scr_locker_pre_lock_evt_struct* lock_event = (mmi_scr_locker_pre_lock_evt_struct*)evt;

                if(lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_POWER_KEY)
                {
                    return MMI_RET_OK;
                }
                else if(lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_AUTO_LOCK)
                {
                    return MMI_RET_ERR;
                }
            }
        	  break;
       default:
       	    return MMI_RET_OK;
    }
    return MMI_RET_OK;
}
#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_camco_group_proc
 * DESCRIPTION
 *  Camcorder CUI proc function.
 * PARAMETERS
 *  evt     [IN]        The event for camcorder CUI
 * RETURNS
 *  mmi_ret event handle result
 *****************************************************************************/
mmi_ret mmi_camco_group_proc(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {

        case EVT_ID_GROUP_DEINIT:
            mmi_camco_del_scr_callback(0);
            break;

        case EVT_ID_MEM_CANCELED:
        {
            cui_camco_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camco_event_struct), SCR_GROUP_ID_CAMCO_INT_APP);
            evt.evt_id = CUI_CAMCO_EVENT_RESULT_FAILED;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_INT_APP, (mmi_group_event_struct*) & evt);
        }
            break;

        case EVT_ID_MEM_IS_ENOUGH:

            cui_camco_run(SCR_GROUP_ID_CAMCO_INT_APP, NULL);
            break;

        case EVT_ID_ALERT_QUIT:
        {
            cui_camco_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camco_event_struct), SCR_GROUP_ID_CAMCO_INT_APP);
            evt.evt_id = CUI_CAMCO_EVENT_RESULT_FAILED;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_INT_APP, (mmi_group_event_struct*) & evt);
        }
            break;

    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_ext_resume_from_cui
 * DESCRIPTION
 *  ext CUI resume function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_ext_resume_from_cui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_mem_buf_p == NULL && !mmi_is_redrawing_bk_screens())
    {
        if (mmi_camco_check_and_allocate_asm(MMI_TRUE, SCR_GROUP_ID_CAMCO_EXT_APP))
        {
            mmi_camco_entry_app_screen();
        }
    }
    else
    {
        mmi_camco_entry_app_screen();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_enter_from_cui
 * DESCRIPTION
 *  Camera CUI enter function.
 * PARAMETERS
 *  cur_gid     [IN]        The camera CUI id
 *  p_args      [IN]        The excute param for camcorder CUI
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_cam_enter_from_cui(mmi_id cur_gid, p_cui_camera_run_struct p_args)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVING && !mmi_camco_rec_p->is_save_result_back)
    {
        /* 
         * Because pseudo merge will spend a quite long time, 
         * we need to wait that med video finishes the saving.
         */
        mmi_popup_display_simple((WCHAR *) GetString(STR_ID_CAMCO_NOTIFY_CAMCO_TOO_BUSY), MMI_EVENT_WARNING, GRP_ID_ROOT, 0);
        return;
    }
    else if (mmi_camco_rec_p->is_saving_prev &&
             mmi_camco_rec_p->is_save_success && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
    {
        /* 
         * Because pseudo merge will spend a quite long time, 
         * we need to wait that med video finishes the saving.
         */
        mmi_popup_display_simple((WCHAR *) GetString(STR_ID_CAMCO_NOTIFY_CAMCO_TOO_BUSY), MMI_EVENT_WARNING, GRP_ID_ROOT, 0);
        return;
    }

    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT || g_mmi_camco_cntx.is_to_media_editor)
    {
        g_mmi_camco_cntx.is_to_media_editor = MMI_FALSE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
    }

    mmi_camco_cam_p->external_request.is_enable = MMI_TRUE;
    mmi_camco_cam_p->external_request.is_switch_app = MMI_FALSE;

    app = mmi_camco_setting_get_active_app();
    if (app == MMI_CAMCO_SETTING_APP_VIDEO)
    {
        mmi_camco_cam_p->external_request.is_switch_app = MMI_TRUE;
    }
    
    if(p_args->req_mode == MMI_CAMERA_EXTERNAL_MODE_LCD_RESOLUTION)
    {
        mmi_camco_cam_p->external_request.is_capsize_lcd_limit = MMI_TRUE;
    }

    mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_CAMERA);

    if (mmi_camco_check_and_allocate_asm(MMI_TRUE, cur_gid))
    {

        mmi_frm_group_enter(SCR_GROUP_ID_CAMCO_EXT_APP, MMI_FRM_NODE_NONE_FLAG);

        mmi_camco_entry_app_screen();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_cam_group_proc
 * DESCRIPTION
 *  Camera CUI proc function.
 * PARAMETERS
 *  evt     [IN]        The event for camcorder CUI
 * RETURNS
 *  mmi_ret event handle result
 *****************************************************************************/
mmi_ret mmi_camco_cam_group_proc(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {

        case EVT_ID_GROUP_DEINIT:
            mmi_camco_del_scr_callback(0);
            break;

        case EVT_ID_MEM_CANCELED:
        {
            cui_camera_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_CAMERA_EVENT_RESULT_FAILED;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }
            break;

        case EVT_ID_MEM_IS_ENOUGH:

            cui_camco_run(SCR_GROUP_ID_CAMCO_EXT_APP, NULL);
            break;

        case EVT_ID_ALERT_QUIT:
        {
            cui_camera_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_CAMERA_EVENT_RESULT_FAILED;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }

    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_enter_from_cui
 * DESCRIPTION
 *  Video recorder  CUI enter function.
 * PARAMETERS
 *  cur_gid     [IN]        The video recorder CUI id
 *  p_args      [IN]        The excute param for camcorder CUI
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_camco_rec_enter_from_cui(mmi_id cur_gid, p_cui_vdorec_run_struct p_args)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_camco_setting_app_enum app;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_camco_rec_p->is_saving_prev &&
        mmi_camco_rec_p->is_save_success && g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_EXIT)
    {
        /* 
         * Because pseudo merge will spend a quite long time, 
         * we need to wait that med video finishes the saving.
         */
        mmi_popup_display_simple((WCHAR *) GetString(STR_ID_CAMCO_NOTIFY_CAMCO_TOO_BUSY), MMI_EVENT_WARNING, GRP_ID_ROOT, 0);
        return;
    }
    else if (g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_INT_SAVING && !mmi_camco_rec_p->is_save_result_back)
    {
        /* 
         * Because pseudo merge will spend a quite long time, 
         * we need to wait that med video finishes the saving.
         */
        mmi_popup_display_simple((WCHAR *) GetString(STR_ID_CAMCO_NOTIFY_CAMCO_TOO_BUSY), MMI_EVENT_WARNING, GRP_ID_ROOT, 0);
        return;
    }

    if (g_mmi_camco_cntx.app_state != MMI_CAMCO_STATE_EXIT || g_mmi_camco_cntx.is_to_media_editor)
    {
        g_mmi_camco_cntx.is_to_media_editor = MMI_FALSE;
        mmi_camco_enter_state(MMI_CAMCO_STATE_EXIT);
    }

    /*
     * MMI_TRACE(
     * MMI_MEDIA_TRC_G2_APP,
     * MMI_TRC_CAMCO_REC_EXT_SIZE_TIME,
     * max_size,
     * max_time_sec);
     */

    if (p_args->is_partial)
    {
        g_mmi_camco_cntx.partial_app.is_only_recorder = MMI_TRUE;
    }
    else
    {

        mmi_camco_rec_p->external_request.is_enable = MMI_TRUE;
        mmi_camco_rec_p->external_request.is_use_ext_req_path = MMI_FALSE;
        mmi_camco_rec_p->external_request.req_size = p_args->max_file_size;
        mmi_camco_rec_p->external_request.is_switch_app = MMI_FALSE;

        /* video can be record so accurate, -5K for margin  */
        mmi_camco_rec_p->external_request.req_size -= 5;

        /* limited size 10k */
        MMI_ASSERT(mmi_camco_rec_p->external_request.req_size >= 10);

        if (p_args->file_path != NULL)
        {
            mmi_camco_rec_p->external_request.is_use_ext_req_path = MMI_TRUE;
            //mmi_fmgr_util_store_filepath((CHAR*) p_args->file_path, FMGR_PATH_ID_VIDEO);
            memcpy(mmi_camco_rec_p->external_request.ext_path, p_args->file_path, SRV_FMGR_PATH_BUFFER_SIZE);
        }

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMCO_REC_EXT_SIZE, mmi_camco_rec_p->external_request.req_size);
    }

    app = mmi_camco_setting_get_active_app();
    if (app == MMI_CAMCO_SETTING_APP_CAMERA)
    {
        if (p_args->is_partial)
        {
            g_mmi_camco_cntx.partial_app.is_switch_app = MMI_TRUE;
        }
        else
        {
            mmi_camco_rec_p->external_request.is_switch_app = MMI_TRUE;
        }

    }

    mmi_camco_setting_set_active_app(MMI_CAMCO_SETTING_APP_VIDEO);

    if (mmi_camco_check_and_allocate_asm(MMI_TRUE, cur_gid))
    {

        mmi_frm_group_enter(SCR_GROUP_ID_CAMCO_EXT_APP, MMI_FRM_NODE_NONE_FLAG);

        mmi_camco_entry_app_screen();
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_camco_rec_group_proc
 * DESCRIPTION
 *  Video recorder CUI proc function.
 * PARAMETERS
 *  evt     [IN]        The event for camcorder CUI
 * RETURNS
 *  mmi_ret event handle result
 *****************************************************************************/
mmi_ret mmi_camco_rec_group_proc(mmi_event_struct *evt)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {

        case EVT_ID_GROUP_DEINIT:
            mmi_camco_del_scr_callback(0);
            break;

        case EVT_ID_MEM_CANCELED:
        {
            cui_vdorec_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_vdorec_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_VDOREC_RECORD_EVENT_RESULT_FAILED;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }
            break;

        case EVT_ID_MEM_IS_ENOUGH:

            cui_camco_run(SCR_GROUP_ID_CAMCO_EXT_APP, NULL);
            break;

        case EVT_ID_ALERT_QUIT:
        {
            cui_vdorec_event_struct evt;

            MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_vdorec_event_struct), SCR_GROUP_ID_CAMCO_EXT_APP);
            evt.evt_id = CUI_VDOREC_RECORD_EVENT_RESULT_FAILED;
            mmi_frm_group_post_to_parent(SCR_GROUP_ID_CAMCO_EXT_APP, (mmi_group_event_struct*) & evt);
        }
    }

    return MMI_RET_OK;
}
#if defined(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )
/*****************************************************************************
 * FUNCTION
 *  mmi_camcorder_motion_tilt_hdlr
 * DESCRIPTION
 *  tilt motin handler
 * PARAMETERS
 *  dirsct  [IN]
 *  action  [IN]
 *  detail  [IN]
 *  user data [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_camco_motion_tilt_hdlr(srv_sensor_type_enum sensor_type, 
               void *sensor_data, void *user_data)
/*
(mdi_motion_angle_enum direction,
 mdi_motion_action_enum action,
  mdi_motion_tilt_detail_struct *detail,
  void *user_data)*/
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_sensor_motion_direct_struct* p_direct;
    srv_sensor_motion_direct_enum direct;
	U16 rotation = g_mmi_camco_cntx.rotate;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    p_direct = (srv_sensor_motion_direct_struct*)sensor_data;
    direct = p_direct->direct;

    switch (direct)
    {
        case SRV_SENSOR_MOTION_ANGLE_GX0:
            rotation = MDI_CAMERA_UI_ROTATE_270;
            break;
	    case SRV_SENSOR_MOTION_ANGLE_GY0:
            rotation = MDI_CAMERA_UI_ROTATE_180;;
            break;
        case SRV_SENSOR_MOTION_ANGLE_GX180:
			rotation = MDI_CAMERA_UI_ROTATE_90;
            break;
        case SRV_SENSOR_MOTION_ANGLE_GY180:
            rotation = MDI_CAMERA_UI_ROTATE_0;
            break;
        default:
            return;
			//break;
    }
	g_mmi_camco_cntx.rotate =  rotation;  
}
#endif /*(__CAMERA_MOTION_SENSOR_SUPPORT_BY_TAG__ ) || defined(__RECORDER_MOTION_SENSOR_SUPPORT_BY_TAG__ )*/
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
static void resz_cp_ESD_timeout_timer_hdlr(void)
{
	 if(resz_esd_check_flag)
	 {
		  resz_esd_check_flag = KAL_FALSE;
		  kal_set_timer(resz_cp_ESD_timeout_timer, (kal_timer_func_ptr)resz_cp_ESD_timeout_timer_hdlr,NULL, KAL_TICKS_3_SEC, 0);
	 }
	 else
	 {
		  kal_cancel_timer(resz_cp_ESD_timeout_timer);  
		  mmi_camco_app_reset_watchdog_ESD();
	 }
}

static void mmi_camco_app_reset_watchdog_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_cancel_timer(mmi_camco_app_reset_watchdog_callback);

	if(mmi_camco_setting_get_active_app() == MMI_CAMCO_SETTING_APP_CAMERA)
	{
		mdi_camera_preview_stop();
		mdi_camera_power_off();
		kal_sleep_task(100);
		
		mdi_camera_power_on(g_mmi_camco_cntx.memory_group_id);
		mmi_camco_cam_preview_start();
	}
	else
	{
		if(MMI_CAMCO_STATE_REC_RECORDING == g_mmi_camco_cntx.app_state || MMI_CAMCO_STATE_REC_PAUSE == g_mmi_camco_cntx.app_state)
		{
			gui_cancel_timer(mmi_camco_rec_record_timer_cyclic);
			mdi_video_rec_record_stop();
			if(g_mmi_camco_cntx.app_state == MMI_CAMCO_STATE_REC_PAUSE)
				mdi_video_rec_preview_stop();
			mdi_video_rec_power_off();
			g_mmi_camco_cntx.is_power_on = MMI_FALSE;
			g_mmi_camco_cntx.is_preview_start = MMI_FALSE;
			
			kal_sleep_task(100);
			
			mmi_camco_enter_rec_preview_state();
		}
		else
		{
			mdi_video_rec_preview_stop();
			mdi_video_rec_power_off();
			kal_sleep_task(100);
			
			mdi_video_rec_power_on(g_mmi_camco_cntx.memory_group_id);
			mmi_camco_rec_preview_start();
		}
	}
}

static void mmi_camco_app_reset_watchdog_ESD(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_cancel_timer(mmi_camco_app_reset_watchdog_callback);
	gui_start_timer(1, mmi_camco_app_reset_watchdog_callback);        
}
#endif
#endif /* __MMI_CAMCORDER__ */ 
