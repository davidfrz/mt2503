/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 * AnswerMachineSetting.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"

#ifdef __MMI_AUTO_ANSWER_MACHINE__
#include "mmi_trc.h"    /* debug info */
#include "CustDataRes.h"
#ifdef __MMI_USB_SUPPORT__
#include "USBDeviceGprot.h"
#include "USBSrvGProt.h"
#endif
#include "wgui_categories_popup.h"
#include "wgui_categories_util.h"
#include "Wgui_inline_edit.h"
#include "FileMgrSrvGProt.h"
#include "dcl.h"
#include "UcmGprot.h"   /* to use MakeCall */
#include "AnswerMachineType.h"
#include "AnswerMachineProt.h"
#include "MediaAppGprot.h"
#include "Conversions.h"
#include "PhbSrvGprot.h"
#include "PhbCuiGprot.h"
#include "gpiosrvgprot.h"
#ifdef __DRM_SUPPORT__
#include "Drm_gprot.h"
#endif 

#include "MenuCuiGprot.h"
#include "InlineCuiGprot.h"
#include "FileMgrCUIGProt.h"


#include "MMIDataType.h"
#include "fs_type.h"
#include "gui_data_types.h"
#include "UcmSrvGprot.h"
#include "ImeGprot.h"
#include "GlobalResDef.h"
#include "mmi_rp_app_autoam_def.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "gui_typedef.h"
#include "mmi_frm_scenario_gprot.h"
#include "AlertScreen.h"
#include "GlobalConstants.h"
#include "mmi_frm_scenario_gprot.h"
#include "nvram_common_defs.h"
#include "mmi_frm_nvram_gprot.h"
#include "string.h"
#include "AlertScreen.h"
#include "CommonScreensResDef.h"
#include "mmi_frm_events_gprot.h"
#include "mdi_datatype.h"
#include "mdi_audio.h"
#include "mmi_rp_file_type_def.h"
#include "drm_def.h"
#include "MediaPlayerGProt.h"
#include "wgui_touch_screen.h"
#include "wgui_categories_list.h"
#include "wgui_categories.h"
#include "custom_phb_config.h"
#include "app_mem.h"
#include "wgui_categories_text_viewer.h"
#include "mmi_frm_input_gprot.h"
#include "IdleAppDef.h"
#include "mmi_rp_app_autoam_def.h"
#include "ScrLockerGprot.h"
#include "SimCtrlSrvGprot.h"
#include "BootupSrvGprot.h"
#include "ModeSwitchSrvGprot.h"



#ifdef __MMI_SOUND_RECORDER__
extern void mmi_sndrec_entry_record_from_autoam(U16 *file_path, U32 size_limit, U32 time_limit,
                                                void (*callback_func) (BOOL result, U16 *filepath));
#endif /* __MMI_SOUND_RECORDER__ */ 

/*
 * Globle variable
 */
mmi_autoam_setting_struct g_autoam_setting;
mmi_autoam_message_struct g_autoam_message;
extern mmi_autoam_speech_struct g_autoam_speech;
static mmi_id g_file_brw_grp_id = 0;
/* for setting screen */

static U16 g_autoam_greeting_temp[MMI_AUTOAM_MAX_FULL_NAME_LEN];
static U16 g_autoam_greeting_display[MMI_AUTOAM_MAX_FULL_NAME_LEN];
static U16 g_autoam_record_greeting[MMI_AUTOAM_MAX_FULL_NAME_LEN];
static S32 g_select_storage = 0;
static S32 g_select_onoff = 0;
static S32 g_remote_onoff = 0;
static S32 g_temp_remote_onoff = 0;
static U8 g_greeting_default = MMI_AUTOAM_GREETING_DEFAULT;
static U8 g_remote_pwd_lenth = 0;
static S32 g_select_pickup = 0;
static S32 g_select_duration = 0;
static U16 g_remote_hotkey[2];
static U16 g_temp_hotkey[2];
static U16 g_remote_pwd[MMI_AUTOAM_REMOTE_PASSWD_LEN + 1];
static U16 g_temp_remote_pwd[MMI_AUTOAM_REMOTE_PASSWD_LEN + 1];

static U8 g_is_setting_changed = MMI_AUTOAM_OFF;

static U16 *g_autoam_detail_hdlr = NULL;

/* for file opration */
U8 g_autoam_msg_buf[MMI_AUTOAM_FILE_ONE_MSG_LEN];
static S16 g_autoam_voice_msg_index = 0;
static U8 g_autoam_total_message_num = 0;
static FS_HANDLE g_autoam_file_hdlr;
static mmi_id g_phb_cui_id;
static mmi_id delele_screen_id = 0;
/* for delete file, update message list */
U8 g_autoam_del_all_current_index;
MMI_BOOL g_autoam_del_all_flag;
static MMI_BOOL g_autoam_has_delete_flag;
extern U8 g_autoam_file_header[];
extern S32 g_autoam_last_error;
extern U16 g_autoam_in_call_path[];

/* for idle display */
U8 g_autoam_idle_display_flag = 0;
S32 g_autoam_idle_number_before_view = 0;
static U8 g_autoam_save_screen = 0;
U16 g_autoam_last_valid_name[MMI_AUTOAM_CALL_NAME_LEN];

/*
 * Const variable
 */

const UI_character_type mmi_autoam_passwd_allowed[] = L"*#0-9";
/* Macro to judge whether in call or not. */
#define IS_IN_CALL() (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) > 0)

#if defined(__MMI_FMGR_APP_STORAGE__)
static void mmi_autoam_settings_inline_set_storage(MMI_ID inline_id);
#endif

static const cui_inline_item_text_edit_struct remote_settings_autoam_passwd = 
{
    0,                                  /* string id */
    0,                                  /* default text string id */
    MMI_AUTOAM_REMOTE_PASSWD_LEN + 1,   /* string count */
    IMM_INPUT_TYPE_NUMERIC_PASSWORD,    /* input type */
    (S16) IMM_INPUT_TYPE_NUMERIC_PASSWORD,    /* input extended type */
    NULL                                /* required input mode */
};

static const cui_inline_item_text_edit_struct remote_settings_autoam_hotkey = 
{
    0,                              /* string id */
    0,                              /* default text string id */
    2,                              /* string count */
    IMM_INPUT_TYPE_KEYPAD_NUMERIC,    /* input type */
    IMM_INPUT_TYPE_PHONE_NUMBER,    /* input extended type */
    NULL                            /* required input mode */
};

static const U16 remote_settings_autoam_status_str[] = 
{
    STR_GLOBAL_OFF,
    STR_GLOBAL_ON
};

static const cui_inline_item_select_struct remote_settings_autoam_status = 
{
    sizeof(remote_settings_autoam_status_str) / sizeof(U16), 0, remote_settings_autoam_status_str
};

static const cui_inline_item_caption_struct remote_settings_autoam_inline_caption[] = 
{
    {STR_ID_AUTOAM_REMOTE_SATUS},
    {STR_ID_AUTOAM_REMOTE_HOT_KEY},
    {STR_GLOBAL_PASSWORD}

};

static const cui_inline_set_item_struct mmi_autoam_remote_setting_inline_screen_item[] = 
{

    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_STATE_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&remote_settings_autoam_inline_caption[0]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_STATE, CUI_INLINE_ITEM_TYPE_SELECT, 0,
     (void *)&remote_settings_autoam_status},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_KEY_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&remote_settings_autoam_inline_caption[1]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_KEY, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0,
     (void *)&remote_settings_autoam_hotkey},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_PASSWORD_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&remote_settings_autoam_inline_caption[2]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_PASSWORD, CUI_INLINE_ITEM_TYPE_TEXT_EDIT, 0,
     (void *)&remote_settings_autoam_passwd},

};

static cui_inline_item_softkey_struct mmi_autoam_remote_setting_inline_screen_softkey = 
{
    {
     {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0}, /* MMI_LEFT_SOFTKEY */
     {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0}, /* MMI_RIGHT_SOFTKEY */
     {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0}  /* MMI_CENTER_SOFTKEY */
     }
};

static const cui_inline_struct mmi_autoam_remote_setting_inline_data = 
{
    MMI_AUTOAM_NO_OF_REMOTE_SETTING,
    STR_ID_AUTOAM_REMOTE_SETTING,
    0,
    CUI_INLINE_SCREEN_DEFAULT_TEXT,
    &mmi_autoam_remote_setting_inline_screen_softkey,
    mmi_autoam_remote_setting_inline_screen_item
};

/*************************************** REMOTE_SETTING********************************************/
static const U16 settings_autoam_inline_select_duration_str[] = 
{
    STR_ID_AUTOAM_DURATION_THIRTY_SEC,
    STR_ID_AUTOAM_DURATION_ONE_MINUTE,
    STR_ID_AUTOAM_DURATION_THREE_MINUTE,
    STR_ID_AUTOAM_DURATION_FIVE_MINUTE,
    STR_ID_AUTOAM_DURATION_UN_LIMIT
};

static const cui_inline_item_select_struct settings_autoam_inline_select_duration = 
{
    sizeof(settings_autoam_inline_select_duration_str) / sizeof(U16), 0, settings_autoam_inline_select_duration_str
};

static const U16 settings_autoam_inline_select_pickup_str[] = 
{
    STR_ID_AUTOAM_PICKUP_THREE_SEC,
    STR_ID_AUTOAM_PICKUP_FIVE_SEC,
    STR_ID_AUTOAM_PICKUP_TEN_SEC,
    STR_ID_AUTOAM_PICKUP_THIRTY_SEC
};

static const cui_inline_item_select_struct settings_autoam_inline_select_pickup = 
{
    sizeof(settings_autoam_inline_select_pickup_str) / sizeof(U16), 0, settings_autoam_inline_select_pickup_str
};

static const U16 settings_autoam_inline_select_ans_switch_str[] = 
{
    STR_GLOBAL_OFF,
    STR_GLOBAL_ON
};

static const cui_inline_item_select_struct settings_autoam_inline_select_ans_switch = 
{
    sizeof(settings_autoam_inline_select_ans_switch_str) / sizeof(U16), 0, settings_autoam_inline_select_ans_switch_str
};

static const cui_inline_item_caption_struct settings_autoam_inline_caption[] = 
{
    STR_ID_AUTOAM_AUTO_ANSWER_SWITCH,
    STR_GLOBAL_STORAGE,
    STR_ID_AUTOAM_PICKUP,
    STR_ID_AUTOAM_DURATION,
    STR_ID_AUTOAM_GREETING_FILE,
    STR_ID_AUTOAM_REMOTE_ACCESS
};

static const cui_inline_set_item_struct mmi_autoam_entry_setting_inline_screen_item[] = 
{

    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STATE_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&settings_autoam_inline_caption[0]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STATE, CUI_INLINE_ITEM_TYPE_SELECT, 0,
     (void *)&settings_autoam_inline_select_ans_switch},
 #if defined(__MMI_FMGR_APP_STORAGE__)
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STORAGE_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&settings_autoam_inline_caption[1]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STORAGE, CUI_INLINE_ITEM_TYPE_SELECT, 0, NULL},
 #endif /* defined(__MMI_FMGR_APP_STORAGE__) */ 

    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_PICKUP_TIME_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&settings_autoam_inline_caption[2]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_PICKUP_TIME, CUI_INLINE_ITEM_TYPE_SELECT, 0,
     (void *)&settings_autoam_inline_select_pickup},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_DURATION_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&settings_autoam_inline_caption[3]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_DURATION, CUI_INLINE_ITEM_TYPE_SELECT, 0,
     (void *)&settings_autoam_inline_select_duration},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_GREETING_CAP, CUI_INLINE_ITEM_TYPE_CAPTION, 0,
     (void *)&settings_autoam_inline_caption[4]},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_GREETING, CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY, 0, NULL},
    {CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_REMOTE_ACCESS, (CUI_INLINE_ITEM_DISPLAY_NO_RESPONSE_NUMKEY|CUI_INLINE_ITEM_TYPE_DISPLAY_ONLY), 0, NULL},

};

static cui_inline_item_softkey_struct mmi_autoam_entry_setting_inline_screen_softkey = 
{
    {
     {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0}, /* MMI_LEFT_SOFTKEY */
     {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0}, /* MMI_RIGHT_SOFTKEY */
     {CUI_INLINE_SOFTKEY_DEFAULT_VALUE, 0}  /* MMI_CENTER_SOFTKEY */
     }
};

static const cui_inline_struct mmi_autoam_entry_setting_inline_screen = 
{
    MMI_AUTOAM_NO_OF_SETTING,
    STR_GLOBAL_SETTINGS,
    0,
    CUI_INLINE_SCREEN_DEFAULT_TEXT,
    &mmi_autoam_entry_setting_inline_screen_softkey,
    mmi_autoam_entry_setting_inline_screen_item
};


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_init_app
 * DESCRIPTION
 *  this function is used to initialize auto answer machine
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_init_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE fd = -1;
    U8 record_num;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_autoam_setting.rec_storage = 0;
    g_autoam_del_all_flag = MMI_FALSE;

    /* creat folder */
    fd = FS_Open((kal_uint16*) MMI_AUTOAM_SYSTEM_FOLDER, FS_OPEN_DIR | FS_READ_ONLY);
    if (fd >= FS_NO_ERROR)
    {
        /* path already exist */
        FS_Close(fd);
    }
    else
    {
        /* file not exist */
        fd = FS_CreateDir((kal_uint16*) MMI_AUTOAM_SYSTEM_FOLDER);
    }

    if (mmi_autoam_file_load_incall(&fd, &record_num))
    {
        if (record_num > 0)
        {
            g_autoam_idle_number_before_view = mmi_autoam_file_check_unread(fd, record_num);
        }
    }
    FS_Close(fd);

    /* init setting value */
    mmi_autoam_init_setting();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_init_statusicon
 * DESCRIPTION
 *  this function is used to initialize auto answer machine
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_init_statusicon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_update = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_autoam_idle_number_before_view > 0)
    {
        wgui_status_icon_bar_set_icon_display(STATUS_ICON_AUTOAM_UNREAD);
        is_update = MMI_TRUE;
    }
    if (MMI_AUTOAM_ON == g_autoam_setting.turn_on)
    {
        wgui_status_icon_bar_set_icon_display(STATUS_ICON_AUTOAM_ON);
        is_update = MMI_TRUE;
    }
    if (is_update)
    {
        wgui_status_icon_bar_update();
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_answer_update_statusicon
 * DESCRIPTION
 *  
 * PARAMETERS
 *  event       [IN]     
 *  
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_autoam_answer_update_statusicon(mmi_event_struct *event)
{
    mmi_autoam_init_statusicon(); 	
	return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_highlight_main
 * DESCRIPTION
 *  this function is the highlight hdlr of auto answer machine main menu item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_highlight_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ChangeLeftSoftkey(STR_GLOBAL_OK, 0);
    ChangeRightSoftkey(STR_GLOBAL_BACK, 0);
    SetLeftSoftkeyFunction(mmi_autoam_entry_main, KEY_EVENT_UP);
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetCenterSoftkeyFunction(mmi_autoam_entry_main, KEY_EVENT_UP);
	
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_entry_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt             [?]         
 *  index(?)        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_main_entry_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*) evt;
    mmi_id title_icon = GetRootTitleIcon(MENU_ID_AUTOAM_MAIN);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (menu_evt->evt_id)
    {
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {
            cui_menu_set_default_title_image(menu_evt->sender_id, get_image(title_icon));
            break;
        }
        case EVT_ID_CUI_MENU_ITEM_HILITE:
            /* mmi_cal_option_menu_cui_highlight_hdlr(menu_evt); */
            break;

        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
            switch (menu_evt->highlighted_menu_id)
            {
                case MENU_ID_AUTOAM_LEAVING_MESSAGE:
                    mmi_autoam_entry_message_list();
                    break;
                case MENU_ID_AUTOAM_SETTING:					
			mmi_autoam_prepare_setting_inline_data();
                    break;
                default:
                    break;
            }
            break;
        }

        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            cui_menu_close(menu_evt->sender_id);

            break;
        case EVT_ID_GROUP_DEINIT:
            mmi_frm_group_close(GRP_ID_AUTOAM_MAIN);

            break;

    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_main
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_id menu_gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Check if in USB mode before enter setting */
#if defined(__USB_IN_NORMAL_MODE__)
    if (srv_usb_is_in_mass_storage_mode())
    {
        mmi_usb_app_unavailable_popup(0);
        return;
    }
#endif /* defined(__USB_IN_NORMAL_MODE__) */ 

    mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTOAM_MAIN, mmi_autoam_main_entry_proc, (void*)NULL);

    mmi_frm_group_enter(GRP_ID_AUTOAM_MAIN, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    menu_gid = cui_menu_create(
                GRP_ID_AUTOAM_MAIN,
                CUI_MENU_SRC_TYPE_RESOURCE,
                CUI_MENU_TYPE_APPSUB,
                MENU_ID_AUTOAM_MAIN,
                MMI_TRUE,
                NULL);
    cui_menu_run(menu_gid);
    /* create auto answer machine used folder */
    mmi_autoam_create_dest_folder();
}

#define MMI_AUTO_ANSWER_MAHCINE_MAIN_SETTING


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_init_setting
 * DESCRIPTION
 *  this function is to read nvram and prepare the setting data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_init_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 pError;
    S8 buffer[NVRAM_EF_ANSWER_MACHINE_SETTING_SIZE];
    mmi_autoam_setting_struct *data_ptr;
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadRecord(NVRAM_EF_ANSWER_MACHINE_SETTING_LID, 1, buffer, NVRAM_EF_ANSWER_MACHINE_SETTING_SIZE, &pError);
    data_ptr = (mmi_autoam_setting_struct*) buffer;
    /* if the setting data has not been used, let it be the default value */
    g_autoam_setting.turn_on = (data_ptr->turn_on == 0x01) ? MMI_AUTOAM_ON : MMI_AUTOAM_OFF;
    g_autoam_setting.remote_allow = (data_ptr->remote_allow == 0x01) ? MMI_AUTOAM_ON : MMI_AUTOAM_OFF;
    g_autoam_setting.greeting_default = (data_ptr->greeting_default < MMI_AUTOAM_GREETING_TOTAL) ?
        data_ptr->greeting_default : MMI_AUTOAM_GREETING_DEFAULT;
    g_autoam_setting.drv_letter = data_ptr->drv_letter;
    g_autoam_setting.pickup = data_ptr->pickup;
    g_autoam_setting.duration = data_ptr->duration;
    /* check pickup time and duration */
    mmi_autoam_check_pick_up_setting(&g_autoam_setting.pickup);
    mmi_autoam_check_duration_setting(&g_autoam_setting.duration);
    /* Restore to default drive if hardware not exists */
    if (!srv_fmgr_drv_is_valid((U8) (g_autoam_setting.drv_letter)))
    {
        g_autoam_setting.drv_letter = (U8) SRV_FMGR_PUBLIC_DRV;
    }
    /* Greeting File path */
    if (g_autoam_setting.greeting_default == MMI_AUTOAM_GREETING_DEFAULT)
    {
        memset((S8*) g_autoam_setting.greeting_filename, 0, MMI_AUTOAM_MAX_FULL_NAME_LEN);
    }
    else if (mmi_ucs2strlen((S8*) data_ptr->greeting_filename) > 0)
    {
        mmi_ucs2cpy((S8*) g_autoam_setting.greeting_filename, (S8*) data_ptr->greeting_filename);
    }
    else
    {
        memset((S8*) g_autoam_setting.greeting_filename, 0, MMI_AUTOAM_MAX_FULL_NAME_LEN);
    }
    /* read the hot key */
    g_autoam_setting.hot_key = (data_ptr->hot_key == 0xff) ? MMI_AUTOAM_DEFAULT_REMOTE_HOTKEY : data_ptr->hot_key;
    /* read the password */
    if ((data_ptr->password[0] == 0xff) || (data_ptr->pwlength > MMI_AUTOAM_REMOTE_PASSWD_LEN))
    {
        g_autoam_setting.pwlength = MMI_AUTOAM_REMOTE_PASSWD_LEN;
        for (i = 0; i < MMI_AUTOAM_REMOTE_PASSWD_LEN; i++)
        {
            g_autoam_setting.password[i] = 49 + i;  /* default pwd as 1,2,3,4 */
        }
    }
    else
    {
        g_autoam_setting.pwlength = data_ptr->pwlength;
        if (g_autoam_setting.pwlength > 0)
        {
            if (g_autoam_setting.pwlength > MMI_AUTOAM_REMOTE_PASSWD_LEN)
            {
                ASSERT(0);
            }
            memcpy(g_autoam_setting.password, data_ptr->password, g_autoam_setting.pwlength);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_prepare_setting_inline_data
 * DESCRIPTION
 *  this function is to prepare setting inline data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_prepare_setting_inline_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set inline editer select item index */
    g_select_pickup = mmi_autoam_get_pick_up_index(g_autoam_setting.pickup);
    g_select_duration = mmi_autoam_get_duration_index(g_autoam_setting.duration);
    g_select_onoff = (S32) g_autoam_setting.turn_on;
    g_remote_onoff = (S32) g_autoam_setting.remote_allow;
    g_greeting_default = g_autoam_setting.greeting_default;
    if (g_greeting_default == MMI_AUTOAM_GREETING_DEFAULT)
    {
        mmi_ucs2cpy((S8*) g_autoam_greeting_temp, (S8*) GetString(STR_GLOBAL_DEFAULT));
    }
    else if (mmi_ucs2strlen((S8*) g_autoam_setting.greeting_filename) > 0)
    {
        mmi_ucs2cpy((S8*) g_autoam_greeting_temp, (S8*) g_autoam_setting.greeting_filename);
    }
    else
    {
        mmi_ucs2cpy((S8*) g_autoam_greeting_temp, (S8*) GetString(STR_GLOBAL_DEFAULT));
    }

    if (0 == g_autoam_setting.hot_key)
    {
        memset((S8*) g_remote_hotkey, 0, 2);
    }
    else
    {
        mmi_asc_n_to_ucs2((S8*) g_remote_hotkey, (S8*) & g_autoam_setting.hot_key, 1);
    }

    g_remote_pwd_lenth = g_autoam_setting.pwlength;
    if (g_remote_pwd_lenth > 0)
    {
        mmi_asc_n_to_ucs2((S8*) g_remote_pwd, (S8*) g_autoam_setting.password, g_remote_pwd_lenth);
    }
    else
    {
        memset((S8*) g_remote_pwd, 0, sizeof(g_remote_pwd));
    }

    /* entry auto answer machine main setting screen */
    mmi_autoam_entry_setting();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_setting_get_string
 * DESCRIPTION
 *  Get string display data before enter screen.
 *  (Need to get every time because language may change)
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_main_setting_get_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
  

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Inline Editor Selection Item */
    if (MMI_AUTOAM_GREETING_DEFAULT == g_greeting_default)
    {
        mmi_ucs2cpy((S8*) g_autoam_greeting_temp, (S8*) GetString(STR_GLOBAL_DEFAULT));
        mmi_ucs2cpy((S8*) g_autoam_greeting_display, (S8*) g_autoam_greeting_temp);
    }
    else
    {
            mmi_ucs2cpy((S8*) g_autoam_greeting_display, (S8*) g_autoam_greeting_temp);
  
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_setting_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_entry_setting_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {

        case EVT_ID_GROUP_FIRST_ENTRY:
            {
                g_is_setting_changed = MMI_AUTOAM_OFF;	

            }        
         break;
	case  EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:		
            mmi_autoam_main_setting_get_string();    
        break;
        case EVT_ID_CUI_INLINE_SUBMIT:
            {
                mmi_autoam_main_setting_save_confirm();
            }        
        break;
        case EVT_ID_CUI_INLINE_SET_KEY:
        {
            if(g_is_setting_changed)
		    {
		       set_wgui_inline_list_menu_changed();
		    }
        }		
		break;
        case EVT_ID_CUI_INLINE_ABORT:
        {
            cui_event_inline_abort_struct *inline_evt = (cui_event_inline_abort_struct*) evt;
            cui_inline_close(inline_evt->sender_id);
            break;
        }
        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            cui_event_inline_notify_struct *inline_evt = (cui_event_inline_notify_struct*) evt;
            S32 item = inline_evt->item_id - CUI_INLINE_ITEM_ID_BASE;
            switch (inline_evt->event_type)
            {
            case CUI_INLINE_NOTIFY_HIGHLIGHT_ITEM:
                {

                    if (item == MMI_AUTOAM_SETTING_GREETING)
                    {
                        ChangeLeftSoftkey(STR_GLOBAL_SELECT, 0);             
                        ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
                        SetLeftSoftkeyFunction(mmi_autoam_entry_choose_greeting, KEY_EVENT_UP);             
                        SetCenterSoftkeyFunction(mmi_autoam_entry_choose_greeting, KEY_EVENT_UP);
                    }
                    else if (item == MMI_AUTOAM_SETTING_REMOTE_ACCESS)
                    {
                        ChangeLeftSoftkey(STR_GLOBAL_EDIT, 0); 
                        ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
                        SetLeftSoftkeyFunction(mmi_autoam_entry_edit_remote_setting, KEY_EVENT_UP);                    
                        SetCenterSoftkeyFunction(mmi_autoam_entry_edit_remote_setting, KEY_EVENT_UP);
                    }
                    break;
                }
                case CUI_INLINE_NOTIFY_SELECT_FOCUS_CHANGED:
                {

                    switch (item)
                    {

                        case MMI_AUTOAM_SETTING_STATE:
                        {
                            g_select_onoff = inline_evt->param;
                        }
                            break;
                    #if defined(__MMI_FMGR_APP_STORAGE__)
                        case MMI_AUTOAM_SETTING_STORAGE:
                        {
                            g_select_storage = inline_evt->param;

                        }
                            break;
                    #endif /* defined(__MMI_FMGR_APP_STORAGE__) */ 

                        case MMI_AUTOAM_SETTING_PICKUP_TIME:
                        {
                            g_select_pickup = inline_evt->param;
                        }
                            break;

                        case MMI_AUTOAM_SETTING_DURATION:
                        {
                            g_select_duration = inline_evt->param;
                        }
                            break;

                        default:
                            break;
                    }
                }
                default:
                    break;
            }
            break;
        }

    }

    return MMI_RET_OK;
}

#if defined(__MMI_FMGR_APP_STORAGE__)
/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_settings_inline_set_storage
 * DESCRIPTION
 *  
 * PARAMETERS
 *  inline_id       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_autoam_settings_inline_set_storage(MMI_ID inline_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 total_drv_num;
    SRV_FMGR_DRVLIST_HANDLE drv_list;
    S32 i;
    U8 drv, driveletter;
    U8 *storage_str_p[SRV_FMGR_DRV_TOTAL];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ALL);
    total_drv_num = (U8) srv_fmgr_drivelist_count(drv_list);
    for (i = 0; i < total_drv_num; i++)
    {
        drv = srv_fmgr_drivelist_get_drv_letter(drv_list, i);
        storage_str_p[i] = (U8*) get_string(srv_fmgr_drv_get_string(drv));
        driveletter = srv_fmgr_drivelist_get_drv_letter(drv_list, i);
        if(driveletter == g_autoam_setting.drv_letter)
        {
            g_select_storage = i;
        }
    }
    
    srv_fmgr_drivelist_destroy(drv_list);

    if (total_drv_num > 1)
    {
        cui_inline_set_item_select(
            inline_id,
            CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STORAGE,
            total_drv_num,
            (U8 **) storage_str_p,
            g_select_storage);
    }
    else
    {
        cui_inline_delete_item(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STORAGE_CAP);
        cui_inline_delete_item(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STORAGE);
    }

}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_setting
 * DESCRIPTION
 *  entry function of auto answer machine main setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    MMI_ID_TYPE inline_icon_list[MMI_AUTOAM_NO_OF_SETTING] = {IMG_GLOBAL_L1, 0,
        IMG_GLOBAL_L2, 0,
        IMG_GLOBAL_L3, 0,
        IMG_GLOBAL_L4, 0,
    #if defined(__MMI_FMGR_APP_STORAGE__)
        IMG_GLOBAL_L5, 0,
    #endif 
        IMG_GLOBAL_L6
    };

    MMI_ID inline_id = GRP_ID_INVALID;
    MMI_BOOL 	is_back = mmi_frm_is_in_backward_scenario();
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* cui inline struct define */

    mmi_frm_group_create(GRP_ID_AUTOAM_MAIN, GRP_ID_AUTOAM_SETTINGS, mmi_autoam_entry_setting_proc, (void*)NULL);
    mmi_frm_group_enter(GRP_ID_AUTOAM_SETTINGS, MMI_FRM_NODE_SMART_CLOSE_FLAG);

	

    inline_id = cui_inline_create(GRP_ID_AUTOAM_SETTINGS, &mmi_autoam_entry_setting_inline_screen);

    cui_inline_set_title(inline_id, STR_GLOBAL_SETTINGS, GetRootTitleIcon(MENU_ID_AUTOAM_MAIN));

    cui_inline_set_value(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_STATE, (void*)g_select_onoff);
#if defined(__MMI_FMGR_APP_STORAGE__)
    mmi_autoam_settings_inline_set_storage(inline_id);
#endif 
    cui_inline_set_value(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_PICKUP_TIME, (void*)g_select_pickup);
    cui_inline_set_value(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_DURATION, (void*)g_select_duration);
    cui_inline_set_value(
        inline_id,
        CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_GREETING,
        (void*)g_autoam_greeting_display);
    cui_inline_set_value(
        inline_id,
        CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_REMOTE_ACCESS,
        (void*)GetString(STR_ID_AUTOAM_REMOTE_ACCESS));
	
	cui_inline_set_softkey_icon(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_GREETING, MMI_CENTER_SOFTKEY, IMG_GLOBAL_COMMON_CSK);
	cui_inline_set_softkey_icon(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_SETTING_REMOTE_ACCESS, MMI_CENTER_SOFTKEY, IMG_GLOBAL_COMMON_CSK);
   
    cui_inline_set_icon_list(inline_id, (U16*) inline_icon_list);

    cui_inline_run(inline_id);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_setting_save_confirm_cb
 * DESCRIPTION
 *  Save setting confirmation
 * PARAMETERS
 *  evt     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_autoam_main_setting_save_confirm_cb(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 driveletter = 0;
    S32 drv_list = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_1:
            case MMI_ALERT_CNFM_2:
            case MMI_ALERT_CNFM_3:
                /* handle softkey event here */
                break;
            case MMI_ALERT_CNFM_OK:
                /* handle softkey event here */
                break;
            case MMI_ALERT_CNFM_YES:
                drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ALL);
                driveletter = srv_fmgr_drivelist_get_drv_letter(drv_list, g_select_storage);
                srv_fmgr_drivelist_destroy(drv_list);                 
                if (FS_GetDevStatus(driveletter, FS_MOUNT_STATE_ENUM) < FS_NO_ERROR)
                {
                    mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_ID_AUTOAM_NO_CARD)), MMI_EVENT_FAILURE, NULL);
                    return MMI_RET_OK;
                }                
                mmi_autoam_main_setting_pre_save();
                mmi_frm_group_close(GRP_ID_AUTOAM_SETTINGS);
                break;
            case MMI_ALERT_CNFM_NO:
                mmi_autoam_main_setting_abort();
                break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_setting_save_confirm
 * DESCRIPTION
 *  Save setting confirmation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_main_setting_save_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;

    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.f_enter_history = MMI_TRUE;
    arg.callback = (mmi_proc_func) mmi_autoam_main_setting_save_confirm_cb;
    mmi_confirm_display((WCHAR*) (get_string(STR_GLOBAL_SAVE_ASK)), MMI_EVENT_QUERY, &arg);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_setting_pre_save
 * DESCRIPTION
 *  Check setting valid
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_main_setting_pre_save(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    U16 str_id = 0;
    mdi_result result = MDI_AUDIO_SUCCESS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (MMI_AUTOAM_GREETING_DEFAULT != g_greeting_default)
    {
        result = mdi_audio_snd_check_file_format(g_autoam_greeting_temp);
    }

    if (MDI_AUDIO_SUCCESS != result)
    {
        if (result == MDI_AUDIO_OPEN_FILE_FAIL)
        {
            str_id = STR_ID_AUTOAM_OPEN_FILE_FAIL;
        }
        else if (result == MDI_AUDIO_BAD_FORMAT)
        {
            str_id = STR_ID_AUTOAM_INVALID_FILE;
        }
        else if (result == MDI_AUDIO_DRM_PROHIBIT)  /* this is useful for time exhausted */
        {
            str_id = STR_GLOBAL_DRM_PROHIBITED;
        }
        else
        {
            str_id = STR_ID_AUTOAM_INVALID_FILE;
        }
        mmi_popup_display((WCHAR*) ((UI_string_type) GetString(str_id)), MMI_EVENT_FAILURE, NULL);
    }
    else
    {
        mmi_autoam_main_setting_save_and_set();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_setting_save_and_set
 * DESCRIPTION
 *  Save setting data to NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_main_setting_save_and_set(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/  
    S8 buffer[NVRAM_EF_ANSWER_MACHINE_SETTING_SIZE];
    S16 pError;
    mmi_autoam_setting_struct *data_ptr;
    S32 drv_list;
    S32 driveletter;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    data_ptr = (mmi_autoam_setting_struct*) buffer;

    g_autoam_setting.turn_on = g_select_onoff;
    /* Get other settings */
    g_autoam_setting.remote_allow = g_remote_onoff;
    g_autoam_setting.greeting_default = g_greeting_default;
    /* get the current drive letter */
    drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ALL);
    driveletter = srv_fmgr_drivelist_get_drv_letter(drv_list, g_select_storage);
    srv_fmgr_drivelist_destroy(drv_list);   
    g_autoam_setting.drv_letter = driveletter;
    /* get the pick up time and save */
    mmi_autoam_get_write_nvram_pick_up(g_select_pickup, &g_autoam_setting.pickup);
    /* get the duration time and save */
    mmi_autoam_get_write_nvram_duration(g_select_duration, &g_autoam_setting.duration);
    /* Get file name */
    if (g_greeting_default != MMI_AUTOAM_GREETING_DEFAULT)
    {
        mmi_ucs2cpy((S8*) g_autoam_setting.greeting_filename, (S8*) g_autoam_greeting_temp);
    }
    /* remote setting */
    if (mmi_ucs2strlen((S8*) g_remote_hotkey) < 1)
    {
        g_autoam_setting.hot_key = 0;
    }
    else
    {
        mmi_ucs2_n_to_asc((S8*) & g_autoam_setting.hot_key, (S8*) g_remote_hotkey, ENCODING_LENGTH);
    }

    ASSERT((g_remote_pwd_lenth <= MMI_AUTOAM_REMOTE_PASSWD_LEN));
    g_autoam_setting.pwlength = g_remote_pwd_lenth;
    if (g_autoam_setting.pwlength > 0)
    {
        mmi_ucs2_n_to_asc((S8*) g_autoam_setting.password, (S8*) g_remote_pwd, g_remote_pwd_lenth * ENCODING_LENGTH);
    }
    memset(buffer, 0, NVRAM_EF_ANSWER_MACHINE_SETTING_SIZE);
    memcpy(data_ptr, (mmi_autoam_setting_struct*) & g_autoam_setting, sizeof(mmi_autoam_setting_struct));

    WriteRecord(NVRAM_EF_ANSWER_MACHINE_SETTING_LID, (U16) 1, buffer, NVRAM_EF_ANSWER_MACHINE_SETTING_SIZE, &pError);

    /* update status icon */
    if (MMI_AUTOAM_ON == g_autoam_setting.turn_on)
    {
        wgui_status_icon_bar_set_icon_display(STATUS_ICON_AUTOAM_ON);
    }
    else
    {
        wgui_status_icon_bar_reset_icon_display(STATUS_ICON_AUTOAM_ON);
    }
    wgui_status_icon_bar_update();

    mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_GLOBAL_SAVED)), MMI_EVENT_SUCCESS, NULL);
    mmi_frm_scrn_close(GRP_ID_AUTOAM_GREETING_CHOOSE, SCR_ID_AUTOAM_GREETING_CHOOSE);   
    mmi_frm_scrn_close(GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE, SCR_ID_AUTOAM_GREETING_CHOOSE_STORAGE);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_main_setting_abort
 * DESCRIPTION
 *  Abort setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_main_setting_abort(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_group_close(GRP_ID_AUTOAM_SETTINGS);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_write_nvram_pick_up
 * DESCRIPTION
 *  get the pick up time by index
 * PARAMETERS
 *  index       [IN]        
 *  pickup      [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_get_write_nvram_pick_up(S32 index, U8 *pickup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (index)
    {
        case MMI_AUTOAM_PICKUP_THREE_SEC:
            *pickup = 3;
            break;
        case MMI_AUTOAM_PICKUP_FIVE_SEC:
            *pickup = 5;
            break;
        case MMI_AUTOAM_PICKUP_TEN_SEC:
            *pickup = 10;
            break;
        case MMI_AUTOAM_PICKUP_THIRTY_SEC:
            *pickup = 30;
            break;
        default:
            ASSERT(0);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_write_nvram_duration
 * DESCRIPTION
 *  get the duration time by index
 * PARAMETERS
 *  index           [IN]        
 *  duraiton        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_get_write_nvram_duration(S32 index, U16 *duraiton)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (index)
    {
        case MMI_AUTOAM_DURATION_THIRTY_SEC:
            *duraiton = 30;
            break;
        case MMI_AUTOAM_DURATION_ONE_MINUTE:
            *duraiton = 60;
            break;
        case MMI_AUTOAM_DURATION_THREE_MINUTE:
            *duraiton = 180;
            break;
        case MMI_AUTOAM_DURATION_FIVE_MINUTE:
            *duraiton = 300;
            break;
        case MMI_AUTOAM_DURATION_UNLIMIT:
            *duraiton = 0;
            break;
        default:
            ASSERT(0);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_check_pick_up_setting
 * DESCRIPTION
 *  check if pickup time is pre-defined, if not, modify the pickup time.
 * PARAMETERS
 *  pickup      [IN/OUT]        
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_autoam_check_pick_up_setting(U8 *pickup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (*pickup == 3 || *pickup == 5 || *pickup == 10 || *pickup == 30 || *pickup == 60)
    {
        return MMI_TRUE;
    }
    else
    {
        *pickup = 10;
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_check_duration_setting
 * DESCRIPTION
 *  check if duration time is pre-defined, if not, modify the duration time.
 * PARAMETERS
 *  duration        [IN/OUT]        
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_autoam_check_duration_setting(U16 *duration)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (*duration == 0 || *duration == 30 || *duration == 60 || *duration == 180 || *duration == 300)
    {
        return MMI_TRUE;
    }
    else
    {
        *duration = 60;
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_pick_up_index
 * DESCRIPTION
 *  get pickup time index in inline editer
 * PARAMETERS
 *  pickup      [IN]        
 * RETURNS
 *  S32
 *****************************************************************************/
S32 mmi_autoam_get_pick_up_index(U8 pickup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pickup_index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (pickup)
    {
        case 3:
            pickup_index = MMI_AUTOAM_PICKUP_THREE_SEC;
            break;
        case 5:
            pickup_index = MMI_AUTOAM_PICKUP_FIVE_SEC;
            break;
        case 10:
            pickup_index = MMI_AUTOAM_PICKUP_TEN_SEC;
            break;
        case 30:
            pickup_index = MMI_AUTOAM_PICKUP_THIRTY_SEC;
            break;
        default:
            ASSERT(0);
            break;
    }

    return pickup_index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_duration_index
 * DESCRIPTION
 *  get duration index in inline editer
 * PARAMETERS
 *  duration        [IN]        
 * RETURNS
 *  S32
 *****************************************************************************/
S32 mmi_autoam_get_duration_index(U16 duration)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 duration_index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (duration)
    {
        case 30:
            duration_index = MMI_AUTOAM_DURATION_THIRTY_SEC;
            break;
        case 60:
            duration_index = MMI_AUTOAM_DURATION_ONE_MINUTE;
            break;
        case 180:
            duration_index = MMI_AUTOAM_DURATION_THREE_MINUTE;
            break;
        case 300:
            duration_index = MMI_AUTOAM_DURATION_FIVE_MINUTE;
            break;
        case 0:
            duration_index = MMI_AUTOAM_DURATION_UNLIMIT;
            break;
        default:
            ASSERT(0);
            break;
    }
    return duration_index;
}

#define MMI_AUTO_ANSWER_MACHINE_CHOOSE_GREETING

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_choose_greeting_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt             [?]         
 *  index(?)        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_entry_choose_greeting_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*) evt;
     mmi_id title_icon = GetRootTitleIcon(MENU_ID_AUTOAM_MAIN);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (menu_evt->evt_id)
    {
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {
            cui_menu_set_default_title_image(menu_evt->sender_id, get_image(title_icon));
            break;
        }

        case EVT_ID_CUI_MENU_ITEM_SELECT:
        {
            switch (menu_evt->highlighted_menu_id)
            {
                case MENU_ID_AUTOAM_GREETTING_FILE_CHOOSE_DEFAULT:
                    mmi_autoam_choose_greeting_default();
                    break;
                case MENU_ID_AUTOAM_GREETTING_FILE_CHOOSE_FROM_FILE:
                    mmi_autoam_entry_select_storage();
                    break;
                default:
                    break;
            }
            break;
        }

        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            cui_menu_close(menu_evt->sender_id);

            break;
        case EVT_ID_GROUP_DEINIT:
            mmi_frm_group_close(GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE);

            break;

    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_choose_greeting
 * DESCRIPTION
 *  this function is to entry choose greeting file screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_choose_greeting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_id menu_gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_group_create(
        GRP_ID_AUTOAM_SETTINGS,
        GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE,
        mmi_autoam_entry_choose_greeting_proc,
        (void*)NULL);

    mmi_frm_group_enter(GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    menu_gid = cui_menu_create(
                GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE,
                CUI_MENU_SRC_TYPE_RESOURCE,
                CUI_MENU_TYPE_APPSUB,
                MENU_ID_AUTOAM_GREETTING_FILE_CHOOSE,
                MMI_TRUE,
                NULL);
    cui_menu_run(menu_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_choose_greeting_default
 * DESCRIPTION
 *  choose default greeting file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_choose_greeting_default(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set setting change flag */
    if (g_greeting_default != MMI_AUTOAM_GREETING_DEFAULT)
    {
        g_is_setting_changed = MMI_AUTOAM_ON;
    }

    /* set values */
    g_greeting_default = MMI_AUTOAM_GREETING_DEFAULT;
    mmi_ucs2cpy((S8*) g_autoam_greeting_temp, (S8*) GetString(STR_GLOBAL_DEFAULT));

    /* go back to setting main screen */
    mmi_frm_group_close(GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE);

}

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_browse_greeting_file_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt         [IN]        Event
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_browse_greeting_file_proc(mmi_event_struct *evt)
{


    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*)evt;
    cui_folder_browser_on_menu_event_struct *option_menu_evt = (cui_folder_browser_on_menu_event_struct *)menu_evt;
     cui_storage_selector_result_event_struct *param = 
        (cui_storage_selector_result_event_struct *)evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    switch (evt->evt_id)
    {
   
    
	case EVT_ID_GROUP_GOBACK:		
	case EVT_ID_GROUP_DEINIT:
		mmi_frm_group_close(GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE);
	break;
        
    case EVT_ID_GROUP_FOCUSED:
        break;
     case EVT_ID_CUI_STORAGE_SELECTOR_RESULT:
	{
        if(param->result > 0)
        {
	    mmi_autoam_browse_greeting_file((cui_storage_selector_result_event_struct*)evt);
        }
        cui_storage_selector_close(param->sender_id);
	    break;
	}        
    case EVT_ID_CUI_FOLDER_BROWSER_ON_ENTRY:
		
        break;
    
    case EVT_ID_CUI_FOLDER_BROWSER_ON_EXIT:
        break;
    case EVT_ID_CUI_FOLDER_BROWSER_ON_QUIT:
        cui_folder_browser_close(mmi_frm_group_get_active_id());
        mmi_frm_group_close(GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE);
        break;

    case EVT_ID_CUI_FOLDER_BROWSER_ON_EMPTY:
       mmi_autoam_record_greeting_file();
        break;

    case EVT_ID_CUI_FOLDER_BROWSER_ON_MENU:
        {
         

            switch(option_menu_evt->menuitem_id)
            {
			case MENU_ID_AUTOAM_GREETTING_FILE_OPTION_PLAY:
			mmi_autoam_choose_play_greeting();
			return MMI_RET_DONT_CARE;

			case MENU_ID_AUTOAM_GREETTING_FILE_OPTION_SELECT:
			mmi_autoam_choose_greeting_file_done();
			mmi_frm_group_close(GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE);		
			return MMI_RET_DONT_CARE;
			case MENU_ID_AUTOAM_GREETTING_FILE_OPTION_RECORD:
			mmi_autoam_record_greeting_file();			
			return MMI_RET_DONT_CARE;
			
                default:
                    break;
            }
           
            return MMI_RET_OK;
        }
        


    default:
        break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_select_storage
 * DESCRIPTION
 *  select the storage screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_select_storage(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	mmi_id storage_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Check if in USB mode before enter setting */
#if defined(__USB_IN_NORMAL_MODE__)
    if (srv_usb_is_in_mass_storage_mode())
    {
        mmi_usb_app_unavailable_popup(0);
        return;
    }
#endif /* defined(__USB_IN_NORMAL_MODE__) */ 

    if (!mmi_frm_is_in_backward_scenario())
    {
        g_autoam_setting.rec_storage = 0;
    }
   // EntryNewScreen(SCR_ID_AUTOAM_GREETING_CHOOSE_STORAGE, NULL, mmi_autoam_entry_select_storage, NULL);

   mmi_frm_group_create(GRP_ID_AUTOAM_GREETTING_FILE_CHOOSE, GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE , mmi_autoam_browse_greeting_file_proc, NULL);
   mmi_frm_group_enter(GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE, MMI_FRM_NODE_SMART_CLOSE_FLAG);
   storage_id =  cui_storage_selector_create(GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE,  g_autoam_setting.rec_storage, 0);
   cui_storage_selector_run(storage_id);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_browse_greeting_file
 * DESCRIPTION
 *  select the greeting file
 * PARAMETERS
 *  drv_letter      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_browse_greeting_file(cui_storage_selector_result_event_struct * eve)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_character_type path[MMI_AUTOAM_MAX_PATH_LEN];
    FMGR_FILTER filter;
    MMI_BOOL result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_autoam_util_get_greeting_path((UI_string_type) path, (U8) eve->result);
    g_autoam_setting.rec_storage = eve->result;
    result = mmi_autoam_check_dest_folder((PU16) path);

    if (result == MMI_FALSE)
    {
        return;
    }
   
    FMGR_FILTER_INIT(&filter);
    FMGR_FILTER_SET(&filter, FMGR_TYPE_WAV);
   
   g_file_brw_grp_id = cui_folder_browser_create(GRP_ID_AUTOAM_GREETING_CHOOSE_STORAGE,
                    (WCHAR *)path,
                    &filter,
                    0,
                    MENU_ID_AUTOAM_GREETTING_FILE_OPTION, 
                    MENU_ID_AUTOAM_GREETTING_EMPRY_FOLDER_OPTION);

    if (g_file_brw_grp_id != GRP_ID_INVALID)
    {
      
        cui_folder_browser_set_empty_lsk(g_file_brw_grp_id, STR_ID_AUTOAM_RECORD, 0); 
        cui_folder_browser_run(g_file_brw_grp_id);
    }
		 


}

#define MMI_AUTO_ANSWER_MACHINE_GREETING_OPTION
/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_choose_play_greeting
 * DESCRIPTION
 *  entry single player and play the greeting file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_choose_play_greeting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    srv_fmgr_fileinfo_struct file_info;
    U16 greeting_temp[MMI_AUTOAM_MAX_FULL_NAME_LEN];

#ifdef __DRM_SUPPORT__
    MMI_BOOL is_permitted = MMI_FALSE;
    FS_HANDLE fd = -1;
#endif /* __DRM_SUPPORT__ */ 
    S32 index = 0;
    WCHAR buffer[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];
    mmi_id grp_id = g_file_brw_grp_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
		
	index = cui_folder_browser_get_highlight_index(grp_id);
	cui_folder_browser_get_filepath(grp_id,index,&file_info,buffer,sizeof(buffer));
	srv_fmgr_path_get_filename_ptr((WCHAR *)buffer); 
	if (!buffer)
	{
		ASSERT(0);
	}

 
    mmi_ucs2cpy((S8*) greeting_temp, (S8*) buffer);

    /* check DRM */
#ifdef __DRM_SUPPORT__
    fd = DRM_open_file((U16*) greeting_temp, FS_READ_ONLY, DRM_PERMISSION_NONE);
    if (fd >= FS_NO_ERROR)
    {
        if (DRM_get_object_method(fd, NULL) == DRM_METHOD_NONE)
        {
            is_permitted = MMI_TRUE;
        }
        DRM_close_file(fd);
    }
    else if (fd <= -1)  /* file open error, but not DRM related problem */
    {
        is_permitted = MMI_TRUE;
    }
    if (!is_permitted)
    {
        mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_GLOBAL_DRM_PROHIBITED)), MMI_EVENT_FAILURE, NULL);        
        return;
    }
#endif /* __DRM_SUPPORT__ */ 

    mmi_media_app_play_audio((U16*) greeting_temp, NULL, GetRootTitleIcon(MENU_ID_AUTOAM_MAIN));
  
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_choose_greeting_file_done
 * DESCRIPTION
 *  select greeting file done
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_choose_greeting_file_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  
    U16 str_id = 0;
    mdi_result result;
    srv_fmgr_fileinfo_struct file_info;
    S32 index = 0;
    WCHAR buffer[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) *ENCODING_LENGTH];
    mmi_id grp_id = g_file_brw_grp_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    	index = cui_folder_browser_get_highlight_index(grp_id);
	cui_folder_browser_get_filepath(grp_id,index,&file_info,buffer,sizeof(buffer));
	srv_fmgr_path_get_filename_ptr((WCHAR *)buffer); 
	if (!buffer)
	{
		ASSERT(0);
	}

     /* Check file format */
    result = mdi_audio_snd_check_file_format((void *)buffer);
    if (result != MDI_AUDIO_SUCCESS)
    {
        if (result == MDI_AUDIO_OPEN_FILE_FAIL)
        {
            str_id = STR_ID_AUTOAM_OPEN_FILE_FAIL;
        }
        else if (result == MDI_AUDIO_BAD_FORMAT)
        {
            str_id = STR_ID_AUTOAM_INVALID_FILE;
        }
        else if (result == MDI_AUDIO_DRM_PROHIBIT)  /* this is useful for time exhausted */
        {
            str_id = STR_GLOBAL_DRM_PROHIBITED;
        }
        else
        {
            str_id = STR_ID_AUTOAM_INVALID_FILE;
        }
        mmi_popup_display((WCHAR*) ((UI_string_type) GetString(str_id)), MMI_EVENT_FAILURE, NULL);
    }
    else
    {
        /* Set Values */
        if (MMI_AUTOAM_GREETING_DEFAULT == g_greeting_default)
        {
            /* change from on to off, set change flag */
            g_is_setting_changed = MMI_AUTOAM_ON;
        }
        else if (0 != mmi_ucs2cmp((S8*) g_autoam_greeting_temp, (S8*) buffer))
        {
            /* only greeting file name changed */
            g_is_setting_changed = MMI_AUTOAM_ON;
        }
        mmi_ucs2cpy((S8*) g_autoam_greeting_display, (S8*) buffer);
        mmi_ucs2cpy((S8*) g_autoam_greeting_temp, (S8*) buffer);
        g_greeting_default = MMI_AUTOAM_GREETING_NORMAL;
      

        /* go back to setting main screen */
	mmi_frm_group_close(SCR_ID_AUTOAM_SETTING);	        
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_record_greeting_file
 * DESCRIPTION
 *  record new greeting file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_record_greeting_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_autoam_get_new_file((U16*) g_autoam_record_greeting);
    mmi_sndrec_entry_record_from_autoam((U16*) g_autoam_record_greeting, 0, 0, NULL);
}

#define MMI_AUTO_ANSWER_MACHINE_UTIL


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_check_dest_folder
 * DESCRIPTION
 *  check if the record fold exist or not
 * PARAMETERS
 *  file_path           [IN]        
 *  drv_letter(?)       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_autoam_check_dest_folder(PU16 file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    file_handle = FS_Open(file_path, FS_OPEN_DIR | FS_READ_ONLY);
    if (file_handle < 0)
    {
        /* result = FS_CreateDir(file_path); */
        result = srv_fmgr_fs_create_folder((WCHAR*) ((S8*) file_path));
        if (result < 0)
        {
            mmi_popup_display(
                (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(result))),
                (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(result),
                NULL);
            return MMI_FALSE;
        }
    }
    else
    {
        FS_Close(file_handle);
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_create_dest_folder
 * DESCRIPTION
 *  create auto answer machine used folder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_create_dest_folder(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle;   
    kal_int32 i;
    U8 drv_num;
    U16 path[MMI_AUTOAM_MAX_PATH_LEN];
    U16 path_greeting[MMI_AUTOAM_MAX_PATH_LEN];
    U16 path_message[MMI_AUTOAM_MAX_PATH_LEN];
    SRV_FMGR_DRVLIST_HANDLE drvlist;
 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ALL);
   drv_num = srv_fmgr_drivelist_count(drvlist);

    for (i = 0; i < drv_num; i++)
    {

        kal_wsprintf((kal_wchar*) path, "%c:\\%w", srv_fmgr_drivelist_get_drv_letter(drvlist, i)
			, MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE);
        file_handle = FS_Open(path, FS_OPEN_DIR | FS_READ_ONLY);

        if (file_handle < 0)
        {
            FS_CreateDir(path);
        }
        else
        {
            FS_Close(file_handle);
        }
        /* create greeting folder */
        mmi_ucs2cpy((S8*) path_greeting, (const S8*)path);
        mmi_ucs2cat((S8*) path_greeting, (const S8*)MMI_AUTOAM_DEFAULT_FOLDER_GREETING);
        file_handle = FS_Open(path_greeting, FS_OPEN_DIR | FS_READ_ONLY);

        if (file_handle < 0)
        {
            FS_CreateDir(path_greeting);
        }
        else
        {
            FS_Close(file_handle);
        }
        /* create message folder */
        mmi_ucs2cpy((S8*) path_message, (const S8*)path);
        mmi_ucs2cat((S8*) path_message, (const S8*)MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE);
        file_handle = FS_Open(path_message, FS_OPEN_DIR | FS_READ_ONLY);

        if (file_handle < 0)
        {
            FS_CreateDir(path_message);
        }
        else
        {
            FS_Close(file_handle);
        }
    }
    srv_fmgr_drivelist_destroy(drvlist);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_util_get_greeting_path
 * DESCRIPTION
 *  Get storage disc and folder
 * PARAMETERS
 *  path            [IN]        
 *  drv_letter      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_util_get_greeting_path(UI_string_type path, U8 drv_letter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_wsprintf(
        (kal_wchar*) path,
        "%c:\\%w%w",
        drv_letter,
        MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
        MMI_AUTOAM_DEFAULT_FOLDER_GREETING);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_new_file
 * DESCRIPTION
 *  create new file name when record
 * PARAMETERS
 *  fullname        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_get_new_file(U16 *fullname)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    RTC_CTRL_GET_TIME_T   rtc_time;
    DCL_HANDLE rtc_handler = 0;
    int i, j;
    U16 filename[SRV_FMGR_PATH_MAX_LEN];
    U16 filepath[SRV_FMGR_PATH_MAX_LEN];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    rtc_handler = DclRTC_Open(DCL_RTC,FLAGS_NONE); 
    DclRTC_Control(rtc_handler, RTC_CMD_GET_TIME, (DCL_CTRL_DATA_T *)& rtc_time);
    DclRTC_Close(rtc_handler);
    kal_wsprintf(
        (kal_wchar*) filename,
        "%02d%02d%02d%02d00",
        rtc_time.u1Mon,
        rtc_time.u1Day,
        rtc_time.u1Hour,
        rtc_time.u1Min);

    mmi_autoam_util_get_greeting_path((UI_string_type) filepath, (U8) g_autoam_setting.rec_storage);
    kal_wsprintf(
        (kal_wchar*) fullname,
        "%w%w",
        filepath,   /* Must call get full path before use */
        (const kal_wchar*)filename);

    mmi_ucs2ncat((S8*) fullname, (S8*) L".wav", MMI_AUTOAM_MAX_FILE_NAME_LEN);

    for (i = j = 0; mmi_autoam_check_file_exist(fullname); i++)
    {
        /* this check prevent from infinite loop if 00~99 are all used */
        if (i == 100)
        {
            j++;
            kal_wsprintf(
                (kal_wchar*) filename,
                "%02d%02d%02d%02d%d00",
								rtc_time.u1Mon,
								rtc_time.u1Day,
								rtc_time.u1Hour,
								rtc_time.u1Min,
                j);
            i = -1;
        }
        else
        {
            mmi_autoam_increase_file_name(fullname);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_check_file_exist
 * DESCRIPTION
 *  check the file exist or not
 * PARAMETERS
 *  filename        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_autoam_check_file_exist(UI_string_type filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE fd;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fd = FS_Open(filename, FS_READ_ONLY);
    if (fd >= 0)
    {
        FS_Close(fd);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_increase_file_name
 * DESCRIPTION
 *  increase the file name if it is a duplicate one
 * PARAMETERS
 *  filename        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_increase_file_name(UI_string_type filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_string_type p;
    U16 fileCount = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p = filename + mmi_ucs2strlen((const S8*)filename); /* UCS2Strlen((const S8*)filename); */
    while (p > filename)
    {
        if (*p == L'.')
        {
            fileCount = (*(p - 2) - '0') * 10 + (*(p - 1) - '0');
            fileCount++;
            *(p - 1) = fileCount % 10 + '0';
            *(p - 2) = fileCount / 10 + '0';
            break;
        }
        p--;
    }
}

#define MMI_AUTOAM_REMOTE_SETTING


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_edit_remote_setting_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt             [?]         
 *  index(?)        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_entry_edit_remote_setting_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {

        case EVT_ID_CUI_INLINE_NOTIFY:
        {
            cui_event_inline_notify_struct *inline_evt = (cui_event_inline_notify_struct*) evt;

            switch (inline_evt->event_type)
            {

                case CUI_INLINE_NOTIFY_SELECT_FOCUS_CHANGED:
                {
                    S32 index = inline_evt->param;

                    g_temp_remote_onoff = index;
                    break;
                }
                default:
                    break;
            }
            break;
        }

        case EVT_ID_CUI_INLINE_SUBMIT:
        {
            cui_event_inline_common_struct *inline_evt = (cui_event_inline_common_struct*) evt;

            cui_inline_get_value(
                inline_evt->sender_id,
                CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_KEY,
                g_temp_hotkey);
            cui_inline_get_value(
                inline_evt->sender_id,
                CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_PASSWORD,
                g_temp_remote_pwd);

            mmi_autoam_remote_setting_done();
        }
        break;
        case EVT_ID_CUI_INLINE_ABORT:
            {
                cui_event_inline_common_struct *inline_evt = (cui_event_inline_common_struct*) evt;
                cui_inline_close(inline_evt->sender_id);
                //mmi_frm_group_close(GRP_ID_AUTOAM_EDIT_REMOTE_SETTING);
            }            
            break;

        default:
            break;

    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_edit_remote_setting
 * DESCRIPTION
 *  entry edit remote setting screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_edit_remote_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    MMI_ID_TYPE item_icons[] = 
    {
        IMG_GLOBAL_L1,
        0,
        IMG_GLOBAL_L2,
        0,
        IMG_GLOBAL_L3,
        0
    };

    MMI_ID inline_id = GRP_ID_INVALID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_is_in_backward_scenario() == MMI_FALSE)
    {
        g_temp_hotkey[0] = g_remote_hotkey[0];
        g_temp_hotkey[1] = g_remote_hotkey[1];
        g_temp_remote_onoff = g_remote_onoff;
        mmi_ucs2ncpy((S8*) g_temp_remote_pwd, (S8*) g_remote_pwd, g_remote_pwd_lenth);
    }

    mmi_frm_group_create(
        GRP_ID_AUTOAM_SETTINGS,
        GRP_ID_AUTOAM_EDIT_REMOTE_SETTING,
        mmi_autoam_entry_edit_remote_setting_proc,
        (void*)NULL);

    mmi_frm_group_enter(GRP_ID_AUTOAM_EDIT_REMOTE_SETTING, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    inline_id = cui_inline_create(GRP_ID_AUTOAM_EDIT_REMOTE_SETTING, &mmi_autoam_remote_setting_inline_data);

    cui_inline_set_title(inline_id, STR_ID_AUTOAM_REMOTE_SETTING, GetRootTitleIcon(MENU_ID_AUTOAM_MAIN));

    cui_inline_set_value(
        inline_id,
        CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_STATE,
        (void*)g_temp_remote_onoff);
    cui_inline_set_value(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_KEY, (void*)g_temp_hotkey);
    cui_inline_set_value(
        inline_id,
        CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_PASSWORD,
        (void*)g_temp_remote_pwd);

	cui_inline_set_softkey_text(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_KEY, MMI_LEFT_SOFTKEY, STR_GLOBAL_OK);
	cui_inline_set_softkey_icon(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_KEY, MMI_CENTER_SOFTKEY, IMG_GLOBAL_COMMON_CSK);
	cui_inline_set_softkey_text(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_PASSWORD, MMI_LEFT_SOFTKEY, STR_GLOBAL_OK);
	cui_inline_set_softkey_icon(inline_id, CUI_INLINE_ITEM_ID_BASE + MMI_AUTOAM_REMOTE_SETTING_PASSWORD, MMI_CENTER_SOFTKEY, IMG_GLOBAL_COMMON_CSK);
       cui_inline_set_icon_list(inline_id, (U16*) item_icons);
       cui_inline_run(inline_id);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_remote_setting_done
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_remote_setting_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_AUTOAM_ON == g_temp_remote_onoff)
    {
        if (mmi_ucs2strlen((S8*) g_temp_hotkey) < 1)
        {
            mmi_popup_display(
                (WCHAR*) ((UI_string_type) GetString(STR_ID_AUTOAM_HOTKEY_ERROR)),
                MMI_EVENT_ERROR,
                NULL);
        }
        else if (mmi_ucs2strlen((S8*) g_temp_remote_pwd) < MMI_AUTOAM_REMOTE_PASSWD_LEN)
        {
            mmi_popup_display(
                (WCHAR*) ((UI_string_type) GetString(STR_ID_AUTOAM_PASSWD_ERROR)),
                MMI_EVENT_ERROR,
                NULL);
        }
        else
        {
            g_remote_pwd_lenth = MMI_AUTOAM_REMOTE_PASSWD_LEN;
            g_is_setting_changed = MMI_AUTOAM_ON;
            g_remote_hotkey[0] = g_temp_hotkey[0];
            g_remote_hotkey[1] = g_temp_hotkey[1];
            g_remote_onoff = g_temp_remote_onoff;
            mmi_ucs2ncpy((S8*) g_remote_pwd, (S8*) g_temp_remote_pwd, g_remote_pwd_lenth);
            mmi_frm_group_close(GRP_ID_AUTOAM_EDIT_REMOTE_SETTING);

        }
    }
    else
    {
        g_remote_hotkey[0] = g_temp_hotkey[0];
        g_remote_hotkey[1] = g_temp_hotkey[1];
        g_remote_onoff = g_temp_remote_onoff;
        mmi_ucs2ncpy((S8*) g_remote_pwd, (S8*) g_temp_remote_pwd, g_remote_pwd_lenth);
        g_remote_pwd_lenth = mmi_ucs2strlen((S8*) g_remote_pwd);
        g_is_setting_changed = MMI_AUTOAM_ON;
        mmi_frm_group_close(GRP_ID_AUTOAM_EDIT_REMOTE_SETTING);

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_remote_custom_function
 * DESCRIPTION
 *  set highlight in inline edit
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_remote_custom_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    mmi_imm_set_characters(MMI_TRUE, mmi_autoam_passwd_allowed);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_prepare_voice_msg_data
 * DESCRIPTION
 *  Check whether voice message valid
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_autoam_prepare_voice_msg_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* prepare data */
    ASSERT(g_autoam_voice_msg_index >= 0);
    fs_ret = mmi_autoam_file_load_single_msg(g_autoam_file_hdlr, g_autoam_file_header[g_autoam_voice_msg_index]);
    if (fs_ret < FS_NO_ERROR)
    {
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(fs_ret))),
            (mmi_event_notify_enum) srv_fmgr_fs_error_get_popup_type(fs_ret),
            NULL);
        return MMI_FALSE;
    }
    return MMI_TRUE;
}

#ifdef __MMI_FTE_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_msg_cmd_hdlr
 * DESCRIPTION
 *  Handle tap command for voice messages
 * PARAMETERS
 *  tap_type        [IN]        Message index
 *  index           [IN]        Message index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_voice_msg_cmd_hdlr(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (tap_type == ENUM_TAP_ON_NONHIGHLIGHTED_ITEM)
    {
        /* only change highlight.  do nothing in tap callback function */
        return;
    }

    if (!mmi_autoam_prepare_voice_msg_data())
    {
        return;
    }
    mmi_autoam_play_voice_message();
}
#endif /* __MMI_FTE_SUPPORT__ */ 

#define MMI_AUTO_ANSWER_MACHINE_ENTRY_MESSAGE_LIST


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_list_scrn_leave_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  info        [?]     
 * RETURNS
 *  
 *****************************************************************************/
static mmi_ret mmi_autoam_entry_message_list_scrn_leave_proc(mmi_event_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_autoam_file_hdlr)
    {
      FS_Close(g_autoam_file_hdlr);
      g_autoam_file_hdlr = 0;	
    
    }    
    return MMI_RET_OK;

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_pre_check_message_list
 * DESCRIPTION
 *  Validates the files are present on file system
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_pre_check_message_list(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    S32 msg_idx = 0;
    FS_HANDLE fs_hdle= FS_NO_ERROR;	
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while( msg_idx < g_autoam_total_message_num)
    {
        if (mmi_autoam_file_load_single_msg(g_autoam_file_hdlr, g_autoam_file_header[msg_idx]) < FS_NO_ERROR)
        {
            return;
        }
        else
        {
            /* Full file name with path*/
            kal_wsprintf((kal_wchar*) g_autoam_in_call_path,  "%c:\\%w%w%w%w",
            g_autoam_message.drv_letter,
            MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
            MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE,
            g_autoam_message.filename,
            L".wav");

            fs_hdle = FS_Open(g_autoam_in_call_path, FS_READ_ONLY );
            
            if(fs_hdle < FS_NO_ERROR)
            {
                g_autoam_voice_msg_index = msg_idx;
                mmi_autoam_file_delete_single_update();
            }
            else
            {	               
                 FS_Close(fs_hdle);
                 msg_idx++;
            }

        }
      
    }       

}

#if defined(__MMI_BASIC_UI_STYLE__)
static S32 mmi_autoam_message_multi_list_item(S32 start_index, gui_iconlist_menu_item *menu_data, S32 item_count);
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_list
 * DESCRIPTION
 *  entry main message list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_message_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    S32 highlighted_item;
    #if defined(__MMI_BASIC_UI_STYLE__)
    S32	cat_err = 0;
    #endif
    MMI_BOOL is_back = mmi_frm_is_in_backward_scenario();
    mmi_id parent_grp_id = GRP_ID_AUTOAM_MAIN;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Check if in USB mode before enter setting */
#if defined(__USB_IN_NORMAL_MODE__)
    if (srv_usb_is_in_mass_storage_mode())
    {
        mmi_usb_app_unavailable_popup(0);
        return;
    }
#endif /* defined(__USB_IN_NORMAL_MODE__) */ 
#if defined (__MMI_BACKGROUND_CALL__)
    if (IS_IN_CALL() == MMI_TRUE)
    {
        FS_Close(g_autoam_file_hdlr);
        g_autoam_file_hdlr = 0;
        mmi_ucm_app_entry_error_message();
        return;
    }
#endif /* defined (__MMI_BACKGROUND_CALL__) */ 

    if (!is_back)
    {
        mmi_autoam_file_load_incall(&g_autoam_file_hdlr, &g_autoam_total_message_num);
    }
    else
    {
        mmi_autoam_file_check_format(g_autoam_file_hdlr, &g_autoam_total_message_num);
    }      
    
#if defined	___AUTOAM_MY_DEBUG___
	if(g_autoam_total_message_num == 0)
	{
		g_autoam_speech.fd = g_autoam_file_hdlr;		
		mmi_autoam_debug_create_dummy_msg();
	}
#else
    if ((is_back == MMI_FALSE) && (g_autoam_total_message_num != 0))
    {
        mmi_autoam_pre_check_message_list();
    }   
#endif

    if (g_autoam_total_message_num == 0)
    {
        mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_GLOBAL_EMPTY)), MMI_EVENT_FAILURE, NULL);
        /* can not entry record list, so close file handler */
        FS_Close(g_autoam_file_hdlr);
        g_autoam_file_hdlr = 0;
        /* hide unread status icon */
        wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD);
        return;
    }

    /* after delete function, goback to message list , check if need show unread status icon */
    if (mmi_autoam_file_check_unread(g_autoam_file_hdlr, g_autoam_total_message_num) <= 0)
    {
        wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD);
    }


        if(g_autoam_idle_display_flag)
        {
            parent_grp_id = mmi_frm_group_get_active_id();
        }
    
        mmi_frm_group_create(parent_grp_id, GRP_ID_AUTOAM_MESSAGE, NULL, NULL);
        mmi_frm_group_enter(GRP_ID_AUTOAM_MESSAGE, MMI_FRM_NODE_SMART_CLOSE_FLAG);



	mmi_frm_scrn_enter(
            GRP_ID_AUTOAM_MESSAGE,
            SCR_ID_AUTOAM_MESSAGE,
            NULL,
            mmi_autoam_entry_message_list,
            MMI_FRM_FULL_SCRN);

    guiBuffer = mmi_frm_scrn_get_gui_buf(GRP_ID_AUTOAM_MESSAGE, SCR_ID_AUTOAM_MESSAGE);
    highlighted_item = 0;

    RegisterHighlightHandler(mmi_autoam_voice_message_highlight_hdlr);

#ifdef __MMI_FTE_SUPPORT__
    mmi_autoam_iconbar_setup();
#endif 

#ifdef __MMI_FTE_SUPPORT__
    mmi_autoam_set_iconbar_state();
#endif 

#if defined(__MMI_BASIC_UI_STYLE__)
wgui_cat1032_show(
    get_string(STR_ID_AUTOAM_LEAVING_MESSAGE),
    get_image(GetRootTitleIcon(MENU_ID_AUTOAM_MAIN)),
    get_string(STR_GLOBAL_OPTIONS),
    get_image(IMG_GLOBAL_OPTIONS),
    get_string(STR_GLOBAL_BACK),
    get_image(IMG_GLOBAL_BACK),
    g_autoam_total_message_num,
    mmi_autoam_message_multi_list_item,
    NULL,
    highlighted_item,
    0,
    0,
    0,
    (U8*) guiBuffer,
    &cat_err);
#else
    ShowCategory284Screen(
        STR_ID_AUTOAM_LEAVING_MESSAGE,
        GetRootTitleIcon(MENU_ID_AUTOAM_MAIN),  /* title text and icon */
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,                     /* LSK text and icon */
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,                        /* RSK text and icon */
        g_autoam_total_message_num,
        mmi_autoam_message_list_item,
        mmi_autoam_message_list_item_hint,
        highlighted_item,
        guiBuffer);

#endif


#ifdef __MMI_FTE_SUPPORT__
    /* Register for intuitive commands */
    wgui_register_tap_callback(mmi_autoam_voice_msg_cmd_hdlr);
#endif /* __MMI_FTE_SUPPORT__ */ 

    mmi_frm_scrn_set_leave_proc(
        GRP_ID_AUTOAM_MESSAGE,
        SCR_ID_AUTOAM_MESSAGE,
        mmi_autoam_entry_message_list_scrn_leave_proc);

    ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
    SetCenterSoftkeyFunction(mmi_autoam_play_voice_message, KEY_EVENT_DOWN);

    /* register LSK, right arrow key hanlders */
    SetLeftSoftkeyFunction(mmi_autoam_entry_voice_message_option, KEY_EVENT_UP);
    /* register RSK, left right arrow key handler */

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_highlight_hdlr
 * DESCRIPTION
 *  message item highlight hdlr
 * PARAMETERS
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_voice_message_highlight_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_autoam_voice_msg_index = g_autoam_total_message_num - 1 - index;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_message_list_delete_callback
 * DESCRIPTION
 *  delete message list screen callback function
 * PARAMETERS
 *  in_param        [IN]        
 * RETURNS
 *  U8
 *****************************************************************************/
U8 mmi_autoam_message_list_delete_callback(void *in_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FS_Close(g_autoam_file_hdlr);
    g_autoam_file_hdlr = 0;

    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_message_list_item
 * DESCRIPTION
 *  show list item
 * PARAMETERS
 *  item_index          [IN]        
 *  str_buff            [IN]        
 *  img_buff_p          [?]         [?]
 *  str_img_mask        [IN]        
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL mmi_autoam_message_list_item(S32 item_index, UI_string_type str_buff, PU8 *img_buff_p, U8 str_img_mask)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL isNumNull = MMI_FALSE;
    U16 tmp_number[MMI_AUTOAM_CALL_NUMBER_LEN];
    U16 duration[MMI_AUTOAM_SHOW_DURATION_LEN];
    U16 str_duration[MMI_AUTOAM_SHOW_DURATION_LEN];
    S32 display_index;
    U16 ph_name_len = (MMI_AUTOAM_SHOW_DURATION_LEN >> 1) + 1;
    MMI_ID img_id = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item_index < 0)
    {
        return MMI_FALSE;
    }
    display_index = g_autoam_total_message_num - item_index - 1;
    if (display_index < 0 || display_index >= g_autoam_total_message_num)
    {
        return MMI_FALSE;
    }
    if (mmi_autoam_file_load_single_msg(g_autoam_file_hdlr, g_autoam_file_header[display_index]) < FS_NO_ERROR)
    {
        return MMI_FALSE;
    }

    /* check number valid */
    mmi_asc_n_to_ucs2((S8*) tmp_number, (S8*) g_autoam_message.number, MMI_AUTOAM_CALL_NUMBER_LEN);
    if (0 == mmi_ucs2strlen((S8*) tmp_number))
    {
        isNumNull = MMI_TRUE;
    }

    /* lookup caller name */
    if (!isNumNull)
    {
        srv_phb_get_name_by_number((U16*) tmp_number, (U16*) str_buff, MMI_PHB_NAME_LENGTH);
        if (!mmi_ucs2strlen((S8*) str_buff))
        {
            mmi_ucs2ncpy((S8*) str_buff, (S8*) g_autoam_message.callername, MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN);
        }
    }
    else
    {
        mmi_ucs2ncpy((S8*) str_buff, (S8*) g_autoam_message.callername, MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN);
    }

    ph_name_len += mmi_ucs2strlen((S8*) str_buff);

    mmi_autoam_get_voice_message_duration((U16*) duration);
    kal_wsprintf((kal_wchar*) str_duration, "%w%w%w", (const kal_wchar*)L" (", duration, (const kal_wchar*)L")");

    /*  
    * Record length duration is show only when caller name length +  record length duration  
    * is less than MAX_SUBMENU_CHARACTERS
    */

    if(ph_name_len < MAX_SUBMENU_CHARACTERS)
    {
        mmi_ucs2cat((S8*) str_buff, (S8*) str_duration);
    }

    /* show order icon */
    if (!(g_autoam_message.flag & MMI_AUTOAM_MSG_READ_FLAG))
    {
        /* UNREAD */
        if (g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG)
        {
            /* have been protected */
            img_id = IMG_ID_AUTOAM_MESSAGE_UNREAD_PROTECT;
            
        }
        else
        {
            /* have been unprotected */
            img_id = IMG_ID_AUTOAM_MESSAGE_UNREAD;
           
        }
    }
    else
    {
        /* READ */
        if (g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG)
        {
            /* have been protected */

            img_id = IMG_ID_AUTOAM_MESSAGE_READ_PROTECT;  
            
        }
        else
        {
            /* have been protected */
            img_id = IMG_ID_AUTOAM_MESSAGE_READ; 
            
        }
    }
    img_buff_p[0] = (PU8) GetImage((U16) (img_id));
    return TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_message_list_item_hint
 * DESCRIPTION
 *  hint list
 * PARAMETERS
 *  item_index      [IN]        
 *  hint_array      [OUT]       
 * RETURNS
 *  S32
 *****************************************************************************/
S32 mmi_autoam_message_list_item_hint(S32 item_index, UI_string_type *hint_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 display_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item_index < 0)
    {
        return MMI_FALSE;
    }
    display_index = g_autoam_total_message_num - item_index - 1;
    if (display_index < 0 || display_index >= g_autoam_total_message_num)
    {
        return MMI_FALSE;
    }
    if (mmi_autoam_file_load_single_msg(g_autoam_file_hdlr, g_autoam_file_header[display_index]) < FS_NO_ERROR)
    {
        return MMI_FALSE;
    }

    mmi_autoam_get_voice_message_datetime((S8*) hint_array[0]);

    return MMI_TRUE;
}

#if defined(__MMI_BASIC_UI_STYLE__)
/*****************************************************************************
 * FUNCTION
 *  mmi_clog_lt_get_multi_log_items
 * DESCRIPTION
 *  Asyncdynamic list item load function
 * PARAMETERS
 *  start_index      :    [IN]     Start index of menu item
 *  menu_data        :    [OUT]    A pointer of parameter to store the menu data
 *  item_count        :    [IN]     The number of load menu items
 * RETURNS
 *  S32
 * RETURN VALUES
 *  Number of items can be retrieved
 *****************************************************************************/
static S32 mmi_autoam_message_multi_list_item(S32 start_index, gui_iconlist_menu_item *menu_data, S32 item_count)
{
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    S32 total_count;
    S32 i, items = 0;   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
  
    total_count = (S32) g_autoam_total_message_num;
    
    for (i = start_index; items < item_count && i < total_count; i++, items++)
    {
        mmi_autoam_message_list_item(i, 
            menu_data[items].item_list[0], 
            menu_data[items].image_list, 0);

		mmi_autoam_message_list_item_hint(i, &(menu_data[items].item_list[1]));
    }
    return items;
}

#endif
/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_file_load_single_msg
 * DESCRIPTION
 *  hint list
 * PARAMETERS
 *  fd              [IN]        
 *  item_index      [IN]        
 * RETURNS
 *  S32
 *****************************************************************************/
S32 mmi_autoam_file_load_single_msg(S32 fd, S32 item_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fs_ret;
    U32 nLen;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fs_ret = FS_Seek(fd, item_index * MMI_AUTOAM_FILE_ONE_MSG_LEN + MMI_AUTOAM_FILE_HEADER_LEN, FS_FILE_BEGIN);
    if (fs_ret >= FS_NO_ERROR)
    {
        fs_ret = FS_Read(fd, g_autoam_msg_buf, MMI_AUTOAM_FILE_ONE_MSG_LEN, &nLen);
        if (fs_ret >= FS_NO_ERROR)
        {
            g_autoam_message.flag = g_autoam_msg_buf[MMI_AUTOAM_FILE_FLAG_OFFSET];
            g_autoam_message.sim_no= g_autoam_msg_buf[MMI_AUTOAM_FILE_SIM_OFFSET];
            g_autoam_message.drv_letter = g_autoam_msg_buf[MMI_AUTOAM_FILE_DRIVE_OFFSET];
            g_autoam_message.rec_len = g_autoam_msg_buf[MMI_AUTOAM_FILE_DURATION_OFFSET];
            g_autoam_message.rec_len |= (g_autoam_msg_buf[MMI_AUTOAM_FILE_DURATION_OFFSET + 1] << 8);
            memcpy(
                (S8*) g_autoam_message.filename,
                (S8*) & g_autoam_msg_buf[MMI_AUTOAM_FILE_NAME_OFFSET],
                MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN * ENCODING_LENGTH);
            memcpy((S8*) g_autoam_message.date, (S8*) & g_autoam_msg_buf[MMI_AUTOAM_FILE_DATE_OFFSET], 12);
            memcpy(
                (S8*) g_autoam_message.callername,
                (S8*) & g_autoam_msg_buf[MMI_AUTOAM_FILE_CALLER_NAME_OFFSET],
                MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN * 2);
            memcpy(
                (S8*) g_autoam_message.number,
                (S8*) & g_autoam_msg_buf[MMI_AUTOAM_FILE_NUMBER_OFFSET],
                MMI_AUTOAM_CALL_NUMBER_LEN);
           #if defined (__MMI_DYNAMIC_SIM_DYNAMIC_UI__)
           memcpy(
              (S8*) g_autoam_message.sim_name,
              (S8*) & g_autoam_msg_buf[MMI_AUTOAM_FILE_SIM_NAME_OFFSET],
              (MMI_NETSET_SIM_NAME_MAX_LEN * 2));
           #endif
			
            return FS_NO_ERROR;
        }
    }
    return fs_ret;
}

#define MMI_AUTO_ANSWER_MACHINE_ENTRY_MESSAGE_OPTION


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_option_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt             [?]         
 *  index(?)        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_voice_message_option_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    cui_menu_event_struct *menu_evt = (cui_menu_event_struct*) evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (menu_evt->evt_id)
    {
        case EVT_ID_CUI_MENU_LIST_ENTRY:
        {
            cui_menu_set_default_title_image(menu_evt->sender_id, get_image(IMG_ID_AUTOAM_APP));
            if (
        #ifdef __MMI_MMS_DUAL_SIM__
                   (!mmi_bootup_is_sim2_valid()) &&
        #endif 
                   (!mmi_bootup_is_sim_valid()))
            {
                cui_menu_set_item_hidden(menu_evt->sender_id, MENU_ID_AUTOAM_MESSAGE_OPTION_DIAL, MMI_TRUE);

            }
            else if (srv_mode_switch_is_network_service_available())
            {
                cui_menu_set_item_hidden(menu_evt->sender_id, MENU_ID_AUTOAM_MESSAGE_OPTION_DIAL, MMI_TRUE);
            }
            else
            {
                cui_menu_set_item_hidden(menu_evt->sender_id, MENU_ID_AUTOAM_MESSAGE_OPTION_DIAL, MMI_FALSE);
            }
             if ((g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG) != 0)
            {                
                cui_menu_set_item_string(menu_evt->sender_id, 
                    MENU_ID_AUTOAM_MESSAGE_OPTION_PROTECT, 
                    get_string(STR_ID_AUTOAM_UNPROTECT));
            }
            break;
        }

        case EVT_ID_CUI_MENU_ITEM_SELECT:
            switch (menu_evt->highlighted_menu_id)
            {

                case MENU_ID_AUTOAM_MESSAGE_OPTION_PLAY:
                    mmi_autoam_play_voice_message();
                    break;
                case MENU_ID_AUTOAM_MESSAGE_OPTION_INFO:
                    mmi_autoam_entry_message_detail_screen();
                    break;
                case MENU_ID_AUTOAM_MESSAGE_OPTION_DIAL:
                    mmi_autoam_voice_message_dial();
                    break;
                case MENU_ID_AUTOAM_MESSAGE_OPTION_SAVE_TO_PBK:
                    mmi_autoam_save_name_to_pbk();
                    break;
                case MENU_ID_AUTOAM_MESSAGE_OPTION_DELETE:
                    mmi_autoam_entry_message_delete_confirm();
                    break;
                case MENU_ID_AUTOAM_MESSAGE_OPTION_DELETE_ALL:
                    mmi_autoam_voice_message_delete_all_confirm();
                    break;
                case MENU_ID_AUTOAM_MESSAGE_OPTION_PROTECT:
                    mmi_autoam_voice_message_protect_change();
                    break;
                default:
                    break;
            }
            break;

        case EVT_ID_CUI_MENU_CLOSE_REQUEST:
            cui_menu_close(menu_evt->sender_id);
            break;
	 case EVT_ID_GROUP_DEINIT:
	 	mmi_frm_group_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION);
	 	break;

    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_voice_message_option
 * DESCRIPTION
 *  entry voice message option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_voice_message_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    mmi_id menu_gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Hide Call option in flight mode */
#if defined (__MMI_BACKGROUND_CALL__)
    if (IS_IN_CALL() == MMI_TRUE)
    {
        return;
    }
#endif /* defined (__MMI_BACKGROUND_CALL__) */ 

    if (!mmi_autoam_prepare_voice_msg_data())
    {
        return;
    }

    mmi_frm_group_create(
        GRP_ID_AUTOAM_MESSAGE,
        GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION,
        mmi_autoam_voice_message_option_proc,
        NULL);

    mmi_frm_group_enter(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    menu_gid = cui_menu_create(
                GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION,
                CUI_MENU_SRC_TYPE_RESOURCE,
                CUI_MENU_TYPE_APPSUB,
                MENU_ID_AUTOAM_MESSAGE_OPTION,
                MMI_TRUE,
                NULL);
    cui_menu_run(menu_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_play_voice_message
 * DESCRIPTION
 *  this funciton is to play the current voice message
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_play_voice_message(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE fd = -1;
    U32 nLen;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_wsprintf(
        (kal_wchar*) g_autoam_in_call_path,
        "%c:\\%w%w%w%w",
        g_autoam_message.drv_letter,
        MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
        MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE,
        g_autoam_message.filename,
        L".wav");

    /* check the file exist or not before action */
    fd = FS_Open((const WCHAR*)g_autoam_in_call_path, FS_READ_ONLY);
    if (fd >= FS_NO_ERROR)
    {
        FS_Close(fd);
        mmi_media_app_play_audio((U16*) g_autoam_in_call_path, NULL, GetRootTitleIcon(MENU_ID_AUTOAM_MAIN));
    }
    else
    {
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(fd))),
            (mmi_event_notify_enum) srv_fmgr_fs_error_get_popup_type(fd),
            NULL);
        mmi_frm_group_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION);
        return;
    }

    if ((g_autoam_message.flag & MMI_AUTOAM_MSG_READ_FLAG) == 0)
    {
        g_autoam_message.flag |= MMI_AUTOAM_MSG_READ_FLAG;
        FS_Seek(
            g_autoam_file_hdlr,
            g_autoam_file_header[g_autoam_voice_msg_index] * MMI_AUTOAM_FILE_ONE_MSG_LEN + MMI_AUTOAM_FILE_HEADER_LEN + MMI_AUTOAM_FILE_FLAG_OFFSET,
            FS_FILE_BEGIN);
        FS_Write(g_autoam_file_hdlr, &g_autoam_message.flag, 1, &nLen);
    }

    if (0 == mmi_autoam_file_check_unread(g_autoam_file_hdlr, g_autoam_total_message_num))
    {
        wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD);
    }
    mmi_frm_group_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_detail_screen
 * DESCRIPTION
 *  highlight hdlr of message info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_message_detail_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined (__MMI_BACKGROUND_CALL__)
    if (IS_IN_CALL() == MMI_TRUE)
    {
        return;
    }
#endif /* defined (__MMI_BACKGROUND_CALL__) */ 

    mmi_frm_scrn_enter(
        GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION,
        SCR_ID_AUTOAM_MESSAGE_DETAIL,
        mmi_autoam_exit_message_detail_screen,
        mmi_autoam_entry_message_detail_screen,
        MMI_FRM_FULL_SCRN);

    g_autoam_detail_hdlr = (U16*) applib_mem_screen_alloc_framebuffer(MMI_AUTOAM_DETAIL_STR_SIZE);

    MMI_ASSERT(g_autoam_detail_hdlr != NULL);

    mmi_autoam_view_voice_message_info();

    ShowCategory74Screen(
        STR_GLOBAL_DETAILS,
        GetRootTitleIcon(MENU_ID_AUTOAM_MAIN),
        0,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (U8*) g_autoam_detail_hdlr,
        mmi_ucs2strlen((S8*) g_autoam_detail_hdlr),
        NULL);

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_exit_message_detail_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_exit_message_detail_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    applib_mem_screen_free((void*)g_autoam_detail_hdlr);
    g_autoam_detail_hdlr = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_view_voice_message_info
 * DESCRIPTION
 *  this function is to view the message detail info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_view_voice_message_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL isNumNull = MMI_FALSE;
    U16 tmp_number[MMI_AUTOAM_CALL_NUMBER_LEN];
    U16 temp_str[MMI_AUTOAM_MAX_FULL_NAME_LEN];
	#ifdef __GEMINI__		
/* under construction !*/
/* under construction !*/
    #endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check number validation */
    mmi_asc_n_to_ucs2((S8*) tmp_number, (S8*) g_autoam_message.number, MMI_AUTOAM_CALL_NUMBER_LEN);
    if (0 == mmi_ucs2strlen((S8*) tmp_number))
    {
        isNumNull = MMI_TRUE;
    }

    /* prepare the name */
    mmi_ucs2ncpy((S8*) g_autoam_detail_hdlr, (S8*) GetString(STR_ID_AUTOAM_INFO_NAME), MMI_AUTOAM_SINGLE_STR_LEN);
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    if (!isNumNull)
    {
        srv_phb_get_name_by_number((U16*) tmp_number, (U16*) temp_str, MMI_PHB_NAME_LENGTH);
        if (!mmi_ucs2strlen((S8*) temp_str))
        {
            mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) g_autoam_message.callername, MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN);
        }
        else
        {
            mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) temp_str, MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN);
        }
    }
    else
    {
        mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) g_autoam_message.callername, MMI_AUTOAM_MAX_DISPLAY_FILE_NAME_LEN);
    }
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
	#ifdef __GEMINI__		
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#if defined (__MMI_DYNAMIC_SIM_DYNAMIC_UI__)
/* under construction !*/
	#endif
/* under construction !*/
	#endif
    /* prepare the number */
    mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) GetString(STR_ID_AUTOAM_INFO_NUMBER), MMI_AUTOAM_SINGLE_STR_LEN);
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    if (!isNumNull)
    {
        mmi_asc_n_to_ucs2((S8*) temp_str, (S8*) g_autoam_message.number, MMI_AUTOAM_CALL_NUMBER_LEN);
        mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) temp_str, MMI_AUTOAM_CALL_NUMBER_LEN);
    }
    else
    {
        mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    }
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    /* prepare date and time */
    mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) GetString(STR_ID_AUTOAM_INFO_TIME), MMI_AUTOAM_SINGLE_STR_LEN);
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    mmi_autoam_get_voice_message_datetime((S8*) temp_str);
    mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (const S8*)temp_str, mmi_ucs2strlen((const S8*)temp_str));
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    /* prepare duration */
    mmi_ucs2ncat((S8*) g_autoam_detail_hdlr, (S8*) GetString(STR_ID_AUTOAM_INFO_DURATION), MMI_AUTOAM_SINGLE_STR_LEN);
    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) L"\n");
    mmi_autoam_get_voice_message_duration((U16*) temp_str);

    mmi_ucs2cat((S8*) g_autoam_detail_hdlr, (S8*) temp_str);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_voice_message_datetime
 * DESCRIPTION
 *  this function is to prepare the datetime string
 * PARAMETERS
 *  buffer      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_get_voice_message_datetime(S8 *buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 tmp_str[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_asc_n_to_ucs2((S8*) tmp_str, (S8*) & g_autoam_message.date[0], 4);
    mmi_ucs2ncpy((S8*) buffer, (S8*) tmp_str, 4);
    mmi_ucs2cat((S8*) buffer, (S8*) L"/");
    mmi_asc_n_to_ucs2((S8*) tmp_str, (S8*) & g_autoam_message.date[4], 2);
    mmi_ucs2ncat((S8*) buffer, (S8*) tmp_str, 2);
    mmi_ucs2cat((S8*) buffer, (S8*) L"/");
    mmi_asc_n_to_ucs2((S8*) tmp_str, (S8*) & g_autoam_message.date[6], 2);
    mmi_ucs2ncat((S8*) buffer, (S8*) tmp_str, 2);
    mmi_ucs2cat((S8*) buffer, (S8*) L" ");
    mmi_asc_n_to_ucs2((S8*) tmp_str, (S8*) & g_autoam_message.date[8], 2);
    mmi_ucs2ncat((S8*) buffer, (S8*) tmp_str, 2);
    mmi_ucs2cat((S8*) buffer, (S8*) L":");
    mmi_asc_n_to_ucs2((S8*) tmp_str, (S8*) & g_autoam_message.date[10], 2);
    mmi_ucs2ncat((S8*) buffer, (S8*) tmp_str, 2);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_get_voice_message_duration
 * DESCRIPTION
 *  this function is to prepare the datetime string
 * PARAMETERS
 *  buffer      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_get_voice_message_duration(U16 *buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 duration;
    U16 second;
    U16 minute;
    U16 hour;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    duration = g_autoam_message.rec_len;

    second = duration % 60;
    duration /= 60;
    minute = duration % 60;
    duration /= 60;
    hour = duration;

    kal_wsprintf((kal_wchar*) buffer, "%02d:%02d:%02d", hour, minute, second);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_save_phb_entry_proc
 * DESCRIPTION
 *  Process save entry to PHB from auto answer machine
 * PARAMETERS
 *  evt     [IN]        Event
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_autoam_save_phb_entry_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_GROUP_FIRST_ENTRY:
        case EVT_ID_GROUP_INACTIVE:
            break;

        case EVT_ID_GROUP_ACTIVE:
            break;

        case EVT_ID_GROUP_GOBACK:
        case EVT_ID_GROUP_DELETE_REQ:
            break;

        case EVT_ID_GROUP_DEINIT:
            break;

        case EVT_ID_PHB_SAVE_CONTACT:
        case EVT_ID_PHB_SAVE_CONTACT_CANCEL:
            cui_phb_save_contact_close(g_phb_cui_id);
            break;
        default:
            break;
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_save_name_to_pbk
 * DESCRIPTION
 *  this function is to save the name to pbk
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_save_name_to_pbk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 temp_num[MMI_AUTOAM_CALL_NUMBER_LEN];
    mmi_id group_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_asc_n_to_ucs2((S8*) temp_num, (S8*) g_autoam_message.number, MMI_AUTOAM_CALL_NUMBER_LEN);
    /* SaveNumberFromIdleScrn((S8*) temp_num, 0); */
    /* mmi_frm_group_entry_ex(GRP_ID_ROOT, GRP_ID_AUTOAM_SAVE_PHB_ENTRY, mmi_autoam_save_phb_entry_proc, NULL, NULL); */
    group_id = mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTOAM_SAVE_PHB_ENTRY, mmi_autoam_save_phb_entry_proc, NULL);
    mmi_frm_group_enter(group_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    g_phb_cui_id = cui_phb_save_contact_create(GRP_ID_AUTOAM_SAVE_PHB_ENTRY);
    if (g_phb_cui_id != GRP_ID_INVALID)
    {
        cui_phb_save_contact_set_number(g_phb_cui_id, temp_num);

        cui_phb_save_contact_run(g_phb_cui_id);
    }
    mmi_frm_group_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_dial
 * DESCRIPTION
 *  make the call use the number in message info
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_voice_message_dial(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 temp_num[MMI_AUTOAM_CALL_NUMBER_LEN];
    mmi_ucm_make_call_para_struct make_call_para;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_asc_n_to_ucs2((S8*) temp_num, (S8*) g_autoam_message.number, MMI_AUTOAM_CALL_NUMBER_LEN);
    /* MakeCall((S8*) temp_num); */
    mmi_ucm_init_call_para(&make_call_para);
    make_call_para.ucs2_num_uri = (U16*) temp_num;
    mmi_ucm_call_launch(0, &make_call_para);
    mmi_frm_group_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_delete_confirm_cb
 * DESCRIPTION
 *  delete message confirmation
 * PARAMETERS
 *  evt     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_autoam_voice_message_delete_confirm_cb(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_1:
            case MMI_ALERT_CNFM_2:
            case MMI_ALERT_CNFM_3:
                /* handle softkey event here */
                break;
            case MMI_ALERT_CNFM_OK:
                /* handle softkey event here */
                break;
            case MMI_ALERT_CNFM_YES:
                mmi_autoam_entry_message_delete_animation();
                break;
            case MMI_ALERT_CNFM_NO:
                mmi_frm_scrn_close_active_id();
                break;
        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_delete_confirm
 * DESCRIPTION
 *  delete message confirmation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_message_delete_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG) != 0)
    {
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(FS_READ_ONLY_ERROR))),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(FS_READ_ONLY_ERROR),
            NULL);     
        mmi_frm_group_close(GRP_ID_AUTOAM_MESSAGE);
        
    }
    else
    {
        mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
        arg.callback = (mmi_proc_func) mmi_autoam_voice_message_delete_confirm_cb;
      	arg.f_auto_map_empty_softkey = MMI_FALSE;
        mmi_confirm_display((WCHAR*) (get_string(STR_ID_AUTOAM_DELETE_ASK)), MMI_EVENT_QUERY, &arg);
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_delete_proc_func
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_entry_message_delete_proc_func(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct   *adv_action = (srv_fmgr_async_done_event_struct*) param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(param->evt_id)
    {
    case EVT_ID_SRV_FMGR_ASYNC_DONE:
       

    if (adv_action->result >= FS_NO_ERROR)
    {
        mmi_autoam_file_delete_single_update();
        mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_GLOBAL_DELETED)), MMI_EVENT_SUCCESS, NULL);
    }
    else
    {
        if (adv_action->result != FS_READ_ONLY_ERROR)
        {
            mmi_autoam_file_delete_single_update();
        }
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(adv_action->result))),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(adv_action->result),
            NULL);
    }
    /* check unread files */
    if (0 == mmi_autoam_file_check_unread(g_autoam_file_hdlr, g_autoam_total_message_num))
    {
        wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD);
    }
    
    mmi_frm_group_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION);	
        break;
    }
    return MMI_RET_OK;
}		

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_delete_animation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_message_delete_animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32  fs_ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_wsprintf(
        (kal_wchar*) g_autoam_in_call_path,
        "%c:\\%w%w%w%w",
        g_autoam_message.drv_letter,
        MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
        MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE,
        g_autoam_message.filename,
        L".wav");


    fs_ret = srv_fmgr_async_delete((WCHAR*)g_autoam_in_call_path, 0, mmi_autoam_entry_message_delete_proc_func, NULL);

    ClearInputEventHandler(MMI_DEVICE_ALL);

    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

    mmi_frm_scrn_enter(
        GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION,
        SCR_ID_AUTOAM_MESSAGE_DELETE_ANIMATION,
        NULL,
        NULL,
        MMI_FRM_SMALL_SCRN);

    ShowCategory66Screen(
        STR_GLOBAL_DELETE,
        GetRootTitleIcon(MENU_ID_AUTOAM_MAIN),
        0,
        0,
        0,
        0,
        (PU8) GetString(STR_GLOBAL_DELETING),
        IMG_GLOBAL_PROGRESS,
        NULL);

   if(fs_ret < 0)
    {
         mmi_autoam_file_delete_single_update();
        mmi_popup_display((WCHAR*) GetString(STR_GLOBAL_DELETED),
            MMI_EVENT_SUCCESS, 
            NULL);
    }

    ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END, KEY_LONG_PRESS);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_file_delete_single_update
 * DESCRIPTION
 *  update message list after delete file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_file_delete_single_update(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 flag;
    U8 i, j;
    U32 nLen;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reset flag */
    FS_Seek(
                g_autoam_file_hdlr,
                (g_autoam_file_header[g_autoam_voice_msg_index] * MMI_AUTOAM_FILE_ONE_MSG_LEN) + MMI_AUTOAM_FILE_HEADER_LEN,
                FS_FILE_BEGIN);
    FS_Read(g_autoam_file_hdlr, &flag, 1, &nLen);
    flag &= ~MMI_AUTOAM_MSG_VALID_FLAG;
    FS_Seek(
                g_autoam_file_hdlr,
                (g_autoam_file_header[g_autoam_voice_msg_index] * MMI_AUTOAM_FILE_ONE_MSG_LEN) + MMI_AUTOAM_FILE_HEADER_LEN,
                FS_FILE_BEGIN);
    FS_Write(g_autoam_file_hdlr, &flag, 1, &nLen);
    FS_Commit(g_autoam_file_hdlr);

    /* reset header */
    i = (U8) g_autoam_voice_msg_index;
    while (i < g_autoam_total_message_num)
    {
        j = i + 1;
        g_autoam_file_header[i] = g_autoam_file_header[j];
        i = j;
    }

    g_autoam_total_message_num--;

    FS_Seek(g_autoam_file_hdlr, 0, FS_FILE_BEGIN);
    FS_Write(g_autoam_file_hdlr, g_autoam_file_header, MMI_AUTOAM_FILE_HEADER_LEN, &nLen);
    FS_Commit(g_autoam_file_hdlr);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_delete_all_confirm_cb
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [?]     
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_autoam_voice_message_delete_all_confirm_cb(mmi_alert_result_evt_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (evt->result)
        {
            case MMI_ALERT_CNFM_1:
            case MMI_ALERT_CNFM_2:
            case MMI_ALERT_CNFM_3:
                /* handle softkey event here */
                break;
            case MMI_ALERT_CNFM_OK:
                /* handle softkey event here */
                break;
            case MMI_ALERT_CNFM_YES:
                mmi_autoam_entry_message_delete_all_animation();
                break;
            case MMI_ALERT_CNFM_NO:
                mmi_frm_scrn_close_active_id();
                break;

        }
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_delete_all_confirm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_voice_message_delete_all_confirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.f_auto_map_empty_softkey = MMI_FALSE;
    arg.callback = (mmi_proc_func) & mmi_autoam_voice_message_delete_all_confirm_cb;
    mmi_confirm_display((WCHAR*) (get_string(STR_ID_AUTOAM_DELETE_ALL_ASK)), MMI_EVENT_QUERY, &arg);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_delete_all_animation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_message_delete_all_animation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_autoam_last_error = FS_NO_ERROR;
    g_autoam_del_all_flag = MMI_TRUE;
    g_autoam_has_delete_flag = MMI_FALSE;
    g_autoam_del_all_current_index = g_autoam_total_message_num;

    ClearInputEventHandler(MMI_DEVICE_ALL);
    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

    mmi_frm_scrn_enter(
        GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION,
        SCR_ID_AUTOAM_MESSAGE_DELETE_ALL_ANIMATION,
        NULL,
        NULL,
        MMI_FRM_SMALL_SCRN);

    delele_screen_id = SCR_ID_AUTOAM_MESSAGE_DELETE_ALL_ANIMATION;



    ShowCategory66Screen(
        STR_GLOBAL_DELETE,
        GetRootTitleIcon(MENU_ID_AUTOAM_MAIN),
        0,
        0,
        0,
        0,
        (PU8) GetString(STR_GLOBAL_DELETING),
        IMG_GLOBAL_PROGRESS,
        NULL);

    ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
    ClearKeyHandler(KEY_END, KEY_LONG_PRESS);

    mmi_autoam_message_delete_all_ordinal();
}




/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_delete_proc_func
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_autoam_entry_message_delete_all_proc_func(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_fmgr_async_done_event_struct  *adv_action = (srv_fmgr_async_done_event_struct *)param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(param->evt_id)
    {
	    case EVT_ID_SRV_FMGR_ASYNC_DONE:
	       

		if (adv_action->result < FS_NO_ERROR)
		{
			g_autoam_last_error = adv_action->result;
			/* If not file file, deal as has deleted */
			if (adv_action->result != FS_READ_ONLY_ERROR)
			{
				mmi_autoam_file_delete_all_update();
			}
		}
		else
		{
			mmi_autoam_file_delete_all_update();
		}

		if (SCR_ID_AUTOAM_MESSAGE_DELETE_ALL_ANIMATION == delele_screen_id)
		{
			/* Delete all operation not be interrupt, go on */
			mmi_autoam_message_delete_all_ordinal();
		}
		else
		{
			/* Delete all is interrupt */
			mmi_autoam_message_delete_all_interrupt();
			delele_screen_id = 0;
		}

    }
    return MMI_RET_OK;
}		


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_message_delete_all_ordinal
 * DESCRIPTION
 *  delete all message one by one
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_message_delete_all_ordinal(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index;
   S32  fs_ret = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	    do
	    {
    if (g_autoam_del_all_current_index > 0)
    {
        do
        {
            g_autoam_del_all_current_index--;
            index = g_autoam_file_header[g_autoam_del_all_current_index];
            mmi_autoam_file_load_single_msg(g_autoam_file_hdlr, index);
        } while (((g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG) != 0) && g_autoam_del_all_current_index > 0);

        /* find file to be deleted */
        if ((g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG) == 0)
        {
            g_autoam_has_delete_flag = MMI_TRUE;
            kal_wsprintf(
                (kal_wchar*) g_autoam_in_call_path,
                "%c:\\%w%w%w%w",
                g_autoam_message.drv_letter,
                MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
                MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE,
                g_autoam_message.filename,
                L".wav");
            /* unprotected */
	
                     fs_ret = srv_fmgr_async_delete((WCHAR*)g_autoam_in_call_path, 0, mmi_autoam_entry_message_delete_all_proc_func, NULL);
                    if(fs_ret < 0)
                    {
                        mmi_autoam_file_delete_single_update();    	      
                    }		
                    else
                    {
            return;
        }
            	         
                }
    }
	    }while(fs_ret < 0 && g_autoam_del_all_current_index > 0);

    /* check unread files */
    if (0 == mmi_autoam_file_check_unread(g_autoam_file_hdlr, g_autoam_total_message_num))
    {
        wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD);
    }

    /* reset delete all flag */
    g_autoam_del_all_flag = MMI_FALSE;

    /* No file to be deleted and go back history */
    srv_backlight_turn_off();
    if (g_autoam_last_error >= FS_NO_ERROR)
    {
        if (MMI_TRUE == g_autoam_has_delete_flag)
        {
            mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_GLOBAL_DELETED)), MMI_EVENT_SUCCESS, NULL);
        }
        else
        {
            mmi_popup_display(
                (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(FS_READ_ONLY_ERROR))),
                (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(FS_READ_ONLY_ERROR),
                NULL);
        }
    }
    else
    {
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(g_autoam_last_error))),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(g_autoam_last_error),
            NULL);
    }

    mmi_frm_scrn_close(GRP_ID_AUTOAM_VOICE_MESSAGE_OPTION, SCR_ID_AUTOAM_MESSAGE_DELETE_ALL_ANIMATION);
    mmi_frm_group_close(GRP_ID_AUTOAM_MESSAGE);

}





/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_message_delete_all_interrupt
 * DESCRIPTION
 *  Delete all process is interrupt
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_message_delete_all_interrupt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check unread files */
    if (0 == mmi_autoam_file_check_unread(g_autoam_file_hdlr, g_autoam_total_message_num))
    {
        wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD);
    }

    /* reset delete all flag */
    g_autoam_del_all_flag = MMI_FALSE;

    if (g_autoam_last_error <= FS_NO_ERROR)
    {
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(g_autoam_last_error))),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(g_autoam_last_error),
            NULL);

    }

    mmi_frm_group_close(GRP_ID_AUTOAM_MESSAGE_OPTION);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_file_delete_all_update
 * DESCRIPTION
 *  Delete every file call back this function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_file_delete_all_update(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 flag;
    U8 i, j;
    U32 nLen;   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reset flag */
     FS_Seek(
                g_autoam_file_hdlr,
                g_autoam_file_header[g_autoam_del_all_current_index] * MMI_AUTOAM_FILE_ONE_MSG_LEN + MMI_AUTOAM_FILE_HEADER_LEN,
                FS_FILE_BEGIN);
    FS_Read(g_autoam_file_hdlr, &flag, 1, &nLen);
    flag &= ~MMI_AUTOAM_MSG_VALID_FLAG;
    FS_Seek(
                g_autoam_file_hdlr,
                g_autoam_file_header[g_autoam_del_all_current_index] * MMI_AUTOAM_FILE_ONE_MSG_LEN + MMI_AUTOAM_FILE_HEADER_LEN,
                FS_FILE_BEGIN);
    FS_Write(g_autoam_file_hdlr, &flag, 1, &nLen);

    /* reset header */
    i = g_autoam_del_all_current_index;
    while (i < g_autoam_total_message_num)
    {
        j = i + 1;
        g_autoam_file_header[i] = g_autoam_file_header[j];
        i = j;
    }

    g_autoam_total_message_num--;

    FS_Seek(g_autoam_file_hdlr, 0, FS_FILE_BEGIN);
    FS_Write(g_autoam_file_hdlr, g_autoam_file_header, MMI_AUTOAM_FILE_HEADER_LEN, &nLen);
    FS_Commit(g_autoam_file_hdlr);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_voice_message_protect_change
 * DESCRIPTION
 *  protect the voice message
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_voice_message_protect_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 attr;
    U32 nLen;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_wsprintf(
        (kal_wchar*) g_autoam_in_call_path,
        "%c:\\%w%w%w%w",
        g_autoam_message.drv_letter,
        MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
        MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE,
        g_autoam_message.filename,
        L".wav");

    /* change protect flag first */
    attr = FS_GetAttributes((U16*) g_autoam_in_call_path);
    if (attr >= FS_NO_ERROR)
    {
        if ((g_autoam_message.flag & MMI_AUTOAM_MSG_PROTECT_FLAG) == 0)
        {
            /* set protect */
            g_autoam_message.flag |= MMI_AUTOAM_MSG_PROTECT_FLAG;
            FS_SetAttributes((U16*) g_autoam_in_call_path, (U8) (attr | (FS_ATTR_READ_ONLY)));
        }
        else
        {
            /* set unprotect */
            g_autoam_message.flag &= ~(MMI_AUTOAM_MSG_PROTECT_FLAG);
            FS_SetAttributes((U16*) g_autoam_in_call_path, (U8) (attr & ~(FS_ATTR_READ_ONLY)));
        }
        FS_Seek(
            g_autoam_file_hdlr,
            g_autoam_file_header[g_autoam_voice_msg_index] * MMI_AUTOAM_FILE_ONE_MSG_LEN + MMI_AUTOAM_FILE_HEADER_LEN,
            FS_FILE_BEGIN);
        FS_Write(g_autoam_file_hdlr, &g_autoam_message.flag, 1, &nLen);
        FS_Commit(g_autoam_file_hdlr);
        mmi_popup_display((WCHAR*) ((UI_string_type) GetString(STR_GLOBAL_DONE)), MMI_EVENT_SUCCESS, NULL);
    }
    else
    {
        /* File has error, set it unprotected */
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
        mmi_popup_display(
            (WCHAR*) (get_string(srv_fmgr_fs_error_get_string(attr))),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(attr),
            NULL);
    }
    mmi_frm_group_close(GRP_ID_AUTOAM_MESSAGE_OPTION);

}

#define MMI_AUTO_ANSWER_MACHINE_IDLE_DISPLAY


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_need_msg_waiting_ind
 * DESCRIPTION
 *  check if need display hint message on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_autoam_need_msg_waiting_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_autoam_idle_display_flag && g_autoam_idle_number_before_view)
    {
        return g_autoam_idle_number_before_view;
    }
    else
    {
        g_autoam_idle_display_flag = 0;
        return 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_msg_waiting_ind_init
 * DESCRIPTION
 *  entry show message screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_msg_waiting_ind_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if( mmi_frm_scrn_enter(
        GRP_ID_AUTOAM_MAIN_ON_IDLE_SCRN,
        SCR_ID_AUTOAM_MSG_WAITING,
	    mmi_autoam_entry_msg_waiting_ind_init,
        NULL,
	    MMI_FRM_FULL_SCRN) == MMI_FALSE)
		{
			return;
		}
  

    if (mmi_scr_locker_is_locked () == MMI_FALSE)
    {
        g_autoam_save_screen = MMI_TRUE;
        ShowCategory154Screen(
            0,
            0,
            STR_GLOBAL_READ,
            0,
            STR_GLOBAL_BACK,
            0,
            (U8*) GetString(STR_ID_AUTOAM_MISSED_MSG),
            (U8*) g_autoam_last_valid_name,
            IMG_GLOBAL_INFO,
            NULL);
	
        SetKeyHandler(mmi_autoam_ignore_missed_msg, KEY_END, KEY_EVENT_DOWN);
        SetLeftSoftkeyFunction(mmi_autoam_entry_message_list_from_idle, KEY_EVENT_UP);
        SetRightSoftkeyFunction(mmi_autoam_ignore_missed_msg, KEY_EVENT_UP);
        ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
        SetCenterSoftkeyFunction(mmi_autoam_entry_message_list_from_idle, KEY_EVENT_DOWN);	
    }
    else
    {
        g_autoam_save_screen = MMI_FALSE;
       // mmi_idle_display();
        mmi_frm_group_close(GRP_ID_AUTOAM_MAIN_ON_IDLE_SCRN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_msg_waiting_ind
 * DESCRIPTION
 *  entry show message screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_msg_waiting_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTOAM_MAIN_ON_IDLE_SCRN, NULL, NULL);
    mmi_frm_group_enter(GRP_ID_AUTOAM_MAIN_ON_IDLE_SCRN, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    mmi_autoam_entry_msg_waiting_ind_init();
  

    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_entry_message_list_from_idle
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_entry_message_list_from_idle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_autoam_entry_message_list();
    g_autoam_idle_display_flag = 0;
    mmi_frm_scrn_close(GRP_ID_AUTOAM_MAIN_ON_IDLE_SCRN, SCR_ID_AUTOAM_MSG_WAITING);


}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_ignore_missed_msg
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_ignore_missed_msg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_autoam_idle_display_flag = 0;
   mmi_frm_group_close(GRP_ID_AUTOAM_MAIN_ON_IDLE_SCRN);		

}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_exit_msg_waiting
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_exit_msg_waiting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_autoam_save_screen == MMI_TRUE)
    {
        //GenericExitScreen(SCR_ID_AUTOAM_MSG_WAITING, mmi_autoam_entry_msg_waiting_ind);
    #if 0
/* under construction !*/
    #endif /* 0 */ 

    }
}

/* temp */


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_highlight_record_incall
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_highlight_record_incall(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef ___AUTOAM_MY_DEBUG___
    /* 1 Register function for left soft key */
    SetLeftSoftkeyFunction(mmi_autoam_entry_record_in_call, KEY_EVENT_DOWN);
    /* 2 Register function for right  key */
    SetKeyHandler(mmi_autoam_entry_record_in_call, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#endif /* ___AUTOAM_MY_DEBUG___ */ 
}

#ifdef __MMI_FTE_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_iconbar_setup
 * DESCRIPTION
 *  Setup icon bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_iconbar_setup(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 iconbar_fg_img[3] = {NULL, NULL, NULL};
    PU8 iconbar_disabled_fg_img[3] = {NULL, NULL, NULL};
    PU8 iconbar_string[3] = {NULL, NULL, NULL};

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    iconbar_fg_img[MMI_AUTOAM_ICON_CALL] = get_image(IMG_GLOBAL_TOOLBAR_CALL);
    iconbar_fg_img[MMI_AUTOAM_ICON_PHB] = get_image(IMG_GLOBAL_TOOLBAR_ADD_CONTACT);
    iconbar_fg_img[MMI_AUTOAM_ICON_DEL] = get_image(IMG_GLOBAL_TOOLBAR_DELETE);

    iconbar_disabled_fg_img[MMI_AUTOAM_ICON_CALL] = get_image(IMG_GLOBAL_TOOLBAR_CALL_DISABLED);
    iconbar_disabled_fg_img[MMI_AUTOAM_ICON_PHB] = get_image(IMG_GLOBAL_TOOLBAR_ADD_CONTACT_DISABLED);
    iconbar_disabled_fg_img[MMI_AUTOAM_ICON_DEL] = get_image(IMG_GLOBAL_TOOLBAR_DELETE_DISABLED);

    iconbar_string[MMI_AUTOAM_ICON_CALL] = (PU8) get_string(STR_GLOBAL_DIAL);
    iconbar_string[MMI_AUTOAM_ICON_PHB] = (PU8) get_string(STR_GLOBAL_SAVE_TO_PHONEBOOK);
    iconbar_string[MMI_AUTOAM_ICON_DEL] = (PU8) get_string(STR_GLOBAL_DELETE);

    wgui_icon_bar_setup(
        MMI_AUTOAM_ICON_TOTAL,
        iconbar_fg_img,
        iconbar_disabled_fg_img,
        iconbar_string,
        mmi_autoam_iconbar_button_hdlr);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_iconbar_button_hdlr
 * DESCRIPTION
 *  Call button handler
 * PARAMETERS
 *  index       [IN]        Message index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_iconbar_button_hdlr(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_autoam_prepare_voice_msg_data())
    {
        return;
    }
    switch (index)
    {
        case MMI_AUTOAM_ICON_CALL:
            mmi_autoam_voice_message_dial();
            break;
        case MMI_AUTOAM_ICON_PHB:
            mmi_autoam_save_name_to_pbk();
            break;
        case MMI_AUTOAM_ICON_DEL:
            mmi_autoam_entry_message_delete_confirm();
            break;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_set_iconbar_state
 * DESCRIPTION
 *  Update icon bar state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_autoam_set_iconbar_state(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (
#ifdef __MMI_MMS_DUAL_SIM__
           (!srv_sim_ctrl_is_available(MMI_SIM2)) &&
#endif 
           (!mmi_bootup_is_sim_valid()))
    {
        state = MMI_FALSE;
    }
    else if (srv_mode_switch_is_network_service_available())
    {
        state = MMI_FALSE;
    }
    else
    {
        state = MMI_TRUE;
    }
    wgui_icon_bar_set_item_enable_state(MMI_AUTOAM_ICON_CALL, state);
    wgui_icon_bar_set_item_enable_state(MMI_AUTOAM_ICON_PHB, MMI_TRUE);
    wgui_icon_bar_set_item_enable_state(MMI_AUTOAM_ICON_DEL, MMI_TRUE);
}

#endif /* __MMI_FTE_SUPPORT__ */ 
/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_def_storage_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  event       [IN]     
 *  
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_autoam_def_storage_hdlr(mmi_event_struct *event)
{	
    srv_fmgr_notification_set_def_storage_event_struct *p_event = NULL;
    p_event = (srv_fmgr_notification_set_def_storage_event_struct*) event;
    if(p_event->state == SRV_FMGR_NOTIFICATION_STATE_AFTER)
    {
        g_autoam_setting.drv_letter = (p_event->drv_letter);
    }                          
	return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_autoam_answer_memory_card_change
 * DESCRIPTION
 *  
 * PARAMETERS
 *  event       [IN]     
 *  
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
mmi_ret mmi_autoam_answer_memory_card_change(mmi_event_struct *event)
{
    FS_HANDLE fd = -1, fs_hdle = -1;
    U8 record_num = 0; 
    U8 msg_idx = 0;
    S32 unread_message_no = 0;

    if((event->evt_id != EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_OUT) && 
        (event->evt_id != EVT_ID_SRV_FMGR_NOTIFICATION_DEV_PLUG_IN)
        )
    {
        return MMI_RET_OK;
    }

    mmi_autoam_file_load_incall(&fd, &record_num);
    
    while( msg_idx < record_num)
    {
        if (mmi_autoam_file_load_single_msg(fd, g_autoam_file_header[msg_idx]) < FS_NO_ERROR)
        {
            return MMI_RET_OK;
        }
        else
        {
            /* Full file name with path*/
            kal_wsprintf((kal_wchar*) g_autoam_in_call_path,  "%c:\\%w%w%w%w",
            g_autoam_message.drv_letter,
            MMI_AUTOAM_DEFAULT_FOLDER_ANSWER_MACHINE,
            MMI_AUTOAM_DEFAULT_FOLDER_MESSAGE,
            g_autoam_message.filename,
            L".wav");
            /* Unread message */
            if (!(g_autoam_message.flag & MMI_AUTOAM_MSG_READ_FLAG))
            {
                fs_hdle = FS_Open(g_autoam_in_call_path, FS_READ_ONLY );
                if(fs_hdle > FS_NO_ERROR)
                {
                    unread_message_no++;
                    FS_Close(fs_hdle); 
                }                

            }
            
            msg_idx++;
           
        }                     

    }
       
    if(unread_message_no == 0)
    {
         wgui_status_icon_bar_hide_icon(STATUS_ICON_AUTOAM_UNREAD); 
    }
    else
    {
        wgui_status_icon_bar_set_icon_display(STATUS_ICON_AUTOAM_UNREAD);
        wgui_status_icon_bar_update();
    }
    if(fd > FS_NO_ERROR)
    {
        FS_Close(fd);
    }
    
    return MMI_RET_OK;
}
#endif /* __MMI_AUTO_ANSWER_MACHINE__ */ 
 
