;**************************************************************
;*     File: ubin_regioninit.s                                     *
;*  Purpose: Application Startup Code                         *
;**************************************************************
;
; This file contains the macro and supporting subroutines to
; copy RO code and RW data from ROM to RAM and zero-initialize
; the ZI data areas in RAM.


; All of this should be set as an assembler argument using the -pd option.
; For example to set support for Angel it would be -pd "MT6218 SETL {TRUE}"
; see also make\comp.mak


;  /* Added by Anthony Chin 10/28/2001. */

 CODE32
 
        AREA RegionInit, CODE, READONLY

        EXPORT INT_InitRegions_for_ubin


; This macro:
; a) copies RO code and/or RW data from ROM at Load$$area$$Base
; to RAM at Image$$area$$Base, of length Image$$area$$Length bytes.
; b) fills with zero the ZI data in RAM at Image$$area$$ZI$$Base, 
; of length Image$$area$$ZI$$Length bytes.
        
        MACRO
        macro_RegionInit $areaname

        LCLS   namecp
        LCLS   copyloadsym
        LCLS   copybasesym
        LCLS   copylensym
        LCLS   zibasesym
        LCLS   zilensym

namecp SETS "$areaname"

copyloadsym SETS  "|Load$$$$":CC:namecp:CC:"$$$$Base|"
copybasesym SETS  "|Image$$$$":CC:namecp:CC:"$$$$Base|"
copylensym  SETS  "|Image$$$$":CC:namecp:CC:"$$$$Length|"
zibasesym   SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Base|"
zilensym    SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Length|"

; The following symbols are generated by the linker.  They are imported 
; WEAKly because they may not all have defined values. Those which are
; undefined will take the value zero.

        IMPORT $copyloadsym, WEAK
        IMPORT $copybasesym, WEAK
        IMPORT $copylensym, WEAK
        IMPORT $zibasesym, WEAK
        IMPORT $zilensym, WEAK
        
        IF :DEF: _SIMULATION

                                        ; For co-sim load,
                                        ; memory is initialized by hardware...   

        ELSE  ; _SIMULATION 

        LDR     r0, =$copyloadsym       ; load address of region
        LDR     r1, =$copybasesym       ; execution address of region
        MOV     r2, r1                  ; copy execution address into r2
        LDR     r4, =$copylensym
        ADD     r2, r2, r4              ; add region length to execution address to...
                                        ; ...calculate address of word beyond end...
                                        ; ... of execution region
        BL      copy

        LDR     r2, =$zilensym          ; get length of ZI region
        LDR     r0, =$zibasesym         ; load base address of ZI region
        MOV     r1, r0                  ; copy base address of ZI region into r1
        ADD     r1, r1, r2              ; add region length to base address to...
                                        ; ...calculate address of word beyond end...
                                        ; ... of ZI region
        BL      zi_init_32

        ENDIF ; _SIMULATION 

        MEND
        
; This macro:
; a) fills with zero the ZI data in RAM at Image$$area$$ZI$$Base, 
; of length Image$$area$$ZI$$Length bytes.

        MACRO
        macro_ZeroInit $areaname
        
        LCLS   namecp
        LCLS   copyloadsym
        LCLS   copybasesym
        LCLS   copylensym
        LCLS   zibasesym
        LCLS   zilensym

namecp SETS "$areaname"

copyloadsym SETS  "|Load$$$$":CC:namecp:CC:"$$$$Base|"
copybasesym SETS  "|Image$$$$":CC:namecp:CC:"$$$$Base|"
copylensym  SETS  "|Image$$$$":CC:namecp:CC:"$$$$Length|"
zibasesym   SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Base|"
zilensym    SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Length|"


; The following symbols are generated by the linker.  They are imported 
; WEAKly because they may not all have defined values. Those which are
; undefined will take the value zero.

        IMPORT $copyloadsym, WEAK
        IMPORT $copybasesym, WEAK
        IMPORT $copylensym, WEAK
        IMPORT $zibasesym, WEAK
        IMPORT $zilensym, WEAK        
        
        LDR     r2, =$zilensym          ; get length of ZI region
        LDR     r0, =$zibasesym         ; load base address of ZI region
        MOV     r1, r0                  ; copy base address of ZI region into r1
        ADD     r1, r1, r2              ; add region length to base address to...
                                        ; ...calculate address of word beyond end...
                                        ; ... of ZI region
        BL      zi_init_32

        MEND

; This macro:
; a) fills with zero the ZI data in RAM at SectionName$$Base, 
; of length SectionName$$Length bytes. 

        MACRO
        macro_ZeroInit_InputSection $inputsection
        
        LCLS   namecp
        LCLS   zibasesym
        LCLS   zilensym

namecp SETS "$inputsection"

zibasesym   SETS  "|":CC:namecp:CC:"$$$$Base|"
zilensym    SETS  "|":CC:namecp:CC:"$$$$Length|"


; The following symbols are generated by the linker.  They are imported 
; WEAKly because they may not all have defined values. Those which are
; undefined will take the value zero.

        IMPORT $zibasesym, WEAK
        IMPORT $zilensym, WEAK        
        
        LDR     r2, =$zilensym          ; get length of ZI region
        LDR     r0, =$zibasesym         ; load base address of ZI region
        MOV     r1, r0                  ; copy base address of ZI region into r1
        ADD     r1, r1, r2              ; add region length to base address to...
                                        ; ...calculate address of word beyond end...
                                        ; ... of ZI region
        BL      zi_init_32

        MEND


; This macro:
; a) copies RO code and/or RW data from ROM at Load$$area$$Base
; to RAM at Image$$area$$Base, of length Image$$area$$Length bytes.

        MACRO
        macro_CopyRW $areaname
        
        LCLS   namecp
        LCLS   copyloadsym
        LCLS   copybasesym
        LCLS   copylensym
        LCLS   zibasesym
        LCLS   zilensym

namecp SETS "$areaname"

copyloadsym SETS  "|Load$$$$":CC:namecp:CC:"$$$$Base|"
copybasesym SETS  "|Image$$$$":CC:namecp:CC:"$$$$Base|"
copylensym  SETS  "|Image$$$$":CC:namecp:CC:"$$$$Length|"
zibasesym   SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Base|"
zilensym    SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Length|"

; The following symbols are generated by the linker.  They are imported 
; WEAKly because they may not all have defined values. Those which are
; undefined will take the value zero.

        IMPORT $copyloadsym, WEAK
        IMPORT $copybasesym, WEAK
        IMPORT $copylensym, WEAK
        IMPORT $zibasesym, WEAK
        IMPORT $zilensym, WEAK

        LDR     r0, =$copyloadsym       ; load address of region
        LDR     r1, =$copybasesym       ; execution address of region
        MOV     r2, r1                  ; copy execution address into r2
        LDR     r4, =$copylensym
        ADD     r2, r2, r4              ; add region length to execution address to...
                                        ; ...calculate address of word beyond end...
                                        ; ... of execution region
        BL      copy

        MEND         

        MACRO
        macro_BackwardCopyRW $areaname
        
        LCLS   namecp
        LCLS   copyloadsym
        LCLS   copybasesym
        LCLS   copylensym
        LCLS   zibasesym
        LCLS   zilensym

namecp SETS "$areaname"

copyloadsym SETS  "|Load$$$$":CC:namecp:CC:"$$$$Base|"
copybasesym SETS  "|Image$$$$":CC:namecp:CC:"$$$$Base|"
copylensym  SETS  "|Image$$$$":CC:namecp:CC:"$$$$Length|"
zibasesym   SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Base|"
zilensym    SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Length|"

; The following symbols are generated by the linker.  They are imported 
; WEAKly because they may not all have defined values. Those which are
; undefined will take the value zero.

        IMPORT $copyloadsym, WEAK
        IMPORT $copybasesym, WEAK
        IMPORT $copylensym, WEAK
        IMPORT $zibasesym, WEAK
        IMPORT $zilensym, WEAK

        LDR     r0, =$copyloadsym       ; load address of region
        LDR     r1, =$copybasesym       ; execution address of region
        MOV     r2, r1                  ; copy execution address into r2
        LDR     r4, =$copylensym
        SUB     r4, r4, #4
        ADD     r0, r0, r4
        ADD     r1, r1, r4
        
        BL      backward_copy

        MEND  
        
; This macro:
; a) copies RW data from ROM at (Load$$area$$Base +Image$$area$$RO$$Length)
; to RAM at Image$$area$$RW$$Base, of length Image$$area$$RW$$Length bytes.
; b) fills with zero the ZI data in RAM at Image$$area$$ZI$$Base, 
; of length Image$$area$$ZI$$Length bytes.        
        MACRO
        macro_RegionInitRWZI $areaname
        
        LCLS   namecp
        LCLS   copyloadsym
        LCLS   rolensym
        LCLS   copybasesym
        LCLS   copylensym
        LCLS   zibasesym
        LCLS   zilensym

namecp SETS "$areaname"

copyloadsym SETS  "|Load$$$$":CC:namecp:CC:"$$$$Base|"
rolensym    SETS  "|Image$$$$":CC:namecp:CC:"$$$$RO$$$$Length|"
copybasesym SETS  "|Image$$$$":CC:namecp:CC:"$$$$RW$$$$Base|"
copylensym  SETS  "|Image$$$$":CC:namecp:CC:"$$$$RW$$$$Length|"
zibasesym   SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Base|"
zilensym    SETS  "|Image$$$$":CC:namecp:CC:"$$$$ZI$$$$Length|"

; The following symbols are generated by the linker.  They are imported 
; WEAKly because they may not all have defined values. Those which are
; undefined will take the value zero.

        IMPORT $copyloadsym, WEAK
        IMPORT $rolensym, WEAK
        IMPORT $copybasesym, WEAK
        IMPORT $copylensym, WEAK
        IMPORT $zibasesym, WEAK
        IMPORT $zilensym, WEAK

        LDR     r0, =$copyloadsym       ; load address of region
        LDR	r1, =$rolensym		; ro length
        ADD     r0,r1			; rw load base
        LDR     r1, =$copybasesym       ; execution address of region
        MOV     r2, r1                  ; copy execution address into r2
        LDR     r4, =$copylensym
	CMP	r4, #0
        SUBHI   r4, r4, #4
        ADDHI   r0, r0, r4
        ADDHI   r1, r1, r4
        BLHI    backward_copy     
        LDR     r2, =$zilensym          ; get length of ZI region
        LDR     r0, =$zibasesym         ; load base address of ZI region
        MOV     r1, r0                  ; copy base address of ZI region into r1
        ADD     r1, r1, r2              ; add region length to base address to...
                                        ; ...calculate address of word beyond end...
                                        ; ... of ZI region
        BL      zi_init_32
        MEND         

;
; NoteXXX: INT_InitXXXRegions is called from boot.s to initialize the specified execution regions.
;          The register r12 will be used in the bootarm.s. We should be careful not to
;          overwrite r12.
;




;
;/*************************************************************************/
;/*                                                                       */
;/* FUNCTION                                                              */
;/*   INT_InitRegions_for_ubin                                                     */
;/*                                                                       */
;/* DESCRIPTION                                                           */
;/*   Initialize the RW/ZI regions                                        */
;/*                                                                       */
;/* INPUTS                                                                */
;/*   None                                                                */
;/*                                                                       */
;/* OUTPUTS                                                               */
;/*   None                                                                */
;/*************************************************************************/
; VOID INT_InitRegions_for_ubin(VOID)
; {
;
INT_InitRegions_for_ubin

   MOV   r8,lr

    IF :DEF:__UPDATE_BINARY_FILE__

    macro_RegionInit UB_EXTSRAM
    macro_ZeroInit UB_DYNAMIC_CACHEABLE_EXTSRAM_DEFAULT_NONCACHEABLE_ZI_MMIPOOL
    macro_ZeroInit UB_DYNAMIC_CACHEABLE_EXTSRAM_DEFAULT_NONCACHEABLE_ZI
	macro_BackwardCopyRW UB_DYNAMIC_CACHEABLE_EXTSRAM_DEFAULT_NONCACHEABLE_RW
	macro_RegionInit UB_CACHED_EXTSRAM
		
	IF :DEF:__GADGET_SUPPORT__
    macro_RegionInit UB_EXTSRAM_GADGET
    ENDIF ;__GADGET_SUPPORT__
    
    macro_BackwardCopyRW UB_DYNAMIC_CACHEABLE_EXTSRAM_DEFAULT_CACHEABLE_RW
    
    IF :LNOT: :DEF: __DCM_WITH_COMPRESSION_MAUI_INIT__
    macro_ZeroInit UB_DYNAMIC_CACHEABLE_EXTSRAM_DEFAULT_CACHEABLE_ZI_MMIPOOL
    ENDIF ;__DCM_WITH_COMPRESSION_MAUI_INIT__
    
    macro_ZeroInit UB_DYNAMIC_CACHEABLE_EXTSRAM_DEFAULT_CACHEABLE_ZI

    ENDIF  ;__UPDATE_BINARY_FILE__


   BX    r8                                 ; Return to caller
; }
;

; --- copy and zi_init subroutines

; copy is a subroutine which copies a region, from an address given by 
; r0 to an address given by r1. The address of the word beyond the end
; of this region is held in r2. r3 is used to hold the word being copied. 
copy
        CMP     r1, r2                 ; loop whilst r1 < r2
        LDRLO   r3, [r0], #4
        STRLO   r3, [r1], #4
        BLO     copy
        MOV     pc, lr                 ; return from subroutine copy
        
; backward_copy is a subroutine which copies a region, from an address given by 
; r0 to an address given by r1. The address of the word beyond the end
; of this region is held in r2. r3 is used to hold the word being copied. 
backward_copy
        CMP     r1, r2                 ; loop whilst r1 < r2
        LDRGE   r3, [r0], #-4
        STRGE   r3, [r1], #-4
        BGE     backward_copy
        MOV     pc, lr                 ; return from subroutine copy

; zi_init is a subroutine which zero-initialises a region,
; starting at the address in r0. The address of the word
; beyond the end of this region is held in r1.
zi_init
        MOV     r2, #0
        CMP     r0, r1                 ; loop whilst r0 < r1
        STRLO   r2, [r0], #4
        BLO     zi_init 
        MOV     pc, lr                 ; return from subroutine zi_init

; zi_init_32 is a subroutine which zero-initialises a region,
; starting at the address in r0. The length is held in r2.
; the address of the 4-byte beyound the end of this region is 
; held in r1. set 32 bytes zero per loop.
zi_init_32
        STMDB   sp!, {r8-r10}          ; save extra working register
        MOV     r3, #0
        MOV     r8, #0
        MOV     r9, #0
        MOV     r10, #0
        SUBS    r2, r2, #0x20          ; loop while r2 > 32

zi_init_32_loop
        STMCSIA r0!, {r3,r8-r10}
        STMCSIA r0!, {r3,r8-r10}
        SUBCSS  r2, r2, #0x20          ; loop while r2 > 32
        BCS     zi_init_32_loop
        LDMIA   sp!, {r8-r10}          ; restore extra working register
        B       zi_init
        MOV     pc, lr                 ; return from subroutine zi_init
        END


