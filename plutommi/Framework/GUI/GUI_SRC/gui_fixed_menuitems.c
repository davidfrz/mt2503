/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   gui_fixed_menuitems.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   Menu items in fixed menu - UI component
 *
 *   [Text menu item]
 *   [Icontext menu item]
 *   [Icontext-list menu item]
 *   [Twostate menu item]
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include 
 *****************************************************************************/
#include "MMI_features.h"
#include "gui_fixed_menuitems.h"
#include "kal_non_specific_general_types.h"
#include "gdi_include.h"
#include "wgui.h"
#include "CustMenuRes.h"
#include "ScreenRotationGprot.h"
#include "wgui_fixed_menuitems.h"
#include "gui_font_size.h"
#include "gui_theme_struct.h"
#include "gui_windows.h"
#include "gui_config.h"
#include "gui_typedef.h"
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "CustThemesRes.h"
#include "gui.h"
#include "gui_data_types.h"
#include "gui_switch.h"
#include "gui_effect_oem.h"
#include "gdi_datatype.h"
#include "gui_fixed_menus.h"
#include "mmi_frm_input_gprot.h"
#include "CustDataProts.h"
#include "gdi_const.h"
#include "gui_themes.h"
#include "gui_scrollbars.h"
#include "GlobalConstants.h"
#include "string.h"
#include "wgui_fixed_menus.h"
#include "PixcomFontEngine.h"
#include "Unicodexdcl.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "wgui_include.h"
#include "mmi_frm_history_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_at_util_gprot.h"
#include "gui_main_menu_post_oem.h"
#include "wgui_inline_edit.h"
#include "wgui_categories_enum.h"
#include "wgui_draw_manager.h"
#include "gui_menu_post_oem.h"
#include "mmi_rp_app_uiframework_def.h"
#include "wgui_categories_util.h"
#include "CustDataRes.h"
#include "app_mem_med.h"


#if defined(__MAUI_SOFTWARE_LA__) && defined(__MTK_TARGET__)
#include "SST_sla.h"
#define gui_swla_log_start(log)     SLA_CustomLogging(log, SA_start)
#define gui_swla_log_stop(log)     SLA_CustomLogging(log, SA_stop)
#else/*defined(__MAUI_SOFTWARE_LA__) && defined(__MTK_TARGET__)*/
#define gui_swla_log_start(log)
#define gui_swla_log_stop(log)
#endif/*defined(__MAUI_SOFTWARE_LA__) && defined(__MTK_TARGET__)*/

/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/ 
/* current scrolling text */ 
scrolling_text gui_current_scroll_text[FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS]; 

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
/* For list highlighter effects */
#if  0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
#endif
MMI_BOOL gblock_list_effect = 0;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

MMI_BOOL gblock_list_animation_highlight = MMI_FALSE;

static MMI_BOOL g_gui_menuitem_need_scroll = MMI_FALSE;

#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__


static gui_animation_with_background_struct g_gui_animation_with_background_cntx;
static gui_animation_with_background_struct * const anim_with_bkg_p = &g_gui_animation_with_background_cntx;


//static void UI_dummy_scrolling_text_draw_background(S32 x1, S32 y1, S32 x2, S32 y2);
#ifndef __MMI_UI_MENU_SLIM__
static MMI_BOOL gui_filled_area_is_animation(UI_filled_area *f);
static void gui_scroll_text_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f);
#else/*__MMI_UI_MENU_SLIM__*/
#define gui_scroll_text_draw_animated_effect_filler(_arg1, _arg2, _arg3, _arg4, _arg5) 
#define gui_filled_area_is_animation(_arg) 
#endif/*__MMI_UI_MENU_SLIM__*/

//#define scrolling_text_draw_two_line_background(_arg1, _arg2, _arg3, _arg4) gui_show_two_line_background(_arg1, _arg2, _arg3, _arg4)
static void gui_fixed_icontext_menuitem_scroll_handler(void);
static void gui_fixed_icontext_menuitem_get_text_dimension(fixed_icontext_menuitem_type *mi);//, UI_string_type text, S32 *width, S32 *height);
static void scrolling_text_draw_icontext_single_line_background(S32 x1,S32 y1,S32 x2,S32 y2);
static void scrolling_text_draw_twostate_single_line_background(S32 x1,S32 y1,S32 x2,S32 y2);
static void scrolling_text_draw_icontext_list_single_line_background(S32 x1,S32 y1,S32 x2,S32 y2);

//add by huking
static MMI_BOOL gui_is_menuitem_show_hint_two_line(void);
static void gui_list_menuitem_adjust_scroll_width(void *m);
static void gui_execute_list_menu_item_resize_function(void);
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
static void gui_menu_replace_menuitem_transparent_filler_by_theme(void *item); 
#else/*__MMI_UI_TRANSPARENT_EFFECT__*/
#define gui_menu_replace_menuitem_transparent_filler_by_theme(_arg)
#endif/*__MMI_UI_TRANSPARENT_EFFECT__*/

#ifdef  __MMI_MAINLCD_320X480__
static void gui_get_matrix_menu_highlight_filler(UI_filled_area *f);
#else/*__MMI_MAINLCD_320X480__*/
#define gui_get_matrix_menu_highlight_filler(_arg)
#endif/*__MMI_MAINLCD_320X480__*/

static MMI_BOOL gui_is_menuitem_show_animation_when_hilited(S32 flags);
static void gui_adjust_menuitem_center_align_icon_position(void *item, PU8 _icon);


//end huking add


static void gui_show_animation_with_background_image(S32 x, S32 y, PU8 animation, PU8 anim_bg_image, gdi_handle *animation_handle);
static void gui_show_animation_with_background_filler(S32 x, S32 y, PU8 animation, UI_filled_area *background_filler, gdi_handle *animation_handle);	


/*
* Global function 
*/
static void gui_get_fixed_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext,S32 Is_two_state);
/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
/*
 * current UI menuitem theme
 */
UI_menuitem_theme* current_menuitem_theme = NULL;
//UI_menuitem_theme *current_fixed_text_menuitem_theme = NULL;
//UI_fixed_icontext_menuitem_theme *current_fixed_icontext_menuitem_theme = NULL;
UI_fixed_icontext_list_menuitem_theme *current_fixed_icontext_list_menuitem_theme = NULL;
//UI_fixed_twostate_menuitem_theme *current_fixed_twostate_menuitem_theme = NULL;

/* 
 * tempoary highlight fillers for the transparent color effect 
 * in HIGHLIGHTER_COLOR_OPACITY_VALUE, defined in gui_fixed_menuitems.h
 */
// TODO: REMOVE THESE, SHOULD CHANGE THE HIGHLIGHT FILLER ALPHA VALUE DIRECTLY
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
UI_filled_area menuitem_transparent_filled_area;

//UI_filled_area fixed_icontext_menuitem_transparent_filled_area;
//UI_filled_area fixed_icontext_list_menuitem_transparent_filled_area;
//UI_filled_area fixed_twostate_menuitem_transparent_filled_area;
//UI_filled_area fixed_two_line_menuitem_transparent_filled_area;
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

#if 0//(defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
/* under construction !*/
/* under construction !*/
#endif

/* text scrolling related data */
#define UI_text_menuitem_scroll_time   UI_TEXT_MENUITEM_SCROLL_TIME
#define UI_text_menuitem_scroll_size   UI_TEXT_MENUITEM_SCROLL_SIZE
#define UI_text_menuitem_scroll_gap    UI_TEXT_MENUITEM_SCROLL_GAP
#define UI_text_menuitem_scroll_pause  UI_TEXT_MENUITEM_SCROLL_PAUSE
//S32 UI_text_menuitem_scroll_time = UI_TEXT_MENUITEM_SCROLL_TIME;
//S32 UI_text_menuitem_scroll_size = UI_TEXT_MENUITEM_SCROLL_SIZE;
//S32 UI_text_menuitem_scroll_gap = UI_TEXT_MENUITEM_SCROLL_GAP;
//S32 UI_text_menuitem_scroll_pause = UI_TEXT_MENUITEM_SCROLL_PAUSE;

UI_filled_area fixed_single_line_menuitem_filled_area;
/* Text scrolling related functions within the menu item */
fixed_icontext_list_menuitem *GUI_current_fixed_icontext_list_menuitem_common_data = NULL;
fixed_icontext_list_menuitem_type *GUI_current_fixed_icontext_list_menuitem_data = NULL;

U8 GUI_current_fixed_icontext_list_menuitem_text_is_scroll[FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS];
U8 GUI_current_fixed_icontext_list_menuitem_scroll = 0;
//U8 GUI_current_fixed_icontext_list_menuitem_scroll_direction;
S32 GUI_current_fixed_icontext_list_menuitem_x;
S32 GUI_current_fixed_icontext_list_menuitem_y;
S32 GUI_current_fixed_icontext_list_menuitem_scroll_counter = 0;

/* Current text column for marqueeing. Auto selected with UI_MENUITEM_AUTO_CHOOSE_MARQUEE. */
S32 GUI_current_fixed_icontext_list_menuitem_column = 0;
//UI_string_type GUI_current_fixed_icontext_list_menuitem_scroll_text = NULL;
//UI_string_type GUI_current_fixed_icontext_list_menuitem_scroll_text_end = NULL;

#if  0
/* under construction !*/
#endif

extern PU8 MMI_mm_animation;

extern gui_effect_struct    *g_slide_effect;

#if defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)
extern gui_list_smooth_scrolling_by_pen_state_enum g_gui_ssp_state;
#endif/*GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN*/

extern S32 gdi_anim_get_current_frame_number(gdi_handle serial_handle);
#if defined(__ATV_SMS_SUPPORT__)
extern gdi_handle g_gui_ssp_static_layer; 
#endif/*#if defined(__ATV_SMS_SUPPORT__)*/

#if defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_TOUCH_SCREEN__)
extern void mmi_two_line_translate_pen_event(S32 x, S32 y, mmi_pen_event_type_enum pen_event,gui_list_pen_enum *menuitem_event);
#endif /* defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_TOUCH_SCREEN__) */

extern MMI_BOOL g_current_display_half_menuitem;

#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
#define GUI_TWO_LINE_TEXT_ICON_GAP 5
extern void line_scrolling_text_timer_handler(void);
#endif/*(defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)*/ 

#define GUI_MENUITEM_DATA_LEFT_GAP 5
static S32 gui_menuitem_dummy_checkbox_clicked_callback(S32 item_index);
static S32 gui_menuitem_dummy_checkbox_get_image_callback(S32 item_index, PU8 *checkbox_image);

static void gui_menuitem_icontext_show_checkbox(fixed_icontext_menuitem *m, S32 x1, S32 y1);
static void gui_menuitem_icontext_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_menuitem *m, S32 x1, S32 y1);

static void gui_menuitem_icontext_list_show_checkbox(fixed_icontext_list_menuitem *m, S32 x1, S32 y1);
static void gui_menuitem_icontext_list_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_list_menuitem *m, S32 x1, S32 y1);

static void gui_menuitem_adjust_text_clip_for_right_gap(void *common_item_data);

#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
static S32 gui_menuitem_is_image_highlight(void *common_item_data);
#else/*__MMI_UI_LIST_SLIDE_EFFECT__*/
#define gui_menuitem_is_image_highlight(_arg) 
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/

static void gui_menuitem_draw_list_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f, MMI_BOOL isAnimate, MMI_BOOL onTran);

#ifndef __MMI_UI_MENU_SLIM__
static void gui_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f);
#else/*__MMI_UI_MENU_SLIM__*/
 #define gui_draw_animated_effect_filler(_arg1, _arg2, _arg3, _arg4, _arg5) 
#endif/*__MMI_UI_MENU_SLIM__*/

static void gui_get_fixed_menuitem_flags_int(void *item, void *common_item_data, U32* flags, U32* flags_ext);
static void gui_get_menu_top_and_bottom_position(void* common_item_data, S32* menu_y1, S32* menu_y2);

#define scrolling_text_draw_two_line_background gui_show_two_line_background
void gui_menuitem_set_text_position(void *m, S32 x, S32 y);

//static void gui_menuitem_set_icon_position(void *m, S32 x, S32 y);
//void gui_menuitem_set_icon_position(void *m, S32 x, S32 y);
static void gui_show_two_line_icontext_list_menuitem(void *item, void *common_item_data, UI_filled_area **f);

#ifdef  __MMI_UI_HINTS_IN_MENUITEM__
static MMI_BOOL gui_menuitem_has_hint(gui_common_menuitem_base_struct *m, U32 flags);
#endif/*__MMI_UI_HINTS_IN_MENUITEM__*/

#ifdef  __MMI_CAT203_SUPPORT__
GetUnderLineFuncPtr g_gui_list_get_underline = NULL;
#endif/*__MMI_CAT203_SUPPORT__*/

//UI_font_type g_gui_list_data_font = NULL;
//S32 g_gui_list_data_gap = 0;
/* this is used to show different text color for icontext list menuitem */
#if   0
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

GetMenuitemFlags g_gui_list_get_menuitem_flags = NULL;

#if defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)|| !defined(__MMI_UI_MENU_SLIM__)
static S32 xstart_effect, ystart_effect, xend_effect, yend_effect;
static S32 list_highlight_effect_current_frame = 0;
#endif/*defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)|| !defined(__MMI_UI_MENU_SLIM__)*/

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
static S32 list_highlight_effect_times = 0;
#endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/

#ifndef __MMI_UI_MENU_SLIM__
static MMI_BOOL gui_list_in_scroll = MMI_FALSE;
#endif/*__MMI_UI_MENU_SLIM__*/

#if defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)|| !defined(__MMI_UI_MENU_SLIM__)
static void *ghighlight_item;
static void *ghighlight_common_item_data;
static S32 gstartX1, gstartY1;
#endif/*defined(__MMI_UI_LIST_HIGHLIGHT_EFFECTS__)|| !defined(__MMI_UI_MENU_SLIM__)*/

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
static S32 is_draw_next_frame_list_highlight_effect = 0;
#endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/

void (*gui_call_menuitem_scroll) (void);

#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__)
extern MMI_BOOL pen_down_in_list;
extern MMI_BOOL g_gui_ssp_launch;
#endif /*__MMI_WEARABLE_DEVICE__*/

/* Pop up description related data  */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

#ifdef __MMI_UI_HINTS_IN_MENUITEM__

/*****************************************************************************
 * FUNCTION
 *  UI_dummy_get_current_pop_up_description_string
 * DESCRIPTION
 *  Dummy function to get popup description string.
 * PARAMETERS
 *  void
 * RETURNS
 *  NULL
 *****************************************************************************/
UI_string_type UI_dummy_get_current_pop_up_description_string(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return NULL;
}

#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 


// intern use
/*****************************************************************************
 * FUNCTION
 *  gui_list_set_alpha_blending_layer_ex
 * DESCRIPTION
 *gui_list_set_alpha_blending_layer_ex.
 * PARAMETERS
 *  void
 * RETURNS
 *  NULL
 *****************************************************************************/
gdi_handle gui_list_set_alpha_blending_layer_ex(U32 flags, MMI_BOOL ext)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MMI_fixed_list_menu.alpha_blend_layer_handle)
    {
        return gdi_set_alpha_blending_source_layer(MMI_fixed_list_menu.alpha_blend_layer_handle);
    }
    else if (ext)
    {
        if ((flags & UI_MENUITEM_STATE_FOCUSSED 	
			&& !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
			#ifndef __MMI_UI_MENU_SLIM__
			|| g_slide_effect->in_flatten
			#endif/*__MMI_UI_MENU_SLIM__*/
			)
        {
            gdi_layer_get_active(&old_alpha_layer);
           	return gdi_set_alpha_blending_source_layer(old_alpha_layer);
        }
    }
    return old_alpha_layer;
}

#define gui_list_set_alpha_blending_layer() gui_list_set_alpha_blending_layer_ex(0, MMI_FALSE)

/*****************************************************************************
 * FUNCTION
 *  gui_list_reset_alpha_blending_layer
 * DESCRIPTION
 *gui_list_reset_alpha_blending_layer.
 * PARAMETERS
 *  void
 * RETURNS
 *  NULL
 *****************************************************************************/
void gui_list_reset_alpha_blending_layer(gdi_handle old_alpha_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (old_alpha_layer)
    {
        gdi_set_alpha_blending_source_layer(old_alpha_layer);
    }
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
static BOOL block_transparency = FALSE;
//UI_filled_area non_transparent_focussed_filler;
UI_filled_area *backup_focussed_filler;
S32 transparency_in_list = 0;

/*****************************************************************************
 * FUNCTION
 *  gui_block_transparency_effect
 * DESCRIPTION
 *  Block the transparency effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_block_transparency_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    block_transparency = TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_unblock_transparency_effect
 * DESCRIPTION
 *  Unblock the transparency effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_unblock_transparency_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    block_transparency = FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_enable_transparent_effect
 * DESCRIPTION
 *  Enable the transparent effect for the icontext menu item.
 * PARAMETERS
 *  m           [IN]    common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_enable_transparent_effect(void* common_item_data)//(fixed_icontext_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem* m = (gui_common_menuitem*)common_item_data;  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (block_transparency)
    {
        return;
    }

    /* to enable transparency only when it is required */
    if (transparency_in_list)
    {
        m->focussed_filler = backup_focussed_filler;
    }
    transparency_in_list = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_disable_transparent_effect
 * DESCRIPTION
 *  Disable the transparent effect for the icontext menu item.
 * PARAMETERS
 *  m           [IN]    common icontext menu item object     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_disable_transparent_effect(void*common_item_data)//(fixed_icontext_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem* m = (gui_common_menuitem*)common_item_data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (block_transparency)
    {
        return;
    }
    /* disable transparency only when it is enabled */
    if (m->focussed_filler->flags & UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR)
    {
        transparency_in_list = 1;
        backup_focussed_filler = m->focussed_filler;
       // non_transparent_focussed_filler = *backup_focussed_filler;
        m->focussed_filler = backup_focussed_filler;
        m->focussed_filler->flags = m->focussed_filler->flags & ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
    }
}

#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_dummy_checkbox_clicked_callback
 * DESCRIPTION
 *  Dummy function of checkbox clicked callback.
 * PARAMETERS
 *  item_index       [IN]       item index
 * RETURNS
 *  MMI_TRUE
 *****************************************************************************/
static S32 gui_menuitem_dummy_checkbox_clicked_callback(S32 item_index)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item_index);
    
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_dummy_checkbox_get_image_callback
 * DESCRIPTION
 *  Dummy function of checkbox get image callback.
 * PARAMETERS
 *  item_index      [IN]        item index
 *  checkbox_image  [IN]        image data
 * RETURNS
 *  MMI_TRUE
 *****************************************************************************/
static S32 gui_menuitem_dummy_checkbox_get_image_callback(S32 item_index, PU8 *checkbox_image)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item_index);
    *checkbox_image = (PU8)GetImage(CHECKBOX_OFF_IMAGE_ID);
    
    return MMI_TRUE;
}


/* Fixed menuitem dummy functions: Do not delete any of these functions */

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_measure_function
 * DESCRIPTION
 *  Dummy item measure function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item      
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height    
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_get_length_function(void *item, void *common_item_data, S32 *width)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(width);
}


/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_measure_function
 * DESCRIPTION
 *  Dummy item measure function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item      
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height    
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_measure_function(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(width);
    UI_UNUSED_PARAMETER(height);
}

/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_function
 * DESCRIPTION
 *  Dummy item function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item       
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_function(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
}

/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_function_with_2_s32
 * DESCRIPTION
 *  Dummy item function.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item       
 * RETURNS
 *  void
 *****************************************************************************/
void UI_fixed_menuitem_dummy_function_with_2_S32(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  UI_fixed_menuitem_dummy_pen_function
 * DESCRIPTION
 *  Dummy menu item pen handler.
 * PARAMETERS
 *  item                    [IN]        private menu item
 *  common_item_data        [IN]        common menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE.
 *****************************************************************************/
MMI_BOOL UI_fixed_menuitem_dummy_pen_function(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    UI_UNUSED_PARAMETER(common_item_data);
    UI_UNUSED_PARAMETER(pen_event);
    UI_UNUSED_PARAMETER(x);
    UI_UNUSED_PARAMETER(y);
    UI_UNUSED_PARAMETER(menuitem_event);
    UI_UNUSED_PARAMETER(menuitem_param);
    return MMI_FALSE;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 *
 * TEXT MENUITEM                                                             
 *                                                                           
 * implemented by the icontext menuitem                                      
 *
 *****************************************************************************/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_text_menuitem
 * DESCRIPTION
 *  Measure a text menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private text menu item object
 *  common_item_data        [IN]        common text menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_get_fixed_text_length_menuitem(void *item, void *common_item_data, S32 *width)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 sh;//sw, 
   // UI_string_type _text;    
   // fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //_text = mi->item_text;
	gui_measure_string(((fixed_icontext_menuitem_type*) item)->item_text, width, &sh);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


/*****************************************************************************
 *
 * ICONTEXT MENUITEM                                                             
 *                                                                           
 *                                
 *
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_menuitem_current_theme
 * DESCRIPTION
 *  Apply the current theme to an icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_menuitem_current_theme(void *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_icontext_menuitem_theme(m, current_menuitem_theme);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_menuitem_theme
 * DESCRIPTION
 *  Apply the given theme to an icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  t           [IN]        icontext menu item theme
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_menuitem_theme(void *item, UI_menuitem_theme *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_common_menuitem *m = (gui_common_menuitem*)item;
	
    m->disabled_filler = t->disabled_filler;
    m->disabled_text_color = t->disabled_text_color;
    m->flags |= t->flags;
    m->focussed_filler = t->focussed_filler;

	gui_menu_replace_menuitem_transparent_filler_by_theme(item);
#if  0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
    m->focussed_text_color = t->focussed_text_color;
    m->normal_filler = t->normal_filler;
    m->normal_text_color = t->normal_text_color;
    m->selected_filler = t->selected_filler;
    m->selected_text_color = t->selected_text_color;
    m->text_font = t->text_font;
}


/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_icontext_menuitem
 * DESCRIPTION
 *  Create a common icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  width       [IN]        width
 *  height      [IN]        height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_icontext_menuitem(fixed_icontext_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	memset(m, 0, sizeof(fixed_icontext_menuitem));
	
    m->width = width;
    m->height = height;
	
    gui_set_fixed_icontext_menuitem_current_theme(m);

	m->scroll_width = width;

    m->checkbox_clicked_callback = gui_menuitem_dummy_checkbox_clicked_callback;
    m->checkbox_get_image_callback = gui_menuitem_dummy_checkbox_get_image_callback;    
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

/*****************************************************************************
 * FUNCTION
 *  gui_resize_fixed_icontext_menuitem
 * DESCRIPTION
 *  Resize a common icontext menu item.
 * PARAMETERS
 *  m           [IN]        common icontext menu item object
 *  width       [IN]        new width
 *  height      [IN]        new height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_resize_fixed_icontext_menuitem(void *m0, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem *m = (gui_common_menuitem*)m0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->width = width;
    m->height = height;

	gui_list_menuitem_adjust_scroll_width(m);
	
	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif//0 
    /* keep the text right clip spacing for list menu image highlight */
    if (MMI_current_menu_type == LIST_MENU)
    {

#ifdef __MMI_FTE_SUPPORT__
        if ( !(MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT))
        {
            m->scroll_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            m->scroll_width -= 1;
        }
#else/*__MMI_FTE_SUPPORT__*/
        /* adjust the scrolling width if image highlight is used */
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
        if (gui_menuitem_is_image_highlight(m) || !(MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT))
#else/*__MMI_UI_LIST_SLIDE_EFFECT__*/
        if (!(MMI_fixed_list_menu.flags & UI_LIST_MENU_INLINE_EDIT))
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/
        {
            m->scroll_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            m->scroll_width -= 1;
        }
#endif/*__MMI_FTE_SUPPORT__*/
    }
}


/* Text scrolling related functions within the menu item */
fixed_icontext_menuitem *GUI_current_fixed_icontext_menuitem_common_data = NULL;
fixed_icontext_menuitem_type *GUI_current_fixed_icontext_menuitem_data = NULL;
static MMI_BOOL GUI_current_fixed_icontext_menuitem_scroll = MMI_FALSE;
//U8 GUI_current_fixed_icontext_menuitem_scroll_direction;
S32 GUI_current_fixed_icontext_menuitem_x;
S32 GUI_current_fixed_icontext_menuitem_y;
S32 GUI_current_fixed_icontext_menuitem_y2;
S32 GUI_current_fixed_icontext_menuitem_x2;
S32 GUI_current_fixed_icontext_menuitem_scroll_counter = 0;
UI_string_type GUI_current_fixed_icontext_menuitem_scroll_text = NULL;
UI_string_type GUI_current_fixed_icontext_menuitem_scroll_text_end = NULL;


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_background_filler
 * DESCRIPTION
 *  Draw background filler for the scrolling menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 *  f             [IN]        background filler
 *  has_round_rect  [IN]  the menu item has UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT flags
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_background_filler(
        S32 x1,
        S32 y1, 
        S32 x2, 
        S32 y2, 
        UI_filled_area *f, 
        MMI_BOOL has_round_rect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_SLIM__	
    S32 count;
#endif/*__MMI_UI_MENU_SLIM__*/
    gdi_handle old_alpha_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_alpha_layer = gui_list_set_alpha_blending_layer();

/*#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__)
if (MMI_TRUE != pen_down_in_list)
	f = NULL;
#endif /*defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__)*/

#ifndef __MMI_UI_MENU_SLIM__
    if (gui_filled_area_is_animation(f))
    {
        gdi_image_get_frame_count(f->b, &count);
        if (count >= 1)
        {
            gui_scroll_text_draw_animated_effect_filler(x1, y1, x2, y2, f);
        }                    
    }            
    else
#endif/*__MMI_UI_MENU_SLIM__*/		
		if (f)
    {
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__    
        if (has_round_rect)
        {
            gui_draw_filled_area(x1, y1 + 1, x2, y2 - 1, f);
        }
        else
#endif/*__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__*/			
       // {
            gui_draw_filled_area(x1, y1, x2, y2, f);
       // }
    }
    else
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    }

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
}


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_icontext_single_line_background
 * DESCRIPTION
 *  Draw background for the scrolling single line menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_icontext_single_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_filled_area *f;
 //   fixed_icontext_menuitem *m;
    MMI_BOOL has_round_rect = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //m = (fixed_icontext_menuitem*)MMI_fixed_list_menu.common_item_data;
//	m = (fixed_icontext_menuitem*)GUI_current_fixed_icontext_menuitem_common_data;

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
	if (GUI_current_fixed_icontext_menuitem_common_data->hide_function)
    {
        GUI_current_fixed_icontext_menuitem_common_data->hide_function(x1, y1, x2, y2);
        return;
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
	
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    f = &fixed_single_line_menuitem_filled_area;

#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    if ((MMI_current_menu_type == LIST_MENU) && 
        (GUI_current_fixed_icontext_menuitem_data->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT))
    {
        has_round_rect = MMI_TRUE;
    }
#endif/*__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__*/

	gui_get_matrix_menu_highlight_filler(f);	
#if  0//__MMI_MAINLCD_320X480__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_MAINLCD_320X480__

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
#if defined(__MMI_CASCADED_OPTION_MENU__)
    if (g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID)
    { 
        #if 0  
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif//0
		gui_list_is_hide_menu_callback_executed(x1, y1, x2, y2);
    }
#endif/*__MMI_CASCADED_OPTION_MENU__*/	
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

    scrolling_text_draw_background_filler(
        GUI_current_fixed_icontext_menuitem_x,
        GUI_current_fixed_icontext_menuitem_y,
        GUI_current_fixed_icontext_menuitem_x2,
        GUI_current_fixed_icontext_menuitem_y2, 
        f,
        has_round_rect);

    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_icontext_list_single_line_background
 * DESCRIPTION
 *  Draw background for the scrolling single line menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_icontext_list_single_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //UI_filled_area *f;
    fixed_icontext_list_menuitem m;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m = MMI_fixed_icontext_list_menuitem;

    if (m.ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT)
    {
        /* verify two line menuitem highlight image dimension */
        m.height *= 2;
        
       // m.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
  //      m.focussed_without_sc_filler = current_MMI_theme->menuitem_two_line_highlight_filler;//menuitem_two_line_highlight_without_scroll_filler

      //  f = m.focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &m);
        if (current_MMI_theme->menuitem_two_line_highlight_filler)//(m.focussed_filler)
        {
            fixed_single_line_menuitem_filled_area = *current_MMI_theme->menuitem_two_line_highlight_filler;//m.focussed_filler;
        }
    }   
    //f = &fixed_single_line_menuitem_filled_area;
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__    
#if defined(__MMI_CASCADED_OPTION_MENU__)
    if (g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID)
    {
       #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif//0
		gui_list_is_hide_menu_callback_executed(x1, y1, x2, y2);
    }
#endif/*__MMI_CASCADED_OPTION_MENU__*/
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

    scrolling_text_draw_background_filler(
        GUI_current_fixed_icontext_list_menuitem_x,
        GUI_current_fixed_icontext_list_menuitem_y,
        GUI_current_fixed_icontext_list_menuitem_x + MMI_fixed_icontext_list_menuitem.width - 1,
        GUI_current_fixed_icontext_list_menuitem_y + m.height - 1, 
        &fixed_single_line_menuitem_filled_area,
        MMI_FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_scroll_text_handler
 * DESCRIPTION
 *  Scroll text handler of the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_scroll_text_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // U32 flags = GUI_current_fixed_icontext_menuitem_common_data->flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(GUI_current_fixed_icontext_menuitem_common_data->flags & UI_MENUITEM_MARQUEE_SCROLL) ||
		!GUI_current_fixed_icontext_menuitem_scroll)
    {
        return;
    }
/*
    if (!GUI_current_fixed_icontext_menuitem_scroll)
    {
        return;
    }
*/
#if   0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    

#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif/*__MMI_UI_MENU_SLIM__*/

#if defined(__MMI_MAINLCD_320X480__)
#ifdef __MMI_MATRIX_MAIN_MENU_OPTIMIZE__
    if (MMI_current_menu_type == MATRIX_MENU)
    {
        gui_show_fixed_icontext_menuitem(
            (void*)GUI_current_fixed_icontext_menuitem_data,
            (void*)GUI_current_fixed_icontext_menuitem_common_data,
            GUI_current_fixed_icontext_menuitem_x,
            GUI_current_fixed_icontext_menuitem_y);
    }
#endif/*__MMI_MATRIX_MAIN_MENU_OPTIMIZE__*/
#endif/*__MMI_MAINLCD_320X480__*/

    gui_handle_scrolling_text(&gui_current_scroll_text[0]);
    
   // flags |= GUI_current_fixed_icontext_menuitem_data->flags;
    GUI_current_fixed_icontext_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

	gui_menu_disable_transparent_effect_when_multilayer(GUI_current_fixed_icontext_menuitem_common_data);
#if  0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    /*
     * Disable the list effect for showing the highlighted menu item later.
     * When scrolling, no list effect is allowed. e.g., HIGHLIGHT_EFFECT_FLASH_FEELING.
     */
    gui_reset_current_list_effect();
    /* restore list effect */
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    gui_fixed_icontext_enable_transparent_effect(GUI_current_fixed_icontext_menuitem_common_data);  /* Enable after scrolling text */
#endif/*__MMI_UI_TRANSPARENT_EFFECT__*/ 

    GUI_current_fixed_icontext_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
#ifndef __MMI_UI_MENU_SLIM__   
	gui_list_in_scroll = MMI_FALSE;    
#endif/*__MMI_UI_MENU_SLIM__*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_fixed_icontext_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = GUI_current_fixed_icontext_menuitem_common_data->flags;
#ifdef __MMI_SUBLCD__
    gdi_handle act_lcd;
#endif/*__MMI_SUBLCD__*/

	S32 layer_offset_x, layer_offset_y;
	S32	x1, y1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(flags & UI_MENUITEM_MARQUEE_SCROLL) || !GUI_current_fixed_icontext_menuitem_scroll)
    {
        return;
    }

/*
    if (!GUI_current_fixed_icontext_menuitem_scroll)
    {
        return;
    }
*/

#if   0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    

#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif/*__MMI_UI_MENU_SLIM__*/

    if (GUI_current_fixed_icontext_menuitem_common_data->parent_list)
    {
       // fixed_list_menu *parent_list = GUI_current_fixed_icontext_menuitem_common_data->parent_list;
#ifdef __MMI_SUBLCD__
		gdi_lcd_get_active(&act_lcd);
		gdi_lcd_set_active(GUI_current_fixed_icontext_menuitem_common_data->parent_list->act_lcd_handle);
#endif/*__MMI_SUBLCD__*/
        gdi_layer_push_and_set_active(GUI_current_fixed_icontext_menuitem_common_data->parent_list->act_layer_handle);

        GUI_current_fixed_icontext_menuitem_common_data->parent_list->current_displayed_item = -1;
    }

    flags |= GUI_current_fixed_icontext_menuitem_data->flags;
    if (GUI_current_fixed_icontext_menuitem_scroll_counter)
    {
        GUI_current_fixed_icontext_menuitem_scroll_counter--;
    }
    else
    {
        if (flags & UI_MENUITEM_MARQUEE_SCROLL)
        {
            if (mmi_fe_get_r2l_state())
            {
                GUI_current_fixed_icontext_menuitem_common_data->scroll_x += UI_text_menuitem_scroll_size;
                if (GUI_current_fixed_icontext_menuitem_common_data->scroll_x >=
                    (GUI_current_fixed_icontext_menuitem_common_data->text_width + UI_text_menuitem_scroll_gap))
                {
                    GUI_current_fixed_icontext_menuitem_common_data->scroll_x = 0;
                }
            }
            else
            {
                GUI_current_fixed_icontext_menuitem_common_data->scroll_x -= UI_text_menuitem_scroll_size;
                if (GUI_current_fixed_icontext_menuitem_common_data->scroll_x <=
                    (-(GUI_current_fixed_icontext_menuitem_common_data->text_width + UI_text_menuitem_scroll_gap)))
                {
                    GUI_current_fixed_icontext_menuitem_common_data->scroll_x = 0;
                }
            }
        }
		#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif//0
    GUI_current_fixed_icontext_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

	gui_menu_disable_transparent_effect_when_multilayer(GUI_current_fixed_icontext_menuitem_common_data);
    #if  0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /*
         * Disable the list effect for showing the highlighted menu item later.
         * When scrolling, no list effect is allowed. e.g., HIGHLIGHT_EFFECT_FLASH_FEELING.
         */
        gui_reset_current_list_effect();
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */
    
        gui_show_fixed_icontext_menuitem(
            (void*)GUI_current_fixed_icontext_menuitem_data,
            (void*)GUI_current_fixed_icontext_menuitem_common_data,
            GUI_current_fixed_icontext_menuitem_x,
            GUI_current_fixed_icontext_menuitem_y);

#ifdef __MMI_FTE_SUPPORT__        
        {
            gdi_handle layers[4], act_layer;
            gdi_layer_get_blt_layer(&layers[0], &layers[1], &layers[2], &layers[3]);
            if (mmi_fe_get_r2l_state())
            {
                gdi_layer_push_and_set_clip(
                    MMI_fixed_list_menu.x, 
                    GUI_current_fixed_icontext_menuitem_y, 
                    MMI_fixed_list_menu.x + MMI_fixed_list_menu.vbar.width - 1, 
                    GUI_current_fixed_icontext_menuitem_y2);
            }
            else
            {
                gdi_layer_push_and_set_clip(
                    MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1 - MMI_fixed_list_menu.vbar.width, 
                    GUI_current_fixed_icontext_menuitem_y, 
                    MMI_fixed_list_menu.x + MMI_fixed_list_menu.width - 1, 
                    GUI_current_fixed_icontext_menuitem_y2);
            }
            /* menu height might be larger than normal one. Prevent the scrollbar mismatch when going back to the normal menu */
            
            gdi_layer_flatten_with_clipping(layers[0], layers[1], layers[2], layers[3]);
            gdi_layer_get_active(&act_layer);
            
            gui_enable_scrollbar_redraw_clip(MMI_FALSE);
            gui_vertical_scrollbar_set_alpha_blend_layer(&MMI_fixed_list_menu.vbar, act_layer);
            gui_show_vertical_scrollbar(&MMI_fixed_list_menu.vbar);
            gui_vertical_scrollbar_set_alpha_blend_layer(&MMI_fixed_list_menu.vbar, MMI_fixed_list_menu.act_layer_handle);
            gui_enable_scrollbar_redraw_clip(MMI_TRUE);
            gui_pop_clip();
        }   
#endif/*__MMI_FTE_SUPPORT__*/


#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    /* restore list effect */
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    gui_fixed_icontext_enable_transparent_effect(GUI_current_fixed_icontext_menuitem_common_data);  /* Enable after scrolling text */
#endif/*__MMI_UI_TRANSPARENT_EFFECT__*/ 

    GUI_current_fixed_icontext_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

	/* consider layer offset for JUI category 176 */
	gdi_layer_get_position(&layer_offset_x, &layer_offset_y);
	x1 = GUI_current_fixed_icontext_menuitem_x + layer_offset_x;
	y1 = GUI_current_fixed_icontext_menuitem_y + layer_offset_y;

#if defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    if (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT ||
		gui_is_menuitem_show_hint_two_line() &&
        GUI_current_fixed_icontext_menuitem_common_data->parent_list && 
        GUI_current_fixed_icontext_menuitem_common_data->parent_list->gui_get_current_pop_up_description_string && 
        (GUI_current_fixed_icontext_menuitem_common_data->parent_list->gui_get_current_pop_up_description_string())
		)
    {
        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
    }
    else
    {
        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);
    }        
#else /* defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_UI_HINTS_IN_MENUITEM__) */ 
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    if (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)
    {
        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
    }
    else
    {
        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);
    }
#else /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (gui_is_menuitem_show_hint_two_line() &&
        (GUI_current_fixed_icontext_menuitem_common_data->parent_list->gui_get_current_pop_up_description_string()))
    {
        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + (GUI_current_fixed_icontext_menuitem_common_data->height << 1) - 1);
    }
    else
    {
        gui_BLT_double_buffer(
            x1,
            y1,
            x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
            y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);
    }
#else /* __MMI_UI_HINTS_IN_MENUITEM__ */

    gui_BLT_double_buffer(
        x1,
        y1,
        x1 + GUI_current_fixed_icontext_menuitem_common_data->width - 1,
        y1 + GUI_current_fixed_icontext_menuitem_common_data->height - 1);

#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 
#endif /* defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) && defined(__MMI_UI_HINTS_IN_MENUITEM__) */ 
	}

    if (GUI_current_fixed_icontext_menuitem_common_data->parent_list)
    {
        gdi_layer_pop_and_restore_active();
#ifdef __MMI_SUBLCD__
		gdi_lcd_set_active(act_lcd);
#endif/*__MMI_SUBLCD__*/
    }
	
#ifndef __MMI_UI_MENU_SLIM__    
    gui_list_in_scroll = MMI_FALSE;    
#endif/*__MMI_UI_MENU_SLIM__*/

#ifdef  __MMI_CAT203_SUPPORT__    
    if (g_gui_list_get_underline)
    {
        gui_start_timer(UI_text_menuitem_scroll_time, gui_fixed_icontext_menuitem_scroll_handler);
    }
#endif  // __MMI_CAT203_SUPPORT__    
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_redraw_scrolling_text
 * DESCRIPTION
 *  redraw the scolling text in menu item.
 * PARAMETERS
 *  scrolling_text  [IN]    scrolling text instance
 *  x                 [IN]        x
 *  y                 [IN]        y
 *  width           [IN]        width
 *  height          [IN]        height
 *  text_color    [IN]        the text color of scolling text
 *  text_border_color  [IN]  the text border color of scolling text
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_redraw_scrolling_text(
        scrolling_text *scrolling_text,
        S32 x,
        S32 y,
        S32 width,
        S32 height,
        color *text_color
    )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void (*draw_background_temp)(S32 x1, S32 y1, S32 x2, S32 y2);
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (scrolling_text)
    {
        scrolling_text->x = x;
        scrolling_text->y = y;
        scrolling_text->width = width;
        scrolling_text->height = height;
        if (text_color)
        {
            scrolling_text->text_color = *text_color;
        }
#if 0        
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0		
        gdi_layer_lock_frame_buffer();
        draw_background_temp = scrolling_text->draw_background;
        scrolling_text->draw_background = UI_dummy_function_with_4_s32;
        gui_redraw_scrolling_text(scrolling_text);
        scrolling_text->draw_background = draw_background_temp;
        gdi_layer_unlock_frame_buffer();
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_list_menuitem_set_font
 * DESCRIPTION
 *  set the font fot menu item
 * PARAMETERS
 *  cm      [IN]    the menu item's base structure
 *  flags    [IN]    the flags of menu items
 * RETURNS
 *  void
 *****************************************************************************/
void gui_list_menuitem_set_font(gui_common_menuitem_base_struct *cm, U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if  0
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
  //  {
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) &&
        (MMI_current_menu_type == LIST_MENU) 
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
       && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT) &&      
        cm && !(cm->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/         
        )
    {
        gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_LIST_HIGHLIGHT));
    }
    else
    {
        gui_set_font(cm->text_font);
    }
 //   }
}


extern void wgui_inline_get_default_indicator_width( S32 *pwidth, S32 *pheight);
/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_start_scroll
 * DESCRIPTION
 *  Start scrolling for the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*) GUI_current_fixed_icontext_menuitem_data;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) GUI_current_fixed_icontext_menuitem_common_data;
    S32  scroll_width;//w, h,
    U32 flags, ret_flag = 0, ret_flag_ext = 0;
#if  0
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

    UI_filled_area *f = NULL;
    S32 i_width = 0, i_height = 0;

#ifdef  __MMI_CAT203_SUPPORT__    
    S32 *underline_array;
    S32 count = 0;
#endif  // __MMI_CAT203_SUPPORT__

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (t == NULL || m == NULL)
    {
        return;
    }

    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
    flags = m->flags;
    flags |= t->flags;
    if (flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY)
    {
        return;
    }

	gui_execute_list_menu_item_resize_function();
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif//0

    if (g_gui_list_get_menuitem_flags)
    {
        g_gui_list_get_menuitem_flags(MMI_fixed_list_menu.highlighted_item, &ret_flag, &ret_flag_ext);
        flags |= ret_flag;
    }

#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

#if 0//defined(__MMI_OP11_HOMESCREEN__) || defined(__MMI_OP11_SIDEBAR__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //  defined(__MMI_OP11_HOMESCREEN__) || defined(__MMI_OP11_SIDEBAR__)
  //  {
    if (MMI_current_menu_type == LIST_MENU
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
		&& !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
		)
    {
        gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_LIST_HIGHLIGHT));
    }
    else
    {
        gui_set_font(m->text_font);
    }
   // }
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

    gui_fixed_icontext_menuitem_get_text_dimension(t);//, t->item_text, &w, &h);
   // w = t->text_width;
	//h = t->text_height;
    m->text_width = t->text_width;
    m->scroll_x = 0;
	
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
    if (flags & UI_MENUITEM_DISABLE_ICON && t->item_icon == UI_NULL_IMAGE)
    {
        scroll_width = m->scroll_width + GUI_ICONTEXT_MENUITEM_TEXT_X - 2;
    }
    else
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
   // {
        scroll_width = m->scroll_width;
   // }
	
#ifdef  __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
    /* For move the cursor by 3 pixels when the default text effect is enabled and the
       menu item is to be shown inside rectangle in in-line screen. */
    if (t->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
    {
         scroll_width -= 3;
    }
#endif  // __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__


#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    if (t->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
    {
        wgui_inline_get_default_indicator_width(&i_width, &i_height);
        scroll_width -= i_width; 
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

    if (MMI_current_menu_type == LIST_MENU)
    {
        f = m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
    }
	
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
    if (f && (f->flags & UI_FILLED_AREA_BORDER))
    {
        scroll_width -= 2;
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    if (MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU)
    {
        scroll_width = MMI_fixed_icontext_menuitem.width;
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/	

    if ((t->text_width > scroll_width)
	#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
		&& !(flags & UI_MENUITEM_TRUNCATE_CONTENT)
	#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/	
		)
    {
        if ((flags & UI_MENUITEM_MARQUEE_SCROLL))
        {
            GUI_current_fixed_icontext_menuitem_scroll = MMI_TRUE;
           // GUI_current_fixed_icontext_menuitem_scroll_direction = 0;
            GUI_current_fixed_icontext_menuitem_scroll_counter = UI_text_menuitem_scroll_pause;

        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            if (gui_get_current_list_effect() && !gblock_list_effect)
            {
#ifdef  __MMI_CAT203_SUPPORT__    
                if (g_gui_list_get_underline)
                {
                    /* to see how to show scrolling text in under line case */
                    underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
                    if (underline_array)
                    {
                        memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
                        g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &count);

                        applib_asm_free_anonymous(underline_array);
                    }
                }
                
                if (count)
                {
                    gui_register_callback_menuitem_scroll(gui_fixed_icontext_menuitem_scroll_handler);
                }
                else
#endif  // __MMI_CAT203_SUPPORT__
                {
                    gui_create_scrolling_text(
                        &gui_current_scroll_text[0],
                        0,
                        0,
                        0,
                        0,
                        (UI_string_type)t->item_text,
                        gui_fixed_icontext_menuitem_scroll_text_handler,
                        scrolling_text_draw_icontext_single_line_background,
                        MMI_fixed_icontext_menuitem.focussed_text_color,
                        MMI_fixed_icontext_menuitem.focussed_text_color);
                    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
					#endif
                    gui_scrolling_text_start(&gui_current_scroll_text[0]);
                    gui_register_callback_menuitem_scroll(gui_fixed_icontext_menuitem_scroll_text_handler);    
                }
            }
            else
        #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        {
#ifdef  __MMI_CAT203_SUPPORT__            
            if (g_gui_list_get_underline)
            {
                underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
                if (underline_array)
                {
                    memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
                    g_gui_list_get_underline(MMI_fixed_list_menu.highlighted_item, underline_array, &count);

                    applib_asm_free_anonymous(underline_array);
                }
            }
            
            if (count!= 0)
            {
                gui_start_timer(UI_text_menuitem_scroll_time, gui_fixed_icontext_menuitem_scroll_handler);
            }
            else
#endif  //__MMI_CAT203_SUPPORT__
            {
                gui_create_scrolling_text(
                    &gui_current_scroll_text[0],
                    0,
                    0,
                    0,
                    0,
                    (UI_string_type)t->item_text,
                    gui_fixed_icontext_menuitem_scroll_text_handler,
                    scrolling_text_draw_icontext_single_line_background,
                    MMI_fixed_icontext_menuitem.focussed_text_color,
                    MMI_fixed_icontext_menuitem.focussed_text_color);
                #if 0  
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
				#endif
                gui_scrolling_text_start(&gui_current_scroll_text[0]);
            }
            }
        }
    }
    else
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    {
        gui_register_callback_menuitem_scroll(UI_dummy_function);
        GUI_current_fixed_icontext_menuitem_scroll = MMI_FALSE;
    }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
   // {
        GUI_current_fixed_icontext_menuitem_scroll = MMI_FALSE;
   // }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}

#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted icontext menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    gui_cancel_timer(gui_fixed_icontext_menuitem_start_scroll);
    if (GUI_current_fixed_icontext_menuitem_scroll)
    {
#ifdef  __MMI_CAT203_SUPPORT__        
        if (g_gui_list_get_underline)
        {
            gui_cancel_timer(gui_fixed_icontext_menuitem_scroll_handler);        
        }
        else
#endif  // __MMI_CAT203_SUPPORT__
       // {
          gui_scrolling_text_stop(&gui_current_scroll_text[0]);
        //} 

        GUI_current_fixed_icontext_menuitem_scroll = MMI_FALSE;
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_register_callback_menuitem_scroll(UI_dummy_function);
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/* External used to display inline edit menu items */
void wgui_show_inline_edit_menuitem(S32 x1, S32 y1, S32 width, S32 height);
extern S32 MMI_current_menu_type;
extern fixed_matrix_menu MMI_fixed_matrix_menu;
extern gdi_handle animation_handle;


/*****************************************************************************
 * FUNCTION
 *  gui_list_show_text
 * DESCRIPTION
 *  show text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_list_show_text (fixed_icontext_menuitem *m, fixed_icontext_menuitem_type *mi, S32 x1, S32 y1, S32 item_width, S32 text_width, S32 text_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
#ifdef  __MMI_CAT203_SUPPORT__
    s32 count = 0;
    S32 *underline_array = NULL;
	S32 i = 0, x, width, iwidth;
	U32 n, nlen;
    UI_string_type text;
    stFontAttribute text_font;
    mmi_fe_get_string_info_param_struct query;
    U8 underline, bold;
#endif/*__MMI_CAT203_SUPPORT__*/

	S32 height = 0;
    S32 scrolling_text_x;
    S32 menu_y1, menu_y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   

	gui_get_menu_top_and_bottom_position(m, &menu_y1, &menu_y2);

    height = text_height;
	
#ifdef  __MMI_CAT203_SUPPORT__
    width = text_width;

    text_font = *m->text_font;
	
    underline = m->text_font->underline;
    bold = m->text_font->bold;
    
    if (g_gui_list_get_underline)
    {
        underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
        
        if (underline_array)
        {
            memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
		#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif	
		   g_gui_list_get_underline(wgui_get_current_menuitem_index(&MMI_fixed_list_menu), underline_array, &count);
        }
    }
    if (count != 0)
    {
        memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
        query.String = (U8*)mi->item_text;
        query.checkCompleteWord = MMI_FALSE;
        query.enableTruncated = MMI_FALSE;
        query.n =  mmi_ucs2strlen((const char*)mi->item_text);
        query.w = 0;
        mmi_fe_get_string_widthheight(&query);
        if (mmi_fe_get_r2l_state())
        {
            width = 0;
            text = mi->item_text;
            nlen = mmi_ucs2strlen((const CHAR *)text);
            if(underline_array[0] != 0)
            {
                n = underline_array[0];
                gui_set_font(&text_font);
                gui_measure_string_n(text, n, &iwidth, &height);
                width += iwidth;
                text += n;
                nlen -= n;
            }

            while(nlen > 0)
            {
                n = underline_array[i + 1] - underline_array[i] + 1;
                
                text_font.underline = 1;
                text_font.bold = 1;
                gui_set_font(&text_font);
                gui_measure_string_n(text, n, &iwidth, &height);
                width += iwidth;
                text += n;
                nlen -= n;
                if (underline_array[i + 2])
                {
                    n = underline_array[i + 2] - underline_array[i + 1] - 1;
                    text_font.underline = underline;
                    text_font.bold = bold;
                    gui_set_font(&text_font);
                    gui_measure_string_n(text, n, &iwidth, &height);
                    width += iwidth;
                    text += n;
                    nlen -= n;
                }
                i = i + 2;
                count --;
                if (count == 0)
                {
                    break;
                }
                if(underline_array[i] == 0 || i >= MAX_SUB_MENU_SIZE - 2)
                {
                    break;
                }
            }
            if (nlen)
            {
                text_font.underline = underline;
                text_font.bold = bold;
                gui_set_font(&text_font);
                gui_measure_string(text, &iwidth, &height);
                width += iwidth;
            }
        }
        x = x1;
        text = mi->item_text;
        nlen = mmi_ucs2strlen((const CHAR *)text);
        i = 0;
        if (mmi_fe_get_r2l_state())
        {
            x -= width;
        }
        if(underline_array[0] != 0)
        {
            n = underline_array[0];
            gui_set_font(&text_font);
            gui_measure_string_n(text, n, &width, &height);
            if (mmi_fe_get_r2l_state())
            {
                x += width;
                gui_move_text_cursor(x, y1);
            }
//#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
            if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                    (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                (x + width - x1 > item_width))
            {
                gui_print_truncated_text(x, y1, item_width - (x - x1), text);
            }
            else
//#endif
            {
                if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
                {
                    mmi_fe_show_string_n_baseline(x, y1, (U8*)text, n, query.baseline);
                }
            }
                
            if (!mmi_fe_get_r2l_state())
            {
                x += width;
            }
            gui_move_text_cursor(x, y1);
            text += n;
            nlen -= n;
        }

        while(nlen > 0)
        {
            n = underline_array[i + 1] - underline_array[i] + 1;
            
            text_font.underline = 1;
            text_font.bold = 1;
            gui_set_font(&text_font);
            gui_measure_string_n(text, n, &width, &height);
            if (mmi_fe_get_r2l_state())
            {
                x += width;
                gui_move_text_cursor(x, y1);
            }
//#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
            if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                    (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                (x + width - x1 > item_width))
            {
                gui_print_truncated_text(x, y1, item_width - (x - x1), text);
            }
            else
//#endif      
            {
                if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
                {
                    mmi_fe_show_string_n_baseline(x, y1, (U8*)text, n, query.baseline);
                }
            }
            
            if (!mmi_fe_get_r2l_state())
            {
                x += width;
            }
            text += n;
            nlen -= n;
            gui_move_text_cursor(x, y1);
            if (underline_array[i + 2])
            {
                n = underline_array[i + 2] - underline_array[i + 1] - 1;
                text_font.underline = underline;
                text_font.bold = bold;
                gui_set_font(&text_font);
                gui_measure_string_n(text, n, &width, &height);
                if (mmi_fe_get_r2l_state())
                {
                    x += width;
                    gui_move_text_cursor(x, y1);
                }
//#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
                if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                        (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                    (x + width - x1 > item_width))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
//#endif
                {
                    if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                    {
                        gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                    }
                    else
                    {
                        mmi_fe_show_string_n_baseline(x, y1, (U8*)text, n, query.baseline);
                    }
                }
                if (!mmi_fe_get_r2l_state())
                {
                    x += width;
                }
                gui_move_text_cursor(x, y1);                
                text += n;
                nlen -= n;
            }
            i = i + 2;
            count --;
            if (count == 0)
            {
                break;
            }
            if(underline_array[i] == 0 || i >= MAX_SUB_MENU_SIZE - 2)
            {
                break;
            }
        }
        if (nlen)
        {
            text_font.underline = underline;
            text_font.bold = bold;
            gui_set_font(&text_font);
            gui_measure_string(text, &width, &height);
            if (mmi_fe_get_r2l_state())
            {
                x += width;
                gui_move_text_cursor(x, y1);
            }
//#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
            if ((!((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
                    (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))) &&
                (x + width - x1 > item_width))
            {
                gui_print_truncated_text(x, y1, item_width - (x - x1), text);
            }
            else
//#endif
            {
                if ((mi->flags & UI_MENUITEM_TRUNCATE_CONTENT) || (m->flags & UI_MENUITEM_TRUNCATE_CONTENT))
                {
                    gui_print_truncated_text(x, y1, item_width - (x - x1), text);
                }
                else
                {
                    mmi_fe_show_string_n_baseline(x, y1, (U8*)text, nlen, query.baseline);
                }
            }
        }
    }
    else
#endif  // __MMI_CAT203_SUPPORT__
    {
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_DATA)
        {
            gui_set_font(&MMI_small_font);
        }
        else
        {
            gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, mi->flags);
        }
#if 1
//#ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
        if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && 
			(GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            (!(m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) &&
            ((y1 >= menu_y1 && y1 + height <= menu_y2) || !g_current_display_half_menuitem))
        {
#ifdef  __MMI_CAT203_SUPPORT__
            if (mmi_fe_get_r2l_state() && g_gui_list_get_underline)
            {
                scrolling_text_x = x1 - item_width + 1;
            }
            else
#endif  // __MMI_CAT203_SUPPORT__
            //{
                scrolling_text_x = x1;
           // }

            gui_menuitem_redraw_scrolling_text(
                &(gui_current_scroll_text[0]),
                scrolling_text_x,
                y1,
                item_width,
                height + 1,
                &(m->focussed_text_color));
        }
        else
        {
            gui_print_truncated_text(x1, y1, item_width, mi->item_text);
        }  
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef  __MMI_CAT203_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_CAT203_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_MAINLCD_320X480__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef  __MMI_CAT203_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_CAT203_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif/*__MMI_MAINLCD_320X480__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif/*__MMI_UI_LIST_TRUNCATE_ITEM__*/
    }

#ifdef  __MMI_CAT203_SUPPORT__
    if (underline_array)
    {
        applib_asm_free_anonymous(underline_array);
    }
#endif  //  __MMI_CAT203_SUPPORT__
    gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, mi->flags);
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_icontext_menuitem_flag
 * DESCRIPTION
 *  get the flag of  icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 * item_type[IN]  0,icontext, 1,icontext list, 2,twostate
 * RETURNS
 *  flag
 *****************************************************************************/
static void gui_get_fixed_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext, S32 Is_two_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U32 ret_flag = 0, ret_flag_ext = 0;

	gui_common_menuitem*m = (gui_common_menuitem*) common_item_data;
	fixed_menuitem_type* mi = (fixed_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *flags = 0;
    if (m && mi)
    {
        *flags = mi->flags | m->flags;
		if(Is_two_state)
			*flags_ext = m->ext_flags;
		else
            *flags_ext = mi->ext_flags | m->ext_flags;
    }
    if (g_gui_list_get_menuitem_flags)
    {
        g_gui_list_get_menuitem_flags(index, &ret_flag, &ret_flag_ext);
        *flags |= ret_flag;
        *flags_ext |= ret_flag_ext;
    }
}


//#if 0
/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_icontext_menuitem_flag
 * DESCRIPTION
 *  get the flag of  icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_icontext_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												*/
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body														*/
	/*----------------------------------------------------------------*/

    gui_get_fixed_menuitem_flag(item, common_item_data, index, flags,flags_ext, 0);
}
#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_scroll_start_handler_for_list_effects
 * DESCRIPTION
 *  Start the associated scroll handler for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_scroll_start_handler_for_list_effects(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gui_call_menuitem_scroll)
    {
        gui_call_menuitem_scroll(); /* call the corresponding scroll handler */
    }
}

/*****************************************************************************
 * FUNCTION
 *  gui_callback_highlighter_text_filler
 * DESCRIPTION
 *  Timer callback function for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_callback_highlighter_text_filler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SUBLCD__	
    GDI_HANDLE lcd;
#endif
    S32 iwidth, iheight;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!ghighlight_item || !ghighlight_common_item_data)
    {
      //  MMI_DBG_ASSERT(0);
        return;
    }
    
#ifdef __MMI_SUBLCD__
	gdi_lcd_get_active(&lcd);
	gdi_lcd_set_active(MMI_fixed_list_menu.act_lcd_handle);
#endif

    gui_lock_double_buffer();

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__    
    is_draw_next_frame_list_highlight_effect = 1;
#endif

    if (!gui_is_fixed_list_menu_empty())//(MMI_fixed_list_menu.n_items > 0)
    {
        //gdi_layer_push_and_set_active(MMI_fixed_list_menu.act_layer_handle);
        gui_push_and_set_list_menu_act_handle_active();
		
        MMI_fixed_list_menu.current_displayed_item = -1;
        MMI_fixed_list_menu.item_measure_function(ghighlight_item, ghighlight_common_item_data, &iwidth, &iheight);
        
        MMI_fixed_list_menu.item_display_function(ghighlight_item, ghighlight_common_item_data, gstartX1, gstartY1);

#ifdef UI_ENABLE_POP_UP_DESCRIPTIONS
        
        if (MMI_fixed_list_menu.menu_style == GUI_MENU_TYPE_FIXED)
        {
            wgui_display_fixed_text_list_pop_up_description();
        }
        else if (MMI_fixed_list_menu.menu_style == GUI_MENU_TYPE_DYNAMIC)
        {
            wgui_display_dynamic_text_list_pop_up_description();
        }
        else if (MMI_fixed_list_menu.menu_style == GUI_MENU_TYPE_ASYNCDYNAMIC)
        {
            wgui_display_asyncdynamic_text_list_pop_up_description();  
        }
#endif
        gdi_layer_pop_and_restore_active();
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__	
    is_draw_next_frame_list_highlight_effect = 0;
#endif    
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(xstart_effect, ystart_effect, xend_effect, yend_effect);
    
#ifdef __MMI_SUBLCD__
	gdi_lcd_set_active(lcd);
#endif
}

/*****************************************************************************
 * FUNCTION
 *  set_start_position_and_item_parameters_for_list_highlighter_effect
 * DESCRIPTION
 *  Save menu item information for the list effect.
 * PARAMETERS
 *  item                    [IN]        private menu item object
 *  common_item_data        [IN]        common menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void set_start_position_and_item_parameters_for_list_highlighter_effect(
        void *item,
        void *common_item_data,
        S32 x,
        S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ghighlight_item = item;
    ghighlight_common_item_data = common_item_data;
    gstartX1 = x;
    gstartY1 = y;
}

/*****************************************************************************
 * FUNCTION
 *  gui_draw_animated_effect_filler
 * DESCRIPTION
 *  Draw the animated highlighter filler.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_frame, repeat_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    xstart_effect = x1;
    ystart_effect = y1;
    xend_effect = x2;
    yend_effect = y2;

    /* get the number of frames in the animation */
    repeat_time = gdi_anim_get_count(f->b);
    gdi_image_get_frame_count(f->b, &max_frame);  

    if (list_highlight_effect_current_frame >= max_frame)
    {
        list_highlight_effect_current_frame = 0;
    }


    gui_push_and_set_clip(x1, y1, x2, y2);    
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    if (mmi_is_redrawing_bk_screens())
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1); 
    }
    else if (gui_list_in_scroll && list_highlight_effect_current_frame == 0 && repeat_time == 1)
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }
    else if (list_highlight_effect_current_frame == max_frame - 1 && repeat_time == 1)
    {   
        /* the last frame is already shown, go back to the first frame */
        //gdi_image_draw_animation_single_frame(x1, y1, f->b, 0);
        gdi_image_draw_frames(x1, y1, f->b, (S16) list_highlight_effect_current_frame);  
        //gui_draw_list_highlight_effect_last_frame();                
        list_highlight_effect_current_frame = 0;
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__		
        list_highlight_effect_times = 1;
#endif
        /* prevent from drawing the menu item twice when it is already scrolling */
        gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
        
    }
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    else if (list_highlight_effect_current_frame <= max_frame && list_highlight_effect_times == 0)
#else
    else if (list_highlight_effect_current_frame <= max_frame)
#endif
    {   
        U32 *header32 = (U32*)f->b;
        U32 frame_delay = header32[4];
        MMI_BOOL need_start_timer = MMI_TRUE;
        
        gdi_image_draw_frames(x1, y1, f->b, (S16) list_highlight_effect_current_frame);      /* Show frame by frame no. */
        if (list_highlight_effect_current_frame == max_frame - 1)
        {
            list_highlight_effect_current_frame = 0;
        }
        else
        {
            list_highlight_effect_current_frame++;  /* Treat list_highlight_effect_current_frame as frame no. */
        }
        if (repeat_time == 1)
        {
        }        
        else if ((GUI_current_fixed_icontext_menuitem_scroll || GUI_current_fixed_icontext_list_menuitem_scroll)&&
            list_highlight_effect_current_frame == 0)
        {
            GUI_current_fixed_icontext_menuitem_scroll_counter = 0;
        }
        else if (!gui_list_in_scroll)
        {
        }
        else
        {
            need_start_timer = MMI_FALSE;
        }

        if (need_start_timer)
        {
            gui_start_timer(frame_delay, gui_callback_highlighter_text_filler);
        }
    }
    else
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }

    gui_pop_clip();

}
#endif/*__MMI_UI_MENU_SLIM__*/

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__

/*****************************************************************************
 * FUNCTION
 *  gui_register_fixed_icontext_menuitem_hide_function
 * DESCRIPTION
 *  Register hide callback function
 * PARAMETERS
 *  hide_funtion            [IN]        hide callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_register_fixed_icontext_menuitem_hide_function(
	void *common_item_data, 
	void (*f) (S32 x1, S32 y1, S32 x2, S32 y2))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    ((fixed_icontext_menuitem*) common_item_data)->hide_function = f;
}
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

/*****************************************************************************
 * FUNCTION
 *  gui_list_inline_draw_icon
 * DESCRIPTION
 *  draw the icon for inline item
 * PARAMETERS
 *  m         [IN]      inline menu item base structure
 *  mi        [IN]      inline menu item
 *  x1        [IN]      x1
 *  x2        [IN]      x2
 *  y1        [IN]      y1
 *  y2        [IN]      y2
 *  flags     [IN]      the flags of menu item
 *  _icon    [IN]      the icon pointer
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_list_inline_draw_icon(
    fixed_icontext_menuitem *m,
    fixed_icontext_menuitem_type *mi,
    S32 x1, 
    S32 x2, 
    S32 y1, 
    S32 y2,
    U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_alpha_layer;
    S32 clip_x1, clip_y1, clip_x2, clip_y2;

    S32 i_width, i_height, icon_width = 0, icon_height = 0;
    S32 icon_x;

    S32 menu_y2;
	//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
	gdi_handle act_layer = GDI_NULL_HANDLE;
#endif/*__MMI_UI_MENU_SLIM__*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    menu_y2 = m->parent_list->y + m->parent_list->height - 1;

    gui_measure_fixed_icontext_menuitem(mi, m, &i_width, &i_height);
    
  // if (mi->item_icon!= UI_NULL_IMAGE)
  //  {
        gui_measure_image(mi->item_icon, &icon_width, &icon_height);

	//	if (flags & UI_MENUITEM_CENTER_ICON_Y)
     ///   {
            m->icon_y = (i_height >> 1) - (icon_height >> 1);
     //   }
   // }

    old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__        
    {
        S32 x_clip = 0, y_clip = 0, y_gap = 0;
        
      //  gui_push_clip();
        if (m->icon_x > 0)
        {
            x_clip = m->icon_x;
        }
#ifdef __MMI_UI_LIST_GRID_LINE__
        if (m->icon_y <= 0)
        {
            y_clip = 1;
        }
#endif /* __MMI_UI_LIST_GRID_LINE__ */
        if (m->icon_y > 0)
        {
            y_clip = m->icon_y;
        }
        
        clip_y1 = y1 + y_clip;
        clip_y2 = menu_y2;

        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            y_gap = y_clip;
        }

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }
#endif/*__MMI_UI_MENU_SLIM__*/
        if (y1 + y_gap >= menu_y2)
        {
            clip_y1 = menu_y2;
        }
        else if (y1 + i_height - 1 < menu_y2)
        {
            clip_y2 = y1 + i_height - 1;
        }
        
        if (mmi_fe_get_r2l_state())
        {
            clip_x1 = x2 - m->text_x + 2;
            clip_x2 = x2 - x_clip;

            icon_x = x2 - m->icon_x - icon_width + 1;
        }
        else
        {
            clip_x1 = x1 + x_clip;
            clip_x2 = x1 + m->text_x - 2;

            icon_x = x1 + m->icon_x;
        }
        
        gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
		
        gdi_image_draw_animation_single_frame(icon_x, y1 + m->icon_y, (U8*) mi->item_icon, 0);

        gui_pop_clip();
    }
#if   0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_icontext_menuitem
 * DESCRIPTION
 *  Show an icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y      
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_icontext_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    /* offset in y to bottom */
    S32 yoff;

    /* relative x offset of text inside menu item. 
       (which might be different from m->text_x in Arabic or scrolling) */
    S32 text_x = 0;

    /* relative y offset of text inside menu item. */
    S32 text_y = 0;

//#if (defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__)
//    MMI_BOOL show_hint_in_menuitem = MMI_FALSE;
//#endif/*(defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__)*/ 

    S32 ani_w, ani_h;
    color text_color;
    UI_filled_area *f = NULL;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
    U32 flags, flags_ext;
  //  UI_string_type _text;
  //  PU8 _icon;
 //   U8 animation_flag = 0;
    S32 sw = 0, sh = 0, max_text_width = 0;//, time_w = 0;
#ifdef __MMI_WEARABLE_DEVICE__
	MMI_BOOL show_highlight = MMI_FALSE;
#endif /*__MMI_WEARABLE_DEVICE__*/
#if  0//__MMI_OP11_SIDEBAR__
/* under construction !*/
/* under construction !*/
#endif
    S32 is_text_full_width = 0, old_text_x = 0, old_text_y = 0, old_icon_x = 0, old_icon_y = 0;
    S32 icon_width, icon_height;
    U32  ret_flag_ext = 0;//ret_flag = 0,
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;

#if 0//__MMI_OP11_SIDEBAR__
/* under construction !*/
#endif

#if 0//__MMI_UI_LIST_HIGHLIGHT_BOLD
/* under construction !*/
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

#if defined(__MMI_MAINLCD_320X480__) || defined(__MMI_MAINMENU_SPREAD_SUPPORT__)
    UI_filled_area background_filler;
#endif

    /* position of inline indicator */
    S32 i_x = 0, i_y = 0;
    /* dimension of indicator in inline edit */
    S32 i_width = 0, i_height = 0;

    S32 clip_x1, clip_y1, clip_x2, clip_y2;
	//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_handle act_layer = GDI_NULL_HANDLE;
#endif/*__MMI_UI_MENU_SLIM__*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	///TODO: FIX ME, move to menu
    MMI_fixed_list_menu.default_inline_item = 0;
	//g_gui_menuitem_need_scroll = MMI_FALSE;

//get flags
    gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
    
  //  _text = mi->item_text;
 //   _icon = mi->item_icon;
    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + m->height - 1;
	
	gui_get_menu_top_and_bottom_position(m, &menu_y1, &menu_y2);
	yoff = (MMI_fixed_matrix_menu.height - (m->height * MMI_fixed_matrix_menu.displayed_rows)) % (MMI_fixed_matrix_menu.displayed_rows + 1);

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
	if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
	{
		wgui_inline_get_default_indicator_width(&i_width, &i_height);
	}
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

    if (flags & UI_MENUITEM_STATE_FOCUSSED)
    {
#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
        mmi_frm_dss_set_menu_highlight(MMI_SCREEN_FOCUSED_ICONTEXT_ITEM);
#endif/*__MMI_SUPPORT_DUMP_SCREEN_STRING__*/
        GUI_current_fixed_icontext_menuitem_x = x;
        GUI_current_fixed_icontext_menuitem_y = y;
        GUI_current_fixed_icontext_menuitem_x2 = x2;
        GUI_current_fixed_icontext_menuitem_y2 = y2;
    }
    
//#ifdef __MMI_UI_HINTS_IN_MENUITEM__
//    show_hint_in_menuitem = gui_menuitem_has_hint((gui_common_menuitem_base_struct*) m, flags & UI_MENUITEM_STATE_FOCUSSED);
//#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

#if (defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__)
    if (gui_menuitem_has_hint((gui_common_menuitem_base_struct*) m, flags & UI_MENUITEM_STATE_FOCUSSED)
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        || (m->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/ 
        )
    {
        if (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))	
        {
            gui_show_two_line_icontext_menuitem(item, common_item_data, x, y);
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__			
			#ifdef __MMI_EMAIL__
            if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_SEPARATORLINE)
            {
                gui_draw_horizontal_line(x1, x2, y1, *(current_MMI_theme->list_grid_line_color));//list_separator_color
            }
            else
			#endif/*__MMI_EMAIL__*/	
				if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
            {
                gui_draw_horizontal_line(x1, x2, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
            }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
				
#if 0//defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
            return;
        }
    }
#endif /* (defined __MMI_UI_HINTS_IN_MENUITEM__ || defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__) */ 

    if (flags & UI_MENUITEM_INLINE_EDIT_OBJECT)
    {
        gui_measure_fixed_icontext_menuitem(item, common_item_data, &i_width, &i_height);
        /* calculate the icon position */
       // if (mi->item_icon != UI_NULL_IMAGE)
       // {
        gui_measure_image(mi->item_icon, &icon_width, &icon_height);
        //}

        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            /* Remove the display of background filler when the default text effect is enabled */
#ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
            if (!(mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT))
#endif/*__MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__*/ 
            {
                old_alpha_layer = gui_list_set_alpha_blending_layer();
				#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
                if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
				#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/	
                //{
#if 0//__OP01_FWPBW__
/* under construction !*/
#else
                    gui_draw_filled_area(x1, y1, x2, y2, m->focussed_filler);
#endif
                //}
                gui_list_reset_alpha_blending_layer(old_alpha_layer);
            }
        }
        else
        {
            gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
        }

        if (mi->item_icon != UI_NULL_IMAGE)
        {
            gui_list_inline_draw_icon(m, mi, x1, x2, y1, y2, flags);
        }

#ifdef __MMI_FTE_SUPPORT__
        /* display the focussed inline item with different coordinates when the default
           text effect is enabled. */
        gui_push_clip();
        gui_measure_fixed_icontext_menuitem(item, common_item_data, &i_width, &i_height);

        clip_x1 = x;
        clip_y1 = y;
        clip_x2 = x + i_width - 1;
        clip_y2 = menu_y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }
#endif/*__MMI_UI_MENU_SLIM__*/
        if (y >= menu_y2)
        {
            clip_y1 = menu_y2;
        }
        else if (menu_y2 >= y + i_height - 1)
        {
            clip_y2 = y + i_height - 1;
        }
		//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        }  
        #else
        {
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
        }
        #endif    
#else/*__MMI_UI_MENU_SLIM__*/		
        gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/
        
        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            if (m->parent_list && m->parent_list->gui_display_pop_up_description)
            {
                m->parent_list->gui_display_pop_up_description(x, y, i_width, i_height);
            }
        }
        else
        {
            wgui_show_inline_edit_menuitem(x, y, i_width, i_height);
        }
        gui_pop_clip();
#else /* __MMI_FTE_SUPPORT__ */
        /* display inline item with different coordinates when the default
           text effect is enabled. */
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        if ((mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT))
        {
            i_y = y + 1;
            
            i_width = m->width - m->text_x;
            i_height = i_height - 2;
            if (mmi_fe_get_r2l_state())
            {
                i_x = x + 2;
            }
            else
            {
                i_x = x + m->text_x;
            }
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
        {
            i_x = x + 2;
            i_y = y;

            i_width = m->width - 2;
        }

        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            if (m->parent_list && m->parent_list->gui_display_pop_up_description)
            {
                //gdi_layer_lock_frame_buffer();
                m->parent_list->gui_display_pop_up_description(i_x, i_y, i_width, i_height);
               // gdi_layer_unlock_frame_buffer();
            }
        }
        else
        {
            wgui_show_inline_edit_menuitem(i_x, i_y, i_width, i_height);
        }
    #endif /* __MMI_FTE_SUPPORT__ */

        return;
    }
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
    else if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
    {
        i_y = y + ((m->height - i_height) >> 1);
        if (mmi_fe_get_r2l_state())
        {
            i_x = x;
        }
        else
        {
            i_x = x + m->width - i_width - 1 ;
        }
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
        /* Autocalculate the text position based on font   */
#if 0//defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)            
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //  defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__) 
        //{
        gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
        //}
        gui_fixed_icontext_menuitem_get_text_dimension(mi);//, mi->item_text, &sw, &sh);
		sw = mi->text_width;
		sh = mi->text_height;
        if (flags & UI_MENUITEM_CENTER_TEXT_X)
        {
            old_text_x = m->text_x;
            m->text_x = (m->width - sw) >> 1;

            /* if the text width is too large, display from the beginning. */
            if (m->text_x < 0)
            {
                m->text_x = 0;
            }            
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
        }
        if (flags & UI_MENUITEM_CENTER_TEXT_Y)
        {
            old_text_y = m->text_y;
            m->text_y = (m->height >> 1) - (sh >> 1);
        }
    }

    /* calculate the icon position */
    if (mi->item_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(mi->item_icon, &icon_width, &icon_height);

        if (flags & UI_MENUITEM_CENTER_ICON_X)
        {
            old_icon_x = m->icon_x;
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            old_icon_y = m->icon_y;
#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
          //  {
            m->icon_y = (m->height >> 1) - (icon_height >> 1);
          //  }
        }
        if (flags & UI_MENUITEM_ICON_CENTER_JUSTIFY)
        {
            old_icon_x = m->icon_x;
            if (m->text_x > m->icon_x)
            {
                m->icon_x += ((m->text_x - m->icon_x + 1) >> 1) - (icon_width >> 1);
            }
            else
            {
                m->icon_x += ((m->width - m->icon_x + 1) >> 1) - (icon_width >> 1);
            }
        }
    }

    /* Compute text_x and text_y */
    text_x = m->text_x;
    text_y = m->text_y;

    /* For inline edit captions to appear from left when there is no icon   */
    if ((flags & UI_MENUITEM_DISABLE_ICON) && (mi->item_icon == UI_NULL_IMAGE) && !(flags & UI_MENUITEM_CENTER_TEXT_X))
    {
        is_text_full_width = 1;
        text_x = 2;
    }

    if (mmi_fe_get_r2l_state())
    {
        /* short one pixel for vector font in Abric language */
        text_x = m->width - 1 - text_x - 1;
    }

#if 0//defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)   

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 

#ifdef __MMI_MAINLCD_320X480__
    if (MMI_current_menu_type == MATRIX_MENU && MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU)
        is_text_full_width = 1;
#endif


#if 0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    

#ifdef  __MMI_CAT203_SUPPORT__
    if ((g_gui_list_get_underline != NULL) && (flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        text_x += m->scroll_x;
    }
#endif  // __MMI_CAT203_SUPPORT__

/*
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && (flags & UI_MENUITEM_FOCUSSED_ANIMATE))
    {
        animation_flag = 1;
    }
 */

///get filler and text color
    if ((flags & UI_MENUITEM_STATE_FOCUSSED)&& !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
		#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__) //add by xl
		 && (MMI_TRUE == pen_down_in_list)
		#endif /*__MMI_WEARABLE_DEVICE__*/
		)
    {
		#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__) //add by xl  
		if (MMI_FALSE == g_gui_ssp_launch)
		{
			pen_down_in_list = MMI_FALSE;
		}
		#endif /*__MMI_WEARABLE_DEVICE__*/
    #ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
	#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
        {
            f = m->focussed_filler;
            fixed_single_line_menuitem_filled_area = *f;
	#ifdef __MMI_WEARABLE_DEVICE__
			show_highlight = MMI_TRUE;
	#endif /*__MMI_WEARABLE_DEVICE__*/
        }
		text_color = m->focussed_text_color;
#if 0		
#ifndef __MMI_MAINLCD_320X480__
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif//0
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {

        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND) && !(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
      //  {
            f = m->disabled_filler;
      //  }
#ifndef __MMI_UI_MENU_SLIM__		
        if ((mi->ext_flags & UI_MENUITEM_EXT_DISABLED_NORMAL_TEXT) || (ret_flag_ext & UI_MENUITEM_EXT_DISABLED_NORMAL_TEXT))
        {
            text_color = m->normal_text_color;
        }
        else
#endif/*__MMI_UI_MENU_SLIM__*/			
        //{
            text_color = m->disabled_text_color;
       // }
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        f = m->selected_filler;
        text_color = m->selected_text_color;
       // if (flags & UI_MENUITEM_SELECTED_ANIMATE)
       // {
       //     animation_flag = 1;
       // }
    }
    else
    {

        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND) && !(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))		
       // {
            f = m->normal_filler;
       // }
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        // if condition is not correct. It fails when any other flag is ON 
        // along with UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT.
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
        {
            f = m->selected_filler;
        }
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 

#ifdef  __MMI_SCREEN_ROTATE__
        if (mmi_frm_is_screen_width_height_swapped() && !current_MMI_theme->rotated_bkg_filler)
        {
            text_color = UI_COLOR_BLACK;
        }
        else
#endif  // __MMI_SCREEN_ROTATE__
      //  {
            text_color = m->normal_text_color;
       // }

    }


	
    gui_push_clip();

    if (MMI_current_menu_type == MATRIX_MENU)
    {
        S32 vbar_width = 0;
        S32 l_gap = 0, r_gap = 0; 
        if (gui_is_menuitem_show_animation_when_hilited(flags))
        {
            gui_measure_image(MMI_mm_animation, &ani_w, &ani_h);
            if (gui_is_matrix_menu_show_vbar(MMI_fixed_matrix_menu.flags))//(MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR)
            {
                vbar_width = MMI_fixed_matrix_menu.vbar.width;
            }
            if (mmi_fe_get_r2l_state())
            {
                l_gap = vbar_width;    
            }
            else
            {
                r_gap = vbar_width;
            }
            if (ani_w > m->width)
            {
                m->icon_x -= ((ani_w - m->width) >> 1);
                if (x1 + m->icon_x < MMI_fixed_matrix_menu.x + l_gap)
                {
                    m->icon_x = MMI_fixed_matrix_menu.x  + l_gap - x1;
                }
                if (x1 + m->icon_x + ani_w > MMI_fixed_matrix_menu.x + MMI_fixed_matrix_menu.width - r_gap)
                {
                    m->icon_x = MMI_fixed_matrix_menu.x + MMI_fixed_matrix_menu.width - r_gap - x1 - ani_w;
                }
            }
            
            if (ani_h > m->height)
            {
                m->icon_y -= ((ani_h - m->height) >> 1);
                if (y1 + m->icon_y < MMI_fixed_matrix_menu.y)
                {
                    m->icon_y = MMI_fixed_matrix_menu.y - y1;
                }
                if (y1 + m->icon_y + ani_h > MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - yoff)
                {
                    m->icon_y = MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - yoff - y1 - ani_h;
                }
            }
		
        }
        else if (mi->item_icon)/* for fixed text matrix, _icon = NULL, don't touch the clip */
        {    
          	gui_measure_image(mi->item_icon, &ani_w, &ani_h);	
        }

		if (gui_is_menuitem_show_animation_when_hilited(flags) || 
			mi->item_icon)
		{
			clip_x1 = x1 + m->icon_x;
			clip_y1 = y1 + m->icon_y;
			clip_x2 = x1 + m->icon_x + ani_w - 1;
			clip_y2 = menu_y2;
			
			if (y1 + m->icon_y >= menu_y2)
			{
				clip_y1 = menu_y2;
			}
			else if (y1 + m->icon_y + ani_h - 1 < menu_y2)
			{
				clip_y2 = y1 + m->icon_y + ani_h - 1;
			}
            #ifdef __128X128_WEARABLE_DEVICE_UI__
            {
                wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
            }  
            #else
            {
                gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
            }
            #endif    
		
         }
    }
    else
    {
        clip_y2 = menu_y2;
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif//0
            clip_x1 = x1;
            clip_y1 = y1;
            clip_x2 = x2;

            //unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
            gdi_layer_get_active(&act_layer);
            if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
#else/*__MMI_UI_MENU_SLIM__*/
            if (y1 < m->parent_list->y && g_current_display_half_menuitem)
#endif/*__MMI_UI_MENU_SLIM__*/
			{
                clip_y1 = m->parent_list->y;
            }            
            if (y1 >= menu_y2)
            {
                clip_y1 = menu_y2;
            }
            else if (y2 < menu_y2)
            {
                clip_y2 = y2;
            }
        //}
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        }  
        #else
        {
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
        }
        #endif    
    }
		
#if defined(__MMI_UM_CONVERSATION_BOX_ENHANCE__)
    if (m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT_DISPLAY)
    {
        f = NULL;
    }
#endif/*__MMI_UM_CONVERSATION_BOX_ENHANCE__*/

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    if (m->hide_function)
    {
        gui_swla_log_start("IFL");
        m->hide_function(x1, y1, x2, y2);
        gui_swla_log_stop("IFL");
    }
    else 
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
		if (f != NULL
#ifndef __MMI_UI_MENU_SLIM__		
		&& !g_slide_effect->in_flatten
#endif/*__MMI_UI_MENU_SLIM__*/		
		)
    {
    //unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        if (MMI_current_menu_type == LIST_MENU && m->parent_list)
        {
            if (m->parent_list->alpha_blend_layer_handle)
            {
                old_alpha_layer = gdi_set_alpha_blending_source_layer(m->parent_list->alpha_blend_layer_handle);
            }
        }
        else
#endif/*__MMI_UI_MENU_SLIM__*/
       // {
          old_alpha_layer = gui_list_set_alpha_blending_layer();
        //}

    #if  0
/* under construction !*/
/* under construction !*/
        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
/* under construction !*/
        #endif 
        #ifndef __MMI_MAINLCD_320X480__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
        {
        #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
            // if condition is not correct. It fails when any other flag is ON 
            // along with UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT.

            /* 
             * special menu item background filler drawing for inline items
             *
             * 1. y1 + 1 and y2 - 1 are to keep the border not touch each other. 
             * (That is a 2 pixel spacing.)
             * 2. The filler does not cover the icon, unlike normal list menu items.
             */
            if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
            {
                gui_swla_log_start("IFL");
                if (text_y)
                {
                    if (mmi_fe_get_r2l_state())
                    {
                        gui_draw_filled_area(x1, y1 + 1, x2 - m->text_x, y2 - 1, f);
                    }
                    else
                    {
                        gui_draw_filled_area(x1 + m->text_x, y1 + 1, x2, y2 - 1, f);
                    }
                }
                else
                {   
                    if (mmi_fe_get_r2l_state())
                    {
                        gui_draw_filled_area(x1, y1, x2 - m->text_x, y2, f);
                    }
                    else
                    {
                        gui_draw_filled_area(x1 + m->text_x, y1, x2, y2, f);
                    }
                }
                gui_swla_log_stop("IFL");
            }
            else
        #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
            {
           	#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
           	#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
                if (is_draw_next_frame_list_highlight_effect_value())
            #endif
                {
                    mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_ICONTEXT_ITEM);
                }
            #endif	

                set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);
            #if 0//defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

                gui_swla_log_start("IFL");
#if  0//__OP01_FWPBW__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else   // __OP01_FWPBW__
            #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
                gui_draw_list_filled_area(x1, y1, x2, y2, f);
            #else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
			  #ifdef __MMI_MAINLCD_96X64__
			    gui_menuitem_draw_list_filler(x1 + m->text_x, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
			  #else
                gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
			  #endif
            #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#endif  // __OP01_FWPBW__
                gui_swla_log_stop("IFL");
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
            }
        }

        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }

    if (mi->item_icon != UI_NULL_IMAGE && !((m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE)
			&& gui_is_menuitem_show_animation_when_hilited(flags)))
    {
        old_alpha_layer = GDI_NULL_HANDLE;
        if (MMI_fixed_list_menu.alpha_blend_layer_handle)
        {
            old_alpha_layer = gdi_set_alpha_blending_source_layer(MMI_fixed_list_menu.alpha_blend_layer_handle);
        }
        else if ((flags & UI_MENUITEM_STATE_FOCUSSED && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
#ifndef __MMI_UI_MENU_SLIM__
			|| g_slide_effect->in_flatten
#endif/*__MMI_UI_MENU_SLIM__*/
			)
        {
#if 0
/* under construction !*/
#endif
          //  {
#ifndef __MMI_WEARABLE_DEVICE__
            gdi_layer_get_active(&old_alpha_layer);
            old_alpha_layer = gdi_set_alpha_blending_source_layer(old_alpha_layer);
#else
		if (show_highlight == MMI_TRUE)
		{
			gdi_layer_get_active(&old_alpha_layer);
            old_alpha_layer = gdi_set_alpha_blending_source_layer(old_alpha_layer);
		}
#endif /*__MMI_WEARABLE_DEVICE__*/
      //  } 
        }

        if (mi->item_icon_handle != GDI_ERROR_HANDLE)
        {
            gdi_image_stop_animation(mi->item_icon_handle);
            mi->item_icon_handle = GDI_ERROR_HANDLE;
        }

        if (gui_is_menuitem_show_animation_when_hilited(flags))
        {
        
			/* imageResource violation */
		//#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
			PU8 imgBuffer = NULL;
		//#endif
		
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
			imgBuffer = (PU8)GetImageData((S8*)MMI_mm_animation) ;
#else
			imgBuffer = MMI_mm_animation ;
#endif

            if (MMI_current_menu_type == MATRIX_MENU )
            {
                if ((MMI_fixed_matrix_menu.flags & UI_MATRIX_MENU_FOR_MAINMENU))
                {
//unimportant issues
#if(!(defined __MMI_UI_MENU_SLIM__ ))&& (defined(__MMI_MAINMENU_SPREAD_SUPPORT__))
                    gdi_handle active_layer;
                    S32 w, h;
    
                    gdi_image_get_dimension(current_MMI_theme->matrix_main_menu_highlight_image, &w, &h);
    
                    clip_x1 = x1 + (((x2 - x1) - w) >> 1);
                    clip_y1 = y1;
                    clip_x2 = x1 + (((x2 - x1) - w) >> 1) + w - 1;
                    clip_y2 = menu_y2;
    
                    if (y1 + m->icon_y >= menu_y2)
                    {
                        clip_y1 = menu_y2;
                    }
                    else if (y1 + m->height - 1 < menu_y2)
                    {
                        clip_y2 = y1 + m->height - 1;
                    }
                    gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    
                    background_filler.b = current_MMI_theme->matrix_main_menu_highlight_image;
                    background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
                    gui_draw_filled_area(x1 + (((x2 - x1) - w) >> 1), y1, x1 + (((x2 - x1) - w) >> 1) + w, y2,&background_filler);
                    gdi_layer_flatten_with_clipping(dm_get_layer_handle(0), dm_get_layer_handle(1), dm_get_layer_handle(2), dm_get_layer_handle(3));
                    gdi_layer_get_active(&active_layer);
                    gdi_push_and_set_alpha_blending_source_layer(active_layer);
    
                    gdi_image_draw_frames(
                        x1 + m->icon_x,
                        y1 + m->icon_y,
                        mi->item_icon,
                        1);
    
                    gdi_pop_and_restore_alpha_blending_source_layer();
                    gui_pop_clip();
#else /* defined(__MMI_MAINMENU_SPREAD_SUPPORT__) */
                    /* matrix main menu. call special function for drawing animation on a highlight image.  */
                    if ((!gui_main_menu_matrix_slide_is_under_control()))// &&
                        //(!gui_matrix_screen_smooth_scrolling_moved_by_pen()))
                    {
#ifdef  __MMI_MAINLCD_320X480__

                        clip_x1 = x1 + m->icon_x;
                        clip_y1 = y1 + m->icon_y;
                        clip_x2 = x1 + m->width - 1;
                        clip_y2 = menu_y2;

                        if (y1 + m->icon_y >= menu_y2)
                        {
                            clip_y1 = menu_y2;
                        }
                        else if (y1 + m->height - 1 < menu_y2)
                        {
                            clip_y2 = y1 + m->height - 1;
                        }
                        gui_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                        
                        background_filler.b = current_MMI_theme->matrix_main_menu_highlight_image;
                        background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
                        gui_draw_filled_area(x1 + m->icon_x, y1 + m->icon_y, x2, y2,&background_filler);
                        gui_pop_clip();
#endif  // __MMI_MAINLCD_320X480__
                        gui_show_animation_with_background_image(
                            x1 + m->icon_x, 
                            y1 + m->icon_y,
                            imgBuffer,///MMI_mm_animation,
                            current_MMI_theme->matrix_main_menu_highlight_image,
                            (gdi_handle*)&mi->item_icon_handle);
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
							  SetImageFlushable(MMI_mm_animation);
#endif/*__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__*/

                    }
                    else
                    {
                        gdi_image_draw_animation(
                            x1 + m->icon_x,
                            y1 + m->icon_y,
                            imgBuffer,//MMI_mm_animation,
                            (gdi_handle*)&mi->item_icon_handle);
						
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__						
						SetImageFlushable(MMI_mm_animation);
#endif/*__MMI_RESOURCE_IMAGE_GROUP_COMPRESS__*/
                    }
//unimportant issues
//#ifndef __MMI_UI_MENU_SLIM__
#endif /* defined(__MMI_MAINMENU_SPREAD_SUPPORT__) */
//#endif
                }
                else	
                {   /* normal matrix menu */             
                    gdi_image_draw_animation(
                        x1 + m->icon_x,
                        y1 + m->icon_y,
                        mi->item_icon,
                        (gdi_handle*)&mi->item_icon_handle);
                }                
            }
#if 0//defined (__MMI_MAINLCD_320X480__) && defined (__MMI_BI_DEGREE_MAIN_MENU_STYLE__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if defined __MMI_RESOURCE_IMAGE_GROUP_COMPRESS__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif  // defined (__MMI_MAINLCD_320X480__) && defined (__MMI_BI_DEGREE_MAIN_MENU_STYLE__)
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
			#endif//0
            else
            {
                S32 icon_x;

                /* have to handle R2L list menu animation icon x position */
                if (mmi_fe_get_r2l_state() && (MMI_current_menu_type == LIST_MENU))
                {                   
                    icon_x = x2 - m->icon_x - icon_width + 1;
                }
                else
                {
                    icon_x = x1 + m->icon_x;
                }

                gui_swla_log_start("ICO");
                gdi_image_draw_animation(
                    icon_x,
                    y1 + m->icon_y,
                    mi->item_icon,
                    (gdi_handle*)&mi->item_icon_handle);                    
                gui_swla_log_stop("ICO");
            }
        }
        else if (m->flags & UI_MENUITEM_STATE_ANIMATE)
        {
            gui_swla_log_start("ICO");
            gdi_image_draw_frames(
                x1 + m->icon_x,
                y1 + m->icon_y,
                mi->item_icon,
                1);
            gui_swla_log_stop("ICO");
            m->flags &= ~UI_MENUITEM_STATE_ANIMATE;
        }
        else if (MMI_current_menu_type == LIST_MENU)
        {
            S32 x_clip = 0, y_clip = 0;

            gui_push_clip();
            if (m->icon_x > 0)
            {
                x_clip = m->icon_x;
            }
#ifdef __MMI_UI_LIST_GRID_LINE__
            if (m->icon_y <= 0)
            {
                y_clip = 1;
            }
#endif /* __MMI_UI_LIST_GRID_LINE__ */
            if (m->icon_y > 0)
            {
                y_clip = m->icon_y;
            }

            clip_y1 = y1 + y_clip;
            clip_y2 = menu_y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
            gdi_layer_get_active(&act_layer);
            if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
            {
                clip_y1 = m->parent_list->y;
            }
#endif/*__MMI_UI_MENU_SLIM__*/

            if (mmi_fe_get_r2l_state())
            {
                clip_x1 = x2 - m->text_x + 2;
                clip_x2 = x2 - x_clip;
                
                /* R2L icons are right-aligned. */
                if (y1 + y_clip >= menu_y2)
                {
                    clip_y1 = menu_y2;
                }
                else if (y1 + m->height - 1 < menu_y2)
                {
                    clip_y2 = y1 + m->height - 1;
                }
				//unimportant issues
				#ifndef __MMI_UI_MENU_SLIM__
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                }  
                #else
                {
                    gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                }
                #endif    
#else/*__MMI_UI_MENU_SLIM__*/				
                gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/

                gui_swla_log_start("ICO");
                gdi_image_draw_animation_single_frame(x2 - m->icon_x - icon_width + 1, y1 + m->icon_y, (U8*) mi->item_icon, 0);
                gui_swla_log_stop("ICO");
            }
            else
            {
				clip_x1 = x1 + x_clip;
				clip_x2 = x1 + m->text_x - 2;
				
				if (y1 + y_clip >= menu_y2)
				{
					clip_y1 = menu_y2;
				}
				else if (y1 + m->height - 1 < menu_y2)
				{
					clip_y2 = y1 + m->height - 1;
				}
				//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                }  
                #else
                {
                    gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                }
                #endif    
#else/*__MMI_UI_MENU_SLIM__*/				
				gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/
				gui_swla_log_start("ICO");
				gdi_image_draw_animation_single_frame(x1 + m->icon_x, y1 + m->icon_y, (U8*) mi->item_icon, 0);
				gui_swla_log_stop("ICO");
            }

            gui_pop_clip();

            /* show checkbox, show it here to correspond to list effects since */
            if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
            {
                gui_menuitem_icontext_show_checkbox(m, x1, y1);
            }
        }
        else
        {
            gdi_image_draw_animation_single_frame(x1 + m->icon_x, y1 + m->icon_y, (U8*) mi->item_icon, 0);
        }
#ifdef __MMI_WEARABLE_DEVICE__
		if (MMI_fixed_list_menu.alpha_blend_layer_handle || show_highlight == MMI_TRUE)
#endif /*__MMI_WEARABLE_DEVICE__*/
		{
        	gui_list_reset_alpha_blending_layer(old_alpha_layer);
		}
    }

#if  0//__MMI_OP11_SIDEBAR__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //  __MMI_OP11_SIDEBAR__


    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        old_alpha_layer = GDI_NULL_HANDLE;
        if (MMI_fixed_list_menu.alpha_blend_layer_handle)
        {
            old_alpha_layer = gdi_set_alpha_blending_source_layer(MMI_fixed_list_menu.alpha_blend_layer_handle);
        }
        else if ((flags & UI_MENUITEM_STATE_FOCUSSED && !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
#ifndef __MMI_UI_MENU_SLIM__
			|| g_slide_effect->in_flatten
#endif/*__MMI_UI_MENU_SLIM__*/
			)
        {
#if 0
/* under construction !*/
#endif
          //  {
                gdi_layer_get_active(&old_alpha_layer);
                old_alpha_layer = gdi_set_alpha_blending_source_layer(old_alpha_layer);
          //  } 
        }
#endif  // __MMI_VECTOR_FONT_SUPPORT__
        gui_push_text_clip();

#ifdef __MMI_MAINMENU_PAGE_SUPPORT__
        if (!(flags & UI_MENUITEM_DISABLE_TEXT_CLIP))
#endif/*__MMI_MAINMENU_PAGE_SUPPORT__*/
        {
            clip_y1 = y1;
            clip_y2 = menu_y2;

//unimportant issues
			#ifndef __MMI_UI_MENU_SLIM__
            gdi_layer_get_active(&act_layer);
            if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
            {
                clip_y1 = m->parent_list->y;
            }
			#endif/*__MMI_UI_MENU_SLIM__*/
            if (y1 >= menu_y2)
            {
                clip_y1 = menu_y2;
            }
            else if (y2 < menu_y2)
            {
                clip_y2 = y2;
            }
            
            if (is_text_full_width)
            {
                /* FIXME. text_x might not be 0 */
#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                //{
                    clip_x1 = x1;
                    clip_x2 = x2;
                    
                   //unimportant issues
                   #ifndef __MMI_UI_MENU_SLIM__
                    #ifdef __128X128_WEARABLE_DEVICE_UI__
                    {
                        wgui_fixed_list_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                    }  
                    #else
                    {
                        gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                    }
                    #endif                        
				   #else/*__MMI_UI_MENU_SLIM__*/ 
				   gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				   #endif/*__MMI_UI_MENU_SLIM__*/
                    
                    if (mmi_fe_get_r2l_state())
                    {
                        max_text_width = text_x;
                    }
                    else
                    {
                        max_text_width = m->width - text_x;
                    }
#ifdef __MMI_FTE_SUPPORT__
                    if (MMI_current_menu_type == LIST_MENU)
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
#else/*__MMI_FTE_SUPPORT__*/
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
                    if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/					
#endif/*__MMI_FTE_SUPPORT__*/
               // }
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__               
                if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
                {
                    max_text_width -= i_width;
                }
#endif/*__MMI_UI_MENU_SLIM__*/				
            }
            else
            {
                if ((m->icon_x > m->text_x) && !(flags & UI_MENUITEM_DISABLE_ICON))
                {
                    clip_x1 = x1;
                    clip_x2 = x1 + m->icon_x - 1;
                    
                   //unimportant issues
                   #ifndef __MMI_UI_MENU_SLIM__
                    #ifdef __128X128_WEARABLE_DEVICE_UI__
                    {
                        wgui_fixed_list_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                    }  
                    #else
                    {
                        gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                    }
                    #endif    
				   #else/*__MMI_UI_MENU_SLIM__*/ 
				   gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				   #endif/*__MMI_UI_MENU_SLIM__*/
                    
                    max_text_width = m->icon_x - m->text_x;
                }
                else
                {
                   // if (time_w)
                   //     time_w += GUI_MENUITEM_DATA_LEFT_GAP;
                    if (mmi_fe_get_r2l_state())
                    {
						clip_x1 = x1 + i_width;//+ time_w
						clip_x2 = x2 - m->text_x;
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
						if (f && (f->flags & UI_FILLED_AREA_BORDER))
						{
						  clip_x1 += 2;
						  /* Leave space for border of background filler */
						}
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/						
                    }
                    else
                    {
                        clip_x1 = x1 + m->text_x;
                        clip_x2 = x2 - i_width;//- time_w
                     #ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__   
                        if (f && (f->flags & UI_FILLED_AREA_BORDER))
                        {
                            /* Leave space for border of background filler */
                            clip_x2 -= 2;
                        }    
					 #endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/	
                    }
                   //unimportant issues
                   #ifndef __MMI_UI_MENU_SLIM__
                    #ifdef __128X128_WEARABLE_DEVICE_UI__
                    {
                        wgui_fixed_list_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                    }  
                    #else
                    {
                        gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                    }
                    #endif    
				   #else/*__MMI_UI_MENU_SLIM__*/ 
				   gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
				   #endif/*__MMI_UI_MENU_SLIM__*/
                    
                    if (flags & UI_MENUITEM_CENTER_TEXT_X)
                    {
                        max_text_width = x2 - (x1 + old_text_x) + 1 - i_width;
                    }
                    else
                    {
                        max_text_width = x2 - (x1 + m->text_x) + 1 - i_width;
                    }

                    gui_menuitem_adjust_text_clip_for_right_gap(m);                
#ifdef  __MMI_FTE_SUPPORT__                    
                    if (MMI_current_menu_type == LIST_MENU)
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
#else   // __MMI_FTE_SUPPORT__
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
                    if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
                    {
                        max_text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
                    }
                    else 
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/						
						if (MMI_current_menu_type == LIST_MENU)
                    {
                        max_text_width -= 1;
                    }
#endif  // __MMI_FTE_SUPPORT__
                }
            }
        }
#ifdef __MMI_MAINMENU_PAGE_SUPPORT__
        else
        {
            max_text_width = m->width - m->text_x;
        }
#endif/*__MMI_MAINMENU_PAGE_SUPPORT__*/

#if 0//defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // defined(__MMI_OP11_SIDEBAR__) || defined(__MMI_OP11_HOMESCREEN__)

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
        if (f && (f->flags & UI_FILLED_AREA_BORDER))
        {
            if (text_x < 1)
            {
                gui_get_text_clip(&clip_x1, &clip_y1, &clip_x2, &clip_y2);
                clip_x1++;
                clip_x2--;
                if (mmi_fe_get_r2l_state())
                {
                    text_x -= 1;
                }
                else
                {
                    text_x += 1;
                }

               //unimportant issues
               #ifndef __MMI_UI_MENU_SLIM__
                gdi_layer_get_active(&act_layer);
                if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
                {
                    clip_y1 = m->parent_list->y;
                }
				#endif/*__MMI_UI_MENU_SLIM__*/
                if (clip_y1 >= menu_y2)
                {
              
                //unimportant issues
                #ifndef __MMI_UI_MENU_SLIM__
                    #ifdef __128X128_WEARABLE_DEVICE_UI__
                    {
                        wgui_fixed_list_set_clip(clip_x1, menu_y2, clip_x2, menu_y2);
                    }  
                    #else
                    {
                        gui_set_clip(clip_x1, menu_y2, clip_x2, menu_y2);            
                    }
                    #endif    
				#else/*__MMI_UI_MENU_SLIM__*/				  
				gui_set_clip_preset(clip_x1, menu_y2, clip_x2, menu_y2);
  				#endif/*__MMI_UI_MENU_SLIM__*/
                }
                else if (clip_y2 >= menu_y2)
                {
                    //unimportant issues
                    #ifndef __MMI_UI_MENU_SLIM__
                    #ifdef __128X128_WEARABLE_DEVICE_UI__
                    {
                        wgui_fixed_list_set_text_clip(clip_x1, menu_y2, clip_x2, menu_y2);
                    }  
                    #else
                    {
                        gui_set_text_clip(clip_x1, clip_y1, clip_x2, menu_y2);            
                    }
                    #endif    
					#else/*__MMI_UI_MENU_SLIM__*/					
                    gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, menu_y2);
					#endif/*__MMI_UI_MENU_SLIM__*/
                }
                else
                {
                    //unimportant issues
                    #ifndef __MMI_UI_MENU_SLIM__
                    #ifdef __128X128_WEARABLE_DEVICE_UI__
                    {
                        wgui_fixed_list_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                    }  
                    #else
                    {
                        gui_set_text_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                    }
                    #endif    
					#else/*__MMI_UI_MENU_SLIM__*/
                    gui_set_text_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
					#endif/*__MMI_UI_MENU_SLIM__*/
                }           
            }           
            max_text_width -= 1;
        }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
        /* move the cursor by 3 pixels when the default text effect is enabled and the
           menu item is to be shown inside rectangle. */
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
        {
            /* 
             * This is a workaround to make the text y not 0 since the rect filler starts
             * at y1 + 1.
             */
            // TODO: The menu height should be at least (font height + 2).
            //if (text_y == 0)
            //{
             //   text_y = 1;
            //}
            S32 x_offset = 0;

            if (flags & UI_MENUITEM_STATE_FOCUSSED)
            {
                x_offset = 3;
            }

            if (mmi_fe_get_r2l_state())
            {
                gui_move_text_cursor(x1 + text_x - x_offset, y1 + text_y);
                text_x -= x_offset;
                max_text_width -= x_offset;
            }
            else
            {
              	gui_move_text_cursor(x1 + text_x + x_offset, y1 + text_y);
                text_x += x_offset;
                max_text_width -= x_offset;    
            }
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
       // {
            gui_move_text_cursor(x1 + text_x, y1 + text_y);
        //}

        gui_set_line_height(sh);
        gui_set_text_color(text_color);
      
        g_gui_menuitem_need_scroll = ((sw > max_text_width) &&
			!(flags & UI_MENUITEM_TRUNCATE_CONTENT)&&
			((flags & UI_MENUITEM_MARQUEE_SCROLL)) 
			&&(!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))); 
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
        if ((flags & UI_MENUITEM_STATE_FOCUSSED) && 
            (flags & UI_MENUITEM_MARQUEE_SCROLL) &&
            (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            !(mi->ext_flags & UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY) &&
            ((y1 >= menu_y1 && y1 + sh <= menu_y2) || !g_current_display_half_menuitem))
        {
        #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_ICONTEXT_MARQUEE_SCROLL);
		#endif
#ifdef __MMI_MAINLCD_320X480__
            if ((MMI_current_menu_type == MATRIX_MENU) &&(mi->flags & UI_MENUITEM_STATE_FOCUSSED) 
                && GUI_current_fixed_icontext_menuitem_scroll)
            {
////for BT Dialer, matrix:3X4
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//for BT Dialer, matrix:3X4					
                //{
                    gdi_draw_solid_rect(x1, y1 + text_y, x2, y2, GDI_COLOR_TRANSPARENT);
                //}
            }
#endif  // __MMI_MAINLCD_320X480__

#ifdef  __MMI_CAT203_SUPPORT__
            if (g_gui_list_get_underline == NULL && mmi_fe_get_r2l_state() && (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))
#else/*__MMI_CAT203_SUPPORT__*/
            if (mmi_fe_get_r2l_state() && (GUI_current_fixed_icontext_menuitem_scroll || g_gui_menuitem_need_scroll))
#endif/*__MMI_CAT203_SUPPORT__*/                
            {
                /* short one pixel for vector font in Abric language */
                gui_list_show_text(m, mi, x1 + text_x - max_text_width + 2, y1 + text_y, max_text_width - 1, sw, sh);
            }
            else
            {
                /* print the text at the normal position */
                gui_list_show_text(m, mi, x1 + text_x, y1 + text_y, max_text_width, sw, sh);
            }
#ifdef  __MMI_CAT203_SUPPORT__            
            if (g_gui_list_get_underline)
            {
                S32 *underline_array;
                S32 underline_count = 0;
                underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);
                if (underline_array)
                {
                    memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
                    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                    #endif
					g_gui_list_get_underline(wgui_get_current_menuitem_index(&MMI_fixed_list_menu), underline_array, &underline_count);

					applib_asm_free_anonymous(underline_array);
                    
                    /* print the text again for scrolling */
                    if (underline_count != 0)
                    {
                        if (mmi_fe_get_r2l_state())
                        {      
                        	gui_move_text_cursor(x1 + text_x - (m->text_width + UI_text_menuitem_scroll_gap), y1 + text_y);
                            gui_set_line_height(sh);
                            gui_list_show_text(m, mi, x1 + text_x - (m->text_width + UI_text_menuitem_scroll_gap), y1 + text_y, max_text_width, sw, sh);
                      	}
                        else
                        {
							gui_move_text_cursor(x1 + text_x + m->text_width + UI_text_menuitem_scroll_gap, y1 + text_y);
							gui_set_line_height(sh);
							gui_list_show_text(m, mi, x1 + text_x + m->text_width + UI_text_menuitem_scroll_gap, y1 + text_y, max_text_width, sw, sh);
                       	}
                    }
                }
            }
#endif  // __MMI_CAT203_SUPPORT__            
        }
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
        else
        {
            /* 
             * Text is getting displayed behind the left button in case of Inline Selection
             * when the menu item is focussed. So remove the display of text when the item
             * is focussed and UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY flag is ON
             * for that item. 
             */
            if (!((flags & UI_MENUITEM_STATE_FOCUSSED) &&
                 (mi->ext_flags & UI_MENUITEM_EXT_DISABLE_FOCUSSED_TEXT_DISPLAY)))
            {
                gui_list_show_text(m, mi, x1 + text_x, y1 + text_y, max_text_width, sw, sh);
            }
        }
        gui_pop_text_clip();
#ifdef __MMI_VECTOR_FONT_SUPPORT__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif/*__MMI_VECTOR_FONT_SUPPORT__*/
    }

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __LOW_COST_PROJECT__ */

#ifdef __MMI_MENUITEM_DOTTED_UNDERLINE_SUPPORT__
    if (flags & UI_MENUITEM_DOTTED_UNDERLINE)
    {
        static const U8 dotted_line_bitvalues[] = {1, 1, 1, 1, 0, 0, 0};
        S32 r = max_text_width % 7; /* pattern width */

        if (r == 0)
        {
            r = 7;
        }
        gdi_draw_line_style(
            m->text_x,
            y2,
            m->text_x + max_text_width - 1 - r,
            y2,
            gdi_act_color_from_rgb(255, 112, 125, 240),
            sizeof(dotted_line_bitvalues),
            dotted_line_bitvalues);
    }
#endif/*__MMI_MENUITEM_DOTTED_UNDERLINE_SUPPORT__*/

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
	#ifdef __MMI_EMAIL__
    if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1, x2, y1, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
    else
	#endif/*__MMI_EMAIL__*/	
		if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1, x2, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

#if 0//defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)


    if (m->post_display_function)
    {
        m->post_display_function(item, common_item_data, x, y);
    }

    gui_pop_clip();

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_INDICATOR)
    {	
		MMI_fixed_list_menu.item_indicator_display_callback(MMI_fixed_list_menu.default_inline_item, i_x, i_y);   
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && !(m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE) && 
	!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT) &&
        m->parent_list &&
	m->parent_list->gui_display_pop_up_description)
    {
    #ifdef __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__
        /* pass the modified parameters in the function so that there is proper gapping
           between the menu items. */
        if (mi->ext_flags & UI_MENUITEM_EXT_SHOW_IN_ROUNDED_RECT)
        {
            m->parent_list->gui_display_pop_up_description(x, y + 1, m->width, ((m->height - 1) - 1));
        }
        else
    #endif /* __MMI_UI_INLINE_EDIT_DEFAULT_TEXT_EFFECT__ */ 
      //  {
            m->parent_list->gui_display_pop_up_description(x, y, m->width, m->height);
      //  }
    }
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 

#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
    mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_NONE);
#endif/*__MMI_SUPPORT_DUMP_SCREEN_STRING__*/


//restore back
   
    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
    {
        if (flags & UI_MENUITEM_CENTER_TEXT_X)
        {
            m->text_x = old_text_x;
        }
        if (flags & UI_MENUITEM_CENTER_TEXT_Y)
        {
            m->text_y = old_text_y;
        }
    }
    
    /* calculate the icon position */
    if (mi->item_icon != UI_NULL_IMAGE)
    {
        if (flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = old_icon_x;
        }
        if (flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = old_icon_y;
        }
        if (flags & UI_MENUITEM_ICON_CENTER_JUSTIFY)
        {
            m->icon_x = old_icon_x;
        }
    }
}


#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_translate_pen_event
 * DESCRIPTION
 *  Pen event handler of the icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item
 *  common_item_data        [IN]        common icontext menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE. 
 *****************************************************************************/
#if defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
extern wgui_get_display_style get_current_menu_item_displaystyle;
extern wgui_horizontal_select_menuitem_struct two_line_horizontal_select_menuitem;
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/

BOOL gui_fixed_icontext_menuitem_translate_pen_event(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;

#ifndef __MMI_FTE_SUPPORT__
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;

    gui_menuitem_icontext_checkbox_struct checkbox;
    S32 is_pen_in_checkbox;

#endif  // ifndef   __MMI_FTE_SUPPORT__    

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    gui_list_pen_enum old_event;
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item)
    {
        flags |= ((fixed_icontext_menuitem_type*) item)->ext_flags;
    }

    *menuitem_event = GUI_LIST_PEN_NONE;

#ifndef __MMI_FTE_SUPPORT__

    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {       
        gui_menuitem_icontext_checkbox_get_data(&checkbox, m, item_x, item_y);
#if defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox.x, checkbox.y, checkbox.image_width, checkbox.image_height) || 
                             ((menuitem_param->i2 == GUI_LIST_PEN_HIGHLIGHT_CHANGED) && 
                              PEN_CHECK_BOUND(x, y, checkbox.x, checkbox.y + m->height, checkbox.image_width, checkbox.image_height));
#else /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox.x, checkbox.y, checkbox.image_width, checkbox.image_height);
#endif /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */

        if (pen_event == MMI_PEN_EVENT_DOWN)
        {
            if (is_pen_in_checkbox)
            {            
                *menuitem_event = GUI_LIST_PEN_DOWN_ON_STATE_BOX;
            }
            else
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            
            return MMI_TRUE;
        }
        else if (pen_event == MMI_PEN_EVENT_UP)
        {
            if (m->checkbox_clicked_callback(menuitem_param->_u.i) == MMI_TRUE)
            {                    
                *menuitem_event = GUI_LIST_PEN_NEED_REDRAW;
            }
            else
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            
            return MMI_TRUE;
        }            
    }
#endif  // #ifndef  __MMI_FTE_SUPPORT__
    
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    /* FIXME: do not check pen up/down here */
    if( ( pen_event == MMI_PEN_EVENT_UP || pen_event == MMI_PEN_EVENT_DOWN || 
        pen_event == MMI_PEN_EVENT_MOVE) && gui_get_two_line_menuitem_height())
    {
        old_event = two_line_horizontal_select_menuitem.menuitem_current_event;
	    mmi_two_line_translate_pen_event(x, y, pen_event, menuitem_event);
        if (pen_event == MMI_PEN_EVENT_DOWN)
            two_line_horizontal_select_menuitem.menuitem_down_event = *menuitem_event;
        
        if (get_current_menu_item_displaystyle(MMI_fixed_list_menu.highlighted_item) ==
            TWO_LINE_MENUITEM_STYLE_DISPLAY_HORIZONTAL_SELECT)
        {
            two_line_horizontal_select_menuitem.menuitem_current_event = *menuitem_event;
            if (old_event != *menuitem_event)
            {
                if (*menuitem_event == GUI_LIST_PEN_NONE || (*menuitem_event != GUI_LIST_PEN_NONE && 
                    two_line_horizontal_select_menuitem.menuitem_down_event == *menuitem_event))
                {	
                    if (get_current_menu_item_displaystyle)
                    {
                        wgui_show_two_line_horizontal_select();
                        gui_BLT_double_buffer(
                            two_line_horizontal_select_menuitem.x,
                            two_line_horizontal_select_menuitem.y,
                            two_line_horizontal_select_menuitem.x + two_line_horizontal_select_menuitem.width - 1,
                            two_line_horizontal_select_menuitem.y + two_line_horizontal_select_menuitem.height - 1);
                    }
                }
            }
            if (pen_event == MMI_PEN_EVENT_UP)
                two_line_horizontal_select_menuitem.menuitem_current_event = GUI_LIST_PEN_NONE;
        }
        if (*menuitem_event == GUI_LIST_PEN_TWO_LINE_NEXT || *menuitem_event == GUI_LIST_PEN_TWO_LINE_PREVIOUS)
        {
            if (pen_event == MMI_PEN_EVENT_DOWN || pen_event == MMI_PEN_EVENT_MOVE)
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            else if (*menuitem_event != two_line_horizontal_select_menuitem.menuitem_down_event)
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            return MMI_TRUE;
        }
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */

    GUI_PEN_EVENT_PARAM_SET_VOID(menuitem_param);

    if (flags & UI_MENUITEM_PEN_USE_LONGPRESS)
    {
        if (gui_pen_wait_longpress(pen_event, x, y) == GUI_WAIT_LONGPRESS_READY)
        {
            *menuitem_event = GUI_LIST_PEN_ITEM_SELECTED;
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}



/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_translate_pen_event
 * DESCRIPTION
 *  Pen event handler of the icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item
 *  common_item_data        [IN]        common icontext menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE. 
 *****************************************************************************/
BOOL gui_fixed_icontext_list_menuitem_translate_pen_event(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;

#ifndef __MMI_FTE_SUPPORT__
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    gui_menuitem_icontext_checkbox_struct checkbox;
    S32 checkbox_x, checkbox_y;
    S32 iwidth, iheight;
    S32 is_pen_in_checkbox;

    S32 item_index;
#endif  // #ifndef  __MMI_FTE_SUPPORT__

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (item)
    {
        flags |= ((fixed_icontext_list_menuitem_type*) item)->ext_flags;
    }

    *menuitem_event = GUI_LIST_PEN_NONE;

#ifndef __MMI_FTE_SUPPORT__
    item_index = menuitem_param->_u.i;

    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {       
        gui_menuitem_icontext_list_checkbox_get_data(&checkbox, m, item_x, item_y);
        checkbox_x = checkbox.x;
        checkbox_y = checkbox.y;
        iwidth = checkbox.image_width;
        iheight = checkbox.image_height;
    
    #if defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y, iwidth, iheight) || 
                             ((menuitem_param->i2 == GUI_LIST_PEN_HIGHLIGHT_CHANGED) && 
                              PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y + m->height, iwidth, iheight));
    #else /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */
        is_pen_in_checkbox = PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y, iwidth, iheight);
    #endif /* defined(__MMI_UI_HINTS_IN_MENUITEM__) || defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) */

        //if (is_pen_in_checkbox)
        {            
            if (pen_event == MMI_PEN_EVENT_DOWN)
            {
                if (is_pen_in_checkbox)
                {            
                    *menuitem_event = GUI_LIST_PEN_DOWN_ON_STATE_BOX;
                }
                else
                {
                    *menuitem_event = GUI_LIST_PEN_NONE;
                }
                
                return MMI_TRUE;
            }
            else if (pen_event == MMI_PEN_EVENT_UP)
            {
                if (m->checkbox_clicked_callback(item_index) == MMI_TRUE)
                {                    
                    *menuitem_event = GUI_LIST_PEN_NEED_REDRAW;
                }
                else
                {
                    *menuitem_event = GUI_LIST_PEN_NONE;
                }
                
                return MMI_TRUE;
            }            
        }        
    }
#endif  // #ifndef  __MMI_FTE_SUPPORT__
    

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    /* FIXME: do not check pen up/down here */
    if( ( pen_event == MMI_PEN_EVENT_UP || pen_event == MMI_PEN_EVENT_DOWN ) && gui_get_two_line_menuitem_height())
    {
	    mmi_two_line_translate_pen_event(x, y, pen_event, menuitem_event);
        
        if (*menuitem_event == GUI_LIST_PEN_TWO_LINE_NEXT || *menuitem_event == GUI_LIST_PEN_TWO_LINE_PREVIOUS)
        {
            if (pen_event == MMI_PEN_EVENT_DOWN)
            {
                *menuitem_event = GUI_LIST_PEN_NONE;
            }
            return MMI_TRUE;
        }
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */

    GUI_PEN_EVENT_PARAM_SET_VOID(menuitem_param);

    if (flags & UI_MENUITEM_PEN_USE_LONGPRESS)
    {
        if (gui_pen_wait_longpress(pen_event, x, y) == GUI_WAIT_LONGPRESS_READY)
        {
            *menuitem_event = GUI_LIST_PEN_ITEM_SELECTED;
        }
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_is_pen_in_checkbox
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y   
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL gui_fixed_icontext_list_menuitem_is_pen_in_checkbox(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        S16 x,
        S16 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;
    gui_menuitem_icontext_checkbox_struct checkbox;
    S32 checkbox_x, checkbox_y;
    S32 iwidth, iheight;
    MMI_BOOL is_pen_in_checkbox = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {
        gui_menuitem_icontext_list_checkbox_get_data(&checkbox, m, item_x, item_y);
        checkbox_x = checkbox.x;
        checkbox_y = checkbox.y;
        iwidth = checkbox.image_width;
        iheight = checkbox.image_height;
    
        is_pen_in_checkbox = (MMI_BOOL)PEN_CHECK_BOUND(x, y, checkbox_x, checkbox_y, iwidth, iheight);
    }

    return is_pen_in_checkbox;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_hide_fixed_icontext_menuitem
 * DESCRIPTION
 *  Hide an icontext menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y   
 * RETURNS
 *  void
 *****************************************************************************/
void gui_hide_fixed_icontext_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    UI_filled_area *f;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
    U32 flags;
   // PU8 _icon;
    gdi_handle old_alpha_layer;
    S32 icon_width = 0, icon_height = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    flags = mi->flags;
    flags |= m->flags;
    //_icon = mi->item_icon;

    gui_adjust_menuitem_center_align_icon_position(m, mi->item_icon);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + m->height - 1;

    if ((flags & UI_MENUITEM_STATE_FOCUSSED)&& !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
    {
        f = m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        f = m->disabled_filler;
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        f = m->selected_filler;
    }
    else
    {
        f = m->normal_filler;
    }
    #ifdef __128X128_WEARABLE_DEVICE_UI__
    {
        wgui_fixed_list_set_clip(x1, y1, x2, y2);
    }  
    #else
    {
        gui_set_clip(x1, y1, x2, y2);            
    }
    #endif    
    gui_push_and_set_clip(m->icon_x + x1, m->icon_y + y1, m->icon_x + x1 + icon_width - 1, m->icon_y + y1 + icon_height - 1);

    old_alpha_layer = gui_list_set_alpha_blending_layer();
    gui_draw_filled_area(x1, y1, x2, y2, f);
    gui_list_reset_alpha_blending_layer(old_alpha_layer);
    gui_pop_clip();
}
#endif/*__MMI_UI_MENU_SLIM__*/

/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_icontext_menuitem
 * DESCRIPTION
 *  Measure an icontext menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height     
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_icontext_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem *t = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
#ifdef __MMI_UI_HINTS_IN_MENUITEM__
	UI_string_type curr_hint_string = NULL;
#endif/*__MMI_UI_HINTS_IN_MENUITEM__*/

//    U32 index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    *width = t->width;
    *height = t->height;

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    // TODO: configure UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT in other place
    if (MMI_fixed_list_menu.current_displayed_item == -1 && gui_get_two_line_menuitem_height())
    {
        *height = *height << 1;
        t->ext_flags |= UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT;
        t->ext_flags |= UI_MENUITEM_EXT_CONTAIN_TWO_LINE_MENU_ITEM;
        return;
    }
    else
    {
        t->ext_flags &= ~UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT;
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (t->parent_list && t->parent_list->gui_get_current_pop_up_description_string)
    {
  	    curr_hint_string = t->parent_list->gui_get_current_pop_up_description_string();
    }
    if (curr_hint_string && mmi_ucs2strlen((CHAR *)curr_hint_string))
    {
        if (
#ifdef __WGUI_CATE_LIST_ALL_HINTS_IN_MENUITEM__			
			t->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS ||
#endif/*__WGUI_CATE_LIST_ALL_HINTS_IN_MENUITEM__*/			
			(t->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT) && 
            MMI_fixed_list_menu.current_displayed_item == -1
            && !(t->flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        {
            *height = (*height) << 1;
            t->ext_flags |= UI_MENUITEM_EXT_CONTAIN_TWO_LINE_MENU_ITEM;
        } 
    }       
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

        if (mi && mi->flags & UI_MENUITEM_INLINE_EDIT_OBJECT)
        {
        	*height = wgui_get_inline_item_height(wgui_get_current_menuitem_index(&MMI_fixed_list_menu));
#if 0			
#ifdef __MMI_FTE_SUPPORT__
             #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
			#endif
/* under construction !*/
#else /* __MMI_FTE_SUPPORT__ */
#if defined(__MMI_INSCREEN_MULTILINE_TEXTBOX__)
#if defined( __MMI_INLINE_ITEM_MULTILINE_READ_ONLY__) || defined( __MMI_INLINE_ITEM_MULTILINE_EDIT__)
            #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
			#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif
#endif /* __MMI_FTE_SUPPORT__ */ 
#endif//0

        }
	
}


/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_icontext_menuitem
 * DESCRIPTION
 *  Highlight a text menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object           
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_icontext_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*)item;
    //fixed_icontext_menuitem *m = (fixed_icontext_menuitem*)common_item_data;
    //U32 flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	GUI_current_fixed_icontext_menuitem_common_data = (fixed_icontext_menuitem*)common_item_data;//m;
    GUI_current_fixed_icontext_menuitem_data = (fixed_icontext_menuitem_type*)item;//t;
	
    //flags = GUI_current_fixed_icontext_menuitem_common_data->flags;
    //flags |= GUI_current_fixed_icontext_menuitem_data->flags;


    GUI_current_fixed_icontext_menuitem_data->text_width = 0;
    GUI_current_fixed_icontext_menuitem_data->text_height = 0;
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    gui_set_current_two_line_menuitem_data();
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/ 

    if (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL)
    {
        GUI_current_fixed_icontext_menuitem_scroll = MMI_FALSE;
        GUI_current_fixed_icontext_menuitem_common_data->scroll_x = 0;
    }
    gui_fixed_icontext_menuitem_stop_scroll();

#if 0//__MMI_UI_HINTS_IN_MENUITEM__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

    if (!(GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL))
    {
        gui_fixed_icontext_menuitem_start_scroll();
    }
	
    if (!(GUI_current_fixed_icontext_menuitem_data->flags & UI_MENUITEM_DISABLE_HIGHLIGHT))		
    {
		GUI_current_fixed_icontext_menuitem_data->flags |= UI_MENUITEM_STATE_FOCUSSED;
		GUI_current_fixed_icontext_menuitem_data->flags |= UI_MENUITEM_STATE_ANIMATE; 
    }

}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_icontext_menuitem
 * DESCRIPTION
 *  Remove the highlight of an icontext menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext menu item object
 *  common_item_data        [IN]        common icontext menu item object  
 * RETURNS
 *  void
 *****************************************************************************/
#if defined (__MMI_UI_TWO_LINE_MENUITEM_STYLES__) || defined(__MMI_UI_HINTS_IN_MENUITEM__)
static scrolling_text gui_two_line_scroll_text;
#endif/**/ 
void gui_remove_highlight_fixed_icontext_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_menuitem_type *t = (fixed_icontext_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    t->text_width = 0;
    t->text_height = 0;
#if defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) || defined(__MMI_UI_HINTS_IN_MENUITEM__)
    gui_scrolling_text_stop(&gui_two_line_scroll_text);
#endif/*defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__) || defined(__MMI_UI_HINTS_IN_MENUITEM__)*/ 

    gui_fixed_icontext_menuitem_stop_scroll();

    UI_UNUSED_PARAMETER(common_item_data);
    t->flags &= ~UI_MENUITEM_STATE_FOCUSSED;
#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
    gui_reset_current_two_line_menuitem_data();
#endif/*(defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)*/ 

    t->flags &= ~UI_MENUITEM_STATE_ANIMATE;
    if (t->item_icon_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(t->item_icon_handle);
        t->item_icon_handle = GDI_ERROR_HANDLE;
    }
#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    gui_reset_pop_up_description_transition_ex(&wgui_pop_up_description);
#endif/*__MMI_UI_HINT_TOGGLE_TRANSITION__*/ 
}


/*****************************************************************************
 *
 * ICONTEXT LIST MENUITEM                                                             
 *                                                                           
 *                                   
 *
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_list_menuitem_current_theme
 * DESCRIPTION
 *  Apply the current theme to a common icontext list menu item.
 * PARAMETERS
 *  m           [IN]        common icontext list menu item object
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_list_menuitem_current_theme(fixed_icontext_list_menuitem *m)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_fixed_icontext_list_menuitem_theme(m, current_fixed_icontext_list_menuitem_theme);
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_fixed_icontext_list_menuitem_theme
 * DESCRIPTION
 *  Apply the given theme to a common icontext list menu item.
 * PARAMETERS
 *  m           [IN]        common icontext list menu item object
 *  t           [IN]        icontext list menu item theme
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_fixed_icontext_list_menuitem_theme(
        fixed_icontext_list_menuitem *m,
        UI_fixed_icontext_list_menuitem_theme *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->disabled_filler = t->disabled_filler;
    m->flags |= t->flags;
    m->focussed_filler = t->focussed_filler;
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
	gui_menu_replace_menuitem_transparent_filler_by_theme(m);
#if 0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
    m->normal_filler = t->normal_filler;
    m->selected_filler = t->selected_filler;
    for (i = 0; i < m->n_text_columns; i++)
    {
        m->normal_text_colors[i] = t->normal_text_colors[i];
        m->focussed_text_colors[i] = t->focussed_text_colors[i];
        m->selected_text_colors[i] = t->selected_text_colors[i];
        m->disabled_text_colors[i] = t->disabled_text_colors[i];
        m->text_fonts[i] = t->text_fonts[i];
        m->selected_fonts[i] = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Create a common icontext list menu item.
 * PARAMETERS
 *  m               [IN]        common icontext list menu item object
 *  width           [IN]        width
 *  height          [IN]        height
 *  n_text_columns  [IN]        number of text columns
 *  n_icon_columns  [IN]        number of icon columns
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_icontext_list_menuitem(
        fixed_icontext_list_menuitem *m,
        S32 width,
        S32 height,
        S32 n_text_columns,
        S32 n_icon_columns)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	memset(m, 0, sizeof(fixed_icontext_list_menuitem));
    m->width = width;
    m->height = height;
    if (n_icon_columns > FIXED_ICONTEXT_LIST_MAX_ICON_COLUMNS)
    {
        n_icon_columns = FIXED_ICONTEXT_LIST_MAX_ICON_COLUMNS;
    }
    if (n_text_columns > FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS)
    {
        n_text_columns = FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS;
    }
    m->n_icon_columns = n_icon_columns;
    m->n_text_columns = n_text_columns;
    gui_set_fixed_icontext_list_menuitem_current_theme(m);
    m->scroll_width = width;
    m->checkbox_clicked_callback = gui_menuitem_dummy_checkbox_clicked_callback;
    m->checkbox_get_image_callback = gui_menuitem_dummy_checkbox_get_image_callback; 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_post_display
 * DESCRIPTION
 *  Set the post-display callback function for the icontext list menu item.
 * PARAMETERS
 *  m                       [IN]        common icontext list menu item object       
 *  post_display_function   [IN]        post-display callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_set_post_display(
        fixed_icontext_list_menuitem *m,
        void (*post_display_function) (void *item, void *common_item_data, S32 x, S32 y))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->post_display_function = post_display_function;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_post_display
 * DESCRIPTION
 *  Set the post-display callback function for the icontext list menu item.
 * PARAMETERS
 *  m                       [IN]        common icontext list menu item object       
 *  post_display_function   [IN]        post-display callback function
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_menuitem_set_post_display(
        fixed_icontext_menuitem *m,
        void (*post_display_function) (void *item, void *common_item_data, S32 x, S32 y))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->post_display_function = post_display_function;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted icontext list menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // U32 flags = GUI_current_fixed_icontext_list_menuitem_common_data->flags;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0// __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    
  
#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif/*__MMI_UI_MENU_SLIM__*/

   // flags |= GUI_current_fixed_icontext_list_menuitem_data->flags;
    GUI_current_fixed_icontext_list_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

	gui_menu_disable_transparent_effect_when_multilayer(GUI_current_fixed_icontext_list_menuitem_common_data);
#if 0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
   /*
    * Disable the list effect for showing the highlighted menu item later.
    * When scrolling, no list effect is allowed. e.g., HIGHLIGHT_EFFECT_FLASH_FEELING.
    */
    gui_reset_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

    for (i = 0; i < MMI_fixed_icontext_list_menuitem.n_text_columns; i++)
    {
        if (GUI_current_fixed_icontext_list_menuitem_text_is_scroll[i])
        {
            gui_handle_scrolling_text(&gui_current_scroll_text[i]);
        }
    }
	
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    /* restore list effect */
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    gui_fixed_icontext_list_enable_transparent_effect(GUI_current_fixed_icontext_list_menuitem_common_data);        /* To enable transparency */
#endif/*__MMI_UI_TRANSPARENT_EFFECT__*/ 

    GUI_current_fixed_icontext_list_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_FALSE;
#endif/*__MMI_UI_MENU_SLIM__*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_reset_scroll_text_column
 * DESCRIPTION
 *  Set the scrolling text column to the first column.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_reset_scroll_text_column(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* This cannot be done in gui_fixed_icontext_list_menuitem_stop_scroll() 
       because we need to keep text scroll column unchanged when highlight is switched */
    GUI_current_fixed_icontext_list_menuitem_column = 0;
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_start_scroll
 * DESCRIPTION
 *  Start scrolling for the highlighted icontext list menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem_type *t =
        (fixed_icontext_list_menuitem_type*) GUI_current_fixed_icontext_list_menuitem_data;
    fixed_icontext_list_menuitem *m =
        (fixed_icontext_list_menuitem*) GUI_current_fixed_icontext_list_menuitem_common_data;
    S32 w , text_column;
    U32 flags;
    MMI_BOOL do_scroll = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (t == NULL || m == NULL)
    {
        return;
    }

    flags = m->flags;
    flags |= t->flags;

    for (text_column = 0; text_column < FIXED_ICONTEXT_LIST_MAX_TEXT_COLUMNS; text_column ++)
    {
        GUI_current_fixed_icontext_list_menuitem_text_is_scroll[text_column] = 0;
    }

	if(!(m->flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
	{
		gui_execute_list_menu_item_resize_function(); 
	}
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
	#endif//0

    gui_add_cleanup_hook(gui_fixed_icontext_list_menuitem_reset_scroll_text_column);

    if (flags & UI_MENUITEM_AUTO_CHOOSE_MARQUEE)
    {
        S32 i;

        for (i = 0; i < m->n_text_columns; i++)
        {
            if (m->selected_fonts[i])
            {
                gui_set_font(m->selected_fonts[i]);
            }
            else
            {
                gui_set_font(m->text_fonts[i]);
            }
            w = gui_get_string_width(t->item_texts[i]);
            if (i == 0)
            {
                m->text_width = w;
            }
            else if (w > m->text_width)
            {
                m->text_width = w;
            }

            m->scroll_x = 0;
            if (w > m->text_coordinates[i].width)
            {
                GUI_current_fixed_icontext_list_menuitem_text_is_scroll[i] = 1;
                GUI_current_fixed_icontext_list_menuitem_column = i;
                m->scroll_width = m->text_coordinates[i].width;
                do_scroll = MMI_TRUE;
                
                gui_create_scrolling_text(
                    &gui_current_scroll_text[i],
                    0,
                    0,
                    0,
                    0,
                    (UI_string_type)t->item_texts[i],
                    gui_fixed_icontext_list_menuitem_scroll_handler,
                    scrolling_text_draw_icontext_list_single_line_background,
                    MMI_fixed_icontext_list_menuitem.focussed_text_colors[i],
                    MMI_fixed_icontext_list_menuitem.focussed_text_colors[i]);
                gui_scrolling_text_start(&gui_current_scroll_text[i]);
                //break;
            }
        }
    }
    else
    {
        if (GUI_current_fixed_icontext_list_menuitem_column >= m->n_text_columns)
        {
            //MMI_DBG_ASSERT(0);
            GUI_current_fixed_icontext_list_menuitem_column = 0;
        }

        if (m->selected_fonts[GUI_current_fixed_icontext_list_menuitem_column])
        {
            gui_set_font(m->selected_fonts[GUI_current_fixed_icontext_list_menuitem_column]);
        }
        else
        {
            gui_set_font(m->text_fonts[GUI_current_fixed_icontext_list_menuitem_column]);
        }
        w = gui_get_string_width(t->item_texts[GUI_current_fixed_icontext_list_menuitem_column]);
        m->scroll_width = m->text_coordinates[GUI_current_fixed_icontext_list_menuitem_column].width;
        m->text_width = w;
        m->scroll_x = 0;
        
        /* only scroll when the text is not empty (a fix for the bi-degree main menu) */
        if (w && (w > m->scroll_width))
        {
            do_scroll = MMI_TRUE;
            GUI_current_fixed_icontext_list_menuitem_text_is_scroll[GUI_current_fixed_icontext_list_menuitem_column] = 1;
            gui_create_scrolling_text(
                &gui_current_scroll_text[GUI_current_fixed_icontext_list_menuitem_column],
                0,
                0,
                0,
                0,
                (UI_string_type)t->item_texts[GUI_current_fixed_icontext_list_menuitem_column],
                gui_fixed_icontext_list_menuitem_scroll_handler,
                scrolling_text_draw_icontext_list_single_line_background,
                MMI_fixed_icontext_list_menuitem.focussed_text_colors[GUI_current_fixed_icontext_list_menuitem_column],
                MMI_fixed_icontext_list_menuitem.focussed_text_colors[GUI_current_fixed_icontext_list_menuitem_column]);
            gui_scrolling_text_start(&gui_current_scroll_text[GUI_current_fixed_icontext_list_menuitem_column]);
        }
    }

    if (do_scroll)
    {
        if ((flags & UI_MENUITEM_MARQUEE_SCROLL))
        {
            GUI_current_fixed_icontext_list_menuitem_scroll = 1;
        //    GUI_current_fixed_icontext_list_menuitem_scroll_direction = 0;
            GUI_current_fixed_icontext_list_menuitem_scroll_counter = UI_text_menuitem_scroll_pause;

        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            if (gui_get_current_list_effect() && !gblock_list_effect)
            {
                gui_register_callback_menuitem_scroll(gui_fixed_icontext_list_menuitem_scroll_handler);
            }
        #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        }
    }
    else
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    {
        gui_register_callback_menuitem_scroll(UI_dummy_function);
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
    }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    {
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
    }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted icontext list menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (GUI_current_fixed_icontext_list_menuitem_scroll)
    {
        gui_cancel_timer(gui_fixed_icontext_list_menuitem_scroll_handler);
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
    }

#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    gui_two_line_scroller_stop();
#endif/*defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)*/

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_register_callback_menuitem_scroll(UI_dummy_function);
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_text_coordinates
 * DESCRIPTION
 *  Set the coordinate and dimension for a text column.
 * PARAMETERS
 *  m               [IN]        common icontext list menu item object
 *  text_column     [IN]        text column index
 *  x               [IN]        text x
 *  y               [IN]        text y
 *  width           [IN]        text width
 *  height          [IN]        text height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_set_text_coordinates(
        fixed_icontext_list_menuitem *m,
        S32 text_column,
        S32 x,
        S32 y,
        S32 width,
        S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (text_column >= m->n_text_columns)
    {
        return;
    }
    m->text_coordinates[text_column].x = x;
    m->text_coordinates[text_column].y = y;
    m->text_coordinates[text_column].width = width;
    m->text_coordinates[text_column].height = height;
    if (text_column == GUI_current_fixed_icontext_list_menuitem_column)
    {
        m->scroll_width = width;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_list_menuitem_set_icon_coordinates
 * DESCRIPTION
 *  Set the coordinate and dimension for an icon column.
 * PARAMETERS
 *  m               [IN]        common icontext list menu item object
 *  icon_column     [IN]        icon column index
 *  x               [IN]        icon x
 *  y               [IN]        icon y
 *  width           [IN]        icon width
 *  height          [IN]        icon height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_icontext_list_menuitem_set_icon_coordinates(
        fixed_icontext_list_menuitem *m,
        S32 icon_column,
        S32 x,
        S32 y,
        S32 width,
        S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (icon_column < m->n_icon_columns)
    {   
	    m->icon_coordinates[icon_column].x = x;
	    m->icon_coordinates[icon_column].y = y;
	    m->icon_coordinates[icon_column].width = width;
	    m->icon_coordinates[icon_column].height = height;
	}
}


/*****************************************************************************
 * FUNCTION
 *  gui_resize_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Resize a common icontext list menu item.
 * PARAMETERS
 *  m           [IN]        common icontext list menu item object
 *  width       [IN]        new width
 *  height      [IN]        new height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_resize_fixed_icontext_list_menuitem(fixed_icontext_list_menuitem *m, S32 width, S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->width = width;
    m->height = height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_icontext_list_menuitem_flag
 * DESCRIPTION
 *  get the flag of  icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_icontext_list_menuitem_flag(
	void *item, 
	void *common_item_data, 
	S32 index, 
	U32* flags, 
	U32* flags_ext)
{
   gui_get_fixed_menuitem_flag(item, common_item_data, index, flags,flags_ext, 0);
}

/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Show an icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_icontext_list_menuitem(
	void *item, 
	void *common_item_data, 
	S32 x, 
	S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    S32 ix1, iy1, ix2, iy2;
    color text_color;
    UI_filled_area *f = NULL;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;
    fixed_icontext_list_menuitem_type *mi = (fixed_icontext_list_menuitem_type*) item;
    U32 flags, flags_ext;
    UI_string_type _text;
    PU8 _icon;
   // U8 animation_flag = 0;
    U8 focussed_flag = 0;
    U8 disabled_flag = 0;
    U8 selected_flag = 0;
    S32 i;
#ifdef __MMI_WEARABLE_DEVICE__
	MMI_BOOL show_highlight = MMI_FALSE;
#endif /*__MMI_WEARABLE_DEVICE__*/
#if 0
/* under construction !*/
#endif
    S32 sw, sh;
    U32 ret_flag_ext = 0;
#ifndef __MMI_MAINLCD_96X64__
    U32 ret_flag = 0;
//    gdi_handle alpha_layer;
#endif /* __MMI_MAINLCD_96X64__ */

    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
    S32 icon_width = 0, icon_height = 0;

#ifndef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
#ifndef __MMI_UI_MENU_SLIM__
    S32 count = 0;
#endif/*__MMI_UI_MENU_SLIM__*/
#endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/

    S32 clip_x1, clip_x2, clip_y1, clip_y2;

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    S32 i_width, i_height;
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/

#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    MMI_BOOL show_hint_in_menuitem = MMI_FALSE;
    UI_string_type curr_hint_string = NULL;
    S32 text_width = 0;
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_handle act_layer = GDI_NULL_HANDLE;
#endif/*__MMI_UI_MENU_SLIM__*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#if  0
/* under construction !*/
#endif
//get flags
#ifndef __MMI_MAINLCD_96X64__
   if (g_gui_list_get_menuitem_flags)
	{     
	       #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		   #endif//0
		   g_gui_list_get_menuitem_flags(wgui_get_current_menuitem_index(&MMI_fixed_list_menu), &ret_flag, &ret_flag_ext);
   	}
   ret_flag = 0;
#endif /* __MMI_MAINLCD_96X64__ */

   gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);

    if (flags & UI_MENUITEM_STATE_FOCUSSED)
    {
        GUI_current_fixed_icontext_list_menuitem_x = x;
        GUI_current_fixed_icontext_list_menuitem_y = y;
    }

    x1 = x;
    y1 = y;
    y2 = y1 + m->height - 1;
    x2 = x1 + m->width - 1;
//get menu region h
     gui_get_menu_top_and_bottom_position(m, &menu_y1, &menu_y2);

#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    show_hint_in_menuitem = gui_menuitem_has_hint((gui_common_menuitem_base_struct*) m, flags & UI_MENUITEM_STATE_FOCUSSED);
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
    {
        gui_measure_fixed_icontext_list_menuitem(item, common_item_data, &i_width, &i_height);
        y2 = y1 + i_height - 1;
    }
	else
#endif
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && 
        (m->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT)
        #ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
        &&(!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
        #endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
        )
    {
        focussed_flag = 1;
#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        if (show_hint_in_menuitem)
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        {
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
            if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
            {
                y2 = y1 + (i_height + m->height) - 1;
            }
            else
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/
            //{
            	y2 = y1 + (m->height << 1) - 1;
            //}
            gui_show_two_line_icontext_list_menuitem(item, common_item_data, &f);
        }
#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        else
        {
            f = m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        }
#endif  // defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    }
    else if ((flags & UI_MENUITEM_STATE_FOCUSSED)
		#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
		&& !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
		#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
		#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__) //add by xl
		 && (MMI_TRUE == pen_down_in_list)
		#endif /*__MMI_WEARABLE_DEVICE__*/
		)
    {
		#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__)//add by xl
		if (MMI_FALSE == g_gui_ssp_launch)
		{
			pen_down_in_list = MMI_FALSE;
		}
		#endif /*__MMI_WEARABLE_DEVICE__*/
        f = m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        #ifdef __MMI_WEARABLE_DEVICE__
        show_highlight = MMI_TRUE;
		#endif /*__MMI_WEARABLE_DEVICE__*/
		//if (g_dm_data.s32CatId != MMI_CATEGORY414_ID)
        //{
            fixed_single_line_menuitem_filled_area = *f;
        //}
		focussed_flag = 1;
      //  if (flags & UI_MENUITEM_FOCUSSED_ANIMATE)
      //  {
      //      animation_flag = 1;
      //  }
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {

        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))		
      //  {
            f = m->disabled_filler;
      //  }
        disabled_flag = 1;
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {
        f = m->selected_filler;
      //  if (flags & UI_MENUITEM_SELECTED_ANIMATE)
      //  {
      //      animation_flag = 1;
      //  }
        selected_flag = 1;
    }
    else
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))		
       // {
            f = m->normal_filler;
        //}
    }

#ifndef __MMI_WEARABLE_DEVICE__
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    /* cascading menu special case, disabled text color with a highlighted filler. */
    if ((flags & UI_MENUITEM_STATE_FOCUSSED) && (flags & UI_MENUITEM_STATE_DISABLED))
    {
        f = m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        focussed_flag = 0;
        disabled_flag = 1;
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/


    gui_push_clip();
    
    clip_x1 = x1;
    clip_x2 = x2;
    clip_y1 = y1;
    clip_y2 = y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
    }            
#endif/*__MMI_UI_MENU_SLIM__*/
    if (y1 >= menu_y2)
    {
        clip_y1 = menu_y2;
        clip_y2 = menu_y2;
    }
    else if (y2 >= menu_y2)
    {
        clip_y2 = menu_y2;
    }
    
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    #ifdef __128X128_WEARABLE_DEVICE_UI__
    {
        wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    }  
    #else
    {
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
    }
    #endif    

    if (m->flags & UI_MENUITEM_DISABLE_HIGHLIGHT_DISPLAY)
    {
        f = NULL;
    }
#else/*__MMI_UI_MENU_SLIM__*/

	gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/

    if (f != NULL
#ifndef __MMI_UI_MENU_SLIM__
		&& !g_slide_effect->in_flatten
#endif/*__MMI_UI_MENU_SLIM__*/
		)
    {
    #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        if (is_draw_next_frame_list_highlight_effect_value())
    #endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/
        {
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_ICONTEXT_LIST);
        }
    #endif/*__MMI_SUPPORT_DUMP_SCREEN_STRING__*/

        old_alpha_layer = gui_list_set_alpha_blending_layer();
        set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);

    #if 0//defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

        gui_swla_log_start("IFL");
#if  0
/* under construction !*/
#else   // __OP01_FWPBW__
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_draw_list_filled_area(x1, y1, x2, y2, f);
    #else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#ifndef __MMI_UI_MENU_SLIM__
		if (gui_filled_area_is_animation(f))
        {
            gdi_image_get_frame_count(f->b, &count);
            if (gblock_list_animation_highlight)
            {   
                if (count >= 1)
                {
                    gdi_image_draw_frames(x1, y1, f->b, count - 1);
                }
                else
                {
                    gui_draw_filled_area(x1, y1, x2, y2, f);
                }
            }
            else
            {
                gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);

//#ifndef __MMI_UI_MENU_SLIM__
				if (count >= 1)
                {
                    gui_draw_animated_effect_filler(x1, y1, x2, y2, f);            
                }
                else
//#endif					
                {
                    gui_draw_filled_area(x1, y1, x2, y2, f);
                } 
            }           
        }            
        else
#endif/*__MMI_UI_MENU_SLIM__*/
       // {
            gui_draw_filled_area(x1, y1, x2, y2, f);
        //}
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#endif  //__OP01_FWPBW__
        gui_swla_log_stop("IFL");

    #if 0//defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)

        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    if ((m->highlight_twoline_display_function != NULL) && (flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        m->highlight_twoline_display_function(item, x1, y1, x2, y2);
        gui_pop_clip();
        return;
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

    /* To hide the text and icon of the menuitem up to the last frame for flash feel effect */
#if 0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    

    /* show checkbox, show it here to correspond to list effects since */
    if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
    {
        gui_menuitem_icontext_list_show_checkbox(m, x1, y1);
    }


//draw icons
#ifndef __MMI_WEARABLE_DEVICE__
    old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#else
	if (show_highlight == MMI_TRUE)
	{
		old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
	}
#endif /*__MMI_WEARABLE_DEVICE__*/
    if (!(flags & UI_MENUITEM_DISABLE_ICON))
    {
    for (i = 0; i < m->n_icon_columns; i++)
    {
        /* For bi-degree main menu */
        /* selected item, should draw selected image */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
            #endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__

        if (mi->item_icon_handles[i] != GDI_ERROR_HANDLE)
        {
            gdi_image_stop_animation(mi->item_icon_handles[i]);
            mi->item_icon_handles[i] = GDI_ERROR_HANDLE;
        }
        _icon = mi->item_icons[i];
        /* _icon_handle=mi->item_icon_handles[i]; */
#if defined(__MMI_CASCADED_OPTION_MENU__)		
        if (i == 0 && g_dm_data.s32CatId == MMI_CATEGORY_CASCADING_MENU_ID &&
            flags & UI_MENUITEM_STATE_FOCUSSED)
        {
            if (flags_ext & UI_MENUITEM_EXT_WITH_SUBMENU)
            {
                if (mmi_fe_get_r2l_state() && _icon == current_MMI_theme->cascade_menu_submenu_left_arrow_image)
                    _icon = current_MMI_theme->cascade_menu_submenu_highlight_left_arrow_image;
                else if (!mmi_fe_get_r2l_state() && _icon == current_MMI_theme->cascade_menu_submenu_right_arrow_image)
                    _icon = current_MMI_theme->cascade_menu_submenu_highlight_right_arrow_image;
            }
        }
#endif/*__MMI_CASCADED_OPTION_MENU__*/		

    #if 0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */
 

        /* calculate the icon position */
        iy1 = m->icon_coordinates[i].y + y1;
        if (_icon != UI_NULL_IMAGE)
        {
			//add by xl
			#ifdef __MMI_WEARABLE_DEVICE_NOTI_UI_ENHANCE__
			if (mi->item_icon_flags[i] & UI_MENUITEM_IMAGE_PATH)
			{
				gdi_image_get_dimension_file(_icon, &icon_width, &icon_height);
			}
            else if (mi->item_icon_flags[i] & UI_MENUITEM_IMAGE_MEM)
            {
                icon_width = m->icon_coordinates[i].width;
				icon_height = m->icon_coordinates[i].height;
            }
			else 	
			#endif //add end	
			{
            gui_measure_image(_icon, &icon_width, &icon_height);
			}
			#ifdef __MMI_WEARABLE_DEVICE_NOTI_UI_ENHANCE__
			if (m->icon_coordinates[i].width > icon_width)
			{
				icon_width = m->icon_coordinates[i].width;
				icon_height = m->icon_coordinates[i].height;
			}
			#endif //add end  
            if (flags & UI_MENUITEM_CENTER_ICON_X)
            {
                m->icon_coordinates[i].x = (m->width >> 1) - (icon_width >> 1);
            }

            if (!(m->flags & MENU_MUTLIROW_ICON_LIST))
            {
                if (flags & UI_MENUITEM_CENTER_ICON_Y)
                {
                    if (m->height == MMI_MENUITEM_HEIGHT)
                        iy1 = m->icon_coordinates[i].y + y1 + (m->height >> 1) - (icon_height >> 1);
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
                    else if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
                        iy1 = m->icon_coordinates[i].y + y1 + (i_height >> 1) - (icon_height >> 1);
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/
                    else
                        iy1 = m->icon_coordinates[i].y + y1 + (m->icon_coordinates[i].height >> 1) - (icon_height >> 1);
                }
            }
            if (mmi_fe_get_r2l_state())
            {
                ix1 = x2 - m->icon_coordinates[i].x - icon_width + 1;
            }
            else
            {
                ix1 = m->icon_coordinates[i].x + x1;
            }
            ix2 = ix1 + icon_width - 1;
            iy2 = iy1 + icon_height - 1;
        }
        else
        {            
            if (mmi_fe_get_r2l_state())
            {
                ix1 = x2 - m->icon_coordinates[i].x - m->icon_coordinates[i].width + 1;
            }
            else
            {
                ix1 = m->icon_coordinates[i].x + x1;
            }
            ix2 = ix1 + m->icon_coordinates[i].width - 1;
            iy2 = iy1 + m->icon_coordinates[i].height - 1;
        }

        if (ix2 > x2)
        {
            ix2 = x2;
        }
        if (iy2 > y2)
        {
            iy2 = y2;
        }

        gui_push_clip();

        clip_x1 = ix1;
        clip_y1 = iy1;
        clip_x2 = ix2;
        clip_y2 = iy2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }            
#endif/*__MMI_UI_MENU_SLIM__*/
        if (iy1 >= menu_y2)
        {
            clip_y1 = menu_y2;
            clip_y2 = menu_y2;
        }
        else if (iy2 >= menu_y2)
        {
            clip_y2 = menu_y2;
        }
	//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        }  
        #else
        {
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
        }
        #endif    
#else/*__MMI_UI_MENU_SLIM__*/
		gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/
        if (_icon != UI_NULL_IMAGE && iy1 < y2)
        {
            /* 
             * UI_MENUITEM_HIGHLIGHT_SWITCH_ICON is for bi-degree main menu only.
             */
            UI_filled_area         *anim_bkg_filler = NULL;

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
            if (gui_is_menuitem_show_animation_when_hilited(flags))
            {
                gui_swla_log_start("ICO");
                gui_show_animation_with_background_filler(ix1, iy1, _icon, anim_bkg_filler, &(mi->item_icon_handles[i]));
                gui_swla_log_stop("ICO");
                
                m->flags |= UI_MENUITEM_STATE_ANIMATE;
            }
            else
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/				
            {
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //  __MMI_BI_DEGREE_MAIN_MENU_STYLE__

                gui_swla_log_start("ICO");
		#ifdef __MMI_WEARABLE_DEVICE_NOTI_UI_ENHANCE__
			if (mi->item_icon_flags[i] & UI_MENUITEM_IMAGE_PATH)
			{
				//gdi_image_draw_resized_file(ix1,iy1,m->menuitem_icon_width,m->menuitem_icon_height,_icon);
				gdi_image_draw_resized_file(ix1, iy1, icon_width, icon_height, _icon);
			}
			else if (mi->item_icon_flags[i] & UI_MENUITEM_IMAGE_MEM)
			{
				gdi_image_draw_resized_mem(ix1,iy1,icon_width,icon_height,_icon,GDI_IMAGE_TYPE_JPG, mi->item_icon_len[i]);
				//gdi_image_draw_mem(ix1,iy1,_icon,GDI_IMAGE_TYPE_JPG, mi->item_icon_len[i]);
			}
			else	
		#endif	//add by xl end
			{
		#ifdef __MMI_WEARABLE_DEVICE__
				//gdi_image_draw_resized_frames(ix1, iy1, m->menuitem_icon_width, m->menuitem_icon_height, _icon, 0);
				gdi_image_draw_resized_frames(ix1, iy1, icon_width, icon_height, _icon, 0);
		#else
                gdi_image_draw_frames(ix1, iy1, _icon, 0);
		#endif
			}	
                gui_swla_log_stop("ICO");

#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_BI_DEGREE_MAIN_MENU_STYLE__
                
                if (m->flags & UI_MENUITEM_STATE_ANIMATE)
                {
                    m->flags &= ~UI_MENUITEM_STATE_ANIMATE;
                }
            }
        }

        gui_pop_clip();

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //  __MMI_BI_DEGREE_MAIN_MENU_STYLE__
    }
    }
#ifndef __MMI_WEARABLE_DEVICE__
    gui_list_reset_alpha_blending_layer(old_alpha_layer);
#else
	if (show_highlight == MMI_TRUE)
	{
		gui_list_reset_alpha_blending_layer(old_alpha_layer);
	}
#endif /*__MMI_WEARABLE_DEVICE__*/


//draw text
    gui_push_text_clip();

    clip_x1 = x1;
    clip_y1 = y1;
    clip_x2 = x2;
    clip_y2 = y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
    }            
#endif/*__MMI_UI_MENU_SLIM__*/

    if (y1 >= menu_y2)
    {
        clip_y1 = menu_y2;
        clip_y2 = menu_y2;
    }
    else if (y2 >= menu_y2)
    {
        clip_y2 = menu_y2;
    }
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    #ifdef __128X128_WEARABLE_DEVICE_UI__
    {
        wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    }  
    #else
    {
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
    }
    #endif    
#else/*__MMI_UI_MENU_SLIM__*/  
	gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/


#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
    {

    //unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        S32 col1_iy1 = 0, col1_ascent = 0;
#endif/*__MMI_UI_MENU_SLIM__*/

#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#endif  // __MMI_VECTOR_FONT_SUPPORT__
        for (i = 0; i < m->n_text_columns; i++)
        {
            _text = mi->item_texts[i];
            if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) &&
				 #ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
                (MMI_current_menu_type == LIST_MENU) &&                
                (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)) &&
                #endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
                (m->selected_fonts[i]))
            {
                gui_set_font(m->selected_fonts[i]);
            }
            else
            {
                gui_set_font(m->text_fonts[i]);
            }
            gui_measure_string(_text, &sw, &sh);
            if (flags & UI_MENUITEM_CENTER_TEXT_X)
            {
                m->text_coordinates[i].x = (m->width >> 1) - (sw >> 1);
                ix1 = m->text_coordinates[i].x + x1;
                ix2 = ix1 + m->text_coordinates[i].width - 1;
            }

            iy1 = m->text_coordinates[i].y + y1;
            iy2 = iy1 + m->text_coordinates[i].height - 1;
            
            if (m->flags & UI_MENUITEM_ICONTEXT_LIST_ALL_TEXT_VERTICAL_ALIGN_CENTER)
            {
                iy1 += (m->text_coordinates[i].height - sh) / 2;
            }
            else
            {
                if (!(m->flags & MENU_MUTLIROW_ICON_LIST))
                {
                    if (flags & UI_MENUITEM_CENTER_TEXT_Y)
                    {
                    //unimportant issues
                    #ifndef __MMI_UI_MENU_SLIM__
                        if ((i == 1) && (mi->flags & UI_MENUITEM_TEXT_COL1_IS_NUMBER))
                        {
                            /* special case for UI_MENUITEM_TEXT_COL1_IS_NUMBER) */
                            mmi_fe_get_string_info_param_struct query;
                            memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
                            query.String = (U8*)_text;
                            query.checkCompleteWord = MMI_FALSE;
                            query.enableTruncated = MMI_FALSE;
                            query.n =  mmi_ucs2strlen((const char*)_text);
                            query.w = 0;
                            mmi_fe_get_string_widthheight(&query);

                            iy1 = col1_iy1 + (col1_ascent - query.maxAscent);
                            iy2 = iy1 + m->text_coordinates[i].height - 1;
                        }
                        else
					#endif/*__MMI_UI_MENU_SLIM__*/
							if (m->height == MMI_MENUITEM_HEIGHT)
                        {
                            iy1 = m->text_coordinates[i].y + y1 + (m->height >> 1) - (sh >> 1);
                            iy2 = iy1 + m->text_coordinates[i].height - 1;
                        }
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
                        else if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
                        {
                            iy1 = m->text_coordinates[i].y + y1 + (i_height >> 1) - (sh >> 1);
                            iy2 = iy1 + m->text_coordinates[i].height - 1;
                        }
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/
                        else
                        {
                            iy1 = m->text_coordinates[i].y + y1 + (m->text_coordinates[i].height >> 1) - (sh >> 1);
                            iy2 = iy1 + sh - 1;
                        }
                    }
                }
            }
            
			if ((flags & UI_MENUITEM_DISABLE_ICON) &&(m->n_text_columns == 1))
			{
				ix1 = x1 + 2;
                ix2 = x2 - 2;
			}
            else
            {
                if (mmi_fe_get_r2l_state())
                {
                    ix1 = x2 - m->text_coordinates[i].x - m->text_coordinates[i].width + 1;
                    ix2 = ix1 + m->text_coordinates[i].width - 1;
                }
                else
                {
                    ix1 = m->text_coordinates[i].x + x1;
                    ix2 = ix1 + m->text_coordinates[i].width - 1;
                }
            }
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
            if (flags & UI_MENUITEM_STATE_FOCUSSED && f && f->flags & UI_FILLED_AREA_SINGLE_BORDER)
            {
                if (ix2 > x2 - 1)
                {
                    ix2 = x2 - 1;
                }
            }
            else
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/				
          //  {
            if (ix2 > x2)
            {
                ix2 = x2;
            }
            //}
            
            if (iy2 > y2)
            {
                iy2 = y2;
            }

#if 0    // none will use UI__MENUITEM_FILL_COL1, so colorangewgui_pop_up_dialog_background is useless 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_GUI_LIST_MENU_FULL_PACKAGE__            
            if ( _text && mmi_ucs2strlen((CHAR *)_text) && iy1 < y2)
                {
                    if (disabled_flag)
                    {
                    #ifndef __MMI_UI_MENU_SLIM__
                        if (flags_ext & UI_MENUITEM_EXT_DISABLED_NORMAL_TEXT)
                        {
                            text_color = m->normal_text_colors[i];
                        }
                        else
					#endif/*__MMI_UI_MENU_SLIM__*/		
                       // {
                            text_color = m->disabled_text_colors[i];
                       // }
                    }
                    else if (focussed_flag)
                    {
                        text_color = m->focussed_text_colors[i];
                    }
                    else if (selected_flag)
                    {
                        text_color = m->selected_text_colors[i];
                    }
                    else
                    {
                        text_color = m->normal_text_colors[i];
                    }

#if 0//__MMI_OP01_DCD__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // __MMI_OP01_DCD__                    


                    gui_push_clip();
#ifdef __MMI_MAINMENU_PAGE_SUPPORT__
                    if (!(flags & UI_MENUITEM_DISABLE_TEXT_CLIP))
#endif/*__MMI_MAINMENU_PAGE_SUPPORT__*/
                    {
                        clip_x1 = ix1;
                        clip_x2 = ix2;
                        clip_y1 = iy1;
                        clip_y2 = iy2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
                        gdi_layer_get_active(&act_layer);
                        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
                        {
                            clip_y1 = m->parent_list->y;
                        }   
#endif/*__MMI_UI_MENU_SLIM__*/
                        if (iy1 >= menu_y2)
                        {
                            clip_y1 = menu_y2;
                            clip_y2 = menu_y2;
                        }
                        else if (iy2 >= menu_y2)
                        {
                            clip_y2 = menu_y2;
                        }

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
                        #ifdef __128X128_WEARABLE_DEVICE_UI__
                        {
                            wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
                        }  
                        #else
                        {
                            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
                        }
                        #endif    
#else/*__MMI_UI_MENU_SLIM__*/
						gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/
                    }
                    gui_set_text_color(text_color);

#if 1//ndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
                    /* Added specifically to right justify second column in case of two column display with numbers */
                    if ((i == 1) && 
                        (flags & UI_MENUITEM_RIGHT_JUSTIFY_COL2) && 
                        (sw <= m->text_coordinates[i].width))
                    {
                        if (mmi_fe_get_r2l_state())
                        {
                            gui_move_text_cursor(ix1 + sw, iy1);
                        }
                        else
                        {
                            gui_move_text_cursor(ix2 - sw, iy1);
                        }

                        gui_set_line_height(sh);
                        gui_print_text(_text);
                    }
                    else
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/						
                    {       
                        S32 temp_text_width = m->text_coordinates[i].width;
                        if ((flags & UI_MENUITEM_DISABLE_ICON) &&(m->n_text_columns == 1) && (i == 0))
                        {
                            temp_text_width = ix2 - ix1 + 1;
                        }
                        
                        if ((flags & UI_MENUITEM_STATE_FOCUSSED) &&
                            ((i == GUI_current_fixed_icontext_list_menuitem_column) ||
                            (m->flags & UI_MENUITEM_AUTO_CHOOSE_MARQUEE)))
                            /* Second Column Text Scroll Change For Multi Row List */
                        {
                            if (sw > temp_text_width)
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_move_text_cursor(ix2 + m->scroll_x, iy1);
                                }
                                else
                                {
                                    gui_move_text_cursor(ix1 + m->scroll_x, iy1);
                                }
                            }
                            else
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_move_text_cursor(ix2, iy1);
                                }
                                else
                                {
                                    gui_move_text_cursor(ix1, iy1);
                                }
                            }
                            gui_set_line_height(sh);

                            /* trucate too long number/name in call list. */
                            if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_print_truncated_text(ix2, iy1, temp_text_width, _text);
                                }
                                else
                                {
                                    gui_print_truncated_text(ix1, iy1, temp_text_width, _text);
                                }
                            }
                            else
                            {
                                if ((flags & UI_MENUITEM_MARQUEE_SCROLL) &&
                                    (sw > temp_text_width) &&
                                    GUI_current_fixed_icontext_list_menuitem_scroll 
								     &&
                                    ((iy1 >= menu_y1 && iy1 + sh <= menu_y2) || !g_current_display_half_menuitem)
)
                                {
                                    gui_menuitem_redraw_scrolling_text(
                                        &(gui_current_scroll_text[i]),
                                        ix1,
                                        iy1,
                                        temp_text_width,
                                        sh + 1,
                                        &text_color);
                                 }
                                 else
                                 {
                                     gui_print_text(_text);
                                 }
                            }
                        }
                        else
                        {
                            if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
                            {
                                gui_set_line_height(sh);
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_print_truncated_text(ix2, iy1, temp_text_width, _text);
                                }
                                else
                                {
                                    gui_print_truncated_text(ix1, iy1, temp_text_width, _text);
                                }
                            }
                            else
                            {
                                if (mmi_fe_get_r2l_state())
                                {
                                    gui_move_text_cursor(ix2, iy1);
                                }
                                else
                                {
                                    gui_move_text_cursor(ix1, iy1);
                                }
                                
                                gui_set_line_height(sh);

								#ifndef __MMI_UI_MENU_SLIM__
                                if ((i == 0) && (mi->flags & UI_MENUITEM_TEXT_COL1_IS_NUMBER))
                                {   /* special case for cateogry 89 "1." in Arabic */
                                //unimportant issues
                               
                                    mmi_fe_get_string_info_param_struct query;
                                    memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
                                    query.String = (U8*)_text;
                                    query.checkCompleteWord = MMI_FALSE;
                                    query.enableTruncated = MMI_FALSE;
                                    query.n =  mmi_ucs2strlen((const char*)_text);
                                    query.w = 0;
                                    mmi_fe_get_string_widthheight(&query);

                                    col1_ascent = query.maxAscent;
                                    col1_iy1 = iy1;
                                 
                                    gui_print_text_by_direction(_text);
                                }
                                else
								#endif/*__MMI_UI_MENU_SLIM__*/	
                                {
                                //huking
                                #if 1
//                                #ifdef __MMI_UI_LIST_TRUNCATE_ITEM__
                                    if (mmi_fe_get_r2l_state())
                                    {
                                        gui_print_truncated_text(ix2, iy1, temp_text_width, _text);
                                    }
                                    else
                                    {
                                        gui_print_truncated_text(ix1, iy1, temp_text_width, _text);
                                    }
                                #else /* __MMI_UI_LIST_TRUNCATE_ITEM__ */
/* under construction !*/
                                #endif /* __MMI_UI_LIST_TRUNCATE_ITEM__ */
                                }                                
                            }
                        }
                    }
                    gui_pop_clip();

                }
            }
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
            gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif/*__MMI_VECTOR_FONT_SUPPORT__*/
        }



#ifdef __MMI_MENUITEM_DOTTED_UNDERLINE_SUPPORT__
    if (flags & UI_MENUITEM_DOTTED_UNDERLINE)
    {
        static const U8 dotted_line_bitvalues[] = {1, 1, 1, 1, 0, 0, 0};
        color underline_color = m->normal_text_colors[0];

        clip_x1 = x1;
        clip_x2 = x2;
        clip_y1 = y1;
        clip_y2 = y2;

        gui_push_clip();

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        gdi_layer_get_active(&act_layer);
        if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
        {
            clip_y1 = m->parent_list->y;
        }            
#endif/*__MMI_UI_MENU_SLIM__*/
        if (y1 >= menu_y2)
        {
            clip_y1 = menu_y2;
            clip_y2 = menu_y2;
        }
        else if (y2 >= menu_y2)
        {
            clip_y2 = menu_y2;
        }
		//unimportant issues
		#ifndef __MMI_UI_MENU_SLIM__
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        }  
        #else
        {
            gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);            
        }
        #endif    
		#else/*__MMI_UI_MENU_SLIM__*/		
        gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
		#endif/*__MMI_UI_MENU_SLIM__*/
        gdi_draw_line_style(
            x1,
            y2,
            x2,
            y2,
            gdi_act_color_from_rgb(255, underline_color.r, underline_color.g, underline_color.b),
            sizeof(dotted_line_bitvalues),
            dotted_line_bitvalues);
        gui_pop_clip();
    }
#endif/**/


    // for slim, support display hint in icontext list menuitem
#if  defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
    if (show_hint_in_menuitem 
		#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
		&& (!(flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
		#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
		)
    {
        curr_hint_string = m->parent_list->gui_get_current_pop_up_description_string();
        // display the hint in the second line
        clip_x1 = x1 + GUI_TWO_LINE_TEXT_ICON_GAP;
        clip_x2 = x2 - GUI_TWO_LINE_TEXT_ICON_GAP;

        text_width = clip_x2 - clip_x1 + 1;

        // use first text's color and font
        gui_set_font(m->text_fonts[0]);
        
        if (disabled_flag)
        {
            text_color = m->disabled_text_colors[0];
        }
        else if (focussed_flag)
        {
            text_color = m->focussed_text_colors[0];
        }
        else if (selected_flag)
        {
            text_color = m->selected_text_colors[0];
        }
        else
        {
            text_color = m->normal_text_colors[0];
        }
        gui_set_text_color(text_color);
        gui_measure_string(curr_hint_string, &sw, &sh);

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
        clip_y1 = y1 + i_height + ((m->height - sh)>>1);
    else
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/
        clip_y1 = y1 + m->height + ((m->height - sh)>>1);

        clip_y2 = y2;

        if (mmi_fe_get_r2l_state())
        {
            gui_move_text_cursor(clip_x2, clip_y1);
        }
        else
        {
            gui_move_text_cursor(clip_x1, clip_y1);
        }

        gdi_layer_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
        {
            gui_set_line_height(sh);
            if (mmi_fe_get_r2l_state())
            {
                gui_print_truncated_text(clip_x2, clip_y1, text_width, curr_hint_string);
            }
            else
            {
                gui_print_truncated_text(clip_x1, clip_y1, text_width, curr_hint_string);
            }
        }
        else
        {
            if ((flags & UI_MENUITEM_MARQUEE_SCROLL) &&(sw > text_width))
            {
                gui_create_scrolling_text(
                    &gui_two_line_scroll_text,
                    clip_x1,
                    clip_y1,
                    text_width,
                    clip_y2 - clip_y1 + 1,
                    (UI_string_type)curr_hint_string,
                    line_scrolling_text_timer_handler,
                    scrolling_text_draw_icontext_list_single_line_background,
                    text_color,
                    text_color);
                #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
				#endif
                gui_show_scrolling_text(&gui_two_line_scroll_text);
                
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
                if (gui_get_current_list_effect() && !gblock_list_effect)
                {
                    gui_register_callback_menuitem_scroll(gui_fixed_icontext_list_menuitem_scroll_handler);
                }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
             }
             else
             {
                 gui_print_text(curr_hint_string);
             }
        }
        gdi_layer_pop_clip();
    }
#endif  // __MMI_BASIC_UI_STYLE__


//draw grid line
    clip_x1 = x1;
    clip_x2 = x2;
    clip_y1 = y1;
    clip_y2 = y2;

//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
    } 
#endif/*__MMI_UI_MENU_SLIM__*/

    if (y2 >= menu_y2)
    {
        clip_y2 = menu_y2;
    }
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    #ifdef __128X128_WEARABLE_DEVICE_UI__
    {
        wgui_fixed_list_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    }  
    #else
    {
        gui_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);           
    }
    #endif    
#else/*__MMI_UI_MENU_SLIM__*/
	gui_set_clip_preset(clip_x1, clip_y1, clip_x2, clip_y2);
#endif/*__MMI_UI_MENU_SLIM__*/

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
	#ifdef __MMI_EMAIL__
    if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_SEPARATORLINE)
    {
        gui_draw_horizontal_line(x1 + GUI_MENUITEM_TEXT_RIGHT_GAP, x2 - GUI_MENUITEM_TEXT_RIGHT_GAP, y1, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    }
    else
	#endif/*__MMI_EMAIL__*/	
		if (ret_flag_ext & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE || mi->ext_flags & UI_MENUITEM_EXT_SHOW_DOWN_SEPARATORLINE)
    {
    #ifdef __MMI_MAINLCD_96X64__
        gui_draw_horizontal_line(x1, x2, y2, *(current_MMI_theme->list_grid_line_color));//list_separator_color
    #else /* __MMI_MAINLCD_96X64__ */
       // alpha_layer = dm_get_scr_bg_layer();
       gui_draw_list_menuitem_separator_line(
		 gui_get_list_menu_alpha_layer(), //alpha_layer
		 x1, 
		 y2, 
		 x2, 
		 y2);
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
    #endif /* __MMI_MAINLCD_96X64__ */
    }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
		
#if 0//defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  // defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)


    if (m->post_display_function)
    {
        gui_swla_log_start("PST");
        m->post_display_function(item, common_item_data, x, y);
        gui_swla_log_stop("PST");
    }

    gui_pop_text_clip();
    gui_pop_clip();


//show popup hint
#if  !defined(__MMI_BASIC_UI_STYLE__) || !defined(__MMI_UI_HINTS_IN_MENUITEM__)
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    if (m->parent_list && m->parent_list->gui_display_pop_up_description &&
        (flags & UI_MENUITEM_STATE_FOCUSSED) && !(m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE))
    {
#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
        if (flags_ext & UI_MENUITEM_EXT_INEQUAL_HEIGHT)
            m->parent_list->gui_display_pop_up_description(x, y, m->width, i_height);
        else
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/
            m->parent_list->gui_display_pop_up_description(x, y, m->width, m->height);
    }
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 
#endif/*!defined(__MMI_BASIC_UI_STYLE__) || !defined(__MMI_UI_HINTS_IN_MENUITEM__)*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_two_line_icontext_list_menuitem
 * DESCRIPTION
 *  Show an two line style icontext list menu item.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_show_two_line_icontext_list_menuitem(void *item, void *common_item_data, UI_filled_area **f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;
    fixed_icontext_list_menuitem_type *mi = (fixed_icontext_list_menuitem_type*) item;
    U32 flags;
    fixed_icontext_list_menuitem cm; /* common menuitem */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
    flags = mi->flags;
    flags |= m->flags;
    if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS))
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/	
    {
        /* verify two line menuitem highlight image dimension */
        cm = *m;
        //cm.height *= 2;
        
        cm.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
#if 0
#ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
#else
/* under construction !*/
#endif
#endif//0
		gui_menu_replace_menuitem_transparent_filler_by_theme(&cm);
#if 0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
        *f = cm.focussed_filler;//m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &cm);
    }           
 //   return;
}


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Measure an icontext list menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_icontext_list_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_icontext_list_menuitem *t = (fixed_icontext_list_menuitem*) common_item_data;
//#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
 //   S32 index = 0;
//#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *width = t->width;
    *height = t->height;

#if defined(__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__)
    if (t->ext_flags & UI_MENUITEM_EXT_INEQUAL_HEIGHT
        && MMI_fixed_list_menu.item_get_height_function)
    {
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif//0
        *height = MMI_fixed_list_menu.item_get_height_function(wgui_get_current_menuitem_index(&MMI_fixed_list_menu));
    }
#endif/*__MMI_UI_LIST_SUPPORT_UNEQUAL_HEIGHT_ITEM__*/

    if (MMI_fixed_list_menu.current_displayed_item == -1 && t->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT)
    {
#if defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)
        if (gui_menuitem_has_hint((gui_common_menuitem_base_struct*) t, 1))
#endif/*defined(__MMI_BASIC_UI_STYLE__) && defined(__MMI_UI_HINTS_IN_MENUITEM__)*/
       // {
            *height += t->height;
        //}
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Highlight an icontext list menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object 
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_icontext_list_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  //  fixed_icontext_list_menuitem_type *t = (fixed_icontext_list_menuitem_type*) item;
  //  fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GUI_current_fixed_icontext_list_menuitem_common_data = (fixed_icontext_list_menuitem*) common_item_data;
    GUI_current_fixed_icontext_list_menuitem_data = (fixed_icontext_list_menuitem_type*) item;
    if (GUI_current_fixed_icontext_list_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL)
    {
        gui_fixed_icontext_list_menuitem_stop_scroll();        
        GUI_current_fixed_icontext_list_menuitem_scroll = 0;
        GUI_current_fixed_icontext_list_menuitem_common_data->scroll_x = 0;
    }
    else if (!(GUI_current_fixed_icontext_list_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_KEEP_SCROLLING))
    {        
        gui_fixed_icontext_list_menuitem_stop_scroll();
        gui_fixed_icontext_list_menuitem_start_scroll();
    }
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
    if (!(GUI_current_fixed_icontext_list_menuitem_data->flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
   // {
        GUI_current_fixed_icontext_list_menuitem_data->flags |= UI_MENUITEM_STATE_FOCUSSED;
    //}
  
}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_icontext_list_menuitem
 * DESCRIPTION
 *  Remove the highlight of an icontext list menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private icontext list menu item object
 *  common_item_data        [IN]        common icontext list menu item object   
 * RETURNS
 *  void
 *****************************************************************************/
void gui_remove_highlight_fixed_icontext_list_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    fixed_icontext_list_menuitem_type *t = (fixed_icontext_list_menuitem_type*) item;
    fixed_icontext_list_menuitem *m = (fixed_icontext_list_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_icontext_list_menuitem_stop_scroll();
	
    t->flags &= ~UI_MENUITEM_STATE_FOCUSSED;
    for (i = 0; i < m->n_icon_columns; i++)
    {
        if (t->item_icon_handles[i] != GDI_ERROR_HANDLE)
        {
            gdi_image_stop_animation(t->item_icon_handles[i]);
            t->item_icon_handles[i] = GDI_ERROR_HANDLE;
        }
    }

#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    gui_reset_pop_up_description_transition_ex(&wgui_pop_up_description);
#endif /*__MMI_UI_HINT_TOGGLE_TRANSITION__*/
}


/*****************************************************************************
 *
 * TWOSTATE MENUITEM                                                             
 *                                                                           
 *
 *
 *****************************************************************************/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

/*****************************************************************************
 * FUNCTION
 *  gui_create_fixed_twostate_menuitem
 * DESCRIPTION
 *  Create a common two-state menu item.
 * PARAMETERS
 *  m               [IN]        common two-state menu item object
 *  width           [IN]        width
 *  height          [IN]        height
 *  ON_icon         [IN]        ON icon
 *  OFF_icon        [IN]        OFF icon
 * RETURNS
 *  void
 *****************************************************************************/
void gui_create_fixed_twostate_menuitem(fixed_twostate_menuitem *m, S32 width, S32 height, PU8 ON_icon, PU8 OFF_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	memset(m, 0, sizeof(fixed_twostate_menuitem));
	
    m->width = width;
    m->height = height;

	gui_set_fixed_twostate_menuitem_current_theme(m);

	m->OFF_icon = OFF_icon;
    m->ON_icon = ON_icon;
    
    /* calculate the icon position*/
	gui_adjust_menuitem_center_align_icon_position(m, m->OFF_icon);
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
	
    m->scroll_width = width;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_set_icons
 * DESCRIPTION
 *  Set the ON/OFF icons of a common two-state menu item.
 * PARAMETERS
 *  m               [IN]        common two-state menu item object
 *  ON_icon         [IN]        ON icon
 *  OFF_icon        [IN]        OFF icon
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_set_icons(fixed_twostate_menuitem *m, PU8 ON_icon, PU8 OFF_icon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->OFF_icon = OFF_icon;
    m->ON_icon = ON_icon;
    
    /* calculate the icon position */
	gui_adjust_menuitem_center_align_icon_position(m, m->OFF_icon);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//	
	gui_list_menuitem_adjust_scroll_width(m);

	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
/* Text scrolling related functions within the menu item */

fixed_twostate_menuitem *GUI_current_fixed_twostate_menuitem_common_data = NULL;
fixed_twostate_menuitem_type *GUI_current_fixed_twostate_menuitem_data = NULL;
MMI_BOOL GUI_current_fixed_twostate_menuitem_scroll = MMI_FALSE;
S32 GUI_current_fixed_twostate_menuitem_x;
S32 GUI_current_fixed_twostate_menuitem_y;
//	S32 GUI_current_fixed_twostate_menuitem_scroll_counter = 0;


/*****************************************************************************
 * FUNCTION
 *  scrolling_text_draw_twostate_single_line_background
 * DESCRIPTION
 *  Draw background for the scrolling twostate single line menu item.
 * PARAMETERS
 *  x1          [IN]        x1
 *  y1          [IN]        y1
 *  x2          [IN]        x2
 *  y2          [IN]        y2
 * RETURNS
 *  void
 *****************************************************************************/
static void scrolling_text_draw_twostate_single_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    scrolling_text_draw_background_filler(
        GUI_current_fixed_twostate_menuitem_x,
        GUI_current_fixed_twostate_menuitem_y,
        GUI_current_fixed_twostate_menuitem_x + MMI_fixed_twostate_menuitem.width - 1,
        GUI_current_fixed_twostate_menuitem_y + MMI_fixed_twostate_menuitem.height - 1,
        &fixed_single_line_menuitem_filled_area,
        MMI_FALSE);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_scroll_handler
 * DESCRIPTION
 *  Scroll handler of the highlighted two-state menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_scroll_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //U32 flags = GUI_current_fixed_twostate_menuitem_common_data->flags;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#if 0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    

#ifndef __MMI_UI_MENU_SLIM__
    gui_list_in_scroll = MMI_TRUE;
#endif/*__MMI_UI_MENU_SLIM__*/

   // flags |= GUI_current_fixed_twostate_menuitem_data->flags;
    gui_handle_scrolling_text(&gui_current_scroll_text[0]);
        /* 
         * WAP might display two-state fixed list as list box outside of content region.
         * We should disable scrolling text when it locates outside the content region, 
         * otherwise it will overlap with the title bar or softkey.
         */
        if (GUI_current_fixed_twostate_menuitem_y >= MMI_content_y &&
            (GUI_current_fixed_twostate_menuitem_y + GUI_current_fixed_twostate_menuitem_common_data->height - 1)
            < (MMI_content_y + MMI_content_height))
        {
            GUI_current_fixed_twostate_menuitem_common_data->ext_flags |= UI_MENUITEM_EXT_SHOW_IN_MARQUEE;

			gui_menu_disable_transparent_effect_when_multilayer(GUI_current_fixed_twostate_menuitem_common_data);
        #if 0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
            
        #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
            ////////////////// MOVE FROM FUNCTION BEGINNING ///
            gui_reset_current_list_effect(); 
            gui_restore_current_list_effect();
        #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */

        #ifdef __MMI_UI_TRANSPARENT_EFFECT__
            gui_fixed_twostate_menuitem_enable_transparent_effect(GUI_current_fixed_twostate_menuitem_common_data);     /* To enable transparency */
        #endif/*__MMI_UI_TRANSPARENT_EFFECT__*/ 

            GUI_current_fixed_twostate_menuitem_common_data->ext_flags &= ~UI_MENUITEM_EXT_SHOW_IN_MARQUEE;
    }
#ifndef __MMI_UI_MENU_SLIM__		
    gui_list_in_scroll = MMI_FALSE;
#endif/*__MMI_UI_MENU_SLIM__*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_start_scroll
 * DESCRIPTION
 *  Start scrolling for the highlighted two-state menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_start_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem_type *t = (fixed_twostate_menuitem_type*) GUI_current_fixed_twostate_menuitem_data;
    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) GUI_current_fixed_twostate_menuitem_common_data;
    U32 flags;
#if 0
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD__
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
#endif//0

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    t->flags |= UI_MENUITEM_STATE_FOCUSSED;
    flags = m->flags;
    flags |= t->flags;

	gui_execute_list_menu_item_resize_function();
#if 0	
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#endif//
    gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);

    m->text_width = gui_get_string_width(t->item_text);
    m->scroll_x = 0;

    if (m->text_width > m->scroll_width)
    {
        GUI_current_fixed_twostate_menuitem_scroll = MMI_TRUE;
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        if (gui_get_current_list_effect() && !gblock_list_effect)
        {
            gui_register_callback_menuitem_scroll(gui_fixed_twostate_menuitem_scroll_handler);
        }
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
        gui_create_scrolling_text(
            &gui_current_scroll_text[0],
            0,
            0,
            0,
            0,
            (UI_string_type)t->item_text,
            gui_fixed_twostate_menuitem_scroll_handler,
            scrolling_text_draw_twostate_single_line_background,
            MMI_fixed_twostate_menuitem.focussed_text_color,
            MMI_fixed_twostate_menuitem.focussed_text_color);
        //if (flags & UI_MENUITEM_TWO_DIRECTION_SCROLL)
        //{
        //    gui_current_scroll_text[0].flags = UI_SCROLLING_TEXT_TWO_DIRECTION_SCROLL;
        //}
        gui_scrolling_text_start(&gui_current_scroll_text[0]);
    }
    else
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    {
        gui_register_callback_menuitem_scroll(UI_dummy_function);
        GUI_current_fixed_twostate_menuitem_scroll = MMI_FALSE;
    }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    {
        GUI_current_fixed_twostate_menuitem_scroll = MMI_FALSE;
    }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_stop_scroll
 * DESCRIPTION
 *  Stop scrolling for the highlighted two-state menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_fixed_twostate_menuitem_stop_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    gui_cancel_timer(gui_fixed_twostate_menuitem_start_scroll);
    if (GUI_current_fixed_twostate_menuitem_scroll)
    {
        gui_cancel_timer(gui_fixed_twostate_menuitem_scroll_handler);
        GUI_current_fixed_twostate_menuitem_scroll = MMI_FALSE;
    }
	
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_register_callback_menuitem_scroll(UI_dummy_function);
    gui_restore_current_list_effect();
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_twostate_menuitem_flag
 * DESCRIPTION
 *  get the flag of two-state menu item.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object
 * RETURNS
 *  flag
 *****************************************************************************/
void gui_get_fixed_twostate_menuitem_flag(void *item, void *common_item_data, S32 index, U32* flags, U32* flags_ext)
{
  gui_get_fixed_menuitem_flag(item, common_item_data, index, flags,flags_ext, 1); 
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_fixed_twostate_menuitem
 * DESCRIPTION
 *  Show a two-state menu item.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_fixed_twostate_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    S32 text_x, text_y;
    color text_color;
    UI_filled_area *f = NULL;
    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) common_item_data;
    fixed_twostate_menuitem_type *mi = (fixed_twostate_menuitem_type*) item;
    U32 flags, flags_ext;
//    U32 ret_flag = 0, ret_flag_ext = 0;
 //   UI_string_type _text;

    /* byte animation_flag=0; */
    S32 sw, sh;
    S32 icon_width, icon_height;
#ifdef __MMI_WEARABLE_DEVICE__
	MMI_BOOL show_highlight = MMI_FALSE;
#endif /*__MMI_WEARABLE_DEVICE__*/
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    PU8 temp_on_icon = m->ON_icon;
    PU8 temp_off_icon = m->OFF_icon;
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

    S32 text_width;
    gdi_handle old_alpha_layer=GDI_NULL_HANDLE;
#if 0
#ifdef __MMI_UI_LIST_HIGHLIGHT_BOLD__
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/
#endif//0
    PU8 temp_icon = NULL;
    S32 scrolling_text_x;
	
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    S32 clip_y1;
    gdi_handle act_layer = GDI_NULL_HANDLE;
#endif/*__MMI_UI_MENU_SLIM__*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   // _text = mi->item_text;
  //  g_gui_menuitem_need_scroll = MMI_FALSE;

//get flags
	gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
	if (flags & UI_MENUITEM_STATE_FOCUSSED)
	{
	    GUI_current_fixed_twostate_menuitem_x = x;
	    GUI_current_fixed_twostate_menuitem_y = y;
	}


//get 
    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + m->height - 1;

//get menu region h
	gui_get_menu_top_and_bottom_position(m, &menu_y1, &menu_y2);

    if (g_current_display_half_menuitem)
    {
        menu_y2 -= 1;
    }


	/* calculate the text position based on font */
	gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
//huking	
	gui_measure_string(mi->item_text, &sw, &sh);
	if (flags & UI_MENUITEM_CENTER_TEXT_X)
	{
		m->text_x = (m->width >> 1) - (sw >> 1);
	}
	if (flags & UI_MENUITEM_CENTER_TEXT_Y)
	{
		m->text_y = (m->height >> 1) - (sh >> 1);
	}

    if (mmi_fe_get_r2l_state())
    {
        text_x = x2 - m->text_x;
    }
    else
    {
        text_x = m->text_x;
    }

    text_y = m->text_y;



#if  0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */    



//get filler and text color
    if ((flags & UI_MENUITEM_STATE_FOCUSSED)
		#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
		&& !(flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
		#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/
		#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__) //add by xl
		 && (MMI_TRUE == pen_down_in_list)
		#endif /*__MMI_WEARABLE_DEVICE__*/
		)
    {
    	#if defined(__MMI_WEARABLE_DEVICE__) && defined(__MMI_TOUCH_SCREEN__) //add by xl
		if (MMI_FALSE == g_gui_ssp_launch)
		{
			pen_down_in_list = MMI_FALSE;
		}
		#endif /*__MMI_WEARABLE_DEVICE__*/
		#ifdef __MMI_WEARABLE_DEVICE__
		show_highlight = MMI_TRUE;
		#endif /*__MMI_WEARABLE_DEVICE__*/
        f = m->focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) m);
        fixed_single_line_menuitem_filled_area = *f;
        text_color = m->focussed_text_color;
    }
    else if (flags & UI_MENUITEM_STATE_DISABLED)
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
		
       //{
            f = m->disabled_filler;
       // }
        text_color = m->focussed_text_color;
    }
    else if (flags & UI_MENUITEM_STATE_SELECTED)
    {

        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
	
        //{
            f = m->selected_filler;
        //}
#ifdef __MMI_SCREEN_ROTATE__
        if (mmi_frm_is_screen_width_height_swapped() && !current_MMI_theme->rotated_bkg_filler)
        {
            text_color = UI_COLOR_BLACK;
        }
        else
#endif  // __MMI_SCREEN_ROTATE__
       // {
            text_color = m->normal_text_color;
        //}
    }
    else
    {
        if (!(flags & UI_MENUITEM_DISABLE_BACKGROUND))
		
       // {
            f = m->normal_filler;
       // }
        
#ifdef __MMI_SCREEN_ROTATE__
        if (mmi_frm_is_screen_width_height_swapped() && !current_MMI_theme->rotated_bkg_filler)
        {
            text_color = UI_COLOR_BLACK;
        }
        else
#endif  // __MMI_SCREEN_ROTATE__
       // {
            text_color = m->normal_text_color;
       // }
    }
	//unimportant issues
	#ifndef __MMI_UI_MENU_SLIM__
    if (flags_ext & UI_MENUITEM_EXT_SHOW_DISABLED)
    {
        text_color = m->disabled_text_color;
    }
	#endif/*__MMI_UI_MENU_SLIM__*/



//draw the menuitem filler	
    gui_push_clip();
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
    clip_y1 = y1;

    gdi_layer_get_active(&act_layer);
    if (MMI_current_menu_type == LIST_MENU && clip_y1 < m->parent_list->y && m->parent_list->act_layer_handle == act_layer)
    {
        clip_y1 = m->parent_list->y;
        if (m->parent_list->normal_filler && m->parent_list->normal_filler->flags & UI_FILLED_AREA_SINGLE_BORDER)
        {
            clip_y1 += 1;
        }
    }
#endif/*__MMI_UI_MENU_SLIM__*/
    if (y1 >= menu_y2)
    {
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(x1, menu_y2, x2 + 2, menu_y2);
        }  
        #else
        {
            gui_set_clip(x1, menu_y2, x2 + 2, menu_y2);            
        }
        #endif    
#else/*__MMI_UI_MENU_SLIM__*/
	    gui_set_clip_preset(x1, menu_y2, x2 + 2, menu_y2);
#endif/*__MMI_UI_MENU_SLIM__*/
    }
    else if (y2 >= menu_y2)
    {
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(x1, clip_y1, x2 + 2, menu_y2);
        }  
        #else
        {
            gui_set_clip(x1, clip_y1, x2 + 2, menu_y2);            
        }
        #endif    
#else/*__MMI_UI_MENU_SLIM__*/     
        gui_set_clip_preset(x1, y1, x2 + 2, menu_y2);
#endif/*__MMI_UI_MENU_SLIM__*/
    }
    else
    {
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        #ifdef __128X128_WEARABLE_DEVICE_UI__
        {
            wgui_fixed_list_set_clip(x1, clip_y1, x2 + 2, y2 + 2);
        }  
        #else
        {
            gui_set_clip(x1, clip_y1, x2 + 2, y2 + 2);            
        }
        #endif    
#else /*__MMI_UI_MENU_SLIM__*/     
        gui_set_clip_preset(x1, y1, x2 + 2, y2 + 2);
#endif/*__MMI_UI_MENU_SLIM__*/
    }

    if (f != NULL
#ifndef __MMI_UI_MENU_SLIM__		
		&& !g_slide_effect->in_flatten
#endif/*__MMI_UI_MENU_SLIM__*/		
		)
    {
 	#ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
 	#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        if (is_draw_next_frame_list_highlight_effect_value())
    #endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/
        {
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_TWOSTATE_ITEM);
        }
    #endif/*__MMI_SUPPORT_DUMP_SCREEN_STRING__*/
        old_alpha_layer = gui_list_set_alpha_blending_layer();
        set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);

#if 0// __OP01_FWPBW__
/* under construction !*/
#else   // __OP01_FWPBW__
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_draw_list_filled_area(x1, y1, x2, y2, f);
    #else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
	  #ifdef __MMI_MAINLCD_96X64__
        gui_menuitem_draw_list_filler(x1 + m->text_x, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
	  #else/*__MMI_MAINLCD_96X64__*/
        gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
	  #endif/*__MMI_MAINLCD_96X64__*/
    #endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
#endif//  __OP01_FWPBW__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }
#ifndef __MMI_WEARABLE_DEVICE__
    old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#else
	if (show_highlight == MMI_TRUE)
		old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#endif /*__MMI_WEARABLE_DEVICE__*/


//get the two state radio icon
    if (flags & UI_MENUITEM_STATE_SELECTED)
    {
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /* To hide the ON icon of the menuitem up to the last frame for flash feel effect */
       // if (temp_on_icon != UI_NULL_IMAGE)
       // {
            temp_icon = temp_on_icon;
       // }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
       // if (m->ON_icon != UI_NULL_IMAGE)
       // {
            temp_icon = m->ON_icon;
       // }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    }
    else
    {
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        /* To hide the ON icon of the menuitem up to the last frame for flash feel effect */
      //  if (temp_off_icon != UI_NULL_IMAGE)
      //  {
            temp_icon = temp_off_icon;
       // }
#else /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
      //  if (m->OFF_icon != UI_NULL_IMAGE)
      //  {
            temp_icon = m->OFF_icon;
      //  }
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 
    }

//draw the radio icon
    if (temp_icon)
    {
    
        gui_measure_image(temp_icon, &icon_width, &icon_height);
		gui_adjust_menuitem_center_align_icon_position(m, temp_icon);
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif//0	
        if (mmi_fe_get_r2l_state())
        {
            /* R2L icons are right-aligned. */    
            gui_show_image(
                x2 - m->icon_x - icon_width + 1,
                y1 + m->icon_y,
                temp_icon);   
        }
        else
        {
        	gui_show_image(
				x1 + m->icon_x,
				y1 + m->icon_y, 
				temp_icon);

        }
    }

	
    gui_pop_clip();
#ifndef __MMI_WEARABLE_DEVICE__
    gui_list_reset_alpha_blending_layer(old_alpha_layer);
#else
	if (show_highlight == MMI_TRUE)
    gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif /*__MMI_WEARABLE_DEVICE__*/

   // gui_push_clip();
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__   
    if (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY))
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
    {
#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        old_alpha_layer = gui_list_set_alpha_blending_layer_ex(flags, MMI_TRUE);
#endif/*__MMI_VECTOR_FONT_SUPPORT__*/
        gui_push_text_clip();
//unimportant issues
#ifndef __MMI_UI_MENU_SLIM__
        if (m->icon_x > m->text_x)
        {
            if (y1 >= menu_y2)
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(x1, menu_y2, x2 - (m->width - m->icon_x), menu_y2);
                }  
                #else
                {
                    gui_set_clip(x1, menu_y2, x2 - (m->width - m->icon_x), menu_y2);            
                }
                #endif    
            }
            else if (y2 >= menu_y2)
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(x1, clip_y1, x2 - (m->width - m->icon_x), menu_y2);
                }  
                #else
                {
                    gui_set_clip(x1, clip_y1, x2 - (m->width - m->icon_x), menu_y2);            
                }
                #endif    
            }
            else
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(x1, clip_y1, x2 - (m->width - m->icon_x), y2);
                }  
                #else
                {
                    gui_set_clip(x1, clip_y1, x2 - (m->width - m->icon_x), y2);            
                }
                #endif    
            }
            text_width = x2 - (m->width - m->icon_x) - x1 + 1;
        }
        else
        {
            if (y1 >= menu_y2)
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_text_clip(x1 + m->text_x, menu_y2, x2, menu_y2);
                }  
                #else
                {
                    gui_set_text_clip(x1 + m->text_x, menu_y2, x2, menu_y2);            
                }
                #endif    
            }
            else if (y2 >= menu_y2)
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_text_clip(x1 + m->text_x, clip_y1, x2, menu_y2);
                }  
                #else
                {
                    gui_set_text_clip(x1 + m->text_x, clip_y1, x2, menu_y2);            
                }
                #endif    
            }
            else
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_text_clip(x1 + m->text_x, clip_y1, x2, y2);
                }  
                #else
                {
                    gui_set_text_clip(x1 + m->text_x, clip_y1, x2, y2);            
                }
                #endif    
            }
            text_width = x2 - (x1 + m->text_x) + 1;
        }

      //  if (r2lMMIFlag)
		if(mmi_fe_get_r2l_state())
        {
            if (y1 >= menu_y2)
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(x1, menu_y2, x2 - m->text_x, menu_y2);
                }  
                #else
                {
                    gui_set_clip(x1, menu_y2, x2 - m->text_x, menu_y2);            
                }
                #endif    
            }
            else if (y2 >= menu_y2)
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(x1, clip_y1, x2 - m->text_x, menu_y2);
                }  
                #else
                {
                    gui_set_clip(x1, clip_y1, x2 - m->text_x, menu_y2);            
                }
                #endif    
            }
            else
            {
                #ifdef __128X128_WEARABLE_DEVICE_UI__
                {
                    wgui_fixed_list_set_clip(x1, clip_y1, x2 - m->text_x, y2);
                }  
                #else
                {
                    gui_set_clip(x1, clip_y1, x2 - m->text_x, y2);            
                }
                #endif    
            }
        }
#else/*__MMI_UI_MENU_SLIM__*/


   	
	//if (mmi_fe_get_r2l_state())//(m->icon_x > m->text_x)
	if (m->icon_x > m->text_x)
	{
		if (y1 >= menu_y2)
		{
			gui_set_clip_preset(x1, menu_y2, x2 - (m->width - m->icon_x), menu_y2);
		}
		else if (y2 >= menu_y2)
		{
			gui_set_clip_preset(x1, y1, x2 - (m->width - m->icon_x), menu_y2);
		}
		else
		{
			gui_set_clip_preset(x1, y1, x2 - (m->width - m->icon_x), y2);
		}
		text_width = x2 - (m->width - m->icon_x) - x1 + 1;
	}
	else
	{
		if (y1 >= menu_y2)
		{
			gui_set_text_clip_preset(x1 + m->text_x, menu_y2, x2, menu_y2);
		}
		else if (y2 >= menu_y2)
		{
			gui_set_text_clip_preset(x1 + m->text_x, y1, x2, menu_y2);
		}
		else
		{
			gui_set_text_clip_preset(x1 + m->text_x, y1, x2, y2);
		}
		text_width = x2 - (x1 + m->text_x) + 1;
	}


      //  if (r2lMMIFlag)
	if(mmi_fe_get_r2l_state())
	{
		if (y1 >= menu_y2)
		{
			gui_set_clip_preset(x1, menu_y2, x2 - m->text_x, menu_y2);
		}
		else if (y2 >= menu_y2)
		{
			gui_set_clip_preset(x1, y1, x2 - m->text_x, menu_y2);
		}
		else
		{
			gui_set_clip_preset(x1, y1, x2 - m->text_x, y2);
		}
	}
#endif/*__MMI_UI_MENU_SLIM__*/
        gui_menuitem_adjust_text_clip_for_right_gap(m);

#ifdef __MMI_FTE_SUPPORT__    
        if (MMI_current_menu_type == LIST_MENU)
        {
            text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
#else/*__MMI_FTE_SUPPORT__*/
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
        if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
        {
            text_width -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/
#endif/*__MMI_FTE_SUPPORT__*/
        if (mmi_fe_get_r2l_state())
        {
            gui_move_text_cursor(text_x, y1 + text_y);
        }
        else
        {
            gui_move_text_cursor(x1 + text_x, y1 + text_y);
        }

#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
        if (f && (f->flags & UI_FILLED_AREA_BORDER))
        {
            text_width -= 1;
        }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/

        gui_set_text_color(text_color); /* set text clor */
        gui_set_line_height(sh);


		g_gui_menuitem_need_scroll = ((sw > text_width) && 
			!(flags & UI_MENUITEM_TRUNCATE_CONTENT) && 
			(flags & UI_MENUITEM_MARQUEE_SCROLL));
#if 0		
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//        
#if 1//def __MMI_UI_LIST_TRUNCATE_ITEM__
        if ((mi->flags & UI_MENUITEM_STATE_FOCUSSED) && (GUI_current_fixed_twostate_menuitem_scroll || g_gui_menuitem_need_scroll) &&
            ((y1 + text_y >= menu_y1 && y1 + text_y + sh <= menu_y2) || !g_current_display_half_menuitem))
        {
			if (mmi_fe_get_r2l_state())
            {
                scrolling_text_x = x1 + text_x - text_width + 2;
            }
            else
            {
                scrolling_text_x = x1 + text_x;
            }
            
            gui_menuitem_redraw_scrolling_text(
                &(gui_current_scroll_text[0]),
                scrolling_text_x,
                y1 + text_y,
                text_width,
                sh + 1,
                NULL);
        }
        else
        {
            if (mmi_fe_get_r2l_state())
            {
                gui_print_truncated_text(text_x, y1 + text_y, text_width, mi->item_text);
            }
            else
            {
                gui_print_truncated_text(x1 + text_x, y1 + text_y, text_width, mi->item_text);
            }
            
        }  
#else/*__MMI_UI_LIST_TRUNCATE_ITEM__*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif/*__MMI_UI_LIST_TRUNCATE_ITEM__*/

        gui_pop_text_clip();

#ifdef  __MMI_VECTOR_FONT_SUPPORT__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
#endif/*__MMI_VECTOR_FONT_SUPPORT__*/
    }

   // gui_pop_clip();

//show the pop hint
#if(UI_ENABLE_POP_UP_DESCRIPTIONS)
    if (m->parent_list && m->parent_list->gui_display_pop_up_description &&
        (flags & UI_MENUITEM_STATE_FOCUSSED) && !(m->ext_flags & UI_MENUITEM_EXT_SHOW_IN_MARQUEE))
    {
        m->parent_list->gui_display_pop_up_description(x, y, m->width, m->height);      /* display popp description */
    }
#endif /* (UI_ENABLE_POP_UP_DESCRIPTIONS) */ 
}


#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  gui_fixed_twostate_menuitem_translate_pen_event
 * DESCRIPTION
 *  Pen event handler of the two-state menu item.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item
 *  common_item_data        [IN]        common two-state menu item
 *  item_x                  [IN]        item x1
 *  item_y                  [IN]        item y1
 *  pen_event               [IN]        pen event type
 *  x                       [IN]        pen x
 *  y                       [IN]        pen y
 *  menuitem_event          [OUT]       pen event result
 *  menuitem_param          [IN]        pen event parameter
 * RETURNS
 *  Return MMI_TRUE if the pen event is handled; otherwise, MMI_FALSE.  
 *****************************************************************************/
BOOL gui_fixed_twostate_menuitem_translate_pen_event(
        void *item,
        void *common_item_data,
        S32 item_x,
        S32 item_y,
        mmi_pen_event_type_enum pen_event,
        S16 x,
        S16 y,
        gui_list_pen_enum *menuitem_event,
        gui_pen_event_param_struct *menuitem_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_FTE_SUPPORT__
    
    BOOL ret = MMI_TRUE, pen_inside = MMI_FALSE;
    S32 iwidth, iheight;

    fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) common_item_data;
#endif  /*__MMI_FTE_SUPPORT__ */    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
#if defined(__MMI_FTE_SUPPORT__) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)

    return MMI_FALSE;
#else/*defined(__MMI_FTE_SUPPORT__) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)*/

    *menuitem_event = GUI_LIST_PEN_NONE;
    GUI_PEN_EVENT_PARAM_SET_VOID(menuitem_param);
//huking
//    if (m->OFF_icon != UI_NULL_IMAGE)
//    {
        gui_measure_image(m->OFF_icon, &iwidth, &iheight);
//    }
//    else
//    {
//        iwidth = iheight = 0;
//    }

    item_x += m->icon_x;
    item_y += m->icon_y;
    if (mmi_fe_get_r2l_state())
    {
        if (PEN_CHECK_BOUND(x, y, MMI_fixed_list_menu.width - m->icon_x- iwidth, item_y, iwidth, iheight))
        {
            pen_inside = MMI_TRUE;
        }
    }
    else
    {
        if (PEN_CHECK_BOUND(x, y, item_x, item_y, iwidth, iheight))
        {
            pen_inside = MMI_TRUE;
        }
    }

    if (pen_event == MMI_PEN_EVENT_DOWN)
    {
        if (!pen_inside)
        {
            /* The following pen events will not be directed to twostate menuitem */
            ret = MMI_FALSE;
        }
        else
        {
            *menuitem_event = GUI_LIST_PEN_DOWN_ON_STATE_BOX;
        }
    }
    else if (pen_event == MMI_PEN_EVENT_UP)
    {
        if (MMI_fixed_list_menu.pen_state.pen_down_state_box)
        {
            // for ssp pen up, doesn't handle the click cb function
            /* Outside of the image, it is not controlled by menuitem */
            if (pen_inside)
            {
                *menuitem_event = GUI_TWOSTATE_PEN_TOGGLE;
            }
        }
        else
        {
            *menuitem_event = GUI_TWOSTATE_PEN_TOGGLE;
        }
    }

    return ret;
#endif/*defined(__MMI_FTE_SUPPORT__) || defined(GUI_LIST_MENU_SMOOTH_SCROLLING_BY_PEN)*/
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  gui_measure_fixed_twostate_menuitem
 * DESCRIPTION
 *  Measure a two-state menu item for dimension.
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object
 *  width                   [OUT]       item width
 *  height                  [OUT]       item height
 * RETURNS
 *  void
 *****************************************************************************/
void gui_measure_fixed_twostate_menuitem(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem *t = (fixed_twostate_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(item);
    *width = t->width;
    *height = t->height;
}


/*****************************************************************************
 * FUNCTION
 *  gui_highlight_fixed_twostate_menuitem
 * DESCRIPTION
 *  Highlight a two-state menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object    
 * RETURNS
 *  void
 *****************************************************************************/
void gui_highlight_fixed_twostate_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 //   fixed_twostate_menuitem_type *t = (fixed_twostate_menuitem_type*) item;
 //   fixed_twostate_menuitem *m = (fixed_twostate_menuitem*) common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GUI_current_fixed_twostate_menuitem_common_data = (fixed_twostate_menuitem*) common_item_data;
    GUI_current_fixed_twostate_menuitem_data =  (fixed_twostate_menuitem_type*) item;
    if (GUI_current_fixed_twostate_menuitem_common_data->ext_flags & UI_MENUITEM_EXT_DISABLED_SCROLL)
    {
        gui_fixed_twostate_menuitem_stop_scroll();
        GUI_current_fixed_twostate_menuitem_scroll = MMI_FALSE;
        GUI_current_fixed_twostate_menuitem_common_data->scroll_x = 0;
    }
    else
    {
        gui_fixed_twostate_menuitem_stop_scroll();
        gui_fixed_twostate_menuitem_start_scroll();
    }
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
   if(!(GUI_current_fixed_twostate_menuitem_data->flags & UI_MENUITEM_DISABLE_HIGHLIGHT))
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/   	
   	  GUI_current_fixed_twostate_menuitem_data->flags |= UI_MENUITEM_STATE_FOCUSSED;
	
   // if (t->flags & UI_MENUITEM_DISABLE_HIGHLIGHT)
   // {
   //     return;
   // }
   // t->flags |= UI_MENUITEM_STATE_FOCUSSED;
}


/*****************************************************************************
 * FUNCTION
 *  gui_remove_highlight_fixed_twostate_menuitem
 * DESCRIPTION
 *  Remove the highlight of a two-state menu item (not visually).
 * PARAMETERS
 *  item                    [IN]        private two-state menu item object
 *  common_item_data        [IN]        common two-state menu item object  
 * RETURNS
 *  void
 *****************************************************************************/
void gui_remove_highlight_fixed_twostate_menuitem(void *item, void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    fixed_twostate_menuitem_type *t = (fixed_twostate_menuitem_type*) item;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_fixed_twostate_menuitem_stop_scroll();
    UI_UNUSED_PARAMETER(common_item_data);
    t->flags &= ~UI_MENUITEM_STATE_FOCUSSED;
	
#ifdef __MMI_UI_HINT_TOGGLE_TRANSITION__
    gui_reset_pop_up_description_transition_ex(&wgui_pop_up_description);
#endif/*__MMI_UI_HINT_TOGGLE_TRANSITION__*/ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_block_list_animation_highlight
 * DESCRIPTION
 *  Block the list effect. Save and set the current effect to none.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_block_list_animation_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_animation_highlight = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_unblock_list_animation_highlight
 * DESCRIPTION
 *  Unblock the list effect. Set the current effect from the backup.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_unblock_list_animation_highlight(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_animation_highlight = MMI_FALSE;
}

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__

#define LIST_EFFECT_TYPE__(A) MMI_UI_LIST_HIGHLIGHT_EFFECT_##A
#define LIST_EFFECT_TYPE_(A)  LIST_EFFECT_TYPE__(A)
#define LIST_EFFECT_TYPE(A)      LIST_EFFECT_TYPE_(A)

static gui_list_effect_styles goriginal_list_effect = LIST_EFFECT_TYPE_(UI_LIST_EFFECT_TYPE);
static gui_list_effect_styles current_list_effect = LIST_EFFECT_TYPE_(UI_LIST_EFFECT_TYPE);
static gui_list_effect_styles backup_current_list_effect = LIST_EFFECT_TYPE_(UI_LIST_EFFECT_TYPE);

#if 0//defined(__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__)||defined(__MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__)
/* under construction !*/
#endif

extern fixed_list_menu MMI_fixed_list_menu;
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
extern gdi_handle anim_handle;
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/


/*****************************************************************************
 * FUNCTION
 *  gui_draw_list_highlight_effect_last_frame
 * DESCRIPTION
 *  Draw the last frame of list highlight effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_list_highlight_effect_last_frame(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!ghighlight_item || !ghighlight_common_item_data)
    {
       // MMI_DBG_ASSERT(0);
        return;
    }

    gui_lock_double_buffer();
    MMI_fixed_list_menu.item_display_function(ghighlight_item, ghighlight_common_item_data, gstartX1, gstartY1);
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(xstart_effect, ystart_effect, xend_effect, yend_effect);
}


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifndef __MMI_UI_MENU_SLIM__
/* under construction !*/
/* under construction !*/
		#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_ANIMATE_HIGHLIGHT_EFFECTS__ */


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifndef __MMI_UI_MENU_SLIM__
/* under construction !*/
/* under construction !*/
		#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__ */


#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
       #ifndef __MMI_UI_MENU_SLIM__
/* under construction !*/
/* under construction !*/
	   #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */


/*****************************************************************************
 * FUNCTION
 *  gui_get_current_list_effect
 * DESCRIPTION
 *  Get the current list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  List effect type.
 *****************************************************************************/
S32 gui_get_current_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return current_list_effect;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_current_list_effect
 * DESCRIPTION
 *  Set the current list effect.
 * PARAMETERS
 *  list_style      [IN]        list effect
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_current_list_effect(gui_list_effect_styles list_style)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_list_effect = list_style;
    backup_current_list_effect = current_list_effect;
}


/*****************************************************************************
 * FUNCTION
 *  gui_reset_current_list_effect
 * DESCRIPTION
 *  Reset the current list effect to none.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_reset_current_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (current_list_effect != MMI_UI_LIST_HIGHLIGHT_EFFECT_NONE)
    {
        backup_current_list_effect = current_list_effect;
    }
    current_list_effect = MMI_UI_LIST_HIGHLIGHT_EFFECT_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  gui_set_current_list_effect_to_default
 * DESCRIPTION
 *  Set the current list effect to default.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_set_current_list_effect_to_default(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    current_list_effect = goriginal_list_effect;
    backup_current_list_effect = goriginal_list_effect; /* restore as current list effect is also set to default */
}


/*****************************************************************************
 * FUNCTION
 *  gui_restore_current_list_effect
 * DESCRIPTION
 *  Restore the current list effect from the backup_current_list_effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_restore_current_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!gblock_list_effect)
    {
        current_list_effect = backup_current_list_effect;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_block_list_effect
 * DESCRIPTION
 *  Block the list effect. Save and set the current effect to none.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_block_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_effect = MMI_TRUE;
    gui_reset_current_list_effect();
}


/*****************************************************************************
 * FUNCTION
 *  gui_unblock_list_effect
 * DESCRIPTION
 *  Unblock the list effect. Set the current effect from the backup.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_unblock_list_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gblock_list_effect = MMI_FALSE;
    gui_restore_current_list_effect();
}


/*****************************************************************************
 * FUNCTION
 *  gui_draw_list_filled_area
 * DESCRIPTION
 *  Draw the list effect filler.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_draw_list_filled_area(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // S32 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (gblock_list_effect)
    {
        gui_reset_current_list_effect();    /* This is to block the effects in case of inline edit screens. */
    }
    switch (current_list_effect)
    {
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_NONE:
		{
            /* Disable transparent effect if we do not have screen background layer. */
            gui_menuitem_draw_list_filler(
                x1, y1, x2, y2, f, 
                (gblock_list_effect || gblock_list_animation_highlight), 
                !gui_is_current_transparency_with_multi_layer());
            break;
		}

#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_TRANSPARENCY_HIGHLIGHT_EFFECTS__ */

#if  0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__ */            

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  /* __MMI_UI_LIST_ANIMATE_HIGHLIGHT_EFFECTS__ */            
            
        case MMI_UI_LIST_HIGHLIGHT_EFFECT_SLIDE:
            gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, (gblock_list_effect || gblock_list_animation_highlight), MMI_FALSE);
#ifndef __MMI_UI_MENU_SLIM__
			/* start menu item scrolling */
			// TODO: SHOULD START SCROLLING WHEN THE SLIDING IS FINISHED

			gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
#endif/*__MMI_UI_MENU_SLIM__*/
            break;
    }
}



/*****************************************************************************
 * FUNCTION
 *  gui_stop_list_highlight_effect
 * DESCRIPTION
 *  Stop timer for the list effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_stop_list_highlight_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0//__MMI_UI_LIST_FLASH_HIGHLIGHT_EFFECTS__
/* under construction !*/
#endif
    list_highlight_effect_current_frame = 0;
    list_highlight_effect_times = 0;
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
    if (anim_handle)
    {
        gdi_anim_stop(anim_handle);
        anim_handle = GDI_NULL_HANDLE;
    }
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/
    gui_cancel_timer(gui_callback_highlighter_text_filler);
    gui_list_effect_slide_stop();
}


/*****************************************************************************
 * FUNCTION
 *  gui_register_callback_menuitem_scroll
 * DESCRIPTION
 *  Set the associated scroll handler for the list effect.
 * PARAMETERS
 *  f       [IN]        menu item scroll handler
 * RETURNS
 *  void
 *****************************************************************************/
void gui_register_callback_menuitem_scroll(void (*f)(void))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_call_menuitem_scroll = f;
}



#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

/*****************************************************************************
 * FUNCTION
 *  is_draw_next_frame_list_highlight_effect_value
 * DESCRIPTION
 *  Return the is_draw_next_frame_list_highlight_effect value.
 * PARAMETERS
 *  void
 * RETURNS
 *  0: the menu item is not drawed for the list effect. 1: yes.
 *****************************************************************************/
S32 is_draw_next_frame_list_highlight_effect_value(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return is_draw_next_frame_list_highlight_effect;
}

/*****************************************************************************
 * FUNCTION
 *  set_is_draw_next_frame_list_highlight_effect_value
 * DESCRIPTION
 *  Set the is_draw_next_frame_list_highlight_effect value.
 * PARAMETERS
 *  the menu item is not drawed for the list effect
 * RETURNS
 *  void
 *****************************************************************************/
void set_is_draw_next_frame_list_highlight_effect_value(MMI_BOOL draw_next_frame)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (draw_next_frame)
        is_draw_next_frame_list_highlight_effect = 1;
    else
        is_draw_next_frame_list_highlight_effect = 0;
}




#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */ 

#if 0//(defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__) */ 


#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_get_two_line_menuitem_height
 * DESCRIPTION
 *  Dummy function to check whether the current menuitem is two line.
 * PARAMETERS
 *  void
 * RETURNS
 *  0: single line. 1: two line. 
 *****************************************************************************/
MMI_BOOL UI_dummy_get_two_line_menuitem_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  UI_dummy_two_line_get_thumbnail_flags
 * DESCRIPTION
 *  Dummy function to return thumbnail flags.
 * PARAMETERS
 *  void
 * RETURNS
 *  Thumbnail flag.
 *****************************************************************************/
U8 UI_dummy_two_line_get_thumbnail_flags(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 0;
}


/*----------------------------------------------------------------------------
The various callbakcs for two line menu item are defined below this line.
----------------------------------------------------------------------------*/
U8(*gui_two_line_get_thumbnail_flags) (void) = UI_dummy_two_line_get_thumbnail_flags;
void (*gui_reset_two_line) (void) = UI_dummy_function;
void (*gui_two_line_toggle_thumbnail_direction) (void) = UI_dummy_function;
void (*gui_set_current_two_line_menuitem_data) (void) = UI_dummy_function;
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
void (*gui_reset_current_two_line_menuitem_data) (void) = UI_dummy_function;
#endif /*(defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)*/

#if defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__
void (*gui_show_two_line_menuitem_part) (void) = UI_dummy_function;
void (*gui_move_two_line_menuitem_part) (S32 x, S32 y) = UI_dummy_function_with_2_s32;
void (*gui_resize_two_line_menuitem_part) (S32 x, S32 y) = UI_dummy_function_with_2_s32;

MMI_BOOL(*gui_get_two_line_menuitem_height) (void) = UI_dummy_get_two_line_menuitem_height;
#endif /* defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

// TODO: modify function name
#if 0//(defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif   


#if (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__)
extern wgui_get_display_style get_current_menu_item_displaystyle;

/*****************************************************************************
 * FUNCTION
 *  gui_show_two_line_background
 * DESCRIPTION
 *  Show the two line background (highlight filler).
 * PARAMETERS
 *  x1       [IN]   x coordinate of the top-left point
 *  y1       [IN]   y coordinate of the top-left point
 *  x2       [IN]   x coordinate of the bottom-right point
 *  y2       [IN]   y coordinate of the bottom-right point
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_two_line_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //UI_filled_area *highlight_filler;
    fixed_icontext_menuitem m;
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
//    S32 count;
    S32 current_x1, current_y1, current_x2, current_y2;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_menu_disable_transparent_effect_when_multilayer(&MMI_fixed_icontext_menuitem);	
#if 0//__MMI_UI_TRANSPARENT_EFFECT__ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

    /* verify two line menuitem highlight image dimension */
	m = MMI_fixed_icontext_menuitem;
//	m.height *= 2;
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #if !defined(__MMI_OP11_MENU_12MATRIX__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif  /* !defined(__MMI_OP11_MENU_12MATRIX__) */
/* under construction !*/
#if !defined(0)   
/* under construction !*/
#endif
#endif
    {
        //if (fixed_two_line_menuitem_filler)
       // {
        //    m.focussed_filler = fixed_two_line_menuitem_filler;
       // }
        //else
        //{   
            m.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
        //}
#if 0		
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0  
		gui_menu_replace_menuitem_transparent_filler_by_theme(&m);
#if 0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */

    //highlight_filler = m.focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &m);

    old_alpha_layer = gui_list_set_alpha_blending_layer();
    
 #ifndef __MMI_UI_MENU_SLIM__
    if (gui_filled_area_is_animation(m.focussed_filler))
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        if (list_highlight_effect_current_frame)
        {
            gdi_image_draw_frames(
                GUI_current_fixed_icontext_menuitem_x,
                GUI_current_fixed_icontext_menuitem_y,
                m.focussed_filler->b,
                list_highlight_effect_current_frame - 1);
        }
        else
        {  
            S32 count;
            gdi_image_get_frame_count(m.focussed_filler->b, &count);
            if (count >= 1)
            {
                gdi_image_draw_frames(
                    GUI_current_fixed_icontext_menuitem_x,
                    GUI_current_fixed_icontext_menuitem_y,
                    m.focussed_filler->b,
                    count-1);
            }
            else
            {
                gui_draw_filled_area(
                    GUI_current_fixed_icontext_menuitem_x,
                    GUI_current_fixed_icontext_menuitem_y,
                    GUI_current_fixed_icontext_menuitem_x2,
                    y2,
                    m.focussed_filler);
            }                    
        }            
    }            
    else
#endif/*__MMI_UI_MENU_SLIM__*/
    {
        gui_push_clip();
        gdi_layer_get_clip(&current_x1, &current_y1, &current_x2, &current_y2);
        if (current_x1 < GUI_current_fixed_icontext_menuitem_x )
        {
            current_x1 = GUI_current_fixed_icontext_menuitem_x;
        }
        
        if (current_y1 < GUI_current_fixed_icontext_menuitem_y)
        {
            current_y1 = GUI_current_fixed_icontext_menuitem_y;
        }
        
        if (current_x2 > GUI_current_fixed_icontext_menuitem_x2)
        {
            current_x2 = GUI_current_fixed_icontext_menuitem_x2;
        }
        
        if (current_y2 > y2)
        {
            current_y2 = y2;
        }
        
        gdi_layer_set_clip(current_x1, current_y1, current_x2, current_y2);
        gui_draw_filled_area(
            GUI_current_fixed_icontext_menuitem_x,
            GUI_current_fixed_icontext_menuitem_y,
            GUI_current_fixed_icontext_menuitem_x2,
            GUI_current_fixed_icontext_menuitem_y + 2* m.height - 1,
            m.focussed_filler);
        gui_pop_clip();
    }

    gui_list_reset_alpha_blending_layer(old_alpha_layer);
    }
    
#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    gui_fixed_icontext_enable_transparent_effect(&MMI_fixed_icontext_menuitem); /* To hide text below scrolling text */
#endif/*__MMI_UI_TRANSPARENT_EFFECT__*/
}


/*****************************************************************************
 * FUNCTION
 *  line_scrolling_text_timer_handler
 * DESCRIPTION
 *  Scroll handler of the two line hint/select menu item.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void line_scrolling_text_timer_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&gui_two_line_scroll_text);
}


/*****************************************************************************
 * FUNCTION
 *  two_line_menuitem_cleanup_function
 * DESCRIPTION
 *  Clean up function mainly to stop scrolling text on category exit.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void two_line_menuitem_cleanup_function(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&gui_two_line_scroll_text);
    gui_reset_current_two_line_menuitem_data();
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    gui_reset_two_line();
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_two_line_icontext_menuitem
 * DESCRIPTION
 *  Function to display an two line hint/select menuitem
 * PARAMETERS
 *  item                    [IN]        private two-line menu item object (icontext)
 *  common_item_data        [IN]        common two-line menu item object (icontext)
 *  x                       [IN]        x
 *  y                       [IN]        y
 * RETURNS
 *  void
 *****************************************************************************/
void gui_show_two_line_icontext_menuitem(void *item, void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y2, menu_y1;

    S32 text_x1 = 0;
    S32 text_x2 = 0;
    S32 text_y1 = 0;
    S32 text_y2 = 0;

    S32 icon_x = 0;
    S32 icon_y = 0;
    S32 icon_width = 0;
    S32 icon_height = 0;
    S32 sw = 0, sh = 0;
    U8 show_two_line_hints = 1;
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    U8 thumbnail_flags = 0;
    S32 image_width = 0;
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/
    U32 flags, flags_ext;
   // U32 ret_flag = 0, ret_flag_ext = 0;
    UI_filled_area *f = NULL;
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
    fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
   // UI_string_type _text = NULL;

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    UI_string_type _hint_text = NULL;
#endif/*__MMI_UI_HINTS_IN_MENUITEM__*/ 
  //  PU8 _icon = NULL;

    fixed_icontext_menuitem cm; /* common menuitem */
    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
//#ifndef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
 //   S32 count = 0;
//#endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/  
#if  0
/* under construction !*/
#endif /*__MMI_UI_LIST_HIGHLIGHT_BOLD*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_add_cleanup_hook(two_line_menuitem_cleanup_function);//053006 2 line Calvin
	gui_get_fixed_menuitem_flags_int(item, common_item_data, &flags, &flags_ext);
  //  _text = mi->item_text;
  //  _icon = mi->item_icon;
    x1 = x;
    y1 = y;
    x2 = x1 + m->width - 1;
    y2 = y1 + (m->height << 1) - 1;
    gui_get_menu_top_and_bottom_position(m, &menu_y1,&menu_y2);
    gui_lock_double_buffer();

#if defined(__MMI_UI_HINTS_IN_MENUITEM__) && defined(__MMI_UI_TWO_LINE_MENUITEM_STYLES__)
    if (m->parent_list && m->parent_list->gui_get_current_pop_up_description_string &&
        ((_hint_text = m->parent_list->gui_get_current_pop_up_description_string()) == NULL ||
        (m->ext_flags & UI_MENUITEM_EXT_SHOW_TWO_LINE_SELECT)))
#elif defined (__MMI_UI_HINTS_IN_MENUITEM__)
    if ((_hint_text = m->parent_list->gui_get_current_pop_up_description_string()) == NULL)
#endif 
    {
        show_two_line_hints = 0;
    #ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        thumbnail_flags = gui_two_line_get_thumbnail_flags();
    #endif /*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/
    }

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    if (mmi_fe_get_r2l_state() && thumbnail_flags)
    {
        gui_two_line_toggle_thumbnail_direction();
        thumbnail_flags = gui_two_line_get_thumbnail_flags();
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    gui_reset_current_list_effect();
#endif /*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/

    if (
	#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
		!(flags & UI_MENUITEM_DISABLE_BACKGROUND_ALWAYS) && 
	#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/	
		(flags & UI_MENUITEM_STATE_FOCUSSED))
    {
        if (y1 >= menu_y2)
        {
            gui_push_and_set_clip(x1, menu_y2, x2, menu_y2);
        }
        else if (y2 >= menu_y2)
        {
            gui_push_and_set_clip(x1, y1, x2, menu_y2);
        }
        else
        {
            gui_push_and_set_clip(x1, y1, x2, y2);
        }

        /* verify two line menuitem highlight image dimension */
        cm = *m;
        cm.height *= 2;
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #if !defined(__MMI_OP11_MENU_12MATRIX__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif  /* !defined(__MMI_OP11_MENU_12MATRIX__) */
/* under construction !*/
#if !defined(__MMI_OP11_MENU_12MATRIX__)
/* under construction !*/
#endif
#endif  // __MMI_UI_TWO_LINE_MENUITEM_IMG_SELECTOR__
     //{            
       // if (fixed_two_line_menuitem_filler)
       // {
       //     cm.focussed_filler = fixed_two_line_menuitem_filler;
       // }
       // else
      //  {   
            cm.focussed_filler = current_MMI_theme->menuitem_two_line_highlight_filler;
      //  }
#if 0		
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0        
		gui_menu_replace_menuitem_transparent_filler_by_theme(&cm);
#if 0//__MMI_UI_TRANSPARENT_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 
        f = cm.focussed_filler;//gui_list_get_focussed_filler((gui_common_menuitem_base_struct*) &cm);

        old_alpha_layer = gui_list_set_alpha_blending_layer();
        set_start_position_and_item_parameters_for_list_highlighter_effect(item, common_item_data, x1, y1);
    #ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
		/* Currently special list effect is not supported in two-line menu item */
        gui_draw_list_filled_area(x1, y1, x2, y2, f);
    #else
        gui_menuitem_draw_list_filler(x1, y1, x2, y2, f, MMI_TRUE, MMI_FALSE);
    #endif  // __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
        gui_list_reset_alpha_blending_layer(old_alpha_layer);
	gui_pop_clip();
        }
        
    //}

#ifdef __MMI_FTE_SUPPORT__
    if (mmi_fe_get_r2l_state())
    {
        x1 += MMI_fixed_list_menu.vbar.width;
    }
    else
    {
        x2 -= MMI_fixed_list_menu.vbar.width;
    }
#endif/*__MMI_FTE_SUPPORT__*/

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
    if (!show_two_line_hints)
    {
    	gui_menu_disable_transparent_effect_when_multilayer(m);
		#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif//0
    }
#endif /* __MMI_UI_TRANSPARENT_EFFECT__ */ 

   // if (mi->item_icon != UI_NULL_IMAGE)
  //  {
        gui_measure_image(mi->item_icon, &icon_width, &icon_height);
  //  }
  //  else
  //  {
   //     icon_width = icon_height = 0;
   // }

    /* scenario 0 - No Image, 1 - LEFT Image,  2 - RIGHT Image */
    if (show_two_line_hints
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
        || (thumbnail_flags == UI_TWO_LINE_MENUITEM_NO_THUMBNAIL)
#endif/*__MMI_UI_TWO_LINE_MENUITEM_STYLES__*/ 
        )
    {
        if (mmi_fe_get_r2l_state())
        {
            /* Icon calculation */
            /* R2L icons are right-aligned. */
            icon_x = x2 - m->icon_x - icon_width + 1;
            icon_y = y1;
            /* Text calculation */
            text_x1 = x1;
            text_x2 = x2 - m->text_x;
            text_y1 = y1;
            text_y2 = text_y1 + ((y2 - y1) >> 1);
        }
        else
        {
            /* Icon calculation */
            icon_x = x1 + m->icon_x;
            icon_y = y1;
            /* Text calculation */
            text_x1 = x1 + m->text_x;
            text_x2 = x2;
            text_y1 = y1;
            text_y2 = text_y1 + ((y2 - y1) >> 1);
        }
        if ((flags & UI_MENUITEM_DISABLE_ICON) && (mi->item_icon == UI_NULL_IMAGE))
        {
            if (mmi_fe_get_r2l_state())
            {
                text_x2 = x2 - 2;
            }
            else
            {
                text_x1 = x1 + 2;
            }
        }
    }
#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    else if (thumbnail_flags & UI_TWO_LINE_MENUITEM_LEFT_ALIGN_THUMBNAIL)
    {
        image_width = (m->height << 1);

        icon_x = x2 - m->text_x + 2;
        icon_y = y1;

        text_x1 = x1 + image_width + 2;
        text_x2 = x2 - (m->text_x + GUI_TWO_LINE_TEXT_ICON_GAP);
        text_y1 = y1;
        text_y2 = text_y1 + ((y2 - y1) >> 1);

        if ((flags & UI_MENUITEM_DISABLE_ICON) && (mi->item_icon == UI_NULL_IMAGE))
        {
            text_x2 = x2 - GUI_TWO_LINE_TEXT_ICON_GAP;
        }
    }
    else if (thumbnail_flags & UI_TWO_LINE_MENUITEM_RIGHT_ALIGN_THUMBNAIL)
    {
        image_width = (m->height << 1);

        icon_x = x1 + m->icon_x;

        if ((flags & UI_MENUITEM_DISABLE_ICON) && (mi->item_icon == UI_NULL_IMAGE))
        {
            text_x1 = x1 + 2;
        }
        else
        {
            text_x1 = x1 + m->text_x;
        }

        icon_y = y1;

        text_x2 = x2 - image_width - 2;
        text_y1 = y1;
        text_y2 = text_y1 + ((y2 - y1) >> 1);
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 

#ifdef __MMI_FTE_SUPPORT__    
    /* adjust the text width for the text right gap */
    if (mmi_fe_get_r2l_state())
    {
        text_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
    }
    else
    {
        text_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
    }
#else
    /* adjust the text width for the text right gap */
    //if (gui_menuitem_is_image_highlight(m))
    {
        if (mmi_fe_get_r2l_state())
        {
            text_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            text_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
    }
#endif

    /* draw text */
    if (mi->item_text != NULL && (!(flags & UI_MENUITEM_DISABLE_TEXT_DISPLAY)))
    {
        if (text_y1 >= menu_y2)
        {
            gui_push_and_set_clip(text_x1, menu_y2, text_x2, menu_y2);
        }
        else if (text_y2 >= menu_y2)
        {
            gui_push_and_set_clip(text_x1, text_y1, text_x2, menu_y2);
        }
        else
        {
            gui_push_and_set_clip(text_x1, text_y1, text_x2, text_y2);
        } 

        gui_list_menuitem_set_font((gui_common_menuitem_base_struct *) m, flags);
        gui_measure_string((UI_string_type)mi->item_text, &sw, &sh);
        text_y1 += (m->height >> 1) - (sh >> 1);    /* Center Vertically */
        if (flags & UI_MENUITEM_STATE_FOCUSSED)
        {
        #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
            mmi_frm_dss_set_menu_highlight(MMI_SCREEN_FOCUSED_TWO_LINE_ICONTEXT);
		#endif/*__MMI_SUPPORT_DUMP_SCREEN_STRING__*/
            /* Use another scroll handler */
            gui_fixed_icontext_menuitem_stop_scroll();
            gui_set_text_color(MMI_fixed_icontext_menuitem.focussed_text_color);
        }
        else
        {
            gui_set_text_color(MMI_fixed_icontext_menuitem.normal_text_color);
        }

        if (sw < (text_x2 - text_x1 - 1) || (!(flags & UI_MENUITEM_STATE_FOCUSSED)))
        {
            if (mmi_fe_get_r2l_state())
            {
                gui_move_text_cursor(text_x2, text_y1);
            }
            else
            {
                gui_move_text_cursor(text_x1, text_y1);
            }
            gui_set_line_height(sh);
            if (sw >= (text_x2 - text_x1 - 1))
            {
                gui_print_truncated_text(text_x1, text_y1, text_x2 - text_x1 + 1, mi->item_text);
            }
            else
            {
                gui_print_text((UI_string_type) mi->item_text);
            }
        }
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__		
        else if (flags & UI_MENUITEM_TRUNCATE_CONTENT)
        {
            gui_print_truncated_text(text_x1, text_y1, text_x2 - text_x1 + 1, mi->item_text);
        }
#endif/*__MMI_UI_MENU_ENHANCEMENT_SLIM__*/		
        else
        {
            gui_create_scrolling_text(
                &gui_two_line_scroll_text,
                text_x1,
                text_y1,
                text_x2 - text_x1 + 1,
                sh + 1,
                (UI_string_type)mi->item_text,
                line_scrolling_text_timer_handler,
                scrolling_text_draw_two_line_background,
                MMI_fixed_icontext_menuitem.focussed_text_color,
                MMI_fixed_icontext_menuitem.focussed_text_color);
            gui_show_scrolling_text(&gui_two_line_scroll_text);
        }
        gui_pop_text_clip();
    }

    /* draw icon */
    if (mi->item_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(mi->item_icon, &sw, &sh);
        icon_y += (m->height >> 1) - (sh >> 1); /* Center Vertically */
        if (icon_y >= menu_y2)
        {
            gui_push_and_set_clip(icon_x, menu_y2, icon_x + sw,  menu_y2);
        }
        else if (icon_y + sh >= menu_y2)
        {
            gui_push_and_set_clip(icon_x, icon_y, icon_x + sw,  menu_y2);
        }
        else
        {
            gui_push_and_set_clip(icon_x, icon_y, icon_x + sw, icon_y + sh);
        } 
        gdi_image_draw_animation_single_frame(icon_x, icon_y, (U8*)mi->item_icon, 0);
        gui_pop_clip();

        /* show check box to be corresponding to list effects, since list effects may set _icon as NULL */
        if (m->ext_flags & UI_MENUITEM_EXT_SHOW_ICONTEXT_CHECKBOX)
        {
            gui_menuitem_icontext_show_checkbox(m, x1, y1);
        }
    }

#ifdef __MMI_UI_HINTS_IN_MENUITEM__
    if (show_two_line_hints)
    {
    #ifdef __MMI_SUPPORT_DUMP_SCREEN_STRING__
        mmi_frm_dss_set_menu_highlight(MMI_SCREEN_HIGHLIGHT_TWO_LINE_HINTS);
	#endif/*__MMI_SUPPORT_DUMP_SCREEN_STRING__*/
        gui_show_two_line_hint_part(text_x1, text_x2, y + m->height, y + 2*m->height - 1, _hint_text, flags);
        gui_unlock_double_buffer();
        return;
    }
#endif /* __MMI_UI_HINTS_IN_MENUITEM__ */ 

#ifdef __MMI_UI_TWO_LINE_MENUITEM_STYLES__
    {
        gui_move_two_line_menuitem_part(x1 + 2, y1 + m->height);
        gui_resize_two_line_menuitem_part(x2 - x1 - 4, m->height);
        gui_show_two_line_menuitem_part();
        gui_unlock_double_buffer();
    //    return;
    }
#endif /* __MMI_UI_TWO_LINE_MENUITEM_STYLES__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  gui_two_line_scroller_stop
 * DESCRIPTION
 *  Stop the two-line scroll timer.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gui_two_line_scroller_stop(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_scrolling_text_stop(&gui_two_line_scroll_text);
}

#endif /* (defined __MMI_UI_TWO_LINE_MENUITEM_STYLES__ || defined __MMI_UI_HINTS_IN_MENUITEM__) */ 


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_checkbox_get_data
 * DESCRIPTION
 *  Get the checkbox object.
 * PARAMETERS
 *  checkbox       [OUT]    checkbox object
 *  m              [IN]     common menu item object
 *  x1             [IN]     x1
 *  y1             [IN]     y1
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, gui_common_menuitem_base_struct *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 //   S32 iwidth, iheight;
    PU8 checkbox_img;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*
     * get checkbox image and dimension
     */
#if 0     
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0	
	m->checkbox_get_image_callback(wgui_get_current_menuitem_index(m->parent_list), &checkbox_img);

	gui_measure_image(checkbox_img, &checkbox->image_width, &checkbox->image_height);
    
    checkbox->image = checkbox_img;
 //   checkbox->image_width = iwidth;
 //   checkbox->image_height = iheight;
    
    /* 
     * get checkbox x1 
     */
    if (mmi_fe_get_r2l_state())
    {        
        checkbox->x = x1 + m->width - 1 - checkbox->image_width - m->checkbox_x;
    }
    else
    {
        checkbox->x = x1 + m->checkbox_x;
    }

    /* 
     * get checkbox y1 
     */
    if (m->checkbox_y == 0)
    {   /* vertical center align */
        checkbox->y = y1 + (m->height - checkbox->image_height) / 2;
    }    
    else
    {
        checkbox->y = y1 + m->checkbox_y;
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_checkbox_get_data
 * DESCRIPTION
 *  Get the checkbox object.
 * PARAMETERS
 *  checkbox       [OUT]    checkbox object
 *  m              [IN]     common icontext menu item object
 *  x1             [IN]     x1
 *  y1             [IN]     y1
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_menuitem *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_checkbox_get_data(checkbox, (gui_common_menuitem_base_struct *) m, x1, y1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_checkbox_get_data
 * DESCRIPTION
 *  Get the checkbox object.
 * PARAMETERS
 *  checkbox       [OUT]    checkbox object
 *  m              [IN]     common icontext menu item object
 *  x1             [IN]     x1
 *  y1             [IN]     y1
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_list_checkbox_get_data(gui_menuitem_icontext_checkbox_struct *checkbox, fixed_icontext_list_menuitem *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_checkbox_get_data(checkbox, (gui_common_menuitem_base_struct *) m, x1, y1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_show_checkbox
 * DESCRIPTION
 *  Show the checkbox of icontext menu items.
 * PARAMETERS
 *  x1                    [IN]      x1
 *  y1                    [IN]      y1
 *  common_menuitem       [IN]      common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_show_checkbox(fixed_icontext_menuitem *m, S32 x1, S32 y1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_checkbox_struct checkbox;
       
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_checkbox_get_data(&checkbox, m, x1, y1);

    gdi_image_draw(checkbox.x, checkbox.y, checkbox.image);
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_icontext_show_checkbox
 * DESCRIPTION
 *  Show the checkbox of icontext menu items.
 * PARAMETERS
 *  x1                    [IN]      x1
 *  y1                    [IN]      y1
 *  common_menuitem       [IN]      common icontext menu item object
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_icontext_list_show_checkbox(fixed_icontext_list_menuitem *m, S32 x1, S32 y1)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_checkbox_struct checkbox;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_menuitem_icontext_list_checkbox_get_data(&checkbox, m, x1, y1);
    
    gdi_image_draw(checkbox.x, checkbox.y, checkbox.image);
}

#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_is_image_highlight
 * DESCRIPTION
 *  Check if the highlight is image.
 * PARAMETERS
 *  common_item_data    [IN]    common menu item object
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/
static S32 gui_menuitem_is_image_highlight(void *common_item_data)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (((m->focussed_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_BITMAP) ||
            ((m->focussed_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN) ||
            ((m->focussed_filler->flags & 0xFF) == UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN) ||
            gui_list_effect_slide_is_enable());
}
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/

/*****************************************************************************
 * FUNCTION
 *  gui_get_fixed_menuitem_flag_int
 * DESCRIPTION
 *  get meuitem flags
 * PARAMETERS
 *  f               [IN]    highlight filler
 *  x1, y1, x2, y2    [IN]    the position of filler
 *  isAnimate  [IN]    whether block the animation when filler is animation
 *  noTran      [IN]    whether the filler support transparent color
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/

static void gui_get_fixed_menuitem_flags_int(
	void *item, 
	void *common_item_data, 
	U32* flags, 
	U32* flags_ext)
{
  //  fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) common_item_data;
  //  fixed_icontext_menuitem_type *mi = (fixed_icontext_menuitem_type*) item;
  
  gui_common_menuitem*m = (gui_common_menuitem*) common_item_data;
  fixed_menuitem_type* mi = (fixed_menuitem_type*) item;
  U32 ret_flag = 0, ret_flag_ext = 0;
	
	*flags = mi->flags | m->flags;
    *flags_ext = m->ext_flags;

	if (g_gui_list_get_menuitem_flags)
    {
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif//
		g_gui_list_get_menuitem_flags(wgui_get_current_menuitem_index(&MMI_fixed_list_menu), &ret_flag, &ret_flag_ext);

		*flags     |= ret_flag;
		*flags_ext |= ret_flag_ext;
    }

}

/*****************************************************************************
 * FUNCTION
 *  gui_get_menu_top_and_bottom_position
 * DESCRIPTION
 *  get meuitem flags
 * PARAMETERS
 *gui_get_menu_top_and_bottom_position
 * RETURNS
 *  
 *****************************************************************************/
static void gui_get_menu_top_and_bottom_position(
	void * common_item_data,
	S32 * menu_y1,
	S32 * menu_y2)
{
     gui_common_menuitem*m = (gui_common_menuitem*) common_item_data;
	 
	  if ((MMI_current_menu_type == LIST_MENU) 
#ifdef __MMI_UI_PAGE_MAINMENU_SUPPORT__	  	
	  	|| (MMI_current_menu_type == PAGE_MENU)
#endif/*__MMI_UI_PAGE_MAINMENU_SUPPORT__*/	  	
	  	)
	   {
		   *menu_y1 = m->parent_list->y;
		   *menu_y2 = m->parent_list->y + m->parent_list->height - 1;
	   }
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_BI_DEGREE_MAIN_MENU_STYLE__ */ 
	   else
	   {
		   *menu_y1 = m->parent_matrix->y;
		   *menu_y2 = m->parent_matrix->y + m->parent_matrix->height - 1;
	   }

}

/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_draw_list_filler
 * DESCRIPTION
 *  Draw list filler
 * PARAMETERS
 *  f               [IN]    highlight filler
 *  x1, y1, x2, y2    [IN]    the position of filler
 *  isAnimate  [IN]    whether block the animation when filler is animation
 *  noTran      [IN]    whether the filler support transparent color
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/
static void gui_menuitem_draw_list_filler(
                S32 x1, 
                S32 y1, 
                S32 x2, 
                S32 y2,
                UI_filled_area * f,
                MMI_BOOL isAnimate,
                MMI_BOOL noTran
                )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__	
#ifndef __MMI_UI_MENU_SLIM__	
    S32 count;
#endif/*__MMI_UI_MENU_SLIM__*/
    UI_filled_area tf;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (f == NULL)
    {
        return;
    }

#ifndef __MMI_UI_MENU_SLIM__
    if (gui_filled_area_is_animation(f))
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        if (isAnimate)
        {
            gdi_image_get_frame_count(f->b, &count);
            if (count >= 1)
            {
                gui_draw_animated_effect_filler(x1, y1, x2, y2, f);            
            }
            else
            {
                gui_draw_filled_area(x1, y1, x2, y2, f);
            }
        }
        else
        {
            gui_draw_animated_effect_filler(x1, y1, x2, y2, f);            
        }
    }            
    else
#endif/*__MMI_UI_MENU_SLIM__*/
    {
        tf = *f;
        
        if (noTran)
        {
            tf.flags &= ~UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
        }
        gui_draw_filled_area(x1, y1, x2, y2, &tf);
    }
#else/*#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__*/
	 gui_draw_filled_area(x1, y1, x2, y2, f);
#endif/*#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_set_text_position
 * DESCRIPTION
 *  Draw list filler
 * PARAMETERS
 *  common_item_data       [IN]   list menu common item data
 *  x, y    [IN]    the text position
 * RETURNS
 *      None
 *****************************************************************************/
void gui_menuitem_set_text_position(void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;
       
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->text_x = x;
    m->text_y = y;

    gui_list_menuitem_adjust_scroll_width(m);
	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif//
}


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_set_icon_position
 * DESCRIPTION
 *  Draw list filler
 * PARAMETERS
 *  common_item_data       [IN]   list menu common item data
 *  x, y    [IN]    the icon position
 * RETURNS
 *      None
 *****************************************************************************/
void gui_menuitem_set_icon_position(void *common_item_data, S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    m->icon_x = x;
    m->icon_y = y;

    gui_list_menuitem_adjust_scroll_width(m);

	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif
}


#ifdef  __MMI_UI_HINTS_IN_MENUITEM__
/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_has_hint
 * DESCRIPTION
 *  Check whether current menuitem has hint
 * PARAMETERS
 *  m     [IN]    common menu item object
 *  flags [IN]    the flags of menuitem
 *  hint_string  [OUT]   store the hint string
 * RETURNS
 *  0: without image highlight. 1: with image highlight.
 *****************************************************************************/
static MMI_BOOL gui_menuitem_has_hint(
    gui_common_menuitem_base_struct *m,
    U32 isFocused)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL show_hint_in_menuitem = MMI_FALSE;
    UI_string_type curr_hint_string = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (m->parent_list && m->parent_list->gui_get_current_pop_up_description_string &&
        (
#ifdef __WGUI_CATE_LIST_ALL_HINTS_IN_MENUITEM__	        
        (m->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS) ||
#endif/*__WGUI_CATE_LIST_ALL_HINTS_IN_MENUITEM__*/        
        ((isFocused) && (m->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT))))
    {
        curr_hint_string = m->parent_list->gui_get_current_pop_up_description_string();
        if (curr_hint_string && mmi_ucs2strlen((CHAR *)curr_hint_string))
        {
            show_hint_in_menuitem = MMI_TRUE;
        }
    }
    
    return show_hint_in_menuitem;
}
#endif  /*__MMI_UI_HINTS_IN_MENUITEM__*/ 


/*****************************************************************************
 * FUNCTION
 *  gui_menuitem_adjust_text_clip_for_right_gap
 * DESCRIPTION
 *  Adjust the menu item text clip with image highlight by GUI_MENUITEM_TEXT_RIGHT_GAP.
 * PARAMETERS
 *  common_item_data    [IN]    common menu item object        
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_menuitem_adjust_text_clip_for_right_gap(void *common_item_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem_base_struct *m = (gui_common_menuitem_base_struct*)common_item_data;
    S32     text_clip_x1, text_clip_y1, text_clip_x2, text_clip_y2, menu_y2, menu_y1;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_get_menu_top_and_bottom_position(m, &menu_y1, &menu_y2);
    gui_get_text_clip(&text_clip_x1, &text_clip_y1, &text_clip_x2, &text_clip_y2);
	
#ifdef __MMI_FTE_SUPPORT__
    if (MMI_current_menu_type == LIST_MENU)
    {
        if (mmi_fe_get_r2l_state())
        {
            text_clip_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            text_clip_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
    }   
#else /*__MMI_FTE_SUPPORT__*/   
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
    if ((MMI_current_menu_type == LIST_MENU) && gui_menuitem_is_image_highlight(m))
    {
        if (mmi_fe_get_r2l_state())
        {
            text_clip_x1 += GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
        else
        {
            text_clip_x2 -= GUI_MENUITEM_TEXT_RIGHT_GAP;
        }
    }   
#endif/*__MMI_UI_LIST_SLIDE_EFFECT__*/
#endif/*__MMI_FTE_SUPPORT__*/

    if (text_clip_y1 >= menu_y2)
    {
        text_clip_y1 = menu_y2;
    }
    else if (text_clip_y2 >= menu_y2)
    {
        text_clip_y2 = menu_y2;
    }

#ifdef __128X128_WEARABLE_DEVICE_UI__
    {
        wgui_fixed_list_set_text_clip(text_clip_x1, text_clip_y1, text_clip_x2, text_clip_y2);
    }  
#else
    {
        gui_set_text_clip(text_clip_x1, text_clip_y1, text_clip_x2, text_clip_y2);            
    }
#endif    
}


#ifndef __MMI_BASIC_UI_STYLE__
/*****************************************************************************
 * FUNCTION
 *  gui_animation_with_background_draw_before_cb
 * DESCRIPTION
 *  Animation with background draw before callback.
 * PARAMETERS
 *  result       [IN]   GDI image result code
 * RETURNS
 *  void
 *****************************************************************************/    
static void gui_animation_with_background_draw_before_cb(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle  active_layer;
    S32         iw, ih;
    S32         clip_x1, clip_y1, clip_x2, clip_y2;
    S32         min_y, max_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//	    if (anim_with_bkg_p->background_filler == NULL)
//	    {
//	        //return;
//	    }

    /* save source layer */
    //gdi_get_alpha_blending_source_layer(&anim_with_bkg_p->old_src_layer);
    
    gdi_layer_get_active(&active_layer);
    gdi_set_alpha_blending_source_layer(active_layer);

    /* bring the background layer to the active layer by flattening */    
    gdi_image_get_dimension(anim_with_bkg_p->animation, &iw, &ih);       
    clip_x1 = anim_with_bkg_p->x;
    clip_y1 = anim_with_bkg_p->y;
    clip_x2 = clip_x1 + iw - 1;
    clip_y2 = clip_y1 + ih - 1;    
#ifdef  GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if (gui_matrix_screen_smooth_scrolling_moved_by_pen())
    {
        min_y = clip_y1;
        max_y = clip_y2;
    }
    else
#endif  // GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    {
        min_y = MMI_fixed_matrix_menu.y;
        max_y = MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - 1;
    }
    if (clip_y1 < min_y)
    {
        clip_y1 = min_y;
    }
    if (clip_y2 > max_y)
    {
        clip_y2 = max_y;
    }
    gdi_layer_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    /* for MAUI_02637906, gif will only draw the different between two frame */
    gdi_image_cache_reset();
    gdi_layer_flatten_with_clipping(anim_with_bkg_p->old_src_layer, 0, 0, 0);
    gdi_layer_pop_clip();

    /* draw the animation background filler */
    gui_draw_filled_area(clip_x1, clip_y1, clip_x2, clip_y2, anim_with_bkg_p->background_filler);
}
#endif/*__MMI_BASIC_UI_STYLE__*/



/*****************************************************************************
 * FUNCTION
 *  gui_animation_with_background_blt_before_cb
 * DESCRIPTION
 *  Animation with background before BLT callback.
 * PARAMETERS
 *  result       [IN]   GDI image result code
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_animation_with_background_blt_before_cb(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_BASIC_UI_STYLE__
    S32 iw, ih;
    S32 clip_x1, clip_y1, clip_x2, clip_y2;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_image_get_dimension(anim_with_bkg_p->animation, &iw, &ih);       
    clip_x1 = anim_with_bkg_p->x;
    clip_y1 = anim_with_bkg_p->y;
    clip_x2 = clip_x1 + iw - 1;
    clip_y2 = clip_y1 + ih - 1;    
    if (clip_y1 < MMI_fixed_matrix_menu.y)
    {
        clip_y1 = MMI_fixed_matrix_menu.y;
    }
    if (clip_y2 >= MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height)
    {
        clip_y2 = MMI_fixed_matrix_menu.y + MMI_fixed_matrix_menu.height - 1;
    }
    gdi_layer_push_and_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);

    /* draw the animation background filler */
    gui_draw_filled_area(clip_x1, clip_y1, clip_x2, clip_y2, anim_with_bkg_p->background_filler);

    gdi_layer_pop_clip();
#endif  /*__MMI_BASIC_UI_STYLE__*/ 

    if (anim_with_bkg_p->old_src_layer)
    {
        /* restore the ABM source layer gracefully */
        gdi_set_alpha_blending_source_layer(anim_with_bkg_p->old_src_layer);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gui_show_animation_with_background_filler
 * DESCRIPTION
 *  Draw the animation with a given background filler.
 *  NOTE: Because of the gdi animation API limit, there can be only one animation 
 *  with background in play.
 * PARAMETERS
 *  x                           [IN]     x
 *  y                           [IN]     y
 *  animation                   [IN]     animation
 *  animation_background_filler [IN]     animation background filler
 *  animation_handle            [OUT]    animation handle
 * RETURNS
 *  void
 * REMAKE
 *  this function will only called by matrix main menu
 *****************************************************************************/
void gui_show_animation_with_background_filler(S32 x, S32 y, PU8 animation, UI_filled_area *animation_background_filler, gdi_handle *animation_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     frame_count;
    gdi_handle active_layer;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (animation == NULL)
    {
        return;
    }
    
    anim_with_bkg_p->x = x;
    anim_with_bkg_p->y = y;   
    anim_with_bkg_p->background_filler = animation_background_filler;
    anim_with_bkg_p->animation = animation;
    anim_with_bkg_p->image_type = animation[0];
#ifndef __MMI_BASIC_UI_STYLE__
    gdi_anim_set_draw_before_callback(gui_animation_with_background_draw_before_cb);
#endif/*__MMI_BASIC_UI_STYLE__*/
    gdi_anim_set_draw_after_callback(gui_animation_with_background_blt_before_cb);
    gdi_image_get_frame_count(animation, &frame_count);
    
    /* save source layer */
    gdi_get_alpha_blending_source_layer(&anim_with_bkg_p->old_src_layer);
#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef  GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN
    if (gui_matrix_screen_smooth_scrolling_moved_by_pen())
    {
        gdi_layer_flatten_with_clipping(dm_get_layer_handle(0), dm_get_layer_handle(1), dm_get_layer_handle(2), dm_get_layer_handle(3));
    }
    else
#endif  /* GUI_MATRIX_MENU_SMOOTH_SCROLLING_BY_PEN */        
   // {
        gdi_layer_flatten_with_clipping(dm_get_layer_handle(0), dm_get_layer_handle(1), dm_get_layer_handle(2), dm_get_layer_handle(3));
   // }
#endif/*#ifdef __GDI_MEMORY_PROFILE_2__*/
    // For display animation icon on highlight background
    gdi_layer_get_active(&active_layer);
    gdi_push_and_set_alpha_blending_source_layer(active_layer);
    /* draw the animation */
    gdi_anim_set_count(gdi_anim_get_count(animation));
    gdi_anim_draw(
        x, 
        y,
        animation,   
        animation_handle);
    gdi_pop_and_restore_alpha_blending_source_layer();
    anim_with_bkg_p->animation_handler = *animation_handle;   
}

 
/*****************************************************************************
 * FUNCTION
 *  gui_show_animation_with_background_image
 * DESCRIPTION
 *  Draw the animation with a given background image.
 *  NOTE: Because of the gdi animation API limit, there can be only one animation 
 *  with background in play. 
 * PARAMETERS
 *  x                      [IN]     x
 *  y                      [IN]     y
 *  animation              [IN]     animation
 *  anim_bg_image          [IN]     animation background image
 *  animation_handle       [OUT]    animation handle
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_show_animation_with_background_image(S32 x, S32 y, PU8 animation, PU8 anim_bg_image, gdi_handle *animation_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static UI_filled_area background_filler;
    UI_filled_area  *f;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (anim_bg_image == NULL)
    {
        f = NULL;
    }
    else
    {
        background_filler.b = anim_bg_image;
        background_filler.flags = UI_FILLED_AREA_TYPE_BITMAP;
        f = &background_filler;
    }

    gui_show_animation_with_background_filler(x, y, animation, f, animation_handle);
}


/*****************************************************************************
 * FUNCTION
 *  gui_fixed_icontext_menuitem_get_text_dimension
 * DESCRIPTION
 *  Get width of the text.
 * PARAMETERS
 *  text              [IN]         text
 *  width             [OUT]        width
 *  height            [OUT]        height
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_fixed_icontext_menuitem_get_text_dimension(fixed_icontext_menuitem_type *mi)//, UI_string_type text, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef  __MMI_CAT203_SUPPORT__    
    fixed_icontext_menuitem *m = (fixed_icontext_menuitem*) GUI_current_fixed_icontext_menuitem_common_data;
#endif/*__MMI_CAT203_SUPPORT__*/
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mi->text_width != 0 && mi->text_height != 0 &&!(mi->flags & UI_MENUITEM_STATE_FOCUSSED))
    {
       // *width = mi->text_width;
       // *height = mi->text_height;
        return;
    }
	else
	{
	#ifndef __MMI_UI_MENU_SLIM__
		mmi_fe_get_string_info_param_struct query;
	    memset(&query, 0, sizeof(mmi_fe_get_string_info_param_struct));
	    query.String = (U8*)mi->item_text;
	    query.checkCompleteWord = MMI_FALSE;
	    query.enableTruncated = MMI_FALSE;
	    query.n =  mmi_ucs2strlen((const char*)mi->item_text);
	    query.w = 0;
	    mmi_fe_get_string_widthheight(&query);
	    mi->text_width = query.pWidth;
	    mi->text_height = query.pHeight;
	    mi->baseline = query.baseline;
	#else
		gui_measure_string(mi->item_text, &mi->text_width, &mi->text_height);
	#endif
	}
	
#ifdef  __MMI_CAT203_SUPPORT__    
    if (g_gui_list_get_underline)
    {
        S32 *underline_array = NULL;
        S32 count = 0;    
        S32 i = 0, iwidth, iheight;
        U32 n, nlen;
        U8 underline, bold;
        stFontAttribute text_font;
        text_font = *m->text_font;
    
        underline = m->text_font->underline;
        bold = m->text_font->bold;
        underline_array = (S32*) applib_asm_alloc_anonymous(sizeof(S32) * MAX_SUB_MENU_SIZE);

        if (underline_array)
        {
            memset(underline_array, 0, sizeof(S32) * MAX_SUB_MENU_SIZE);
            #if 0 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
			#endif//0
			g_gui_list_get_underline(wgui_get_current_menuitem_index(&MMI_fixed_list_menu), underline_array, &count);

			if (count != 0)
            {
                mi->text_width = 0;
                nlen = mmi_ucs2strlen((const CHAR *)mi->item_text);
                if(underline_array[0] != 0)
                {
                    n = underline_array[0];
                    gui_set_font(&text_font);
                    gui_measure_string_n(mi->item_text, n, &iwidth, &iheight);
                    mi->text_width += iwidth;
                    mi->item_text += n;
                    nlen -= n;
                }
            
                while(nlen > 0)
                {
                    n = underline_array[i + 1] - underline_array[i] + 1;
                
                    text_font.underline = 1;
                    text_font.bold = 1;
                    gui_set_font(&text_font);
                    gui_measure_string_n(mi->item_text, n, &iwidth, &iheight);
                    mi->text_width += iwidth;
               
                    mi->item_text += n;
                    nlen -= n;
                    if (underline_array[i + 2])
                    {
                        n = underline_array[i + 2] - underline_array[i + 1] - 1;
                        text_font.underline = underline;
                        text_font.bold = bold;
                        gui_set_font(&text_font);
                        gui_measure_string_n(mi->item_text, n, &iwidth, &iheight);
                        mi->text_width += iwidth;             
                        mi->item_text += n;
                        nlen -= n;
                    }
                    i = i + 2;
                    count --;
                    if (count == 0)
                    {
                        break;
                    }
                    if(underline_array[i] == 0 || i >= MAX_SUB_MENU_SIZE - 2)
                    {
                        break;
                    }
                }
                if (nlen)
                {
                    text_font.underline = underline;
                    text_font.bold = bold;
                    gui_set_font(&text_font);
                    gui_measure_string(mi->item_text, &iwidth, &iheight);
                    mi->text_width += iwidth;
                }
            }

            applib_asm_free_anonymous(underline_array);
        }
    }
#endif  // __MMI_CAT203_SUPPORT__
  //  mi->text_width = *width;
  //  mi->text_height = *height;
}

#ifndef __MMI_UI_MENU_SLIM__
/*****************************************************************************
 * FUNCTION
 *  gui_filled_area_is_animation
 * DESCRIPTION
 *  Decide whether to show animation.
 * PARAMETERS
 *  f              [IN]         filler area
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL gui_filled_area_is_animation(UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return 
       (f && 
        f->flags & UI_FILLED_AREA_TYPE_BITMAP && 
        f->b &&
        (f->b[0] == GDI_IMAGE_TYPE_PNG_SEQUENCE ||
        f->b[0] == GDI_IMAGE_TYPE_ABM_SEQUENCE || 
        f->b[0] == GDI_IMAGE_TYPE_AB2_SEQUENCE || 
        f->b[0] == GDI_IMAGE_TYPE_PNG_SEQUENCE_FILE_OFFSET ||
        f->b[0] == GDI_IMAGE_TYPE_ABM_SEQUENCE_FILE_OFFSET || 
        f->b[0] == GDI_IMAGE_TYPE_AB2_SEQUENCE_FILE_OFFSET));
   // {
   //     return MMI_TRUE;
   // }
   // return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  gui_scroll_text_draw_animated_effect_filler
 * DESCRIPTION
 *  Draw the animated highlighter filler for scrolling text.
 * PARAMETERS
 *  x1      [IN]        x1
 *  y1      [IN]        y1
 *  x2      [IN]        x2
 *  y2      [IN]        y2
 *  f       [IN]        filler
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_scroll_text_draw_animated_effect_filler(S32 x1, S32 y1, S32 x2, S32 y2, UI_filled_area *f)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_frame, repeat_time;
    S32 current_anim_frame = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    xstart_effect = x1;
    ystart_effect = y1;
    xend_effect = x2;
    yend_effect = y2;

    /* get the number of frames in the animation */
    repeat_time = gdi_anim_get_count(f->b);
    gdi_image_get_frame_count(f->b, &max_frame);  

    if (list_highlight_effect_current_frame >= max_frame)
    {
        list_highlight_effect_current_frame = 0;
    }

    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
    if (mmi_is_redrawing_bk_screens())
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1); 
    }
    else if (list_highlight_effect_current_frame == 0 && repeat_time == 1)
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }
    else if (list_highlight_effect_current_frame == max_frame - 1 && repeat_time == 1)
    {   
        /* the last frame is already shown, go back to the first frame */
        //gdi_image_draw_animation_single_frame(x1, y1, f->b, 0);
        gdi_image_draw_frames(x1, y1, f->b, (S16) list_highlight_effect_current_frame);  
        //gui_draw_list_highlight_effect_last_frame();                
        list_highlight_effect_current_frame = 0;
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__		
        list_highlight_effect_times = 1;
#endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/
        /* prevent from drawing the menu item twice when it is already scrolling */
        //gui_start_timer(UI_text_menuitem_scroll_time, gui_scroll_start_handler_for_list_effects);
        
    }
	
#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
    else if (list_highlight_effect_current_frame <= max_frame && list_highlight_effect_times == 0)
#else/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/
    else if (list_highlight_effect_current_frame <= max_frame)
#endif/*__MMI_UI_LIST_HIGHLIGHT_EFFECTS__*/
    {  
#ifdef __MMI_UI_LIST_SLIDE_EFFECT__
        if (anim_handle)
        {
            current_anim_frame = gdi_anim_get_current_frame_number(anim_handle);
        }
        else
#endif /* __MMI_UI_LIST_SLIDE_EFFECT__ */
        {
            current_anim_frame = list_highlight_effect_current_frame;
        }
        
        if (current_anim_frame == 0)
        {
            current_anim_frame = max_frame - 1;
        }
        else
        {
            current_anim_frame--;
        }

        gdi_image_draw_frames(x1, y1, f->b, (S16) current_anim_frame);      /* Show frame by frame no. */    
    }
    else
    {
        gdi_image_draw_animation_single_frame(x1, y1, f->b, (S16) max_frame - 1);      /* Show frame by frame no. */
    }
}
#endif/*__MMI_UI_MENU_SLIM__*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0

#ifdef __MMI_UI_LIST_HIGHLIGHT_EFFECTS__
/*****************************************************************************
* FUNCTION
*  gui_list_effect_is_blocked
* DESCRIPTION
*  Get whether list effect is blocked.
* PARAMETERS
*  void   
* RETURNS
*  S32
*  0    :    List effect is unblocked
*  1    :    List effect is blocked
*****************************************************************************/
MMI_BOOL gui_list_effect_is_blocked(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gblock_list_effect;
}
#endif /* __MMI_UI_LIST_HIGHLIGHT_EFFECTS__ */


///add by huking
#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__
/*****************************************************************************
* FUNCTION
*  gui_list_is_hide_menu_callback_executed
* DESCRIPTION
*  gui_list_is_hide_menu_callback_executed.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
MMI_BOOL gui_list_is_hide_menu_callback_executed(S32 x1,S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

	if (g_gui_list_hide_menu)
	{
		g_gui_list_hide_menu(x1, y1, x2, y2);
		return MMI_TRUE;
	}
	return MMI_FALSE;
}
#endif/*#ifndef __MMI_UI_MENU_ENHANCEMENT_SLIM__*/
/*****************************************************************************
* FUNCTION
*  gui_list_is_hide_menu_callback_executed
* DESCRIPTION
*  gui_list_is_hide_menu_callback_executed.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static MMI_BOOL gui_is_menuitem_show_hint_two_line(void)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   return (
#ifdef __WGUI_CATE_LIST_ALL_HINTS_IN_MENUITEM__   
   	GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_SHOW_ALL_HINTS ||
#endif/*__WGUI_CATE_LIST_ALL_HINTS_IN_MENUITEM__*/   	
                  ((GUI_current_fixed_icontext_menuitem_data->flags & UI_MENUITEM_STATE_FOCUSSED) &&
                   (GUI_current_fixed_icontext_menuitem_common_data->ext_flags & UI_MENUITEM_SHOW_HIGHLIGHTED_HINT)));
   
}

/*****************************************************************************
* FUNCTION
*  gui_list_is_hide_menu_callback_executed
* DESCRIPTION
*  gui_list_is_hide_menu_callback_executed.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
S32 wgui_get_current_menuitem_index(fixed_list_menu *m)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (m->current_displayed_item == -1)
	{
		return m->highlighted_item;
	}
	else
	{
		return m->current_displayed_item;
	}
}

/*****************************************************************************
* FUNCTION
*  gui_list_is_hide_menu_callback_executed
* DESCRIPTION
*  gui_list_is_hide_menu_callback_executed.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static void gui_list_menuitem_adjust_scroll_width(void *m0)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem *m = (gui_common_menuitem*)m0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    	 
    if (m->icon_x > m->text_x)
    {
        m->scroll_width = m->icon_x - m->text_x;
    }
    else
    {
        m->scroll_width = m->width - m->text_x;
    }

}

/*****************************************************************************
* FUNCTION
*  gui_list_is_hide_menu_callback_executed
* DESCRIPTION
*  gui_list_is_hide_menu_callback_executed.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static void gui_execute_list_menu_item_resize_function(void)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (MMI_current_menu_type == LIST_MENU)
	{
		if(!gui_is_list_menu_show_vertical_scrollbar(&MMI_fixed_list_menu))
		{
			if (MMI_fixed_list_menu.width == MMI_content_width)
			{
				MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - 4, 0);
			}
		}
		else
		{
		  wgui_resize_menuitem();
#if 0		
/* under construction !*/
/* under construction !*/
#ifdef __MMI_FTE_SUPPORT__
/* under construction !*/
#else
/* under construction !*/
#endif
#endif//0
		}
	}

}

/*****************************************************************************
* FUNCTION
*  gui_list_is_hide_menu_callback_executed
* DESCRIPTION
*  gui_list_is_hide_menu_callback_executed.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
void wgui_resize_menuitem(void)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FTE_SUPPORT__
    MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#else/*__MMI_FTE_SUPPORT__*/
    MMI_fixed_list_menu.item_resize_function(MMI_fixed_list_menu.width - MMI_fixed_list_menu.vbar.width - GUI_MENUITEM_X1_GAP - GUI_MENUITEM_X2_GAP, 0);
#endif/*__MMI_FTE_SUPPORT__*/

}

/*****************************************************************************
* FUNCTION
*  gui_is_matrix_menu_show_vbar
* DESCRIPTION
*  gui_is_matrix_menu_show_vbar.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
MMI_BOOL gui_is_matrix_menu_show_vbar(S32 flags)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return flags & UI_MATRIX_MENU_SHOW_VERTICAL_SCROLLBAR;
}
#ifdef __MMI_HORIZONTAL_SCROLL_BAR_SUPPORT__    

/*****************************************************************************
* FUNCTION
*  gui_is_matrix_menu_show_vbar
* DESCRIPTION
*  gui_is_matrix_menu_show_vbar.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
MMI_BOOL gui_is_matrix_menu_show_hbar(S32 flags)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return flags & UI_MATRIX_MENU_SHOW_HORIZONTAL_SCROLLBAR;
}
#endif/*#ifdef __MMI_HORIZONTAL_SCROLL_BAR_SUPPORT__    */

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
/*****************************************************************************
* FUNCTION
*  gui_menu_replace_menuitem_transparent_filler_by_theme
* DESCRIPTION
*  gui_menu_replace_menuitem_transparent_filler_by_theme.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static void gui_menu_replace_menuitem_transparent_filler_by_theme(void *item)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_common_menuitem *m = (gui_common_menuitem*)item;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
	if (m->focussed_filler && 
	 (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_BITMAP &&
	 (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_RIGHT_ALIGN &&
	 (m->focussed_filler->flags & 0xFF) != UI_FILLED_AREA_TYPE_IMAGE_LEFT_ALIGN)
	{
		menuitem_transparent_filled_area = *(m->focussed_filler);
		m->focussed_filler = &menuitem_transparent_filled_area;
		menuitem_transparent_filled_area.flags |= UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR;
		menuitem_transparent_filled_area.c.alpha = HIGHLIGHTER_COLOR_OPACITY_VALUE;
	}

}
#endif/*#__MMI_UI_TRANSPARENT_EFFECT__*/

#ifdef  __MMI_MAINLCD_320X480__
/*****************************************************************************
* FUNCTION
*  gui_get_matrix_menu_highlight_filler
* DESCRIPTION
*  gui_get_matrix_menu_highlight_filler.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static void gui_get_matrix_menu_highlight_filler(UI_filled_area *f)

{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
    if (MMI_current_menu_type == MATRIX_MENU)
    {
        if (current_MMI_theme->matrix_main_menu_highlight_image)
        {
            f->b = current_MMI_theme->matrix_main_menu_highlight_image;
            f->flags = UI_FILLED_AREA_TYPE_BITMAP;
        }
        else
        {
            f = NULL;
        }
    }
}
#endif/*__MMI_MAINLCD_320X480__*/

#ifdef __MMI_UI_TRANSPARENT_EFFECT__
/*****************************************************************************
* FUNCTION
*  gui_menu_disable_transparent_effect_when_multilayer
* DESCRIPTION
*  gui_menu_disable_transparent_effect_when_multilayer.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
void gui_menu_disable_transparent_effect_when_multilayer(void *m)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/* This is to replace the UI_FILLED_AREA_TYPE_TRANSPARENT_COLOR flag and alpha value from the themecomponent.h */
	if (!gui_is_current_transparency_with_multi_layer())
	{
	  gui_fixed_icontext_disable_transparent_effect(m);	  /* To hide text below scrolling text */
	}
}
#endif/*__MMI_UI_TRANSPARENT_EFFECT__*/

/*****************************************************************************
* FUNCTION
*  gui_is_menuitem_show_animation_when_hilited
* DESCRIPTION
*  gui_is_menuitem_show_animation_when_hilited.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static MMI_BOOL gui_is_menuitem_show_animation_when_hilited(S32 flags)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return ((flags & UI_MENUITEM_STATE_FOCUSSED)&&(flags & UI_MENUITEM_FOCUSSED_ANIMATE));//||
		   //(flags & (UI_MENUITEM_STATE_SELECTED|UI_MENUITEM_SELECTED_ANIMATE)));	

}

/*****************************************************************************
* FUNCTION
*  gui_push_and_set_list_menu_act_handle_active
* DESCRIPTION
*  gui_push_and_set_list_menu_act_handle_active.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
void gui_push_and_set_list_menu_act_handle_active(void)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	 gdi_layer_push_and_set_active(MMI_fixed_list_menu.act_layer_handle);	

}

/*****************************************************************************
* FUNCTION
*  gui_is_fixed_list_menu_empty
* DESCRIPTION
*  gui_is_fixed_list_menu_empty.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
MMI_BOOL gui_is_fixed_list_menu_empty(void)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	 return (MMI_fixed_list_menu.n_items <= 0);	

}

/*****************************************************************************
* FUNCTION
*  gui_is_fixed_list_menu_empty
* DESCRIPTION
*  gui_is_fixed_list_menu_empty.
* PARAMETERS
*  void   
* RETURNS
*
*****************************************************************************/
static void gui_adjust_menuitem_center_align_icon_position(void *item, PU8 _icon)
{
     /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 icon_width, icon_height; 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_common_menuitem *m  = (gui_common_menuitem *)item;
	
	if (_icon != UI_NULL_IMAGE)
    {
        gui_measure_image(_icon, &icon_width, &icon_height);
        if (m->flags & UI_MENUITEM_CENTER_ICON_X)
        {
            m->icon_x = (m->width >> 1) - (icon_width >> 1);
        }
        if (m->flags & UI_MENUITEM_CENTER_ICON_Y)
        {
            m->icon_y = (m->height >> 1) - (icon_height >> 1);
        }
    }	

}

//end huking add

