/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/

#include "MMI_features.h"
#if defined (__MMI_DOWNLOAD_AGENT__)

//#include "CommonScreens.h"
//#include "ProtocolEvents.h"
#include "app_mine.h"
//#include "FileMgr.h"
//#include "FileManagerGProt.h"

#include "drm_def.h"                    /* DRM_PROC_RESULT_OK */
#include "DLAgentSrvDef.h"
#include "DLAgentSrvGprot.h"
#include "DLAgentSrvIProt.h"
#include "DLAgentSrvProt.h"
#ifdef __MMI_DOWNLOAD_AGENT__
#include "mmi_rp_srv_downloadagent_def.h"
#endif
#if defined(__MMI_VIDEO_PDL__) || defined(__MMI_VIDEO_STREAM__)
#ifdef __MMI_VIDEO_PLAYER__
#include "VdoPlyGProt.h"
#endif /*__MMI_VIDEO_PLAYER__*/
#endif 

#if defined(__MMI_VIDEO_PDL__) || defined(__MMI_AUDIO_PDL__) || defined(__MMI_MEDIA_PLAYER_STREAM__)
#ifdef __MMI_MEDIA_PLAYER__
#include "MediaPlayerGProt.h"
#endif /*__MMI_MEDIA_PLAYER__*/
#endif /*defined(__MMI_VIDEO_PDL__) || defined(__MMI_AUDIO_PDL__) || defined(__MMI_MEDIA_PLAYER_STREAM__)*/
#ifdef __COSMOS_MMI_PACKAGE__
#if defined(__MMI_VIDEO_PDL__) && (defined(__MMI_FTO_GALLERY__)|| defined(__MMI_GALLERY_SLIM__))
#include "vapp_gallery_gprot.h"
#endif
#endif

#ifdef __MMI_KURO_SUPPORT__
#include "MediaPlayerGProt.h"
#endif

#if defined (__MMI_SWFLASH__)
#include "SWFlashGProt.h"
#endif

#ifdef __MMI_SYNCML_SERVER_ALERT_SYNC_SUPPORT__
/* under construction !*/
#endif
#ifdef __MMI_BARCODEREADER__
#include "mmi_features_barcodereader.h"
#include "barcodereadergprot.h"
#endif

#ifdef __MMI_OP01_DCD__
#include "DCDGProt.h"
#endif

#include "ProvisioningSrvGprot.h"
#ifdef __MMI_PROVISIONING_SERVICE_SUPPORT__
#include "ProvisioningSrvMain.h"
#endif




    #include "MMIDataType.h"
	#include "GlobalResDef.h"
    #include "wgui.h"
    #include "FileMgrGProt.h"
    #include "mmi_rp_srv_downloadagent_def.h"
    #include "kal_general_types.h"
    #include "FileMgrType.h"
    #include "Unicodexdcl.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "string.h"
    #include "MMI_conn_app_trc.h"
    #include "mmi_conn_app_trc.h"
    #include "kal_trace.h"
    #include "mmi_frm_mem_gprot.h"


#ifndef __COSMOS_MMI_PACKAGE__
#define MMI_DLA_DEFAULT_FOLDER_IMAGES    FMGR_DEFAULT_FOLDER_IMAGES
#define MMI_DLA_DEFAULT_FOLDER_AUDIOS    FMGR_DEFAULT_FOLDER_AUDIO
#define MMI_DLA_DEFAULT_FOLDER_VIDEOS    FMGR_DEFAULT_FOLDER_VIDEO
#define MMI_DLA_DEFAULT_FOLDER_EBOOKS    FMGR_DEFAULT_FOLDER_EBOOKS
#define MMI_DLA_DEFAULT_FOLDER_RECEIVED  FMGR_DEFAULT_FOLDER_RECEIVED
#define MMI_DLA_DEFAULT_FOLDER_MRE       L"Mre\\"
#else
#include "custom_mmi_folders_config.h"
#define MMI_DLA_DEFAULT_FOLDER_IMAGES    IMAGE_DOWNLOAD_FOLDER_NAME
#define MMI_DLA_DEFAULT_FOLDER_AUDIOS    AUDIO_DOWNLOAD_FOLDER_NAME
#define MMI_DLA_DEFAULT_FOLDER_VIDEOS    VIDEO_DOWNLOAD_FOLDER_NAME
#define MMI_DLA_DEFAULT_FOLDER_EBOOKS    EBOOK_DOWNLOAD_FOLDER_NAME
#define MMI_DLA_DEFAULT_FOLDER_RECEIVED  RECEIVED_DOWNLOAD_FOLDER_NAME
#define MMI_DLA_DEFAULT_FOLDER_MRE       APPLICATION_DOWNLOAD_FOLDER_NAME
#endif


extern void srv_da_receive_da_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string);

extern void srv_da_receive_unsupported_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string);


#ifdef __MMI_EMAIL__
extern void srv_email_receive_emn_file(
                S32 session_id,
                S32 mime_type,
                S32 mime_subtype,
                S32 action,
                PU16 filepath,
                PS8 url,
                PS8 mime_type_string);
#endif /* __MMI_EMAIL__ */

/****************************************************************************
* Function Forward Declaration
*****************************************************************************/

#if defined (__IMPS__)
extern void imps_receive_da_file(S32 session_id,S32 mime_type, S32 mime_subtype, S32 action, PU16 file_path, PS8 url, PS8 mime_type_string);
#endif

#ifdef __MMI_MMS_MMA_MMS_OBJECT_IND__
extern void srv_mms_handle_mms_file(S32 session_id,
        S32 mime_type,
        S32 mime_subtype,
        S32 action_type,
        PU16 filename,
        PS8 download_url,
        PS8 mime_type_str_string);
#endif

#ifdef OBIGO_Q03C_MMS_V01
extern void mmi_mmsv01_agent_handle_mms_file(
        S32 session_id,
        S32 mime_type,
        S32 mime_subtype,
        S32 action_type,
        PU16 filename,
        PS8 download_url,
        PS8 mime_type_str_string);
#endif /* OBIGO_Q03C_MMS_V01 */


#ifdef __MMI_OP01_BARCODEREADER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if defined(__AGPS_SUPPORT__) && defined(__SUPL_SUPPORT__)
extern void mmi_gps_mgr_da_file(S32 session_id, S32 mime_type, S32 mime_subtype, S32 action, PU16 file_path, PS8 url, PS8 mime_type_string);
#endif

#ifdef SYNCML_DM_SUPPORT
extern void srv_dm_session_bootstrap_receive_da_file(
                S32 session_id,
                S32 mime_type,
                S32 mime_subtype,
                S32 action,
                PU16 filepath,
                PS8 url,
                PS8 mime_type_string);
extern void srv_dm_session_da_push_setting(
                S32 session_id,
                S32 mime_type,
                S32 mime_subtype,
                S32 action,
                U32 filesize,
                PS8 url,
                PS8 mime_type_string,
                U32 content_len,
                PS8 content,
                srv_da_setting_struct * setting);
extern void srv_dm_session_notification_receive_da_file(
                S32 session_id,
                S32 mime_type,
                S32 mime_subtype,
                S32 action,
                PU16 filepath,
                PS8 url,
                PS8 mime_type_string);
extern  void srv_dm_dl_receive_upc_file(
                S32 session_id,
                S32 mime_type,
                S32 mime_subtype,
                S32 action,
                PU16 filepath,
                PS8 url,
                PS8 mime_type_string);
extern void srv_dm_dl_da_fumo_setting(
                S32 session_id,
                S32 mime_type,
                S32 mime_subtype,
                S32 action,
                U32 filesize,
                S8 *url,
                S8 *mime_type_string,
                U32 content_len,
                S8 *content,
                srv_da_setting_struct *setting);
#endif /* SYNCML_DM_SUPPORT */

#ifndef __MMI_MMS_MMA_MMS_OBJECT_IND__
void srv_da_handle_mms_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string);
#endif

/****************************************************************************
 * Typedef
 *****************************************************************************/

typedef struct
{
    applib_mime_subtype_enum mime_subtype;
    UI_string_ID_type string_id;
} srv_da_mime_type_str_struct;


typedef struct srv_da_dynamic_reg_hdlr_element_struct_s {
    srv_da_type_handler_struct type_handler;
    struct srv_da_dynamic_reg_hdlr_element_struct_s *next;
} srv_da_dynamic_reg_hdlr_element_struct;


/****************************************************************************
 * Static Variable
 *****************************************************************************/

/*--------------------------------------------------------------------------
 * Register your MIME type handler following:
 * { mime_type, subtype, dispatch_handler, presetting_handler, setting_handler}
 *--------------------------------------------------------------------------*/
 
const static srv_da_type_handler_struct srv_da_hdlr_tbl[] =
{
#ifdef __COSMOS_MMI_PACKAGE__
    {MIME_TYPE_UNKNOWN, MIME_SUBTYPE_UNRECOGNIZED, srv_da_receive_unsupported_file, srv_da_default_presetting, srv_da_default_setting},
#else
    {MIME_TYPE_UNKNOWN, MIME_SUBTYPE_UNRECOGNIZED, NULL, srv_da_default_presetting, srv_da_default_setting},
#endif

#ifdef __J2ME__
    {MIME_TYPE_TEXT, MIME_SUBTYPE_JAD, srv_da_adp_java_receive_da_file, srv_da_default_presetting, srv_da_adp_java_setting},
#ifdef __NO_JAR_DL__
    {MIME_TYPE_TEXT, MIME_SUBTYPE_JAR, NULL, srv_da_default_presetting, srv_da_default_setting},
#else
    {MIME_TYPE_TEXT, MIME_SUBTYPE_JAR, srv_da_adp_java_receive_da_file, srv_da_default_presetting, srv_da_adp_java_setting},
#endif
#endif

#ifdef __DRM_SUPPORT__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_CONTENT, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_drm_content_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_MESSAGE, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_drm_content_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_RIGHTS_WBXML, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_push_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_RIGHTS_XML, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_push_setting},
    #ifdef __DRM_V02__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_CONTENT_V2, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_drm_content_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_ROAP_PDU, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_drm_content_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_ROAP_TRIGGER, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_drm_content_setting},
    {MIME_TYPE_APPLICATION, MIMI_SUBTYPE_PROTECTED_RO, srv_da_receive_da_file, srv_da_drm_presetting, srv_da_push_setting},
    #endif
#endif

#ifdef __MMI_OMA_DD_DOWNLOAD__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_OMA_DD,srv_da_oma_process_dd_file, srv_da_oma_dd_presetting, srv_da_oma_dd_setting},
#ifdef __MMI_OMA_DD2_DOWNLOAD__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_OMA_DD2,srv_da_oma_process_dd2_file, srv_da_oma_dd_presetting, srv_da_oma2_setting},
#endif
#endif

#ifdef __CERTMAN_SUPPORT__
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_CA_CERT,srv_da_adp_certman_install_file, srv_da_default_presetting, srv_da_default_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_USR_CERT,srv_da_adp_certman_install_file, srv_da_default_presetting, srv_da_default_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_PKCS7_CERT,srv_da_adp_certman_install_file, srv_da_default_presetting, srv_da_default_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_PKCS12_CERT,srv_da_adp_certman_install_file, srv_da_default_presetting, srv_da_default_setting},
#else        
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_CA_CERT, NULL, srv_da_default_presetting, srv_da_default_setting},
#endif /*__CERTMAN_SUPPORT__*/
#ifdef OBIGO_Q03C_MMS_V01
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_MMS,mmi_mmsv01_agent_handle_mms_file, srv_da_default_presetting, srv_da_push_setting},
#else
#ifdef __MMI_MMS_MMA_MMS_OBJECT_IND__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_MMS,srv_mms_handle_mms_file, srv_da_default_presetting, srv_da_push_setting},  
#else
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_MMS,srv_da_handle_mms_file,srv_da_default_presetting, srv_da_push_setting},
#endif
#endif
#ifdef __IMPS__
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_CSP_XML,imps_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_CSP_WBXML,imps_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_CSP_CIR,imps_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_CSP_SMS,imps_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
#endif
#ifdef __MMI_SWFLASH__
	{MIME_TYPE_APPLICATION,MIME_SUBTYPE_ZDD,mmi_swflash_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
#endif
#ifdef __MMI_VIDEO_PDL__
#ifdef __MMI_VIDEO_PLAYER__
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_3GPP_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_vdoply_pdl_da_notify_file},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_3GPP_VIDEO_1, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_vdoply_pdl_da_notify_file},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_3GPP_VIDEO_2, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_vdoply_pdl_da_notify_file},
#endif /*__MMI_VIDEO_PLAYER__*/

#ifdef __MMI_MEDIA_PLAYER__
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_3GPP_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_3GPP_VIDEO_1, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_3GPP_VIDEO_2, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_MP4, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_MPEG4, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
#ifdef __FLV_FILE_FORMAT_SUPPORT__
        {MIME_TYPE_VIDEO, MIME_SUBTYPE_FLV_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
        {MIME_TYPE_VIDEO, MIME_SUBTYPE_F4V_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_video_file},
#endif 
#endif /*__MMI_MEDIA_PLAYER__*/
#ifdef __COSMOS_MMI_PACKAGE__
#if defined(__MMI_FTO_GALLERY__) || defined(__MMI_GALLERY_SLIM__)
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_3GPP_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_3GPP_VIDEO_1, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_3GPP_VIDEO_2, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_MP4, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_MPEG4, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    #ifdef __FLV_FILE_FORMAT_SUPPORT__
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_F4V_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    {MIME_TYPE_VIDEO, MIME_SUBTYPE_FLV_VIDEO, srv_da_receive_da_file, srv_da_need_content_presetting, vapp_gallery_pdl_da_notify_video_file},
    #endif
#endif /* __MMI_FTO_GALLERY__*/
#endif

#endif /*__MMI_VIDEO_PDL__*/

#if defined(__MMI_AUDIO_PDL__) && (__MTK_TARGET__)

#ifdef __MMI_MEDIA_PLAYER__
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AMR, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_WAV, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#ifdef AU_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AU, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AU_XULAW, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*AU_DECODE*/
#ifdef SND_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_SND, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*SND_DECODE*/
#ifdef AIFF_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AIFF, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AIF, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AIFC, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*AIFF_DECODE*/
#ifdef AAC_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AAC, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*AAC_DECODE*/
#ifdef M4A_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_M4A, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*M4A_DECODE*/
#ifdef AMRWB_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AWB, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*AMRWB_DECODE*/
#ifdef DAF_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AUDIO_MP3, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*DAF_DECODE*/
#ifdef WMA_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_WMA, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*WMA_DECODE*/
#ifdef MUSICAM_DECODE
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AUDIO_MP2, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif /*MUSICAM_DECODE*/
#ifdef __FLAC_DECODE__
    {MIME_TYPE_AUDIO, MIME_SUBTYPE_AUDIO_FLAC, srv_da_receive_da_file, srv_da_need_content_presetting, mmi_medply_sinlge_pdl_da_notify_audio_file},
#endif/*__FLAC_DECODE__*/

#endif /*__MMI_MEDIA_PLAYER__*/
#endif /*__MMI_AUDIO_PDL__*/

#ifdef __MMI_VIDEO_STREAM__

#ifdef __MMI_VIDEO_PLAYER__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_SDP, mmi_vdoply_stream_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
#endif
#ifdef __MMI_MEDIA_PLAYER_STREAM__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_SDP,mmi_medply_single_stream_receive_da_file, srv_da_default_presetting, srv_da_bypass_setting},
#endif

#endif /*__MMI_VIDEO_STREAM__*/

#ifdef SYNCML_DM_SUPPORT
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DM_WBXML, srv_dm_session_bootstrap_receive_da_file, srv_da_default_presetting, srv_dm_session_da_push_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DM_XML, srv_dm_session_bootstrap_receive_da_file, srv_da_default_presetting, srv_dm_session_da_push_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DM_NOTIFICATION, srv_dm_session_notification_receive_da_file, srv_da_default_presetting, srv_dm_session_da_push_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_DM_FUMO, srv_dm_dl_receive_upc_file, srv_da_default_presetting, srv_dm_dl_da_fumo_setting},
#endif /* SYNCML_DM_SUPPORT */
#ifdef __MMI_SYNCML_SERVER_ALERT_SYNC_SUPPORT__
/* under construction !*/
#endif
#ifdef __MMI_OP01_DCD__
    {MIME_TYPE_TEXT,        MIME_SUBTYPE_SL,    mmi_dcd_receive_da_file, srv_da_default_presetting, srv_da_push_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_SLC,   mmi_dcd_receive_da_file, srv_da_default_presetting, srv_da_push_setting},
#endif

	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_OMA_PROV_WBXML, srv_prov_receive_da_file, srv_da_default_presetting, srv_prov_da_push_setting},
#ifdef __PROV_NOKIA_OTA_SUPPORT__
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_NOKIA_PROV_BROWSER,    srv_prov_receive_da_file, srv_da_default_presetting, srv_prov_da_push_setting},
	{MIME_TYPE_APPLICATION, MIME_SUBTYPE_NOKIA_PROV_BOOKMARKS,  srv_prov_receive_da_file, srv_da_default_presetting, srv_prov_da_push_setting},
#endif

#ifdef __MMI_OP01_BARCODEREADER__
/* under construction !*/
#endif
#if defined(__AGPS_SUPPORT__) && defined(__SUPL_SUPPORT__)
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_SUPL, mmi_gps_mgr_da_file, srv_da_default_presetting, srv_da_push_setting},
#endif

#ifdef __MMI_KURO_SUPPORT__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_KUR, srv_da_receive_da_file, srv_da_default_presetting, mmi_medply_kuro_bypass_settings},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_KLR, srv_da_receive_da_file, srv_da_default_presetting, mmi_medply_kuro_bypass_settings},
#endif

#ifdef __MMI_EMAIL__
    {MIME_TYPE_TEXT, MIME_SUBTYPE_EMN_XML, srv_email_receive_emn_file, srv_da_default_presetting, srv_da_push_setting},
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_EMN_WBXML, srv_email_receive_emn_file, srv_da_default_presetting, srv_da_push_setting},
#endif /* __MMI_EMAIL__ */

#ifdef __MMI_GADGET_SUPPORT__
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_WIDGET, srv_da_receive_da_file, srv_da_default_presetting, srv_da_default_setting},
#endif
    {MIME_TYPE_APPLICATION, MIME_SUBTYPE_VXP, srv_da_receive_da_file, srv_da_default_presetting, srv_da_default_setting},
    {MIME_TYPE_NONE, MIME_SUBTYPE_NONE, srv_da_receive_da_file, srv_da_default_presetting, srv_da_default_setting}
};

const static S32 srv_da_hdlr_num = sizeof(srv_da_hdlr_tbl) / sizeof(srv_da_type_handler_struct);


static struct {
    U32 size;
    srv_da_dynamic_reg_hdlr_element_struct *head;
}
g_srv_da_dynamic_reg_hdlr_tbl =
{
    0,
    NULL 
};


/*--------------------------------------------------------------------------
 * Register your hook handler following:
 * { mime_type, subtype, handler_function }
 *--------------------------------------------------------------------------*/
const static srv_da_hook_handler_struct srv_da_hook_hdlr_tbl[] =
{
#ifdef __MMI_OP11_BARCODEREADER__
/* under construction !*/
#endif
    {MIME_TYPE_NONE, MIME_SUBTYPE_NONE, NULL}
};
const static S32 srv_da_hook_hdlr_num = (sizeof(srv_da_hook_hdlr_tbl) / sizeof(srv_da_hook_handler_struct)) - 1;


const static srv_da_mime_type_str_struct srv_da_mime_type_string_tbl[] =
{
    {MIME_SUBTYPE_JPEG,		     STR_DA_IMAGE_FILE},   /*      image/jpeg */
    {MIME_SUBTYPE_VCARD,         STR_DA_VCARD_FILE},
    {MIME_SUBTYPE_XVCARD,        STR_DA_VCARD_FILE},
    {MIME_SUBTYPE_CALENDAR,      STR_DA_VCALENDAR_FILE},
    {MIME_SUBTYPE_XVCALENDAR,    STR_DA_VCALENDAR_FILE},
    {MIME_SUBTYPE_XIMELODY,      STR_DA_AUDIO_FILE},   /*      text/x-imelody */
    {MIME_SUBTYPE_THEME,         STR_DA_APP_FILE},
#ifdef M3D_MMI_SUPPORT
    {MIME_SUBTYPE_M3D,           STR_DA_IMAGE_FILE},
#endif
#if defined(MP4_DECODE)
    {MIME_SUBTYPE_3GPP_AUDIO,    STR_DA_VIDEO_FILE},
#endif
    {MIME_SUBTYPE_UNRECOGNIZED,  STR_DA_UNKNOWN_FILE} /*      Un-recognized file type */

};
const static S32 srv_da_mime_type_string_num = sizeof(srv_da_mime_type_string_tbl) / sizeof(srv_da_mime_type_str_struct);


/****************************************************************************
 * Function 
 ****************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  srv_da_default_presetting
 * DESCRIPTION
 *  Set the presetting to default values.
 * PARAMETERS
 *  param       [IN]  Parameters to determine pre-setting
 *  presetting  [OUT] Pre-setting
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_default_presetting(
    const srv_da_presetting_param_struct *param,
    srv_da_presetting_struct *presetting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Confirm with user before download */
    presetting->confirm_download = MMI_TRUE;

    /* Not need content to determine setting */
    presetting->need_content = MMI_FALSE;
}



/*****************************************************************************
 * FUNCTION
 *  srv_da_need_content_presetting
 * DESCRIPTION
 *  Set the presetting to default values, but need_content = MMI_TRUE.
 * PARAMETERS
 *  param       [IN]  Parameters to determine pre-setting
 *  presetting  [OUT] Pre-setting
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_need_content_presetting(
    const srv_da_presetting_param_struct *param,
    srv_da_presetting_struct *presetting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    srv_da_default_presetting(param, presetting);

    /* Need content to determine setting */
    presetting->need_content = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_config_set_folder
 * DESCRIPTION
 *  
 * PARAMETERS
 *  mime_type       [IN]  MIME type
 *  mime_subtype    [IN]  MIME subtype
 *  folder          [OUT] folder
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_config_set_folder(S32 mime_type, S32 mime_subtype, U16 *folder)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16 *folder_setting;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    folder_setting = MMI_DLA_DEFAULT_FOLDER_RECEIVED;

    switch (mime_type)
    {
        case MIME_TYPE_AUDIO:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_AUDIOS;
            break;
            
        case MIME_TYPE_IMAGE:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_IMAGES;
            break;
            
        case MIME_TYPE_VIDEO:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_VIDEOS;
            break;
            
        case MIME_TYPE_APPLICATION:
            if (mime_subtype == MIME_SUBTYPE_THEME)
            {
                folder_setting = FMGR_DEFAULT_FOLDER_THEMES;
            }
            else
            {
                folder_setting = MMI_DLA_DEFAULT_FOLDER_RECEIVED;
            }
            break;
            
        default:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_RECEIVED;
            break;
    }

    switch (mime_subtype)
    {
    #ifdef M3D_MMI_SUPPORT
        case MIME_SUBTYPE_M3D:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_IMAGES;
            break;
    #endif

    #ifdef __MMI_EBOOK_READER__
        case MIME_SUBTYPE_PDB:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_EBOOKS;
            break;
    #endif

    #if defined(__MMI_BARCODEREADER__) && !defined(__MMI_OP11_BARCODEREADER__)
        case MIME_SUBTYPE_MBC:
            folder_setting = FMGR_DEFAULT_FOLDER_BARCODE;
            break;
    #endif

    #ifdef LANGLN_DIGIDEA
        case MIME_SUBTYPE_DZD:
            folder_setting = FMGR_DEFAULT_FOLDER_LANGLN;
            break;
    #endif

    #ifdef __MMI_MESSAGES_EMS__
        case MIME_SUBTYPE_EMS:
        case MIME_SUBTYPE_ANM:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_IMAGES;
            break;
    #endif
		case MIME_SUBTYPE_VXP:
            folder_setting = MMI_DLA_DEFAULT_FOLDER_MRE;

        default:
            break;
    }


    mmi_wcscpy(folder, folder_setting);

    MMI_ASSERT(mmi_wcslen(folder) > 0);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_type_needs_processing
 * DESCRIPTION
 *  Determine if the type needs processing. This function is designed for
 *  bypass_setting and push_setting. If the file needs processing,
 *  DLAgent should hard-code special rules for these files.
 * PARAMETERS
 *  subtype     [IN] applib_mime_subtype_enum
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL srv_da_type_needs_processing(S32 subtype)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (subtype)
    {
#ifdef __DRM_SUPPORT__
        case MIME_SUBTYPE_DRM_CONTENT:
        case MIME_SUBTYPE_DRM_MESSAGE:
        case MIME_SUBTYPE_DRM_RIGHTS_WBXML:
        case MIME_SUBTYPE_DRM_RIGHTS_XML:
    #ifdef __DRM_V02__
        case MIME_SUBTYPE_DRM_CONTENT_V2:
        case MIME_SUBTYPE_ROAP_PDU:
        case MIME_SUBTYPE_ROAP_TRIGGER:
        case MIMI_SUBTYPE_PROTECTED_RO:
    #endif
            return MMI_TRUE;
#endif

        default:
            break;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_default_setting
 * DESCRIPTION
 *  Default setting function for convenience. Please see the comments to know
 *  the detail of behavior.
 * PARAMETERS
 *  session_id          [IN]    Session ID
 *  mime_type           [IN]    applib_mime_type_enum
 *  mime_subtype        [IN]    applib_mime_subtype_enum
 *  action              [IN]    srv_da_action_enum
 *  filesize            [IN]    File size
 *  url                 [IN]    URL: url[WAP_DL_MAX_URL_LEN]
 *  mime_type_string    [IN]    MIME type string: mime_type_string[WAP_DL_MAX_MIME_TYPE_LEN]
 *  content_len         [IN]    Content-Length in HTTP header, may be 0.
 *  content             [IN]    Content in HTTP response, may be NULL
 *  setting             [OUT]   Appropriate behavior setting by previous information.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_default_setting(
        S32	session_id,
        S32	mime_type,
        S32	mime_subtype,
        S32 action,
        U32	filesize,
        PS8	url,
        PS8	mime_type_string,
        U32	content_len,
        PS8	content,
        srv_da_setting_struct *setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(setting, 0, sizeof(srv_da_setting_struct));

    /* Let user to decide the storage */
    setting->storage = SRV_DA_STORAGE_NONE;
    setting->drv = 0;
    
    /* Let user to input the filename */
    setting->default_filename = MMI_FALSE;
    setting->filename[0] = setting->filename[1] = L'\0';

    /* Default folder */
    srv_da_config_set_folder(mime_type, mime_subtype, setting->folder);

    /* Confirm with user before dispatch */
    setting->confirm_dispatch = MMI_TRUE;

    /* Popup when received via push. */
    setting->confirm_push = MMI_TRUE;

    /* Background download is allowed */
    setting->can_minimize = MMI_TRUE;

    /* Dispatch after file received. */
    setting->do_dispatch = MMI_TRUE;

    /* Not need to report during downloading. */
    setting->filepath_hdlr = NULL;
    setting->report_hdlr = NULL;


    /* --- OBSOLETE --- */
    setting->bypass = MMI_DA_BYPASS_FALSE;
    setting->keepfile = MMI_FALSE;
    setting->percentage_bar = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_bypass_setting
 * DESCRIPTION
 *  Please refer to the comments for further detail.
 *
 *  (Old description)
 *  This setting is used for application want to control the file by itself
 *  User cannot input filename and select drv.
 *  Download agent will save the file into temp folder.
 *  Application must move the file to suitable folder if they want reserve
 *  the file. The temp folder would be deleted.
 * PARAMETERS
 *  session_id          [IN]    Session ID
 *  mime_type           [IN]    applib_mime_type_enum
 *  mime_subtype        [IN]    applib_mime_subtype_enum
 *  action              [IN]    srv_da_action_enum
 *  filesize            [IN]    File size
 *  url                 [IN]    URL: url[WAP_DL_MAX_URL_LEN]
 *  mime_type_string    [IN]    MIME type string: mime_type_string[WAP_DL_MAX_MIME_TYPE_LEN]
 *  content_len         [IN]    Content-Length in HTTP header, may be 0.
 *  content             [IN]    Content in HTTP response, may be NULL
 *  setting             [OUT]   Appropriate behavior setting by previous information.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_bypass_setting(
        S32	session_id,
        S32	mime_type,
        S32	mime_subtype,
        S32 action,
        U32	filesize,
        PS8	url,
        PS8	mime_type_string,
        U32	content_len,
        PS8	content,
        srv_da_setting_struct *setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (action == MMI_DA_SAVE_AS && !srv_da_type_needs_processing(mime_subtype))
    {
        srv_da_default_setting(
            session_id,
            mime_type,
            mime_subtype,
            action,
            filesize,
            url,
            mime_type_string,
            content_len,
            content,
            setting);

        setting->confirm_dispatch = MMI_FALSE;
        setting->do_dispatch = MMI_FALSE;
        
        return;
    }

    /* Let DLAgent to decide the storage */
    setting->storage = SRV_DA_STORAGE_AUTO;
    setting->drv = 0;
    
    /* Let DLAgent to decide the filename */
    setting->default_filename = MMI_TRUE;
    setting->filename[0] = setting->filename[1] = L'\0';

    /* Background download is not allowed */
    setting->can_minimize = MMI_FALSE;

    /* Save in temp folder */
    mmi_ucs2cpy((S8*)setting->folder, (S8*)FMGR_DEFAULT_FOLDER_TEMP);

    /* Don't confirm with user before dispatch */
    setting->confirm_dispatch = MMI_FALSE;

    /* Popup when received via push. */
    setting->confirm_push = MMI_TRUE;

    /* Dispatch after file received. */
    setting->do_dispatch = MMI_TRUE;

    /* Not need to report during downloading. */
    setting->filepath_hdlr = NULL;
    setting->report_hdlr = NULL;


    /* --- OBSOLETE --- */
    setting->bypass = MMI_DA_BYPASS_LEVEL_2;
    setting->keepfile = MMI_FALSE;
    setting->percentage_bar = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_push_setting
 * DESCRIPTION
 *  Please refer to the comments for further detail.
 * PARAMETERS
 *  session_id          [IN]    Session ID
 *  mime_type           [IN]    applib_mime_type_enum
 *  mime_subtype        [IN]    applib_mime_subtype_enum
 *  action              [IN]    srv_da_action_enum
 *  filesize            [IN]    File size
 *  url                 [IN]    URL: url[WAP_DL_MAX_URL_LEN]
 *  mime_type_string    [IN]    MIME type string: mime_type_string[WAP_DL_MAX_MIME_TYPE_LEN]
 *  content_len         [IN]    Content-Length in HTTP header, may be 0.
 *  content             [IN]    Content in HTTP response, may be NULL
 *  setting             [OUT]   Appropriate behavior setting by previous information.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_push_setting(
        S32	session_id,
        S32	mime_type,
        S32	mime_subtype,
        S32 action,
        U32	filesize,
        PS8	url,
        PS8	mime_type_string,
        U32	content_len,
        PS8	content,
        srv_da_setting_struct *setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (action == MMI_DA_SAVE_AS && !srv_da_type_needs_processing(mime_subtype))
    {
        srv_da_default_setting(
            session_id,
            mime_type,
            mime_subtype,
            action,
            filesize,
            url,
            mime_type_string,
            content_len,
            content,
            setting);

        setting->confirm_dispatch = MMI_FALSE;
        setting->do_dispatch = MMI_FALSE;
            
        return;
    }
    
    /* Let DLAgent to decide the storage */
    if (action == MMI_DA_PUSH || action == MMI_DA_PUSH_SIM2 || action == MMI_DA_PUSH_SIM3 || action == MMI_DA_PUSH_SIM4)
    {
        setting->storage = SRV_DA_STORAGE_PUSH_TEMP;
    }
    else
    {
        setting->storage = SRV_DA_STORAGE_AUTO;
    }
    setting->drv = 0;
    
    /* Let DLAgent to decide the filename */
    setting->default_filename = MMI_TRUE;
    setting->filename[0] = setting->filename[1] = L'\0';

    /* Always save into temp folder */
    mmi_ucs2cpy((S8*)setting->folder, (S8*)FMGR_DEFAULT_FOLDER_TEMP);

    /* Don't confirm with user before dispatch */
    setting->confirm_dispatch = MMI_FALSE;

    /* Not inform the user by DLAgent when file received */
    setting->confirm_push = MMI_FALSE;

    /* Dispatch after file received. */
    setting->do_dispatch = MMI_TRUE;

    /* Background download is not allowed. */
    setting->can_minimize = MMI_FALSE;

    /* Not need to report during downloading. */
    setting->filepath_hdlr = NULL;
    setting->report_hdlr = NULL;


    /* --- OBSOLETE --- */
    setting->bypass = MMI_DA_BYPASS_LEVEL_3;
    setting->percentage_bar = MMI_TRUE;
    setting->keepfile = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_get_default_mime_type_handler
 * DESCRIPTION
 *  Get the default MIME type handler.
 * PARAMETERS
 *  void
 * RETURNS
 *  The default MIME type handler.
 *****************************************************************************/
const srv_da_type_handler_struct* srv_da_get_default_mime_type_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return &(srv_da_hdlr_tbl[srv_da_hdlr_num-1]);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_search_mime_type_handler_by_subtype
 * DESCRIPTION
 *  Search corresponding mime type handler
 * PARAMETERS
 *  mime_subtype      [IN] MIME subtype
 * RETURNS
 *  A pointer points to the corresponding handler structure.
 *****************************************************************************/
static const srv_da_type_handler_struct* srv_da_search_mime_type_handler_by_subtype(
    applib_mime_subtype_enum mime_subtype)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    srv_da_dynamic_reg_hdlr_element_struct *hdlr_ele;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mime_subtype == 0)
    {
        return &(srv_da_hdlr_tbl[0]);
    }

    for (i = srv_da_hdlr_num - 1; i >= 0; i--)
    {
        if (srv_da_hdlr_tbl[i].mime_subtype == mime_subtype)
        {
            return &(srv_da_hdlr_tbl[i]);
        }
    }

    for (hdlr_ele = g_srv_da_dynamic_reg_hdlr_tbl.head; hdlr_ele != NULL; hdlr_ele = hdlr_ele->next)
    {
        if (hdlr_ele->type_handler.mime_subtype == mime_subtype)
        {
            return &(hdlr_ele->type_handler);
        }
    }

    return srv_da_get_default_mime_type_handler();
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_search_mime_type_handler
 * DESCRIPTION
 *  Search corresponding mime type handler
 * PARAMETERS
 *  type      [IN]  The MIME type
 * RETURNS
 *  A pointer points to the corresponding handler structure.
 *****************************************************************************/
const srv_da_type_handler_struct* srv_da_search_mime_type_handler(const applib_mime_type_struct* type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (type == NULL)
    {
        return &(srv_da_hdlr_tbl[0]);
    }

    return srv_da_search_mime_type_handler_by_subtype(type->mime_subtype);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_register_type_handler
 * DESCRIPTION
 *  Register a type handler to DLAgent.
 * PARAMETERS
 *  mime_type       [IN] MIME type
 *  mime_subtype    [IN] MIME subtype
 *  presetting_hdlr [IN] Presetting handler
 *  setting_hdlr    [IN] Setting handler
 *  dispatch_hdlr   [IN] Dispatch handler
 * RETURNS
 *  Successfully registered
 *****************************************************************************/
MMI_BOOL srv_da_register_type_handler(
    applib_mime_type_enum mime_type,
    applib_mime_subtype_enum mime_subtype,
    srv_da_presetting_hdlr presetting_hdlr,
    srv_da_setting_hdlr setting_hdlr,
    srv_da_dispatch_hdlr dispatch_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_dynamic_reg_hdlr_element_struct *hdlr_ele;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_REGISTER_TYPE_HANDLER,
                mime_type, mime_subtype, presetting_hdlr, setting_hdlr, dispatch_hdlr);

    if (mime_subtype != 0 &&
        srv_da_search_mime_type_handler_by_subtype(mime_subtype) != srv_da_get_default_mime_type_handler())
    {
        hdlr_ele = (srv_da_dynamic_reg_hdlr_element_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_dynamic_reg_hdlr_element_struct));

        hdlr_ele->type_handler.mime_type = mime_type;
        hdlr_ele->type_handler.mime_subtype = mime_subtype;
        hdlr_ele->type_handler.get_presetting = presetting_hdlr;
        hdlr_ele->type_handler.setting_hdlr = setting_hdlr;
        hdlr_ele->type_handler.dispatch_hdlr = dispatch_hdlr;

        /* Add to list */
        hdlr_ele->next = g_srv_da_dynamic_reg_hdlr_tbl.head;
        g_srv_da_dynamic_reg_hdlr_tbl.head = hdlr_ele;
        g_srv_da_dynamic_reg_hdlr_tbl.size++;

        return MMI_TRUE;
    }
    
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_search_hook_handler
 * DESCRIPTION
 *  Get the hook handler from s_index.
 * PARAMETERS
 *  type        [IN]    The MIME type
 *  s_index     [IN]    Start index to search
 *  p_hdlr      [OUT]   Hook handler.
 * RETURNS
 *  Next index to search. If no hook handler is found, returns -1.
 *****************************************************************************/
S32 srv_da_search_hook_handler(
        const applib_mime_type_struct *type, 
        S32 s_index, 
        srv_da_hook_dispatch_hdlr *p_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (type != NULL)
    {
        while (s_index < srv_da_hook_hdlr_num)
        {
            if (srv_da_hook_hdlr_tbl[s_index].mime_subtype == type->mime_subtype)
            {
                *p_hdlr = srv_da_hook_hdlr_tbl[s_index].hook_hdlr;
                return s_index+1;
            }
            s_index++;
        }
    }

    *p_hdlr = NULL;
    
    return -1;
}


/*****************************************************************************
* FUNCTION
*  srv_da_search_mime_type_string
* DESCRIPTION
*  Search the mime type string in table by mime_subtype
* PARAMETERS
*  mime_subtype    IN  Which mime_subtype you want to search.
* RETURNS
*  The string id
*****************************************************************************/
UI_string_ID_type srv_da_search_mime_type_string(const applib_mime_type_struct * type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(type == NULL)
    {
        return STR_DA_UNKNOWN_FILE;
    }
    for (i = srv_da_mime_type_string_num - 1; i >= 0; i--)
    {
        if (type->mime_subtype == srv_da_mime_type_string_tbl[i].mime_subtype)
        {
            return srv_da_mime_type_string_tbl[i].string_id;
        }
    }

    switch (type->mime_type)
    {
        case MIME_TYPE_TEXT:
            return STR_DA_TEXT_FILE;
        case MIME_TYPE_IMAGE:
            return STR_DA_IMAGE_FILE;
        case MIME_TYPE_AUDIO:
            return STR_DA_AUDIO_FILE;
        case MIME_TYPE_VIDEO:
            return STR_DA_VIDEO_FILE;
        case MIME_TYPE_APPLICATION:
            return STR_DA_APP_FILE;
        case MIME_TYPE_MESSAGE:
            return STR_DA_MSG_FILE;
        case MIME_TYPE_MULTIPART:
            return STR_DA_MULTI_FILE;
        default:
            return STR_DA_UNKNOWN_FILE;
    }

   
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_setting_check
 * DESCRIPTION
 *  Check the validaity of setting
 * PARAMETERS
 *  setting     [IN]
 * RETURNS
 *  MMI_TRUE if pass
 *****************************************************************************/
MMI_BOOL srv_da_setting_check(const srv_da_setting_struct *setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (setting->storage)
    {
        case SRV_DA_STORAGE_USER_SELECT:
        case SRV_DA_STORAGE_AUTO:
        case SRV_DA_STORAGE_PUSH_TEMP:
            break;

        case SRV_DA_STORAGE_GIVEN:
        default:
            if (setting->drv == L'\0')
            {
                return MMI_FALSE;
            }
            break;
    }

    /* if ap use the default_filename, the length of filename must be zero */
    if (setting->default_filename == MMI_TRUE && setting->filename[0] != L'\0')
    {
        return MMI_FALSE;
    }


    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_dispatch_to_app
 * DESCRIPTION
 *  Dispatch a file to application registered.
 *  It will search the hook handler first. If no hook handler accepts
 *  the file, dispatch to type handler finally.
 * PARAMETERS
 *  session_id          [IN] Session ID which will be passed into hook/dispatch handler
 *  action              [IN] srv_da_action_enum
 *  filepath            [IN] Path of file to be dispatched
 *  url                 [IN] Source URI
 *  mime_type_string    [IN] MIME type string.
 *                           If NULL, the string will be extracted by using mime_type.
 *  type_hdlr           [IN] If no hook handler, dispatch to the dispatch_hdlr() in
 *                           this type handler. If NULL, try to find a proper type handler.
 * RETURNS
 *  MMI_TRUE if dispatched successfully; otherwise, returns MMI_FALSE
 *****************************************************************************/
MMI_BOOL srv_da_dispatch_to_app(
    S32 session_id, 
    const applib_mime_type_struct *mime_type,
    srv_da_action_enum action, 
    U16 *filepath,
    S8 *url,
    const S8 *mime_type_string,
    const srv_da_type_handler_struct *type_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_hook_dispatch_hdlr hook_hdlr;
    S32 hook_idx;
    S32 mime_type_enum_value, mime_subtype_enum_value;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (mime_type_string == NULL && mime_type != NULL)
    {
        mime_type_string = mime_type->mime_string;
    }

    mime_type_enum_value = (mime_type != NULL ? mime_type->mime_type : 0);
    mime_subtype_enum_value = (mime_type != NULL ? mime_type->mime_subtype : 0);

    /* Dispatch to hook handler first */
    hook_idx = 0;
    do
    {
        hook_idx = srv_da_search_hook_handler(mime_type, hook_idx, &hook_hdlr);

        if (hook_idx >= 0 && hook_hdlr != NULL)
        {        
            if (hook_hdlr(session_id,
                    mime_type_enum_value,
                    mime_subtype_enum_value,
                    action,
                    filepath,
                    url,
                    (S8*)mime_type_string))
            {
                MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_DISPATCH_TO_APP,
                    mime_type_enum_value, mime_subtype_enum_value, 'H', hook_idx);
                
                return MMI_TRUE;
            }
            else
            {
                /* To find next hook handler */
            }
        }
        else
        {
            /* No next */
            break;
        }
    } while (MMI_TRUE);

	if (action == MMI_DA_WAP_DOWNLOAD && mime_subtype_enum_value == MIME_SUBTYPE_MMS)
	{
		srv_da_receive_da_file(session_id,
					mime_type_enum_value,
					mime_subtype_enum_value,
					action,
					filepath,
					url,
					(S8*)mime_type_string);
	}
	else
	{
    /* Dispatch to type handler */
    if (type_hdlr == NULL)
    {
        type_hdlr = srv_da_search_mime_type_handler(mime_type);
    }

    if (type_hdlr != NULL && type_hdlr->dispatch_hdlr != NULL)
    {
        type_hdlr->dispatch_hdlr(
            session_id,
            mime_type_enum_value,
            mime_subtype_enum_value,
            action,
            filepath,
            url,
            (S8*)mime_type_string);

        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_DISPATCH_TO_APP,
            mime_type_enum_value, mime_subtype_enum_value, 'D', -1);

        return MMI_TRUE;
    }
	}

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_DISPATCH_TO_APP,
        mime_type_enum_value, mime_subtype_enum_value, 'N', -1);

    return MMI_FALSE;
}



/*************************************************************************
* FUNCTION
*   srv_da_receive_da_file
* DESCRIPTION
*   Start to handle file
* PARAMETERS
*   mime_type   [IN]    the mime type of file
*   mime_subtype[IN]    the sub mime type of file
*   action_type [IN]    defined in Download agent
*   filename    [IN]    the filepath of file
*   download_url[IN]    the source of file, normally is a link
*   mime_type_string    [IN]    the originaly mime type string get from server
* RETURNS
*   void
*************************************************************************/
void srv_da_receive_unsupported_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string)
{
    srv_da_adp_popup (SRV_DA_GLOBAL_NOT_SUPPORTED, 0, SRV_DA_POPUP_TYPE_ERROR);
}


/*************************************************************************
* FUNCTION
*   srv_da_receive_da_file
* DESCRIPTION
*   Start to handle file
* PARAMETERS
*   mime_type   [IN]    the mime type of file
*   mime_subtype[IN]    the sub mime type of file
*   action_type [IN]    defined in Download agent
*   filename    [IN]    the filepath of file
*   download_url[IN]    the source of file, normally is a link
*   mime_type_string    [IN]    the originaly mime type string get from server
* RETURNS
*   void
*************************************************************************/
void srv_da_receive_da_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string)
{
    
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef __MMI_ULTRA_SLIM_FILE_MANAGER__
	mmi_fmgr_receive_da_file(session_id, mime_type, mime_subtype, action_type, filename, download_url, mime_type_string);
#endif
#else
    S32 file_type = -1;
    S32 menu_opt = -1;
    file_type = srv_fmgr_types_find_type_by_filepath (filename);
    if (file_type > 0)
    {
        //menu_opt = srv_fmgr_types_get_use_option_menu(file_type, (const WCHAR*) filename);
        menu_opt = srv_fmgr_types_get_option_menu((filetypes_file_type_enum)file_type, NULL, 0);
        if (menu_opt > 0)
        {
            S32 child_id = GetSeqItemId(menu_opt, 0);
            if (0 > srv_fmgr_types_launch_option ((const WCHAR*) filename, child_id))
            {
                goto ERROR;
            }
        }
        else
        {
            goto ERROR;
        }
    }
    else
    {
        goto ERROR;
    }

    return;
ERROR:
    srv_da_adp_popup (SRV_DA_GLOBAL_UNSUPPORTED_FORMAT, 0, SRV_DA_POPUP_TYPE_ERROR);
#endif
}
    
/*************************************************************************
* FUNCTION
*   srv_da_handle_mms_file
* DESCRIPTION
*   Delete unhandled mms file
* PARAMETERS
*   mime_type   [IN]    the mime type of file
*   mime_subtype[IN]    the sub mime type of file
*   action_type [IN]    defined in Download agent
*   filename    [IN]    the filepath of file
*   download_url[IN]    the source of file, normally is a link
*   mime_type_string    [IN]    the originaly mime type string get from server
* RETURNS
*   void
*************************************************************************/
#ifndef __MMI_MMS_MMA_MMS_OBJECT_IND__
void srv_da_handle_mms_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string)
{
	FS_HANDLE file_handle;
    S8 temp_filename[100];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(temp_filename, 0, sizeof(temp_filename));
    mmi_ucs2_n_to_asc(temp_filename, (S8*) filename, 99);

    file_handle = FS_Open((const WCHAR*)filename, FS_READ_ONLY);

    if (file_handle < FS_NO_ERROR)
    {
        return;
    }

    ASSERT(FS_Close(file_handle) == FS_NO_ERROR);
    FS_Delete((const WCHAR*)filename);

}
#endif
    
#endif
