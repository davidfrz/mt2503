/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  ImageViewerEXApp.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  Image Viewer EX.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"

#ifdef __MMI_IMAGE_VIEWER_EX__

#include "GlobalConstants.h"
#include "stack_config.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "kal_trace.h"
#include "fs_errcode.h"
#include "fs_type.h"
#include "fs_func.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gdi_lcd_config.h"
#include "gdi_include.h"
#include "gdi_image_gif.h"
#include "gui_typedef.h"
#include "gui_data_types.h"
#include "gui.h"
#include "gui_inputs.h"
#include "gui_touch_feedback.h"
#include "wgui_touch_screen.h"
#include "wgui_inputs.h"
#include "wgui_categories_util.h"
#include "wgui_categories_text_viewer.h"
#include "wgui_categories_inputs.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_frm_input_gprot.h"
#include "mmi_frm_nvram_gprot.h"
#include "nvram_common_defs.h"

#include "FileMgrSrvGProt.h"
#include "lcd_sw_inc.h"
#include "MMIDataType.h"
#include "InlineCuiGprot.h"
#include "GlobalResDef.h"
#include "ImageViewerEXAppGprot.h"
#include "mmi_rp_srv_filemanager_def.h"
#include "CustDataRes.h"
#include "MMI_media_app_trc.h"
#include "DebugInitDef_Int.h"
#include "mmi_media_app_trc.h"
#include "ImageViewCuiGprot.h"
#include "lcd_sw_rnd.h"
#include "MediaCacheSrvMem.h"
#include "string.h"
#include "med_smalloc.h"
#include "app_ltlcom.h"
#include "Unicodexdcl.h"
#include "lcd_if.h"
#include "FileMgrCuiGProt.h"
#include "CustMenuRes.h"
#include "GlobalMenuItems.h"
#include "mmi_rp_app_filemanager_def.h"
#include "mmi_rp_file_type_def.h"
#include "AlertScreen.h"
#include "FileMgrType.h"
#include "FileMgrGProt.h"
#include "GpioSrvGprot.h"
#include "stdlib.h"
#include "stdio.h"
#include "drm_def.h"

#include "Drm_gprot.h"         /* DRM support */
#include "RightsMgrGProt.h"    /* MMI_RMGR_STATUS_NO_PERMISSION define */
#include "math.h"
//#include "SimDetectionGprot.h" /* for mmi_bootup_get_active_flight_mode */
#include "NwUsabSrvGprot.h"
#include "ModeSwitchSrvGProt.h"
#include "PhotoEditorGProt.h"

#include "App_mem.h"
#include "FileMgrServiceResDef.h"
#include "med_api.h"
#include "Gui_font_size.h"
#include "stack_msgs.h"

#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
#include "ScrLockerGprot.h"
#endif

#ifdef __MMI_RMGR__
#include "RightsMgrGprot.h"
#endif

#ifdef __MMI_BT_SUPPORT__
#include "BTMMIScrGprots.h"
#endif


#ifdef MOTION_SENSOR_SUPPORT
//#include "mdi_motion.h"
#include "SensorSrvGport.h"
#endif

#if defined(__MMI_SCREEN_SWITCH_EFFECT__)
#include "gui_effect_oem.h"
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

#ifdef __MMI_VUI_MEDIAWALL__
#include "MediaWall\vadp_mediawall.h"
#endif

#ifdef __MMI_PHOTOEDITOR__
#include "photoeditorcuigprot.h"
#endif

#include "AMGprot.h"

#include "MediaCacheSrvGprot.h"
#include "ImageViewerGprot.h"
#include "mmi_rp_app_imageviewer_def.h"
#include "menucuigprot.h"
#include "ImageViewerEXApp.h"
#include "ImageViewerEXSkin.h"
/* For imgview CUI */
#include "ImageViewCui.h"
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
#include "ImageViewerExSlidingBar.h"
#endif

extern void *mmi_imgview_asm_alloc_debug(mmi_id app_id, U32 size);
extern void mmi_imgview_asm_free_debug(mmi_id id, void *ptr);

#if (defined(__MTK_TARGET__) && defined(__DYNAMIC_SWITCH_CACHEABILITY__))
   #include "mmu.h"
   #include "cache_sw.h"
#endif

#include "ImageViewerSap.h"
#include "mmi_rp_srv_filemanager_def.h"

#undef IVAPP_DEBUG

#ifdef IVAPP_DEBUG
kal_uint32 d_time;

#define TMP_TRACE(fmt) kal_prompt_trace(MOD_MMI, fmt) 
#define TMP_TRACE1(fmt, arg1) kal_prompt_trace(MOD_MMI, fmt, arg1)
#define TMP_TRACE2(fmt, arg1, arg2) kal_prompt_trace(MOD_MMI, fmt, arg1, arg2)
#define TMP_TRACE3(fmt, arg1, arg2, arg3) kal_prompt_trace(MOD_MMI, fmt, arg1, arg2, arg3)
#define TMP_TRACE_TIME(fmt) \
    do{ \
        kal_get_time(&d_time); \
        TMP_TRACE1(fmt, kal_ticks_to_milli_secs(d_time)); \
    }while(0);

#else
#define TMP_TRACE(fmt)
#define TMP_TRACE1(fmt, arg1)
#define TMP_TRACE2(fmt, arg1, arg2)
#define TMP_TRACE3(fmt, arg1, arg2, arg3)
#define TMP_TRACE_TIME(fmt)
#endif

#define GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(x1, y1, x2, y2)    \
    do{ \
    TMP_TRACE1("[IVAPP][YWY]mmi_ivex_layer_nb_concurrentcy_blt------begin, line=%d", __LINE__);  \
    gdi_layer_blt_previous_nb_concurrent(x1, y1, x2, y2); \
    TMP_TRACE1("[IVAPP][YWY]mmi_ivex_layer_nb_concurrentcy_blt------end, line=%d", __LINE__); \
    }while(0);


extern void srv_mediacache_util_fix_box(
        S32 bbox_width,
        S32 bbox_height,
        S32 src_width,
        S32 src_height,
        S32 *offset_x,
        S32 *offset_y,
        S32 *dest_width,
        S32 *dest_height,
        U16 image_type);



#if defined(__MMI_FTE_SUPPORT__)

/* forground of up is same as down */
#define IMG_ID_IVEX_ZOOMIN_DOWN_P    IMG_ID_IVEX_ZOOMIN_UP_P  
#define IMG_ID_IVEX_ZOOMOUT_DOWN_P   IMG_ID_IVEX_ZOOMOUT_UP_P
#define IMG_ID_IVEX_CWR_DOWN_P       IMG_ID_IVEX_CWR_UP_P    
#define IMG_ID_IVEX_CCWR_DOWN_P      IMG_ID_IVEX_CCWR_UP_P   

#define IMG_ID_IVEX_ZOOMIN_DOWN_H    IMG_ID_IVEX_ZOOMIN_UP_H 
#define IMG_ID_IVEX_ZOOMOUT_DOWN_H   IMG_ID_IVEX_ZOOMOUT_UP_H
#define IMG_ID_IVEX_CWR_DOWN_H       IMG_ID_IVEX_CWR_UP_H    
#define IMG_ID_IVEX_CCWR_DOWN_H      IMG_ID_IVEX_CCWR_UP_H      

/* landscape icon is same as portrait */
#define IMG_ID_IVEX_LSK_UP_H         IMG_ID_IVEX_LSK_UP_P     
#define IMG_ID_IVEX_RSK_UP_H         IMG_ID_IVEX_RSK_UP_P     
#define IMG_ID_IVEX_CSK_PLAY_UP_H    IMG_ID_IVEX_CSK_PLAY_UP_P
#define IMG_ID_IVEX_CSK_STOP_UP_H    IMG_ID_IVEX_CSK_STOP_UP_P

#define IMG_ID_IVEX_LSK_DOWN_H       IMG_ID_IVEX_LSK_DOWN_P     
#define IMG_ID_IVEX_RSK_DOWN_H       IMG_ID_IVEX_RSK_DOWN_P     
#define IMG_ID_IVEX_CSK_PLAY_DOWN_H  IMG_ID_IVEX_CSK_PLAY_DOWN_P
#define IMG_ID_IVEX_CSK_STOP_DOWN_H  IMG_ID_IVEX_CSK_STOP_DOWN_P

#ifdef __MMI_IMGVIEWEX_TOUCH__

#define  IMG_ID_IVEX_ZOOMIN_UP_H           IMG_ID_IVEX_ZOOMIN_UP_P       
#define  IMG_ID_IVEX_ZOOMOUT_UP_H          IMG_ID_IVEX_ZOOMOUT_UP_P      
#define  IMG_ID_IVEX_CWR_UP_H              IMG_ID_IVEX_CWR_UP_P          
#define  IMG_ID_IVEX_CCWR_UP_H             IMG_ID_IVEX_CCWR_UP_P         
#define  IMG_ID_IVEX_ZOOMIN_DISABLE_H      IMG_ID_IVEX_ZOOMIN_DISABLE_P  
#define  IMG_ID_IVEX_ZOOMOUT_DISABLE_H     IMG_ID_IVEX_ZOOMOUT_DISABLE_P 
#define  IMG_ID_IVEX_CWR_DISABLE_H         IMG_ID_IVEX_CWR_DISABLE_P     
#define  IMG_ID_IVEX_CCWR_DISABLE_H        IMG_ID_IVEX_CCWR_DISABLE_P 
#endif

#endif /*__MMI_FTE_SUPPORT_SLIM__*/

typedef enum{
    IVEX_IMG_QTY_LOW,
    IVEX_IMG_QTY_MEDIAM,
    IVEX_IMG_QTY_HIGH
}ivex_img_quality_enum;

#define IVEX_IMG_QTY_DEFAULT    IVEX_IMG_QTY_LOW
#define IVEX_IMG_QTY_ZOOM        IVEX_IMG_QTY_LOW

static S32 mmi_ivex_get_curr_img(ivex_img_quality_enum img_qty);
static void mmi_ivex_get_moved_image(ivex_img_quality_enum img_qty);


/***************************************************************************** 
* Local Variable
*****************************************************************************/
#define MMI_IVEX_LANDSCAPE  ((LCD_WIDTH == 320) && (LCD_HEIGHT == 240))

/*****************************************************************************
* Global Variable
*****************************************************************************/
ivex_context_struct g_ivex_cntx;

static const S32 mmi_ivex_keyframe_ease_out[] = {0, 25, 46, 63, 76, 86, 92, 95, 97, 99, 100};

ivex_osd_icon_struct lock_drm_hint[2];
ivex_osd_icon_struct lock_error_hint[2];
ivex_osd_icon_struct lock_loading_hint[2];
CHAR g_curr_file_limit_error[LIMIT_ERROR_BUF_SIZE];
CHAR g_swit_file_limit_error[LIMIT_ERROR_BUF_SIZE];

///***************Inline************/////
#define IVEX_SETTINGS_INLINE_ITEMS_COUNT    (2)
static const cui_inline_item_caption_struct g_ivex_settings_speed_caption =
{
    STR_ID_IMGVIEW_PLAY_SPEED
};
static const U16 g_ivex_play_speed_str[] =
{
    STR_GLOBAL_SLOW,
    STR_GLOBAL_MEDIUM,
    STR_GLOBAL_FAST
};
static const cui_inline_item_select_struct g_ivex_play_speed_select =
{
    3, 0, (U16*)g_ivex_play_speed_str
};
static const cui_inline_set_item_struct g_ivex_settings_items[IVEX_SETTINGS_INLINE_ITEMS_COUNT] =
{
    {MMI_IVEX_SETTINGS_SPEED_CAP,        CUI_INLINE_ITEM_TYPE_CAPTION,                                       IMG_GLOBAL_L1,    (void*)&g_ivex_settings_speed_caption},
    {MMI_IVEX_SETTINGS_SPEED,            CUI_INLINE_ITEM_TYPE_SELECT | CUI_INLINE_ITEM_CENTER_JUSTIFY,       0,                (void*)&g_ivex_play_speed_select},
};static const cui_inline_struct g_ivex_settings_inline_struct =
{
    IVEX_SETTINGS_INLINE_ITEMS_COUNT,
    STR_GLOBAL_SETTINGS,
    0,
    CUI_INLINE_SCREEN_DISABLE_DONE,
    NULL,
    g_ivex_settings_items
};
///***************Inline************/////

/* CUI related variables */
mmi_id g_ivex_cui_gid;
extern cui_imgview_context_struct *g_imgview_cui_ptr;

/********************** Animation Support Zoom ***************/

#ifdef __OP01__
#define __IVEX_SUPPOERT_ANIM_ZOOM__
#endif

#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
typedef struct{
    S32 is_cache_ok; /* if cache in temp layer is OK*/
    S32 cache_width;
    S32 cache_height;
    
}ivex_anim_context;

static ivex_anim_context g_anim_context;
#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/

//#define DEBUGE_IVEX_UI_ROTATE

/*****************************************************************************
* Local Function
*****************************************************************************/
extern void srv_mediacache_retry_decode_curr(srv_handle handle);
extern srv_mediacache_err_enum srv_mediacache_get_last_source(srv_handle handle);
extern void mmi_imgview_show_img_info(const WCHAR* filepath, MMI_ID parent_gid);
extern void srv_mediacache_calc_h_w_by_image_and_length(S32 index, U32 buf_length, S32 *width, S32 *height);

static void mmi_ivex_key_down_hdlr(U16 Keycode);
static void mmi_ivex_key_repeat_hdlr(U16 Keycode);
static void mmi_ivex_key_up_hdlr(U16 Keycode);
static MMI_BOOL mmi_ivex_check_arrow_key(U16 Keycode);
static void mmi_ivex_inactive_cache_service(void);
static void mmi_ivex_deinit_cache_service(void);
static void mmi_ivex_entry_screen_bh(void);

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
MMI_BOOL current_image_is_mav(void);
static void mmi_ivex_draw_mav_file(ivex_image_info_struct* img_info);
static void mmi_ivex_stop_mav_if_need(ivex_image_info_struct* img_info, gdi_handle layer_handle);
static void mmi_ivex_shortcut_mav_prev_frame_press(void);
static void mmi_ivex_shortcut_mav_next_frame_press(void);
static void mmi_ivex_shortcut_mav_prev_frame_repeat(void);
static void mmi_ivex_shortcut_mav_next_frame_repeat(void);
static void mmi_ivex_shortcut_mav_prev_frame_release(void);
static void mmi_ivex_shortcut_mav_next_frame_release(void);
static void mmi_ivex_sliding_bar_progess_observer(SlidingBar *sb, void *userdata);
static void mmi_ivex_shortcut_mav_prev_frame_press_int(void);
static void mmi_ivex_shortcut_mav_next_frame_press_int(void);
static void mmi_ivex_draw_osd_sliding_bar_layer(void);
static void mmi_ivex_mav_draw_callback(GDI_RESULT result, gdi_handle handle);
static MMI_BOOL mmi_ivex_should_show_sliding_bar(void);
static void mmi_ivex_sliding_bar_convert_touch_coordinate(mmi_pen_point_struct *pos);

#ifdef __MMI_IMGVIEWEX_MAV_MOTION__
static void mmi_ivex_mav_motion_pulse(void);
static void mmi_ivex_mav_motion_start_pulse(void);
static void mmi_ivex_mav_motion_stop_pulse(void);
static void mmi_ivex_mav_image_tilt_callback(
        srv_sensor_type_enum sensor_type,
        void *sensor_data,
        void *user_data);
void mmi_ivex_mav_cancel_motion_handling(void);
static void mmi_ivex_mav_start_listen_motion(void);
static void mmi_ivex_mav_stop_listen_motion(void);
#endif /* __MMI_IMGVIEWEX_MAV_MOTION__ */
#endif /* __MULTIPLE_ANGLE_VIEW_SUPPORT__ */



#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
/*****************************************************************************
 * FUNCTION
 *  cui_ivex_screen_locker_event_handler
 * DESCRIPTION
 *
 * PARAMETERS
 *  pcui        [?]
 * RETURNS
 *
 *****************************************************************************/
static mmi_ret mmi_ivex_screen_locker_event_handler (mmi_event_struct *evt)
{
    if (evt->evt_id == EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING) {
        mmi_scr_locker_pre_lock_evt_struct *lock_event = (mmi_scr_locker_pre_lock_evt_struct *) evt;
        if (lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_POWER_KEY)
        {
            return MMI_RET_OK;
        }
        else if (lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_AUTO_LOCK)
        {
            if (MMI_IVEX_IMAGE_STATE_PLAY == g_ivex_cntx.image_state)
                return MMI_RET_ERR;
            else
                return MMI_RET_OK;
        }
        else
        {
            return MMI_RET_OK;
        }
    }
    else {
        return MMI_RET_ERR;
    }
}
#endif

#define MMI_IVEX_MEMORY_MGR

static U16 mmi_ivex_get_storage(void)
{
    return g_imgview_cui_ptr->storage;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_is_direct_exit_state
 * DESCRIPTION
 *  fade imgadv osd
 * PARAMETERS
 *  sleep       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_ivex_is_direct_exit_state(ivex_direct_exit_enum org_type, ivex_direct_exit_enum new_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (org_type & new_type)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_add_direct_exit_state
 * DESCRIPTION
 *  fade imgadv osd
 * PARAMETERS
 *  sleep       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_add_direct_exit_state(ivex_direct_exit_enum *org_type, ivex_direct_exit_enum new_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *org_type |= new_type;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_remove_direct_exit_state
 * DESCRIPTION
 *  fade imgadv osd
 * PARAMETERS
 *  sleep       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_remove_direct_exit_state(ivex_direct_exit_enum *org_type, ivex_direct_exit_enum new_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *org_type &= ~new_type;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_post_close_cui
 * DESCRIPTION
 *  Close view cui group, this use send will close right now
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_close_group(mmi_id *media_viewer_id, U16 evt_id, MMI_BOOL is_send, MMI_BOOL need_reset)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_group_event_struct evt;
    mmi_group_node_struct group_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MEDIAVIEW_IVEX_CUI_CLOSE_BLOCK, *media_viewer_id;
    mmi_frm_group_get_info(*media_viewer_id, &group_info);

    if(group_info.state == MMI_SCENARIO_STATE_CREATE)
    {
        mmi_frm_group_close(*media_viewer_id);
    }
    else
    {
        evt.evt_id = evt_id;
        evt.sender_id = *media_viewer_id;
        evt.size = sizeof(mmi_group_event_struct);
        if (is_send)
        {
            mmi_frm_group_send_to_parent(*media_viewer_id, &evt);
        }
        else
        {
            mmi_frm_group_post_to_parent(*media_viewer_id, &evt);
        }
    }
    if (need_reset)
    {
        *media_viewer_id = GRP_ID_INVALID;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_view_avaliable_and_process
 * DESCRIPTION
 *  init function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_view_avaliable_and_process(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL view_ava = MMI_TRUE;
    MMI_BOOL is_exist = MMI_TRUE;
    FS_HANDLE file_handle = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_ivex_cntx.view_from_fmgr)
    {
        if ((srv_fmgr_filelist_count(g_imgview_fl_hdl)) <= 0)
        {
            mmi_ivex_display_error_sg(
                g_ivex_cui_gid,
                (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
                MMI_EVENT_FAILURE,
                (U16)g_ivex_cntx.ui_display_rotate,
                MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);

            mmi_mediaview_free_filelist();
            view_ava = MMI_FALSE;
        }
    }
    else
    {
        /* from fmgr, will prompt file not found for plug out card and delete it use tools */
        is_exist = mmi_ivex_is_file_exist(g_ivex_cntx.image_info.filepath, &file_handle);
        if (!is_exist)
        {
            if (file_handle == FS_FILE_NOT_FOUND ||
                file_handle == FS_DRIVE_NOT_FOUND)
            {
                mmi_ivex_display_error_sg(
                    g_ivex_cui_gid,
                    (UI_string_type)GetString(srv_fmgr_fs_error_get_string(file_handle)),
                    (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(file_handle),
                    (U16)g_ivex_cntx.ui_display_rotate,
                    MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);

                view_ava = MMI_FALSE;
            }
        }
    }
    return view_ava;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_app
 * DESCRIPTION
 *  init function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_init_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_util_read_settings_data();
    applib_mem_ap_register(
        APPLIB_MEM_AP_ID_IVEX,
        STR_ID_IMGVIEW_NAME,
        IMG_ID_IMGVIEW_MAIN_ICON,
        mmi_ivex_asm_stop_cb);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_adm_close_view_cui
 * DESCRIPTION
 *  Close view cui group, this use send will close right now
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_adm_close_view_cui(mmi_id *media_viewer_id, U16 evt_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_group_event_struct evt;
    mmi_group_node_struct group_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MEDIAVIEW_IVEX_CUI_CLOSE_BLOCK, *media_viewer_id;
    if(*media_viewer_id == GRP_ID_INVALID)
        return;

    mmi_frm_group_get_info(*media_viewer_id, &group_info);

    if(group_info.state == MMI_SCENARIO_STATE_CREATE)
    {
        mmi_frm_group_close(*media_viewer_id);
    }
    else
    {
        evt.evt_id = evt_id;
        evt.sender_id = *media_viewer_id;
        evt.size = sizeof(mmi_group_event_struct);
        mmi_frm_group_send_to_parent(*media_viewer_id, &evt);
    }
    *media_viewer_id = GRP_ID_INVALID;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_asm_stop_cb
 * DESCRIPTION
 *  asm stop function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_asm_stop_cb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ASM_STOP_CB);
    /* Exit view screen */

#ifdef __MMI_VUI_MEDIAWALL__
    if (mmi_mediaview_vapp_mediawall_is_caller())
    {
        mmi_ivex_adm_close_view_cui(&g_mediaview_cui_gid, EVT_ID_MEDIAVIEW_CLOSE_GID);
    }
#endif
    mmi_ivex_adm_close_view_cui(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID);
//    applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_IVEX, KAL_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_asm_request_cancel_callback
 * DESCRIPTION
 *  asm cancel function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_asm_request_cancel_callback(mmi_frm_appmem_evt_struct *cancel_event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.filepath != NULL && g_ivex_cntx.view_from_fmgr)
    {
        gui_free(g_ivex_cntx.image_info.filepath);
        g_ivex_cntx.image_info.filepath = NULL;
    }
    if (!g_ivex_cntx.view_from_fmgr)
    {
        mmi_mediaview_free_filelist();
    }

    if (g_ivex_cui_gid != GRP_ID_INVALID)
    {
        mmi_ivex_close_group(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID, MMI_FALSE, MMI_FALSE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_create_app_based_memory_adm
 * DESCRIPTION
 *  allocate app based memory and create adm id
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_create_app_based_memory_adm(U32 min_size, U32 max_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CREATE_ADM);
    MMI_ASSERT(g_ivex_cntx.app_mem_pool == NULL);
    if (g_ivex_cntx.app_mem_pool == NULL)
    {
        g_ivex_cntx.app_mem_pool = mmi_imgview_asm_alloc_debug(g_imgview_cui_ptr->imgview_cui_gid, min_size);
    }

    if (g_ivex_cntx.app_mem_pool == NULL)
        return MMI_FALSE;
    else {
        g_ivex_cntx.app_mem_size = min_size;
        g_ivex_cntx.app_adm_id = kal_adm_create(g_ivex_cntx.app_mem_pool, g_ivex_cntx.app_mem_size, NULL, KAL_TRUE);
        MMI_ASSERT(g_ivex_cntx.app_adm_id != NULL);
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_destroy_app_based_memory_adm
 * DESCRIPTION
 *  free all app based memory of ivex view screen used
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_destroy_app_based_memory_adm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* delete adm */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DESTROY_ADM);
    MMI_ASSERT(g_ivex_cntx.app_adm_id != NULL);
    if (g_ivex_cntx.app_adm_id != NULL)
    {
        kal_adm_delete(g_ivex_cntx.app_adm_id);
        g_ivex_cntx.app_adm_id = NULL;
    }

    /* free asm */
    MMI_ASSERT(g_ivex_cntx.app_mem_pool != NULL);
    if (g_ivex_cntx.app_mem_pool != NULL)
    {
        mmi_imgview_asm_free_debug(g_imgview_cui_ptr->imgview_cui_gid, g_ivex_cntx.app_mem_pool);
        g_ivex_cntx.app_mem_pool = NULL;
        g_ivex_cntx.app_mem_size = 0;
        applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_IVEX, KAL_TRUE);
    }
}


#ifdef __MMI_VUI_MEDIAWALL__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_create_adm
 * DESCRIPTION
 *  allocate app based memory and create adm id
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_create_adm(U32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CREATE_ADM);
    MMI_ASSERT(g_ivex_cntx.app_mem_pool == NULL);
    g_ivex_cntx.app_mem_size = size;
    if (g_ivex_cntx.app_mem_pool == NULL)
    {
        g_ivex_cntx.app_mem_pool = mmi_mediaview_get_app_based_memory_from_vapp_mediawall(&g_ivex_cntx.app_mem_size);
    }

    if (g_ivex_cntx.app_mem_pool != NULL)
    {
       g_ivex_cntx.app_adm_id = kal_adm_create(g_ivex_cntx.app_mem_pool, g_ivex_cntx.app_mem_size, NULL, KAL_TRUE);
       MMI_ASSERT(g_ivex_cntx.app_adm_id != NULL);
    }
    else
    {
        MMI_ASSERT(0);
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_destory_adm
 * DESCRIPTION
 *  allocate app based memory and create adm id
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_destory_adm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DESTROY_ADM);
    mmi_ivex_remove_app_mem_cache_and_adm_mem();

    MMI_ASSERT(g_ivex_cntx.app_adm_id != NULL);
    if (g_ivex_cntx.app_adm_id != NULL)
    {
        kal_adm_delete(g_ivex_cntx.app_adm_id);
        g_ivex_cntx.app_adm_id = NULL;
    }

    /* free asm */
    MMI_ASSERT(g_ivex_cntx.app_mem_pool != NULL);
    if (g_ivex_cntx.app_mem_pool != NULL)
    {
        if (!(mmi_frm_group_is_present(g_mediaview_cui_gid) &&
            mmi_mediaview_vapp_mediawall_is_caller()))
        {
            mmi_imgview_asm_free_debug(g_imgview_cui_ptr->imgview_cui_gid, g_ivex_cntx.app_mem_pool);
            applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_IVEX, KAL_TRUE);
        }
        g_ivex_cntx.app_mem_pool = NULL;
        g_ivex_cntx.app_mem_size = 0;
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_memory_struct_varialbe
 * DESCRIPTION
 *  initialize the context memory struct member
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_init_memory_struct_varialbe(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++){
        memset((void*)&g_ivex_cntx.mem_cache[i], 0, sizeof(ivex_memory_struct));
    }
    memset((void*)&g_ivex_cntx.mem_osd_title, 0, sizeof(ivex_memory_struct));
    memset((void*)&g_ivex_cntx.mem_osd_panel, 0, sizeof(ivex_memory_struct));
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    memset((void*)&g_ivex_cntx.mem_osd_sliding_bar, 0, sizeof(ivex_memory_struct));
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_util_malloc_osd_mem
 * DESCRIPTION
 *  This function will malloc memory for osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_util_malloc_osd_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int buffer_size;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* ivexapp using memory from screen based asm, current the osd use ARGB8888 */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_MALLOC_SCR_OSD);
    buffer_size = MMI_IVEX_OSD_TITLE_SIZE + MMI_IVEX_OSD_PANEL_SIZE;
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    buffer_size += MMI_IVEX_OSD_SLIDING_BAR_SIZE;
#endif
    g_ivex_cntx.mem_osd_title.buffer = mmi_imgview_asm_alloc_debug(g_imgview_cui_ptr->imgview_cui_gid, buffer_size);
    MMI_ASSERT(g_ivex_cntx.mem_osd_title.buffer != NULL);
    g_ivex_cntx.mem_osd_title.size = MMI_IVEX_OSD_TITLE_SIZE;
    g_ivex_cntx.mem_osd_title.type = MMI_IVEX_MEMORY_TYPE_SCREEN_BASED;
    
    g_ivex_cntx.mem_osd_panel.buffer = (PU8)g_ivex_cntx.mem_osd_title.buffer + MMI_IVEX_OSD_TITLE_SIZE;
    g_ivex_cntx.mem_osd_panel.size = MMI_IVEX_OSD_PANEL_SIZE;
    g_ivex_cntx.mem_osd_panel.type = MMI_IVEX_MEMORY_TYPE_SCREEN_BASED;

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    g_ivex_cntx.mem_osd_sliding_bar.buffer = (PU8)g_ivex_cntx.mem_osd_panel.buffer + MMI_IVEX_OSD_PANEL_SIZE;
    g_ivex_cntx.mem_osd_sliding_bar.size = MMI_IVEX_OSD_SLIDING_BAR_SIZE;
    g_ivex_cntx.mem_osd_sliding_bar.type = MMI_IVEX_MEMORY_TYPE_SCREEN_BASED;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_util_free_osd_mem
 * DESCRIPTION
 *  This function will free memory for osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_util_free_osd_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* ivexapp using memory from screen based asm, current the osd use ARGB8888 */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_FREE_SCR_OSD);
    MMI_ASSERT(g_ivex_cntx.mem_osd_title.buffer != NULL);
    mmi_imgview_asm_free_debug(g_imgview_cui_ptr->imgview_cui_gid, g_ivex_cntx.mem_osd_title.buffer);
    g_ivex_cntx.mem_osd_title.buffer = NULL;
    g_ivex_cntx.mem_osd_title.size = 0;
    g_ivex_cntx.mem_osd_title.type = MMI_IVEX_MEMORY_TYPE_NONE;
    
    MMI_ASSERT(g_ivex_cntx.mem_osd_panel.buffer != NULL);
    g_ivex_cntx.mem_osd_panel.buffer = NULL;
    g_ivex_cntx.mem_osd_panel.size = 0;
    g_ivex_cntx.mem_osd_panel.type = MMI_IVEX_MEMORY_TYPE_NONE;

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    MMI_ASSERT(g_ivex_cntx.mem_osd_sliding_bar.buffer != NULL);
    g_ivex_cntx.mem_osd_sliding_bar.buffer = NULL;
    g_ivex_cntx.mem_osd_sliding_bar.size = 0;
    g_ivex_cntx.mem_osd_sliding_bar.type = MMI_IVEX_MEMORY_TYPE_NONE;
#endif
}

#define MMI_IVEX_LAYER_MGR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_layer_set_position
 * DESCRIPTION
 *  This function is called to set specified layer position.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_layer_set_position(gdi_handle layer_handler, ivex_osd_layer_struct *positon)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_set_position_nb_concurrent(layer_handler, positon->offset_x, positon->offset_y);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_layer_set_blt_layer
 * DESCRIPTION
 *  This function is called to rotate layer for display.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_layer_set_blt_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set blt layers */
    MMI_ASSERT(g_ivex_cntx.display_layer_handle != GDI_LAYER_EMPTY_HANDLE);
    MMI_ASSERT(g_ivex_cntx.switch_layer_handle != GDI_LAYER_EMPTY_HANDLE);
    MMI_ASSERT(g_ivex_cntx.osd_title_layer != GDI_LAYER_EMPTY_HANDLE);
    MMI_ASSERT(g_ivex_cntx.osd_panel_layer!= GDI_LAYER_EMPTY_HANDLE);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    MMI_ASSERT(g_ivex_cntx.osd_sliding_bar.panel_layer!= GDI_LAYER_EMPTY_HANDLE);
#endif

    /* this will set black cavins ouside layer */
    gdi_layer_set_background_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (g_ivex_cntx.image_info.is_mav) {
        if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_HIDE)
        {
            switch (g_ivex_cntx.image_state)
            {
                case MMI_IVEX_IMAGE_STATE_STILL:
                case MMI_IVEX_IMAGE_STATE_STILL_H2P:
                case MMI_IVEX_IMAGE_STATE_STILL_P2H:
                    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90) {
                        gdi_layer_set_blt_layer_nb_concurrent(
                            g_ivex_cntx.display_layer_handle,
                            g_ivex_cntx.osd_panel_layer,
                            g_ivex_cntx.osd_sliding_bar.panel_layer, 0);
                    }
                    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0) {
                        gdi_layer_set_blt_layer_nb_concurrent(
                            g_ivex_cntx.display_layer_handle,
                            g_ivex_cntx.osd_panel_layer,
                            g_ivex_cntx.osd_title_layer, 0);
                    }
                    else {
                        MMI_ASSERT(0);
                    }
                    break;
                case MMI_IVEX_IMAGE_STATE_SWITCH_NEXT:
                case MMI_IVEX_IMAGE_STATE_SWITCH_PREV:
                case MMI_IVEX_IMAGE_STATE_PLAY:
                    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90) {
                        gdi_layer_set_blt_layer_nb_concurrent(
                            g_ivex_cntx.display_layer_handle,
                            g_ivex_cntx.switch_layer_handle,
                            g_ivex_cntx.osd_panel_layer,
                            g_ivex_cntx.osd_sliding_bar.panel_layer);
                    }
                    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0) {
                        gdi_layer_set_blt_layer_nb_concurrent(
                            g_ivex_cntx.display_layer_handle,
                            g_ivex_cntx.switch_layer_handle,
                            g_ivex_cntx.osd_panel_layer,
                            g_ivex_cntx.osd_title_layer);
                    }
                    else {
                        MMI_ASSERT(0);
                    }
                    break;
                default:
                    break;
            }
        }
        else
        {
            switch (g_ivex_cntx.image_state)
            {
                case MMI_IVEX_IMAGE_STATE_STILL:
                case MMI_IVEX_IMAGE_STATE_STILL_H2P:
                case MMI_IVEX_IMAGE_STATE_STILL_P2H:
                    gdi_layer_set_blt_layer_nb_concurrent(
                        g_ivex_cntx.display_layer_handle,
                        0, 0, 0);
                    break;
                case MMI_IVEX_IMAGE_STATE_SWITCH_NEXT:
                case MMI_IVEX_IMAGE_STATE_SWITCH_PREV:
                case MMI_IVEX_IMAGE_STATE_PLAY:
                    gdi_layer_set_blt_layer_nb_concurrent(
                        g_ivex_cntx.display_layer_handle,
                        g_ivex_cntx.switch_layer_handle,
                        0, 0);
                    break;
                default:
                    break;
            }
        }
    }
    else {
#endif /* __MULTIPLE_ANGLE_VIEW_SUPPORT__ */
        if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_HIDE)
        {
            switch (g_ivex_cntx.image_state)
            {
                case MMI_IVEX_IMAGE_STATE_STILL:
                case MMI_IVEX_IMAGE_STATE_STILL_H2P:
                case MMI_IVEX_IMAGE_STATE_STILL_P2H:
                    gdi_layer_set_blt_layer_nb_concurrent(
                        g_ivex_cntx.display_layer_handle,
                        g_ivex_cntx.osd_panel_layer,
                        g_ivex_cntx.osd_title_layer, 0);
                    break;
                case MMI_IVEX_IMAGE_STATE_SWITCH_NEXT:
                case MMI_IVEX_IMAGE_STATE_SWITCH_PREV:
                case MMI_IVEX_IMAGE_STATE_PLAY:
                    gdi_layer_set_blt_layer_nb_concurrent(
                        g_ivex_cntx.display_layer_handle,
                        g_ivex_cntx.switch_layer_handle,
                        g_ivex_cntx.osd_panel_layer,
                        g_ivex_cntx.osd_title_layer);
                    break;
                default:
                    break;
            }
        }
        else
        {
            switch (g_ivex_cntx.image_state)
            {
                case MMI_IVEX_IMAGE_STATE_STILL:
                case MMI_IVEX_IMAGE_STATE_STILL_H2P:
                case MMI_IVEX_IMAGE_STATE_STILL_P2H:
                    gdi_layer_set_blt_layer_nb_concurrent(
                        g_ivex_cntx.display_layer_handle,
                        0, 0, 0);
                    break;
                case MMI_IVEX_IMAGE_STATE_SWITCH_NEXT:
                case MMI_IVEX_IMAGE_STATE_SWITCH_PREV:
                case MMI_IVEX_IMAGE_STATE_PLAY:
                    gdi_layer_set_blt_layer_nb_concurrent(
                        g_ivex_cntx.display_layer_handle,
                        g_ivex_cntx.switch_layer_handle,
                        0, 0);
                    break;
                default:
                    break;
            }
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    }
#endif /* __MULTIPLE_ANGLE_VIEW_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reset_view_layer_info
 * DESCRIPTION
 *  This function reset the view layer info according to UI oriention.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_layer_nb_concurrentcy_blt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reset_view_layer_info
 * DESCRIPTION
 *  This function reset the view layer info according to UI oriention.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_reset_view_layer_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* keep view and ui consistency */
    g_ivex_cntx.view_image_rotate = g_ivex_cntx.ui_display_rotate;
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        g_ivex_cntx.view_layer_width = LCD_WIDTH;
        g_ivex_cntx.view_layer_height = LCD_HEIGHT;
    }
    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        g_ivex_cntx.view_layer_width = LCD_HEIGHT;
        g_ivex_cntx.view_layer_height = LCD_WIDTH;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reset_new_display_image_setting
 * DESCRIPTION
 *  This function called indicates has change switch image as real display image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_reset_new_display_image_setting(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* make sure the offset is o after last image move out */
    g_ivex_cntx.display_layer_last_offset_x = 0;
    g_ivex_cntx.display_layer_last_offset_y = 0;
#ifdef __MMI_TOUCH_SCREEN__
    g_ivex_cntx.is_pen_down_on_switch = MMI_FALSE;
    g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_NONE;
#endif
    g_ivex_cntx.switch_frame_index = 0;
    g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
#ifdef __DRM_SUPPORT__
    if (g_ivex_cntx.image_info.is_drm)
    {
        mmi_ivex_stop_drm_consume();
    }
#endif
    /* stop current loading because current image layer has slide out screen */
    mmi_ivex_stop_curr_loading_effect();
    /* stop anim because the current layer has slide out */
    mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif

    mmi_ivex_view_layers_and_imginfo_switch();
    /* This is for switch image becomes display, at this time, if loading need continue, should keep icon sequence */
    g_ivex_cntx.pre_image_state = g_ivex_cntx.image_state;
    if (g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_PLAY)
    {
    #ifdef __MMI_TOUCH_SCREEN__
        if (!g_ivex_cntx.is_pen_down)
    #endif
        {
            g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
            /* avoid the switch layer is drawn behind display layer when display layer has opacity  */
            mmi_ivex_layer_set_blt_layer();
        }
    }
    else
    {
        /* this means that not to set switch layer as blt layer */
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        mmi_ivex_layer_set_blt_layer();
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_PLAY;
    }

    mmi_ivex_reset_view_layer_info();
    /* the new display image is not interrupted yet */
    g_ivex_cntx.is_resume = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_layer_done
 * DESCRIPTION
 *  This function is called when finished switching.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_layer_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    mmi_imgview_play_file_req_struct *msg_local_para;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SWI_LAYER_DONE,g_imgview_fl_idx,g_ivex_cntx.image_info.filelist_index);
    if(g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK)
    {
        mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
        mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
    }
    else if (g_ivex_cntx.image_info.is_from_l1)
    {
        /* Do nothing */
        g_ivex_cntx.image_info.is_from_l1 = MMI_FALSE;

        mmi_ivex_stop_switch_loading_effect();

        mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
    #ifdef __DRM_SUPPORT__
        mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
    #endif
    }
    else
    {
        mmi_ivex_stop_curr_loading_effect();
        mmi_ivex_stop_switch_loading_effect();

        g_ivex_cntx.image_info.is_first_ok = MMI_FALSE;
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        if (ret >= SRV_MEDIACACHE_OK)
        {
            mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
        #ifdef __DRM_SUPPORT__
            mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
        #endif
        }
        else
        {
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }
    mmi_ivex_layer_reset_switch_layer_info(g_ivex_cntx.switch_layer_handle);
    mmi_ivex_draw_osd_panel_layer();
    mmi_ivex_draw_osd_title_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (g_ivex_cntx.image_info.is_mav)
        sliding_bar_set_progress(&g_ivex_cntx.osd_sliding_bar, 0.0);
#endif

    msg_local_para = (mmi_imgview_play_file_req_struct*) construct_local_para(sizeof(mmi_imgview_play_file_req_struct), TD_CTRL);
    mmi_ucs2cpy((CHAR*)msg_local_para->filepath, (CHAR*)g_ivex_cntx.image_info.filepath);
    mmi_imgview_sap_send_msg(MOD_MMI, MOD_MMI, MSG_ID_MMI_IMGVIEW_PLAY_FILE_REQ, msg_local_para);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_layer_resizer
 * DESCRIPTION
 *  This function is called to resize layer width and height.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_layer_resizer(gdi_handle layer_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        if (layer_handler == g_ivex_cntx.osd_title_layer)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, MMI_IVEX_OSD_TITLE_LAYER_WIDTH_0, MMI_IVEX_OSD_TITLE_LAYER_HEIGHT);
        }
        else if (layer_handler == g_ivex_cntx.osd_panel_layer)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, MMI_IVEX_OSD_PENAL_LYAER_WIDTH_0, MMI_IVEX_OSD_PENAL_LYAER_HEIGHT_0);
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        else if (layer_handler == g_ivex_cntx.osd_sliding_bar.panel_layer)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, MMI_IVEX_OSD_SLIDING_BAR_LAYER_WIDTH_0, MMI_IVEX_OSD_SLIDING_BAR_LAYER_HEIGHT_0);
        }
#endif
    }
    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        if (layer_handler == g_ivex_cntx.osd_title_layer)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, MMI_IVEX_OSD_TITLE_LAYER_WIDTH_270, MMI_IVEX_OSD_TITLE_LAYER_HEIGHT);
        }
        else if (layer_handler == g_ivex_cntx.osd_panel_layer)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, MMI_IVEX_OSD_PENAL_LYAER_WIDTH_270, MMI_IVEX_OSD_PENAL_LYAER_HEIGHT_270);
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        else if (layer_handler == g_ivex_cntx.osd_sliding_bar.panel_layer)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, MMI_IVEX_OSD_SLIDING_BAR_LAYER_WIDTH_270, MMI_IVEX_OSD_SLIDING_BAR_LAYER_HEIGHT_270);
        }
#endif
    }
    gdi_layer_clear_nb_concurrent(layer_handler, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key_nb_concurrent(layer_handler, MMI_TRUE, GDI_COLOR_TRANSPARENT);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_layer_resizer
 * DESCRIPTION
 *  This function is called to resize layer width and height.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_layer_resizer(gdi_handle layer_handler, MMI_BOOL is_switch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_switch)
    {
        if (g_ivex_cntx.ui_display_rotate== GDI_LCD_LAYER_ROTATE_0)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, LCD_WIDTH, LCD_HEIGHT);
            g_ivex_cntx.switch_layer_height = LCD_HEIGHT;
            g_ivex_cntx.switch_layer_width = LCD_WIDTH;
        }
        else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, LCD_HEIGHT, LCD_WIDTH);
            g_ivex_cntx.switch_layer_height = LCD_WIDTH;
            g_ivex_cntx.switch_layer_width = LCD_HEIGHT;
        }
    }
    else
    {
        /* image rotate only works on display layer */
        if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0 ||
            g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, LCD_WIDTH, LCD_HEIGHT);
            g_ivex_cntx.view_layer_height = LCD_HEIGHT;
            g_ivex_cntx.view_layer_width = LCD_WIDTH;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270 ||
            g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            gdi_layer_resize_nb_concurrent(layer_handler, LCD_HEIGHT, LCD_WIDTH);
            g_ivex_cntx.view_layer_height = LCD_WIDTH;
            g_ivex_cntx.view_layer_width = LCD_HEIGHT;
        }
    }
    gdi_layer_clear_nb_concurrent(layer_handler, GDI_COLOR_BLACK);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_create_osd_layers
 * DESCRIPTION
 *  This function is called to create resource used by ivexapp.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_create_osd_layers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CREATE_OSD_LAYER);
    g_ivex_cntx.osd_opacity = MMI_IVEX_OSD_FADE_OPACITY_VALUE;
    /* prepare switch zone of OSD lyaer using Screen asm, use RGB565, if set RGB self, us API gdi_layer_create_cf_using_outside_memory */
    MMI_ASSERT(g_ivex_cntx.mem_osd_title.buffer != NULL);

    gdi_layer_create_cf_using_outside_memory(
        MMI_IVEX_OSD_TITLE_LAYER_CF,
        0,
        0,
        MMI_IVEX_OSD_TITLE_LAYER_WIDTH_0,
        MMI_IVEX_OSD_TITLE_LAYER_HEIGHT,
        &g_ivex_cntx.osd_title_layer,
        (PU8) g_ivex_cntx.mem_osd_title.buffer,
        g_ivex_cntx.mem_osd_title.size);

    gdi_layer_clear_nb_concurrent(g_ivex_cntx.osd_title_layer, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_opacity_nb_concurrent(g_ivex_cntx.osd_title_layer, MMI_TRUE, (U8) g_ivex_cntx.osd_opacity);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.osd_title_layer, MMI_TRUE, GDI_COLOR_TRANSPARENT);

    /* prepare panel zone of OSD lyaer using Screen asm */
    MMI_ASSERT(g_ivex_cntx.mem_osd_panel.buffer != NULL);
    gdi_layer_create_cf_using_outside_memory(
        MMI_IVEX_OSD_PENAL_LAYER_CF,
        0,
        0,
        MMI_IVEX_OSD_PENAL_LYAER_WIDTH_0,
        MMI_IVEX_OSD_PENAL_LYAER_HEIGHT_0,
        &g_ivex_cntx.osd_panel_layer,
        (PU8) g_ivex_cntx.mem_osd_panel.buffer,
        g_ivex_cntx.mem_osd_panel.size);

    gdi_layer_clear_nb_concurrent(g_ivex_cntx.osd_panel_layer, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_opacity_nb_concurrent(g_ivex_cntx.osd_panel_layer, MMI_TRUE, (U8) g_ivex_cntx.osd_opacity);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.osd_panel_layer, MMI_TRUE, GDI_COLOR_TRANSPARENT);

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    MMI_ASSERT(g_ivex_cntx.mem_osd_sliding_bar.buffer != NULL);
    gdi_layer_create_cf_using_outside_memory(
        MMI_IVEX_OSD_SLIDING_BAR_LAYER_CF,
        0,
        0,
        MMI_IVEX_OSD_SLIDING_BAR_LAYER_WIDTH_0,
        MMI_IVEX_OSD_SLIDING_BAR_LAYER_HEIGHT_0,
        &g_ivex_cntx.osd_sliding_bar.panel_layer,
        (PU8) g_ivex_cntx.mem_osd_sliding_bar.buffer,
        g_ivex_cntx.mem_osd_sliding_bar.size);

    gdi_layer_clear_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_opacity_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, MMI_TRUE, (U8) g_ivex_cntx.osd_opacity);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, MMI_TRUE, GDI_COLOR_TRANSPARENT);
    g_ivex_cntx.osd_sliding_bar.external_layer = g_ivex_cntx.osd_panel_layer;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_free_osd_layers
 * DESCRIPTION
 *  This function is called to free resource used by ivexapp
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_free_osd_layers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_FREE_OSD_LAYER);
    /* free app osd layer handle*/
    MMI_ASSERT(g_ivex_cntx.osd_title_layer != GDI_LAYER_EMPTY_HANDLE);
    gdi_layer_free(g_ivex_cntx.osd_title_layer);
    g_ivex_cntx.osd_title_layer = GDI_LAYER_EMPTY_HANDLE;

    MMI_ASSERT(g_ivex_cntx.osd_panel_layer != GDI_LAYER_EMPTY_HANDLE);
    gdi_layer_free(g_ivex_cntx.osd_panel_layer);
    g_ivex_cntx.osd_panel_layer = GDI_LAYER_EMPTY_HANDLE;

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    MMI_ASSERT(g_ivex_cntx.osd_sliding_bar.panel_layer != GDI_LAYER_EMPTY_HANDLE);
    gdi_layer_free(g_ivex_cntx.osd_sliding_bar.panel_layer);
    g_ivex_cntx.osd_sliding_bar.panel_layer = GDI_LAYER_EMPTY_HANDLE;
    g_ivex_cntx.osd_sliding_bar.external_layer = GDI_LAYER_EMPTY_HANDLE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_create_view_layers
 * DESCRIPTION
 *  This function is called to create resource used by ivexapp.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_create_view_layers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* prepare display layer for ivexapp using base layer */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CREATE_VIEW_LAYER);
#if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
    g_ivex_cntx.app_layer_buf_ptr = (PU8)kal_adm_alloc(g_ivex_cntx.app_adm_id, MMI_IVEX_SHOWN_IMAGE_LAYER_24BIT);
    MMI_ASSERT(g_ivex_cntx.app_layer_buf_ptr != NULL);
    gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_24,
        0,
        0,
        LCD_WIDTH,
        LCD_HEIGHT,
        &g_ivex_cntx.switch_layer_handle,
        g_ivex_cntx.app_layer_buf_ptr,
        (S32) MMI_IVEX_SHOWN_IMAGE_LAYER_24BIT);

    /* prepare switch layer for ivexapp using gdi creat layer */
    gdi_layer_create_cf(GDI_COLOR_FORMAT_24, 0, 0, LCD_WIDTH, LCD_HEIGHT, &g_ivex_cntx.display_layer_handle);
#else
    gdi_layer_get_base_handle(&g_ivex_cntx.switch_layer_handle);

    /* prepare switch layer for ivexapp using gdi creat layer */
    gdi_layer_create(0,0,LCD_WIDTH,LCD_HEIGHT,&g_ivex_cntx.display_layer_handle);
#endif

    gdi_layer_clear_nb_concurrent(g_ivex_cntx.switch_layer_handle, GDI_COLOR_BLACK);
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);

#ifdef __IVEX_SUPPORT_IES__
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.switch_layer_handle, MMI_FALSE, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.display_layer_handle, MMI_FALSE, GDI_COLOR_TRANSPARENT);
#else
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.switch_layer_handle, MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.display_layer_handle, MMI_TRUE, GDI_COLOR_TRANSPARENT);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_free_app_view_layers
 * DESCRIPTION
 *  This function is called to free app resource used by ivexapp
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_free_app_view_layers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* free lcd cache memory from APP asm */
    MMI_ASSERT(g_ivex_cntx.app_adm_id  != NULL);
    kal_adm_free(g_ivex_cntx.app_adm_id, (void*)g_ivex_cntx.app_layer_buf_ptr);
    g_ivex_cntx.app_layer_buf_ptr = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_free_view_layers
 * DESCRIPTION
 *  This function is called to free resource used by ivexapp
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_free_view_layers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle temp_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* free app switch layer handle, display layer use base layer that not need release */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_FREE_VIEW_LAYER);
#if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
    if (g_ivex_cntx.switch_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_ivex_cntx.switch_layer_handle);
    }
    if (g_ivex_cntx.display_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_ivex_cntx.display_layer_handle);
    }
#else
    gdi_layer_get_base_handle(&temp_handle);
    if (temp_handle == g_ivex_cntx.switch_layer_handle)
    {
        gdi_layer_free(g_ivex_cntx.display_layer_handle);
    }
    else
    {
        gdi_layer_free(g_ivex_cntx.switch_layer_handle);
    }
#endif
    g_ivex_cntx.switch_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    g_ivex_cntx.display_layer_handle = GDI_LAYER_EMPTY_HANDLE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_layers_and_imginfo_switch
 * DESCRIPTION
 *  This function is called to exchange switched two image info used by ivexapp.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_layers_and_imginfo_switch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle layer_hdlr;
    ivex_image_info_struct temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* layer handle switch */
    layer_hdlr = g_ivex_cntx.display_layer_handle;
    g_ivex_cntx.display_layer_handle = g_ivex_cntx.switch_layer_handle;
    g_ivex_cntx.switch_layer_handle = layer_hdlr;

    /* image info switch */
    temp = g_ivex_cntx.image_info;
    g_ivex_cntx.image_info = g_ivex_cntx.switch_image_info;
    g_ivex_cntx.switch_image_info = temp;
    g_imgview_fl_idx = g_ivex_cntx.image_info.filelist_index;

    if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_LOADING)
    {
        mmi_ivex_get_image_base_info(
            g_ivex_cntx.image_info.filelist_index,
            MMI_FALSE,
            &g_ivex_cntx.image_info);

        if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_READY)
        {
            mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_make_bg_when_exit
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_make_bg_when_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer_handle, temp_layer=0, title_layer=0, panel_layer=0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_base_handle(&base_layer_handle);
    if(g_ivex_cntx.display_layer_handle == base_layer_handle && 
            g_ivex_cntx.view_image_rotate != GDI_LCD_LAYER_ROTATE_0){
            
            temp_layer = g_ivex_cntx.switch_layer_handle;
            gdi_layer_resize_nb_concurrent(temp_layer, LCD_WIDTH, LCD_HEIGHT);
            gdi_layer_set_rotate_nb_concurrent(temp_layer,GDI_LCD_LAYER_ROTATE_0);
            gdi_layer_set_position_nb_concurrent(temp_layer, 0, 0);
            gdi_layer_set_position_nb_concurrent(g_ivex_cntx.display_layer_handle, 0, 0);
            gdi_layer_push_and_set_active(temp_layer);
            gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
            gdi_layer_flatten(g_ivex_cntx.display_layer_handle, 0, 0, 0);
            gdi_layer_pop_and_restore_active();
    }else{
        temp_layer = g_ivex_cntx.display_layer_handle;
        gdi_layer_set_position_nb_concurrent(temp_layer, 0, 0);
    }

    if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_HIDE)
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            mmi_ivex_layer_set_position(g_ivex_cntx.osd_title_layer, &g_ivex_cntx.active_osd_layout_ptr->title);
        }
        mmi_ivex_layer_set_position(g_ivex_cntx.osd_panel_layer, &g_ivex_cntx.active_osd_layout_ptr->panel);
        title_layer = g_ivex_cntx.osd_title_layer;
        panel_layer = g_ivex_cntx.osd_panel_layer;
    }

    gdi_layer_resize_nb_concurrent(base_layer_handle, LCD_WIDTH, LCD_HEIGHT);
    gdi_layer_set_rotate_nb_concurrent(base_layer_handle,GDI_LCD_LAYER_ROTATE_0);
    gdi_layer_set_position_nb_concurrent(base_layer_handle, 0, 0);
    gdi_layer_push_and_set_active(base_layer_handle);
    //blt to base layer
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (g_ivex_cntx.image_info.is_mav) {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0) {
            gdi_layer_flatten(temp_layer, title_layer, panel_layer, 0);
        }
        else {
            gdi_layer_flatten(temp_layer, panel_layer, g_ivex_cntx.osd_sliding_bar.panel_layer, 0);
        }
    }
    else {
#endif
        gdi_layer_flatten(temp_layer, title_layer, panel_layer, 0);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    }
#endif
    gdi_layer_pop_and_restore_active();
    gdi_layer_set_blt_layer(base_layer_handle, 0,0,0);
    
    /* delete this line for fix MAUI_02218431 
    gdi_layer_blt(g_ivex_cntx.display_layer_handle,0,0,0,0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);*/

}



#define MMI_IVEX_ENTER_EXIT_MGR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_if_folder_changed
 * DESCRIPTION
 *  Pre check if the folder is changed when comeback from history.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_if_folder_changed(CHAR* file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_changed = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (file_path != NULL)
    {
        /* add this for check if the first letter is a valide drv letter.
        cause MMS will pass a virtual filepath to image viewer, the first is not a valide drv letter */
        if(srv_fmgr_drv_get_type(file_path[0]) >= FS_NO_ERROR)
        {
            if (FS_GetDevStatus(file_path[0], FS_MOUNT_STATE_ENUM) != FS_NO_ERROR)
            {
                is_changed = MMI_TRUE;

                if (g_ivex_cntx.image_info.filepath != NULL && g_ivex_cntx.view_from_fmgr)
                {
                    gui_free(g_ivex_cntx.image_info.filepath);
                    g_ivex_cntx.image_info.filepath = NULL;
                }
            }
        }
    }

    if (!g_ivex_cntx.view_from_fmgr)
    {
        g_ivex_cntx.total_image_count = srv_fmgr_filelist_count(g_imgview_fl_hdl);
        if (g_ivex_cntx.total_image_count <= 0)
        {
            is_changed = MMI_TRUE;
        }
    }
    return is_changed;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_variable
 * DESCRIPTION
 *  initial some variable when enter, make sure they are right before entry view screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_init_variable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* restore key state */
    g_ivex_cntx.key_press = MMI_FALSE;
    g_ivex_cntx.is_switch_two = MMI_FALSE;
    g_ivex_cntx.osd_fade_percent = 100;
    /* need restore to view one image when switch half */
    g_ivex_cntx.display_layer_last_offset_x = 0;
    g_ivex_cntx.display_layer_last_offset_y = 0;
    g_ivex_cntx.play_skip_number = 0;
    g_ivex_cntx.switch_orientation = MMI_IVEX_SWITCH_NONE;
    g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
    g_ivex_cntx.is_zoomin = MMI_FALSE;
    g_ivex_cntx.is_zoomout = MMI_FALSE;
    g_ivex_cntx.is_spring = MMI_FALSE;
#ifdef __MMI_TOUCH_SCREEN__
    g_ivex_cntx.is_pen_down = MMI_FALSE;
    g_ivex_cntx.is_pen_down_zoom = MMI_FALSE;
    g_ivex_cntx.is_pen_down_on_switch = MMI_FALSE;
    g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_NONE;
    g_ivex_cntx.start_ticks_1 = 0;
    g_ivex_cntx.start_ticks_2 = 0;
    g_ivex_cntx.double1_x = 0;
    g_ivex_cntx.double1_y = 0;
#endif
    g_ivex_cntx.redecode_time = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_all
 * DESCRIPTION
 *  stop all operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_all(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_stop_curr_loading_effect();
    mmi_ivex_stop_switch_loading_effect();
    mmi_ivex_stop_switch_next();
    mmi_ivex_stop_switch_pre();
    mmi_ivex_stop_zoomin();
    mmi_ivex_stop_zoomout();
    mmi_ivex_stop_play();
    mmi_ivex_enable_osd_fade(MMI_FALSE);
    mmi_ivex_stop_osd_fade_out();
    mmi_ivex_stop_osd_fade_in();
    mmi_ivex_stop_rotate();
    mmi_ivex_stop_move();
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_ivex_non_move_axis_stop_bounce();
    mmi_ivex_stop_auto_move();
    mmi_ivex_stop_rebound_back();
#endif
    mmi_ivex_stop_renderer_cyclic();
    gui_cancel_timer(mmi_ivex_entry_screen_bh);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_free_scr_related_resource
 * DESCRIPTION
 *  free screen related resource
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_free_scr_related_resource(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* free memory for app use */
    mmi_ivex_util_free_osd_mem();        /* Screen-based (ARGB8888) */
    /* free handler for app use */
    mmi_ivex_free_osd_layers();
    mmi_ivex_free_view_layers();
#if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
    mmi_ivex_free_app_view_layers();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_remove_app_mem_cache_and_adm_mem
 * DESCRIPTION
 *  free app memory related resource
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_remove_app_mem_cache_and_adm_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.image_info.filepath);
    g_ivex_cntx.image_info.filepath= NULL;
    kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.switch_image_info.filepath);
    g_ivex_cntx.switch_image_info.filepath = NULL;
    kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.title_str);
    g_ivex_cntx.title_str = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_free_app_mem_resource
 * DESCRIPTION
 *  free app memory related resource
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_free_app_mem_resource(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_remove_app_mem_cache_and_adm_mem();
    mmi_ivex_destroy_app_based_memory_adm();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_del_view_scr_callback
 * DESCRIPTION
 *  delete view screen callback handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_ivex_del_view_scr_callback(void* ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DEL_VIEW_SCR_CB);
    mmi_ivex_stop_all();
    mmi_ivex_enable_osd_fade(MMI_FALSE);

    /* destroy ivsrv */
    mmi_ivex_deinit_cache_service();

    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_VIEW)
    {
        mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
        mmi_ivex_free_scr_related_resource();

    #ifdef __MMI_VUI_MEDIAWALL__
        mmi_ivex_destory_adm();
    #else
        mmi_ivex_free_app_mem_resource();
    #endif
    }
    else if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_PAUSE)
    {
    #ifdef __MMI_VUI_MEDIAWALL__
        mmi_ivex_destory_adm();
    #else
        mmi_ivex_free_app_mem_resource();
    #endif
    }
    else
    {
        MMI_ASSERT(0);
    }

#ifdef __DRM_SUPPORT__
    if (g_ivex_cntx.image_info.is_drm)
    {
        mmi_ivex_stop_drm_consume();
    }
#endif

    g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_EXIT;
    mmi_mediaview_free_filelist();

#ifdef __MMI_VUI_MEDIAWALL__
    if (mmi_frm_group_is_present(g_mediaview_cui_gid) && mmi_mediaview_vapp_mediawall_is_caller())
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_90)
        {
            vapp_mediawall_set_direction(VADP_MEDIAWALL_LANDSCAPE);
        }
        else
        {
            vapp_mediawall_set_direction(VADP_MEDIAWALL_PORTRAIT);
        }
    }
#endif
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_exit_view_screen
 * DESCRIPTION
 *  ivex exit screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_exit_view_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_direct_exit;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_EXIT_VIEW_SCR, g_ivex_cntx.renderer_ref_count);
#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
    mmi_frm_cb_dereg_event(EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING, mmi_ivex_screen_locker_event_handler, NULL);
#endif
    g_ivex_cntx.key_press = MMI_FALSE;
    is_direct_exit = mmi_ivex_is_direct_exit_state(g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_VIEWSCRN);
    if (is_direct_exit)
    {
        return;
    }

#ifdef __MMI_IMGVIEWEX_MOTION__
    if (!MMI_IVEX_LANDSCAPE)
    {
        mmi_ivex_stop_listen_motion();
    }
#endif
#ifdef __MMI_IMGVIEWEX_MAV_MOTION__
    mmi_ivex_mav_stop_listen_motion();
#endif    
#ifdef __MMI_TOUCH_SCREEN__
    /* restore to normal state */
    mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_1, MMI_PEN_SAMPLING_PERIOD_2);
#endif
    /* remove screen related cache */
    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_VIEW)
    {
        /* for MAUI_02318244, back up usable variable
        cause they may be changed when in bellow statement before be used */
        MMI_BOOL                ui_rotating = g_ivex_cntx.ui_rotating;
        ivex_rotate_state_enum  rot_oriention = g_ivex_cntx.rot_oriention;

        mmi_ivex_stop_all();
        mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
        /* stop ivsrv */
        mmi_ivex_inactive_cache_service();
        mmi_ivex_make_bg_when_exit();
        mmi_ivex_free_scr_related_resource();
    #ifdef __DRM_SUPPORT__
        if (g_ivex_cntx.image_info.is_drm &&
            g_ivex_cntx.image_info.drm_state == MMI_IVEX_DRM_STATE_CONSUME)
        {
            mmi_ivex_pause_drm_consume(&g_ivex_cntx.image_info);
        }
    #endif

        if(ui_rotating == MMI_TRUE && /* ui is switching and osd is fading out */
           rot_oriention == MMI_IVEX_ROTATE_NONE) /* rotate error or loading */
        {
            /* this is for MAUI_02318244,
            when rotate error, will swith image first and then start to fade osd,
            if interrup comes during fade out, will be switched image and un-swiched osd */
            g_ivex_cntx.ui_display_rotate =
                g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0 ?
                GDI_LCD_LAYER_ROTATE_90 : GDI_LCD_LAYER_ROTATE_0;
        }
        g_ivex_cntx.ui_rotating = MMI_FALSE;

        g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_PAUSE;
    }
    else if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_EXIT)
    {
        /* do nothing, already exit */
    }
    else
    {
        /* wrong state */
        MMI_ASSERT(0);
    }
    /* re-enable keypad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);
    /* this will force title status to redraw */
    entry_full_screen();
    g_ivex_cntx.view_one_from_other_app = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_screen_leave_proc
 * DESCRIPTION
 *  Ext view screen leave proc.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
mmi_ret mmi_ivex_view_screen_leave_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
    {
    case EVT_ID_SCRN_GOBACK:
        break;
    case EVT_ID_SCRN_DELETE_REQ:
        break;
    case EVT_ID_SCRN_DEINIT:
        mmi_ivex_del_view_scr_callback(NULL);
        break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_view_screen_health
 * DESCRIPTION
 *  Check screen health state when from history.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_view_screen_health(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_is_in_backward_scenario())
    {
        if ((FS_GetDevStatus(mmi_ivex_get_storage() ,FS_MOUNT_STATE_ENUM) != FS_NO_ERROR)  ||
            g_ivex_cntx.is_card_out == MMI_TRUE)
        {
            /* This is for quickly plug in/out card case, if can not resotre some info when plug out, enven if plug in quickly, still not allow to entry */
            g_ivex_cntx.is_card_out = MMI_FALSE;
            /* Delete up to previous screen */
            mmi_ivex_close_group(&g_mediaview_cui_gid, EVT_ID_MEDIAVIEW_CLOSE_GID, MMI_FALSE, MMI_FALSE);
            if (g_ivex_cui_gid != GRP_ID_INVALID)
            {
                mmi_ivex_close_group(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID, MMI_FALSE, MMI_TRUE);
            }
            return MMI_FALSE;
        }

        if (srv_fmgr_filelist_is_dirty(g_imgview_fl_hdl) || srv_fmgr_filelist_count(g_imgview_fl_hdl) <= 0)
        {
            mmi_ivex_display_error_sg(
                g_ivex_cui_gid,
                (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
                MMI_EVENT_FAILURE,
                (U16)g_ivex_cntx.ui_display_rotate,
                MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);
            if (cui_folder_browser_is_filelist_locked(mmi_mediaview_get_browse_gid()))
                mmi_mediaview_free_filelist();
            return MMI_FALSE;
        }
    }
    return MMI_TRUE;
}

static mmi_ret mmi_ivex_view_scrn_key_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_arrow;
    mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct*)evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_ivex_cntx.view_state != MMI_IVEX_VIEW_STATE_VIEW)
        return MMI_RET_OK;

    if (evt->evt_id == EVT_ID_ON_KEY)
    {
        /* ignore sys keys */
        if (key_evt->key_code == KEY_END || key_evt->key_code == KEY_POWER)
            return MMI_RET_OK;

        if(!mmi_ivex_check_view_avaliable_and_process())
            return MMI_RET_KEY_HANDLED;

        is_arrow = mmi_ivex_check_arrow_key(key_evt->key_code);
        if (g_ivex_cntx.ui_rotating == MMI_FALSE)
        {
            if (!is_arrow)
            {
                mmi_ivex_enable_osd_fade(MMI_TRUE);
                if (g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_FADE_OUT ||
                    g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_HIDE)
                {
                    mmi_ivex_stop_osd_fade_out();
                    mmi_ivex_start_osd_fade_in();
                }
            }
            else
            {
                if (g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_SHOW)
                {
                    mmi_ivex_stop_osd_fade_out();
                    mmi_ivex_stop_osd_fade_in();
                    mmi_ivex_start_osd_fade_out();
                }
            }
        }

        if(key_evt->key_type == KEY_EVENT_DOWN)
            mmi_ivex_key_down_hdlr((U16)(key_evt->key_code));
        else if(key_evt->key_type == KEY_EVENT_UP)
            mmi_ivex_key_up_hdlr((U16)(key_evt->key_code));
        else if(key_evt->key_type == KEY_REPEAT)
            mmi_ivex_key_repeat_hdlr((U16)(key_evt->key_code));
        

        return MMI_RET_KEY_HANDLED;

    }
    return MMI_RET_OK;

}

/*********** operations of media cache service *****************/

static void* mmi_ivex_alloc_med(S32 size, MMI_BOOL need_assert)
{
    void *pbuf = NULL;
    if(size == 0)
        return pbuf;

    pbuf = mmi_imgview_asm_alloc_debug(g_imgview_cui_ptr->imgview_cui_gid, size);

    if(need_assert == MMI_TRUE)
        MMI_ASSERT(pbuf != NULL);

    return pbuf;

}

static void* mmi_ivex_alloc_asm(S32 size, MMI_BOOL need_assert)
{
    void *pbuf = NULL;

    MMI_ASSERT(g_ivex_cntx.app_adm_id  != NULL);

    if(size == 0)
        return pbuf;
    
#if (defined(__MTK_TARGET__) && defined(__DYNAMIC_SWITCH_CACHEABILITY__))
    pbuf = kal_adm_alloc_noncacheable(g_ivex_cntx.app_adm_id, size, PAGE_SIZE_4KB);
#else
    pbuf = kal_adm_alloc(g_ivex_cntx.app_adm_id, size);
#endif

    if(need_assert == MMI_TRUE)
        MMI_ASSERT(pbuf != NULL);

    return pbuf;
    
}

static S32 mmi_ivex_get_lcdcache_size(S32 size)
{
    if(size == MMI_IVEX_TOTAL_LCD_CACHE_SIZE)
    {
        /* more memory are all for LCD cache */
        return (size + (g_ivex_cntx.app_mem_size - MMI_IVEX_TOTAL_APP_BASED_MEM_POOL_SIZE));
    }
    else
    {
        return size;
    }

}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_malloc_cache
 * DESCRIPTION
 *  This function will malloc and add cache to cache service.
 * PARAMETERS
 *  is_med: MMI_TRUE -- alloc memory from med pool
 *          MMI_FALSE -- alloc memory from ASM
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_malloc_cache(MMI_BOOL is_med)
{
    int i;
    ivex_memory_struct *pmem = g_ivex_cntx.mem_cache;

    if(is_med == MMI_TRUE){
        for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++){
#ifdef __MMI_IMGVIEWEX_DB__
            MMI_BOOL need_assert = (i == MMI_IVEX_DB_INDEX) ? MMI_FALSE : MMI_TRUE;
#else
            MMI_BOOL need_assert = MMI_TRUE;
#endif
            if(pmem[i].type == MMI_IVEX_MEMORY_TYPE_MED){
                pmem[i].buffer = mmi_ivex_alloc_med(pmem[i].size, need_assert);
                TMP_TRACE3("[IVAPP] malloc med cache %d, size %d, i: %d", pmem[i].buffer, pmem[i].size, i);
            }
        }
    }else{
        for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++){
            if(pmem[i].type == MMI_IVEX_MEMORY_TYPE_APP_BASED){
                pmem[i].buffer = mmi_ivex_alloc_asm(pmem[i].size, MMI_TRUE);
                TMP_TRACE3("[IVAPP] malloc asm cache %d, size %d, i: %d", pmem[i].buffer, pmem[i].size, i);
            }
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_free_cache
 * DESCRIPTION
 *  free cache memory
 * PARAMETERS
 *  is_med: MMI_TRUE -- free cache from med pool
 *          MMI_FALSE -- free cache from ASM
 *  need_remove : if need remove from cache service.
 * RETURNS
 *  void
 *****************************************************************************/

static void mmi_ivex_free_cache(MMI_BOOL is_med, MMI_BOOL need_remove)
{
    int i=0;
    ivex_memory_struct *pmem = g_ivex_cntx.mem_cache;
    
    if(is_med){
        for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++)
        {
            if(pmem[i].type == MMI_IVEX_MEMORY_TYPE_MED)
            {
                if(need_remove == MMI_TRUE)
                    srv_mediacache_remove_cache(g_ivex_cntx.srv_mediacache_handle, pmem[i].buffer);
                mmi_imgview_asm_free_debug(g_imgview_cui_ptr->imgview_cui_gid, pmem[i].buffer);
                pmem[i].buffer = NULL;
            }
        }
    }else{
        for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++)
        {
            if(pmem[i].type == MMI_IVEX_MEMORY_TYPE_APP_BASED)
            {
                if(need_remove == MMI_TRUE)
                    srv_mediacache_remove_cache(g_ivex_cntx.srv_mediacache_handle, pmem[i].buffer);

                MMI_ASSERT(g_ivex_cntx.app_adm_id  != NULL);
                kal_adm_free(g_ivex_cntx.app_adm_id, pmem[i].buffer);

                pmem[i].buffer = NULL;
            }
        }
    }
}

#ifdef __MMI_IMGVIEWEX_DB__
static void mmi_ivex_config_db(ivex_memory_struct *pmem, ivex_memory_type_enum mem_type)
{
    if(pmem->buffer == NULL || pmem->type != mem_type)
        return;
        
    /* CUI control part, user can reset it */
    if (g_ivex_cntx.total_image_count <= MMI_IVEX_DB_START_LIMIT_MAX &&
        g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_DB] == MMI_TRUE)
    {
        S32 srv_fmgr_ret;
        S32 str_len, cha_index;

        g_ivex_cntx.filepath = kal_adm_alloc(g_ivex_cntx.app_adm_id, SRV_FMGR_PATH_BUFFER_SIZE);
        /* In fact, here filepath should be ready because it is locked from fmgr */
        srv_fmgr_filelist_get_filepath(g_imgview_fl_hdl, g_imgview_fl_idx, (WCHAR*)g_ivex_cntx.filepath, SRV_FMGR_PATH_BUFFER_SIZE);
        
        /* In fact, here filepath should be ready because it is locked from fmgr */
        srv_fmgr_ret = srv_fmgr_filelist_get_filepath(g_imgview_fl_hdl, g_imgview_fl_idx, (WCHAR*)g_ivex_cntx.filepath, SRV_FMGR_PATH_BUFFER_SIZE);
        if(srv_fmgr_ret < 0)
        {
            if(srv_fmgr_ret == SRV_FMGR_FILELIST_ERROR_FILE_NOT_READY)
            {
                // TODO: nothing, cause here only need the path of the folder
            }
        }

        str_len = mmi_ucs2strlen(g_ivex_cntx.filepath);
        /* get file name, e.g. IMG0111 */
        for (cha_index = str_len * 2 - 2; cha_index >= 2; cha_index -= 2)
        {
            if (mmi_ucs2ncmp(&g_ivex_cntx.filepath[cha_index], (const CHAR*) L"\\", 1) == 0)
            {
                g_ivex_cntx.filepath[cha_index] = 0;
                g_ivex_cntx.filepath[cha_index + 1] = 0;
                break;
            }
        }
        srv_mediacache_config_db(g_ivex_cntx.srv_mediacache_handle, 
                pmem->buffer, pmem->size, 
                (WCHAR*)g_ivex_cntx.filepath,L"ivex.db");
        g_ivex_cntx.is_db_start = MMI_TRUE;
    }

}
#endif
/*
 * free all cache resource
 */
static void mmi_ivex_destroy_cache_service(void)
{
    srv_mediacache_destroy(g_ivex_cntx.srv_mediacache_handle);
    g_ivex_cntx.srv_mediacache_handle = NULL;
    kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.srv_mediacache_run_buffer);
    g_ivex_cntx.srv_mediacache_run_buffer = NULL;

#ifdef __MMI_IMGVIEWEX_DB__
    if(g_ivex_cntx.is_db_start == MMI_TRUE){
        kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.filepath);
        g_ivex_cntx.filepath = NULL;
        g_ivex_cntx.is_db_start = MMI_FALSE;
    }
#endif

#if (defined(__IVEX_SUPPORT_IES__) && (MMI_IVEX_MEDCACHE_IES_WORKING_BUF_SIZE != 0))
    kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.p_ies_work_buf);
    g_ivex_cntx.p_ies_work_buf = NULL;
    
#endif

    /* free ASM Cache buffer */
    mmi_ivex_free_cache(MMI_FALSE, MMI_FALSE);

}

/*
 * malloc and config cache service
 * 
 */
#define IVEX_CACHE_MODE_FILE        0
#define IVEX_CACHE_MODE_FILELIST    1

static void mmi_ivex_create_cache_service(int mode)
{
    g_ivex_cntx.srv_mediacache_run_buffer = kal_adm_alloc(g_ivex_cntx.app_adm_id, MMI_IVEX_MEM_FOR_SRV_RUN_BUFFER);
    g_ivex_cntx.srv_mediacache_handle = srv_mediacache_create(g_ivex_cntx.srv_mediacache_run_buffer, MMI_IVEX_MEM_FOR_SRV_RUN_BUFFER);

#if (defined(__IVEX_SUPPORT_IES__) && (MMI_IVEX_MEDCACHE_IES_WORKING_BUF_SIZE != 0))
    g_ivex_cntx.p_ies_work_buf = 
    #if (defined(__MTK_TARGET__) && defined(__DYNAMIC_SWITCH_CACHEABILITY__))
             kal_adm_alloc_cacheable(g_ivex_cntx.app_adm_id, MMI_IVEX_MEDCACHE_IES_WORKING_BUF_SIZE, PAGE_SIZE_4KB);
    #else
             kal_adm_alloc(g_ivex_cntx.app_adm_id, MMI_IVEX_MEDCACHE_IES_WORKING_BUF_SIZE);
    #endif
    MMI_ASSERT(g_ivex_cntx.p_ies_work_buf != NULL);
    srv_mediacache_config_image_decode_and_get_source(g_ivex_cntx.srv_mediacache_handle, MMI_TRUE, (U8*)(g_ivex_cntx.p_ies_work_buf), MMI_IVEX_MEDCACHE_IES_WORKING_BUF_SIZE);
#else
    srv_mediacache_config_image_decode_and_get_source(g_ivex_cntx.srv_mediacache_handle, MMI_TRUE, NULL, 0);
#endif
    srv_mediacache_config_blocking_get_first(g_ivex_cntx.srv_mediacache_handle, MMI_TRUE);
#if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
    srv_mediacache_config_color_format(g_ivex_cntx.srv_mediacache_handle, GDI_COLOR_FORMAT_24);
#endif
    srv_mediacache_config_database_store_group(g_ivex_cntx.srv_mediacache_handle, SRV_MEDIACACHE_CACHE_TYPE_L1);
    if(mode == IVEX_CACHE_MODE_FILELIST){
    srv_mediacache_config_work_mode_to_filelist(g_ivex_cntx.srv_mediacache_handle, g_imgview_fl_hdl);
    }else if(mode == IVEX_CACHE_MODE_FILE){
        srv_mediacache_config_work_mode_to_filename(g_ivex_cntx.srv_mediacache_handle, (WCHAR*)g_ivex_cntx.image_info.filepath);
    }

    /* config cache */    
    mmi_ivex_malloc_cache(MMI_FALSE);
    if(g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].buffer != NULL && 
        g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].type == MMI_IVEX_MEMORY_TYPE_APP_BASED){
        srv_mediacache_add_cache(
            g_ivex_cntx.srv_mediacache_handle,
            SRV_MEDIACACHE_CACHE_TYPE_L2,
            g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].size);
        TMP_TRACE2("[IVAPP] add asm L2 cache: %d, %d", g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].size);
    }

    if(g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].buffer != NULL && 
        g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].type == MMI_IVEX_MEMORY_TYPE_APP_BASED){
        srv_mediacache_add_cache(
            g_ivex_cntx.srv_mediacache_handle,
            SRV_MEDIACACHE_CACHE_TYPE_L1,
            g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].size);
       
       TMP_TRACE2("[IVAPP] add asm L1 cache: %d, %d", g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].size);
       
    }

    if(g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer != NULL && 
        g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].type == MMI_IVEX_MEMORY_TYPE_APP_BASED){
        srv_mediacache_add_cache(
            g_ivex_cntx.srv_mediacache_handle,
            SRV_MEDIACACHE_CACHE_TYPE_LARGE,
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size);
        
        TMP_TRACE2("[IVAPP] add asm Large cache: %d, %d", 
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size);
        
        
    }
    
#ifdef __MMI_IMGVIEWEX_DB__
    g_ivex_cntx.is_db_start = MMI_FALSE;
    mmi_ivex_config_db(&g_ivex_cntx.mem_cache[MMI_IVEX_DB_INDEX], MMI_IVEX_MEMORY_TYPE_APP_BASED);

#endif

}

/*
 * malloc and config screen based resource
 */
static void mmi_ivex_active_cache_service(MMI_BOOL usedb, int mode, U32 l2_size, U32 l1_size)
{
    int start_index = (mode == IVEX_CACHE_MODE_FILELIST) ? g_imgview_fl_idx : 0;

    if(g_ivex_cntx.srv_mediacache_handle == NULL){
        mmi_ivex_create_cache_service(mode);
    }
    /*
#if (__MMI_IMAGE_VIEWER_EX_MEM_SRC__ == MMI_IMAGE_VIEWER_EX_MEM_SRC_MED)
        mmi_ivex_create_cache_service(mode);
#endif
    */

    /* malloc and config screen based resource */
    /* config cache */    
    mmi_ivex_malloc_cache(MMI_TRUE);
    if(g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].buffer != NULL && 
        g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].type == MMI_IVEX_MEMORY_TYPE_MED){
        srv_mediacache_add_cache(
            g_ivex_cntx.srv_mediacache_handle,
            SRV_MEDIACACHE_CACHE_TYPE_L2,
            g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].size);

        TMP_TRACE2("[IVAPP] add med L2 cache: %d, %d", g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].size);
            
    }

    if(g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].buffer != NULL && 
        g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].type == MMI_IVEX_MEMORY_TYPE_MED){
        srv_mediacache_add_cache(
            g_ivex_cntx.srv_mediacache_handle,
            SRV_MEDIACACHE_CACHE_TYPE_L1,
            g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].size);
        
        TMP_TRACE2("[IVAPP] add med L1 cache: %d, %d", g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].buffer,
             g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].size);
        
    }

    if(g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer != NULL && 
        g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].type == MMI_IVEX_MEMORY_TYPE_MED){
        srv_mediacache_add_cache(
            g_ivex_cntx.srv_mediacache_handle,
            SRV_MEDIACACHE_CACHE_TYPE_LARGE,
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size);
        
        TMP_TRACE2("[IVAPP] add med Large cache: %d, %d", 
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer,
            g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size);
        
    }

    /*config DB */
#ifdef __MMI_IMGVIEWEX_DB__
    mmi_ivex_config_db(&g_ivex_cntx.mem_cache[MMI_IVEX_DB_INDEX], MMI_IVEX_MEMORY_TYPE_MED);
#endif

    /* start iv-service */
    if (srv_mediacache_start(g_ivex_cntx.srv_mediacache_handle, start_index))
    {
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
            MMI_EVENT_FAILURE,
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);
        return;
        //MMI_ASSERT(0);
    }

}

/*
 * free screen based resource
 */
static void mmi_ivex_inactive_cache_service(void)
{
    if(g_ivex_cntx.srv_mediacache_handle == NULL){
        return;
    }
    
    srv_mediacache_stop(g_ivex_cntx.srv_mediacache_handle);

#if (__MMI_IMAGE_VIEWER_EX_MEM_SRC__ == MMI_IMAGE_VIEWER_EX_MEM_SRC_MED)
    mmi_ivex_destroy_cache_service();
    /* free screen based resource */
    mmi_ivex_free_cache(MMI_TRUE,MMI_FALSE);
#else
    /* free screen based resource */
    mmi_ivex_free_cache(MMI_TRUE,MMI_TRUE);
#endif
}

static void mmi_ivex_init_cache_service(MMI_BOOL usedb, int mode, U32 l2_size, U32 l1_size)
{
    int i;

    /* Config memory size */
    g_ivex_cntx.mem_cache[MMI_IVEX_SMALL_INDEX].size = l2_size;
    
#if (__MMI_IMAGE_VIEWER_EX_MEM_SRC__ != MMI_IMAGE_VIEWER_EX_MEM_SRC_MED)
    g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].size = mmi_ivex_get_lcdcache_size(l1_size);
#else
    g_ivex_cntx.mem_cache[MMI_IVEX_LCD_INDEX].size = l1_size;
#endif

    g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size = MMI_IVEX_LARGE_CACHE_SIZE;

#ifdef __MMI_IMGVIEWEX_DB__
    if(usedb == MMI_TRUE)
        g_ivex_cntx.mem_cache[MMI_IVEX_DB_INDEX].size = MMI_IVEX_DB_BUFFER_SIZE;
    else
        g_ivex_cntx.mem_cache[MMI_IVEX_DB_INDEX].size = 0;
#endif

    /* Config memory type */
#if (__MMI_IMAGE_VIEWER_EX_MEM_SRC__ == MMI_IMAGE_VIEWER_EX_MEM_SRC_MED)
    for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++){
        g_ivex_cntx.mem_cache[i].buffer = NULL;
        g_ivex_cntx.mem_cache[i].type = MMI_IVEX_MEMORY_TYPE_MED;
    }
#elif(__MMI_IMAGE_VIEWER_EX_MEM_SRC__ == MMI_IMAGE_VIEWER_EX_MEM_SRC_ASM)
    
    for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++){
        g_ivex_cntx.mem_cache[i].buffer = NULL;
        g_ivex_cntx.mem_cache[i].type = MMI_IVEX_MEMORY_TYPE_APP_BASED;
    }
    //mmi_ivex_create_cache_service(mode);
#else
    for(i=0; i<MMI_IVEX_CACHE_TOTAL; i++){
        g_ivex_cntx.mem_cache[i].buffer = NULL;
        g_ivex_cntx.mem_cache[i].type = MMI_IVEX_MEMORY_TYPE_APP_BASED;
    }

    g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].type = MMI_IVEX_MEMORY_TYPE_MED;
    //mmi_ivex_create_cache_service(mode);

#endif

}

static void mmi_ivex_deinit_cache_service()
{
    if(g_ivex_cntx.srv_mediacache_handle == NULL){
        return;
     }
     
#if (__MMI_IMAGE_VIEWER_EX_MEM_SRC__ != MMI_IMAGE_VIEWER_EX_MEM_SRC_MED)
        mmi_ivex_destroy_cache_service();
#endif
}

static void mmi_ivex_entry_screen_bh(void)
{
    S32 ret = SRV_MEDIACACHE_OK;

    mmi_frm_scrn_set_key_proc(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_view_scrn_key_proc);
    mmi_ivex_init_pen_event_handler();

    mmi_ivex_stop_curr_loading_effect();
    
    TMP_TRACE("[IVAPP][TMP]mmi_ivex_active_cache_service---begin");  
    mmi_ivex_active_cache_service(MMI_TRUE, IVEX_CACHE_MODE_FILELIST, MMI_IVEX_TOTAL_SMALL_CACHE_SIZE, MMI_IVEX_TOTAL_LCD_CACHE_SIZE);
    TMP_TRACE("[IVAPP][TMP]mmi_ivex_active_cache_service---end");  

    if(g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK){
       gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);
    
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        if (ret >= SRV_MEDIACACHE_OK)
        {
            mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif

            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
#ifdef __DRM_SUPPORT__
            mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
#endif
        }
        else
        {
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }

        /*Draw osd */
        mmi_ivex_draw_osd_title_layer();
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif

        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }

}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_entry_view_screen
 * DESCRIPTION
 *  Entry function of image viewer EX.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_entry_view_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    S32 ret = SRV_MEDIACACHE_OK;
    ivex_osd_layer_struct display_layer;
    MMI_BOOL entry_ret;
    MMI_BOOL need_retry = MMI_FALSE;
    S32 first_entry = 0;
#if (defined(__MMI_VUI_MEDIAWALL__) && defined(__MMI_SCREEN_SWITCH_EFFECT__))
    U16 ui_direct = g_ivex_cntx.ui_display_rotate;
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_add_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_VIEWSCRN);
    if (!mmi_ivex_check_view_screen_health())
    {
        return;
    }
    if (!mmi_frm_is_in_backward_scenario() && !mmi_frm_group_is_present(g_ivex_cui_gid))
    {
        mmi_frm_group_enter(g_ivex_cui_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    }

#ifdef __MMI_VUI_MEDIAWALL__
    if (!mmi_mediaview_vapp_mediawall_is_terminate())
    {
        /* Should make sure the memory is ready */
        MMI_ASSERT(0);
    }
#endif

    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_EXIT && g_ivex_cntx.app_mem_pool == NULL)
    {
    #ifdef __MMI_VUI_MEDIAWALL__
        if (mmi_mediaview_vapp_mediawall_is_caller())
        {
            if (!mmi_ivex_create_adm(MMI_IVEX_TOTAL_APP_BASED_MEM_POOL_SIZE))
            {
                return;
            }
        }
        else
        {
            if (!mmi_ivex_create_app_based_memory_adm(MMI_IVEX_TOTAL_APP_BASED_MEM_POOL_SIZE, MMI_IVEX_MAX_APP_BASED_MEM_POOL_SIZE))
            {
                return;
            }
        }
    #else
        if (!mmi_ivex_create_app_based_memory_adm(MMI_IVEX_TOTAL_APP_BASED_MEM_POOL_SIZE, MMI_IVEX_MAX_APP_BASED_MEM_POOL_SIZE))
        {
            return;
        }
    #endif
    }

#if (defined(__MMI_VUI_MEDIAWALL__) && defined(__MMI_SCREEN_SWITCH_EFFECT__))
    if (ui_direct == 0)
    {
        gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_PHOTOWALL_TO_IMGVIEWER);
    }
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    entry_ret = mmi_frm_scrn_enter(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_exit_view_screen, mmi_ivex_entry_view_screen, MMI_FRM_FULL_SCRN);
    if (!entry_ret)
    {
        return;
    }
    mmi_ivex_remove_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_VIEWSCRN);

    mmi_frm_scrn_set_leave_proc(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_view_screen_leave_proc);

#ifdef __MMI_SCREEN_LOCK_ANY_TIME__
    mmi_frm_cb_reg_event(EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING, mmi_ivex_screen_locker_event_handler, NULL);
#endif

    /* force all playing keypad tone off */
    //AudioStopReq(GetCurKeypadTone());
    /* entry full screen app */
    entry_full_screen();
    /* clear key events for key release event from last screen */
    ClearKeyEvents();
    gdi_layer_reset_clip();
    /* disable key pad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);
    /* make sure at initiation state*/
    mmi_ivex_init_variable();
    /* check if it is return from interrupt */
    guiBuffer = mmi_frm_scrn_get_gui_buf(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW);
    if (guiBuffer != NULL)
    {
        g_ivex_cntx.is_resume = MMI_TRUE;  /* pause state */
    }
    else
    {
        g_ivex_cntx.is_resume = MMI_FALSE; /* eixt state */
    }
    /* avoid popup will appear before initical key */
    //mmi_frm_scrn_set_key_proc(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_view_scrn_key_proc);
    //mmi_ivex_init_pen_event_handler();
    mmi_ivex_init_osd_icon_info();
    mmi_ivex_get_active_osd_cntx();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    sliding_bar_init(&g_ivex_cntx.osd_sliding_bar,
                     IMG_ID_IVEX_SLIDING_BAR_BG,
                     IMG_ID_IVEX_SLIDER_UP,
                     IMG_ID_IVEX_SLIDER_DOWN,
                     g_ivex_cntx.ui_display_rotate);
    sliding_bar_set_progress_observer(&g_ivex_cntx.osd_sliding_bar, mmi_ivex_sliding_bar_progess_observer, NULL);
#endif

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ENTRY_VIEW_SCR, g_ivex_cntx.view_state);
    
    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_EXIT)
    {
        first_entry = 1;

        mmi_ivex_init_memory_struct_varialbe();
        mmi_ivex_init_cache_service(MMI_TRUE, IVEX_CACHE_MODE_FILELIST, MMI_IVEX_TOTAL_SMALL_CACHE_SIZE, MMI_IVEX_TOTAL_LCD_CACHE_SIZE);

        /* init image info and memory struct */
        mmi_ivex_reset_image_info(&g_ivex_cntx.image_info);
        mmi_ivex_reset_image_info(&g_ivex_cntx.switch_image_info);
        /* malloc memory for file path,  use App-based*/
        g_ivex_cntx.image_info.filepath = kal_adm_alloc(g_ivex_cntx.app_adm_id, SRV_FMGR_PATH_BUFFER_SIZE);
        g_ivex_cntx.switch_image_info.filepath = kal_adm_alloc(g_ivex_cntx.app_adm_id, SRV_FMGR_PATH_BUFFER_SIZE);
        g_ivex_cntx.title_str = kal_adm_alloc(g_ivex_cntx.app_adm_id, SRV_FMGR_PATH_BUFFER_SIZE);
        /* get current file_info */
        mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
        /* for the first entry ivex and for the first display of current image */
        mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
    }
    else if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_PAUSE)  /* pause state */
    {
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        S32 mav_old_frame_index = g_ivex_cntx.image_info.mav_current_frame;
#endif
        
        mmi_frm_scrn_set_key_proc(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_view_scrn_key_proc);
        mmi_ivex_init_pen_event_handler();
        /* back from interrupt, set blt layers will be to do at follows */
        if (g_ivex_cntx.image_info.need_drm_right == MMI_TRUE ||
            g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK ||
            g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_LOADING)
        {
            /* need_right is not a real error code,
            it can not get all info of image when need_right is checked,
            so need get display info again */
            need_retry = MMI_TRUE;
            g_ivex_cntx.image_info.is_err = MMI_FALSE;
#ifndef __IVEX_SUPPORT_IES__
            mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
            mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
#endif
        }
    #if defined(__DRM_SUPPORT__)
        else
        {
            /* check if still have print permission */
            if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_READY)
            {
                mmi_ivex_check_file_drm_right(&g_ivex_cntx.image_info);
                if (g_ivex_cntx.image_info.is_printable == MMI_TRUE &&
                    (MMI_IVEX_DRM_RET_PRINT_VALID & g_ivex_cntx.image_info.drm_valid) != 0)
                {
                    g_ivex_cntx.image_info.is_printable = MMI_TRUE;
                }
                else
                {
                    g_ivex_cntx.image_info.is_printable = MMI_FALSE;
                }
            }
        }
    #endif
#ifdef __IVEX_SUPPORT_IES__
        mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
        mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
#endif
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (mav_old_frame_index < 0 || mav_old_frame_index > (g_ivex_cntx.image_info.mav_total_frames - 1)) {
            g_ivex_cntx.image_info.mav_current_frame = 0;
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_ENTRY_VIEW_RESET_FRAME_INDEX);
        }
        else {
            g_ivex_cntx.image_info.mav_current_frame = mav_old_frame_index;
        }
        sliding_bar_set_progress_ex(&g_ivex_cntx.osd_sliding_bar, (g_ivex_cntx.image_info.mav_current_frame) * 100.0 / (g_ivex_cntx.image_info.mav_total_frames - 1), MMI_FALSE, MMI_FALSE);
#endif
        /* Make sure that the animation is not done */
        g_ivex_cntx.image_info.is_anim_done = MMI_FALSE;
    }
    else
    {
        /* wrong state */
        MMI_ASSERT(0);
    }

    /* alloc and init memory for app use, current and next image use GDI 2xLCD size */
    mmi_ivex_util_malloc_osd_mem();            /* Screen-based (ARGB8888) */

    /* create app used layers*/
    mmi_ivex_create_view_layers();
    mmi_ivex_create_osd_layers();
    /* resize layers */
    mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
    mmi_ivex_view_layer_resizer(g_ivex_cntx.switch_layer_handle, MMI_TRUE);
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_title_layer);
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_panel_layer);
    /* set layer rotate value*/
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.switch_layer_handle, g_ivex_cntx.ui_display_rotate);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_title_layer, g_ivex_cntx.ui_display_rotate);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_panel_layer, g_ivex_cntx.ui_display_rotate);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_sliding_bar.panel_layer);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, g_ivex_cntx.ui_display_rotate);
#endif

    mmi_ivex_layer_set_position(g_ivex_cntx.osd_panel_layer, &g_ivex_cntx.active_osd_layout_ptr->panel);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    gdi_layer_set_position_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer,
                                         g_ivex_cntx.osd_sliding_bar.active_layout->panel_rect.x, 
                                         g_ivex_cntx.osd_sliding_bar.active_layout->panel_rect.y);
#endif

    if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_90)
    {
        display_layer.offset_y = - g_ivex_cntx.active_osd_layout_ptr->title.height;
    }
    else
    {
        display_layer.offset_y = 0;
    }
    display_layer.offset_x = 0;
    mmi_ivex_layer_set_position(g_ivex_cntx.osd_title_layer, &display_layer);
    g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_VIEW;
    g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_SHOW;
    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;

#ifdef __IVEX_SUPPORT_IES__
        g_ivex_cntx.is_scalado_anim = MMI_FALSE;
#endif

    /* set blt layers */
    mmi_ivex_layer_set_blt_layer();

    if(!first_entry){
        TMP_TRACE("[IVAPP][TMP]mmi_ivex_active_cache_service---begin");  
        mmi_ivex_active_cache_service(MMI_TRUE, IVEX_CACHE_MODE_FILELIST, MMI_IVEX_TOTAL_SMALL_CACHE_SIZE, MMI_IVEX_TOTAL_LCD_CACHE_SIZE);
        TMP_TRACE("[IVAPP][TMP]mmi_ivex_active_cache_service---end");  
        if (need_retry)
        {
            srv_mediacache_retry_decode_curr(g_ivex_cntx.srv_mediacache_handle);
        }
    }
#if (defined(__MMI_VUI_MEDIAWALL__) && defined(__MMI_SCREEN_SWITCH_EFFECT__))
    if (ui_direct == 0)
    {
        /* before SSE config, not blt */
        gdi_layer_lock_frame_buffer();
    }
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    if(first_entry){  //post bh
        mmi_ivex_draw_curr_loading_effect();
        gui_start_timer(0, mmi_ivex_entry_screen_bh);
    }

    if(g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK)
    {
        /* first entry or has gained the right from net successfully and come from history or is loading before interrupt */
        g_ivex_cntx.image_info.is_first_ok = MMI_FALSE;
        if(!first_entry){
            ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            if (ret >= SRV_MEDIACACHE_OK)
            {
                mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif

                g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
            #ifdef __DRM_SUPPORT__
                mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
            #endif
            }
            else
            {
                mmi_ivex_process_curr_image_decode_abnormal(ret);
            }
        }
    }
    else
    {
        mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
    }

    /*Draw osd */
    mmi_ivex_draw_osd_title_layer();
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif

#if (defined(__MMI_VUI_MEDIAWALL__) && defined(__MMI_SCREEN_SWITCH_EFFECT__))
        if (ui_direct == 0)
        {
            gdi_layer_unlock_frame_buffer();
            gui_screen_switch_effect_setup(0, 0, 0);
        }
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    /* blt to lcd */
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);

#if (defined(__MMI_VUI_MEDIAWALL__) && defined(__MMI_SCREEN_SWITCH_EFFECT__))
    if (ui_direct == 0)
    {
        gui_screen_switch_effect_run();
    }
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    mmi_ivex_enable_osd_fade(MMI_TRUE);
    if (!MMI_IVEX_LANDSCAPE)
    {
    #if defined(__MMI_IMGVIEWEX_MOTION__)  && !defined(DEBUGE_IVEX_UI_ROTATE)
            mmi_ivex_start_listen_motion();
    #else
        if(g_ivex_cntx.is_play_start)
        {
            g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_PLAY;
            g_ivex_cntx.play_switch_done = MMI_TRUE;
            g_ivex_cntx.is_play_stop = MMI_FALSE;
            g_ivex_cntx.is_play_start = MMI_FALSE;
            display_layer.offset_x = 0;
            display_layer.offset_y = 0;
            mmi_ivex_layer_set_position(g_ivex_cntx.display_layer_handle, &display_layer);
            /* switch layer is not rotated as display. switch layer should have the same rotate angle with ui */
            display_layer.offset_x = mmi_ivex_get_ext_ui_width();
            mmi_ivex_layer_set_position(g_ivex_cntx.switch_layer_handle, &display_layer);
            mmi_ivex_start_play();
        }
    #endif
#ifdef __MMI_IMGVIEWEX_MAV_MOTION__
        mmi_ivex_mav_start_listen_motion();
#endif    
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ENTRY_VIEW_SCR_OVER, g_ivex_cntx.view_state);
}


/* Imageviwer call imgview CUI using start */
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_run_imgview_cui
 * DESCRIPTION
 *  Run image view CUI
 * PARAMETERS
 *  parent_gid           :  [IN]  Image view's parent group id.
 *  filelist             :  [IN]  File list.
 *  start_index          :  [IN]  Start view index.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_run_imgview_cui(mmi_id parent_gid, SRV_FMGR_FILELIST_HANDLE filelist, U32 start_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id imgview_gid;
    U16 ui_direct;
    cui_imgview_ui_direction_enum cui_view_direct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ui_direct = mmi_imgview_get_rotate();
    if (ui_direct == 0)
    {
        cui_view_direct = CUI_IMGVIEW_UI_DIRECTION_VERTICAL;
    }
    else
    {
        cui_view_direct = CUI_IMGVIEW_UI_DIRECTION_HORIZONTAL;
    }

    if ((imgview_gid = cui_imgview_create(parent_gid)) != GRP_ID_INVALID)
    {
        cui_imgview_set_mode_filelist(imgview_gid, filelist,start_index);
        cui_imgview_set_app_id(imgview_gid, mmi_mediaview_get_curr_app_id());
        cui_imgview_set_ui_direction(imgview_gid, cui_view_direct);
        cui_imgview_set_display_cap(imgview_gid, CUI_IMGVIEW_CAP_ALL, MMI_TRUE);
        cui_imgview_run(imgview_gid);
    }
    else
    {
        /*TODO: add trace, enter fail*/
    }
}
/* Imgview CUI using end */

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_preentry_view_screen
 * DESCRIPTION
 *  Pre entry function of image viewer EX.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_preentry_view_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* check filelist valid or not , if total_count < 0, it means folder changed; we need to resort filelist again. */
    g_ivex_cntx.total_image_count = srv_fmgr_filelist_count(g_imgview_fl_hdl);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PRE_ENTRY_VIEW_SCR, g_ivex_cntx.total_image_count);
    if (g_ivex_cntx.total_image_count == 0)
    {
        /* here g_ivex_cui_gid should be GRP_ID_INVALID */
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(STR_GLOBAL_EMPTY),
            MMI_EVENT_FAILURE,
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
        mmi_mediaview_free_filelist();
        return;
    }
    else if (g_ivex_cntx.total_image_count < 0)
    {
        /* here g_ivex_cui_gid should be GRP_ID_INVALID */
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
            MMI_EVENT_FAILURE,
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
        mmi_mediaview_free_filelist();
        return;
    }

    if (mmi_ivex_entry_ivex_is_prohibit())
    {
        mmi_mediaview_free_filelist();
        return;
    }
    /* this is avoid the case: when entry form fmgr, asm not enough and not entry view, then go to imageviewer, asm also not enough, stop other app and entry, so this time must make sure it is not from fmgr. */
    g_ivex_cntx.view_from_fmgr = MMI_FALSE;

    mmi_ivex_run_imgview_cui(g_mediaview_cui_gid,g_imgview_fl_hdl, g_imgview_fl_idx);
}


#define MMI_IVEX_GET_IMG_FROM_IVSR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_ivsrv_error_code
 * DESCRIPTION
 *  matching ivsrv error code.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_process_ivsrv_error_code(GDI_RESULT result, ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SRV_MEDIALIB_ERRC, result);
    switch (result)
    {
        case SRV_MEDIACACHE_ERR_NOT_SUPPORT:
            img_info->err_str_ptr = GetString(STR_GLOBAL_INVALID_FORMAT);
            break;
        default:
            img_info->err_str_ptr = GetString(STR_GLOBAL_INVALID_FORMAT);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_gdi_error_code
 * DESCRIPTION
 *  matching gdi error code.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_process_gdi_error_code(GDI_RESULT result, ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GDI_ERRC, result);
    switch (result)
    {
        case GDI_JPEG_ERR_IMAGE_TOO_LARGE:
#ifdef __PLUTO_MMI_PACKAGE__
            img_info->err_str_ptr = GetString(STR_ID_FMGR_FILE_LIMIT_IMAGE_TOO_LARGE);
#endif
            break;
        case GDI_JPEG_ERR_FILE_FORMAT_WRONG:
            img_info->err_str_ptr = GetString(STR_GLOBAL_INVALID_FORMAT);
            break;
        case GDI_JPEG_ERR_DECODE_TIME_OUT:
            img_info->err_str_ptr = GetString(STR_ID_IMGVIEW_SYSTEM_BUSY);
            break;
        case GDI_IMAGE_ERR_INVALID_IMG_TYPE:
            img_info->err_str_ptr = GetString(STR_GLOBAL_INVALID_FORMAT);
            break;
        case GDI_IMAGE_ERR_UNSUPPORTED_FORMAT:
            img_info->err_str_ptr = GetString(STR_GLOBAL_UNSUPPORTED_FORMAT);
            break;
        default:
            img_info->err_str_ptr = GetString(STR_GLOBAL_INVALID_FORMAT);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_error_string
 * DESCRIPTION
 *  matching ivsrv error code.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_error_string(ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 err_group, err_code;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_mediacache_get_last_err(g_ivex_cntx.srv_mediacache_handle, &err_group, &err_code);

    if (err_group == SRV_MEDIACACHE_ERR_GROUP_GDI)
    {
        mmi_ivex_process_gdi_error_code(err_code, img_info);
    }
    else if (err_group == SRV_MEDIACACHE_ERR_GROUP_MEDIACACHE)
    {
        mmi_ivex_process_ivsrv_error_code(err_code, img_info);
    }
    else /*(err_group == SRV_MEDIACACHE_ERR_GROUP_FS or APP)*/
    {
        img_info->err_str_ptr = GetString(srv_fmgr_fs_error_get_string(err_code));
    }

}

#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_calc_anim_pos
 * DESCRIPTION
 *  Calculate position of current animation frame.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_calc_anim_pos(const ivex_image_info_struct* img_info, S32 *x, S32 *y, S32 *w, S32 *h)
{
    *w = (S32)(img_info->original_width * img_info->curr_zoom_factor);
    *h = (S32)(img_info->original_height * img_info->curr_zoom_factor);

    if(img_info->resized_offset_x > 0){
        *x = -img_info->resized_offset_x;
    }else{
        *x = img_info->draw_offset_x;
    }

    
    if(img_info->resized_offset_y > 0){
        *y = -img_info->resized_offset_y;
    }else{
        *y = img_info->draw_offset_y;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_anim_resize
 * DESCRIPTION
 *  Resize current frame from temp layer to display layer.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_anim_resize(void)
{
    S32 x, y, w, h;
    ivex_anim_context *pcontext = &g_anim_context;
    
    /* compute virtual image position */
    mmi_ivex_calc_anim_pos(&g_ivex_cntx.image_info, &x, &y, &w, &h);
    
    /* resize to display layer*/
    gdi_layer_push_and_set_active(g_ivex_cntx.display_layer_handle);
    //gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_bitblt_resized_with_resizer(
            g_ivex_cntx.temp_display_layer.temp_layer_handle,
            0,
            0,
            pcontext->cache_width-1,
            pcontext->cache_height-1,
            x,
            y,
            x + w - 1,
            y + h - 1,
            GDI_RESIZER_DEFAULT);
    gdi_layer_pop_and_restore_active();
}

#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_display_layer_temp_borrow_large_cache_buffer
 * DESCRIPTION
 *  This will deal with the GIF, M3D and SVG etc. files.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void* mmi_ivex_display_layer_temp_borrow_large_cache_buffer(S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* free large cache to srv */
    srv_mediacache_pause_decode(g_ivex_cntx.srv_mediacache_handle);
    srv_mediacache_remove_cache(g_ivex_cntx.srv_mediacache_handle, g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer);
    srv_mediacache_resume_decode(g_ivex_cntx.srv_mediacache_handle);
    *size = g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size;
    return g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_display_layer_temp_give_back_large_cache_buffer
 * DESCRIPTION
 *  This will deal with the GIF, M3D and SVG etc. files.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_display_layer_temp_give_back_large_cache_buffer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_mediacache_pause_decode(g_ivex_cntx.srv_mediacache_handle);
    srv_mediacache_add_cache(
        g_ivex_cntx.srv_mediacache_handle,
        SRV_MEDIACACHE_CACHE_TYPE_LARGE,
        g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].buffer,
        g_ivex_cntx.mem_cache[MMI_IVEX_LARGE_INDEX].size);
    srv_mediacache_resume_decode(g_ivex_cntx.srv_mediacache_handle);
    g_ivex_cntx.temp_display_layer.temp_layer_buffer = NULL;
    g_ivex_cntx.temp_display_layer.temp_layer_buffer_size = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_display_layer_temp_create
 * DESCRIPTION
 *  This function is called to create resource used by ivexapp.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
gdi_handle mmi_ivex_display_layer_temp_create(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_color_format cf;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* prepare display layer for ivexapp using base layer */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CREATE_VIEW_LAYER);
    g_ivex_cntx.temp_display_layer.temp_layer_buffer
        = (PU8)mmi_ivex_display_layer_temp_borrow_large_cache_buffer(&g_ivex_cntx.temp_display_layer.temp_layer_buffer_size);
#if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
    cf = GDI_COLOR_FORMAT_24;
#else
    cf = GDI_COLOR_FORMAT_16;
#endif
    gdi_layer_create_cf_using_outside_memory(
        cf,
        0,
        0,
        g_ivex_cntx.view_layer_width,
        g_ivex_cntx.view_layer_height,
        &g_ivex_cntx.temp_display_layer.temp_layer_handle,
        g_ivex_cntx.temp_display_layer.temp_layer_buffer,
        g_ivex_cntx.temp_display_layer.temp_layer_buffer_size);
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.temp_display_layer.temp_layer_handle, GDI_COLOR_BLACK);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.temp_display_layer.temp_layer_handle, MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.temp_display_layer.temp_layer_handle, g_ivex_cntx.view_image_rotate);
    return g_ivex_cntx.temp_display_layer.temp_layer_handle;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_display_layer_free_temp
 * DESCRIPTION
 *  This function is called to free resource used by ivexapp
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_display_layer_temp_free(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* free app switch layer handle, display layer use base layer that not need release */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_FREE_VIEW_LAYER);
    if (g_ivex_cntx.temp_display_layer.temp_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_ivex_cntx.temp_display_layer.temp_layer_handle);
    }
    g_ivex_cntx.temp_display_layer.temp_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    mmi_ivex_display_layer_temp_give_back_large_cache_buffer();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_anim_if_need
 * DESCRIPTION
 *  Stop decoding.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_anim_if_need(ivex_image_info_struct* img_info, gdi_handle layer_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_ANMI, img_info->is_animation,img_info->handle);
    if (img_info->is_animation && img_info->handle)
    {
        gdi_image_nb_stop(img_info->handle);
        mmi_ivex_display_layer_temp_free();
        //gdi_anim_stop_all_by_layer(layer_handle);
        img_info->handle = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_anim_finish_callback
 * DESCRIPTION
 *  start timer for next image if animation finished playing.
 * PARAMETERS
 *  result
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_anim_finish_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        g_ivex_cntx.image_info.is_anim_done = MMI_TRUE;
    }
    if (mmi_ivex_if_start_slide_cyclic(g_ivex_cntx.image_state, &g_ivex_cntx.image_info, g_ivex_cntx.is_play_stop))
    {
        if (g_ivex_cntx.play_skip_number == 0)
        {
            mmi_ivex_start_slide_cyclic();
        }
    }
    g_ivex_cntx.image_info.is_anim_done = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_imgadv_decode_done_callback
 * DESCRIPTION
 *  decode done callback function called by gdi
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_decode_done_callback(GDI_RESULT result, gdi_handle handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 is_ok;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DECODE_DONE_CB, result,handle);
    if (mmi_frm_scrn_get_active_id()!=SCR_ID_IMGVIEW_VIEW)
    {
        return;
    }
    if (result == GDI_SUCCEED)
    {
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
    else
    {
        /* this case is that the small image is ok from ivsrv, but ivapp draw animation error (especialy timeout, it maybe docode some clear on layer), should draw the fuzz again. */
        is_ok = srv_mediacache_can_draw_curr(g_ivex_cntx.srv_mediacache_handle);
        if (is_ok != SRV_MEDIACACHE_ERR_CACHE_NOT_READY)
        {
            mmi_ivex_get_curr_img(IVEX_IMG_QTY_MEDIAM);
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        }
    }
}

#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_before_draw_callback
 * DESCRIPTION
 *  callback of before draw frame called by gdi
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_after_each_draw_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_anim_context *pcontext = &g_anim_context;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_scrn_get_active_id()!=SCR_ID_IMGVIEW_VIEW)
    {
        return;
    }
    if (result == GDI_SUCCEED)
    {
        pcontext->is_cache_ok = 1;
        mmi_ivex_anim_resize();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        
    }
}
#else /*__IVEX_SUPPOERT_ANIM_ZOOM__*/
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_before_draw_callback
 * DESCRIPTION
 *  callback of before draw frame called by gdi
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_after_each_draw_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void *buffer_ptr;
    S32   buffer_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_scrn_get_active_id()!=SCR_ID_IMGVIEW_VIEW)
    {
        return;
    }
    if (result == GDI_SUCCEED)
    {
        buffer_ptr = (void*)(((gdi_layer_struct*)g_ivex_cntx.display_layer_handle)->buf_ptr);
    #if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
        buffer_size = MMI_IVEX_SHOWN_IMAGE_LAYER_24BIT;
    #else
        buffer_size = MMI_IVEX_LAYER_SIZE;
    #endif
        memcpy(buffer_ptr, g_ivex_cntx.temp_display_layer.temp_layer_buffer, buffer_size);
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
}

#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_before_draw_callback
 * DESCRIPTION
 *  callback of before draw frame called by gdi
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_before_draw_callback(GDI_RESULT result, gdi_handle handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_scrn_get_active_id()!=SCR_ID_IMGVIEW_VIEW)
    {
        return;
    }
    if (result == GDI_SUCCEED)
    {
        gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);
    }
}

#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_calc_anim_cache_size
 * DESCRIPTION
 *  Calculate size of amination cache.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_calc_anim_cache_size(S32 expectSize, S32 actualSize, S32 orgW, S32 orgH, S32 *resizedW, S32 *resizedH)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (actualSize < expectSize)
    {
        U32 ratio = (U32) sqrt((actualSize * 100.0 * 100.0) / expectSize);

        *resizedW = (S32) (ratio * orgW / 100.0);
        *resizedH = (S32) (ratio * orgH / 100.0);
    }
    else
    {
        *resizedW = orgW;
        *resizedH = orgH;
    }
}


static void mmi_ivex_init_anim_context(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_anim_context *pcontext = &g_anim_context;
    gdi_color_format cf;
    S32 org_w = (img_info->original_width + 1) & (~0x1);
    S32 org_h = img_info->original_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* compute cache size */
    
    /* prepare display layer for ivexapp using base layer */
    g_ivex_cntx.temp_display_layer.temp_layer_buffer
        = (PU8)mmi_ivex_display_layer_temp_borrow_large_cache_buffer(&g_ivex_cntx.temp_display_layer.temp_layer_buffer_size);
#if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
    cf = GDI_COLOR_FORMAT_24;
#else
    cf = GDI_COLOR_FORMAT_16;
#endif

    mmi_ivex_calc_anim_cache_size(org_w * org_h * cf, g_ivex_cntx.temp_display_layer.temp_layer_buffer_size, 
        img_info->original_width, img_info->original_height, &pcontext->cache_width, &pcontext->cache_height);
    MMI_ASSERT(pcontext->cache_width * pcontext->cache_height * cf <= (U32)(g_ivex_cntx.temp_display_layer.temp_layer_buffer_size));

    
    gdi_layer_create_cf_using_outside_memory(
        cf,
        0,
        0,
        pcontext->cache_width,
        pcontext->cache_height,
        &g_ivex_cntx.temp_display_layer.temp_layer_handle,
        g_ivex_cntx.temp_display_layer.temp_layer_buffer,
        g_ivex_cntx.temp_display_layer.temp_layer_buffer_size);
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.temp_display_layer.temp_layer_handle, GDI_COLOR_BLACK);
    gdi_layer_set_source_key_nb_concurrent(g_ivex_cntx.temp_display_layer.temp_layer_handle, MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.temp_display_layer.temp_layer_handle, g_ivex_cntx.view_image_rotate);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_animation_file
 * DESCRIPTION
 *  This will deal with the GIF, M3D and SVG etc. files.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_animation_file(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle temp_layer_handle;
    ivex_anim_context *pcontext = &g_anim_context;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DRAW_ANMI, img_info->is_animation);
    if (!img_info->is_animation)
    {
        return;
    }

    /* Init context */
    MMI_ASSERT(img_info != &g_ivex_cntx.switch_image_info);
    mmi_ivex_init_anim_context(img_info);
    
    temp_layer_handle = g_ivex_cntx.temp_display_layer.temp_layer_handle;
    MMI_ASSERT(img_info->filepath != NULL);
    gdi_layer_push_and_set_active(temp_layer_handle);
    gdi_push_and_set_alpha_blending_source_layer(temp_layer_handle);
    gdi_nb_set_anim_after_each_frame_callback(mmi_ivex_after_each_draw_callback);
    gdi_nb_set_done_callback(mmi_ivex_decode_done_callback);
    //gdi_nb_set_anim_before_frame_callback(mmi_ivex_before_draw_callback);
    gdi_nb_set_anim_last_frame_callback(mmi_ivex_anim_finish_callback);
    gdi_nb_set_blt(MMI_FALSE,MMI_FALSE);
    gdi_anim_set_disable_blt();
    srv_mediacache_pause_decode(g_ivex_cntx.srv_mediacache_handle);
    img_info->handle = gdi_anim_nb_draw_resized_file(
                                0,
                                0,
                                pcontext->cache_width,
                                pcontext->cache_height,
                                img_info->filepath);
    srv_mediacache_resume_decode(g_ivex_cntx.srv_mediacache_handle);
    MMI_ASSERT(img_info->handle != 0);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DRAW_ANMI_1, img_info->handle);
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
    //mmi_ivex_layer_nb_concurrentcy_blt();
}

#else /*__IVEX_SUPPOERT_ANIM_ZOOM__*/
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_animation_file
 * DESCRIPTION
 *  This will deal with the GIF, M3D and SVG etc. files.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_animation_file(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle temp_layer_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DRAW_ANMI, img_info->is_animation);
    if (!img_info->is_animation)
    {
        return;
    }

    temp_layer_handle = mmi_ivex_display_layer_temp_create();
    MMI_ASSERT(img_info->filepath != NULL);
    gdi_layer_push_and_set_active(temp_layer_handle);
    gdi_push_and_set_alpha_blending_source_layer(temp_layer_handle);
    gdi_nb_set_anim_after_each_frame_callback(mmi_ivex_after_each_draw_callback);
    gdi_nb_set_done_callback(mmi_ivex_decode_done_callback);
    //gdi_nb_set_anim_before_frame_callback(mmi_ivex_before_draw_callback);
    gdi_nb_set_anim_last_frame_callback(mmi_ivex_anim_finish_callback);
    gdi_nb_set_blt(MMI_FALSE,MMI_FALSE);
    gdi_anim_set_disable_blt();
    srv_mediacache_pause_decode(g_ivex_cntx.srv_mediacache_handle);
    img_info->handle = gdi_anim_nb_draw_resized_file(
                                img_info->draw_offset_x,
                                img_info->draw_offset_y,
                                img_info->resized_width,
                                img_info->resized_height,
                                img_info->filepath);
    srv_mediacache_resume_decode(g_ivex_cntx.srv_mediacache_handle);
    MMI_ASSERT(img_info->handle != 0);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DRAW_ANMI_1, img_info->handle);
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
    //mmi_ivex_layer_nb_concurrentcy_blt();
}
#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_curr_loading_effect
 * DESCRIPTION
 *  serve loading case.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_curr_loading_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* this case is for rotate view layer under loading, other for switch case of different oriention between view layer and switch layer */
    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90 ||
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
    {
        index = 1;
    }

    if (g_ivex_cntx.pre_image_state == MMI_IVEX_IMAGE_STATE_STILL)
    {
        g_ivex_cntx.image_info.loading_hint_index = 0;
    }
    else
    {
        /* if switch done lead continue loading, should not reset the index */
        g_ivex_cntx.pre_image_state = MMI_IVEX_IMAGE_STATE_STILL;
        /* make sure the icon image is the right loading icon, or assert */
        if (g_ivex_cntx.image_info.loading_hint_index == MMI_IVEX_LOADING_IMAGE_NUMBER)
        {
            g_ivex_cntx.image_info.loading_hint_index = 0;
        }
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CURR_LOADING);
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK); /*make sure the background of layer is black */
    mmi_ivex_draw_alpha_bmp_id_nb_concurrent(g_ivex_cntx.display_layer_handle,
        lock_loading_hint[index].offset_x,
        lock_loading_hint[index].offset_y,
        g_ivex_cntx.display_layer_handle,
        (U16)(IMG_ID_IVEX_HINT_LOADING_0 + g_ivex_cntx.image_info.loading_hint_index));

    mmi_ivex_stop_curr_loading_effect();
    mmi_ivex_start_curr_loading_effect();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_curr_img_draw_error_effect
 * DESCRIPTION
 *  serve error case.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_curr_img_draw_error_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CURR_ERROR);
    mmi_ivex_stop_curr_loading_effect();
    /* if error happen, ivsrv will give the error code at callback fun */
    mmi_ivex_draw_err_effect(g_ivex_cntx.display_layer_handle, MMI_FALSE);
    g_ivex_cntx.image_info.err_img_id = IMG_ID_IVEX_HINT_FILE_ERR;
    g_ivex_cntx.image_info.result = MMI_IVEX_IMG_HEALTH_ERROR;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_curr_img
 * DESCRIPTION
 *  callback function of get current image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ivex_get_curr_img(ivex_img_quality_enum img_qty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret = 0;
    srv_mediacache_img_to_layer_struct area;
    S32 err_group, err_code;
#ifdef __IVEX_SUPPORT_IES__
    S32 need_update_dim = 0;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_CURR_IMG,
        img_qty,g_ivex_cntx.view_from_fmgr,
        g_ivex_cntx.image_info.filelist_index,
        g_ivex_cntx.image_info.draw_offset_x,
        g_ivex_cntx.image_info.draw_offset_y,
        g_ivex_cntx.image_info.resized_offset_x,
        g_ivex_cntx.image_info.resized_offset_y,
        g_ivex_cntx.image_info.resized_width,
        g_ivex_cntx.image_info.resized_height);

    
#ifdef __IVEX_SUPPORT_IES__
    // Pablo: why do we need to clear? for zoom out case?
    // but Scalado won't redarw the buffer if input has not changed...
    if(g_ivex_cntx.image_info.image_type != GDI_IMAGE_TYPE_JPG_FILE && g_ivex_cntx.image_info.image_type != GDI_IMAGE_TYPE_JPG)
        {
#endif
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);
#ifdef __IVEX_SUPPORT_IES__
        }
#endif

#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
    if(g_ivex_cntx.image_info.is_animation && g_anim_context.is_cache_ok){
        mmi_ivex_anim_resize();
        return SRV_MEDIACACHE_OK;
    }
#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/

    area.dst_layer = g_ivex_cntx.display_layer_handle;
    area.src.x = (S32)((float)g_ivex_cntx.image_info.resized_offset_x / (float)g_ivex_cntx.image_info.curr_zoom_factor);
    area.src.y = (S32)((float)g_ivex_cntx.image_info.resized_offset_y / (float)g_ivex_cntx.image_info.curr_zoom_factor);
    area.src.width = (S32)((float)g_ivex_cntx.image_info.resized_width / (float)g_ivex_cntx.image_info.curr_zoom_factor + MMI_IVEX_ROUND_ADD_VALUE);
    area.src.height = (S32)((float)g_ivex_cntx.image_info.resized_height / (float)g_ivex_cntx.image_info.curr_zoom_factor + MMI_IVEX_ROUND_ADD_VALUE);

    if (area.src.width > g_ivex_cntx.image_info.original_width)
    {
        area.src.width = g_ivex_cntx.image_info.original_width;
    }
    if (area.src.width <= 1)
    {
        area.src.width = 1;
    }

    if (area.src.height > g_ivex_cntx.image_info.original_height)
    {
        area.src.height = g_ivex_cntx.image_info.original_height;
    }
    if (area.src.height <= 1)
    {
        area.src.height = 1;
    }

    if (area.src.x + area.src.width >= g_ivex_cntx.image_info.original_width)
    {
        area.src.x = g_ivex_cntx.image_info.original_width - area.src.width;
    }
    if (area.src.y + area.src.height >= g_ivex_cntx.image_info.original_height)
    {
        area.src.y = g_ivex_cntx.image_info.original_height - area.src.height;
    }

    area.dst.x = g_ivex_cntx.image_info.draw_offset_x;
    area.dst.y = g_ivex_cntx.image_info.draw_offset_y;
    area.dst.width = g_ivex_cntx.image_info.resized_width;
    area.dst.height = g_ivex_cntx.image_info.resized_height;
    area.user_data = (void*)g_ivex_cntx.image_info.filelist_index;


    if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_LOADING)
    {
        ret = SRV_MEDIACACHE_ERR_DECODING; /* let IVAPP handle it as loading */
    }
    else
    {
        if (g_ivex_cntx.view_from_fmgr)
        {
            area.callback = mmi_ivex_get_one_img_callback;
        }
        else
        {
            area.callback = mmi_ivex_get_curr_img_callback;
        }

#ifdef __IVEX_SUPPORT_IES__
        if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
            {
                ivex_image_info_struct *pinfo = &g_ivex_cntx.image_info;

        	    switch(g_ivex_cntx.image_info.CAPS_flag)
        	    {
        		    case MMI_IVEX_caps_move:
        		    {
                        need_update_dim = 1;
        			    area.anim_hint = SRV_MEDIACACHE_ANIM_HINT_PAN;
        			    area.delta_x=pinfo->CAPS_move_x;
        			    area.delta_y=pinfo->CAPS_move_y;
        			    pinfo->CAPS_flag=MMI_IVEX_caps_display;

#ifdef  IVAPP_DEBUG

                        //update local offset
                        pinfo->resized_offset_x += area.delta_x;
                        pinfo->resized_offset_y += area.delta_y;
                        if(pinfo->resized_offset_x > (pinfo->resized_image_width - pinfo->resized_width))
                           pinfo->resized_offset_x = pinfo->resized_image_width - pinfo->resized_width;
                        else if(pinfo->resized_offset_x < 0)
                            pinfo->resized_offset_x = 0;
                    
                        if(pinfo->resized_offset_y > (pinfo->resized_image_height - pinfo->resized_height))
                           pinfo->resized_offset_y = pinfo->resized_image_height - pinfo->resized_height;
                        else if(pinfo->resized_offset_y < 0)
                            pinfo->resized_offset_y = 0;
#endif
        		    }
        		    break;
                    case MMI_IVEX_caps_display:
        		    {
        			    area.anim_hint = SRV_MEDIACACHE_ANIM_HINT_NEUTRAL;
        		    }
        		    break;
        		    case MMI_IVEX_caps_stop_animate:
        		    {
                        need_update_dim = 2;
        			    area.anim_hint = SRV_MEDIACACHE_ANIM_HINT_END;
        			    area.zoom_target=g_ivex_cntx.image_info.CAPS_zoom_level;
        			    g_ivex_cntx.image_info.CAPS_flag=MMI_IVEX_caps_display;
        		    }
        		    break;
        		    case MMI_IVEX_caps_running_animate:
        		    {
        			    area.anim_progress=g_ivex_cntx.image_info.CAPS_zoom_progrss;
        			    area.zoom_target=g_ivex_cntx.image_info.CAPS_zoom_level;

        			    area.anim_hint = SRV_MEDIACACHE_ANIM_HINT_RUNNING;
        		    }
        		    break;
        		    case MMI_IVEX_caps_rotation:
        		    {
        			    area.anim_hint = SRV_MEDIACACHE_ANIM_HINT_ROTATION;
        			    area.rotation_step = (srv_mediacache_rotation_step)(g_ivex_cntx.image_info.CAPS_rotation_step);
                        g_ivex_cntx.image_info.CAPS_flag=MMI_IVEX_caps_display;
        		    }
        		    break;
        	    }
            }
#endif /* __IVEX_SUPPORT_IES__ */

        if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_GIF ||
                g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_GIF_FILE)
        {
            gdi_layer_set_source_key_nb_concurrent(area.dst_layer, MMI_TRUE, GDI_COLOR_TRANSPARENT);
        }else{
            gdi_layer_set_source_key_nb_concurrent(area.dst_layer, MMI_FALSE, GDI_COLOR_TRANSPARENT);
        }

        /*set image quality*/
        if(img_qty == IVEX_IMG_QTY_HIGH){
            srv_mediacache_set_qulity_high();
        }else if(img_qty == IVEX_IMG_QTY_LOW){
            srv_mediacache_set_qulity_low();
        }
        
        TMP_TRACE1("[IVAPP][YWY]srv_mediacache_get_curr_img_to_layer---begin, line=%d", __LINE__);  
        ret = srv_mediacache_get_curr_img_to_layer(g_ivex_cntx.srv_mediacache_handle, &area);
        TMP_TRACE1("[IVAPP][YWY]srv_mediacache_get_curr_img_to_layer---end, line=%d", __LINE__);  

        if (ret == GDI_JPEG_ERR_DECODE_TIME_OUT)
        {
            srv_mediacache_get_last_err(g_ivex_cntx.srv_mediacache_handle, &err_group, &err_code);
            if (err_group == SRV_MEDIACACHE_ERR_GROUP_GDI)
            {
                srv_mediacache_retry_decode_curr(g_ivex_cntx.srv_mediacache_handle);
                ret = srv_mediacache_get_curr_img_to_layer(g_ivex_cntx.srv_mediacache_handle, &area);
            }
        }
        g_ivex_cntx.image_info.is_from_l1 = MMI_FALSE;
        if (ret >= SRV_MEDIACACHE_OK)
        {
#ifdef __IVEX_SUPPORT_IES__
        /* update dimension */
        if(need_update_dim != 0){
            S32 retval;
#ifdef IVAPP_DEBUG
            if(need_update_dim == 1){
            
                TMP_TRACE2("[IVAPP] After move should be: x = %d, y = %d", 
                    g_ivex_cntx.image_info.resized_offset_x, g_ivex_cntx.image_info.resized_offset_y);  
            }
#endif
            retval = srv_mediacache_preview_get_current_rect(g_ivex_cntx.srv_mediacache_handle, 
                &g_ivex_cntx.image_info.resized_offset_x, &g_ivex_cntx.image_info.resized_offset_y, 
                &g_ivex_cntx.image_info.resized_width, &g_ivex_cntx.image_info.resized_height);
            MMI_ASSERT(retval == SRV_MEDIACACHE_OK);
            TMP_TRACE2("[IVAPP] After move is: x = %d, y = %d", 
                g_ivex_cntx.image_info.resized_offset_x, g_ivex_cntx.image_info.resized_offset_y);  
            TMP_TRACE2("[IVAPP] After move is: disp_w = %d, disp_h = %d", 
                            g_ivex_cntx.image_info.resized_width, g_ivex_cntx.image_info.resized_height); 

            if(need_update_dim == 2)
            {
                retval = srv_mediacache_preview_get_current_size(g_ivex_cntx.srv_mediacache_handle,
                    &g_ivex_cntx.image_info.resized_image_width, 
                    &g_ivex_cntx.image_info.resized_image_height);
                MMI_ASSERT(retval == SRV_MEDIACACHE_OK);
                
                TMP_TRACE2("[IVAPP] After zoom: img_w = %d, img_h = %d", 
                                g_ivex_cntx.image_info.resized_image_width, g_ivex_cntx.image_info.resized_image_height);  
            }
        }
#endif
            if (SRV_MEDIACACHE_OK_L1 == srv_mediacache_get_last_source(g_ivex_cntx.srv_mediacache_handle))
            {
                g_ivex_cntx.image_info.is_from_l1 = MMI_TRUE;
            }
            else
            {
                g_ivex_cntx.image_info.is_from_l1 = MMI_FALSE;
            }
        }
        if (ret < SRV_MEDIACACHE_OK)
        {
            mmi_ivex_get_error_string(&g_ivex_cntx.image_info);
        }
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_CURR_IMG,
        ret,g_ivex_cntx.view_from_fmgr,
        g_ivex_cntx.image_info.filelist_index,
        g_ivex_cntx.image_info.draw_offset_x,
        g_ivex_cntx.image_info.draw_offset_y,
        g_ivex_cntx.image_info.resized_offset_x,
        g_ivex_cntx.image_info.resized_offset_y,
        g_ivex_cntx.image_info.resized_width,
        g_ivex_cntx.image_info.resized_height);
    return ret;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_curr_image_decode_abnormal
 * DESCRIPTION
 *  Deal with abnormal case when decode error.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_process_curr_image_decode_abnormal(S32 ret)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CURR_ABNORMAL,ret);
    if (ret == SRV_MEDIACACHE_ERR_DECODING)
    {
        mmi_ivex_draw_curr_loading_effect();
    }
    else
    {
        mmi_ivex_curr_img_draw_error_effect();
        mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_disable_image_zoomable
 * DESCRIPTION
 *  reset image zoomable value.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_disable_image_zoomable(ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    img_info->is_zoomin_able = MMI_FALSE;
    img_info->is_zoomout_able = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_and_redecode
 * DESCRIPTION
 *  Check if need redecode, if yes, redecode. return true.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_check_and_redecode(S32 err_group, S32 err_code, ivex_redecode_case_enum *redecode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 redraw_ok;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    redraw_ok = srv_mediacache_can_draw_curr(g_ivex_cntx.srv_mediacache_handle);
    if (redraw_ok == SRV_MEDIACACHE_OK_L1 ||
        redraw_ok == SRV_MEDIACACHE_OK_L2)
    {
        if (err_code == GDI_JPEG_ERR_DECODE_TIME_OUT)
        {
            if (g_ivex_cntx.redecode_time > 3)
            {
                /* if three times not decode success, will not to try again */
                g_ivex_cntx.redecode_time = 0;
                *redecode = MMI_IVEX_REDECODE_CASE_BUSY_OVER;
            }
            else
            {
                g_ivex_cntx.redecode_time++;
                srv_mediacache_retry_decode_curr(g_ivex_cntx.srv_mediacache_handle);
                *redecode = MMI_IVEX_REDECODE_CASE_BUSY;
            }
        }
        else if (err_code >= SRV_MEDIACACHE_OK)
        {
            /* This case is that the first small image come from DB or special for acc */
            *redecode = MMI_IVEX_REDECODE_CASE_FROM_DB;
        }
        else
        {
            /* This case is that the current shown small image and callback is error for large */
            *redecode = MMI_IVEX_REDECODE_CASE_NONE;
        }
    }
    else if (redraw_ok == SRV_MEDIACACHE_ERR_CACHE_NOT_READY)
    {
        *redecode = MMI_IVEX_REDECODE_CASE_ERROR;
    }
    else
    {
        *redecode = MMI_IVEX_REDECODE_CASE_LARGE_OK;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_mediacache_get_curr_img_callback
 * DESCRIPTION
 *  callback function of get current image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_curr_img_callback(S32 err_group, S32 err_code, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    S32 err_code_temp;
    ivex_redecode_case_enum redecode;
    MMI_BOOL is_from_loading = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT (g_ivex_cntx.view_state != MMI_IVEX_VIEW_STATE_EXIT);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_CURR_CB,
        g_ivex_cntx.view_state,
        g_ivex_cntx.image_state,
        err_group,err_code,
        g_ivex_cntx.image_info.filelist_index,
        g_ivex_cntx.image_info.draw_offset_x,
        g_ivex_cntx.image_info.draw_offset_y,
        g_ivex_cntx.image_info.resized_offset_x,
        g_ivex_cntx.image_info.resized_offset_y,
        g_ivex_cntx.image_info.resized_width,
        g_ivex_cntx.image_info.resized_height,
        g_ivex_cntx.image_info.is_first_ok,
        g_ivex_cntx.image_info.is_animation);
    if (user_data != (void*)g_imgview_fl_idx)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_CURR_CB,
            0,0,0,0,g_imgview_fl_idx,1,1,1,1,2,2,2,2);
        return;
    }

    MMI_ASSERT(srv_mediacache_get_curr_index(g_ivex_cntx.srv_mediacache_handle) == g_imgview_fl_idx);

    if (g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_animation)
    {
        /* APP has drawing it, not need SRV redraw it */
        return;
    }

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_mav)
    {
        /* APP has drawn it, so SRV need not redraw it */
        return;
    }
#endif

    TMP_TRACE3("[IVAPP][TMP]get img cb: L1:%d, zoomin:%d, zoom_cnt:%d", 
        g_ivex_cntx.image_info.is_from_l1, 
        g_ivex_cntx.is_zoomin, g_ivex_cntx.image_info.zoom_cnt);

    if (g_ivex_cntx.image_info.is_from_l1)
    {
        /* Do nothing */
        g_ivex_cntx.image_info.is_from_l1 = MMI_FALSE;
        if (g_ivex_cntx.image_info.zoom_cnt == 0)
        {
            return;
        }
        else if (g_ivex_cntx.is_zoomin)
        {
            return;
        }
        else
        {
            /* Do nothing */
        }
    }

    err_code_temp = err_code;

    mmi_ivex_check_and_redecode(err_group, err_code, &redecode);
    if (redecode == MMI_IVEX_REDECODE_CASE_BUSY)
    {
        /* this case need redecode */
        err_code_temp = SRV_MEDIACACHE_OK;
    }
    else if (redecode == MMI_IVEX_REDECODE_CASE_BUSY_OVER ||
                redecode == MMI_IVEX_REDECODE_CASE_NONE)
    {
        /* there is small cache to draw, but current meets error or redecode more than three times */
        return;
    }
    else
    {
        /* MMI_IVEX_REDECODE_CASE_ERROR, do nothing, this callback from loading */
        /* MMI_IVEX_REDECODE_CASE_LARGE_OK, do nothing, this callback from large decode done */
        /* MMI_IVEX_REDECODE_CASE_FROM_DB, do nothing, this callback from DB return */
        S32 file_count = srv_fmgr_filelist_count(g_imgview_fl_hdl);
        if (file_count <= 0)
        {
            /* This case for at play state, current image is at loading, delete one image, IVSRV will decode valid image error as -1404,
            here ivapp cover it */
            mmi_ivex_display_error_sg(
                g_ivex_cui_gid,
                (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
                MMI_EVENT_FAILURE,
                (U16)g_ivex_cntx.ui_display_rotate,
                MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);

            mmi_mediaview_free_filelist();
            return;
        }
    }
    is_from_loading = g_ivex_cntx.image_info.is_loading;
    mmi_ivex_stop_curr_loading_effect();

    if (err_code_temp < SRV_MEDIACACHE_OK)
    {
        /* clear the bg as black */
        gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);

        if (err_group == SRV_MEDIACACHE_ERR_GROUP_FS)
        {
            g_ivex_cntx.image_info.err_str_ptr = GetString(srv_fmgr_fs_error_get_string(err_code));
        }
        else if (err_group == SRV_MEDIACACHE_ERR_GROUP_GDI)
        {
            mmi_ivex_process_gdi_error_code(err_code, &g_ivex_cntx.image_info);
        }
        else if (err_group == SRV_MEDIACACHE_ERR_GROUP_MEDIACACHE)
        {
            mmi_ivex_process_ivsrv_error_code(err_code, &g_ivex_cntx.image_info);
        }
        mmi_ivex_curr_img_draw_error_effect();
        mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    }
    else
    {
        if (g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK &&
            (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL ||
             (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY &&
              g_ivex_cntx.play_switch_done == MMI_TRUE)))
        {
            /* clear the bg as black */
            gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);

            /* try to redraw more clear again */
            ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            if (ret >= SRV_MEDIACACHE_OK)
            {
                if (!g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_animation)
                {
                    mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
                    g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
                }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                if (!g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_mav)
                {
                    mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
                    g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
                }
#endif
            #ifdef __DRM_SUPPORT__
                if (g_ivex_cntx.image_info.is_drm)
                {
                    if (g_ivex_cntx.image_info.drm_state == MMI_IVEX_DRM_STATE_EXIT) /* the image is decoding when first get image, not cosume the right. here should consume */
                    {
                        mmi_ivex_start_drm_consume(&g_ivex_cntx.image_info);
                    }
                }
            #endif
                mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            }
            else
            {
                /* no should come here because the first srv_mediacache_get_curr_img_to_layer has been ok whatever it is clear or not */
                MMI_ASSERT(0);
            }
        }
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_CURR_CB_OVER);
    /* blt to lcd */
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

    if (mmi_ivex_if_start_slide_cyclic(g_ivex_cntx.image_state, &g_ivex_cntx.image_info, g_ivex_cntx.is_play_stop) &&
        is_from_loading == MMI_TRUE)
    {
        mmi_ivex_start_slide_cyclic();
    }
}


#define MMI_IVEX_FOR_FMGR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_entry_ivex_prohibit_prompt
 * DESCRIPTION
 *  for performance, when (BT) or TV running at background, exit ivex
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_entry_ivex_prohibit_prompt(U16 strid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_group_node_struct group_info;
    mmi_imgview_popup_result_process_enum process;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MEDIAVIEW_IVEX_CUI_CLOSE_BLOCK, *media_viewer_id;
    if (g_ivex_cui_gid == GRP_ID_INVALID)
    {
        process = MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE;
    }
    else
    {
        mmi_frm_group_get_info(g_ivex_cui_gid, &group_info);
        if(group_info.state == MMI_SCENARIO_STATE_CREATE)
        {
            mmi_frm_group_enter(g_ivex_cui_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
        }
        process = MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP;
    }
    mmi_ivex_display_error_sg(
        g_ivex_cui_gid,
        (UI_string_type) GetString(strid),
        MMI_EVENT_FAILURE,
        (U16)g_ivex_cntx.ui_display_rotate,
        process);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_entry_ivex_is_prohibit
 * DESCRIPTION
 *  for performance, when (BT) or TV running at background, exit ivex
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_entry_ivex_is_prohibit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_prohibit = MMI_FALSE;
    U16 strid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MEDIAVIEW_IVEX_CUI_CLOSE_BLOCK, *media_viewer_id;

    if (mmi_am_is_using_media_memory())
    {
        S32 type;
        strid = mmi_am_get_error_info(MMI_MRE_ERR_IS_UNAVAILABLE, &type);
        is_prohibit = MMI_TRUE;
    }
    if (is_prohibit)
    {
        mmi_ivex_entry_ivex_prohibit_prompt(strid);
    }
    return is_prohibit;
}


/*****************************************************************************
 * FUNCTION
 *  srv_mediacache_get_curr_img_callback
 * DESCRIPTION
 *  callback function of get current image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_one_img_callback(S32 err_group, S32 err_code, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    S32 err_code_temp;
    S32 is_ok;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT (g_ivex_cntx.view_state != MMI_IVEX_VIEW_STATE_EXIT);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_ONE_CB,
        g_ivex_cntx.view_state,
        err_group,
        err_code,
        g_ivex_cntx.image_info.is_first_ok,
        g_ivex_cntx.image_info.is_animation);
    if (g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_animation)
    {
        /* APP has drawing it, not need SRV redraw it */
        return;
    }

    err_code_temp = err_code;

    is_ok= srv_mediacache_can_draw_curr(g_ivex_cntx.srv_mediacache_handle);
    if (is_ok != SRV_MEDIACACHE_ERR_CACHE_NOT_READY)
    {
        err_code_temp = SRV_MEDIACACHE_OK;
    }

    mmi_ivex_stop_curr_loading_effect();

    if (err_code_temp < SRV_MEDIACACHE_OK)
    {
        /* clear the bg as black */
        gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);
        if (err_group == SRV_MEDIACACHE_ERR_GROUP_FS)
        {
            g_ivex_cntx.image_info.err_str_ptr = GetString(srv_fmgr_fs_error_get_string(err_code));
        }
        else if (err_group == SRV_MEDIACACHE_ERR_GROUP_GDI)
        {
            mmi_ivex_process_gdi_error_code(err_code, &g_ivex_cntx.image_info);
        }
        else if (err_group == SRV_MEDIACACHE_ERR_GROUP_MEDIACACHE)
        {
            mmi_ivex_process_ivsrv_error_code(err_code, &g_ivex_cntx.image_info);
        }
        mmi_ivex_curr_img_draw_error_effect();
        mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    }
    else
    {
        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL ||
            (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY &&
            g_ivex_cntx.play_switch_done == MMI_TRUE))
        {
            /* clear the bg as black */
            gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);
            /* try to redraw more clear again */
            ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            if (ret >= SRV_MEDIACACHE_OK)
            {
                if (!g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_animation)
                {
                    mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
                    g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
                }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                if (!g_ivex_cntx.image_info.is_first_ok && g_ivex_cntx.image_info.is_mav)
                {
                    mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
                    g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
                }
#endif
            #ifdef __DRM_SUPPORT__
                if (g_ivex_cntx.image_info.is_drm)
                {
                    if (g_ivex_cntx.image_info.drm_state == MMI_IVEX_DRM_STATE_EXIT) /* the image is decoding when first get image, not cosume the right. here should consume */
                    {
                        mmi_ivex_start_drm_consume(&g_ivex_cntx.image_info);
                    }
                }
            #endif
                mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            }
            else
            {
                /* no should come here because the first srv_mediacache_get_curr_img_to_layer has been ok whatever it is clear or not */
                MMI_ASSERT(0);
            }
        }
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_ONE_CB_OVER);
    /* blt to lcd */
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_all_ext
 * DESCRIPTION
 *  stop all operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_all_ext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_stop_curr_loading_effect();
    mmi_ivex_stop_zoomin();
    mmi_ivex_stop_zoomout();
    mmi_ivex_enable_osd_fade(MMI_FALSE);
    mmi_ivex_stop_osd_fade_out();
    mmi_ivex_stop_osd_fade_in();
    mmi_ivex_stop_rotate();
    mmi_ivex_stop_move();
#if defined(__MMI_TOUCH_SCREEN__)
    mmi_ivex_non_move_axis_stop_bounce();
    mmi_ivex_stop_auto_move();
#endif
    mmi_ivex_stop_renderer_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_del_view_scr_callback_ext
 * DESCRIPTION
 *  delete view screen callback handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_ivex_del_view_scr_callback_ext(void* ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_DEL_VIEW_SCR_CB_EXT);
    mmi_ivex_stop_all_ext();
    mmi_ivex_enable_osd_fade(MMI_FALSE);
    /* free buffer */
    if (g_ivex_cntx.image_info.filepath != NULL)
    {
        gui_free(g_ivex_cntx.image_info.filepath);
        g_ivex_cntx.image_info.filepath = NULL;
    }
    kal_adm_free(g_ivex_cntx.app_adm_id, g_ivex_cntx.title_str);
    g_ivex_cntx.title_str = NULL;
    /*deinit cache service */
    mmi_ivex_deinit_cache_service();
    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_VIEW)
    {
        mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
        mmi_ivex_free_scr_related_resource();
        mmi_ivex_destroy_app_based_memory_adm();
    }
    else if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_PAUSE)
    {
        mmi_ivex_destroy_app_based_memory_adm();
    }
    else
    {
        MMI_ASSERT(0);
    }

#ifdef __DRM_SUPPORT__
    if (g_ivex_cntx.image_info.is_drm)
    {
        mmi_ivex_stop_drm_consume();
    }
#endif

    g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_EXIT;
    g_ivex_cntx.view_from_fmgr = MMI_FALSE;
    g_ivex_cntx.caller_app_id = 0;
    g_ivex_cntx.view_one_from_other_app = MMI_FALSE;
    return 0;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_exit_view_screen_ext
 * DESCRIPTION
 *  ivex exit screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_exit_view_screen_ext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_direct_exit;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_EXIT_VIEW_SCR_EXT, g_ivex_cntx.renderer_ref_count);
    g_ivex_cntx.key_press = MMI_FALSE;
    is_direct_exit = mmi_ivex_is_direct_exit_state(g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_VIEWSCRN_EXT);
    if (is_direct_exit)
    {
        return;
    }

#ifdef __MMI_IMGVIEWEX_MOTION__
    if (!MMI_IVEX_LANDSCAPE)
    {
        mmi_ivex_stop_listen_motion();
    }
#endif
#ifdef __MMI_IMGVIEWEX_MAV_MOTION__
    mmi_ivex_mav_stop_listen_motion();
#endif    

#ifdef __MMI_TOUCH_SCREEN__
    /* restore to normal state */
    mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_1, MMI_PEN_SAMPLING_PERIOD_2);
#endif

    /* remove screen related cache */
    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_VIEW)
    {
        /* for MAUI_02318244, back up usable variable
        cause they may be changed when in bellow statement before be used */
        MMI_BOOL                ui_rotating = g_ivex_cntx.ui_rotating;
        ivex_rotate_state_enum  rot_oriention = g_ivex_cntx.rot_oriention;

        mmi_ivex_stop_all_ext();
        mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
        /* Inactive cache service */
        mmi_ivex_inactive_cache_service();
        mmi_ivex_make_bg_when_exit();
        mmi_ivex_free_scr_related_resource();
    #ifdef __DRM_SUPPORT__
        if (g_ivex_cntx.image_info.is_drm &&
            g_ivex_cntx.image_info.drm_state == MMI_IVEX_DRM_STATE_CONSUME)
        {
            mmi_ivex_pause_drm_consume(&g_ivex_cntx.image_info);
        }
    #endif

        if(ui_rotating == MMI_TRUE && /* ui is switching and osd is fading out */
           rot_oriention == MMI_IVEX_ROTATE_NONE) /* rotate error or loading */
        {
            /* this is for MAUI_02318244,
            when rotate error, will swith image first and then start to fade osd,
            if interrup comes during fade out, will be switched image and un-swiched osd */
            g_ivex_cntx.ui_display_rotate =
                g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0 ?
                GDI_LCD_LAYER_ROTATE_90 : GDI_LCD_LAYER_ROTATE_0;
        }
        g_ivex_cntx.ui_rotating = MMI_FALSE;

        g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_PAUSE;
    }
    else if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_EXIT)
    {
        /* do nothing, already exit */
    }
    else
    {
        /* wrong state */
        MMI_ASSERT(0);
    }
    /* re-enable keypad tone */
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);
    /* this will force title status to redraw */
    entry_full_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_screen_ext_leave_proc
 * DESCRIPTION
 *  Ext view screen leave proc.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
mmi_ret mmi_ivex_view_screen_ext_leave_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(evt->evt_id)
    {
    case EVT_ID_SCRN_GOBACK:
        break;
    case EVT_ID_SCRN_DELETE_REQ:
        break;
    case EVT_ID_SCRN_DEINIT:
        mmi_ivex_del_view_scr_callback_ext(NULL);
        break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_view_screen_ext_health
 * DESCRIPTION
 *  Check screen health state when from history.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_view_screen_ext_health(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_exist = MMI_FALSE;
    FS_HANDLE file_handle = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_is_in_backward_scenario())
    {
        /* add this for check if the first letter is a valide drv letter.
        cause MMS will pass a virtual filepath to image viewer, the first is not a valide drv letter */
        if(srv_fmgr_drv_get_type(g_ivex_cntx.image_info.filepath[0]) >= FS_NO_ERROR)
        {
            if ((FS_GetDevStatus(g_ivex_cntx.image_info.filepath[0] ,FS_MOUNT_STATE_ENUM) != FS_NO_ERROR)  ||
                g_ivex_cntx.is_card_out == MMI_TRUE)
            {
                /* This is for quickly plug in/out card case, if can not resotre some info when plug out, enven if plug in quickly, still not allow to entry */
                g_ivex_cntx.is_card_out = MMI_FALSE;
                mmi_mediaview_close_view_cui(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID);
                return MMI_FALSE;
            }
        }

        /* file not found, also exit  */
        is_exist = mmi_ivex_is_file_exist(g_ivex_cntx.image_info.filepath, &file_handle);
        if (!is_exist)
        {
            if (file_handle == FS_FILE_NOT_FOUND ||
                file_handle == FS_DRIVE_NOT_FOUND)
            {
                mmi_ivex_display_error_sg(
                    g_ivex_cui_gid,
                    (UI_string_type)GetString(srv_fmgr_fs_error_get_string(file_handle)),
                    (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(file_handle),
                    (U16)g_ivex_cntx.ui_display_rotate,
                    MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);
                return MMI_FALSE;
            }
        }
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_entry_view_screen_ext
 * DESCRIPTION
 *  Entry function of image viewer EX from FMGR.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_entry_view_screen_ext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer;
    S32 ret = SRV_MEDIACACHE_OK;
    MMI_BOOL entry_ret;
    ivex_osd_layer_struct display_layer;
    MMI_BOOL need_retry = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_add_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_VIEWSCRN_EXT);
    if (!mmi_ivex_check_view_screen_ext_health())
    {
        return;
    }
    if (!mmi_frm_is_in_backward_scenario())
    {
        mmi_frm_group_enter(g_ivex_cui_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    }

    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_EXIT && g_ivex_cntx.app_mem_pool == NULL)
    {
        if (!mmi_ivex_create_app_based_memory_adm(MMI_IVEX_FMGR_APP_BASED_MEM_POOL_SIZE, MMI_IVEX_FMGR_APP_BASED_MEM_POOL_SIZE))
        {
            return;
        }
    }
    entry_ret = mmi_frm_scrn_enter(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_exit_view_screen_ext, mmi_ivex_entry_view_screen_ext, MMI_FRM_FULL_SCRN);
    if (!entry_ret)
    {
        return;
    }
    mmi_ivex_remove_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_VIEWSCRN_EXT);
    mmi_frm_scrn_set_leave_proc(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_view_screen_ext_leave_proc);
    //AudioStopReq(GetCurKeypadTone());
    entry_full_screen();
    ClearKeyEvents();
    gdi_layer_reset_clip();
    mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);
    /* make sure at initiation state*/
    mmi_ivex_init_variable();
    /* set TRUE again to avoid reentry from fmgr */
    g_ivex_cntx.view_from_fmgr = MMI_TRUE;
    /* check if it is return from interrupt */
    guiBuffer = mmi_frm_scrn_get_gui_buf(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW);
    if (guiBuffer != NULL)
    {
        g_ivex_cntx.is_resume = MMI_TRUE;  /* pause state */
    }
    else
    {
        g_ivex_cntx.is_resume = MMI_FALSE; /* eixt state */
    }

    /* avoid popup will appear before initical key */
    mmi_frm_scrn_set_key_proc(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, mmi_ivex_view_scrn_key_proc);
    mmi_ivex_init_pen_event_handler();
    mmi_ivex_init_osd_icon_info();
    mmi_ivex_get_active_osd_cntx();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    sliding_bar_init(&g_ivex_cntx.osd_sliding_bar,
                     IMG_ID_IVEX_SLIDING_BAR_BG,
                     IMG_ID_IVEX_SLIDER_UP,
                     IMG_ID_IVEX_SLIDER_DOWN,
                     g_ivex_cntx.ui_display_rotate);
    sliding_bar_set_progress_observer(&g_ivex_cntx.osd_sliding_bar, mmi_ivex_sliding_bar_progess_observer, NULL);
#endif
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ENTRY_VIEW_SCR_EXT, g_ivex_cntx.view_state);
    if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_EXIT)
    {
        mmi_ivex_init_memory_struct_varialbe();

        /* Init cache service */
        mmi_ivex_init_cache_service(MMI_FALSE, IVEX_CACHE_MODE_FILE, MMI_IVEX_TOTAL_SMALL_CACHE_SIZE_SINGLE_VIEW, MMI_IVEX_TOTAL_LCD_CACHE_SIZE_SINGLE_VIEW);
        /* init image info and memory struct */
        mmi_ivex_reset_image_info(&g_ivex_cntx.image_info);

        g_ivex_cntx.title_str = kal_adm_alloc(g_ivex_cntx.app_adm_id, SRV_FMGR_PATH_BUFFER_SIZE);
        mmi_ivex_get_image_base_info(0, MMI_TRUE, &g_ivex_cntx.image_info);
        mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
    }
    else if (g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_PAUSE)  /* pause state */
    {
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        S32 mav_old_frame_index = g_ivex_cntx.image_info.mav_current_frame;
#endif
        if (g_ivex_cntx.image_info.need_drm_right == MMI_TRUE ||
            g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK ||
            g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_LOADING)
        {
            need_retry = MMI_TRUE;
            g_ivex_cntx.image_info.is_err = MMI_FALSE;
#ifndef __IVEX_SUPPORT_IES__
            mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
            mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
#endif
        }
    #if defined(__DRM_SUPPORT__)
        else
        {
            /* check if still have print permission */
            if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_READY)
            {
                mmi_ivex_check_file_drm_right(&g_ivex_cntx.image_info);
                if (g_ivex_cntx.image_info.is_printable == MMI_TRUE &&
                    (MMI_IVEX_DRM_RET_PRINT_VALID & g_ivex_cntx.image_info.drm_valid) != 0)
                {
                    g_ivex_cntx.image_info.is_printable = MMI_TRUE;
                }
                else
                {
                    g_ivex_cntx.image_info.is_printable = MMI_FALSE;
                }
            }
        }
    #endif
#ifdef __IVEX_SUPPORT_IES__
        mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
        mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
#endif
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (mav_old_frame_index < 0 || mav_old_frame_index > (g_ivex_cntx.image_info.mav_total_frames - 1)) {
            g_ivex_cntx.image_info.mav_current_frame = 0;
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_ENTRY_VIEW_RESET_FRAME_INDEX);
        }
        else {
            g_ivex_cntx.image_info.mav_current_frame = mav_old_frame_index;
        }
        sliding_bar_set_progress_ex(&g_ivex_cntx.osd_sliding_bar, (g_ivex_cntx.image_info.mav_current_frame) * 100.0 / (g_ivex_cntx.image_info.mav_total_frames - 1), MMI_FALSE, MMI_FALSE);
#endif

    }
    else
    {
        MMI_ASSERT(0);
    }

    //mmi_ivex_util_malloc_large_cache();         /* MED */   
    
    mmi_ivex_util_malloc_osd_mem();            /* Screen-based (ARGB8888) */
    mmi_ivex_create_view_layers();
    mmi_ivex_create_osd_layers();
    mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_panel_layer);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_panel_layer, g_ivex_cntx.ui_display_rotate);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_sliding_bar.panel_layer);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, g_ivex_cntx.ui_display_rotate);
#endif

    /*Draw osd */
    mmi_ivex_draw_osd_title_layer();
    mmi_ivex_draw_osd_panel_layer();
    mmi_ivex_layer_set_position(g_ivex_cntx.osd_panel_layer, &g_ivex_cntx.active_osd_layout_ptr->panel);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
    gdi_layer_set_position_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer,
                                         g_ivex_cntx.osd_sliding_bar.active_layout->panel_rect.x, 
                                         g_ivex_cntx.osd_sliding_bar.active_layout->panel_rect.y);
#endif
    if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_90)
    {
        display_layer.offset_y = - g_ivex_cntx.active_osd_layout_ptr->title.height;
    }
    else
    {
        display_layer.offset_y = 0;
    }
    display_layer.offset_x = 0;
    mmi_ivex_layer_set_position(g_ivex_cntx.osd_title_layer, &display_layer);
    /* set blt layers */
    g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_VIEW;
    g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_SHOW;

#ifdef __IVEX_SUPPORT_IES__
            g_ivex_cntx.is_scalado_anim = MMI_FALSE;
#endif

    mmi_ivex_layer_set_blt_layer();
/*
    srv_mediacache_add_cache(
        g_ivex_cntx.srv_mediacache_handle,
        SRV_MEDIACACHE_CACHE_TYPE_LARGE,
        g_ivex_cntx.mem_large_cache.buffer,
        g_ivex_cntx.mem_large_cache.size);
  */  
    mmi_ivex_active_cache_service(MMI_FALSE, IVEX_CACHE_MODE_FILE,MMI_IVEX_TOTAL_SMALL_CACHE_SIZE_SINGLE_VIEW, MMI_IVEX_TOTAL_LCD_CACHE_SIZE_SINGLE_VIEW);

    if (need_retry)
    {
        srv_mediacache_retry_decode_curr(g_ivex_cntx.srv_mediacache_handle);
    }
    if (g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK)
    {
        /* first entry or has gained the right from net successfully and come from history or is loading before interrupt */
        g_ivex_cntx.image_info.is_first_ok = MMI_FALSE;
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        if (ret >= SRV_MEDIACACHE_OK)
        {
            mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
        #ifdef __DRM_SUPPORT__
            mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
        #endif
        }
        else
        {
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }
    else
    {
        mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
    }
    /* blt to lcd */
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
    mmi_ivex_enable_osd_fade(MMI_TRUE);
#ifdef __MMI_IMGVIEWEX_MOTION__
    if (!MMI_IVEX_LANDSCAPE)
    {
        mmi_ivex_start_listen_motion();
    }
#endif
#ifdef __MMI_IMGVIEWEX_MAV_MOTION__
    mmi_ivex_mav_start_listen_motion();
#endif    
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ENTRY_VIEW_SCR_EXT_OVER);
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_image_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_image_hdlr(CHAR *file_path, U16 app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ivex_entry_ivex_is_prohibit())
    {
        return;
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_OTHER_APP_VIEW);
    g_ivex_cntx.view_from_fmgr = MMI_TRUE;
    g_ivex_cntx.caller_app_id = app_id;
    mmi_ivex_reset_app();
    g_ivex_cntx.image_info.filepath = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
    mmi_ucs2cpy(g_ivex_cntx.image_info.filepath, file_path);
    mmi_ivex_entry_view_screen_ext();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_util_read_settings_data
 * DESCRIPTION
 *  This function is to read setup data in NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_util_read_settings_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 pError;
    U8 read_buff[NVRAM_EF_IVEX_SETTINGS_SIZE];
    ivex_settings_nvram_struct *read_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadRecord(NVRAM_EF_IVEX_SETTINGS_LID, 1, (void*)read_buff, NVRAM_EF_IVEX_SETTINGS_SIZE, &pError);

    read_ptr = (ivex_settings_nvram_struct*) read_buff;

    /* Set default NVRAM 0xff value to default system value. */
    if (read_ptr->interval_sec == 0xFFFF)
    {
        read_ptr->interval_sec = MMI_IVEX_SPEED_CONST_3S;
    }

    memcpy(&g_ivex_cntx.ivex_settings, read_buff, sizeof(ivex_settings_nvram_struct));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_util_write_settings_data
 * DESCRIPTION
 *  This function is to write setup data back to NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_util_write_settings_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 pError;
    U8 write_buff[NVRAM_EF_IVEX_SETTINGS_SIZE];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memcpy(write_buff, &g_ivex_cntx.ivex_settings, sizeof(ivex_settings_nvram_struct));

    WriteRecord(NVRAM_EF_IVEX_SETTINGS_LID, 1, (void*)write_buff, NVRAM_EF_IVEX_SETTINGS_SIZE, &pError);
}


#define MMI_IVEX_MISC_SCREEN
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_storage_error_and_exit
 * DESCRIPTION
 *  ivex current image option screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_storage_error_and_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_ava = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.view_from_fmgr)
    {
        /* add this for check if the first letter is a valide drv letter.
        cause MMS will pass a virtual filepath to image viewer, the first is not a valide drv letter */
        if(srv_fmgr_drv_get_type(g_ivex_cntx.image_info.filepath[0]) >= FS_NO_ERROR)
        {
            if (FS_GetDevStatus(g_ivex_cntx.image_info.filepath[0] ,FS_MOUNT_STATE_ENUM) != FS_NO_ERROR)
            {
                is_ava = MMI_FALSE;
                mmi_mediaview_close_view_cui(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID);
            }
        }
    }
    else
    {
        if (FS_GetDevStatus(mmi_ivex_get_storage() ,FS_MOUNT_STATE_ENUM) != FS_NO_ERROR)
        {
            is_ava = MMI_FALSE;
            /*  storage is not ready, will exit app, mmi_fmgr_select_path_and_enter will also add screen to histry */
            mmi_ivex_close_group(&g_mediaview_cui_gid, EVT_ID_MEDIAVIEW_CLOSE_GID, MMI_FALSE, MMI_FALSE);
            if (g_ivex_cui_gid != GRP_ID_INVALID)
            {
                mmi_ivex_close_group(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID, MMI_FALSE, MMI_TRUE);
            }
        }
    }
    return is_ava;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_is_file_exist
 * DESCRIPTION
 *  ivex current image option screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_is_file_exist(CHAR *file_path, FS_HANDLE *fs_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_exist = MMI_TRUE;
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (file_path != NULL)
    {
        file_handle = FS_Open((PU16) file_path, FS_READ_ONLY);
        if (file_handle >= FS_NO_ERROR)
        {
            FS_Close(file_handle);
        }
        else
        {
            is_exist = MMI_FALSE;
            *fs_hdlr = file_handle;
        }
    }
    return is_exist;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_is_well_to_going_on
 * DESCRIPTION
 *  ivex current image option screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_is_well_to_going_on(CHAR *file_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE file_handle = -1;
    MMI_BOOL is_exist = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    is_exist = mmi_ivex_is_file_exist(file_path, &file_handle);
    if (g_ivex_cntx.view_from_fmgr)
    {
        if (!is_exist)
        {
            if (file_handle == FS_FILE_NOT_FOUND ||
                file_handle == FS_DRIVE_NOT_FOUND)
            {
                mmi_ivex_display_error_sg(
                    g_ivex_cui_gid,
                    (UI_string_type)GetString(srv_fmgr_fs_error_get_string(file_handle)),
                    (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(file_handle),
                    (U16)g_ivex_cntx.ui_display_rotate,
                    MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);
                return MMI_FALSE;
            }
        }
    }
    else
    {
        if ((srv_fmgr_filelist_count(g_imgview_fl_hdl)) <= 0)
        {
            mmi_ivex_display_error_sg(
                g_ivex_cui_gid,
                (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
                MMI_EVENT_FAILURE,
                (U16)g_ivex_cntx.ui_display_rotate,
                MMI_IMGVIEW_POPUP_RESULT_PROCESS_DELETE_GROUP);
            return MMI_FALSE;
        }
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_set_curr_app_id
 * DESCRIPTION
 *  Set current run ivex app id
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_set_curr_app_id(U16 app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.caller_app_id = app_id;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_curr_app_id
 * DESCRIPTION
 *  Get current run ivex app id
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U16 mmi_ivex_get_curr_app_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_ivex_cntx.caller_app_id;
}


#ifdef __MMI_RMGR__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_option_more_licence_execute_forward
 * DESCRIPTION
 *   handle lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_option_more_licence_execute_forward(U16 highlight_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_fmgr_types_launch_option((WCHAR*)g_ivex_cntx.image_info.filepath, highlight_item);
    if (ret <= 0)
    {
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(srv_fmgr_fs_error_get_string(ret)),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(ret),
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_preentry_option_screen
 * DESCRIPTION
 *  ivex current image option screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_preentry_option_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_unhide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_SEND);
    mmi_frm_unhide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_USE);
#if defined(__MMI_BPP_SUPPORT__) || defined(__MMI_PICT_BRIDGE_SUPPORT__)
    mmi_frm_unhide_menu_item(MENU_ID_FMGR_IMG_OPTION_PRINT);
#endif
    mmi_frm_unhide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_PLAY);
    mmi_frm_unhide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_SETTINGS);
    mmi_frm_unhide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_INFO);

    if (MMI_IVEX_LANDSCAPE)
    {
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_PLAY);
    }
    else
    {
        /* Play menu */
    #if defined(__MMI_IMGVIEWEX_MOTION__) && !defined(DEBUGE_IVEX_UI_ROTATE)
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_PLAY);
    #else
        if ((g_ivex_cntx.total_image_count == 1) || g_ivex_cntx.view_from_fmgr)
        {
            mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_PLAY);
        }
    #endif
    }
    if (g_ivex_cntx.total_image_count == 1 || g_ivex_cntx.view_from_fmgr)
    {
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_SETTINGS);
    }
    /* Send menu */
#if defined(__MMI_BT_SUPPORT__)
    if ((!mmi_bt_is_to_display_bt_menu()) ||
        srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)g_ivex_cntx.image_info.filepath) <= 0)
#else
    if (srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)g_ivex_cntx.image_info.filepath) <= 0)
#endif
    {
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_SEND);
    }
    /* Use as menu */
    if (srv_fmgr_types_get_use_option_menu(FMGR_TYPE_ALL, (WCHAR*)g_ivex_cntx.image_info.filepath) <= 0)
    {
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_USE);
    }

    /* Print menu */
#if defined(__MMI_BPP_SUPPORT__) || defined(__MMI_PICT_BRIDGE_SUPPORT__)
    if (g_ivex_cntx.image_info.is_printable == MMI_FALSE )
    {
        mmi_frm_hide_menu_item(MENU_ID_FMGR_IMG_OPTION_PRINT);
    }
#endif
    /* Get right item */
#ifdef __MMI_RMGR__
    if(!DRM_rights_extendable((kal_wchar*)g_ivex_cntx.image_info.filepath) ||
       !srv_nw_usab_is_any_network_available() ||
       srv_mode_switch_is_network_service_available())
    {
#ifdef __PLUTO_MMI_PACKAGE__
        mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MORE_RITS);
#endif
    }
    else
    {
#ifdef __PLUTO_MMI_PACKAGE__
        mmi_frm_unhide_menu_item(MENU_ID_FMGR_GEN_OPTION_MORE_RITS);
#endif
        mmi_rmgr_set_ro_bound_path((U16*)g_ivex_cntx.image_info.filepath);
    }
#endif

#ifdef __MMI_PHOTOEDITOR__
    if(MMI_FALSE == cui_phoedt_is_supported_format((WCHAR*)g_ivex_cntx.image_info.filepath))
    {
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_EDITOR);
    }
    else
    {
        mmi_frm_unhide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_EDITOR);
    }
#endif

    /* for filelist loading current file */
    if(g_ivex_cntx.image_info.file_state != MMI_IVEX_FILE_STATE_READY ||
       g_ivex_cntx.image_info.result != MMI_IVEX_IMG_HEALTH_OK)
    {
        mmi_frm_hide_menu_item(MENU_ID_IMGVIEW_VIEW_OPTION_INFO);
    }

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_entry_option_screen
 * DESCRIPTION
 *  ivex current image option screen handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_entry_option_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_id option_menu_gid;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_storage_error_and_exit())
    {
        return;
    }

    option_menu_gid = cui_menu_create(
                                    g_ivex_cui_gid,
                                    CUI_MENU_SRC_TYPE_RESOURCE,
                                    CUI_MENU_TYPE_OPTION,
                                    MENU_ID_IMGVIEW_VIEW_OPTION,
                                    MMI_TRUE,
                                    NULL);
    g_ivex_cntx.option_cui_menu_gid = option_menu_gid;
    cui_menu_set_default_left_softkey(option_menu_gid, get_string(STR_GLOBAL_OK));
    cui_menu_set_default_right_softkey(option_menu_gid, get_string(STR_GLOBAL_BACK));
    cui_menu_set_currlist_flags(option_menu_gid, CUI_MENU_LIST_WITH_TEXT_NUMBERED_ITEMS);

    cui_menu_run(option_menu_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_close_settings_inline_cui
 * DESCRIPTION
 *  This function is to prepare the inline data for setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_close_option_menu_cui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_menu_close(g_ivex_cntx.option_cui_menu_gid);
    g_ivex_cntx.option_cui_menu_gid = GRP_ID_INVALID;
    g_ivex_cntx.option_use_menu_id = 0;
    g_ivex_cntx.option_use_child_index = 0;
    g_ivex_cntx.option_send_menu_id = 0;
    g_ivex_cntx.option_send_child_index = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_entry_prepare_play_screen
 * DESCRIPTION
 *  entry get right screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_entry_prepare_play(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_OPTION_PLAY);
    g_ivex_cntx.is_play_start = MMI_TRUE;
    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_err_fw_menu
 * DESCRIPTION
 *   process forward menu error case
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_err_fw_menu(S32 menu_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_OPTION_ERR_FW_MENU,menu_id);
    if (mmi_frm_is_in_backward_scenario())
    {
        mmi_frm_scrn_close(g_ivex_cui_gid, SCR_ID_IMGVIEW_OPTION_USE);
        mmi_frm_scrn_close(g_ivex_cui_gid, SCR_ID_IMGVIEW_OPTION_SEND);
    }
    else
    {
        if (menu_id == 0)
        {
#ifdef __PLUTO_MMI_PACKAGE__
            mmi_ivex_display_error_sg(
                g_ivex_cui_gid,
                (UI_string_type) GetString(STR_ID_FMGR_NO_FORWARD_OPTION),
                MMI_EVENT_FAILURE,
                (U16)g_ivex_cntx.ui_display_rotate,
                MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
#endif
        }
        else
        {
            mmi_ivex_display_error_sg(
                g_ivex_cui_gid,
                (UI_string_type) GetString(srv_fmgr_fs_error_get_string(menu_id)),
                (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(menu_id),
                (U16)g_ivex_cntx.ui_display_rotate,
                MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_option_use_screen_lsk
 * DESCRIPTION
 *   handle lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_option_use_screen_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_fmgr_types_launch_option((WCHAR*)g_ivex_cntx.image_info.filepath, g_ivex_cntx.option_use_child_index);
    if (ret == 0)
    {
    #ifdef __PLUTO_MMI_PACKAGE__
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(STR_ID_FMGR_NO_FORWARD_OPTION),
            MMI_EVENT_FAILURE,
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
    #endif
    }
    else if (ret < 0)
    {
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(srv_fmgr_fs_error_get_string(ret)),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(ret),
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_option_use_execute_forward
 * DESCRIPTION
 *   handle lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_option_use_execute_forward(U16 highlight_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.option_use_child_index = highlight_item;
    mmi_ivex_option_use_screen_lsk();
}


/*****************************************************************************
* FUNCTION
*  mmi_ivex_option_use_init_list
* DESCRIPTION
*  init use option list
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_ivex_option_use_init_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 parent_menu_id;
    S32 sub_menu_id;
    U16 sub_id_num;
    U16 sub_ids[MAX_SUB_MENUS];
    U16 sub_id_strs[MAX_SUB_MENUS];
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_storage_error_and_exit())
    {
        return;
    }
    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }

    /* condition: have saved the image
     * use filepath to ask fmgr for send option and init the sub menu list of send */
    parent_menu_id = srv_fmgr_types_get_use_option_menu(FMGR_TYPE_ALL, (WCHAR*)g_ivex_cntx.image_info.filepath);
    g_ivex_cntx.option_use_menu_id = parent_menu_id;
    sub_id_num = GetNumOfChild_Ext(parent_menu_id);
    GetSequenceStringIds_Ext(parent_menu_id, sub_id_strs);

    for(i = 0; i < sub_id_num; i++)
    {
        sub_ids[i] = GetSeqItemId_Ext(parent_menu_id, i);
    }

    if (parent_menu_id > 0)
    {
        cui_menu_set_currlist(
            g_ivex_cntx.option_cui_menu_gid,
            sub_id_num,
            (MMI_MENU_ID*)sub_ids);

        for(i = 0; i < sub_id_num; i++)
        {
            sub_menu_id = cui_menu_get_currlist_menu_id_from_index(
                g_ivex_cntx.option_cui_menu_gid,
                i);

            cui_menu_set_item_string(
                g_ivex_cntx.option_cui_menu_gid,
                sub_menu_id,
                (WCHAR*)GetString(sub_id_strs[i]));
        }
    }
    else
    {
        mmi_ivex_err_fw_menu(parent_menu_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_option_send_screen_lsk
 * DESCRIPTION
 *   handle lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_option_send_screen_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_fmgr_types_launch_option((WCHAR*)g_ivex_cntx.image_info.filepath, g_ivex_cntx.option_send_child_index);

    if (ret == 0)
    {
#ifdef __PLUTO_MMI_PACKAGE__
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(STR_ID_FMGR_NO_FORWARD_OPTION),
            MMI_EVENT_FAILURE,
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
#endif
    }
    else if (ret < 0)
    {
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(srv_fmgr_fs_error_get_string(ret)),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(ret),
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_option_use_execute_forward
 * DESCRIPTION
 *   handle lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_option_send_execute_forward(U16 highlight_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.option_send_child_index = highlight_item;
    mmi_ivex_option_send_screen_lsk();
}


/*****************************************************************************
* FUNCTION
*  mmi_ivex_option_send_init_list
* DESCRIPTION
*  init use option list
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_ivex_option_send_init_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 parent_menu_id;
    S32 sub_menu_id;
    U16 sub_id_num;
    U16 sub_ids[MAX_SUB_MENUS];
    U16 sub_id_strs[MAX_SUB_MENUS];
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_storage_error_and_exit())
    {
        return;
    }
    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }

    /* condition: have saved the image
     * use filepath to ask fmgr for send option and init the sub menu list of send */
    parent_menu_id = srv_fmgr_types_get_send_option_menu(FMGR_TYPE_ALL, (WCHAR*)g_ivex_cntx.image_info.filepath);
    g_ivex_cntx.option_send_menu_id = parent_menu_id;
    sub_id_num = GetNumOfChild_Ext(parent_menu_id);
    GetSequenceStringIds_Ext(parent_menu_id, sub_id_strs);

    for(i = 0; i < sub_id_num; i++)
    {
        sub_ids[i] = GetSeqItemId_Ext(parent_menu_id, i);
    }

    if (parent_menu_id > 0)
    {
        cui_menu_set_currlist(
            g_ivex_cntx.option_cui_menu_gid,
            sub_id_num,
            (MMI_MENU_ID*)sub_ids);

        for(i = 0; i < sub_id_num; i++)
        {
            sub_menu_id = cui_menu_get_currlist_menu_id_from_index(
                g_ivex_cntx.option_cui_menu_gid,
                i);

            cui_menu_set_item_string(
                g_ivex_cntx.option_cui_menu_gid,
                sub_menu_id,
                (WCHAR*)GetString(sub_id_strs[i]));
        }
    }
    else
    {
        mmi_ivex_err_fw_menu(parent_menu_id);
    }
}


#if defined(__MMI_PHOTOEDITOR__)
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_entry_photoeditor
 * DESCRIPTION
 *  entry photo editor from imageviewer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_entry_photoeditor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }
    /* entry photoeditor */
    mmi_phoedt_entry_from_fmgr((WCHAR*)g_ivex_cntx.image_info.filepath);
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_convert_format_size
 * DESCRIPTION
 *  convert size format
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_convert_format_size(U64 file_size, U16* buffer, S32 buffer_length)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const char postfix[] = {"BKMG"};
    U64 unit = 1;
    S32 i = 0;
    U32 part_int, part_mod;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while(file_size >= 1024*unit && postfix[i] != 'G')
    {
        unit *= 1024;
        i++;
    }

    part_int = (U32)( file_size / unit );
    part_mod = (U32)( ((file_size % unit)*10)/unit );

    if(part_mod)
    {
        kal_wsprintf(buffer, "%d.%d%c", part_int, part_mod, postfix[i]);
    }
    else
    {
        kal_wsprintf(buffer, "%d%c", part_int, postfix[i]);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_entry_info_screen
 * DESCRIPTION
 *  entry info screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_entry_info_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_add_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_INFOSCRN);
    if (!mmi_ivex_storage_error_and_exit())
    {
        return;
    }

    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }
    mmi_ivex_remove_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_INFOSCRN);

    mmi_imgview_show_img_info((WCHAR*)g_ivex_cntx.image_info.filepath, g_ivex_cui_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_settings_save
 * DESCRIPTION
 *  This function is to save the setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_settings_save(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Assign vaule and save */
    switch (g_ivex_cntx.speed_index)
    {
        case MMI_IVEX_SPEED_LOW:
            g_ivex_cntx.ivex_settings.interval_sec = MMI_IVEX_SPEED_CONST_5S;
            break;
        case MMI_IVEX_SPEED_FAST:
            g_ivex_cntx.ivex_settings.interval_sec = MMI_IVEX_SPEED_CONST_1S;
            break;
        default:
            g_ivex_cntx.ivex_settings.interval_sec = MMI_IVEX_SPEED_CONST_3S;
            break;
    }

    mmi_ivex_util_write_settings_data();

/*
    mmi_ivex_display_error_sg(
        g_ivex_cui_gid,
        get_string(STR_GLOBAL_SAVED),
        MMI_EVENT_SUCCESS,
        (U16)GDI_LCD_LAYER_ROTATE_0,
        MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
*/
    mmi_ivex_close_settings_inline_cui();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_settings_done
 * DESCRIPTION
 *  This function is to confirm save before saving setting.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_settings_done(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_struct arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
    arg.parent_id = g_ivex_cui_gid;
    arg.user_tag = (void*)MMI_IMGVIEW_POPUP_RESULT_PROCESS_CONFIRM;
    mmi_confirm_display(
    (WCHAR*)get_string(STR_GLOBAL_SAVE_ASK),
    MMI_EVENT_QUERY,
    &arg);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_entry_settings_screen
 * DESCRIPTION
 *  This function is the entry function of setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_entry_settings_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_storage_error_and_exit())
    {
        return;
    }

    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }

    g_ivex_cntx.settings_cui_inline_gid = cui_inline_create(g_ivex_cui_gid, &g_ivex_settings_inline_struct);
    cui_inline_set_title_icon(g_ivex_cntx.settings_cui_inline_gid, GetRootTitleIcon(MENU_ID_IMGVIEW_APP));
    cui_inline_set_value(g_ivex_cntx.settings_cui_inline_gid, MMI_IVEX_SETTINGS_SPEED, (void*)g_ivex_cntx.speed_index);

    cui_inline_run(g_ivex_cntx.settings_cui_inline_gid);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_settings_prepare_inline_data
 * DESCRIPTION
 *  This function is to prepare the inline data for setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_settings_prepare_inline_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Interval */
    mmi_ivex_util_read_settings_data();
    switch (g_ivex_cntx.ivex_settings.interval_sec)
    {
        case MMI_IVEX_SPEED_CONST_1S:
            g_ivex_cntx.speed_index = MMI_IVEX_SPEED_FAST;
            break;
        case MMI_IVEX_SPEED_CONST_5S:
            g_ivex_cntx.speed_index = MMI_IVEX_SPEED_LOW;
            break;
        default:
            g_ivex_cntx.speed_index = MMI_IVEX_SPEED_NORMAL;
            break;
    }

    /* Enter inline editor screen */
    mmi_ivex_view_option_entry_settings_screen();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_close_settings_inline_cui
 * DESCRIPTION
 *  This function is to prepare the inline data for setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_close_settings_inline_cui(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_inline_close(g_ivex_cntx.settings_cui_inline_gid);
    g_ivex_cntx.settings_cui_inline_gid = GRP_ID_INVALID;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_settings_speed_change_value
 * DESCRIPTION
 *  This function is to prepare the inline data for setting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_settings_speed_change_value(S32 value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.speed_index = value;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_exit_help_screen
 * DESCRIPTION
 *  entry help screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_exit_help_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_direct_exit;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_FREE_APP);
    is_direct_exit = mmi_ivex_is_direct_exit_state(g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_HELPSCRN);
    if (is_direct_exit)
    {
        return;
    }
    MMI_ASSERT(g_ivex_cntx.info_h_buffer != NULL);
    mmi_imgview_asm_free_debug(g_imgview_cui_ptr->imgview_cui_gid, g_ivex_cntx.info_h_buffer);
    g_ivex_cntx.info_h_buffer = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_view_option_entry_help_screen
 * DESCRIPTION
 *  entry help screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_view_option_entry_help_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR *buffer;
    S32 buffer_size;
    PU8 gui_buffer;
    U16 title_id;
    MMI_BOOL entry_ret;
    WCHAR *end_char;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_add_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_HELPSCRN);
    if (!mmi_ivex_storage_error_and_exit())
    {
        return;
    }

    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }

    entry_ret = mmi_frm_scrn_enter(g_ivex_cui_gid, SCR_ID_IMGVIEW_HELP, mmi_ivex_view_option_exit_help_screen, mmi_ivex_view_option_entry_help_screen, MMI_FRM_FULL_SCRN);
    if (!entry_ret)
    {
        return;
    }
    mmi_ivex_remove_direct_exit_state(&g_ivex_cntx.direct_exit, MMI_IVEX_DIRECT_EXIT_HELPSCRN);
    title_id = STR_GLOBAL_HELP;

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_MALLOC_APP);
    g_ivex_cntx.info_h_buffer = mmi_imgview_asm_alloc_debug(g_imgview_cui_ptr->imgview_cui_gid, MMI_IVEX_INFO_HELP_BUFFER_SIZE);
    MMI_ASSERT(g_ivex_cntx.info_h_buffer != NULL);
    buffer = g_ivex_cntx.info_h_buffer;
    mmi_ucs2cpy(buffer,
        GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX1));
    mmi_ucs2cat(buffer,
        GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX2));
    mmi_ucs2cat(buffer,
        GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX3));
    mmi_ucs2cat(buffer,
        GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX4));
    mmi_ucs2cat(buffer,
        GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX5));
    mmi_ucs2cat(buffer,
        GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX6));
    if (!(g_ivex_cntx.view_from_fmgr || (g_ivex_cntx.total_image_count == 1)))
    {
        mmi_ucs2cat(buffer,
            GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX7));
        mmi_ucs2cat(buffer,
            GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX9));
        if (MMI_IVEX_LANDSCAPE)
        {
            mmi_ucs2cat(buffer,
                GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX10));
        }
        else
        {
        #ifdef __MMI_IMGVIEWEX_MOTION__
            mmi_ucs2cat(buffer,
                GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX10));
            mmi_ucs2cat(buffer,
                GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX11));
        #else
            mmi_ucs2cat(buffer,
                GetString(STR_ID_IMGVIEW_VIEW_OPTION_HELP_CNTX12));
        #endif
        }
    }
    buffer_size = mmi_ucs2strlen(buffer);

    /* to cut the last "\n" */
    end_char = (WCHAR*)(buffer + (buffer_size - 1) * ENCODING_LENGTH);
    *end_char = 0;

    buffer_size = mmi_ucs2strlen(buffer);

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_OPTION_HELP_SCR,buffer_size);
    gui_buffer = mmi_frm_scrn_get_gui_buf(g_ivex_cui_gid, SCR_ID_IMGVIEW_HELP);

    ShowCategory74Screen(
        title_id,
        GetRootTitleIcon(MENU_ID_IMGVIEW_APP),
        0,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) buffer,
        buffer_size,
        gui_buffer);

    /* go back to game menu */
    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}


#if defined(__MMI_BPP_SUPPORT__) || defined(__MMI_PICT_BRIDGE_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_option_use_execute_forward
 * DESCRIPTION
 *   handle lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_option_print_execute_forward(U16 highlight_item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = srv_fmgr_types_launch_option((WCHAR*)g_ivex_cntx.image_info.filepath, highlight_item);
    if (ret <= 0)
    {
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(srv_fmgr_fs_error_get_string(ret)),
            (mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(ret),
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_print_req
 * DESCRIPTION
 *  handle print request
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_print_req(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL display_warning;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK)
        display_warning = MMI_FALSE;
    else
        display_warning = MMI_TRUE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PRINT_REQ,display_warning);

    if(!mmi_ivex_is_well_to_going_on(g_ivex_cntx.image_info.filepath))
    {
        return;
    }
    mmi_imgview_service_print_req(
        g_ivex_cntx.image_info.filepath,
        GetRootTitleIcon(MENU_ID_IMGVIEW_APP),
        display_warning,
        g_ivex_cntx.ui_display_rotate,
        g_ivex_cntx.image_info.image_type);
}


#define MMI_IVEX_FILE_MGR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reset_image_info
 * DESCRIPTION
 *  This function is called to reset image info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_reset_image_info(ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR*  filepath;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /*when switch image, should clear all image info except the filepath pointer */
    filepath = img_info->filepath;
    memset((void*)img_info, 0, sizeof(ivex_image_info_struct));
    img_info->filepath = filepath;
    img_info->min_zoom_factor = 1;
    img_info->zoom_factor = 1.02f;
    img_info->curr_zoom_factor =1;
    img_info->zoom_cnt = 0;
    img_info->is_anim_done = MMI_FALSE;
#ifdef __DRM_SUPPORT__
    img_info->drm_state = MMI_IVEX_DRM_STATE_EXIT;
    img_info->drm_id = 0;
    img_info->drm_handle = -1;
#endif
    img_info->is_from_l1 = MMI_FALSE;
    img_info->file_state = MMI_IVEX_FILE_STATE_READY;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pre_prepare_image_info
 * DESCRIPTION
 *  Pre-prepare image image info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pre_prepare_image_info(S32 fl_index, MMI_BOOL is_disp_img, ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 srv_fmgr_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PRE_PREPARE_IMG_INFO,fl_index,is_disp_img);
    /* set  current image index in filelist */
    img_info->filelist_index = fl_index;

    srv_fmgr_ret = srv_fmgr_filelist_get_filepath(g_imgview_fl_hdl, fl_index, (WCHAR*)img_info->filepath, SRV_FMGR_PATH_BUFFER_SIZE);
    TMP_TRACE1("[IVAPP][temp]mmi_ivex_pre_prepare_image_info, srv_fmgr_ret=%d", srv_fmgr_ret);

    if(srv_fmgr_ret < 0)
    {
        img_info->filepath[0] = 0;
        img_info->filepath[1] = 0;
        if(srv_fmgr_ret == SRV_FMGR_FILELIST_ERROR_FILE_NOT_READY)
        {
            srv_fmgr_ret = srv_fmgr_filelist_load_file(
                    g_imgview_fl_hdl,
                    fl_index,
                    mmi_ivex_load_file_proc,
                    (void*)fl_index);
            MMI_ASSERT(srv_fmgr_ret != SRV_FMGR_FILELIST_ERROR_FILE_READY);
            img_info->file_state = MMI_IVEX_FILE_STATE_LOADING;
        }
        else if(srv_fmgr_ret == SRV_FMGR_FILELIST_ERROR_BUSY)
        {
            img_info->file_state = MMI_IVEX_FILE_STATE_LOADING;
        }
        else
        {
            /* should not get SRV_FMGR_FILELIST_ERROR_FILE_READY */
            /* in future, should make sure if need to check other return values */

            /* get filepath error, should set empty to filepath to avoid other errors,
            for MAUI_02836642 */
            img_info->result = srv_fmgr_ret;
        }
    }
    else
    {
        img_info->file_state = MMI_IVEX_FILE_STATE_READY;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_image_base_info
 * DESCRIPTION
 *  get image info by file list index.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

void mmi_ivex_get_image_base_info(S32 fl_index, MMI_BOOL is_disp_img, ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 error_str_id;
    /*S32 frame_cnt = 0;*/
    srv_fmgr_fileinfo_struct file_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_IMG_BASE_INFO,g_ivex_cntx.view_from_fmgr);

    /* for MAUI_02445399,MAUI_02641343,MAUI_02729081,MAUI_02445556 */
    img_info->result = MMI_IVEX_IMG_HEALTH_OK;

    if (!g_ivex_cntx.view_from_fmgr)
    {
        mmi_ivex_pre_prepare_image_info(fl_index, is_disp_img, img_info);
    }

    if(img_info->result < FS_NO_ERROR)
    {
        /* for MAUI_02836642 */
        MMI_STR_ID err_str_id = srv_fmgr_fs_error_get_string(img_info->result);
        if (!is_disp_img)
        {
            mmi_ucs2ncpy(g_swit_file_limit_error, GetString(err_str_id), LIMIT_ERROR_STR_LEN);
            img_info->err_str_ptr = g_swit_file_limit_error;
        }
        else
        {
            mmi_ucs2ncpy(g_curr_file_limit_error, GetString(err_str_id), LIMIT_ERROR_STR_LEN);
            img_info->err_str_ptr = g_curr_file_limit_error;
        }
        img_info->result = MMI_IVEX_IMG_HEALTH_ERROR;

        /* error */
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_IMG_BASE_INFO_3, -1, -1, -1);
    }
    else if(img_info->file_state == MMI_IVEX_FILE_STATE_READY)
    {
        /* DRM permission check with filepath */
    #if defined(__DRM_SUPPORT__)
        mmi_ivex_check_file_drm_right(img_info);
    #endif
        srv_fmgr_fs_path_get_fileinfo((WCHAR*)img_info->filepath, &file_info);
        if (mmi_imgview_print_enabler(&file_info) > 0
    #if defined(__DRM_SUPPORT__)
        && (MMI_IVEX_DRM_RET_PRINT_VALID & img_info->drm_valid)!=0
    #endif
        )
        {
            img_info->is_printable = MMI_TRUE;
        }
        else
        {
            img_info->is_printable = MMI_FALSE;
        }
        /* check file dimension and type */
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_IMG_BASE_INFO_1,img_info->result);
        if (img_info->result >= MMI_IVEX_IMG_HEALTH_OK){
            error_str_id = mmi_fmgr_util_file_limit_check3(FMGR_LIMIT_IMAGE_VIEWER, img_info->filepath, NULL, FMGR_GROUP_IMAGE);
            if(error_str_id)
            {
                img_info->result = MMI_IVEX_IMG_HEALTH_ERROR;
                if (!is_disp_img)
                {
                    mmi_ucs2ncpy(g_swit_file_limit_error,
                                            GetString(error_str_id),
                                            LIMIT_ERROR_STR_LEN);
                    img_info->err_str_ptr = g_swit_file_limit_error;
                }
                else
                {
                    mmi_ucs2ncpy(g_curr_file_limit_error,
                                            GetString(error_str_id),
                                            LIMIT_ERROR_STR_LEN);
                    img_info->err_str_ptr = g_curr_file_limit_error;
                }
            }
        }
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_IMG_BASE_INFO_2,img_info->result);
        if (img_info->result >= MMI_IVEX_IMG_HEALTH_OK)
        {
            img_info->image_type = gdi_image_get_type_from_file(img_info->filepath);

            img_info->result = gdi_image_get_dimension_file(
                                            img_info->filepath,
                                            &(img_info->original_width),
                                            &(img_info->original_height));
            if (((img_info->original_width <= 0) ||
                (img_info->original_height <= 0)) ||
                img_info->result < 0)
            {
                if (img_info->result < 0)
                {
                    mmi_ivex_process_gdi_error_code(img_info->result, img_info);
                }
                else
                {
                    img_info->result = MMI_IVEX_IMG_HEALTH_INVALID_FORMAT;
                    img_info->err_str_ptr = GetString(STR_GLOBAL_INVALID_FORMAT);
                }
            }

            if ((img_info->image_type == GDI_IMAGE_TYPE_SVG ||
                img_info->image_type == GDI_IMAGE_TYPE_SVG_FILE ||
                img_info->image_type == GDI_IMAGE_TYPE_GIF ||
                img_info->image_type == GDI_IMAGE_TYPE_GIF_FILE ||
                img_info->image_type == GDI_IMAGE_TYPE_M3D ||
                img_info->image_type == GDI_IMAGE_TYPE_M3D_FILE) &&
                img_info->result >= MMI_IVEX_IMG_HEALTH_OK)
            {
                gdi_image_gif_check_animation_file(img_info->filepath, &img_info->is_animation);

                /*
                gdi_image_codec_set_flag_begin(GDI_IMAGE_CODEC_FLAG_FAST_GET_FRAME_BUFFER);
                gdi_image_get_frame_count_file((U8*)img_info->filepath, &frame_cnt);
                gdi_image_codec_set_flag_end();
                if (frame_cnt >  1)
                {
                    img_info->is_animation = MMI_TRUE;
                }
                else
                {
                    if ((img_info->image_type == GDI_IMAGE_TYPE_SVG ||
                        img_info->image_type == GDI_IMAGE_TYPE_SVG_FILE) && (frame_cnt == 0))
                    {
                        img_info->is_animation = MMI_TRUE;
                    }
                    else
                    {
                        img_info->is_animation = MMI_FALSE;
                    }
                }
                */
            }
            else
            {
                img_info->is_animation = MMI_FALSE;
            }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            if (img_info->image_type == GDI_IMAGE_TYPE_MAV ||
                img_info->image_type == GDI_IMAGE_TYPE_MAV_FILE)
            {
                img_info->is_mav = MMI_TRUE;
                gdi_image_get_frame_count_file((U8*)img_info->filepath, &(img_info->mav_total_frames));
                img_info->mav_current_frame = 0;
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_GET_IMG_BASE_INFO,
                    img_info->is_mav,
                    img_info->original_width,
                    img_info->original_height,
                    img_info->mav_total_frames);
            }
            else {
                img_info->is_mav = MMI_FALSE;
            }
#endif
        }
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_IMG_BASE_INFO_3,
            img_info->is_animation,img_info->original_width,img_info->original_height);
    }
    else
    {
        /* loading */
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_IMG_BASE_INFO_3, -1, -1, -1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_specified_layer_dimension
 * DESCRIPTION
 *  Get the specified view layer's dimension.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_specified_layer_dimension(MMI_BOOL is_switch, S32* layer_width, S32* layer_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* confirm view layer for the WALLVIEW rotate */
    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0 ||
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
    {
        g_ivex_cntx.view_layer_height = LCD_HEIGHT;
        g_ivex_cntx.view_layer_width = LCD_WIDTH;
    }
    else
    {
        /* camcorder maybe view at horizon when entry */
        g_ivex_cntx.view_layer_height = LCD_WIDTH;
        g_ivex_cntx.view_layer_width = LCD_HEIGHT;
    }
    if (is_switch)
    {
        *layer_width = g_ivex_cntx.switch_layer_width;
        *layer_height = g_ivex_cntx.switch_layer_height;
    }
    else
    {
        *layer_width = g_ivex_cntx.view_layer_width;
        *layer_height = g_ivex_cntx.view_layer_height;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_restore_filelist_index
 * DESCRIPTION
 *  restore the current file index when not switch successfully.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_restore_filelist_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* restore the index because the current display not changeed */
    g_imgview_fl_idx = g_ivex_cntx.image_info.filelist_index;
    cui_folder_browser_set_highlight_index(mmi_mediaview_get_browse_gid(), g_imgview_fl_idx);
}

#ifdef __IMAGE_VIEWER_EX_MEM_SLIM__

static S32 mmi_ivex_check_zoom(WCHAR *filename)
{
    FS_HANDLE h_file;
    kal_uint32 size;
    
    /*
     * temp solution: init max zoom factor according to
     * the limitation, may be delete when the decode add limitation according to chip
     */
    h_file = FS_Open(filename, FS_READ_ONLY);
    FS_GetFileSize(h_file, &size);
    FS_Close(h_file);

    return  (size <= 1024 * 1024);
}

#define MMI_IVEX_CHECK_ZOOM(filename) mmi_ivex_check_zoom(filename)
#else
#define MMI_IVEX_CHECK_ZOOM(filename)  1
#endif /*__IMAGE_VIEWER_EX_MEM_SLIM__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_image_display_info
 * DESCRIPTION
 *  This function init image display info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_init_image_display_info(ivex_image_info_struct *img_info, MMI_BOOL is_switch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 layer_width;
    S32 layer_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_INIT_IMG_DIS_INFO,img_info->result);
    /* basic info is error, so not need to proceed to get other info */
    if (img_info->result < MMI_IVEX_IMG_HEALTH_OK)
    {
        return;
    }
    mmi_ivex_get_specified_layer_dimension(is_switch, &layer_width, &layer_height);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    srv_mediacache_util_fix_box(
                    layer_width, layer_height, 
                        img_info->original_width,
                        img_info->original_height,
                        &img_info->draw_offset_x,
                        &img_info->draw_offset_y,
                        &img_info->resized_image_width,
                        &img_info->resized_image_height,
                        img_info->image_type);
    img_info->resized_width = img_info->resized_image_width;
    img_info->resized_height = img_info->resized_image_height;
    img_info->resized_offset_x = 0;
    img_info->resized_offset_y = 0;
    img_info->is_zoomin_able = MMI_FALSE;
    img_info->is_zoomout_able = MMI_FALSE;
    img_info->zoom_cnt = 0;
    if(img_info->resized_image_width == layer_width){
        img_info->curr_zoom_factor = img_info->min_zoom_factor = 
            (float)(img_info->resized_image_width)/img_info->original_width;
    }else{
        img_info->curr_zoom_factor = img_info->min_zoom_factor = 
            (float)(img_info->resized_image_height)/img_info->original_height;
    }


#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
    /* check if zoomable, GIF, SVG and M3D not allowed */
    if (MMI_IVEX_CHECK_ZOOM((WCHAR*)(img_info->filepath)))
    {
        /* Now if only the file is not animation, zoom in is not avilable */
        img_info->is_zoomin_able = MMI_TRUE;
    }

    if(!is_switch && img_info->is_animation){
        memset(&g_anim_context, 0, sizeof(g_anim_context));
    }

#else /*__IVEX_SUPPOERT_ANIM_ZOOM__*/
    /* check if zoomable, GIF, SVG and M3D not allowed */
    if (!img_info->is_animation && MMI_IVEX_CHECK_ZOOM((WCHAR*)(img_info->filepath)))
    {
        /* Now if only the file is not animation, zoom in is not avilable */
        img_info->is_zoomin_able = MMI_TRUE;
    }

#endif
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (img_info->is_mav)
    {
        img_info->is_zoomin_able = MMI_FALSE;
    }
#endif

    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_ZOOM] == MMI_FALSE)
    {
        img_info->is_zoomin_able = MMI_FALSE;
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_INIT_IMG_DIS_INFO_OVER,
        img_info->original_width,
        img_info->original_height,
        img_info->resized_width,
        img_info->resized_height,
        img_info->resized_offset_x,
        img_info->resized_offset_y,
        img_info->draw_offset_x,
        img_info->draw_offset_y,
        img_info->is_zoomin_able,
        img_info->is_zoomout_able);

	//init CAPS data
#ifdef __IVEX_SUPPORT_IES__
    if(img_info->image_type == GDI_IMAGE_TYPE_JPG_FILE || img_info->image_type == GDI_IMAGE_TYPE_JPG)
    {
        img_info->fit_screen_height = img_info->resized_height;
        img_info->fit_screen_width = img_info->resized_width;

        if(img_info->original_height > 2*layer_height 
        || img_info->original_width > 2*layer_width){ //image > Layer
            img_info->CAPS_max_level = (float)(img_info->original_width) / img_info->fit_screen_width;
            img_info->max_zoom_factor = 1.0f;
        }else{ //image <= layer
            img_info->CAPS_max_level = 2.0f;
            img_info->max_zoom_factor = 2.0f;
        }

        img_info->CAPS_flag=MMI_IVEX_caps_display;
        //yc?
    	img_info->CAPS_zoom_level=1;
    	img_info->CAPS_zoom_progrss=0;
    	img_info->CAPS_move_x=0;
    	img_info->CAPS_move_y=0;
   }
#endif	/* __IVEX_SUPPORT_IES__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reload_curr_image
 * DESCRIPTION
 *  reload curr image and its info after srv fmgr load file done
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_reload_curr_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret = SRV_MEDIACACHE_ERR_DECODING;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_folder_browser_set_highlight_index(mmi_mediaview_get_browse_gid(), g_ivex_cntx.image_info.filelist_index);

    mmi_ivex_get_image_base_info(
        g_ivex_cntx.image_info.filelist_index,
        MMI_FALSE,
        &g_ivex_cntx.image_info);

    if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_READY)
    {
        mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);

        if(g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK)
        {
            g_ivex_cntx.image_info.is_first_ok = MMI_FALSE;
            ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            if (ret >= SRV_MEDIACACHE_OK)
            {
                // TODO: decode is ok, stop loading
                mmi_ivex_stop_curr_loading_effect();

                mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
                g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
            #ifdef __DRM_SUPPORT__
                mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
            #endif
            }
            else
            {
                if(ret == SRV_MEDIACACHE_ERR_DECODING)
                {
                    // TODO: for provide smooth loading animation, should not start loading from here again
                }
                else
                {
                    mmi_ivex_process_curr_image_decode_abnormal(ret);
                }
            }
        }
        else
        {
            // TODO: the file has something error, stop loading, and draw error
            mmi_ivex_stop_curr_loading_effect();

            mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
            mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
        }
        mmi_ivex_draw_osd_panel_layer();
        mmi_ivex_draw_osd_title_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif

        if (ret >= SRV_MEDIACACHE_OK)
        {
            // TODO: if blt when ret = SRV_MEDIACACHE_ERR_DECODING,
            // TODO: there will be a black screen shown between two frame of the loading animation
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_load_file_proc
 * DESCRIPTION
 *  image viewer load file proc
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_ivex_load_file_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TMP_TRACE("[IVAPP][temp]mmi_ivex_load_file_proc_1");
    if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW)
    {
        TMP_TRACE("[IVAPP][temp]mmi_ivex_load_file_proc_2");
        switch(param->evt_id)
        {
            case EVT_ID_SRV_FMGR_FILELIST_LOAD_RESULT:
                {
                    srv_fmgr_filelist_load_result_event_struct *evt = (srv_fmgr_filelist_load_result_event_struct*)param;
                    //TMP_TRACE1("[IVAPP][temp]mmi_ivex_load_file_proc_3, result=%d", evt->result);
                    if(evt->result == FS_NO_ERROR)
                    {
                        // TODO: if start load file, other images maybe blocked,
                        // TODO: so if image state is loading, means it is blocked by load action need to be update

                        if(g_ivex_cntx.image_info.file_state == MMI_IVEX_FILE_STATE_LOADING)
                        {
                            mmi_ivex_reload_curr_image();
                        }
                    }
                }
                break;

            default:
                break;
        }
    }

    return MMI_RET_OK;
}


#define MMI_IVEX_KEY_TOUCH_MGR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_update_image_for_normal_interrupt
 * DESCRIPTION
 *  in some case, need stop animation or not update clear image, when the image stop, should should update it.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_update_image_for_normal_interrupt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL &&
        g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK &&
        g_ivex_cntx.image_info.is_loading == MMI_FALSE)
    {
        if (g_ivex_cntx.image_info.is_animation)
        {
            if (g_ivex_cntx.image_info.handle == 0)
            {
                mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
            }
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        else if (g_ivex_cntx.image_info.is_mav)
        {
            if (g_ivex_cntx.image_info.handle == 0)
            {
                mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
            }
        }
#endif
        else
        {
            mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        }
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_min_value
 * DESCRIPTION
 *  general function, get the minimize value from three values.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ivex_get_min_value(S32 param1, S32 param2, S32 param3)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 temp_value = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (param1 > param2)
    {
        temp_value = param2;
    }
    else
    {
        temp_value = param1;
    }

    if (temp_value > param3)
    {
        temp_value = param3;
    }

    return temp_value;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_max_zoom_factor
 * DESCRIPTION
 *  get the max image zoom factor.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
float mmi_ivex_get_max_zoom_factor(ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 limit_width;
    S32 limit_height;
    float tmp_factor1;
    float tmp_factor2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __IVEX_SUPPORT_IES__
    if(img_info->image_type == GDI_IMAGE_TYPE_JPG_FILE || img_info->image_type == GDI_IMAGE_TYPE_JPG)
    {
        return img_info->max_zoom_factor;
    }else{
#endif /* __IVEX_SUPPORT_IES__ */

    limit_width = mmi_ivex_get_min_value(img_info->original_width * 2, img_info->original_width * 2, g_ivex_cntx.iv_limit_width * 2);
    limit_height = mmi_ivex_get_min_value(img_info->original_height * 2, img_info->original_height * 2, g_ivex_cntx.iv_limit_height * 2);
#ifdef __IVEX_SUPPORT_IES__
    }
#endif /* __IVEX_SUPPORT_IES__ */

    tmp_factor1 = (float)limit_width / (float)img_info->original_width;
    tmp_factor2 = (float)limit_height / (float)img_info->original_height;

    if (tmp_factor1 > tmp_factor2)
    {
        return tmp_factor2;
    }
    else
    {
        return tmp_factor1;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_set_curr_zoom_factor
 * DESCRIPTION
 *  set image curr zoom factor.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_set_shortcut_zoom_factor(ivex_image_info_struct *img_info, float *multiple)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    float tmp_factor1;
    float tmp_factor2;
    float tmp_factor3;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    tmp_factor2 = img_info->max_zoom_factor - img_info->min_zoom_factor;
    if (g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMIN_TO_MAX)
    {
        if (img_info->max_zoom_factor <= 1.5)
        {
            tmp_factor3 = MMI_IVEX_FIRST_ZOOMIN_L_STEP;
        }
        else
        {
            tmp_factor3 = MMI_IVEX_FIRST_ZOOMIN_S_STEP;
        }
        tmp_factor1 = img_info->min_zoom_factor + tmp_factor2 * tmp_factor3;
        if (img_info->curr_zoom_factor < tmp_factor1)
        {
            *multiple = tmp_factor1 / img_info->curr_zoom_factor;
            img_info->curr_zoom_factor = tmp_factor1;
        }
        else
        {
            *multiple = (float)(pow((img_info->max_zoom_factor / tmp_factor1), 1/MMI_IVEX_ZOOM_STEP));
            img_info->curr_zoom_factor = img_info->curr_zoom_factor * (*multiple);
            if (img_info->curr_zoom_factor + 0.01 >= img_info->max_zoom_factor)
            {
                *multiple = ((*multiple) * img_info->max_zoom_factor) / img_info->curr_zoom_factor;
                img_info->curr_zoom_factor = img_info->max_zoom_factor;
            }
        }
        img_info->zoom_cnt = mmi_ivex_calculate_zoom_cnt(img_info->min_zoom_factor, img_info->curr_zoom_factor);
    }

    if (g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMOUT_TO_MIN)
    {
        if (img_info->max_zoom_factor <= 1.5)
        {
            tmp_factor3 = MMI_IVEX_FIRST_ZOOMOUT_L_STEP;
        }
        else
        {
            tmp_factor3 = MMI_IVEX_FIRST_ZOOMOUT_S_STEP;
        }
        tmp_factor1 = img_info->max_zoom_factor - tmp_factor2 * tmp_factor3;
        if (img_info->curr_zoom_factor > tmp_factor1)
        {
            *multiple = img_info->curr_zoom_factor / tmp_factor1;
            img_info->curr_zoom_factor = tmp_factor1;
        }
        else
        {
            *multiple = (float)(pow((tmp_factor1 / img_info->min_zoom_factor), 1/MMI_IVEX_ZOOM_STEP));
            img_info->curr_zoom_factor = img_info->curr_zoom_factor / (*multiple);
            if (img_info->curr_zoom_factor < img_info->min_zoom_factor)
            {
                *multiple = (*multiple * img_info->curr_zoom_factor) / img_info->min_zoom_factor;
                img_info->curr_zoom_factor = img_info->min_zoom_factor;
            }
        }
        img_info->zoom_cnt = mmi_ivex_calculate_zoom_cnt(img_info->min_zoom_factor, img_info->curr_zoom_factor);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_media_changed
 * DESCRIPTION
 *  This function process media changed case.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_process_media_changed(S32 file_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_changed = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PROC_MC,file_count,g_ivex_cntx.total_image_count);
    /* this case need popup */
    if ((g_ivex_cntx.total_image_count != file_count) || file_count <= 0)
    {
        if (g_ivex_cntx.play_switch_done == MMI_FALSE)
        {
            /* for play to switch next, if uploading an image to make filelist destruction at present, so need set true to avoid stop render when stop all in viewer scr */
            g_ivex_cntx.play_switch_done = MMI_TRUE;
        }
        mmi_ivex_display_error_sg(
            g_ivex_cui_gid,
            (UI_string_type) GetString(FMGR_FS_MEDIA_CHANGED_TEXT),
            MMI_EVENT_FAILURE,
            (U16)g_ivex_cntx.ui_display_rotate,
            MMI_IMGVIEW_POPUP_RESULT_PROCESS_NONE);
    }
    else
    {
        is_changed = MMI_FALSE;
    }
    return is_changed;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_abnormal_image
 * DESCRIPTION
 *  This function process error image case.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_process_abnormal_image(gdi_handle layer_handle, ivex_image_info_struct *img_info, MMI_BOOL is_switch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (img_info->result == MMI_IVEX_IMG_HEALTH_DRM_NEED_RIGHT ||
        img_info->result == MMI_IVEX_IMG_HEALTH_DRM_INVALID)
    {
        /* this image is not shown out, so not to get right till switch over */
        mmi_ivex_draw_drm_effect(layer_handle, is_switch);
        img_info->err_img_id = IMG_ID_IVEX_HINT_DRM;
    }
    else
    {
        mmi_ivex_draw_err_effect(layer_handle, is_switch);
        img_info->err_img_id = IMG_ID_IVEX_HINT_FILE_ERR;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_switch_image_decode_abnormal
 * DESCRIPTION
 *  This function process exception decode image case.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_process_switch_image_decode_abnormal(S32 result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SWITCH_ABNORMAL,result);
    if (result == SRV_MEDIACACHE_ERR_DECODING)
    {
        gdi_layer_clear_nb_concurrent(g_ivex_cntx.switch_layer_handle, GDI_COLOR_BLACK);
        mmi_ivex_draw_alpha_bmp_id_nb_concurrent(g_ivex_cntx.switch_layer_handle,
            g_ivex_cntx.active_osd_layout_ptr->loading_hint.offset_x,
            g_ivex_cntx.active_osd_layout_ptr->loading_hint.offset_y,
            g_ivex_cntx.switch_layer_handle,
            (U16)(IMG_ID_IVEX_HINT_LOADING_0));

        mmi_ivex_start_switch_loading_effect();
    }
    else
    {
        mmi_ivex_draw_err_effect(g_ivex_cntx.switch_layer_handle, MMI_TRUE);
        g_ivex_cntx.switch_image_info.err_img_id = IMG_ID_IVEX_HINT_FILE_ERR;
        g_ivex_cntx.switch_image_info.result = MMI_IVEX_IMG_HEALTH_ERROR;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_save_image_info_for_interrupt_switch
 * DESCRIPTION
 *  This function deal with interruption during switch.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_save_image_info_for_interrupt_switch(U8* frame_percent)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SAVE_INFO_INT,*frame_percent);
    if (*frame_percent >= 50)
    {
        mmi_ivex_reset_new_display_image_setting();
        srv_mediacache_goto_index(g_ivex_cntx.srv_mediacache_handle, g_imgview_fl_idx);
    }
    else
    {
        g_imgview_fl_idx = g_ivex_cntx.image_info.filelist_index;
        cui_folder_browser_set_highlight_index(mmi_mediaview_get_browse_gid(), g_imgview_fl_idx);
    }

    /* let display layer fill in the LCD, let curr image be shown */
    gdi_layer_set_position_nb_concurrent(g_ivex_cntx.display_layer_handle, 0, 0);

    *frame_percent = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_switch_info
 * DESCRIPTION
 *  This function prepare layer and switch image info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_switch_info(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREPARE_SWITCH_INFO,g_ivex_cntx.view_layer_width);
    mmi_ivex_reset_image_info(&g_ivex_cntx.switch_image_info);
    mmi_ivex_view_layer_resizer(g_ivex_cntx.switch_layer_handle, MMI_TRUE);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.switch_layer_handle, g_ivex_cntx.ui_display_rotate);
    /* get current file basic info */
    mmi_ivex_get_image_base_info(index, MMI_FALSE, &g_ivex_cntx.switch_image_info);
    /* get position and property of image for the first display of current image */
    mmi_ivex_init_image_display_info(&g_ivex_cntx.switch_image_info, MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_switch_and_draw
 * DESCRIPTION
 *  This function prepare layer and switch image info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ivex_prepare_switch_and_draw(MMI_BOOL is_next)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret = 0;
    srv_mediacache_img_to_layer_struct area;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_NEXT_IMG,
        ret,is_next,
        g_imgview_fl_idx,
        g_ivex_cntx.image_info.filelist_index,
        g_ivex_cntx.switch_image_info.filelist_index,
        g_ivex_cntx.switch_image_info.draw_offset_x,
        g_ivex_cntx.switch_image_info.draw_offset_y,
        g_ivex_cntx.switch_image_info.resized_offset_x,
        g_ivex_cntx.switch_image_info.resized_offset_y,
        g_ivex_cntx.switch_image_info.resized_width,
        g_ivex_cntx.switch_image_info.resized_height);
    area.dst_layer = g_ivex_cntx.switch_layer_handle;
    area.src.x = (S32)((float)g_ivex_cntx.switch_image_info.resized_offset_x / (float)g_ivex_cntx.switch_image_info.curr_zoom_factor);
    area.src.y = (S32)((float)g_ivex_cntx.switch_image_info.resized_offset_y / (float)g_ivex_cntx.switch_image_info.curr_zoom_factor);
    area.src.width = (S32)((float)g_ivex_cntx.switch_image_info.resized_width / (float)g_ivex_cntx.switch_image_info.curr_zoom_factor);
    area.src.height = (S32)((float)g_ivex_cntx.switch_image_info.resized_height / (float)g_ivex_cntx.switch_image_info.curr_zoom_factor);

    if (area.src.width > g_ivex_cntx.switch_image_info.original_width)
    {
        area.src.width = g_ivex_cntx.switch_image_info.original_width;
    }
    if (area.src.height > g_ivex_cntx.switch_image_info.original_height)
    {
        area.src.height = g_ivex_cntx.switch_image_info.original_height;
    }
    if (area.src.x + area.src.width >= g_ivex_cntx.switch_image_info.original_width)
    {
        area.src.x = g_ivex_cntx.switch_image_info.original_width - area.src.width;
    }
    if (area.src.y + area.src.height >= g_ivex_cntx.switch_image_info.original_height)
    {
        area.src.y = g_ivex_cntx.switch_image_info.original_height - area.src.height;
    }

    area.dst.x = g_ivex_cntx.switch_image_info.draw_offset_x;
    area.dst.y = g_ivex_cntx.switch_image_info.draw_offset_y;
    area.dst.width = g_ivex_cntx.switch_image_info.resized_width;
    area.dst.height = g_ivex_cntx.switch_image_info.resized_height;
    area.user_data = NULL;
    area.callback = NULL;
    //yc add
#ifdef __IVEX_SUPPORT_IES__
    area.anim_hint = SRV_MEDIACACHE_ANIM_HINT_NEUTRAL;
    area.zoom_target = 1;
    area.anim_progress = 0;
    area.rotation_step = SRV_MEDIACACHE_ROTATION_0;
    area.delta_x = 0;
    area.delta_y = 0;
#endif

    if(g_ivex_cntx.switch_image_info.file_state == MMI_IVEX_FILE_STATE_LOADING)
    {
        ret = SRV_MEDIACACHE_ERR_DECODING; /* let IVAPP handle it as loading */
    }
    else
    {
        srv_mediacache_set_qulity_high();
        
        if(g_ivex_cntx.switch_image_info.image_type == GDI_IMAGE_TYPE_GIF ||
                g_ivex_cntx.switch_image_info.image_type == GDI_IMAGE_TYPE_GIF_FILE)
        {
            gdi_layer_set_source_key_nb_concurrent(area.dst_layer, MMI_TRUE, GDI_COLOR_TRANSPARENT);
        }else{
            gdi_layer_set_source_key_nb_concurrent(area.dst_layer, MMI_FALSE, GDI_COLOR_TRANSPARENT);
        }
        if (is_next)
        {
            ret = srv_mediacache_get_next_img_to_layer(g_ivex_cntx.srv_mediacache_handle, &area);
        }
        else
        {
            ret = srv_mediacache_get_prev_img_to_layer(g_ivex_cntx.srv_mediacache_handle, &area);
        }
        g_ivex_cntx.image_info.is_from_l1 = MMI_FALSE;
        if (ret >= SRV_MEDIACACHE_OK)
        {
            if (SRV_MEDIACACHE_OK_L1 == srv_mediacache_get_last_source(g_ivex_cntx.srv_mediacache_handle))
            {
                g_ivex_cntx.switch_image_info.is_from_l1 = MMI_TRUE;
            }
            else
            {
                g_ivex_cntx.switch_image_info.is_from_l1 = MMI_FALSE;
            }
        }
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_GET_NEXT_IMG,
        ret,is_next,
        g_imgview_fl_idx,
        g_ivex_cntx.image_info.filelist_index,
        g_ivex_cntx.switch_image_info.filelist_index,
        g_ivex_cntx.switch_image_info.draw_offset_x,
        g_ivex_cntx.switch_image_info.draw_offset_y,
        g_ivex_cntx.switch_image_info.resized_offset_x,
        g_ivex_cntx.switch_image_info.resized_offset_y,
        g_ivex_cntx.switch_image_info.resized_width,
        g_ivex_cntx.switch_image_info.resized_height);
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_previous_image
 * DESCRIPTION
 *  This function prepare previous image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_prepare_previous_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 file_count;
    S32 ret = 0;
    MMI_BOOL is_changed;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREPARE_PREV,g_ivex_cntx.image_state);
    //MMI_ASSERT(g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_PREV);
    if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV){
        return MMI_TRUE;
    }

    /* get file count again and confirm if the file list has been changed ouside */
    file_count = srv_fmgr_filelist_count(g_imgview_fl_hdl);
    is_changed = mmi_ivex_process_media_changed(file_count);
    if (is_changed)
    {
        /* should exit if image number is changed when switch image */
        mmi_mediaview_close_view_cui(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID);
        mmi_mediaview_free_filelist();
        return MMI_FALSE;
    }
    /* when prepare the switch image, need stop the switch layer loading anmi to avoid the layer has the left loading anmi */
    mmi_ivex_stop_switch_loading_effect();

    if (file_count > 1)
    {
        S32 fl_index = g_imgview_fl_idx>0 ? g_imgview_fl_idx - 1 : file_count-1;

        cui_folder_browser_set_highlight_index(mmi_mediaview_get_browse_gid(), fl_index);
        mmi_ivex_prepare_switch_info(fl_index);

        if (g_ivex_cntx.switch_image_info.result < MMI_IVEX_IMG_HEALTH_OK)
        {
            mmi_ivex_process_abnormal_image(g_ivex_cntx.switch_layer_handle, &g_ivex_cntx.switch_image_info, MMI_TRUE);
        }
        else
        {
            gdi_layer_clear_nb_concurrent(g_ivex_cntx.switch_layer_handle, GDI_COLOR_BLACK);
            ret = mmi_ivex_prepare_switch_and_draw(MMI_FALSE);
            if (ret != SRV_MEDIACACHE_OK)
            {
                mmi_ivex_process_ivsrv_error_code(ret, &g_ivex_cntx.switch_image_info);
                mmi_ivex_process_switch_image_decode_abnormal(ret);
            }
        }
    }
    /* should not to here */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREPARE_PREV_OVER);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_next_image
 * DESCRIPTION
 *  This function prepare next image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_prepare_next_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 file_count;
    S32 ret = 0;
    MMI_BOOL is_changed;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREPARE_NEXT,g_ivex_cntx.image_state);
    //MMI_ASSERT(g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_PLAY);

    if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT )
    {
        return MMI_TRUE;
    }

    /* get file count again and confirm if the file list has been changed ouside */
    file_count = srv_fmgr_filelist_count(g_imgview_fl_hdl);
    is_changed = mmi_ivex_process_media_changed(file_count);
    if (is_changed)
    {
        /* should exit if image number is changed when switch image */
        mmi_mediaview_close_view_cui(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID);
        mmi_mediaview_free_filelist();
        return MMI_FALSE;
    }
    /* when prepare the switch image, need stop the switch layer loading anmi to avoid the layer has the left loading anmi */
    mmi_ivex_stop_switch_loading_effect();

    if (file_count > 1)
    {
        S32 fl_index = g_imgview_fl_idx + 1 == file_count ? 0 : g_imgview_fl_idx + 1;

        cui_folder_browser_set_highlight_index(mmi_mediaview_get_browse_gid(), fl_index);
        mmi_ivex_prepare_switch_info(fl_index);

        if (g_ivex_cntx.switch_image_info.result < MMI_IVEX_IMG_HEALTH_OK)
        {
            mmi_ivex_process_abnormal_image(g_ivex_cntx.switch_layer_handle, &g_ivex_cntx.switch_image_info, MMI_TRUE);
        }
        else
        {
            gdi_layer_clear_nb_concurrent(g_ivex_cntx.switch_layer_handle, GDI_COLOR_BLACK);
            ret = mmi_ivex_prepare_switch_and_draw(MMI_TRUE);
            if (ret != SRV_MEDIACACHE_OK)
            {
                mmi_ivex_process_ivsrv_error_code(ret, &g_ivex_cntx.switch_image_info);
                mmi_ivex_process_switch_image_decode_abnormal(ret);
            }
        }
    }
    /* should not to here */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREPARE_NEXT_OVER);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_switch_is_valid
 * DESCRIPTION
 *  This function check if make switch is valid.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_switch_is_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_switch_valid = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_STILL ||
        g_ivex_cntx.total_image_count == 1 ||
#ifdef __MMI_TOUCH_SCREEN__
        g_ivex_cntx.is_pen_down == MMI_TRUE ||
#endif
        g_ivex_cntx.view_from_fmgr == MMI_TRUE)
    {
        is_switch_valid = MMI_FALSE;
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_CHECK_SWI_VALID,
    g_ivex_cntx.osd_state,1,g_ivex_cntx.image_state,g_ivex_cntx.total_image_count,g_ivex_cntx.view_from_fmgr,is_switch_valid);
    return is_switch_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_previous_image_press
 * DESCRIPTION
 *  This function switch previous image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_previous_image_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_switch_is_valid())
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->larrow.is_press = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_previous_image_release
 * DESCRIPTION
 *  This function switch previous image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_previous_image_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct display_layer;
    ivex_osd_layer_struct switch_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PRE_RELEASE,
    g_ivex_cntx.active_osd_layout_ptr->larrow.is_press,g_ivex_cntx.switch_orientation);

    if (!mmi_ivex_check_switch_is_valid() ||
        g_ivex_cntx.switch_orientation != MMI_IVEX_SWITCH_JUST_PRE)
    {
        if (g_ivex_cntx.is_switch_two &&
            g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL)
        {
            g_ivex_cntx.is_switch_two = MMI_FALSE;
        }
        else
        {
            return;
        }
    }
    g_ivex_cntx.active_osd_layout_ptr->larrow.is_press = MMI_FALSE;
    MMI_ASSERT(g_ivex_cntx.image_info.filepath != NULL);
    MMI_ASSERT(g_ivex_cntx.switch_image_info.filepath != NULL);
    /* prepare the switch image info */
    if (!mmi_ivex_prepare_previous_image())
    {
        return;
    }
    display_layer.offset_x = 0;
    display_layer.offset_y = 0;
    /* switch layer not rotate as display, switch layer has the rotate angle with ui */
    switch_layer.offset_x = -mmi_ivex_get_ext_ui_width();
    switch_layer.offset_y = 0;
    /* this means that when start switch, draw offset 0 first, set the persent as MMI_IVEX_SWITCH_FRAME_STEP, this will be the second frame.
    this can avoid when draw the first frame (still), the image state is switch pre, but the frame is 0, at this time, pen down, it
    will treate it as switch pre, but it is not in fact. */
    g_ivex_cntx.switch_frame_precent = MMI_IVEX_SWITCH_FRAME_STEP;
    /* the first frame is still, that is to say offset is 0, when enter switch cyclic, MMI_IVEX_SWITCH_FRAME_STEP offset will be the second */
    mmi_ivex_layer_set_position(g_ivex_cntx.display_layer_handle, &display_layer);
    mmi_ivex_layer_set_position(g_ivex_cntx.switch_layer_handle, &switch_layer);
    mmi_ivex_start_switch_pre();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_previous_image_for_key
 * DESCRIPTION
 *  This function switch to previous image, used to key down act
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_previous_image_for_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_KEY_SWI_PREV,g_ivex_cntx.switch_orientation);
#ifdef __MMI_TOUCH_SCREEN__
    if (!g_ivex_cntx.is_pen_down && g_ivex_cntx.key_press)
#endif
    {
        g_ivex_cntx.switch_orientation = MMI_IVEX_SWITCH_JUST_PRE;
        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
        {
            g_ivex_cntx.is_switch_two = MMI_TRUE;
        }
    }

    mmi_ivex_previous_image_press();
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_KEY_SWI_NEXT,g_imgview_cui_ptr->view_mode.viewmode);
    switch (g_imgview_cui_ptr->view_mode.viewmode)
    {
        case CUI_IMGVIEW_VIEWMODE_FILENAME:
            break;
        case CUI_IMGVIEW_VIEWMODE_PREFETCH:
            mmi_ivex_prefetch_image(MMI_FALSE);
            break;
        case CUI_IMGVIEW_VIEWMODE_FILELIST:
            mmi_ivex_previous_image_release();
            break;
        case CUI_IMGVIEW_VIEWMODE_FILENAME_ARRAY:
            break;
        case CUI_IMGVIEW_VIEWMODE_IMAGEID_ARRAY:
            break;
        case CUI_IMGVIEW_VIEWMODE_FOLDER:
            mmi_ivex_previous_image_release();
            break;
        default:
            mmi_ivex_previous_image_release();
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_layer_offset_percent
 * DESCRIPTION
 *  This function is called to get layer offset percent.
 * PARAMETERS
 *  void
 * RETURNS
 *  Layer offset percent
 *****************************************************************************/
S32 mmi_ivex_get_layer_offset_percent(S32 ext_ui_width)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 percent;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.is_spring)
    {
        percent = g_ivex_cntx.percent_numerator;
    }
    else
    {
        percent = mmi_ivex_animator_ease_out(g_ivex_cntx.switch_frame_precent);
    }

    if (percent >= 100)
    {
        percent = 100;
    }

    if (percent <= 0)
    {
        percent = 0;
        if (g_ivex_cntx.is_spring)
        {
            g_ivex_cntx.is_spring = MMI_FALSE;
            /* just spring back to meet lcd */
            mmi_ivex_restore_filelist_index();
        #ifdef __MMI_TOUCH_SCREEN__
            g_ivex_cntx.is_pen_down_on_switch = MMI_FALSE;
            /* avoid the case of the percent is decimal fraction of 0~1 */
            gui_cancel_timer(mmi_ivex_pen_up_and_rebound_current_image);
        #endif
            g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        }
    }
    return percent;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_layer_offset_coordinate
 * DESCRIPTION
 *  This function is called to get layer offset coordinate.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_layer_offset_coordinate(S32 percent, S32 ext_ui_width, ivex_osd_layer_struct *display_layer, ivex_osd_layer_struct *switch_layer, MMI_BOOL is_playback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 sign = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY && !is_playback) ||
        g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
    {
        sign = 1;
    }
    else
    {
        sign = -1;
    }

    if ((g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0 &&
        g_ivex_cntx.ui_display_rotate == g_ivex_cntx.view_image_rotate) ||
        (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90 &&
        g_ivex_cntx.ui_display_rotate == g_ivex_cntx.view_image_rotate))
    {
        if(percent == 0)
        {
            display_layer->offset_y = 0;
            display_layer->offset_x = 0;
        }
        else if (g_ivex_cntx.is_spring)
        {
            display_layer->offset_y = g_ivex_cntx.display_layer_last_offset_y / 2;
            display_layer->offset_x = g_ivex_cntx.display_layer_last_offset_x / 2;
        }
        else
        {
            display_layer->offset_y = g_ivex_cntx.display_layer_last_offset_y * (100 - percent) / 100;
            display_layer->offset_x = -1 * sign * percent * ext_ui_width / 100;
        }
        switch_layer->offset_y = 0;
        switch_layer->offset_x = display_layer->offset_x + sign * ext_ui_width;
        g_ivex_cntx.display_layer_last_offset_x = display_layer->offset_x;
        g_ivex_cntx.display_layer_last_offset_y = display_layer->offset_y;
    }
    else if ((g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0 &&
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90) ||
        (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90 &&
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180))
    {
        if(percent == 0)
        {
            display_layer->offset_y = 0;
            display_layer->offset_x = 0;
        }
        else if (g_ivex_cntx.is_spring)
        {
            display_layer->offset_y = g_ivex_cntx.display_layer_last_offset_y / 2;
            display_layer->offset_x = g_ivex_cntx.display_layer_last_offset_x / 2;
        }
        else
        {
            display_layer->offset_x = g_ivex_cntx.display_layer_last_offset_x * (100 - percent) / 100;
            display_layer->offset_y = sign * percent * ext_ui_width / 100;
        }
        switch_layer->offset_y = 0;
        switch_layer->offset_x = sign * ext_ui_width - display_layer->offset_y;
        g_ivex_cntx.display_layer_last_offset_y = display_layer->offset_y;
        g_ivex_cntx.display_layer_last_offset_x = display_layer->offset_x;
    }
    else if ((g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90 &&
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0) ||
        (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0 &&
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270))
    {
        if(percent == 0)
        {
            display_layer->offset_y = 0;
            display_layer->offset_x = 0;
        }
        else if (g_ivex_cntx.is_spring)
        {
            display_layer->offset_y = g_ivex_cntx.display_layer_last_offset_y / 2;
            display_layer->offset_x = g_ivex_cntx.display_layer_last_offset_x / 2;
        }
        else
        {
            display_layer->offset_x = g_ivex_cntx.display_layer_last_offset_x * (100 - percent) / 100;
            display_layer->offset_y = -1 * sign * percent * ext_ui_width / 100;
        }
        switch_layer->offset_y = 0;
        switch_layer->offset_x = display_layer->offset_y + sign* ext_ui_width;
        g_ivex_cntx.display_layer_last_offset_y = display_layer->offset_y;
        g_ivex_cntx.display_layer_last_offset_x = display_layer->offset_x;
    }
    else if ((g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0 &&
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180) ||
        (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90 &&
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270))
    {
        if(percent == 0)
        {
            display_layer->offset_y = 0;
            display_layer->offset_x = 0;
        }
        else if (g_ivex_cntx.is_spring)
        {
            display_layer->offset_y = g_ivex_cntx.display_layer_last_offset_y / 2;
            display_layer->offset_x = g_ivex_cntx.display_layer_last_offset_x / 2;
        }
        else
        {
            display_layer->offset_y = g_ivex_cntx.display_layer_last_offset_y * (100 - percent) / 100;
            display_layer->offset_x = sign * percent * ext_ui_width / 100;
        }
        switch_layer->offset_y = 0;
        switch_layer->offset_x = sign * ext_ui_width - display_layer->offset_x;
        g_ivex_cntx.display_layer_last_offset_x = display_layer->offset_x;
        g_ivex_cntx.display_layer_last_offset_y = display_layer->offset_y;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_move_layer
 * DESCRIPTION
 *  This function is called to move layer to the right position.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_move_layer(ivex_osd_layer_struct *display_layer, ivex_osd_layer_struct *switch_layer, MMI_BOOL is_playback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 sign = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY && !is_playback) ||
        g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
    {
        sign = 1;
    }
    else
    {
        sign = -1;
    }

    if ((sign * switch_layer->offset_x) <= 0)
    {
        switch_layer->offset_x = 0;
    }
    mmi_ivex_layer_set_position(g_ivex_cntx.display_layer_handle, display_layer);
    mmi_ivex_layer_set_position(g_ivex_cntx.switch_layer_handle, switch_layer);
    if (switch_layer->offset_x == 0)
    {
        /* avoid the lastest frame quiver */
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_switch_pre
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_switch_pre(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_SWITCH_PREV;
    /* if current animation is decoding, need to stop it */
    //mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);

    /* set blt layers */
    mmi_ivex_layer_set_blt_layer();
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SWI_PREV);
    //mmi_ivex_start_renderer();
    mmi_ivex_switch_previous_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_switch_pre
 * DESCRIPTION
 *  this function is for interrupt under state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_switch_pre(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL gest_move = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_SWI_PREV);
    gui_cancel_timer(mmi_ivex_switch_previous_cyclic);

    if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
    #ifdef __MMI_TOUCH_SCREEN__
        gest_move = mmi_ivex_protect_gesture_switch(g_ivex_cntx.image_state);
    #endif
        if (!gest_move && !g_ivex_cntx.is_spring)
        {
            /* gesture moving not need stop render */
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_SWI_PREV_1);
            //mmi_ivex_stop_renderer();
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        }
        mmi_ivex_save_image_info_for_interrupt_switch(&g_ivex_cntx.switch_frame_precent);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_previous_cyclic
 * DESCRIPTION
 *  This function prepare zoomin image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_previous_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_terminate = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    /* pen event, so stop switch next, need stop renderer */
    if (g_ivex_cntx.is_pen_down == MMI_TRUE &&
        g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_PLAY)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREV_CYC_STOP_RENDER);
        //mmi_ivex_stop_renderer();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        return;
    }
#endif

    is_terminate = mmi_ivex_switch_previous_ease_out();
    if (is_terminate)
    {
        mmi_ivex_reset_new_display_image_setting();
        srv_mediacache_switch_prev(g_ivex_cntx.srv_mediacache_handle);
        mmi_ivex_switch_layer_done();

        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
        {
            mmi_ivex_sleep_play();
        }
        else
        {
            /* stop renderer for switching */
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREV_CYC_STOP_RENDER_1);
            //mmi_ivex_stop_renderer();
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
            /* judge if need switch continuously */
            if (g_ivex_cntx.switch_orientation == MMI_IVEX_SWITCH_JUST_PRE)
            {
                g_ivex_cntx.is_switch_two = MMI_FALSE;
                g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
                mmi_ivex_previous_image_release();
            }
            else if (g_ivex_cntx.is_switch_two)
            {
                g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
                mmi_ivex_previous_image_release();
            }
            else
            {
                mmi_ivex_adjust_to_align_motion();
            }
        }
    }
    else
    {
        /* move prev frame */
        g_ivex_cntx.switch_frame_precent += MMI_IVEX_SWITCH_FRAME_STEP;
        gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_switch_previous_cyclic);
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_previous_ease_out
 * DESCRIPTION
 *  This function is called to set position.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL if has done
 *****************************************************************************/
MMI_BOOL mmi_ivex_switch_previous_ease_out(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct display_layer;
    ivex_osd_layer_struct switch_layer;
    S32 ext_ui_width;
    S32 percent;
    MMI_BOOL is_playback = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        is_playback = MMI_TRUE;
    }

    ext_ui_width = mmi_ivex_get_ext_ui_width();

    percent = mmi_ivex_get_layer_offset_percent(ext_ui_width);

    mmi_ivex_get_layer_offset_coordinate(percent, ext_ui_width, &display_layer, &switch_layer, is_playback);

    mmi_ivex_move_layer(&display_layer, &switch_layer, is_playback);

    if (switch_layer.offset_x >= 0)
    {
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_next_image_press
 * DESCRIPTION
 *  This function switch to next image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_next_image_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_switch_is_valid())
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->rarrow.is_press = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_next_image_release
 * DESCRIPTION
 *  This function switch to next image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_next_image_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct display_layer;
    ivex_osd_layer_struct switch_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_NEXT_RELEASE,
        g_ivex_cntx.active_osd_layout_ptr->rarrow.is_press,g_ivex_cntx.switch_orientation);
    if (!mmi_ivex_check_switch_is_valid() ||
        g_ivex_cntx.switch_orientation != MMI_IVEX_SWITCH_JUST_NEXT)
    {
        if (g_ivex_cntx.is_switch_two &&
            g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL)
        {
            g_ivex_cntx.is_switch_two = MMI_FALSE;
        }
        else
        {
            return;
        }
    }
    g_ivex_cntx.active_osd_layout_ptr->rarrow.is_press = MMI_FALSE;
    MMI_ASSERT(g_ivex_cntx.image_info.filepath != NULL);
    MMI_ASSERT(g_ivex_cntx.switch_image_info.filepath != NULL);
    /* prepare the switch image info */
    if (!mmi_ivex_prepare_next_image())
    {
        return;
    }

    display_layer.offset_x = 0;
    display_layer.offset_y = 0;
    /* switch layer not rotate as display. switch layer has the same rotate angle with ui */
    switch_layer.offset_x = mmi_ivex_get_ext_ui_width();
    switch_layer.offset_y = 0;
    g_ivex_cntx.switch_frame_precent = MMI_IVEX_SWITCH_FRAME_STEP;
    mmi_ivex_layer_set_position(g_ivex_cntx.display_layer_handle, &display_layer);
    mmi_ivex_layer_set_position(g_ivex_cntx.switch_layer_handle, &switch_layer);
    mmi_ivex_start_switch_next();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_next_image_for_key
 * DESCRIPTION
 *  This function switch to next image, used to key down act
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_next_image_for_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_KEY_SWI_NEXT,g_ivex_cntx.switch_orientation);
#ifdef __MMI_TOUCH_SCREEN__
    if (!g_ivex_cntx.is_pen_down && g_ivex_cntx.key_press)
#endif
    {
        g_ivex_cntx.switch_orientation = MMI_IVEX_SWITCH_JUST_NEXT;
        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
        {
            g_ivex_cntx.is_switch_two = MMI_TRUE;
        }
    }

    mmi_ivex_next_image_press();
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_KEY_SWI_NEXT,g_imgview_cui_ptr->view_mode.viewmode);
    switch (g_imgview_cui_ptr->view_mode.viewmode)
    {
        case CUI_IMGVIEW_VIEWMODE_FILENAME:
            break;
        case CUI_IMGVIEW_VIEWMODE_PREFETCH:
            mmi_ivex_prefetch_image(MMI_TRUE);
            break;
        case CUI_IMGVIEW_VIEWMODE_FILELIST:
            mmi_ivex_next_image_release();
            break;
        case CUI_IMGVIEW_VIEWMODE_FILENAME_ARRAY:
            break;
        case CUI_IMGVIEW_VIEWMODE_IMAGEID_ARRAY:
            break;
        case CUI_IMGVIEW_VIEWMODE_FOLDER:
            mmi_ivex_next_image_release();
            break;
        default:
            mmi_ivex_next_image_release();
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_switch_next
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_switch_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_SWITCH_NEXT;
    TMP_TRACE_TIME("[IVAPP][SWITCH] start switch next: %d");
    /* if current animation is decoding, need to stop it */
    //mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);

    /* set blt layers */
    mmi_ivex_layer_set_blt_layer();
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SWI_NEXT);
    //mmi_ivex_start_renderer();
    mmi_ivex_switch_next_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_switch_next
 * DESCRIPTION
 *  this function is for interrupt under state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_switch_next(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL gest_move = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_SWI_NEXT);
    gui_cancel_timer(mmi_ivex_switch_next_cyclic);

    if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
    #ifdef __MMI_TOUCH_SCREEN__
        gest_move = mmi_ivex_protect_gesture_switch(g_ivex_cntx.image_state);
    #endif
        if (!gest_move && !g_ivex_cntx.is_spring)
        {
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_SWI_NEXT_1);
            //mmi_ivex_stop_renderer();
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        }
        mmi_ivex_save_image_info_for_interrupt_switch(&g_ivex_cntx.switch_frame_precent);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_next_cyclic
 * DESCRIPTION
 *  This function prepare zoomin image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_next_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_terminate = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TMP_TRACE_TIME("[IVAPP][SWITCH] mmi_ivex_switch_next_cyclic entry: %d");
#ifdef __MMI_TOUCH_SCREEN__
    /* pen event, so stop switch next, need stop renderer */
    if (g_ivex_cntx.is_pen_down == MMI_TRUE &&
        g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_PLAY)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_NEXT_CYC_STOP_RENDER);
        //mmi_ivex_stop_renderer();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        return;
    }
#endif

    is_terminate = mmi_ivex_switch_next_ease_out();
    if (is_terminate)
    {
        TMP_TRACE_TIME("[IVAPP][SWITCH] mmi_ivex_switch_next_cyclic end: %d");
        mmi_ivex_reset_new_display_image_setting();
        srv_mediacache_switch_next(g_ivex_cntx.srv_mediacache_handle);
        mmi_ivex_switch_layer_done();

        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
        {
            mmi_ivex_sleep_play();
        }
        else
        {
            /* stop renderer for switching */
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_NEXT_CYC_STOP_RENDER_1);
            //mmi_ivex_stop_renderer();
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
            /* judge if need switch continuously if long press will switch continuously */
            if (g_ivex_cntx.switch_orientation == MMI_IVEX_SWITCH_JUST_NEXT)
            {
                g_ivex_cntx.is_switch_two = MMI_FALSE;
                g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
                mmi_ivex_next_image_release();
            }
            else if (g_ivex_cntx.is_switch_two)
            {
                g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
                mmi_ivex_next_image_release();
            }
            else
            {
                mmi_ivex_adjust_to_align_motion();
            }
        }
    }
    else
    {
        TMP_TRACE_TIME("[IVAPP][SWITCH] mmi_ivex_switch_next_cyclic with timer 40: %d");
        /* move next frame */
        g_ivex_cntx.switch_frame_precent += MMI_IVEX_SWITCH_FRAME_STEP;
        gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_switch_next_cyclic);
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
    }

    TMP_TRACE_TIME("[IVAPP][SWITCH] mmi_ivex_switch_next_cyclic exit: %d");
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_next_ease_out
 * DESCRIPTION
 *  This function is called to set position.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL if has done
 *****************************************************************************/
MMI_BOOL mmi_ivex_switch_next_ease_out(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct display_layer;
    ivex_osd_layer_struct switch_layer;
    S32 ext_ui_width;
    S32 percent;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ext_ui_width = mmi_ivex_get_ext_ui_width();

    percent = mmi_ivex_get_layer_offset_percent(ext_ui_width);

    mmi_ivex_get_layer_offset_coordinate(percent, ext_ui_width, &display_layer, &switch_layer, MMI_FALSE);

    mmi_ivex_move_layer(&display_layer, &switch_layer, MMI_FALSE);

    if (switch_layer.offset_x <= 0)
    {
        return MMI_TRUE;
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_zoomin_image
 * DESCRIPTION
 *  This function prepare zoomin image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_zoomin_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 last_draw_offset_x;/* last draw position on lcd */
    S32 last_draw_offset_y;
    float real_multiple = 1;
    float multiple = 1;
    S32 image_width;
    S32 image_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREP_ZOOMIN,g_ivex_cntx.image_info.zoom_cnt);
    /* this is for not gesture */
    last_draw_offset_x = g_ivex_cntx.image_info.draw_offset_x;
    last_draw_offset_y = g_ivex_cntx.image_info.draw_offset_y;

    if (g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMIN_TO_MAX)
    {
        mmi_ivex_set_shortcut_zoom_factor(&g_ivex_cntx.image_info, &real_multiple);
    }
    else
    {
        float temp = g_ivex_cntx.image_info.curr_zoom_factor;
        g_ivex_cntx.image_info.zoom_cnt += MMI_IVEX_KEY_ZOOM_UNIT;
        multiple = mmi_ivex_calculate_real_zoom_factor(g_ivex_cntx.image_info.zoom_factor, MMI_IVEX_KEY_ZOOM_UNIT);
        g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.curr_zoom_factor * multiple;
        /*ajust the zoom factor to avoid the last zoom is very tiny */
        if((g_ivex_cntx.image_info.max_zoom_factor - g_ivex_cntx.image_info.curr_zoom_factor) < 0.01){
            g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.max_zoom_factor;
            multiple = g_ivex_cntx.image_info.max_zoom_factor / temp;
        }
    }

    image_width = (S32)(g_ivex_cntx.image_info.original_width * (float)g_ivex_cntx.image_info.curr_zoom_factor + 0.5);
    image_height = (S32)(g_ivex_cntx.image_info.original_height * (float)g_ivex_cntx.image_info.curr_zoom_factor + 0.5);
    /* the enlarged image can be x2 larger of original dimension */
    if (g_ivex_cntx.image_info.curr_zoom_factor >=2)
    {
        real_multiple = (real_multiple * multiple) / (g_ivex_cntx.image_info.curr_zoom_factor / 2);
        multiple = 1.0;
        g_ivex_cntx.image_info.curr_zoom_factor =2;
        image_width = g_ivex_cntx.image_info.original_width * 2;
        image_height = g_ivex_cntx.image_info.original_height * 2;
    }

    /* remember resized image dimension */
    if (image_height < 1)
    {
        image_height = 1;
    }
    if (image_width < 1)
    {
        image_width = 1;
    }
    g_ivex_cntx.image_info.resized_image_height = image_height;
    g_ivex_cntx.image_info.resized_image_width = image_width;

    /* calculate x coordination */
    if (image_width > g_ivex_cntx.view_layer_width)
    {
        g_ivex_cntx.image_info.draw_offset_x = 0;
        g_ivex_cntx.image_info.resized_width = g_ivex_cntx.view_layer_width;
        if (last_draw_offset_x == 0)
        {
            /* +1 for case: such as the change is 1.9, then devide 2 will be 0. so +1 reduce the error */
            g_ivex_cntx.image_info.resized_offset_x =
                (S32)(real_multiple * multiple * (float)g_ivex_cntx.image_info.resized_offset_x +
                ((float)g_ivex_cntx.view_layer_width * multiple * real_multiple - (float)g_ivex_cntx.view_layer_width + 1.0) / 2.0);
        }
        else if (last_draw_offset_x > 0)
        {
            g_ivex_cntx.image_info.resized_offset_x = (image_width - g_ivex_cntx.view_layer_width)>>1;
        }
        else
        {
            MMI_ASSERT(0);
        }
    }
    else
    {
        g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - image_width)>>1;
        g_ivex_cntx.image_info.resized_width = image_width;
        g_ivex_cntx.image_info.resized_offset_x = 0;
    }

    /* calculate x coordination */
    if (image_height > g_ivex_cntx.view_layer_height)
    {
        g_ivex_cntx.image_info.draw_offset_y = 0;
        g_ivex_cntx.image_info.resized_height = g_ivex_cntx.view_layer_height;
        if (last_draw_offset_y == 0)
        {
            g_ivex_cntx.image_info.resized_offset_y =
                (S32)(real_multiple * multiple * (float)g_ivex_cntx.image_info.resized_offset_y +
                ((float)g_ivex_cntx.view_layer_height * multiple * real_multiple - (float)g_ivex_cntx.view_layer_height + 1.0) / 2.0);
        }
        else if (last_draw_offset_y > 0)
        {
            g_ivex_cntx.image_info.resized_offset_y = (image_height - g_ivex_cntx.view_layer_height)>>1;
        }
        else
        {
            MMI_ASSERT(0);
        }
    }
    else
    {
        g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - image_height)>>1;
        g_ivex_cntx.image_info.resized_height = image_height;
        g_ivex_cntx.image_info.resized_offset_y = 0;
    }

    /* judge if is zoom in enable next step */
    g_ivex_cntx.image_info.is_zoomin_able = MMI_FALSE;
    g_ivex_cntx.image_info.is_zoomout_able = MMI_TRUE;
    if (g_ivex_cntx.image_info.curr_zoom_factor >= g_ivex_cntx.image_info.max_zoom_factor)
    {
        g_ivex_cntx.image_info.is_zoomin_able = MMI_FALSE;
    }
    else
    {
        g_ivex_cntx.image_info.is_zoomin_able = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_zoomout_image
 * DESCRIPTION
 *  This function prepare zoomout image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_zoomout_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 last_draw_offset_x;/* last draw position on lcd */
    S32 last_draw_offset_y;
    float real_multiple = 1;
    float multiple = 1;
    S32 image_width;
    S32 image_height;
    U16 temp_zoom_unit = MMI_IVEX_KEY_ZOOM_UNIT;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PREP_ZOOMOUT,g_ivex_cntx.image_info.zoom_cnt);
    /* this is for not gesture */
    last_draw_offset_x = g_ivex_cntx.image_info.draw_offset_x;
    last_draw_offset_y = g_ivex_cntx.image_info.draw_offset_y;
    if (g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMOUT_TO_MIN)
    {
        mmi_ivex_set_shortcut_zoom_factor(&g_ivex_cntx.image_info, &real_multiple);
    }
    else
    {
        if (g_ivex_cntx.image_info.zoom_cnt >= MMI_IVEX_KEY_ZOOM_UNIT)
        {
            g_ivex_cntx.image_info.zoom_cnt -= MMI_IVEX_KEY_ZOOM_UNIT;
            temp_zoom_unit = MMI_IVEX_KEY_ZOOM_UNIT;
        }
        else if (g_ivex_cntx.image_info.zoom_cnt > 0)
        {
            temp_zoom_unit = g_ivex_cntx.image_info.zoom_cnt;
            g_ivex_cntx.image_info.zoom_cnt = 0;
        }
        else
        {
            MMI_ASSERT(0);
        }
        multiple = mmi_ivex_calculate_real_zoom_factor(g_ivex_cntx.image_info.zoom_factor, temp_zoom_unit);
        g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.curr_zoom_factor / multiple;
        if((g_ivex_cntx.image_info.curr_zoom_factor - g_ivex_cntx.image_info.min_zoom_factor) < 0.01){
            g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.min_zoom_factor;
        }
    }

    if ((g_ivex_cntx.image_info.curr_zoom_factor < g_ivex_cntx.image_info.min_zoom_factor) || (g_ivex_cntx.image_info.zoom_cnt == 0))
    {
        g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.min_zoom_factor;
    }

    image_width = (S32)(g_ivex_cntx.image_info.original_width * (float)g_ivex_cntx.image_info.curr_zoom_factor + 0.5);
    image_height = (S32)(g_ivex_cntx.image_info.original_height * (float)g_ivex_cntx.image_info.curr_zoom_factor + 0.5);
    /* remember resized image dimension */
    if (image_height < 1)
    {
        image_height = 1;
    }

    if (image_width < 1)
    {
        image_width = 1;
    }

    g_ivex_cntx.image_info.resized_image_height = image_height;
    g_ivex_cntx.image_info.resized_image_width = image_width;

    /* calculate x coordination */
    if (image_width < g_ivex_cntx.view_layer_width)
    {
        g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - image_width)>>1;
        g_ivex_cntx.image_info.resized_width = image_width;
        g_ivex_cntx.image_info.resized_offset_x = 0;
    }
    else
    {
        g_ivex_cntx.image_info.draw_offset_x = 0;
        g_ivex_cntx.image_info.resized_width = g_ivex_cntx.view_layer_width;

        if (last_draw_offset_x != 0)
        {
            MMI_ASSERT(0);
        }
        g_ivex_cntx.image_info.resized_offset_x =
            (S32)((float)g_ivex_cntx.image_info.resized_offset_x / (real_multiple * multiple) -
            ((float)g_ivex_cntx.view_layer_width - (float)g_ivex_cntx.view_layer_width / (real_multiple * multiple) - 1.0) / 2.0);

        if (g_ivex_cntx.image_info.resized_offset_x <= 0)
        {
            g_ivex_cntx.image_info.resized_offset_x = 0;
        }

        if (g_ivex_cntx.image_info.resized_offset_x + g_ivex_cntx.image_info.resized_width > image_width)
        {
            g_ivex_cntx.image_info.resized_offset_x = image_width - g_ivex_cntx.image_info.resized_width;
        }
    }

    /* calculate y coordination */
    if (image_height < g_ivex_cntx.view_layer_height)
    {
        g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - image_height)>>1;
        g_ivex_cntx.image_info.resized_height = image_height;
        g_ivex_cntx.image_info.resized_offset_y = 0;
    }
    else
    {
        g_ivex_cntx.image_info.draw_offset_y = 0;
        g_ivex_cntx.image_info.resized_height = g_ivex_cntx.view_layer_height;

        if (last_draw_offset_y != 0)
        {
            MMI_ASSERT(0);
        }

        g_ivex_cntx.image_info.resized_offset_y =
            (S32)((float)g_ivex_cntx.image_info.resized_offset_y / (real_multiple * multiple)  -
            ((float)g_ivex_cntx.view_layer_height - (float)g_ivex_cntx.view_layer_height / (real_multiple * multiple)  - 1.0) / 2.0);

        if (g_ivex_cntx.image_info.resized_offset_y <= 0)
        {
            g_ivex_cntx.image_info.resized_offset_y = 0;
        }

        if (g_ivex_cntx.image_info.resized_offset_y + g_ivex_cntx.image_info.resized_height > image_height)
        {
            g_ivex_cntx.image_info.resized_offset_y = image_height - g_ivex_cntx.image_info.resized_height;
        }
    }

    /* judge if is zoom in enable next step */
    g_ivex_cntx.image_info.is_zoomin_able = MMI_TRUE;
    g_ivex_cntx.image_info.is_zoomout_able = MMI_FALSE;

    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        g_ivex_cntx.image_info.is_zoomout_able = MMI_TRUE;
    }
    else
    {
        g_ivex_cntx.image_info.is_zoomout_able = MMI_FALSE;
    }
}

#ifdef __IVEX_SUPPORT_IES__
#define CAPSANIMATIONSTEP 0.2f
#define CAPSANIMATIONSTEP_S 0.12f

#define CAPSANIMATIONLEVELSTEP 2
#define CAPSANIMATIONLIMITSTEP 3

static MMI_BOOL mmi_ivex_zoom_cyclic_next_frame()
{
	g_ivex_cntx.image_info.CAPS_zoom_progrss+=g_ivex_cntx.Caps_step;

	if(g_ivex_cntx.image_info.CAPS_zoom_progrss>=0.99)
	{
		//mmi_ivex_stop_zoomin();
		return MMI_TRUE;
	}else
	{
		return MMI_FALSE;
	}
}

static U16 mmi_ivex_get_max_zoom_cnt(void)
{
    if(g_ivex_cntx.image_info.CAPS_max_level > 4){
        return 3*MMI_IVEX_KEY_ZOOM_UNIT;
    }else if(g_ivex_cntx.image_info.CAPS_max_level > 2){
        return 2*MMI_IVEX_KEY_ZOOM_UNIT;
    }else{
        return MMI_IVEX_KEY_ZOOM_UNIT;
    }
}

#endif /* __IVEX_SUPPORT_IES__ */

static MMI_BOOL mmi_ivex_prepare_zoomin(void)
{
    MMI_BOOL ret = MMI_TRUE;
#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
    {
        if(mmi_ivex_zoom_cyclic_next_frame())
        {
            //update the image resized dimention.
//            mmi_ivex_update_zoom_dim();
            if(g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMIN_TO_MAX){
                g_ivex_cntx.image_info.zoom_cnt = mmi_ivex_get_max_zoom_cnt();
            }else{
            g_ivex_cntx.image_info.zoom_cnt += MMI_IVEX_KEY_ZOOM_UNIT;
            }
          //reinit and start the next step.
            if(g_ivex_cntx.image_info.CAPS_zoom_level >= g_ivex_cntx.image_info.CAPS_max_level)
                g_ivex_cntx.image_info.is_zoomin_able = MMI_FALSE;
            else if(g_ivex_cntx.is_zoomin == MMI_TRUE){
                g_ivex_cntx.image_info.CAPS_flag= MMI_IVEX_caps_running_animate;
                g_ivex_cntx.image_info.CAPS_zoom_progrss=0;
                g_ivex_cntx.image_info.CAPS_zoom_level*=CAPSANIMATIONLEVELSTEP;
                if(g_ivex_cntx.image_info.CAPS_zoom_level > 4)
                    g_ivex_cntx.image_info.CAPS_zoom_level = g_ivex_cntx.image_info.CAPS_max_level;
                g_ivex_cntx.is_scalado_anim = MMI_TRUE;
            }

            ret = (MMI_BOOL)(g_ivex_cntx.image_info.is_zoomin_able == MMI_TRUE &&  g_ivex_cntx.is_zoomin == MMI_TRUE);
            if(ret == MMI_FALSE){
                g_ivex_cntx.image_info.is_zoomout_able = MMI_TRUE;
                /* completely for result, no reason */                
                g_ivex_cntx.is_zoomin = MMI_TRUE;
                mmi_ivex_draw_osd_panel_layer();
                mmi_ivex_stop_zoomin();
             }
         }

     }else{
#endif /* __IVEX_SUPPORT_IES__ */
    
        mmi_ivex_prepare_zoomin_image();
    
#ifdef __IVEX_SUPPORT_IES__
      }
#endif /* __IVEX_SUPPORT_IES__ */

    return ret;

}
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_zoomin_cyclic
 * DESCRIPTION
 *  This function handles zoom in event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_zoomin_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
	

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TMP_TRACE1("[IVAPP][YWY]mmi_ivex_zoomin_cyclic, line=%d", __LINE__);
    MMI_ASSERT(g_ivex_cntx.image_info.filepath != NULL);
    gui_start_timer(MMI_IVEX_ZOOM_INTERVAL, mmi_ivex_zoomin_cyclic);
    TMP_TRACE1("[IVAPP][YWY]mmi_ivex_zoomin_cyclic, start timer, line=%d", __LINE__);

    /* prepare the switch image info */
    if(mmi_ivex_prepare_zoomin()== MMI_FALSE){
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        return;
    }

    if (!g_ivex_cntx.image_info.is_zoomin_able)
    {
        /* restore not press state */
        mmi_ivex_draw_osd_panel_layer(); /* this will avoid the icon still is enable when is not avilibale in fact under loading state */
        mmi_ivex_stop_zoomin();
        return;
    }else{
    
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_ZOOM);
        if (ret < SRV_MEDIACACHE_OK)
        {
            gui_cancel_timer(mmi_ivex_zoomin_cyclic);
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }

    }
    
    /* blt in times for more stable */
#if 0 //def __IVEX_SUPPORT_IES__
/* under construction !*/
/* under construction !*/
#endif  /* __IVEX_SUPPORT_IES__ */
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

#if 0 //def __IVEX_SUPPORT_IES__
/* under construction !*/
#endif /* __IVEX_SUPPORT_IES__ */
}

static MMI_BOOL mmi_ivex_prepare_zoomout(void)
{
    MMI_BOOL ret = MMI_TRUE;
#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
    {
        if(mmi_ivex_zoom_cyclic_next_frame())
        {
            //mmi_ivex_update_zoom_dim();
            if(g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMOUT_TO_MIN){
                g_ivex_cntx.image_info.zoom_cnt = 0;
            }else{
            g_ivex_cntx.image_info.zoom_cnt -= MMI_IVEX_KEY_ZOOM_UNIT;
            }
          //reinit and start the next step.
            if(g_ivex_cntx.image_info.CAPS_zoom_level <= 1)
                g_ivex_cntx.image_info.is_zoomout_able = MMI_FALSE;
            else if(g_ivex_cntx.is_zoomout == MMI_TRUE){
                g_ivex_cntx.image_info.CAPS_flag = MMI_IVEX_caps_running_animate;
                g_ivex_cntx.image_info.CAPS_zoom_progrss=0;
                g_ivex_cntx.image_info.CAPS_zoom_level /= CAPSANIMATIONLEVELSTEP;
                g_ivex_cntx.is_scalado_anim = MMI_TRUE;
            }

            ret = (MMI_BOOL)(g_ivex_cntx.image_info.is_zoomout_able == MMI_TRUE &&  g_ivex_cntx.is_zoomout == MMI_TRUE);
            if(ret == MMI_FALSE){
                g_ivex_cntx.image_info.is_zoomin_able = MMI_TRUE;
                /* completely for result, no reason */                
                g_ivex_cntx.is_zoomout = MMI_TRUE;
                mmi_ivex_draw_osd_panel_layer();
                mmi_ivex_stop_zoomout();
             }
         }

     }else{
#endif /* __IVEX_SUPPORT_IES__ */
    
        mmi_ivex_prepare_zoomout_image();
    
#ifdef __IVEX_SUPPORT_IES__
      }
#endif /* __IVEX_SUPPORT_IES__ */

    return ret;

}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_zoomout_cyclic
 * DESCRIPTION
 *  This function handles zoom in event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_zoomout_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_ivex_cntx.image_info.filepath != NULL);
    gui_start_timer(MMI_IVEX_ZOOM_INTERVAL, mmi_ivex_zoomout_cyclic);
    /* prepare the switch image info */
    if(mmi_ivex_prepare_zoomout() == MMI_FALSE){
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        return;
    }

    if (!g_ivex_cntx.image_info.is_zoomout_able)
    {
        mmi_ivex_draw_osd_panel_layer(); /* this will avoid the icon still is enable when is not avilibale in fact under loading state */
        mmi_ivex_stop_zoomout();
        return;
    }else{
    
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_ZOOM);
        if (ret < SRV_MEDIACACHE_OK)
        {
            gui_cancel_timer(mmi_ivex_zoomout_cyclic);
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }
    /* blt in times for more stable */

#if 0 //def __IVEX_SUPPORT_IES__
/* under construction !*/
/* under construction !*/
#endif  /* __IVEX_SUPPORT_IES__ */
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
#if 0 //def __IVEX_SUPPORT_IES__
/* under construction !*/
#endif  /* __IVEX_SUPPORT_IES__ */

}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_zoomin
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_zoomin(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_START_ZOOMIN);
    if (g_ivex_cntx.is_zoomin == MMI_FALSE)
    {
#ifndef __IVEX_SUPPORT_IES__
        GDI_LOCK;
#endif
        g_ivex_cntx.is_zoomin = MMI_TRUE;
        //mmi_ivex_start_renderer();
#ifdef __IVEX_SUPPOERT_ANIM_ZOOM__
        if(g_ivex_cntx.image_info.is_animation){
            S32 x, y;
            srv_mediacache_util_fix_box(
                g_ivex_cntx.view_layer_width, g_ivex_cntx.view_layer_height, 
                g_ivex_cntx.image_info.original_width, g_ivex_cntx.image_info.original_height,
                &x,
                &y,
                &g_ivex_cntx.iv_limit_width,
                &g_ivex_cntx.iv_limit_height,
                g_ivex_cntx.image_info.image_type);
        }else
#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/
        {
            srv_mediacache_calc_h_w_by_image_and_length(g_ivex_cntx.image_info.filelist_index, MMI_IVEX_LARGE_CACHE_SIZE, &g_ivex_cntx.iv_limit_width, &g_ivex_cntx.iv_limit_height);
        }
        if (g_ivex_cntx.iv_limit_width <= 0 || g_ivex_cntx.iv_limit_height <= 0)
        {
            g_ivex_cntx.iv_limit_width = g_ivex_cntx.image_info.original_width;
            g_ivex_cntx.iv_limit_height = g_ivex_cntx.image_info.original_height;
        }
        g_ivex_cntx.image_info.max_zoom_factor = mmi_ivex_get_max_zoom_factor(&g_ivex_cntx.image_info);

#ifdef __IVEX_SUPPORT_IES__
        if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
        {
            g_ivex_cntx.Caps_step = CAPSANIMATIONSTEP;
            g_ivex_cntx.image_info.CAPS_flag = MMI_IVEX_caps_running_animate;
            g_ivex_cntx.is_scalado_anim = MMI_TRUE;
            //g_ivex_cntx.image_info.CAPS_zoom_level*=CAPSANIMATIONLEVELSTEP;
            if (g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMIN_TO_MAX)
            {
    	        g_ivex_cntx.image_info.CAPS_zoom_level= g_ivex_cntx.image_info.CAPS_max_level;
    	        if((g_ivex_cntx.image_info.original_height - g_ivex_cntx.image_info.resized_image_height > 800 )
    	        ||(g_ivex_cntx.image_info.original_width- g_ivex_cntx.image_info.resized_image_width > 800 ))
    	          g_ivex_cntx.Caps_step = CAPSANIMATIONSTEP_S;
            }
            else
            {
                g_ivex_cntx.image_info.CAPS_zoom_level*=CAPSANIMATIONLEVELSTEP;
                if(g_ivex_cntx.image_info.CAPS_zoom_level > 4)
                {
                    g_ivex_cntx.image_info.CAPS_zoom_level = g_ivex_cntx.image_info.CAPS_max_level;
                }
            }
            g_ivex_cntx.image_info.CAPS_zoom_progrss=0;
            //MMI_ASSERT(g_ivex_cntx.image_info.CAPS_zoom_level<=MMI_IVEX_MAX_ZOOM_LEVEL);
        }
#endif /* __IVEX_SUPPORT_IES__ */
        mmi_ivex_zoomin_cyclic();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_zoomin
 * DESCRIPTION
 *  this function is for interrupt under zoomin state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_zoomin(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_zoomin_cyclic);
    if (g_ivex_cntx.is_zoomin == MMI_TRUE)
    {
#ifndef __IVEX_SUPPORT_IES__
        GDI_UNLOCK;
#endif
        g_ivex_cntx.is_zoomin = MMI_FALSE;

#ifdef __IVEX_SUPPORT_IES__
        g_ivex_cntx.is_scalado_anim = MMI_FALSE;
        g_ivex_cntx.image_info.CAPS_flag = MMI_IVEX_caps_stop_animate;
#endif

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_ZOOMIN);
        mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        //mmi_ivex_stop_renderer();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
    }
    g_ivex_cntx.active_osd_layout_ptr->zoomin.is_press = MMI_FALSE;
    g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
    TMP_TRACE1("[IVAPP][YWY]stop zoomin, line=%d", __LINE__);  
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_zoomout
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_zoomout(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_START_ZOOMOUT);
    if (g_ivex_cntx.is_zoomout == MMI_FALSE)
    {
#ifndef __IVEX_SUPPORT_IES__
        GDI_LOCK;
#endif
        g_ivex_cntx.is_zoomout = MMI_TRUE;

        /* need start render first because when can only zoom out one time, will stop render in cyclic even if still press */
        //mmi_ivex_start_renderer();
        g_ivex_cntx.image_info.max_zoom_factor = mmi_ivex_get_max_zoom_factor(&g_ivex_cntx.image_info);

#ifdef __IVEX_SUPPORT_IES__
        if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
        {
            g_ivex_cntx.Caps_step = CAPSANIMATIONSTEP;
        	g_ivex_cntx.image_info.CAPS_flag = MMI_IVEX_caps_running_animate;
            g_ivex_cntx.is_scalado_anim = MMI_TRUE;

        	if (g_ivex_cntx.zoom_orientation == MMI_IVEX_ZOOMOUT_TO_MIN)
            {
    	        g_ivex_cntx.image_info.CAPS_zoom_level=1;
    	        if((g_ivex_cntx.image_info.resized_image_height - g_ivex_cntx.image_info.fit_screen_height > 800 )
    	         ||(g_ivex_cntx.image_info.resized_image_width- g_ivex_cntx.image_info.fit_screen_width > 800 ))
    	          g_ivex_cntx.Caps_step = CAPSANIMATIONSTEP_S;
        
            }else
            {
                if(g_ivex_cntx.image_info.CAPS_zoom_level > 4)
                    g_ivex_cntx.image_info.CAPS_zoom_level = 4;
                else if(g_ivex_cntx.image_info.CAPS_zoom_level > 2)
                    g_ivex_cntx.image_info.CAPS_zoom_level = 2;
                else
        	        g_ivex_cntx.image_info.CAPS_zoom_level = 1;
            }

        	g_ivex_cntx.image_info.CAPS_zoom_progrss=0;
        }
#endif /* __IVEX_SUPPORT_IES__ */

        mmi_ivex_zoomout_cyclic();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_zoomout
 * DESCRIPTION
 *  this function is for interrupt under zoomin state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_zoomout(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_zoomout_cyclic);
    if (g_ivex_cntx.is_zoomout == MMI_TRUE)
    {
#ifndef __IVEX_SUPPORT_IES__
        GDI_UNLOCK;
#endif
        g_ivex_cntx.is_zoomout = MMI_FALSE;

#ifdef __IVEX_SUPPORT_IES__
        g_ivex_cntx.is_scalado_anim = MMI_FALSE;
        g_ivex_cntx.image_info.CAPS_flag = MMI_IVEX_caps_stop_animate;
#endif

        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_ZOOMOUT);
        mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        //mmi_ivex_stop_renderer();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);/* blt the fuzzy first to avoid LRZ block */
    }
    g_ivex_cntx.active_osd_layout_ptr->zoomout.is_press = MMI_FALSE;
    g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_fun_on_panel_is_valid
 * DESCRIPTION
 *  This function check if panel function operation is valid.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_fun_on_panel_is_valid(MMI_BOOL is_rsk)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_SHOW ||
        g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_STILL)
    {
        if (is_rsk)
        {
            if (g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_PLAY)
            {
                is_valid = MMI_FALSE;
            }
        }
        else
        {
            is_valid = MMI_FALSE;
        }
    }
    if (is_valid)
    {
        mmi_ivex_enable_osd_fade(MMI_FALSE);
    }
    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_zoomin_press
 * DESCRIPTION
 *  This function handles zoom in event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_zoomin_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __MMI_TOUCH_SCREEN__
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE) &&
        g_ivex_cntx.is_pen_down_zoom == MMI_FALSE)
    #else
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE))
    #endif
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
        return;
    }

    if (!g_ivex_cntx.image_info.is_zoomin_able || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->zoomin.is_press = MMI_TRUE;
    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOMIN_TO_MAX)
    {
        mmi_ivex_draw_osd_panel_layer();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
    else
    {
        g_ivex_cntx.active_osd_layout_ptr->zoomin.is_press = MMI_FALSE;
    }
    mmi_ivex_start_zoomin();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_zoomin_release
 * DESCRIPTION
 *  This function handles zoom in event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_zoomin_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* No press action will not response release */
    if (g_ivex_cntx.active_osd_layout_ptr->zoomin.is_press == MMI_FALSE)
    {
        return;
    }

    if (!g_ivex_cntx.image_info.is_zoomin_able || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
    {
        return;
    }

    g_ivex_cntx.active_osd_layout_ptr->zoomin.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
    {
        g_ivex_cntx.is_zoomin = MMI_FALSE;
    }else{
#endif
    mmi_ivex_stop_zoomin();

#ifdef __IVEX_SUPPORT_IES__
    }
#endif

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ZOOMIN_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_zoomout_press
 * DESCRIPTION
 *  This function handles zoom out event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_zoomout_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __MMI_TOUCH_SCREEN__
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE) &&
        g_ivex_cntx.is_pen_down_zoom == MMI_FALSE)
    #else
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE))
    #endif
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
        return;
    }

    if (!g_ivex_cntx.image_info.is_zoomout_able || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->zoomout.is_press = MMI_TRUE;
    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOMOUT_TO_MIN)
    {
        mmi_ivex_draw_osd_panel_layer();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
    else
    {
        g_ivex_cntx.active_osd_layout_ptr->zoomout.is_press = MMI_FALSE;
    }
    mmi_ivex_start_zoomout();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_zoomout_release
 * DESCRIPTION
 *  This function handles zoom out event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_zoomout_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.active_osd_layout_ptr->zoomout.is_press == MMI_FALSE)
    {
        return;
    }

    if (!g_ivex_cntx.image_info.is_zoomout_able || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->zoomout.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
    {
        g_ivex_cntx.is_zoomout = MMI_FALSE;
    }else{
#endif
    mmi_ivex_stop_zoomout();

#ifdef __IVEX_SUPPORT_IES__
    }
#endif

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_ZOOMOUT_RELEASE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_deal_view_layer_rotate_value
 * DESCRIPTION
 *  This function modify view layer rotate angle.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_deal_view_layer_rotate_value(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* set image rotate orientation */
    if (g_ivex_cntx.rot_oriention == MMI_IVEX_ROTATE_JUST_CCW)
    {
        if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_270;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_0;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_90;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_180;
        }
    }
    else if (g_ivex_cntx.rot_oriention == MMI_IVEX_ROTATE_JUST_CW)
    {
        if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_90;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_180;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_270;
        }
        else if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
        {
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_0;
        }
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_deal_rotate_error_loading
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_deal_rotate_error_loading(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;
    GDI_RESULT result;
    CHAR *err_str_ptr;
    U16 err_img_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* stop loading effect and rotate view layer */
    mmi_ivex_stop_curr_loading_effect();
    mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);

    result = g_ivex_cntx.image_info.result;
    err_str_ptr = g_ivex_cntx.image_info.err_str_ptr;
    err_img_id = g_ivex_cntx.image_info.err_img_id;
    mmi_ivex_reset_image_info(&g_ivex_cntx.image_info);
    g_ivex_cntx.image_info.result = result;
    g_ivex_cntx.image_info.err_str_ptr = err_str_ptr;
    g_ivex_cntx.image_info.err_img_id = err_img_id;

    /* get current file basic info */
    mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
    mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);

    if (g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK)
    {
        /* if has displayed error, not need get the image again, here should show the icon befor interrupt */
        mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
    }
    else
    {
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        if (ret < SRV_MEDIACACHE_OK)
        {
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_adjust_image_dimension_after_rotate
 * DESCRIPTION
 *  This function adjust the image dimension when rotate is over.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_adjust_image_dimension_after_rotate(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 radius = 0;
    S32 rear_lenght = 0;
    MMI_BOOL is_adjusted = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (img_info->resized_width >= g_ivex_cntx.view_layer_width)
    {
        img_info->draw_offset_x = 0;
        img_info->resized_width = g_ivex_cntx.view_layer_width;
        img_info->resized_offset_x = img_info->center_x - (g_ivex_cntx.view_layer_width >> 1);

        radius = g_ivex_cntx.view_layer_height>>1;
        rear_lenght = img_info->resized_image_height - img_info->center_y;
        if (img_info->resized_image_height >= g_ivex_cntx.view_layer_height)
        {
            img_info->draw_offset_y = 0;
            img_info->resized_height = g_ivex_cntx.view_layer_height;
            if (img_info->center_y >= radius &&
                rear_lenght >= radius)
            {
                img_info->resized_offset_y = img_info->center_y - radius;
            }
            else if (img_info->center_y >= radius)
            {
                img_info->resized_offset_y = img_info->resized_image_height - g_ivex_cntx.view_layer_height;
            }
            else if (rear_lenght >= radius)
            {
                img_info->resized_offset_y = 0;
            }
            else
            {
                MMI_ASSERT(0);
            }
        }
        else
        {
            img_info->resized_height = img_info->resized_image_height;
            img_info->resized_offset_y = 0;
            img_info->draw_offset_y = radius - (img_info->resized_image_height>>1);
        }
        is_adjusted = MMI_TRUE;
        MMI_ASSERT(img_info->resized_offset_y >= 0);
    }

    if (img_info->resized_height >= g_ivex_cntx.view_layer_height &&
        is_adjusted == MMI_FALSE)
    {
        img_info->draw_offset_y = 0;
        img_info->resized_height = g_ivex_cntx.view_layer_height;
        img_info->resized_offset_y = img_info->center_y - (g_ivex_cntx.view_layer_height >> 1);

        radius = g_ivex_cntx.view_layer_width>>1;
        rear_lenght = img_info->resized_image_width - img_info->center_x;
        if (img_info->resized_image_width >= g_ivex_cntx.view_layer_width)
        {
            img_info->draw_offset_x = 0;
            img_info->resized_width = g_ivex_cntx.view_layer_width;
            if (img_info->center_x >= radius &&
                rear_lenght >= radius)
            {
                img_info->resized_offset_x = img_info->center_x - radius;
            }
            else if (img_info->center_x >= radius)
            {
                img_info->resized_offset_x = img_info->resized_image_width - g_ivex_cntx.view_layer_width;
            }
            else if (rear_lenght >= radius)
            {
                img_info->resized_offset_x = 0;
            }
            else
            {
                MMI_ASSERT(0);
            }
        }
        else
        {
            img_info->resized_width = img_info->resized_image_width;
            img_info->resized_offset_x = 0;
            img_info->draw_offset_x = radius - (img_info->resized_image_width>>1);
        }
        is_adjusted = MMI_TRUE;
        MMI_ASSERT(img_info->resized_offset_x >= 0);
    }

    if (img_info->resized_width < g_ivex_cntx.view_layer_width &&
        img_info->resized_height < g_ivex_cntx.view_layer_height &&
        is_adjusted == MMI_FALSE)
    {
        /* this case is the same as entry first */
        mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, img_info);
        mmi_ivex_init_image_display_info(img_info, MMI_FALSE);
    }
    g_ivex_cntx.image_rotated = MMI_FALSE;
    g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_set_zoomable_after_rotate
 * DESCRIPTION
 *  This function judge if image is zoomable and set them.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_set_zoomable_after_rotate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.image_info.zoom_cnt
        = mmi_ivex_calculate_zoom_cnt(
        g_ivex_cntx.image_info.min_zoom_factor,
        g_ivex_cntx.image_info.curr_zoom_factor);

    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        g_ivex_cntx.image_info.is_zoomout_able = MMI_TRUE;
    }
    else
    {
        g_ivex_cntx.image_info.is_zoomout_able = MMI_FALSE;
    }

    if (!g_ivex_cntx.image_info.is_animation)
    {
        /* if x2 use here. [X2. twice] */
        if (mmi_ivex_calculate_zoom_cnt(g_ivex_cntx.image_info.curr_zoom_factor, 2) >= MMI_IVEX_KEY_ZOOM_UNIT)
        {
            g_ivex_cntx.image_info.is_zoomin_able = MMI_TRUE;
        }
        else
        {
            g_ivex_cntx.image_info.is_zoomin_able = MMI_FALSE;
        }
    }
    else
    {
        g_ivex_cntx.image_info.is_zoomin_able = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_rotate_changed_image_info
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_rotate_changed_image_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    float tmp_width;
    float tmp_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* initialize resized_img_width/resized_img_height */
    if ((g_ivex_cntx.image_info.original_width < g_ivex_cntx.view_layer_width) &&
        (g_ivex_cntx.image_info.original_height < g_ivex_cntx.view_layer_height))
    {
        g_ivex_cntx.image_info.min_zoom_factor = 1;;
    }
    else
    {
        tmp_width = (float)g_ivex_cntx.image_info.original_width / g_ivex_cntx.view_layer_width;
        tmp_height = (float)g_ivex_cntx.image_info.original_height / g_ivex_cntx.view_layer_height;

        if (tmp_width >= tmp_height)
        {
            g_ivex_cntx.image_info.min_zoom_factor = 1 / tmp_width;
        }
        else
        {
            g_ivex_cntx.image_info.min_zoom_factor = 1 / tmp_height;
        }
    }
    /* calculate the first draw para after rotated */
    g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_width)>>1;
    g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_height)>>1;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_adjust_image_dimension_after_rotate_to_full
 * DESCRIPTION
 *  This function adjust the image dimension when rotate is over.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_adjust_image_dimension_after_rotate_to_full(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* this case is the same as entry first */

    /* mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, img_info);
     * mark this line to comments cause base info are already been set when first view the image */
    mmi_ivex_init_image_display_info(img_info, MMI_FALSE);
    img_info->zoom_cnt = 0;
    g_ivex_cntx.image_rotated = MMI_FALSE;
    g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_rotate_changed_image_info
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_get_rotate_changed_image_info_to_full(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    float step;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_view_avaliable_and_process())
    {
        /* if can not continue view, will exit */
        return MMI_FALSE;
    }

    step = (float)(1.2 * 1.2 * 1.2 * 1.2);
    /* this case is the same as entry first */
    mmi_ivex_get_image_base_info(g_imgview_fl_idx, MMI_TRUE, &g_ivex_cntx.image_info);
    mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);
    g_ivex_cntx.image_info.resized_width = (S32)((float)g_ivex_cntx.image_info.resized_width / step + MMI_IVEX_ROUND_ADD_VALUE);
    g_ivex_cntx.image_info.resized_height = (S32)((float)g_ivex_cntx.image_info.resized_height / step + MMI_IVEX_ROUND_ADD_VALUE);
    g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.curr_zoom_factor / step;

    if (g_ivex_cntx.image_info.resized_width < 1)
    {
        g_ivex_cntx.image_info.resized_width = 1;
    }

    if (g_ivex_cntx.image_info.resized_height < 1)
    {
        g_ivex_cntx.image_info.resized_height = 1;
    }
    g_ivex_cntx.image_info.resized_offset_x = (S32)((float)g_ivex_cntx.image_info.resized_offset_x / step);
    g_ivex_cntx.image_info.resized_offset_y = (S32)((float)g_ivex_cntx.image_info.resized_offset_y / step);

    if (g_ivex_cntx.image_info.resized_offset_x < 0)
    {
        g_ivex_cntx.image_info.resized_offset_x = 0;
    }

    if (g_ivex_cntx.image_info.resized_offset_y < 0)
    {
        g_ivex_cntx.image_info.resized_offset_y = 0;
    }
    /* calculate the first draw para after rotated */
    g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_width)>>1;
    g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_height)>>1;

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_rotate_increase_image_to_full
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_rotate_increase_image_to_full(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 temp;
    MMI_BOOL is_ok = MMI_TRUE;
    MMI_BOOL view_ava = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.switch_frame_index == MMI_IVEX_IMAGE_ROTATE_EFFECT_CNT)
    {
        mmi_ivex_deal_view_layer_rotate_value();
        g_ivex_cntx.image_rotated = MMI_TRUE;
        mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
        gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);
        /* calculate image info at new orientation */
       is_ok = mmi_ivex_get_rotate_changed_image_info_to_full();
    }
    else
    {
        g_ivex_cntx.image_info.resized_width = (S32)((float)g_ivex_cntx.image_info.resized_width * 1.2 + MMI_IVEX_ROUND_ADD_VALUE);
        g_ivex_cntx.image_info.resized_height = (S32)((float)g_ivex_cntx.image_info.resized_height * 1.2 + MMI_IVEX_ROUND_ADD_VALUE);

        MMI_ASSERT(g_ivex_cntx.image_info.resized_width != 0);
        MMI_ASSERT(g_ivex_cntx.image_info.resized_height != 0);

        g_ivex_cntx.image_info.curr_zoom_factor *= 1.2f;
        if (g_ivex_cntx.image_info.curr_zoom_factor >= g_ivex_cntx.image_info.min_zoom_factor)
        {
            g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.min_zoom_factor;
        }
        MMI_ASSERT(g_ivex_cntx.image_info.curr_zoom_factor >= 0.0001);

        /* make sure little image can be draw full */
        if (g_ivex_cntx.image_info.resized_image_width < g_ivex_cntx.view_layer_width)
        {
            g_ivex_cntx.image_info.resized_width =
                (S32)(g_ivex_cntx.image_info.curr_zoom_factor *
                (float)g_ivex_cntx.image_info.original_width);
        }
        if (g_ivex_cntx.image_info.resized_image_height < g_ivex_cntx.view_layer_height)
        {
            g_ivex_cntx.image_info.resized_height =
                (S32)(g_ivex_cntx.image_info.curr_zoom_factor *
                (float)g_ivex_cntx.image_info.original_height);
        }

        /* first judge if the resized dimension is larger than original image */
        if ((g_ivex_cntx.image_info.resized_width > g_ivex_cntx.image_info.original_width) ||
            (g_ivex_cntx.image_info.resized_height > g_ivex_cntx.image_info.original_height))
        {
            g_ivex_cntx.image_info.resized_width = g_ivex_cntx.image_info.original_width;
            g_ivex_cntx.image_info.resized_height = g_ivex_cntx.image_info.original_height;
            g_ivex_cntx.image_info.resized_offset_x = 0;
            g_ivex_cntx.image_info.resized_offset_y = 0;
            g_ivex_cntx.image_info.curr_zoom_factor = 1;
        }

        /* calculate the draw offset according dimension */
        if (g_ivex_cntx.image_info.resized_width > g_ivex_cntx.view_layer_width)
        {
            temp = g_ivex_cntx.image_info.resized_width - g_ivex_cntx.view_layer_width;
            g_ivex_cntx.image_info.draw_offset_x = 0;
            g_ivex_cntx.image_info.resized_offset_x = (g_ivex_cntx.image_info.resized_offset_x * 2) + temp / 2;

            g_ivex_cntx.image_info.resized_width = g_ivex_cntx.view_layer_width;
        }
        else
        {
            g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_width)>>1;
            g_ivex_cntx.image_info.resized_offset_x = g_ivex_cntx.image_info.resized_offset_x * 2;
        }

        if (g_ivex_cntx.image_info.resized_height > g_ivex_cntx.view_layer_height)
        {
            temp = g_ivex_cntx.image_info.resized_height - g_ivex_cntx.view_layer_height;
            g_ivex_cntx.image_info.draw_offset_y = 0;
            g_ivex_cntx.image_info.resized_offset_y = (g_ivex_cntx.image_info.resized_offset_y * 2) + temp / 2;

            g_ivex_cntx.image_info.resized_height = g_ivex_cntx.view_layer_height;
        }
        else
        {
            g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_height)>>1;
            g_ivex_cntx.image_info.resized_offset_y = g_ivex_cntx.image_info.resized_offset_y * 2;
        }

        if (g_ivex_cntx.image_info.resized_width < 1)
        {
            g_ivex_cntx.image_info.resized_width = 1;
        }

        if (g_ivex_cntx.image_info.resized_height < 1)
        {
            g_ivex_cntx.image_info.resized_height = 1;
        }

        if (g_ivex_cntx.switch_frame_index == 0)
        {
            view_ava = mmi_ivex_check_view_avaliable_and_process();
            if (view_ava)
            {
                mmi_ivex_adjust_image_dimension_after_rotate_to_full(&g_ivex_cntx.image_info);
                if (g_ivex_cntx.image_info.is_animation && g_ivex_cntx.image_info.handle == 0)
                {
                    mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
                    g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
                }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                if (g_ivex_cntx.image_info.is_mav && g_ivex_cntx.image_info.handle == 0)
                {
                    mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
                    g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
                }
#endif
            }
            else
            {
                is_ok = MMI_FALSE;
            }
        }
    }

    if (is_ok)
    {
        if (g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK)
        {
            /* this case is for thoes errors that can not lead to exit, draw error at ui orientation */
            if (g_ivex_cntx.ui_rotating == MMI_TRUE)
            {
                /* ui rotating, at this time, has not changed orientation */
                g_ivex_cntx.view_image_rotate = (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)?GDI_LCD_LAYER_ROTATE_90 : GDI_LCD_LAYER_ROTATE_0;
            }
            else
            {
                g_ivex_cntx.view_image_rotate = g_ivex_cntx.ui_display_rotate;
            }
            mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
            mmi_ivex_stop_rotate();
            mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
            mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
            mmi_ivex_layer_nb_concurrentcy_blt();
        }
        else
        {
            mmi_ivex_get_curr_img(IVEX_IMG_QTY_DEFAULT);/* LRZ too slow, this avoid block*/
            gdi_layer_blt_previous_nb_concurrent(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
            if (g_ivex_cntx.switch_frame_index == 0)
            {
                mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            }

            if (g_ivex_cntx.switch_frame_index != 0)
            {
                gui_start_timer(MMI_IVEX_DRAW_ROTATE_EFFECT_DURATION, mmi_ivex_prepare_rotate_increase_image_to_full);
                g_ivex_cntx.switch_frame_index--;
            }
            else
            {
                mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                mmi_ivex_draw_osd_sliding_bar_layer();
#endif
                MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_INC_IMG_FULL);
                mmi_ivex_stop_rotate();
                /* check current motion state and adjust the UI to align Motion */
                mmi_ivex_adjust_to_align_motion();
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_rotate_increase_image
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_rotate_increase_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.switch_frame_index == MMI_IVEX_IMAGE_ROTATE_EFFECT_CNT)
    {
        mmi_ivex_deal_view_layer_rotate_value();
        g_ivex_cntx.image_rotated = MMI_TRUE;
        mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
        gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);
        /* calculate image info at new orientation */
       mmi_ivex_get_rotate_changed_image_info();
    }
    else
    {
        g_ivex_cntx.image_info.resized_width = g_ivex_cntx.image_info.resized_width<<1;
        g_ivex_cntx.image_info.resized_height = g_ivex_cntx.image_info.resized_height<<1;

        MMI_ASSERT(g_ivex_cntx.image_info.resized_width != 0);
        MMI_ASSERT(g_ivex_cntx.image_info.resized_height != 0);

        g_ivex_cntx.image_info.curr_zoom_factor *= 2;
        if (!g_ivex_cntx.image_info.is_animation)
        {
            /* use x2 use here. [x2. twice] */
            if (g_ivex_cntx.image_info.curr_zoom_factor >= 2)
            {
                g_ivex_cntx.image_info.curr_zoom_factor = 2;
            }
        }
        MMI_ASSERT(g_ivex_cntx.image_info.curr_zoom_factor >= 0.0001);

        /* make sure little image can be draw full */
        if (g_ivex_cntx.image_info.resized_image_width < g_ivex_cntx.view_layer_width)
        {
            g_ivex_cntx.image_info.resized_width =
                (S32)(g_ivex_cntx.image_info.curr_zoom_factor *
                (float)g_ivex_cntx.image_info.original_width);
        }
        if (g_ivex_cntx.image_info.resized_image_height < g_ivex_cntx.view_layer_height)
        {
            g_ivex_cntx.image_info.resized_height =
                (S32)(g_ivex_cntx.image_info.curr_zoom_factor *
                (float)g_ivex_cntx.image_info.original_height);
        }

        /* first judge if the resized dimension is larger than original image */
        if (!g_ivex_cntx.image_info.is_animation)
        {
            /* use x2 use here. [x2. twice] */
            if ((g_ivex_cntx.image_info.resized_width > (g_ivex_cntx.image_info.original_width * 2)) ||
                (g_ivex_cntx.image_info.resized_height > (g_ivex_cntx.image_info.original_height * 2)))
            {
                g_ivex_cntx.image_info.resized_width = g_ivex_cntx.image_info.original_width * 2;
                g_ivex_cntx.image_info.resized_height = g_ivex_cntx.image_info.original_height * 2;
                g_ivex_cntx.image_info.curr_zoom_factor = 2;
            }
        }

        /* calculate the draw offset according dimension */
        if (g_ivex_cntx.image_info.resized_width > g_ivex_cntx.view_layer_width)
        {
            temp = g_ivex_cntx.image_info.resized_width - g_ivex_cntx.view_layer_width;
            g_ivex_cntx.image_info.draw_offset_x = 0;
            g_ivex_cntx.image_info.resized_offset_x = (g_ivex_cntx.image_info.resized_offset_x * 2) + temp / 2;

            g_ivex_cntx.image_info.resized_width = g_ivex_cntx.view_layer_width;
        }
        else
        {
            g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_width)>>1;
            g_ivex_cntx.image_info.resized_offset_x = g_ivex_cntx.image_info.resized_offset_x * 2;
        }

        if (g_ivex_cntx.image_info.resized_height > g_ivex_cntx.view_layer_height)
        {
            temp = g_ivex_cntx.image_info.resized_height - g_ivex_cntx.view_layer_height;
            g_ivex_cntx.image_info.draw_offset_y = 0;
            g_ivex_cntx.image_info.resized_offset_y = (g_ivex_cntx.image_info.resized_offset_y * 2) + temp / 2;

            g_ivex_cntx.image_info.resized_height = g_ivex_cntx.view_layer_height;
        }
        else
        {
            g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_height)>>1;
            g_ivex_cntx.image_info.resized_offset_y = g_ivex_cntx.image_info.resized_offset_y * 2;
        }

        if (g_ivex_cntx.image_info.resized_width < 1)
        {
            g_ivex_cntx.image_info.resized_width = 1;
        }

        if (g_ivex_cntx.image_info.resized_height < 1)
        {
            g_ivex_cntx.image_info.resized_height = 1;
        }

        if (g_ivex_cntx.switch_frame_index == 0)
        {
            mmi_ivex_adjust_image_dimension_after_rotate(&g_ivex_cntx.image_info);
            if (g_ivex_cntx.image_info.is_animation)
            {
                mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
            }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            if (g_ivex_cntx.image_info.is_mav)
            {
                mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
            }
#endif
        }
    }

    mmi_ivex_get_curr_img(IVEX_IMG_QTY_DEFAULT);
    if (g_ivex_cntx.switch_frame_index != 0)
    {
        gui_start_timer(MMI_IVEX_DRAW_ROTATE_EFFECT_DURATION, mmi_ivex_prepare_rotate_increase_image);
        g_ivex_cntx.switch_frame_index--;
    }
    else
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        mmi_ivex_set_zoomable_after_rotate();
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_INC_IMG);
        mmi_ivex_stop_renderer();
        /* check current motion state and adjust the UI to align Motion */
        mmi_ivex_adjust_to_align_motion();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_rotate_reduce_image
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_rotate_reduce_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.switch_frame_index++;
    MMI_ASSERT(g_ivex_cntx.switch_frame_index != 0);
    g_ivex_cntx.image_info.resized_width = g_ivex_cntx.image_info.resized_width>>1;
    g_ivex_cntx.image_info.resized_height = g_ivex_cntx.image_info.resized_height>>1;

    if (g_ivex_cntx.image_info.resized_width < 1)
    {
        g_ivex_cntx.image_info.resized_width = 1;
    }

    if (g_ivex_cntx.image_info.resized_height < 1)
    {
        g_ivex_cntx.image_info.resized_height = 1;
    }

    g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_width)>>1;
    g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_height)>>1;
    g_ivex_cntx.image_info.resized_offset_x >>= 1;
    g_ivex_cntx.image_info.resized_offset_y >>= 1;
    g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.curr_zoom_factor/2;
    MMI_ASSERT(g_ivex_cntx.image_info.curr_zoom_factor >= 0.0001);

    mmi_ivex_get_curr_img(IVEX_IMG_QTY_DEFAULT);

    if (g_ivex_cntx.switch_frame_index == MMI_IVEX_IMAGE_ROTATE_EFFECT_CNT)
    {
        gui_start_timer(MMI_IVEX_DRAW_ROTATE_EFFECT_DURATION, mmi_ivex_prepare_rotate_increase_image);
    }
    else
    {
        gui_start_timer(MMI_IVEX_DRAW_ROTATE_EFFECT_DURATION, mmi_ivex_prepare_rotate_reduce_image);
    }
    /* the icon should be up when key or pen up */
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prepare_rotate_reduce_image
 * DESCRIPTION
 *  This function prepare reduce image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prepare_rotate_reduce_image_to_half(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.switch_frame_index++;
    MMI_ASSERT(g_ivex_cntx.switch_frame_index != 0);
    g_ivex_cntx.image_info.resized_width = (S32)((float)g_ivex_cntx.image_info.resized_width / 1.20 + MMI_IVEX_ROUND_ADD_VALUE);
    g_ivex_cntx.image_info.resized_height = (S32)((float)g_ivex_cntx.image_info.resized_height / 1.20 + MMI_IVEX_ROUND_ADD_VALUE);

    if (g_ivex_cntx.image_info.resized_width < 1)
    {
        g_ivex_cntx.image_info.resized_width = 1;
    }

    if (g_ivex_cntx.image_info.resized_height < 1)
    {
        g_ivex_cntx.image_info.resized_height = 1;
    }

    g_ivex_cntx.image_info.draw_offset_x = (g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_width)>>1;
    g_ivex_cntx.image_info.draw_offset_y = (g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_height)>>1;
    g_ivex_cntx.image_info.resized_offset_x = (S32)((float)g_ivex_cntx.image_info.resized_offset_x / 1.20);
    g_ivex_cntx.image_info.resized_offset_y = (S32)((float)g_ivex_cntx.image_info.resized_offset_y / 1.20);

    if (g_ivex_cntx.image_info.resized_offset_x < 0)
    {
        g_ivex_cntx.image_info.resized_offset_x = 0;
    }

    if (g_ivex_cntx.image_info.resized_offset_y < 0)
    {
        g_ivex_cntx.image_info.resized_offset_y = 0;
    }

    g_ivex_cntx.image_info.curr_zoom_factor = g_ivex_cntx.image_info.curr_zoom_factor /1.20f;
    MMI_ASSERT(g_ivex_cntx.image_info.curr_zoom_factor >= 0.0001);

    mmi_ivex_get_curr_img(IVEX_IMG_QTY_DEFAULT);

    if (g_ivex_cntx.switch_frame_index == MMI_IVEX_IMAGE_ROTATE_EFFECT_CNT)
    {
        gui_start_timer(MMI_IVEX_DRAW_ROTATE_EFFECT_DURATION, mmi_ivex_prepare_rotate_increase_image_to_full);
    }
    else
    {
        gui_start_timer(MMI_IVEX_DRAW_ROTATE_EFFECT_DURATION, mmi_ivex_prepare_rotate_reduce_image_to_half);
    }
    /* the icon should be up when key or pen up */
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_rotate
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __IVEX_SUPPORT_IES__

void mmi_ivex_start_rotate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_START_ROTATE);
    mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif

    //change layer
    mmi_ivex_deal_view_layer_rotate_value();
    g_ivex_cntx.image_rotated = MMI_TRUE;
    mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);

    if (mmi_ivex_check_view_avaliable_and_process())
    {
        mmi_ivex_adjust_image_dimension_after_rotate_to_full(&g_ivex_cntx.image_info);
        if (g_ivex_cntx.image_info.is_animation && g_ivex_cntx.image_info.handle == NULL)
        {
            mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (g_ivex_cntx.image_info.is_mav && g_ivex_cntx.image_info.handle == NULL)
        {
            mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
        }
#endif

        if (g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK)
        {
            /* this case is for thoes errors that can not lead to exit, draw error at ui orientation */
            if (g_ivex_cntx.ui_rotating == MMI_TRUE)
            {
                /* ui rotating, at this time, has not changed orientation */
                g_ivex_cntx.view_image_rotate = (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)?GDI_LCD_LAYER_ROTATE_90 : GDI_LCD_LAYER_ROTATE_0;
            }
            else
            {
                g_ivex_cntx.view_image_rotate = g_ivex_cntx.ui_display_rotate;
            }
            mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
            mmi_ivex_stop_rotate();
            mmi_ivex_disable_image_zoomable(&g_ivex_cntx.image_info);
            mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
        }
        else
        {
            //reset image data
            if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
            {
                g_ivex_cntx.image_info.CAPS_flag = MMI_IVEX_caps_rotation;
                g_ivex_cntx.image_info.CAPS_rotation_step = g_ivex_cntx.view_image_rotate;
            }

            mmi_ivex_get_curr_img(IVEX_IMG_QTY_DEFAULT);/* LRZ too slow, this avoid block*/
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
            mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_INC_IMG_FULL);
            mmi_ivex_stop_rotate();
            /* check current motion state and adjust the UI to align Motion */
            mmi_ivex_adjust_to_align_motion();
        }

        
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }

    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
    g_ivex_cntx.switch_frame_index = 0;
}

#else /*__IVEX_SUPPORT_IES__*/

void mmi_ivex_start_rotate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_START_ROTATE);
    mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
    mmi_ivex_start_renderer();
    GDI_LOCK;
    mmi_ivex_prepare_rotate_reduce_image_to_half();
}

#endif /*__IVEX_SUPPORT_IES__*/


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_rotate
 * DESCRIPTION
 *  this function is for interrupt under rotate state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 
#ifdef __IVEX_SUPPORT_IES__

void mmi_ivex_stop_rotate(void)
{
}

#else //__IVEX_SUPPORT_IES__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_restore_image_info_for_interrupt_rotate
 * DESCRIPTION
 *  This function prepare layer and switch image info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_restore_image_info_for_interrupt_rotate_to_full(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_ivex_cntx.image_rotated)
    {
        img_info->resized_offset_x = g_ivex_cntx.roxbr;
        img_info->resized_offset_y = g_ivex_cntx.roybr;
        img_info->resized_width = g_ivex_cntx.drwbr;
        img_info->resized_height = g_ivex_cntx.drhbr;
        img_info->draw_offset_x = g_ivex_cntx.doxbr;
        img_info->draw_offset_y = g_ivex_cntx.doybr;
        img_info->curr_zoom_factor = g_ivex_cntx.czfbr;
        img_info->zoom_cnt = g_ivex_cntx.zcbr;
        img_info->min_zoom_factor = g_ivex_cntx.ozfbr;
        g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
    }
    else
    {
        mmi_ivex_adjust_image_dimension_after_rotate_to_full(img_info);
    }
    mmi_ivex_stop_anim_if_need(img_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(img_info, g_ivex_cntx.display_layer_handle);
#endif
}


void mmi_ivex_stop_rotate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_prepare_rotate_increase_image_to_full);
    gui_cancel_timer(mmi_ivex_prepare_rotate_reduce_image_to_half);

    if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL_P2H  ||
        g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL_H2P)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_ROTATE);
        mmi_ivex_stop_renderer();
        GDI_UNLOCK;
        if (g_ivex_cntx.switch_frame_index != 0 ||
            (g_ivex_cntx.switch_frame_index == 0 &&
            g_ivex_cntx.rot_oriention != MMI_IVEX_ROTATE_NONE))
        {
            if (!mmi_ivex_check_if_folder_changed(g_ivex_cntx.image_info.filepath))
            {
                mmi_ivex_restore_image_info_for_interrupt_rotate_to_full(&g_ivex_cntx.image_info);
            }
            else
            {
                /* for plug out and then in very quikly case  */
                g_ivex_cntx.is_card_out = MMI_TRUE;
            }
        }
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        g_ivex_cntx.switch_frame_index = 0;
    }
}

#endif //__IVEX_SUPPORT_IES__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_cw_press
 * DESCRIPTION
 *  This function handles rotate event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_shown_part_central_coordinate(S32 draw_offset_x,
                                                            S32 draw_offset_y,
                                                            S32 resized_offset_x,
                                                            S32 resized_offset_y,
                                                            S32 view_layer_width,
                                                            S32 view_layer_height,
                                                            S32* center_x,
                                                            S32* center_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (draw_offset_x == 0)
    {
        *center_x = resized_offset_x + (view_layer_width >> 1);
    }
    else
    {
        *center_x = (view_layer_width >> 1) - draw_offset_x;
    }

    if (draw_offset_y == 0)
    {
        *center_y = resized_offset_y + (view_layer_height >> 1);
    }
    else
    {
        *center_y = (view_layer_height >> 1) - draw_offset_y;
    }

    if (*center_x < 1)
    {
        *center_x = 1;
    }

    if (*center_y < 1)
    {
        *center_y = 1;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_pre_prepare
 * DESCRIPTION
 *  This function prepare for rotate.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_rotate_pre_prepare(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_ok = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!(g_ivex_cntx.image_info.is_loading || g_ivex_cntx.image_info.is_err))
    {
        mmi_ivex_get_shown_part_central_coordinate(
                                        g_ivex_cntx.image_info.draw_offset_x,
                                        g_ivex_cntx.image_info.draw_offset_y,
                                        g_ivex_cntx.image_info.resized_offset_x,
                                        g_ivex_cntx.image_info.resized_offset_y,
                                        g_ivex_cntx.view_layer_width,
                                        g_ivex_cntx.view_layer_height,
                                        &g_ivex_cntx.image_info.center_x,
                                        &g_ivex_cntx.image_info.center_y);

    }

    MMI_ASSERT(g_ivex_cntx.switch_frame_index == 0);
    g_ivex_cntx.switch_frame_index = 0;

    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0 ||
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL_P2H;
    }
    else
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL_H2P;
    }

    mmi_ivex_layer_set_blt_layer();

    if (g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK &&
        g_ivex_cntx.image_info.is_loading == MMI_FALSE)
    {
        g_ivex_cntx.image_rotated = MMI_FALSE;
        mmi_ivex_save_image_info_for_interrupt_rotate(&g_ivex_cntx.image_info);
        mmi_ivex_start_rotate();
    }
    else
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        if (!mmi_ivex_check_view_avaliable_and_process())
        {
            is_ok = MMI_FALSE;
        }
        else
        {
            mmi_ivex_deal_view_layer_rotate_value();
            mmi_ivex_deal_rotate_error_loading();
            g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_NONE;
        }
    }
    return is_ok;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_save_image_info_before_interrupt
 * DESCRIPTION
 *  This function prepare layer and switch image info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_save_image_info_for_interrupt_rotate(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.roxbr = img_info->resized_offset_x;
    g_ivex_cntx.roybr = img_info->resized_offset_y;
    g_ivex_cntx.drwbr = img_info->resized_width;
    g_ivex_cntx.drhbr = img_info->resized_height;
    g_ivex_cntx.czfbr = img_info->curr_zoom_factor;
    g_ivex_cntx.ozfbr = img_info->min_zoom_factor;
    g_ivex_cntx.zcbr = img_info->zoom_cnt;
    g_ivex_cntx.doxbr = img_info->draw_offset_x;
    g_ivex_cntx.doybr = img_info->draw_offset_y;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_is_valid
 * DESCRIPTION
 *  This function handles rotate event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_rotate_is_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.is_loading == MMI_TRUE ||
        g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK)
    {
        is_valid = MMI_FALSE;
    }
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_IMG_ROTATE] == MMI_FALSE)
    {
        is_valid = MMI_FALSE;
    }

    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_cw_press
 * DESCRIPTION
 *  This function handles rotate event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rotate_cw_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE))
    {
        return;
    }
    /* loading and error not allow to rotate */
    if (!mmi_ivex_rotate_is_valid())
    {
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->cwr.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_cw_release
 * DESCRIPTION
 *  This function handles rotate event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rotate_cw_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.active_osd_layout_ptr->cwr.is_press == MMI_FALSE)
    {
        return;
    }

    g_ivex_cntx.active_osd_layout_ptr->cwr.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

    g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_JUST_CW;
    mmi_ivex_rotate_pre_prepare();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_ccw_press
 * DESCRIPTION
 *  This function handles rotate event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rotate_ccw_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE))
    {
        return;
    }
    /* loading and error not allow to rotate */
    if (!mmi_ivex_rotate_is_valid())
    {
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->ccwr.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_ccw_release
 * DESCRIPTION
 *  This function handles rotate event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rotate_ccw_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.active_osd_layout_ptr->ccwr.is_press == MMI_FALSE)
    {
        return;
    }

    g_ivex_cntx.active_osd_layout_ptr->ccwr.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

    g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_JUST_CCW;
    mmi_ivex_rotate_pre_prepare();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_lsk_press
 * DESCRIPTION
 *  This function handles lsk event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_lsk_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_OPTION] == MMI_FALSE &&
        g_imgview_cui_ptr->lsk_setting.is_customized == MMI_FALSE)
    {
        return;
    }

    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE))
    {
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->lsk.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_lsk_release
 * DESCRIPTION
 *  This function handles lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_lsk_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_OPTION] == MMI_FALSE &&
        g_imgview_cui_ptr->lsk_setting.is_customized == MMI_FALSE)
    {
        return;
    }

    if (g_ivex_cntx.active_osd_layout_ptr->lsk.is_press == MMI_FALSE)
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->lsk.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->lsk_setting.is_customized)
    {
        if (!((g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK) &&
            (g_imgview_cui_ptr->lsk_setting.is_force_enable == MMI_FALSE)))
        {
            /* Send parent message and close cui */
            mmi_ivex_lsk_custmize_confirmed();
        }
    }
    else
    {
        mmi_ivex_view_entry_option_screen();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rsk_press
 * DESCRIPTION
 *  This function handles rsk event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rsk_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_TRUE))
    {
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->rsk.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rsk_release
 * DESCRIPTION
 *  This function handles rsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rsk_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_group_node_struct node_info;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.active_osd_layout_ptr->rsk.is_press == MMI_FALSE)
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->rsk.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    mmi_frm_group_get_info(g_ivex_cui_gid, &node_info);
    mmi_mediaview_close_view_cui(&g_ivex_cui_gid, EVT_ID_IMGVIEW_CLOSE_GID);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_update_layers_after_rotated
 * DESCRIPTION
 *  This function processes layers after rotated.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_update_layers_after_rotated(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.ui_display_rotate = (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)?GDI_LCD_LAYER_ROTATE_90 : GDI_LCD_LAYER_ROTATE_0;
    /* resize layers */
    mmi_ivex_view_layer_resizer(g_ivex_cntx.switch_layer_handle, MMI_TRUE);
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_title_layer);
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_panel_layer);
    /* set layer rotate value*/
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.switch_layer_handle, g_ivex_cntx.ui_display_rotate);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_title_layer, g_ivex_cntx.ui_display_rotate);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_panel_layer, g_ivex_cntx.ui_display_rotate);
    /* get active osd cntx */
    mmi_ivex_get_active_osd_cntx();

    mmi_ivex_draw_osd_title_layer();
    mmi_ivex_draw_osd_panel_layer();
    
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_osd_layer_resizer(g_ivex_cntx.osd_sliding_bar.panel_layer);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, g_ivex_cntx.ui_display_rotate);
    sliding_bar_set_active_layout(&g_ivex_cntx.osd_sliding_bar, g_ivex_cntx.ui_display_rotate);
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_ui_press
 * DESCRIPTION
 *  This function handles ui switch.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_ui_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_UI_ROTATE] == MMI_FALSE)
    {
        return;
    }

#if	((LCD_WIDTH == 320) && (LCD_HEIGHT == 240))

    if (MMI_IVEX_LANDSCAPE)
    {
        /* landscape not support rotate */
        return;
    }

#else

    if (mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE) == MMI_FALSE)
    {
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

#endif /*(LCD_WIDTH == 320) && (LCD_HEIGHT == 240)*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_ui_release
 * DESCRIPTION
 *  This function handles ui switch
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_ui_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_ok;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_UI_ROTATE] == MMI_FALSE)
    {
        return;
    }

#if (LCD_WIDTH == 320) && (LCD_HEIGHT == 240)
        /* landscape not support rotate */
        return;
#else /*(LCD_WIDTH == 320) && (LCD_HEIGHT == 240)*/

#if !defined(__MMI_IMGVIEWEX_MOTION__) || defined DEBUGE_IVEX_UI_ROTATE
    if (g_ivex_cntx.active_osd_layout_ptr->csk.is_press == MMI_FALSE)
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
#endif

    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE)
    {
        mmi_ivex_shortcut_zoom_stop_hdlr();
    }

    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_JUST_CW;
    }
    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        g_ivex_cntx.rot_oriention = MMI_IVEX_ROTATE_JUST_CCW;
    }

    /* if wrong image is deleted, will exit when can not prepare successfully */
    is_ok = mmi_ivex_rotate_pre_prepare();
    if (is_ok)
    {
        /* mainly for motion rotate ui */
        if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_HIDE)
        {
            g_ivex_cntx.ui_rotating = MMI_TRUE;
            mmi_ivex_enable_osd_fade(MMI_TRUE);
            mmi_ivex_stop_osd_fade_out();
            mmi_ivex_stop_osd_fade_in();
            mmi_ivex_start_osd_fade_out();
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        }
        else
        {
            mmi_ivex_update_layers_after_rotated();
        }
    }
#endif /*(LCD_WIDTH == 320) && (LCD_HEIGHT == 240)*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_adjust_to_align_motion
 * DESCRIPTION
 *  This function processes layers after rotated.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_adjust_to_align_motion(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (LCD_WIDTH == 320) && (LCD_HEIGHT == 240)        /* landscape not support rotate */
        return;
#else /*(LCD_WIDTH == 320) && (LCD_HEIGHT == 240)*/

    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL &&
        g_ivex_cntx.ui_rotating == MMI_FALSE)
    {
    #if defined(__MMI_IMGVIEWEX_MOTION__)
        if ((g_ivex_cntx.mot_ui_state == MMI_IVEX_MOTION_ORIENTATION_HORIZONTAL &&
            g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0) ||
            (g_ivex_cntx.mot_ui_state == MMI_IVEX_MOTION_ORIENTATION_VERTICAL &&
            g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90))
            {
                mmi_ivex_switch_ui_release();
                g_ivex_cntx.mot_ui_state = MMI_IVEX_MOTION_ORIENTATION_NONE;
            }
    #endif
    }

#endif /*(LCD_WIDTH == 320) && (LCD_HEIGHT == 240)*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_layer_reset_switch_layer_info
 * DESCRIPTION
 *  This function is called to set specified layer position.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_layer_reset_switch_layer_info(gdi_handle layer_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct positon;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* next image will be recount for redecode */
    g_ivex_cntx.redecode_time = 0;
    /* next layer should be reset according current OSD orientation */
    mmi_ivex_view_layer_resizer(layer_handler, MMI_TRUE);
    gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.switch_layer_handle, g_ivex_cntx.ui_display_rotate);
    positon.offset_y = 0;
    positon.offset_x = mmi_ivex_get_ext_ui_width();
    gdi_layer_clear_nb_concurrent(layer_handler, GDI_COLOR_BLACK);
    gdi_layer_set_position_nb_concurrent(layer_handler, positon.offset_x, positon.offset_y);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play_action
 * DESCRIPTION
 *  This function handles stop play action under switching image in play.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_play_action(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.is_play_stop = MMI_TRUE;
    /* let MMI can sleep */
    srv_backlight_turn_off();
    if (g_ivex_cntx.play_switch_done == MMI_TRUE)
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        gui_cancel_timer(mmi_ivex_play_slide_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play_press
 * DESCRIPTION
 *  This function handles lsk event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_play_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_SHOW)
    {
        return;
    }

    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play_release
 * DESCRIPTION
 *  This function handles lsk event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_play_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_stop_play_action();
    if (g_ivex_cntx.active_osd_layout_ptr->csk.is_press == MMI_FALSE)
    {
        return;
    }

    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_FALSE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_slide_cyclic
 * DESCRIPTION
 *  start timer to play next image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_slide_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
    gui_cancel_timer(mmi_ivex_play_slide_cyclic);
    if (g_ivex_cntx.image_info.is_animation && g_ivex_cntx.image_info.result >= MMI_IVEX_IMG_HEALTH_OK)
    {
        gui_start_timer(MMI_IVEX_PLAY_SWTICH_SKIP_DURATION ,mmi_ivex_play_slide_cyclic);
    }
    else
    {
        gui_start_timer(g_ivex_cntx.ivex_settings.interval_sec * MMI_IVEX_PLAY_SWTICH_DURATION ,mmi_ivex_play_slide_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_if_start_slide_cyclic
 * DESCRIPTION
 *  check if continue playing
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_if_start_slide_cyclic(ivex_image_state_enum img_state, ivex_image_info_struct *img_info, MMI_BOOL is_stop)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reset tge skip number */
    if (img_state != MMI_IVEX_IMAGE_STATE_PLAY ||
        img_info->is_loading == MMI_TRUE ||
        is_stop == MMI_TRUE ||
        ((img_info->is_animation == MMI_TRUE) &&
        (img_info->is_anim_done == MMI_FALSE) &&
        (img_info->result >= MMI_IVEX_IMG_HEALTH_OK)))
    {
        return MMI_FALSE;
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_play_slide_cyclic
 * DESCRIPTION
 *  This function will switch image as play
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_play_slide_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_backward = MMI_FALSE;;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reset tge skip number */
    if (g_ivex_cntx.play_skip_number != 0)
    {
        if (g_ivex_cntx.play_skip_number < 0)
        {
            is_backward = MMI_TRUE;
        }
        /* start play or not skip, does not run here, if is start, when key release will change the g_imgview_fl_idx, go throght here, will see it as has skip one, so lead to switch next twice */
        mmi_ivex_change_play_index();
        /* in this case, the ivsrv has no cache, so restart is faster */
        srv_mediacache_goto_index(g_ivex_cntx.srv_mediacache_handle, g_imgview_fl_idx);
        g_ivex_cntx.play_skip_number = 0;
    }
#ifdef __MMI_IMGVIEWEX_MOTION__
    if (!MMI_IVEX_LANDSCAPE)
    {
        /* landscape not support rotate */
        if ((g_ivex_cntx.mot_ui_state == MMI_IVEX_MOTION_ORIENTATION_HORIZONTAL &&
            g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0) ||
            (g_ivex_cntx.mot_ui_state == MMI_IVEX_MOTION_ORIENTATION_VERTICAL &&
            g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90))
        {
            mmi_ivex_update_layers_after_rotated();
        }
    }
#endif
    /* if current animation is decoding, need to stop it */
    mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
    mmi_ivex_layer_set_blt_layer();

    /* should set switch_frame_precent as 0 when play to switch next img */
    g_ivex_cntx.switch_frame_precent = 0;
    if (g_ivex_cntx.play_switch_done)
    {
        if (is_backward)
        {
            if (!mmi_ivex_prepare_previous_image())
            {
                return;
            }
        }
        else
        {
            if (!mmi_ivex_prepare_next_image())
            {
                return;
            }
        }
        g_ivex_cntx.play_switch_done = MMI_FALSE;
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SLIDE_CYC);
    if (is_backward)
    {
        mmi_ivex_switch_previous_cyclic();
    }
    else
    {
        mmi_ivex_switch_next_cyclic();
    }
    
    //mmi_ivex_start_renderer();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_play
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_play(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);                     /* stop MMI sleep */
    mmi_ivex_stop_osd_fade_out();
    mmi_ivex_stop_osd_fade_in();
    mmi_ivex_start_osd_fade_out();
    if (mmi_ivex_if_start_slide_cyclic(g_ivex_cntx.image_state, &g_ivex_cntx.image_info, g_ivex_cntx.is_play_stop))
    {
        mmi_ivex_start_slide_cyclic();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play
 * DESCRIPTION
 *  this function is for interrupt under play state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_play(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_switch_next_cyclic);
    gui_cancel_timer(mmi_ivex_play_slide_cyclic);
    g_ivex_cntx.is_play_stop = MMI_TRUE;

    if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        /* let MMI can sleep */
        srv_backlight_turn_off();
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        if (!g_ivex_cntx.play_switch_done)
        {
            /* stop blt under switch to next in play */
            MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_STOP_PLAY);
            //mmi_ivex_stop_renderer();
            mmi_ivex_save_image_info_for_interrupt_switch(&g_ivex_cntx.switch_frame_precent);
        }
        else
        {
            /* make sure that keep the skip index can restore */
            g_ivex_cntx.play_skip_number = 0;
            g_imgview_fl_idx = g_ivex_cntx.image_info.filelist_index;
            cui_folder_browser_set_highlight_index(mmi_mediaview_get_browse_gid(), g_imgview_fl_idx);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play
 * DESCRIPTION
 *  this function is for interrupt under rotate state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_change_play_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = 0;
    U16 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.play_skip_number != 0)
    {
        if (g_ivex_cntx.play_skip_number > 0)
        {
            index = g_ivex_cntx.play_skip_number + g_imgview_fl_idx - 1;
        }
        else
        {
            index = g_ivex_cntx.play_skip_number + g_imgview_fl_idx + 1;
        }

        for (i = 0; index >= g_ivex_cntx.total_image_count; i++)
        {
            index -= g_ivex_cntx.total_image_count;
        }

        for (i = 0; index < 0; i++)
        {
            index += g_ivex_cntx.total_image_count;
        }
        g_imgview_fl_idx = index;
        /* has change the index, so need to reset the skip num to 0 for a new skip count */
        g_ivex_cntx.play_skip_number = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play
 * DESCRIPTION
 *  this function is for interrupt under rotate state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_replay_form_new_index(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PLAY_NEW,g_imgview_fl_idx);
    if (g_ivex_cntx.play_switch_done &&
        !g_ivex_cntx.is_play_stop &&
        g_ivex_cntx.play_skip_number !=0)
    {
        /* for quickly play */
        gui_cancel_timer(mmi_ivex_play_slide_cyclic);
        gui_start_timer(MMI_IVEX_PLAY_SWTICH_SKIP_DURATION ,mmi_ivex_play_slide_cyclic);
        return;
    }

    if (g_ivex_cntx.is_play_stop)
    {
        g_ivex_cntx.play_skip_number = 0;
        return;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play
 * DESCRIPTION
 *  this function is for interrupt under rotate state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_play_implete_skip(U16 Keycode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_skip = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        if (Keycode == KEY_LEFT_ARROW)
        {
            g_ivex_cntx.play_skip_number--;
        }
        else if (Keycode == KEY_RIGHT_ARROW)
        {
            g_ivex_cntx.play_skip_number++;
        }
        else
        {
            is_skip = MMI_FALSE;
        }
    }
    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        if (Keycode == KEY_UP_ARROW)
        {
            g_ivex_cntx.play_skip_number--;
        }
        else if (Keycode == KEY_DOWN_ARROW)
        {
            g_ivex_cntx.play_skip_number++;
        }
        else
        {
            is_skip = MMI_FALSE;
        }
    }
    if (is_skip && g_ivex_cntx.play_skip_number != 0)
    {
        gui_cancel_timer(mmi_ivex_play_slide_cyclic);
    }
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PLAY_SKIP_NO,g_ivex_cntx.play_skip_number);
    return is_skip;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_play
 * DESCRIPTION
 *  this function is for interrupt under rotate state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_sleep_play(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.play_switch_done = MMI_TRUE;
    gui_cancel_timer(mmi_ivex_switch_next_cyclic);
    if (g_ivex_cntx.is_play_stop)
    {
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    }
    else
    {
        if (mmi_ivex_if_start_slide_cyclic(g_ivex_cntx.image_state, &g_ivex_cntx.image_info, g_ivex_cntx.is_play_stop))
        {
            mmi_ivex_start_slide_cyclic();
        }
    }
    /* stop blt in play interval */
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_PLAY_SLEEP);
    //mmi_ivex_stop_renderer();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_play_press
 * DESCRIPTION
 *  This function handles lsk event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_play_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE) ||
        g_ivex_cntx.total_image_count == 1 ||
        g_ivex_cntx.view_from_fmgr == MMI_TRUE)
    {
        return;
    }

#ifdef __MMI_TOUCH_SCREEN__
    if(MMI_TRUE == g_ivex_cntx.is_pen_down)
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
#endif /* __MMI_TOUCH_SCREEN__ */

    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_TRUE;
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_play_release
 * DESCRIPTION
 *  This function handles center key event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_play_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct display_layer;
    ivex_osd_layer_struct switch_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.active_osd_layout_ptr->csk.is_press == MMI_FALSE)
    {
        return;
    }
    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_FALSE;
    mmi_ivex_layer_reset_switch_layer_info(g_ivex_cntx.switch_layer_handle);
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();

    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_PLAY;
    /* Should change as stop icon */
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    display_layer.offset_x = 0;
    display_layer.offset_y = 0;
    /* switch layer is not rotated as display. switch layer should have the same rotate angle with ui */
    switch_layer.offset_x = mmi_ivex_get_ext_ui_width();
    switch_layer.offset_y = 0;
    mmi_ivex_layer_set_position(g_ivex_cntx.display_layer_handle, &display_layer);
    mmi_ivex_layer_set_position(g_ivex_cntx.switch_layer_handle, &switch_layer);

    g_ivex_cntx.play_switch_done = MMI_TRUE;
    g_ivex_cntx.is_play_stop = MMI_FALSE;
    mmi_ivex_start_play();
}


#ifdef __IVEX_SUPPORT_IES__
void mmi_ivex_move_caps(mmi_pen_point_struct pos)
{
    g_ivex_cntx.image_info.CAPS_move_x=pos.x*(-1);
    g_ivex_cntx.image_info.CAPS_move_y=pos.y*(-1);
    g_ivex_cntx.image_info.CAPS_flag=MMI_IVEX_caps_move;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_SWI_LAYER_DONE,pos.x,pos.y);
}
#endif /* __SCALADO_SUPPORT */


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_is_key_move_valid
 * DESCRIPTION
 *  This function precheck if key move is valid.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_is_key_move_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_TRUE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_STILL ||
        g_ivex_cntx.image_info.is_loading)
    {
        is_valid = MMI_FALSE;
    }
    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_move_right_press
 * DESCRIPTION
 *  This function handles the right arrow key pressed event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_move_right_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct pos;
    S32 interval;
    S32 width_margin;
    S32 height_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_is_key_move_valid())
    {
        return;
    }
    pos.y = 0;
    if (g_ivex_cntx.key_first_move == MMI_TRUE)
    {
        g_ivex_cntx.key_first_move = MMI_FALSE;
        pos.x = -MMI_IVEX_KEY_MOVE_MIN_UNIT;
        interval = MMI_IVEX_KEY_MOVE_DURATION_1;
    }
    else
    {
        height_margin = g_ivex_cntx.image_info.resized_image_height - g_ivex_cntx.view_layer_height;
        width_margin = g_ivex_cntx.image_info.resized_image_width - g_ivex_cntx.view_layer_width;
        if (height_margin > width_margin)
        {
            pos.x = -abs(g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_image_height)  / 15;
        }
        else
        {
            pos.x = -abs(g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_image_width)  / 15;
        }

        if (pos.x > (-MMI_IVEX_KEY_MOVE_MIN_UNIT))
        {
            pos.x = -MMI_IVEX_KEY_MOVE_MIN_UNIT;
        }

        if (pos.x < (-MMI_IVEX_KEY_MOVE_MAX_UNIT))
        {
            pos.x = -MMI_IVEX_KEY_MOVE_MAX_UNIT;
        }

        interval = MMI_IVEX_KEY_MOVE_DURATION;
    }
    gui_start_timer(interval, mmi_ivex_move_right_press);
    mmi_ivex_update_enlarged_image_info(pos);
    mmi_ivex_get_moved_image(IVEX_IMG_QTY_DEFAULT);
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_move_up_press
 * DESCRIPTION
 *  This function handles the up arrow key pressed event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_move_up_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct pos;
    S32 interval;
    S32 width_margin;
    S32 height_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_is_key_move_valid())
    {
        return;
    }
    pos.x = 0;
    if (g_ivex_cntx.key_first_move == MMI_TRUE)
    {
        g_ivex_cntx.key_first_move = MMI_FALSE;
        pos.y = MMI_IVEX_KEY_MOVE_MIN_UNIT;
        interval = MMI_IVEX_KEY_MOVE_DURATION_1;
    }
    else
    {
        height_margin = g_ivex_cntx.image_info.resized_image_height - g_ivex_cntx.view_layer_height;
        width_margin = g_ivex_cntx.image_info.resized_image_width - g_ivex_cntx.view_layer_width;
        if (height_margin > width_margin)
        {
            pos.y = abs(g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_image_height)  / 15;
        }
        else
        {
            pos.y = abs(g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_image_width)  / 15;
        }

        if (pos.y < MMI_IVEX_KEY_MOVE_MIN_UNIT)
        {
            pos.y = MMI_IVEX_KEY_MOVE_MIN_UNIT;
        }

        if (pos.y > MMI_IVEX_KEY_MOVE_MAX_UNIT)
        {
            pos.y = MMI_IVEX_KEY_MOVE_MAX_UNIT;
        }
        interval = MMI_IVEX_KEY_MOVE_DURATION;
    }
    gui_start_timer(interval, mmi_ivex_move_up_press);
    mmi_ivex_update_enlarged_image_info(pos);
    mmi_ivex_get_moved_image(IVEX_IMG_QTY_DEFAULT);
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_move_down_press
 * DESCRIPTION
 *  This function handles the down key pressed event.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_move_down_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct pos;
    S32 interval;
    S32 width_margin;
    S32 height_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_is_key_move_valid())
    {
        return;
    }
    pos.x = 0;
    if (g_ivex_cntx.key_first_move == MMI_TRUE)
    {
        g_ivex_cntx.key_first_move = MMI_FALSE;
        pos.y = -MMI_IVEX_KEY_MOVE_MIN_UNIT;
        interval = MMI_IVEX_KEY_MOVE_DURATION_1;
    }
    else
    {
        height_margin = g_ivex_cntx.image_info.resized_image_height - g_ivex_cntx.view_layer_height;
        width_margin = g_ivex_cntx.image_info.resized_image_width - g_ivex_cntx.view_layer_width;
        if (height_margin > width_margin)
        {
            pos.y = -abs(g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_image_height)  / 15;
        }
        else
        {
            pos.y = -abs(g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_image_width)  / 15;
        }

        if (pos.y > (-MMI_IVEX_KEY_MOVE_MIN_UNIT))
        {
            pos.y = -MMI_IVEX_KEY_MOVE_MIN_UNIT;
        }

        if (pos.y < (-MMI_IVEX_KEY_MOVE_MAX_UNIT))
        {
            pos.y = -MMI_IVEX_KEY_MOVE_MAX_UNIT;
        }
        interval = MMI_IVEX_KEY_MOVE_DURATION;
    }
    gui_start_timer(interval, mmi_ivex_move_down_press);
    mmi_ivex_update_enlarged_image_info(pos);
    mmi_ivex_get_moved_image(IVEX_IMG_QTY_DEFAULT);
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_move_left_press
 * DESCRIPTION
 *  This function handles the left key pressed event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_move_left_press(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct pos;
    S32 interval;
    S32 width_margin;
    S32 height_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!mmi_ivex_is_key_move_valid())
    {
        return;
    }
    pos.y = 0;
    if (g_ivex_cntx.key_first_move == MMI_TRUE)
    {
        g_ivex_cntx.key_first_move = MMI_FALSE;
        pos.x = MMI_IVEX_KEY_MOVE_MIN_UNIT;
        interval = MMI_IVEX_KEY_MOVE_DURATION_1;
    }
    else
    {
        height_margin = g_ivex_cntx.image_info.resized_image_height - g_ivex_cntx.view_layer_height;
        width_margin  = g_ivex_cntx.image_info.resized_image_width - g_ivex_cntx.view_layer_width;
        if (height_margin > width_margin)
        {
            pos.x = abs(g_ivex_cntx.view_layer_height - g_ivex_cntx.image_info.resized_image_height)  / 15;
        }
        else
        {
            pos.x = abs(g_ivex_cntx.view_layer_width - g_ivex_cntx.image_info.resized_image_width)  / 15;
        }

        if (pos.x < MMI_IVEX_KEY_MOVE_MIN_UNIT)
        {
            pos.x = MMI_IVEX_KEY_MOVE_MIN_UNIT;
        }

        if (pos.x > MMI_IVEX_KEY_MOVE_MAX_UNIT)
        {
            pos.x = MMI_IVEX_KEY_MOVE_MAX_UNIT;
        }

        interval = MMI_IVEX_KEY_MOVE_DURATION;
    }
    gui_start_timer(interval, mmi_ivex_move_left_press);
    mmi_ivex_update_enlarged_image_info(pos);
    mmi_ivex_get_moved_image(IVEX_IMG_QTY_DEFAULT);
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_move
 * DESCRIPTION
 *  This function handles cancel move timer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_move(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_move_up_press);
    gui_cancel_timer(mmi_ivex_move_down_press);
    gui_cancel_timer(mmi_ivex_move_right_press);
    gui_cancel_timer(mmi_ivex_move_left_press);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_move_key_release
 * DESCRIPTION
 *  This function handles the up/right/left/down key release event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_move_key_release(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);/* LRZ get more clear */
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
    mmi_ivex_stop_move();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_left_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_left_arrow_key_down_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        if (mmi_ivex_reach_large_image_edge(g_ivex_cntx.ui_display_rotate,
                                    g_ivex_cntx.view_image_rotate,
                                    MMI_IVEX_ARROW_KEY_LEFT,
                                    &g_ivex_cntx.image_info))
        {
            mmi_ivex_switch_previous_image_for_key();
            return;
        }
        g_ivex_cntx.key_first_move = MMI_TRUE;
        mmi_ivex_move_left_press();
    }
    else
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            mmi_ivex_switch_previous_image_for_key();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_right_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_right_arrow_key_down_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        if (mmi_ivex_reach_large_image_edge(g_ivex_cntx.ui_display_rotate,
                                    g_ivex_cntx.view_image_rotate,
                                    MMI_IVEX_ARROW_KEY_RIGHT,
                                    &g_ivex_cntx.image_info))
        {
            mmi_ivex_switch_next_image_for_key();
            return;
        }
        g_ivex_cntx.key_first_move = MMI_TRUE;
        mmi_ivex_move_right_press();
    }
    else
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            mmi_ivex_switch_next_image_for_key();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_up_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_up_arrow_key_down_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        if (mmi_ivex_reach_large_image_edge(g_ivex_cntx.ui_display_rotate,
                                    g_ivex_cntx.view_image_rotate,
                                    MMI_IVEX_ARROW_KEY_UP,
                                    &g_ivex_cntx.image_info))
        {
            mmi_ivex_switch_previous_image_for_key();
            return;
        }
        g_ivex_cntx.key_first_move = MMI_TRUE;
        mmi_ivex_move_up_press();
    }
    else
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            mmi_ivex_switch_previous_image_for_key();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_down_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_down_arrow_key_down_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        if (mmi_ivex_reach_large_image_edge(g_ivex_cntx.ui_display_rotate,
                                    g_ivex_cntx.view_image_rotate,
                                    MMI_IVEX_ARROW_KEY_DOWN,
                                    &g_ivex_cntx.image_info))
        {
            mmi_ivex_switch_next_image_for_key();
            return;
        }
        g_ivex_cntx.key_first_move = MMI_TRUE;
        mmi_ivex_move_down_press();
    }
    else
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            mmi_ivex_switch_next_image_for_key();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_left_arrow_key_up_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_left_arrow_key_up_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        mmi_ivex_move_key_release();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_right_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_right_arrow_key_up_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        mmi_ivex_move_key_release();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_up_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_up_arrow_key_up_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        mmi_ivex_move_key_release();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_down_arrow_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_down_arrow_key_up_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        mmi_ivex_move_key_release();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_shortcut_zoom_start_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_shortcut_zoom_start_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.is_zoomout_able)
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOMOUT_TO_MIN;
        mmi_ivex_zoomout_press();
    }
    else if (g_ivex_cntx.image_info.is_zoomin_able)
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOMIN_TO_MAX;
        mmi_ivex_zoomin_press();
    }
    else
    {
        g_ivex_cntx.zoom_orientation = MMI_IVEX_ZOOM_NONE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_shortcut_zoom_start_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_shortcut_zoom_stop_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_stop_zoomout();
    mmi_ivex_stop_zoomin();
    mmi_ivex_draw_osd_panel_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_arrow_key
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_arrow_key(U16 Keycode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_arrow = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (Keycode)
    {
        case KEY_UP_ARROW:
        case KEY_DOWN_ARROW:
        case KEY_LEFT_ARROW:
        case KEY_RIGHT_ARROW:
            is_arrow = MMI_TRUE;
            break;
    }
    return is_arrow;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_key_down_hdlr(U16 Keycode)
{
#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.is_scalado_anim == MMI_TRUE 
        || g_ivex_cntx.ui_rotating == MMI_TRUE 
#ifdef __MMI_TOUCH_SCREEN__
        || g_ivex_cntx.is_auto_move == MMI_TRUE
#endif
        )
        return;
#endif //__IVEX_SUPPORT_IES__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.key_press = MMI_TRUE;
    mmi_ivex_enable_osd_fade(MMI_FALSE);
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        if (mmi_ivex_check_arrow_key(Keycode))
        {
            mmi_ivex_play_implete_skip(Keycode);
            return;
        }
        else
        {
            gui_cancel_timer(mmi_ivex_play_slide_cyclic);
        }
        mmi_ivex_stop_play_action();
        g_ivex_cntx.play_skip_number = 0;
        mmi_ivex_update_image_for_normal_interrupt();
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        return;
    }

    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE)
    {
        /* anykey down, will stop shortcut zoom action, or ui will be abnormal */
        mmi_ivex_shortcut_zoom_stop_hdlr();
        return;
    }

    switch (Keycode)
    {
        case KEY_LEFT_ARROW:
            mmi_ivex_left_arrow_key_down_hdlr();
            break;
        case KEY_RIGHT_ARROW:
            mmi_ivex_right_arrow_key_down_hdlr();
            break;
        case KEY_UP_ARROW:
            mmi_ivex_up_arrow_key_down_hdlr();
            break;
        case KEY_DOWN_ARROW:
            mmi_ivex_down_arrow_key_down_hdlr();
            break;
        case KEY_LSK:
            mmi_ivex_lsk_press();
            break;
        case KEY_RSK:
            mmi_ivex_rsk_press();
            break;
        case KEY_1:
            mmi_ivex_rotate_ccw_press();
            break;
        case KEY_3:
            mmi_ivex_rotate_cw_press();
            break;
        case KEY_4:
        case KEY_VOL_DOWN:
            if (g_ivex_cntx.image_info.is_zoomout_able)
            {
                mmi_ivex_zoomout_press();
            }
            break;
        case KEY_6:
        case KEY_VOL_UP:
            if (g_ivex_cntx.image_info.is_zoomin_able)
            {
                mmi_ivex_zoomin_press();
            }
            break;
        case KEY_5:
            mmi_ivex_shortcut_zoom_start_hdlr();
            break;
        case KEY_ENTER:
            if (MMI_IVEX_LANDSCAPE)
            {
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                {
                    mmi_ivex_stop_play_press();
                }
                else
                {
                    mmi_ivex_play_press();
                }
            }
            else
            {
            #ifdef __MMI_IMGVIEWEX_MOTION__
                #ifdef DEBUGE_IVEX_UI_ROTATE
                mmi_ivex_switch_ui_press();
                #else
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                {
                    mmi_ivex_stop_play_press();
                }
                else
                {
                    mmi_ivex_play_press();
                }
                #endif
            #else
                mmi_ivex_switch_ui_press();
            #endif
            }
            break;
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        case KEY_7:
            mmi_ivex_shortcut_mav_prev_frame_press();
            break;
        case KEY_9:
            mmi_ivex_shortcut_mav_next_frame_press();
            break;
#endif
        default:
            break;
    }
}


static void mmi_ivex_key_repeat_hdlr(U16 Keycode)
{
#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.is_scalado_anim == MMI_TRUE 
        || g_ivex_cntx.ui_rotating == MMI_TRUE 
#ifdef __MMI_TOUCH_SCREEN__
        || g_ivex_cntx.is_auto_move == MMI_TRUE
#endif
        )
        return;
#endif //__IVEX_SUPPORT_IES__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        return;
    }

    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE)
    {
        return;
    }

    switch (Keycode)
    {
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        case KEY_7:
            mmi_ivex_shortcut_mav_prev_frame_repeat();
            break;
        case KEY_9:
            mmi_ivex_shortcut_mav_next_frame_repeat();
            break;
#endif
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_key_down_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_key_up_hdlr(U16 Keycode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(g_ivex_cntx.key_press == MMI_FALSE)
        return;
    
    g_ivex_cntx.key_press = MMI_FALSE;
    g_ivex_cntx.switch_orientation = MMI_IVEX_SWITCH_NONE;
    mmi_ivex_enable_osd_fade(MMI_TRUE);
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        mmi_ivex_replay_form_new_index();
    }

    switch (Keycode)
    {
        case KEY_LEFT_ARROW:
            mmi_ivex_left_arrow_key_up_hdlr();
            break;
        case KEY_RIGHT_ARROW:
            mmi_ivex_right_arrow_key_up_hdlr();
            break;
        case KEY_UP_ARROW:
            mmi_ivex_up_arrow_key_up_hdlr();
            break;
        case KEY_DOWN_ARROW:
            mmi_ivex_down_arrow_key_up_hdlr();
            break;
        case KEY_LSK:
            mmi_ivex_lsk_release();
            break;
        case KEY_RSK:
            mmi_ivex_rsk_release();
            break;
        case KEY_1:
            mmi_ivex_rotate_ccw_release();
            break;
        case KEY_3:
            mmi_ivex_rotate_cw_release();
            break;
        case KEY_4:
        case KEY_VOL_DOWN:
            if (g_ivex_cntx.image_info.is_zoomout_able)
            {
                mmi_ivex_zoomout_release();
            }
            break;
        case KEY_6:
        case KEY_VOL_UP:
            if (g_ivex_cntx.image_info.is_zoomin_able)
            {
                mmi_ivex_zoomin_release();
            }
            break;
        case KEY_ENTER:
            if (MMI_IVEX_LANDSCAPE)
            {
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                {
                    mmi_ivex_stop_play_release();
                }
                else
                {
                    mmi_ivex_play_release();
                }
            }
            else
            {
            #ifdef __MMI_IMGVIEWEX_MOTION__
                #ifdef DEBUGE_IVEX_UI_ROTATE
                mmi_ivex_switch_ui_release();
                #else
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                {
                    mmi_ivex_stop_play_release();
                }
                else
                {
                    mmi_ivex_play_release();
                }
                #endif
            #else
                mmi_ivex_switch_ui_release();
            #endif
            }
            break;
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        case KEY_7:
            mmi_ivex_shortcut_mav_prev_frame_release();
            break;
        case KEY_9:
            mmi_ivex_shortcut_mav_next_frame_release();
            break;
#endif
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_key_handler
 * DESCRIPTION
 *  init key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_dummy_fun(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}

#if defined(__MMI_IMGVIEWEX_MOTION__)
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_motion_is_valid
 * DESCRIPTION
 *  the callback of tilt detection
 * PARAMETERS
 *  param       shake direction
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_motion_is_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* this mainly avoid the case: screen dimension 320*480, one line is 380*2, when view it at horizontal screen,
    it is not allow to zoomin, so the zoomin icon (fuchtion) is invalid, user press the key6 or touch zoomin icon, rotate
    phone to trigger motion, so the image rotate, but at vertical screen, the zoomin icon (function) is valid, now, it is
    difficult to deside if to zoomin or not response zoomin*/
    if (mmi_frm_scrn_is_present(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, MMI_FRM_NODE_EXCLUDE_ACTIVE_SCRN_FLAG) ||
        g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_STILL ||
    #ifdef __MMI_TOUCH_SCREEN__
        g_ivex_cntx.is_pen_down == MMI_TRUE ||
    #endif
        g_ivex_cntx.key_press == MMI_TRUE)
    {
        is_valid = MMI_FALSE;
    }
    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_rotate_image_tilt_callback
 * DESCRIPTION
 *  the callback of tilt detection
 * PARAMETERS
 *  param       shake direction
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_rotate_image_tilt_callback(
        srv_sensor_type_enum sensor_type,
        void *sensor_data,
        void *user_data  )
/*
(mdi_motion_angle_enum direct,
    mdi_motion_action_enum action,
     mdi_motion_tilt_detail_struct *detail,
    void *user_data)*/

{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    srv_sensor_motion_direct_enum direct;
    srv_sensor_motion_direct_struct *p_direct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* if the image screen is covered by other screen, such as popup, call etc. should not response*/

	//modif for sensor split


    p_direct = (srv_sensor_motion_direct_struct *)sensor_data;
    direct = p_direct->direct;




    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_TILT_CB,
        direct,g_ivex_cntx.ui_display_rotate);
    //modify for sensor split
    if (direct == SRV_SENSOR_MOTION_ANGLE_GX180)
    {
        g_ivex_cntx.mot_ui_state = MMI_IVEX_MOTION_ORIENTATION_HORIZONTAL;
    }
    else if(direct == SRV_SENSOR_MOTION_ANGLE_GY180)
    {
        g_ivex_cntx.mot_ui_state = MMI_IVEX_MOTION_ORIENTATION_VERTICAL;
    }
    else
    {
        return;
    }

    if (!mmi_ivex_motion_is_valid())
    {
        return;
    }

    if (direct == SRV_SENSOR_MOTION_ANGLE_GX180)
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            mmi_ivex_switch_ui_release();
        }
    }
    else if (direct == SRV_SENSOR_MOTION_ANGLE_GY180)
    {
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            mmi_ivex_switch_ui_release();
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_listen_motion
 * DESCRIPTION
 *  Start motion.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_listen_motion(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_sensor_motion_direct_cfg_struct sensitive;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sensitive.angle_threshold = 30;

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_LISTEN_MOTION);
    g_ivex_cntx.is_register_mcb = MMI_TRUE;
    if (!g_ivex_cntx.is_resume)
    {
        g_ivex_cntx.mot_ui_state = MMI_IVEX_MOTION_ORIENTATION_NONE;
    }
    //modify for sensor split
   // g_ivex_cntx.motion_handle = mdi_motion_start_listen_tilt(MDI_MOTION_SENSITIVE_NORMAL, MDI_MOTION_TILT_EVENT_AXIS, mmi_ivex_rotate_image_tilt_callback, NULL);
   g_ivex_cntx.motion_handle = srv_sensor_start_listen(SRV_SENSOR_MOTION_DIRECT,
                            &sensitive, mmi_ivex_rotate_image_tilt_callback,NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_listen_motion
 * DESCRIPTION
 *  Start motion.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_listen_motion(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_LISTEN_STOP,g_ivex_cntx.is_register_mcb);
    if (g_ivex_cntx.is_register_mcb && (g_ivex_cntx.motion_handle >= 0))
    {
        srv_sensor_stop_listen(g_ivex_cntx.motion_handle);
    }
    g_ivex_cntx.is_register_mcb = MMI_FALSE;
    g_ivex_cntx.mot_ui_state = MMI_IVEX_MOTION_ORIENTATION_NONE;
}
#endif


#if defined(__MMI_TOUCH_SCREEN__)

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__

void mmi_ivex_sliding_bar_pen_down(mmi_pen_point_struct *pos) {    
    if (!mmi_ivex_check_fun_on_panel_is_valid(MMI_FALSE))
    {
        return;
    }
    sliding_bar_pen_down_handler(&(g_ivex_cntx.osd_sliding_bar), pos);
    mmi_ivex_draw_osd_sliding_bar_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}

void mmi_ivex_sliding_bar_pen_move(mmi_pen_point_struct *pos) {    
    sliding_bar_pen_move_handler(&(g_ivex_cntx.osd_sliding_bar), pos);
    mmi_ivex_draw_osd_sliding_bar_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}

void mmi_ivex_sliding_bar_pen_up(mmi_pen_point_struct *pos) {    
    sliding_bar_pen_up_handler(&(g_ivex_cntx.osd_sliding_bar), pos);
    mmi_ivex_draw_osd_sliding_bar_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}

#endif /* __MULTIPLE_ANGLE_VIEW_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_non_move_axis_bounce_cyclic
 * DESCRIPTION
 *  bounce back.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_non_move_axis_bounce_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset_x, offset_y;
    U8 orient;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.total_image_count == 1 || g_ivex_cntx.view_from_fmgr)
    {
        offset_x = g_ivex_cntx.display_layer_last_offset_x / 2;
        offset_y = g_ivex_cntx.display_layer_last_offset_y / 2;
        g_ivex_cntx.display_layer_last_offset_x = offset_x;
        g_ivex_cntx.display_layer_last_offset_y = offset_y;
        gdi_layer_set_position_nb_concurrent(g_ivex_cntx.display_layer_handle, offset_x, offset_y);
        if (g_ivex_cntx.display_layer_last_offset_y != 0 || g_ivex_cntx.display_layer_last_offset_x != 0)
        {
            gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_non_move_axis_bounce_cyclic);
        }
    }
    else
    {
        orient = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
        switch (orient)
        {
            case MMI_IVEX_SWITCH_AXIS_X:
                offset_x = 0;
                offset_y = g_ivex_cntx.display_layer_last_offset_y / 2;
                g_ivex_cntx.display_layer_last_offset_y = offset_y;
                gdi_layer_set_position_nb_concurrent(g_ivex_cntx.display_layer_handle, offset_x, offset_y);
                if (g_ivex_cntx.display_layer_last_offset_y != 0)
                {
                    gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_non_move_axis_bounce_cyclic);
                }
                break;
            case MMI_IVEX_SWITCH_AXIS_Y:
                offset_y = 0;
                offset_x = g_ivex_cntx.display_layer_last_offset_x / 2;
                g_ivex_cntx.display_layer_last_offset_x = offset_x;
                gdi_layer_set_position_nb_concurrent(g_ivex_cntx.display_layer_handle, offset_x, offset_y);
                if (g_ivex_cntx.display_layer_last_offset_x != 0)
                {
                    gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_non_move_axis_bounce_cyclic);
                }
                break;
            default:
                break;
        }
    }
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_non_move_axis_stop_bounce
 * DESCRIPTION
 *  bounce back.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_non_move_axis_stop_bounce(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_non_move_axis_bounce_cyclic);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_non_move_axis_start_bounce
 * DESCRIPTION
 *  bounce back.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_non_move_axis_start_bounce(U8 orient)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (orient)
    {
        case MMI_IVEX_SWITCH_AXIS_X:
            if (g_ivex_cntx.display_layer_last_offset_y != 0)
            {
                gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_non_move_axis_bounce_cyclic);
            }
            break;
        case MMI_IVEX_SWITCH_AXIS_Y:
            if (g_ivex_cntx.display_layer_last_offset_x != 0)
            {
                gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_non_move_axis_bounce_cyclic);
            }
            break;
        case MMI_IVEX_SWITCH_AXIS_NONE:
            gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_non_move_axis_bounce_cyclic);
            break;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_auto_move_cyclic
 * DESCRIPTION
 *  bounce back.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_auto_move_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_point_struct pos;
    static S32 last_x  = -1, last_y = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TMP_TRACE2("[IVAPP] mmi_ivex_auto_move_cyclic: %d, %d", last_x, last_y);
    TMP_TRACE2("[IVAPP] mmi_ivex_auto_move_cyclic: %d, %d", 
            g_ivex_cntx.image_info.resized_offset_x,
            g_ivex_cntx.image_info.resized_offset_y);
    if (last_x != g_ivex_cntx.image_info.resized_offset_x 
            || last_y != g_ivex_cntx.image_info.resized_offset_y)
    {
        last_x = g_ivex_cntx.image_info.resized_offset_x;
        last_y = g_ivex_cntx.image_info.resized_offset_y;

        gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_auto_move_cyclic);
        pos.x = g_ivex_cntx.pen_move_x;
        pos.y = g_ivex_cntx.pen_move_y;
        mmi_ivex_update_enlarged_image_info(pos);
        if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW)
        {
            mmi_ivex_get_moved_image(IVEX_IMG_QTY_DEFAULT);
        }
        g_ivex_cntx.pen_move_x = (S32)((4.0 / 5.0) * g_ivex_cntx.pen_move_x);
        g_ivex_cntx.pen_move_y = (S32)((4.0 / 5.0) * g_ivex_cntx.pen_move_y);
    }
    else
    {
        last_x  = last_y = -1;
        if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW)
        {
            mmi_ivex_get_moved_image(IVEX_IMG_QTY_HIGH);
        }
        g_ivex_cntx.is_auto_move = MMI_FALSE;
    }
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_auto_move
 * DESCRIPTION
 *  bounce back.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_auto_move(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_auto_move_cyclic);
    g_ivex_cntx.is_auto_move = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_auto_move
 * DESCRIPTION
 *  bounce back.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_auto_move(S32 speed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 speed_x = speed >> 16;
    S32 speed_y = speed & 0xffff;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(speed_x > 5)
        speed_x = 5;
    if(speed_y > 5)
        speed_y = 5;
    g_ivex_cntx.is_auto_move = MMI_TRUE;
    /*Only for performance test*/
    g_ivex_cntx.pen_move_x *= speed_x;
    g_ivex_cntx.pen_move_y *= speed_y;
    gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_auto_move_cyclic);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_if_update_image_position
 * DESCRIPTION
 *  Check if need to update image position.
 * PARAMETERS
 *  distance : based screen axis (left-up is (0,0))
 *  movment : based screen axis (left-up is (0,0)), move from left to right is positive x, up to down is positive y
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_if_update_image_position(S32 distance, S32 movment)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 abs_move;
    S32 abs_dis;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    abs_move = abs(movment);
    abs_dis = abs(distance);
    if (distance == 0)
    {
        /* layer is not moved, need to reset resized_image_offset, this case need move image in layers */
        return MMI_TRUE;
    }
    else if (movment * distance > 0)
    {
        /* the same orientation moving, must reset resized_image_offset, this case indicades layer has moved out lcd and will continuously move,
        the aim of moving image in layers is to remember movement of pen so that to move layer, this movement will convert to actual pen movement */
        return MMI_TRUE;
    }
    else
    {
        if (abs_dis - abs_move >= 0)
        {
            /* not back to the lcd completed, not to reset resized_image_offset, this case means need move layer only yet, but should remember pen movement for move layer */
            if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
            {
                g_ivex_cntx.abs_move_offset_x = movment;
            }
            if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
            {
                g_ivex_cntx.abs_move_offset_y = movment;
            }
            return MMI_FALSE;
        }
        else
        {
            /* has back to the lcd completed and back more, need to reset resized_image_offset, this case means that need move layer first then move image in layer, maybe also move layer again */
            if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
            {
                g_ivex_cntx.abs_move_offset_x = -distance;
            }
            if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
            {
                g_ivex_cntx.abs_move_offset_y = -distance;
            }
            return MMI_TRUE;
        }
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_calculate_layer_position
 * DESCRIPTION
 *  calculate layer position after being moved.
 * PARAMETERS
 *  axis : based on view layer axis
 *  distance : layer offset, it is based on view layer axis
 *  positon_disp : [out] layer position, based on view layer axis
 *  positon_swit : [out] layer position, based on view layer axis
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_calculate_layer_position(U8 axis, S32 distance, ivex_osd_layer_struct *positon_disp, ivex_osd_layer_struct *positon_swit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ext_ui_width, temp;
    S16 sign = 1;
    S16 temp_sign = 1;
    S32 disp_offset = 0;
    U8 adjust_axis;
    S32 layer_offset;
    S32 abs_axis_dis;
    MMI_BOOL is_ok = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CALCULATE_LAYER_POS,distance);
    adjust_axis = axis;
    layer_offset = distance;
    ext_ui_width = mmi_ivex_get_ext_ui_width();
    /* judge if switch to the third image */
    temp = abs(layer_offset);
    if (temp >= ext_ui_width)
    {
        temp_sign = temp/layer_offset;
        mmi_ivex_reset_new_display_image_setting();
        g_ivex_cntx.display_layer_last_offset_x = (temp - ext_ui_width) * temp_sign;
        g_ivex_cntx.display_layer_last_offset_y = 0;
        layer_offset = g_ivex_cntx.display_layer_last_offset_x;

        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
        {
            srv_mediacache_switch_prev(g_ivex_cntx.srv_mediacache_handle);
        }
        else
        {
            srv_mediacache_switch_next(g_ivex_cntx.srv_mediacache_handle);
        }

        /* get image again, hope get more clear image */
        mmi_ivex_switch_layer_done();

        adjust_axis = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
        /* restore as sitll state */
        g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        abs_axis_dis = mmi_ivex_convert_view_layer_offset_to_abs_axis_distance(layer_offset);
        if (!mmi_ivex_get_image_and_set_state(0, abs_axis_dis))
        {
            is_ok = MMI_FALSE;
        }
    }

    switch (adjust_axis)
    {
        case MMI_IVEX_SWITCH_AXIS_X:
            positon_disp->offset_y = g_ivex_cntx.display_layer_last_offset_y;
            positon_swit->offset_y = 0;
            if (g_ivex_cntx.ui_display_rotate == g_ivex_cntx.view_image_rotate)
            {
                sign = 1;
            }
            else
            {
                sign = -1;
            }
            positon_disp->offset_x = layer_offset;
            disp_offset = positon_disp->offset_x;
            break;
        case MMI_IVEX_SWITCH_AXIS_Y:
            positon_disp->offset_x = g_ivex_cntx.display_layer_last_offset_x;
            positon_swit->offset_y = 0;
            switch (g_ivex_cntx.ui_display_rotate)
            {
                case GDI_LCD_LAYER_ROTATE_0:
                    switch (g_ivex_cntx.view_image_rotate)
                    {
                        case GDI_LCD_LAYER_ROTATE_90:
                            sign = -1;
                            break;
                        case GDI_LCD_LAYER_ROTATE_270:
                            sign = +1;
                            break;
                        default:
                            MMI_ASSERT(0);
                    }
                    break;
                case GDI_LCD_LAYER_ROTATE_90:
                    switch (g_ivex_cntx.view_image_rotate)
                    {
                        case GDI_LCD_LAYER_ROTATE_0:
                            sign = +1;
                            break;
                        case GDI_LCD_LAYER_ROTATE_180:
                            sign = -1;
                            break;
                        default:
                            MMI_ASSERT(0);
                    }
                    break;
                default:
                    MMI_ASSERT(0);
            }
            positon_disp->offset_y = layer_offset;
            disp_offset = positon_disp->offset_y;
            break;
        default:
            break;
    }

    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
    {
        positon_swit->offset_x = sign * disp_offset - ext_ui_width;
    }
    else if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
    {
        positon_swit->offset_x = sign * disp_offset + ext_ui_width;
    }
    else
    {
        /* drag back still */
        positon_swit->offset_x = 0;
    }

    return is_ok;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_image_and_set_state
 * DESCRIPTION
 *  set switch orientation.
 * PARAMETERS
 *  offset : based screen axis (left-up is (0,0)), this is the distance before pen move
 *  move_dis : based screen axis (left-up is (0,0)), move from left to right is positive x, up to down is positive y
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_get_image_and_set_state(S32 offset, S32 move_dis)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 muilt;
    MMI_BOOL is_ok = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (offset == 0 && move_dis != 0)
    {
        if (move_dis > 0)
        {
            if (!mmi_ivex_prepare_previous_image())
            {
                is_ok = MMI_FALSE;
            }
            g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_SWITCH_PREV;
        }
        else
        {
            if (!mmi_ivex_prepare_next_image())
            {
                is_ok = MMI_FALSE;
            }
            g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_SWITCH_NEXT;
        }
    }
    else
    {
        muilt = offset * (offset + move_dis);
        if (muilt > 0)
        {
            /* this case not do nothing, it includes :
            1. offset !=0 and move_dis=0, means move vertical but not horizental movement
            2. the layer offset and the the new layer offset after moved stay at the same orientation  */
        }
        else if (muilt < 0)
        {
            /* this case is move the opposite */
            mmi_ivex_restore_filelist_index();
            if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
            {
                if (!mmi_ivex_prepare_next_image())
                {
                    is_ok = MMI_FALSE;
                }
                g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_SWITCH_NEXT;
            }
            else
            {
                if (!mmi_ivex_prepare_previous_image())
                {
                    is_ok = MMI_FALSE;
                }
                g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_SWITCH_PREV;
            }
        }
        else if (muilt == 0)
        {
            /* 1. offset =0 and move_dis =0, the case happened at move enlarged image in layer to edge just
                 2. offset !=0 and offset + move_dis=0, this happened at drag back */
            mmi_ivex_restore_filelist_index();
            g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
        }
    }
    if(is_ok)
    {
        mmi_ivex_layer_set_blt_layer();
    }
    return is_ok;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_move_switch_image
 * DESCRIPTION
 *  pen move to switch image.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 *  move_x : based screen axis (left-up is (0,0)), the two movements are mainly for pen large iamge used
 *  move_y : based screen axis (left-up is (0,0)), move from left to right is positive x, up to down is positive y
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_move_switch_image(mmi_pen_point_struct pos, S32 move_x, S32 move_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 movement_x, movement_y, movement_dis;
    ivex_osd_layer_struct display_layer;
    ivex_osd_layer_struct switch_layer;
    U8 orient;
    S32 layer_offset;
    S32 abs_axis_dis;
    S32 layer_mvx;
    S32 layer_mvy;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    layer_mvx = move_x;
    layer_mvy = move_y;
    if (g_ivex_cntx.is_auto_move)
    {
        if (g_ivex_cntx.display_layer_last_offset_x != 0 || g_ivex_cntx.display_layer_last_offset_y != 0)
        {
            g_ivex_cntx.display_layer_last_offset_x = 0;
            g_ivex_cntx.display_layer_last_offset_y = 0;
            mmi_ivex_stop_auto_move();
        }

        if (move_x != 0 || move_y != 0)
        {
            layer_mvx = 0;
            layer_mvy = 0;
        }
    }

    if ((g_ivex_cntx.total_image_count == 1) || g_ivex_cntx.view_from_fmgr)
    {
        gdi_layer_set_position_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.display_layer_last_offset_x, g_ivex_cntx.display_layer_last_offset_y);
        return;
    }

    if (g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        /* this move distance has subtract the movement of image */
        movement_x = layer_mvx;
        movement_y = layer_mvy;
    }
    else
    {
        movement_x = pos.x - g_ivex_cntx.pen_down_x;
        movement_y = pos.y - g_ivex_cntx.pen_down_y;
    }

    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        movement_dis = movement_y;
    }
    else
    {
        movement_dis = movement_x;
    }
    orient = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);

    layer_offset = mmi_ivex_get_view_switch_distance(g_ivex_cntx.ui_display_rotate,
                                                                                        g_ivex_cntx.view_image_rotate,
                                                                                        g_ivex_cntx.display_layer_last_offset_x,
                                                                                        g_ivex_cntx.display_layer_last_offset_y,
                                                                                        MMI_FALSE);
    abs_axis_dis = mmi_ivex_convert_view_layer_offset_to_abs_axis_distance(layer_offset);

    switch (orient)
    {
        case MMI_IVEX_SWITCH_AXIS_X:
            if (!mmi_ivex_get_image_and_set_state(abs_axis_dis, movement_dis))
            {
                return;
            }
            MMI_ASSERT(abs(abs_axis_dis) == abs(g_ivex_cntx.display_layer_last_offset_x));
            mmi_ivex_get_changed_view_switch_distance(abs_axis_dis, movement_dis, &g_ivex_cntx.display_layer_last_offset_x);
            if (!mmi_ivex_calculate_layer_position(
                MMI_IVEX_SWITCH_AXIS_X,
                g_ivex_cntx.display_layer_last_offset_x,
                &display_layer,
                &switch_layer))
            {
                return;
            }
            break;
        case MMI_IVEX_SWITCH_AXIS_Y:
            if (!mmi_ivex_get_image_and_set_state(abs_axis_dis, movement_dis))
            {
                return;
            }
            MMI_ASSERT(abs(abs_axis_dis) == abs(g_ivex_cntx.display_layer_last_offset_y));
            mmi_ivex_get_changed_view_switch_distance(abs_axis_dis, movement_dis, &g_ivex_cntx.display_layer_last_offset_y);
            if(!mmi_ivex_calculate_layer_position(
                MMI_IVEX_SWITCH_AXIS_Y,
                g_ivex_cntx.display_layer_last_offset_y,
                &display_layer,
                &switch_layer))
            {
                return;
            }
            break;
        default:
            break;
    }

    mmi_ivex_layer_set_position(g_ivex_cntx.display_layer_handle, &display_layer);
    mmi_ivex_layer_set_position(g_ivex_cntx.switch_layer_handle, &switch_layer);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_touch_scr_hit_test
 * DESCRIPTION
 *  This function check if icon is pressed on touch screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_touch_scr_hit_test(S32 pos_x, S32 pos_y, ivex_osd_icon_struct  *touch_obj, ivex_osd_layer_struct  *layer_obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((pos_x >= (layer_obj->offset_x + touch_obj->offset_x)) &&
        (pos_x < (layer_obj->offset_x + touch_obj->offset_x + touch_obj->width)) &&
        (pos_y >= (layer_obj->offset_y + touch_obj->offset_y)) &&
        (pos_y < (layer_obj->offset_y + touch_obj->offset_y + touch_obj->height)))
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_convert_touch_coordinate
 * DESCRIPTION
 *  deal with the touch coordinate between 0 and 90 of ui oriention.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_convert_touch_coordinate(mmi_pen_point_struct *pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 tmp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        tmp = pos->x;
        pos->x = pos->y;
        pos->y = (LCD_WIDTH - 1) - tmp;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_large_image
 * DESCRIPTION
 *  draw complete large image.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_draw_large_image(mmi_pen_point_struct pos, ivex_img_quality_enum img_qty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_error = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_update_enlarged_image_info(pos);

    /* this is for switching image during moving large image, if next can not be found, will exit IVEX, so here should not get image again */
    if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW)
    {
        mmi_ivex_get_moved_image(img_qty);
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        is_error = MMI_FALSE;
    }

    return is_error;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_double_click_is_valid
 * DESCRIPTION
 *  pen down event handler.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_double_click_is_valid(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pos.y < g_ivex_osd_cntx_0.panel.offset_y || g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_HIDE)
    {
        is_valid = MMI_TRUE;
    }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (g_ivex_cntx.image_info.is_mav) {
        mmi_ivex_convert_touch_coordinate(&pos);
        mmi_ivex_sliding_bar_convert_touch_coordinate(&pos);

        if (sliding_bar_is_in_sliding_bar(&(g_ivex_cntx.osd_sliding_bar), pos.x, pos.y)) {
            is_valid = MMI_FALSE;
        }
    }
#endif        
    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_double_click_is_same_pos
 * DESCRIPTION
 *  pen down event handler.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_double_click_is_same_pos(S16 x, S16 y, mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((abs(x - pos.x) < MMI_IVEX_DOUBLE_CLICK_VALID_RADIUS) && (abs(y - pos.y) < MMI_IVEX_DOUBLE_CLICK_VALID_RADIUS))
    {
        is_valid = MMI_TRUE;
    }
    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_shortcut_pen_down_dectect
 * DESCRIPTION
 *  pen down event handler.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_shortcut_pen_down_dectect(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_shortcut_osd_hide_unhide_switch);
    if (mmi_ivex_check_double_click_is_valid(pos))
    {
        if (g_ivex_cntx.start_ticks_1 != 0 && g_ivex_cntx.is_pen_move == MMI_FALSE)
        {
            g_ivex_cntx.is_double_click = MMI_TRUE;
            /* the second pen down */
            is_valid = mmi_ivex_double_click_is_same_pos(g_ivex_cntx.double1_x, g_ivex_cntx.double1_y, pos);
            if (is_valid)
            {
                g_ivex_cntx.is_double_click = MMI_TRUE;
            }
            else
            {
                g_ivex_cntx.is_double_click = MMI_FALSE;
            }
        }
        else
        {
            /* The first pen down */
            is_valid = MMI_TRUE;
            g_ivex_cntx.double1_x = 0;
            g_ivex_cntx.double1_y = 0;
            g_ivex_cntx.is_double_click = MMI_FALSE;
        }

        if (g_ivex_cntx.start_ticks_1 == 0 && is_valid)
        {
            kal_get_time(&g_ivex_cntx.start_ticks_1);
        }
        /* ticks 2 is for osd detect */
        kal_get_time(&g_ivex_cntx.start_ticks_2);
        g_ivex_cntx.double1_x = pos.x;
        g_ivex_cntx.double1_y = pos.y;
    }
    else
    {
        g_ivex_cntx.start_ticks_1 = 0;
        g_ivex_cntx.double1_x = 0;
        g_ivex_cntx.double1_y = 0;
        g_ivex_cntx.is_double_click = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_down_hdlr
 * DESCRIPTION
 *  pen down event handler.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_VIEW);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_PEN_DOWN,
        g_ivex_cntx.view_state,
        g_ivex_cntx.osd_state,
        g_ivex_cntx.image_state,
        g_ivex_cntx.ui_display_rotate,pos.x,pos.y);

    g_ivex_cntx.is_pen_down = MMI_TRUE;
    g_ivex_cntx.is_pen_move = MMI_FALSE;

#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.is_scalado_anim == MMI_TRUE || g_ivex_cntx.ui_rotating == MMI_TRUE){
        g_ivex_cntx.is_pen_down = MMI_FALSE;
            return;
    }
#endif //__IVEX_SUPPORT_IES__
    
    if (!mmi_ivex_check_view_avaliable_and_process())
    {
        return;
    }
    mmi_ivex_non_move_axis_stop_bounce();
    mmi_ivex_stop_auto_move();
    g_ivex_cntx.pen_down_x = pos.x;
    g_ivex_cntx.pen_down_y = pos.y;
    g_ivex_cntx.pen_move_x = g_ivex_cntx.pen_down_x;
    g_ivex_cntx.pen_move_y = g_ivex_cntx.pen_down_y;

    if(MMI_TRUE == mmi_ivex_check_double_click_is_valid(pos))
    {
        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
    }
    else if(g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_SHOW)
    {
        mmi_ivex_enable_osd_fade(MMI_FALSE);
    }
    g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_NONE;
    switch (g_ivex_cntx.image_state)
    {
        case MMI_IVEX_IMAGE_STATE_STILL_H2P:
        case MMI_IVEX_IMAGE_STATE_STILL_P2H:
            return;
        case MMI_IVEX_IMAGE_STATE_SWITCH_NEXT:
        case MMI_IVEX_IMAGE_STATE_SWITCH_PREV:
            /* user control image subjectively */
            gui_cancel_timer(mmi_ivex_switch_next_cyclic);
            gui_cancel_timer(mmi_ivex_switch_previous_cyclic);
            /* stop switch render */
            if (!g_ivex_cntx.is_spring)
            {
                //mmi_ivex_stop_renderer();
            }
            else
            {
                /* pen down should cancel rebound back process */
                g_ivex_cntx.is_spring = MMI_FALSE;
                gui_cancel_timer(mmi_ivex_pen_up_and_rebound_current_image);
            }
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_NONE;
            g_ivex_cntx.is_pen_down_on_switch = MMI_TRUE;
            return;
        case MMI_IVEX_IMAGE_STATE_PLAY:
            mmi_ivex_stop_play_action();
            g_ivex_cntx.play_skip_number = 0;
            mmi_ivex_update_image_for_normal_interrupt();
            /* draw stop icon */
            mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
            mmi_ivex_stop_osd_fade_out();
            mmi_ivex_stop_osd_fade_in();
            mmi_ivex_start_osd_fade_in();
            return;
        default:
            break;
    }

    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE)
    {
        /* anykey down, will stop shortcut zoom action, or ui will be abnormal */
        mmi_ivex_shortcut_zoom_stop_hdlr();
        return;
    }

    mmi_ivex_shortcut_pen_down_dectect(pos);

    if (g_ivex_cntx.osd_state != MMI_IVEX_OSD_STATE_SHOW)
    {
        return;
    }

    mmi_ivex_convert_touch_coordinate(&pos);
    /* LSK */
    if (mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->lsk), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
    {
        g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_LSK;
        mmi_ivex_lsk_press();
        return;
    }
    /* RSK */
    if (mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->rsk), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
    {
        g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_RSK;
        mmi_ivex_rsk_press();
        return;
    }
    /* CENTER KEY */
    if (mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->csk), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
    {
        if (!MMI_IVEX_LANDSCAPE)
        {
        #ifdef __MMI_IMGVIEWEX_MOTION__
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_CENTER_PLAY;

        #ifdef DEBUGE_IVEX_UI_ROTATE
            mmi_ivex_switch_ui_press();
        #else
            mmi_ivex_play_press();
        #endif
            return;
        #else
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_CENTER_SWITCH_UI;
            mmi_ivex_switch_ui_press();
            return;
        #endif
        }
        else
        {
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_CENTER_PLAY;
            mmi_ivex_play_press();
            return;
        }
    }

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    if (g_ivex_cntx.image_info.is_mav) {
        mmi_ivex_sliding_bar_convert_touch_coordinate(&pos);

        if (sliding_bar_is_in_sliding_bar(&(g_ivex_cntx.osd_sliding_bar), pos.x, pos.y)) {
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_SLIDING_BAR;
            mmi_ivex_sliding_bar_pen_down(&pos);
            return;
        }
    }
    else {
#endif        
        /* CW */
        if (mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->cwr), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
        {
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_ROTATE_CW;
            mmi_ivex_rotate_cw_press();
            return;
        }
        /* CCW */
        if (mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->ccwr), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
        {
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_ROTATE_CCW;
            mmi_ivex_rotate_ccw_press();
            return;
        }
        /* ZOOM IN */
        if(mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->zoomin), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
        {
            mmi_ivex_zoomin_press();
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_ZOOMIN;
            return;
        }
        /* ZOOM OUT */
        if(mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->zoomout), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
        {
            mmi_ivex_zoomout_press();
            g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_ZOOMOUT;
            return;
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    }
#endif
    g_ivex_cntx.touch_object = MMI_IVEX_TOUCH_OBJ_NONE;

#if defined(SVG12_SUPPORT)
    /* this need absolute coordinate */
    svg_pen_event_handler(MMI_PEN_EVENT_DOWN, g_ivex_cntx.pen_down_x, g_ivex_cntx.pen_down_y);
#endif
}

static U32 mmi_ivex_get_ease_index(S32 percent)
{
    U32 index = 0;
    U32 count;

    count = sizeof(mmi_ivex_keyframe_ease_out)/sizeof(mmi_ivex_keyframe_ease_out[0]);
    for (index = 0; index <count - 1; index++)
    {
        if (percent == mmi_ivex_keyframe_ease_out[index])
        {
            break;
        }

        if (percent >= mmi_ivex_keyframe_ease_out[index] &&
            percent < mmi_ivex_keyframe_ease_out[index+1])
        {
            break;
        }
    }

    return index;

}
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_ease_out_percent
 * DESCRIPTION
 *  calculate the percent based "ease out" formula.
 * PARAMETERS
 *  ui_angle : UI rotate angle
 *  view_angle : view layer rotate angle
 *  distance_x : view layer offset (position), it based on view layer axis
 *  distance_y : view layer offset (position), it based on view layer axis
 * RETURNS
 *  numerator of percent
 *****************************************************************************/
U8 mmi_ivex_get_ease_out_percent(U8 ui_angle, U8 view_angle, S32 distance_x, S32 distance_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 percent, current_percent;
    U32 abs_distance;
    S32 ext_ui_width;
    U32 index;
    S32 x1, x2, x3;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    abs_distance = mmi_ivex_get_view_switch_distance(ui_angle,view_angle,distance_x,distance_y,MMI_TRUE);
    if (abs_distance <= MMI_IVEX_IMAGE_SPACING)
    {
        return MMI_IVEX_SWITCH_FRAME_STEP;
    }

    ext_ui_width = mmi_ivex_get_ext_ui_width();
    percent = abs_distance * 100 / ext_ui_width;
    index = mmi_ivex_get_ease_index(percent);

    x1 = mmi_ivex_keyframe_ease_out[index];
    x2 = mmi_ivex_keyframe_ease_out[index+1];
    x3 = x2 - x1;

    if (x3 <= 1)
    {
        x3 = 1;
    }

    current_percent  = (S32)(ceil((float)(10 * (percent - x1)) / (float)x3 + 10 * index));

    if (current_percent < 0)
    {
        current_percent = 0;
    }
    if (current_percent > 100)
    {
        current_percent = 100;
    }
    return current_percent;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_up_and_continue_switch_image
 * DESCRIPTION
 *  will continue switch to another image after pen up
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_up_and_continue_switch_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cntx.switch_frame_precent =
        mmi_ivex_get_ease_out_percent(g_ivex_cntx.ui_display_rotate,
                                                g_ivex_cntx.view_image_rotate,
                                                g_ivex_cntx.display_layer_last_offset_x,
                                                g_ivex_cntx.display_layer_last_offset_y);
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
    {
        mmi_ivex_start_switch_pre();
    }
    else
    {
        mmi_ivex_start_switch_next();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_rebound_back
 * DESCRIPTION
 *  interrupt case
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_rebound_back(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_pen_up_and_rebound_current_image);
    if (g_ivex_cntx.is_spring)
    {
        g_ivex_cntx.is_spring = MMI_FALSE;
        /* just spring back to meet lcd */
        mmi_ivex_restore_filelist_index();
    }
    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_up_and_rebound_current_image
 * DESCRIPTION
 *  will spring back the current image when the distance of draging out is less than ten percent of lcd "width"
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_up_and_rebound_current_image(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret = SRV_MEDIACACHE_OK;
    S32 curr_precent = g_ivex_cntx.percent_numerator;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* pen event, so stop switch next, need stop renderer */
    if (g_ivex_cntx.is_pen_down == MMI_TRUE)
    {
        gui_cancel_timer(mmi_ivex_pen_up_and_rebound_current_image);
        g_ivex_cntx.is_spring = MMI_FALSE;
        return;
    }

    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
    {
        mmi_ivex_switch_next_ease_out();
        if (g_ivex_cntx.percent_numerator > 0)
        {
            g_ivex_cntx.percent_numerator >>= 1;
            gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_pen_up_and_rebound_current_image);
        }
    }
    else
    {
        mmi_ivex_switch_previous_ease_out();
        if (g_ivex_cntx.percent_numerator > 0)
        {
            g_ivex_cntx.percent_numerator >>= 1;
            gui_start_timer(MMI_IVEX_SWITCH_EASE_OUT_INTERVAL, mmi_ivex_pen_up_and_rebound_current_image);
        }
    }

    if (curr_precent <= 0 && g_ivex_cntx.image_info.is_loading)
    {
        mmi_ivex_stop_curr_loading_effect();
        mmi_ivex_stop_switch_loading_effect();
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        if (ret >= SRV_MEDIACACHE_OK)
        {
            mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
        #ifdef __DRM_SUPPORT__
            mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
        #endif
        }
        else
        {
            g_ivex_cntx.pre_image_state = MMI_IVEX_IMAGE_STATE_SWITCH_NEXT;
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }

    if (curr_precent <= 0 &&
        g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK &&
        g_ivex_cntx.image_info.is_loading == MMI_FALSE)
    {
        if (g_ivex_cntx.image_info.is_animation)
        {
            if (g_ivex_cntx.image_info.handle == 0)
            {
                mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
            }
        }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        else if (g_ivex_cntx.image_info.is_mav)
        {
            if (g_ivex_cntx.image_info.handle == 0)
            {
                mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
            }
        }
#endif
        else
        {
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);/* blt fuzz first to avoid block */
            mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        }
    }

    /* make sure current panel is for current image */
    if (curr_precent <= 0)
    {
        mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    }
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_up_hdlr
 * DESCRIPTION
 *  pen up event handler
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_up_during_switch(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 curr_times;
    S32 layer_offset;
    S32 limit_value;
    S32 ext_ui_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    layer_offset = mmi_ivex_get_view_switch_distance(g_ivex_cntx.ui_display_rotate,
                                                                                g_ivex_cntx.view_image_rotate,
                                                                                g_ivex_cntx.display_layer_last_offset_x,
                                                                                g_ivex_cntx.display_layer_last_offset_y,
                                                                                MMI_TRUE);
    ext_ui_width = mmi_ivex_get_ext_ui_width();
    if (g_ivex_cntx.image_info.resized_image_height > g_ivex_cntx.view_layer_height ||
        g_ivex_cntx.image_info.resized_image_width > g_ivex_cntx.view_layer_width)
    {
        if (g_ivex_cntx.display_layer_last_offset_x != 0 && g_ivex_cntx.display_layer_last_offset_y != 0)
        {
            /* non-active bounce avaliable */
            limit_value = ext_ui_width / 3;
            if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
            {
                g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_JUST_NEXT;
            }
            else
            {
                g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_JUST_PRE;
            }
        }
        else
        {
            if (g_ivex_cntx.pen_switch_orientation == MMI_IVEX_SWITCH_NONE)
            {
                limit_value = ext_ui_width / 3;
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
                {
                    g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_JUST_NEXT;
                }
                else
                {
                    g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_JUST_PRE;
                }
            }
            else
            {
                kal_get_time(&curr_times);
                if ((g_ivex_cntx.is_pen_down_on_switch == MMI_FALSE) ||
                    ((g_ivex_cntx.is_pen_down_on_switch == MMI_TRUE) &&
                    (curr_times - g_ivex_cntx.pen_move_interval) > MMI_IVEX_AUTO_MOVE_TIME_LIMI))
                {
                    if ((g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT &&
                        g_ivex_cntx.pen_switch_orientation == MMI_IVEX_SWITCH_JUST_PRE) ||
                        (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV &&
                        g_ivex_cntx.pen_switch_orientation == MMI_IVEX_SWITCH_JUST_NEXT))
                    {
                        limit_value = ext_ui_width / 3;
                        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
                        {
                            g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_JUST_NEXT;
                        }
                        else
                        {
                            g_ivex_cntx.pen_switch_orientation = MMI_IVEX_SWITCH_JUST_PRE;
                        }
                    }
                    else
                    {
                        limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT_L;
                    }
                }
                else
                {
                    if ((layer_offset >= MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT) &&
                        (layer_offset <= (ext_ui_width - MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT)))
                    {
                        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
                        {
                            if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_0)
                            {
                                if ((pos.x - g_ivex_cntx.pen_move_x) > 0)
                                {
                                    limit_value = LCD_WIDTH;
                                }
                                else
                                {
                                    limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT_L;
                                }
                            }
                            else
                            {
                                 /* g_ivex_cntx.ui_display_rotate = GDI_LAYER_ROTATE_90 */
                                if ((pos.y - g_ivex_cntx.pen_move_y) > 0)
                                {
                                    limit_value = LCD_HEIGHT;
                                }
                                else
                                {
                                    limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT_L;
                                }
                            }
                        }
                        else
                        {
                            if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_0)
                            {
                                if ((pos.x - g_ivex_cntx.pen_move_x) > 0)
                                {
                                    limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT_L;
                                }
                                else
                                {
                                    limit_value = LCD_WIDTH;
                                }
                            }
                            else
                            {
                                 /* g_ivex_cntx.ui_display_rotate = GDI_LAYER_ROTATE_90 */
                                if ((pos.y - g_ivex_cntx.pen_move_y) > 0)
                                {
                                    limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT_L;
                                }
                                else
                                {
                                    limit_value = LCD_HEIGHT;
                                }
                            }
                        }
                    }
                    else
                    {
                        limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT_L;
                    }
                }
            }
        }
    }
    else
    {
        kal_get_time(&curr_times);
        if ((g_ivex_cntx.is_pen_down_on_switch == MMI_FALSE) ||
            ((g_ivex_cntx.is_pen_down_on_switch == MMI_TRUE) &&
            (curr_times - g_ivex_cntx.pen_move_interval) > MMI_IVEX_AUTO_MOVE_TIME_LIMI))
        {
            limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT;
        }
        else
        {
            if ((layer_offset >= MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT) &&
                (layer_offset <= (ext_ui_width - MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT)))
            {
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
                {
                    if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_0)
                    {
                        if ((pos.x - g_ivex_cntx.pen_move_x) > 0)
                        {
                            limit_value = LCD_WIDTH;
                        }
                        else
                        {
                            limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT;
                        }
                    }
                    else
                    {
                         /* g_ivex_cntx.ui_display_rotate = GDI_LAYER_ROTATE_90 */
                        if ((pos.y - g_ivex_cntx.pen_move_y) > 0)
                        {
                            limit_value = LCD_HEIGHT;
                        }
                        else
                        {
                            limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT;
                        }
                    }
                }
                else
                {
                    if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_0)
                    {
                        if ((pos.x - g_ivex_cntx.pen_move_x) > 0)
                        {
                            limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT;
                        }
                        else
                        {
                            limit_value = LCD_WIDTH;
                        }
                    }
                    else
                    {
                         /* g_ivex_cntx.ui_display_rotate = GDI_LAYER_ROTATE_90 */
                        if ((pos.y - g_ivex_cntx.pen_move_y) > 0)
                        {
                            limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT;
                        }
                        else
                        {
                            limit_value = LCD_HEIGHT;
                        }
                    }
                }
            }
            else
            {
                limit_value = MMI_IVEX_SWITCH_IMAGE_LIMIT_PERCENT;
            }
        }
    }

    if (layer_offset >= limit_value)
    {
        mmi_ivex_pen_up_and_continue_switch_image();
    }
    else
    {
        gdi_layer_struct *layer = (gdi_layer_struct*)g_ivex_cntx.display_layer_handle;
        g_ivex_cntx.percent_numerator =
            abs(g_ivex_cntx.display_layer_last_offset_x) * 100 / layer->width >
            abs(g_ivex_cntx.display_layer_last_offset_y) * 100 / layer->height ?
            abs(g_ivex_cntx.display_layer_last_offset_x) * 100 / layer->width :
            abs(g_ivex_cntx.display_layer_last_offset_y) * 100 / layer->height;
        g_ivex_cntx.is_spring = MMI_TRUE;
        mmi_ivex_pen_up_and_rebound_current_image();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_if_need_move_auto
 * DESCRIPTION
 *  pen up event handler
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ivex_check_if_need_move_auto(mmi_pen_point_struct pos, S32 last_x, S32 last_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 curr_times;
    S32 move_x_speed;
    S32 move_y_speed;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.display_layer_last_offset_y != 0 ||
        g_ivex_cntx.display_layer_last_offset_x != 0)
    {
        return MMI_FALSE;
    }
    kal_get_time(&curr_times);
    g_ivex_cntx.pen_move_interval = curr_times - g_ivex_cntx.pen_move_time1;
    g_ivex_cntx.pen_move_x = pos.x - last_x;
    g_ivex_cntx.pen_move_y = pos.y - last_y;

    move_x_speed = abs(g_ivex_cntx.pen_move_x) * 10 / g_ivex_cntx.pen_move_interval;
    move_y_speed = abs(g_ivex_cntx.pen_move_y) * 10 / g_ivex_cntx.pen_move_interval;

    if (move_x_speed > (MMI_IVEX_AUTO_MOVE_THRESHOLD * 10 / MMI_IVEX_AUTO_MOVE_TIME_LIMI) ||
        move_y_speed > (MMI_IVEX_AUTO_MOVE_THRESHOLD * 10 / MMI_IVEX_AUTO_MOVE_TIME_LIMI))
    {
        TMP_TRACE1("[IVAPP][YWY]pen movex speed=%d", move_x_speed);
        TMP_TRACE1("[IVAPP][YWY]pen movey speed=%d", move_y_speed);
        move_x_speed += 50;
        move_y_speed += 50;
        return (move_x_speed<<16)/50 | move_y_speed/50;
    }
    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_shortcut_osd_hide_unhide_switch
 * DESCRIPTION
 *  pen down event handler.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_shortcut_osd_hide_unhide_switch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_rotating == MMI_FALSE)
    {
        if (g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_HIDE)
        {
            mmi_ivex_stop_osd_fade_out();
            mmi_ivex_stop_osd_fade_in();
            mmi_ivex_start_osd_fade_in();
        }
        else if (g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_SHOW)
        {
            mmi_ivex_stop_osd_fade_out();
            mmi_ivex_stop_osd_fade_in();
            mmi_ivex_start_osd_fade_out();
        }
    }
    g_ivex_cntx.start_ticks_1 = 0;
    g_ivex_cntx.start_ticks_2 = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_shortcut_pen_up_dectect
 * DESCRIPTION
 *  pen down event handler.
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_shortcut_pen_up_dectect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 up_time;
    U32 duration_1;
    U32 duration_2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE ||
        g_ivex_cntx.is_pen_move == MMI_TRUE ||
        g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_STILL)
    {
        g_ivex_cntx.start_ticks_1 = 0;
        g_ivex_cntx.start_ticks_2 = 0;
        return MMI_FALSE;
    }
    kal_get_time(&up_time);
    if (g_ivex_cntx.is_double_click)
    {
        duration_1 = up_time - g_ivex_cntx.start_ticks_1;
        if (duration_1 < MMI_IVEX_DOUBLE_CLICK_INTERVAL)
        {
            g_ivex_cntx.is_pen_down_zoom = MMI_TRUE;
            mmi_ivex_shortcut_zoom_start_hdlr();
        }
        else
        {
            duration_2 = up_time - g_ivex_cntx.start_ticks_2;
            if (duration_2 < MMI_IVEX_SINGLE_CLICK_INTERVAL)
            {
                if (g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_SHOW ||
                    g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_HIDE)
                {
                    gui_start_timer(MMI_IVEX_DOUBLE_CLICK_INTERVAL, mmi_ivex_shortcut_osd_hide_unhide_switch);
                }
            }
        }
        g_ivex_cntx.start_ticks_1 = 0;
        g_ivex_cntx.start_ticks_2 = 0;
        g_ivex_cntx.is_double_click = MMI_FALSE;
    }
    else
    {
        duration_2 = up_time - g_ivex_cntx.start_ticks_2;
        if (duration_2 < MMI_IVEX_SINGLE_CLICK_INTERVAL && g_ivex_cntx.start_ticks_1 != 0)
        {
            gui_start_timer(MMI_IVEX_DOUBLE_CLICK_INTERVAL, mmi_ivex_shortcut_osd_hide_unhide_switch);
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_up_hdlr
 * DESCRIPTION
 *  pen up event handler
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(SVG12_SUPPORT)
    mmi_pen_point_struct temp_pos = pos;
#endif
    S32 ret = SRV_MEDIACACHE_OK;
    MMI_BOOL double_click_require;
    U8 orient;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_ivex_cntx.is_pen_down)
    {
        return;
    }
    MMI_ASSERT(g_ivex_cntx.view_state == MMI_IVEX_VIEW_STATE_VIEW);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_PEN_UP,g_ivex_cntx.image_info.zoom_cnt,g_ivex_cntx.ui_display_rotate, g_ivex_cntx.touch_object);
    /*check if need rebounce */
    if(g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_PREV &&
                            g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
    {
        S32 off_x, off_y;
        S32 need_rebounce = 0;
        gdi_layer_get_position_nb_concurrent(g_ivex_cntx.display_layer_handle, &off_x, &off_y);
        if (g_ivex_cntx.total_image_count == 1 || g_ivex_cntx.view_from_fmgr)
        {
            orient = MMI_IVEX_SWITCH_AXIS_NONE;
            need_rebounce = (off_x != 0 || off_y != 0);
        }
        else
        {
            orient = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
            need_rebounce = orient == MMI_IVEX_SWITCH_AXIS_X ? (off_y != 0) : (off_x != 0);
        }

        if(need_rebounce != 0)
        {
            mmi_ivex_non_move_axis_start_bounce(orient);
            
            g_ivex_cntx.is_pen_down_zoom = MMI_FALSE;
            g_ivex_cntx.is_pen_down = MMI_FALSE;
            return;
            
        }
        
    }
    double_click_require = mmi_ivex_shortcut_pen_up_dectect();
    if (double_click_require)
    {
        g_ivex_cntx.is_pen_down_zoom = MMI_FALSE;
        g_ivex_cntx.is_pen_down = MMI_FALSE;
        return;
    }
    mmi_ivex_enable_osd_fade(MMI_TRUE);

    if (g_ivex_cntx.touch_object == MMI_IVEX_TOUCH_OBJ_NONE &&
        g_ivex_cntx.image_info.zoom_cnt > 0)
    {
        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV ||
            g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
        {
            g_ivex_cntx.is_pen_down = MMI_FALSE;
            mmi_ivex_pen_up_during_switch(pos);
        }
        else
        {
            if (mmi_ivex_pen_move_is_valid())
            {
                if (!g_ivex_cntx.is_pen_down_zoom)
                {
                    //is_error = mmi_ivex_draw_large_image(pos, IVEX_IMG_QTY_HIGH);
                    g_ivex_cntx.is_pen_down = MMI_FALSE;
                    if (mmi_frm_scrn_get_active_id() != SCR_ID_IMGVIEW_VIEW)
                    {
                        return;
                    }
                    else
                    {
                        mmi_ivex_update_enlarged_image_info(pos);
                        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV ||
                            g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
                        {
                            mmi_ivex_draw_large_image(pos, IVEX_IMG_QTY_HIGH);
                            /* this case is that the distance is too far between pen dwon and up and no move callback during this period.
                            when pen up, will refresh the image, during refreshing, found that has started switch image, so change as switch
                            state at pen up, here process up case during switch */
                            mmi_ivex_pen_up_during_switch(pos);
                        }
                        else
                        {
                            S32 speed;
                            
                            ivex_img_quality_enum qty = IVEX_IMG_QTY_HIGH;
                            orient = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
                            speed = mmi_ivex_check_if_need_move_auto(pos, g_ivex_cntx.pen_move_x, g_ivex_cntx.pen_move_y);
                            if (speed != 0)
                            {
                                mmi_ivex_start_auto_move(speed);
                                qty = IVEX_IMG_QTY_DEFAULT;
                                
                            }
                            else
                            {
                                if ((g_ivex_cntx.total_image_count == 1 || g_ivex_cntx.view_from_fmgr) &&
                                    (g_ivex_cntx.display_layer_last_offset_y != 0 || g_ivex_cntx.display_layer_last_offset_x != 0))
                                {
                                    mmi_ivex_non_move_axis_start_bounce(MMI_IVEX_SWITCH_AXIS_NONE);
                                }
                                else if (mmi_ivex_non_move_axis_is_bounce_ava(orient))
                                {
                                    mmi_ivex_non_move_axis_start_bounce(orient);
                                }
                            }
                            mmi_ivex_get_moved_image(qty);
                            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
                        }
                    }
                }
            }
        }
    }
    else if (g_ivex_cntx.touch_object != MMI_IVEX_TOUCH_OBJ_NONE)
    {
        mmi_ivex_convert_touch_coordinate(&pos);
        switch (g_ivex_cntx.touch_object)
        {
            case MMI_IVEX_TOUCH_OBJ_LSK:
                mmi_ivex_lsk_release();
                break;
            case MMI_IVEX_TOUCH_OBJ_RSK:
                mmi_ivex_rsk_release();
                break;
            case MMI_IVEX_TOUCH_OBJ_ZOOMIN:
                mmi_ivex_zoomin_release();
                break;
            case MMI_IVEX_TOUCH_OBJ_ZOOMOUT:
                mmi_ivex_zoomout_release();
                break;
            case MMI_IVEX_TOUCH_OBJ_ROTATE_CCW:
                mmi_ivex_rotate_ccw_release();
                break;
            case MMI_IVEX_TOUCH_OBJ_ROTATE_CW:
                mmi_ivex_rotate_cw_release();
                break;
            case MMI_IVEX_TOUCH_OBJ_CENTER_PLAY:
                #ifdef DEBUGE_IVEX_UI_ROTATE
                mmi_ivex_switch_ui_release();
                #else
                mmi_ivex_play_release();
                #endif
                break;
            case MMI_IVEX_TOUCH_OBJ_CENTER_SWITCH_UI:
                mmi_ivex_switch_ui_release();
                break;
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            case MMI_IVEX_TOUCH_OBJ_SLIDING_BAR:
            {
                mmi_ivex_sliding_bar_convert_touch_coordinate(&pos);
                sliding_bar_pen_up_handler(&(g_ivex_cntx.osd_sliding_bar), &pos);
            }
                break;
#endif
        }
    }
    else if (g_ivex_cntx.touch_object == MMI_IVEX_TOUCH_OBJ_NONE &&
            g_ivex_cntx.image_info.zoom_cnt == 0)
    {
        g_ivex_cntx.is_pen_down = MMI_FALSE;
        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV ||
            g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT)
        {
            mmi_ivex_pen_up_during_switch(pos);
        }

        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL &&
            g_ivex_cntx.image_info.is_loading)
        {
            /* this case is pen move to pre or next and drag back to the right LCD */
            mmi_ivex_stop_curr_loading_effect();
            mmi_ivex_stop_switch_loading_effect();
            ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
            if (ret >= SRV_MEDIACACHE_OK)
            {
                GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
                mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
                mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
                g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
            #ifdef __DRM_SUPPORT__
                mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
            #endif
            }
            else
            {
                g_ivex_cntx.pre_image_state = MMI_IVEX_IMAGE_STATE_SWITCH_NEXT;
                mmi_ivex_process_curr_image_decode_abnormal(ret);
            }
        }
        /* This is for just drag back to lcd */
        /* the condition added is just for scalado not support call 0.1 process twice */
        if(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_NEXT || 
            g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_SWITCH_PREV)
        mmi_ivex_update_image_for_normal_interrupt();
        /* make sure current panel is for current image */
        if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL)
        {
            mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_osd_sliding_bar_layer();
#endif
        }
    }
#if defined(SVG12_SUPPORT)
    svg_pen_event_handler(MMI_PEN_EVENT_UP, temp_pos.x, temp_pos.y);
#endif

    if (g_ivex_cntx.is_pen_down_zoom)
    {
        g_ivex_cntx.is_pen_down_zoom = MMI_FALSE;
    }

    g_ivex_cntx.is_pen_down = MMI_FALSE;
}


#ifdef __MTK_TARGET__
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_abort_hdlr
 * DESCRIPTION
 *  pen up event handler
 * PARAMETERS
 *  pos IN position of the touched pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_abort_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_pen_abort_type_enum abort_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_ivex_cntx.is_pen_down)
    {
        return;
    }

    /* get pen abort type, will do pen up action if pen up lost because queue full, or do nothing */
    abort_type = mmi_pen_get_pen_abort_type();
    if (abort_type == MMI_PEN_ABORT_TYPE_DRVQ_FULL)
    {
        mmi_ivex_pen_up_hdlr(pos);
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_move_is_valid
 * DESCRIPTION
 *  check if move is valid.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_pen_move_is_valid(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_valid = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL_H2P ||
        g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL_P2H ||
        g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
    {
        is_valid = MMI_FALSE;
    }
    return is_valid;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pen_move_hdlr
 * DESCRIPTION
 *  pen move event handler.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL icon_pressed = MMI_TRUE;
    MMI_BOOL is_error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_PEN_MOVE,
        g_ivex_cntx.image_state,
        g_ivex_cntx.view_state,
        g_ivex_cntx.osd_state,
        g_ivex_cntx.image_info.zoom_cnt,
        g_ivex_cntx.view_image_rotate,
        g_ivex_cntx.ui_display_rotate,
        g_ivex_cntx.touch_object,
        g_ivex_cntx.is_pen_down,
        g_ivex_cntx.view_layer_width,
        g_ivex_cntx.switch_layer_width,
        pos.x,pos.y);
    if (g_ivex_cntx.is_pen_down == MMI_TRUE && g_ivex_cntx.is_pen_move == MMI_FALSE)
    {
        if ((abs(g_ivex_cntx.pen_down_x - pos.x) < MMI_IVEX_SINGLE_TAP_VALID_RADIUS) && (abs(g_ivex_cntx.pen_down_y- pos.y) < MMI_IVEX_SINGLE_TAP_VALID_RADIUS))
        {
            //increase double click ratio
            return;
        }
    }

    g_ivex_cntx.is_pen_move = MMI_TRUE;
#ifdef __IVEX_SUPPORT_IES__
    if(g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
    {
        if (!g_ivex_cntx.is_pen_down || g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE || 
            g_ivex_cntx.image_info.CAPS_flag != MMI_IVEX_caps_display)
            return;
    }else{
#endif
    if (!g_ivex_cntx.is_pen_down || g_ivex_cntx.zoom_orientation != MMI_IVEX_ZOOM_NONE)
    {
        return;
    }
#ifdef __IVEX_SUPPORT_IES__
  }
#endif

    if (g_ivex_cntx.ui_rotating == MMI_FALSE
        && mmi_ivex_check_double_click_is_valid(pos)
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        && g_ivex_cntx.touch_object != MMI_IVEX_TOUCH_OBJ_SLIDING_BAR
#endif
        )
    {
        mmi_ivex_stop_osd_fade_out();
        mmi_ivex_stop_osd_fade_in();
        mmi_ivex_start_osd_fade_out();
    }

    if (g_ivex_cntx.touch_object == MMI_IVEX_TOUCH_OBJ_NONE &&
        g_ivex_cntx.image_info.zoom_cnt > 0 &&
        g_ivex_cntx.image_info.is_loading == MMI_FALSE &&
        g_ivex_cntx.image_info.is_err == MMI_FALSE &&
        mmi_ivex_check_double_click_is_valid(pos))
    {
        if (!mmi_ivex_pen_move_is_valid())
        {
            return;
        }
        is_error = mmi_ivex_draw_large_image(pos, IVEX_IMG_QTY_DEFAULT);
        if (is_error)
        {
            return;
        }
    }
    else if (g_ivex_cntx.touch_object == MMI_IVEX_TOUCH_OBJ_NONE &&
        g_ivex_cntx.image_info.zoom_cnt == 0 &&
        mmi_ivex_check_double_click_is_valid(pos))
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_PEN_MOVE_1,g_ivex_cntx.display_layer_last_offset_x);
        if (!mmi_ivex_pen_move_is_valid())
        {
            return;
        }
        mmi_ivex_pen_move_switch_image(pos, 0, 0);
        if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW)
        {
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        }
        else
        {
            return;
        }
    }
    /* remeber the current position as pen_down */
    g_ivex_cntx.pen_move_x = g_ivex_cntx.pen_down_x;
    g_ivex_cntx.pen_move_y = g_ivex_cntx.pen_down_y;
    g_ivex_cntx.pen_move_time1 = g_ivex_cntx.pen_move_interval;
    kal_get_time(&g_ivex_cntx.pen_move_interval);
    g_ivex_cntx.pen_down_x = pos.x;
    g_ivex_cntx.pen_down_y = pos.y;

    if (g_ivex_cntx.touch_object != MMI_IVEX_TOUCH_OBJ_NONE)
    {
        mmi_ivex_convert_touch_coordinate(&pos);
        switch (g_ivex_cntx.touch_object)
        {
            case MMI_IVEX_TOUCH_OBJ_LSK:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->lsk), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    g_ivex_cntx.active_osd_layout_ptr->lsk.is_press = MMI_FALSE;
                }
                break;
            case MMI_IVEX_TOUCH_OBJ_RSK:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->rsk), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    g_ivex_cntx.active_osd_layout_ptr->rsk.is_press = MMI_FALSE;
                }
                break;
            case MMI_IVEX_TOUCH_OBJ_ROTATE_CCW:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->ccwr), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    g_ivex_cntx.active_osd_layout_ptr->ccwr.is_press = MMI_FALSE;
                }
                break;
            case MMI_IVEX_TOUCH_OBJ_ROTATE_CW:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->cwr), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    g_ivex_cntx.active_osd_layout_ptr->cwr.is_press = MMI_FALSE;
                }
                break;
            case MMI_IVEX_TOUCH_OBJ_ZOOMIN:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->zoomin), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    mmi_ivex_stop_zoomin();
                }
                break;
            case MMI_IVEX_TOUCH_OBJ_ZOOMOUT:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->zoomout), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    mmi_ivex_stop_zoomout();
                }
                break;
            case MMI_IVEX_TOUCH_OBJ_CENTER_PLAY:
            case MMI_IVEX_TOUCH_OBJ_CENTER_SWITCH_UI:
                if (!mmi_ivex_touch_scr_hit_test(pos.x, pos.y, &(g_ivex_cntx.active_osd_layout_ptr->csk), &(g_ivex_cntx.active_osd_layout_ptr->panel)))
                {
                    icon_pressed = MMI_FALSE;
                    g_ivex_cntx.active_osd_layout_ptr->csk.is_press = MMI_FALSE;
                }
                break;
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            case MMI_IVEX_TOUCH_OBJ_SLIDING_BAR:
            {
                mmi_ivex_sliding_bar_convert_touch_coordinate(&pos);
                sliding_bar_pen_move_handler(&(g_ivex_cntx.osd_sliding_bar), &pos);
            }
                break;
#endif
        }

        if (icon_pressed == MMI_FALSE)
        {
            g_ivex_cntx.key_press = MMI_FALSE;
            mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_osd_sliding_bar_layer();
#endif
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        }
    }

#if defined(SVG12_SUPPORT)
    if (g_ivex_cntx.map.zoom_factor_cnt == 0)
    {
        svg_pen_event_handler(MMI_PEN_EVENT_MOVE, g_ivex_cntx.pen_down_x, g_ivex_cntx.pen_down_y);
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_switch_enlarged_image
 * DESCRIPTION
 *  get moved image.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 *  move_x : based screen axis (left-up is (0,0)), the two movements are mainly for pen large iamge used
 *  move_y : based screen axis (left-up is (0,0)), move from left to right is positive x, up to down is positive y
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_switch_enlarged_image(mmi_pen_point_struct pos, S32 move_x, S32 move_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!g_ivex_cntx.is_pen_down && !g_ivex_cntx.is_auto_move)
    {
        /* key move will not to switch image */
        return;
    }
    mmi_ivex_pen_move_switch_image(pos, move_x, move_y);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_protect_gesture_switch
 * DESCRIPTION
 *  get moved image.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL MMI_TRUE in pen-moving, MMI_FALSE other case
 *****************************************************************************/
MMI_BOOL mmi_ivex_protect_gesture_switch(ivex_image_state_enum image_state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL gest_move = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.is_pen_down && g_ivex_cntx.image_state == image_state)
    {
        g_ivex_cntx.switch_frame_precent =
        mmi_ivex_get_ease_out_percent(g_ivex_cntx.ui_display_rotate,
                                                g_ivex_cntx.view_image_rotate,
                                                g_ivex_cntx.display_layer_last_offset_x,
                                                g_ivex_cntx.display_layer_last_offset_y);

        gest_move = MMI_TRUE;
    }
    return gest_move;
}
#endif /* __MMI_TOUCH_SCREEN__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_moved_image
 * DESCRIPTION
 *  get moved image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_moved_image(ivex_img_quality_enum img_qty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK)
    {
        ret = mmi_ivex_get_curr_img(img_qty);

        if (ret < SRV_MEDIACACHE_OK)
        {
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_image_edge
 * DESCRIPTION
 *  Check if reach edge of image.
 * PARAMETERS
 *  up [out]: based view layer axis
 *  down [out]: based view layer axis
 *  left [out]: based view layer axis
 *  right [out]: based view layer axis
 *  img_info [in]: image info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_check_image_edge(MMI_BOOL *up,
                                        MMI_BOOL *down,
                                        MMI_BOOL *left,
                                        MMI_BOOL *right,
                                        ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (img_info->resized_offset_y ==
        img_info->resized_image_height
        - img_info->resized_height)
    {
        *down = MMI_TRUE;
    }

    if (img_info->resized_offset_y == 0)
    {
        *up = MMI_TRUE;
    }

    if (img_info->resized_offset_x ==
        img_info->resized_image_width
        - img_info->resized_width)
    {
        *right = MMI_TRUE;
    }

    if (img_info->resized_offset_x == 0)
    {
        *left = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_image_edge_by_orie
 * DESCRIPTION
 *  Check if reach edge of image.
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_check_image_edge_by_orie(MMI_BOOL up,
                                                    MMI_BOOL down,
                                                    MMI_BOOL left,
                                                    MMI_BOOL right,
                                                    U8 view_angle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_edge = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (view_angle)
    {
        case GDI_LCD_LAYER_ROTATE_0:
            if (down)
            {
                is_edge = MMI_TRUE;
            }
            break;
        case GDI_LCD_LAYER_ROTATE_90:
            if (right)
            {
                is_edge = MMI_TRUE;
            }
            break;
        case GDI_LCD_LAYER_ROTATE_180:
            if (up)
            {
                is_edge = MMI_TRUE;
            }
            break;
        case GDI_LCD_LAYER_ROTATE_270:
            if (left)
            {
                is_edge = MMI_TRUE;
            }
            break;
        default:
            break;
    }
    return is_edge;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reach_large_image_edge
 * DESCRIPTION
 *  Check if reach edge of image.
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_reach_large_image_edge(U8 ui_angle,
                                                    U8 view_angle,
                                                    ivex_arrow_key_orientation_enum orientation,
                                                    ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_edge = MMI_FALSE;
    MMI_BOOL is_up_edge = MMI_FALSE;
    MMI_BOOL is_down_edge = MMI_FALSE;
    MMI_BOOL is_left_edge = MMI_FALSE;
    MMI_BOOL is_right_edge = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_check_image_edge(&is_up_edge, &is_down_edge, &is_left_edge, &is_right_edge, img_info);

    switch (orientation)
    {
        case MMI_IVEX_ARROW_KEY_DOWN:
            if (ui_angle == GDI_LCD_LAYER_ROTATE_90)
            {
                if (mmi_ivex_check_image_edge_by_orie(is_up_edge, is_down_edge, is_left_edge, is_right_edge, view_angle))
                {
                    is_edge = MMI_TRUE;
                }
            }
            break;
        case MMI_IVEX_ARROW_KEY_UP:
            if (ui_angle == GDI_LCD_LAYER_ROTATE_90)
            {
                if (mmi_ivex_check_image_edge_by_orie(is_down_edge, is_up_edge, is_right_edge, is_left_edge, view_angle))
                {
                    is_edge = MMI_TRUE;
                }
            }
            break;
        case MMI_IVEX_ARROW_KEY_LEFT:
            if (ui_angle == GDI_LCD_LAYER_ROTATE_0)
            {
                if (mmi_ivex_check_image_edge_by_orie(is_right_edge, is_left_edge, is_up_edge, is_down_edge, view_angle))
                {
                    is_edge = MMI_TRUE;
                }
            }
            break;
        case MMI_IVEX_ARROW_KEY_RIGHT:
            if (ui_angle == GDI_LCD_LAYER_ROTATE_0)
            {
                if (mmi_ivex_check_image_edge_by_orie(is_left_edge, is_right_edge, is_down_edge, is_up_edge, view_angle))
                {
                    is_edge = MMI_TRUE;
                }
            }
            break;
        default:
            break;
    }
    return is_edge;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_update_enlarged_image_info_ex
 * DESCRIPTION
 *  update enlarged image info.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_update_enlarged_image_info_ex(ivex_image_info_struct *img_info, U8 view_angle, S32 move_x, S32 move_y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (view_angle)
    {
        case GDI_LCD_LAYER_ROTATE_0:
            img_info->resized_offset_y -= move_y;
            img_info->resized_offset_x -= move_x;
            break;
        case GDI_LCD_LAYER_ROTATE_90:
            img_info->resized_offset_y += move_x;
            img_info->resized_offset_x -= move_y;
            break;
        case GDI_LCD_LAYER_ROTATE_180:
            img_info->resized_offset_y += move_y;
            img_info->resized_offset_x += move_x;
            break;
        case GDI_LCD_LAYER_ROTATE_270:
            img_info->resized_offset_y -= move_x;
            img_info->resized_offset_x += move_y;
            break;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_layer_movement
 * DESCRIPTION
 *  adjust resized offset.
 * PARAMETERS
 *  img_info : image info
 *  move_x :  the movement in x axis of screen coordinate, that is absolute coordinate
 *  move_y :  the movement in y axis of screen coordinate, that is absolute coordinate
 *  is_up_left :  based on view layer's orientation
 *  view_axis_x: if the x orientation touch the edge of image. the axis besed on view layer's orientation
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_layer_movement(ivex_image_info_struct *img_info,
                                                                    S32* move_x,
                                                                    S32* move_y,
                                                                    MMI_BOOL is_up_left,
                                                                    MMI_BOOL view_axis_x)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 orient;
    S16 sign = 1;
    S32* temp_move = NULL;
    S32 pre_move_dis = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    orient = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
    switch (orient)
    {
        case MMI_IVEX_SWITCH_AXIS_X:
            if (view_axis_x)
            {
                if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
                {
                    /* the y axis (original axis) can only move image in layer but need not to move layer evenif to the edge of image */
                    *move_y = 0;
                    temp_move = move_x;
                    pre_move_dis = g_ivex_cntx.abs_move_offset_x;/* this is screen axis */
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0)
                    {
                        sign = -1;
                    }
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
                    {
                        sign = +1;
                    }
                }

                if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
                {
                    /* the x axis (original axis) can only move image in layer but need not to move layer evenif to the edge of image */
                    *move_x = 0;
                    temp_move = move_y;
                    pre_move_dis = g_ivex_cntx.abs_move_offset_y;/* this is screen axis */
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90)
                    {
                        sign = -1;
                    }
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
                    {
                        sign = +1;
                    }
                }

                if (is_up_left)
                {
                    *temp_move = sign * img_info->resized_offset_x + pre_move_dis;
                }
                else
                {
                    *temp_move = sign * (img_info->resized_offset_x + img_info->resized_width - img_info->resized_image_width) + pre_move_dis;
                }
                if (img_info->zoom_cnt > 0)
                {
                    *temp_move = *temp_move / 2;
                }
            }
            else
            {
                *move_y = 0;
                *move_x = 0;
            }
            break;
        case MMI_IVEX_SWITCH_AXIS_Y:
            if (view_axis_x)
            {
                *move_y = 0;
                *move_x = 0;
            }
            else
            {
                if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
                {
                    /* the y axis (original axis) can only move image in layer but need not to move layer evenif to the edge of image */
                    *move_y = 0;
                    temp_move = move_x;
                    pre_move_dis = g_ivex_cntx.abs_move_offset_x;/* this is screen axis */
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90)
                    {
                        sign = +1;
                    }
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
                    {
                        sign = -1;
                    }
                }

                if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
                {
                    /* the x axis (original axis) can only move image in layer but need not to move layer evenif to the edge of image */
                    *move_x = 0;
                    temp_move = move_y;
                    pre_move_dis = g_ivex_cntx.abs_move_offset_y;/* this is screen axis */
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_0)
                    {
                        sign = -1;
                    }
                    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_180)
                    {
                        sign = +1;
                    }
                }

                if (is_up_left)
                {
                    *temp_move = sign * img_info->resized_offset_y + pre_move_dis;
                }
                else
                {
                    *temp_move = sign * (img_info->resized_offset_y + img_info->resized_height - img_info->resized_image_height) + pre_move_dis;
                }
                if (img_info->zoom_cnt > 0)
                {
                    *temp_move = *temp_move / 2;
                }
            }
            break;
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_and_adjust_offset
 * DESCRIPTION
 *  adjust resized offset.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_check_and_adjust_offset(ivex_image_info_struct *img_info, mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 movement_x, movement_y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* adjust resized offset y, the "if" and "else if" are all include the "=" because of back to original position and the view layer just over the lcd zone, this will avoid run twice  */
    if (img_info->resized_offset_y <= 0)
    {
        mmi_ivex_get_layer_movement(img_info, &movement_x, &movement_y, MMI_TRUE, MMI_FALSE);
        img_info->resized_offset_y = 0;
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_ivex_switch_enlarged_image(pos, movement_x, movement_y);
    #endif
    }
    else if ((img_info->resized_offset_y + img_info->resized_height)
        >= img_info->resized_image_height)
    {
        mmi_ivex_get_layer_movement(img_info, &movement_x, &movement_y, MMI_FALSE, MMI_FALSE);
        img_info->resized_offset_y = img_info->resized_image_height - img_info->resized_height;
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_ivex_switch_enlarged_image(pos, movement_x, movement_y);
    #endif
    }
    else
    {
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_ivex_switch_enlarged_image(pos, g_ivex_cntx.abs_move_offset_x, g_ivex_cntx.abs_move_offset_y);
        g_ivex_cntx.abs_move_offset_x = 0;
        g_ivex_cntx.abs_move_offset_y = 0;
    #endif
    }

    if (img_info->resized_offset_x <= 0)
    {
        mmi_ivex_get_layer_movement(img_info, &movement_x, &movement_y, MMI_TRUE, MMI_TRUE);
        img_info->resized_offset_x = 0;
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_ivex_switch_enlarged_image(pos, movement_x, movement_y);
    #endif
    }
    else if ((img_info->resized_offset_x + img_info->resized_width)
        >= img_info->resized_image_width)
    {
        mmi_ivex_get_layer_movement(img_info, &movement_x, &movement_y, MMI_FALSE, MMI_TRUE);
        img_info->resized_offset_x = img_info->resized_image_width - img_info->resized_width;
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_ivex_switch_enlarged_image(pos, movement_x, movement_y);
    #endif
    }
    else
    {
    #if defined(__MMI_TOUCH_SCREEN__)
        mmi_ivex_switch_enlarged_image(pos, g_ivex_cntx.abs_move_offset_x, g_ivex_cntx.abs_move_offset_y);
        g_ivex_cntx.abs_move_offset_x = 0;
        g_ivex_cntx.abs_move_offset_y = 0;
    #endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_non_move_axis_is_bounce_ava
 * DESCRIPTION
 *  check if make the bounce effect.
 * PARAMETERS
 *  orient: image switch orientation, it is based on layer axis
 * RETURNS
 *  if has bounce effect at non switch orientation
 *****************************************************************************/
MMI_BOOL mmi_ivex_non_move_axis_is_bounce_ava(U8 orient)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (orient)
    {
        case MMI_IVEX_SWITCH_AXIS_X:
            if (g_ivex_cntx.image_info.resized_image_height > g_ivex_cntx.view_layer_height)
            {
                return MMI_TRUE;
            }
            break;

        case MMI_IVEX_SWITCH_AXIS_Y:
            if (g_ivex_cntx.image_info.resized_image_width > g_ivex_cntx.view_layer_width)
            {
                return MMI_TRUE;
            }

            break;

        default:
            break;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_non_move_axis_calculate_offset
 * DESCRIPTION
 *  get layer offset on non switch orientation.
 * PARAMETERS
 *  layer_offset: layer offset that is related with lcd bound
 *  img_offset:   image offset that is related layer
 *  layer_demination: layer demination, it is also shown image demination because of image is larger than lcd(layer)
 *  img_demination: current image demination, it is larger than lcd(layer)
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_non_move_axis_calculate_offset(S32 *layer_offset, S32 *img_offset, S32 layer_demination, S32 img_demination)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (abs(*layer_offset) > (layer_demination / MMI_IVEX_BOUNCE_SLIDE_STEP))
    {
        return;
    }

    if (*layer_offset > 0)
    {
        if (*img_offset <= 0)
        {
            *layer_offset = *layer_offset - (*img_offset)  / MMI_IVEX_BOUNCE_SLIDE_STEP;
            if (abs(*layer_offset) > (layer_demination / MMI_IVEX_BOUNCE_SLIDE_STEP))
            {
                *layer_offset = abs(layer_demination / MMI_IVEX_BOUNCE_SLIDE_STEP);
            }
        }
        else
        {
            if (*layer_offset > *img_offset)
            {
                *layer_offset = *layer_offset - *img_offset;
                /* here must set the offset because of layer move does not affect image position */
                *img_offset = 0;
            }
            else
            {
                if ((*img_offset - *layer_offset) > (img_demination - layer_demination))
                {
                    /* the *layer_offset will change as minus value at this case */
                    *layer_offset = ((img_demination - layer_demination) - (*img_offset - *layer_offset)) / MMI_IVEX_BOUNCE_SLIDE_STEP;
                    *img_offset = img_demination - layer_demination;
                }
                else
                {
                    *img_offset = *img_offset - *layer_offset;
                    *layer_offset = 0;
                }
            }
        }
    }
    else if (*layer_offset < 0)
    {
        if ((*img_offset + layer_demination) >= img_demination)
        {
            *layer_offset = *layer_offset - ((*img_offset + layer_demination) - img_demination) / MMI_IVEX_BOUNCE_SLIDE_STEP;
            if (abs(*layer_offset) > (layer_demination / MMI_IVEX_BOUNCE_SLIDE_STEP))
            {
                *layer_offset = -abs(layer_demination / MMI_IVEX_BOUNCE_SLIDE_STEP);
            }
        }
        else
        {
            if (abs(*layer_offset) > abs((*img_offset + layer_demination) - img_demination))
            {
                *layer_offset = *layer_offset - ((*img_offset + layer_demination) - img_demination);
                /* here must set the offset because of layer move does not affect image position */
                *img_offset = img_demination - layer_demination;
            }
            else
            {
                if ((abs((*img_offset + layer_demination) - img_demination) - abs(*layer_offset)) > (img_demination - layer_demination))
                {
                    /* the *layer_offset will change as positive value at this case */
                    *layer_offset = ((abs((*img_offset + layer_demination) - img_demination) - abs(*layer_offset)) - (img_demination - layer_demination)) / MMI_IVEX_BOUNCE_SLIDE_STEP;
                    *img_offset = 0;
                }
                else
                {
                    *img_offset = -((abs((*img_offset + layer_demination) - img_demination) - abs(*layer_offset)) - (img_demination - layer_demination)) ;
                    *layer_offset = 0;
                }
            }
        }
    }
    else
    {
        if (*img_offset <= 0)
        {
            *layer_offset = -(*img_offset)  / MMI_IVEX_BOUNCE_SLIDE_STEP;
        }

        if ((*img_offset + layer_demination) >= img_demination)
        {
            *layer_offset = -(*img_offset + layer_demination - img_demination) / MMI_IVEX_BOUNCE_SLIDE_STEP;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_non_move_axis_get_bounce_dis
 * DESCRIPTION
 *  get layer offset on non switch orientation.
 * PARAMETERS
 *  offset_x: layer offset x
 *  offset_y: layer offset y
 *  img_info: image info
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_non_move_axis_get_bounce_dis(S32 *offset_x, S32 *offset_y, ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 orient;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.key_press)
    {
        /* key move can not triger the auto move and bounce effect */
        return;
    }

    orient = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
    if (mmi_ivex_non_move_axis_is_bounce_ava(orient))
    {
        switch (orient)
        {
            case MMI_IVEX_SWITCH_AXIS_X:
                mmi_ivex_non_move_axis_calculate_offset(offset_y, &img_info->resized_offset_y, g_ivex_cntx.view_layer_height, img_info->resized_image_height);
                break;
            case MMI_IVEX_SWITCH_AXIS_Y:
                mmi_ivex_non_move_axis_calculate_offset(offset_x, &img_info->resized_offset_x, g_ivex_cntx.view_layer_width, img_info->resized_image_width);
                break;
            default:
                break;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_update_enlarged_image_info
 * DESCRIPTION
 *  update enlarged image info.
 * PARAMETERS
 *  pos IN current position of the moved pixel
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_update_enlarged_image_info(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 movement_x = 0;
    S32 movement_y = 0;

#ifdef __MMI_TOUCH_SCREEN__
    S32 layer_offset;
    S32 abs_axis_dis;
    MMI_BOOL need_update;
#endif

#ifdef __IVEX_SUPPORT_IES__
    S32 old_offset_x, old_offset_y, file_index;
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_UPDATE_ENLARGED_IMG_INFO,
        g_ivex_cntx.display_layer_last_offset_x,
        g_ivex_cntx.image_info.resized_offset_y);

#ifdef __IVEX_SUPPORT_IES__
    old_offset_x = g_ivex_cntx.image_info.resized_offset_x;
    old_offset_y = g_ivex_cntx.image_info.resized_offset_y;
    file_index = g_ivex_cntx.image_info.filelist_index;

#endif /*__IVEX_SUPPORT_IES__*/

#ifdef __MMI_TOUCH_SCREEN__
    if (g_ivex_cntx.is_pen_down && g_ivex_cntx.key_press == MMI_FALSE)
    {
        movement_x = pos.x - g_ivex_cntx.pen_down_x;
        movement_y = pos.y - g_ivex_cntx.pen_down_y;
    }
    else if (!g_ivex_cntx.is_pen_down && (g_ivex_cntx.key_press || g_ivex_cntx.is_auto_move))
    {
        movement_x = pos.x;
        movement_y = pos.y;
    }
#else
    movement_x = pos.x;
    movement_y = pos.y;
#endif

    if (!(g_ivex_cntx.total_image_count ==1 || g_ivex_cntx.view_from_fmgr))
    {
    #ifdef __MMI_TOUCH_SCREEN__
        layer_offset = mmi_ivex_get_view_switch_distance(g_ivex_cntx.ui_display_rotate,
                                                                                            g_ivex_cntx.view_image_rotate,
                                                                                            g_ivex_cntx.display_layer_last_offset_x,
                                                                                            g_ivex_cntx.display_layer_last_offset_y,
                                                                                            MMI_FALSE);
        abs_axis_dis = mmi_ivex_convert_view_layer_offset_to_abs_axis_distance(layer_offset);
        /* make sure layer does not move first, need to init the offset */
        g_ivex_cntx.abs_move_offset_x = 0;
        g_ivex_cntx.abs_move_offset_y = 0;
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
        {
            /* check if need update image position is under touch screen, gesture is also */
            need_update = mmi_ivex_check_if_update_image_position(abs_axis_dis, movement_x);
            if (!need_update)
            {
                movement_x = 0;
            }
            else
            {
                /* special for back more than offset, adjust the movement */
                movement_x = movement_x - g_ivex_cntx.abs_move_offset_x;
            }
        }

        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
        {
            need_update = mmi_ivex_check_if_update_image_position(abs_axis_dis, movement_y);
            if (!need_update)
            {
                movement_y = 0;
            }
            else
            {
                /* special for back more than offset, adjust the movement */
                movement_y = movement_y- g_ivex_cntx.abs_move_offset_y;
            }
        }
    #endif
        mmi_ivex_update_enlarged_image_info_ex(&g_ivex_cntx.image_info, g_ivex_cntx.view_image_rotate, movement_x, movement_y);
        mmi_ivex_non_move_axis_get_bounce_dis(&g_ivex_cntx.display_layer_last_offset_x, &g_ivex_cntx.display_layer_last_offset_y, &g_ivex_cntx.image_info);
    }
    else
    {
        mmi_ivex_update_enlarged_image_info_ex(&g_ivex_cntx.image_info, g_ivex_cntx.view_image_rotate, movement_x, movement_y);
        if (!g_ivex_cntx.key_press)
        {
            if (g_ivex_cntx.image_info.resized_image_height > g_ivex_cntx.view_layer_height)
            {
                mmi_ivex_non_move_axis_calculate_offset(&g_ivex_cntx.display_layer_last_offset_y, &g_ivex_cntx.image_info.resized_offset_y, g_ivex_cntx.view_layer_height, g_ivex_cntx.image_info.resized_image_height);
            }

            if (g_ivex_cntx.image_info.resized_image_width > g_ivex_cntx.view_layer_width)
            {
                mmi_ivex_non_move_axis_calculate_offset(&g_ivex_cntx.display_layer_last_offset_x, &g_ivex_cntx.image_info.resized_offset_x, g_ivex_cntx.view_layer_width, g_ivex_cntx.image_info.resized_image_width);
            }
        }
    }
    mmi_ivex_check_and_adjust_offset(&g_ivex_cntx.image_info, pos);
        /* this is for switching image during moving large image, if next can not be found, will exit IVEX, so here should not get image again */
#ifdef __IVEX_SUPPORT_IES__
    if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW && 
        (g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG_FILE || g_ivex_cntx.image_info.image_type == GDI_IMAGE_TYPE_JPG)
         && file_index == g_ivex_cntx.image_info.filelist_index)
    {
        if( g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK && 
            (old_offset_x != g_ivex_cntx.image_info.resized_offset_x || 
            old_offset_y != g_ivex_cntx.image_info.resized_offset_y)){
            
            mmi_pen_point_struct movement_pos;

            movement_pos.x = old_offset_x - g_ivex_cntx.image_info.resized_offset_x ;
            movement_pos.y = old_offset_y - g_ivex_cntx.image_info.resized_offset_y;
            g_ivex_cntx.image_info.resized_offset_x = old_offset_x;
            g_ivex_cntx.image_info.resized_offset_y = old_offset_y;
            mmi_ivex_move_caps(movement_pos);
            
        }
    }
#endif


}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_pen_event_handler
 * DESCRIPTION
 *  init key handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_init_pen_event_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    ClearInputEventHandler(MMI_DEVICE_PEN);
    /* config high precise */
     mmi_pen_config_sampling_period(MMI_PEN_SAMPLING_PERIOD_2, MMI_PEN_SAMPLING_PERIOD_2);
    /* register pen down/up/move event */
    wgui_register_pen_down_handler(mmi_ivex_pen_down_hdlr);
    wgui_register_pen_up_handler(mmi_ivex_pen_up_hdlr);
    #ifdef __MTK_TARGET__
    wgui_register_pen_abort_handler(mmi_ivex_pen_abort_hdlr);
    #endif
    wgui_register_pen_move_handler(mmi_ivex_pen_move_hdlr);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_curr_img_switch_axis_orien
 * DESCRIPTION
 *  get which axis that current image swiching will following
 * PARAMETERS
 *
 * RETURNS
 *  the axis of view layer
 *****************************************************************************/
U8 mmi_ivex_get_curr_img_switch_axis_orien(U8 ui_angle, U8 view_angle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 orien_axis = MMI_IVEX_SWITCH_AXIS_X;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(ui_angle)
    {
        case GDI_LCD_LAYER_ROTATE_0:
            switch(view_angle)
            {
                case GDI_LCD_LAYER_ROTATE_90:
                case GDI_LCD_LAYER_ROTATE_270:
                    orien_axis = MMI_IVEX_SWITCH_AXIS_Y;
                    break;
                default:
                    orien_axis = MMI_IVEX_SWITCH_AXIS_X;
            }
            break;
        case GDI_LCD_LAYER_ROTATE_90:
            switch(view_angle)
            {
                case GDI_LCD_LAYER_ROTATE_0:
                case GDI_LCD_LAYER_ROTATE_180:
                    orien_axis = MMI_IVEX_SWITCH_AXIS_Y;
                    break;
                default:
                    orien_axis = MMI_IVEX_SWITCH_AXIS_X;
            }
            break;
        case GDI_LCD_LAYER_ROTATE_180:
        case GDI_LCD_LAYER_ROTATE_270:
        default:
            ASSERT(0);
    }
    return orien_axis;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_layer_mvoe_orient_sign
 * DESCRIPTION
 *  Get the move absolute distance
 * PARAMETERS
 *
 * RETURNS
 *  distance by pixel unit
 *****************************************************************************/
S16 mmi_ivex_get_layer_mvoe_orient_sign(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 axis;
    S16 sign = 1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    axis = mmi_ivex_get_curr_img_switch_axis_orien(g_ivex_cntx.ui_display_rotate, g_ivex_cntx.view_image_rotate);
    switch (axis)
    {
        case MMI_IVEX_SWITCH_AXIS_X:
            if (g_ivex_cntx.ui_display_rotate == g_ivex_cntx.view_image_rotate)
            {
                sign = 1;
            }
            else
            {
                sign = -1;
            }
            break;
        case MMI_IVEX_SWITCH_AXIS_Y:
            switch (g_ivex_cntx.ui_display_rotate)
            {
                case GDI_LCD_LAYER_ROTATE_0:
                    switch (g_ivex_cntx.view_image_rotate)
                    {
                        case GDI_LCD_LAYER_ROTATE_90:
                            sign = -1;
                            break;
                        case GDI_LCD_LAYER_ROTATE_270:
                            sign = +1;
                            break;
                        default:
                            MMI_ASSERT(0);
                    }
                    break;
                case GDI_LCD_LAYER_ROTATE_90:
                    switch (g_ivex_cntx.view_image_rotate)
                    {
                        case GDI_LCD_LAYER_ROTATE_0:
                            sign = +1;
                            break;
                        case GDI_LCD_LAYER_ROTATE_180:
                            sign = -1;
                            break;
                        default:
                            MMI_ASSERT(0);
                    }
                    break;
                default:
                    MMI_ASSERT(0);
            }
            break;
        default:
            break;
    }

    return sign;
}

#ifdef __MMI_TOUCH_SCREEN__

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_convert_view_layer_offset_to_abs_axis_distance
 * DESCRIPTION
 *  Get the move absolute distance
 * PARAMETERS
 *  
 * RETURNS
 *  distance by pixel unit
 *****************************************************************************/
S32 mmi_ivex_convert_view_layer_offset_to_abs_axis_distance(S32 layer_offset)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 abs_axis_dis = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        switch (g_ivex_cntx.view_image_rotate)
        {
            case GDI_LCD_LAYER_ROTATE_0:
            case GDI_LCD_LAYER_ROTATE_270:
                abs_axis_dis = layer_offset;
                break;
            case GDI_LCD_LAYER_ROTATE_90:
            case GDI_LCD_LAYER_ROTATE_180:
                abs_axis_dis = -layer_offset;
                break;
            default:
                break;
        }
    }

    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        switch (g_ivex_cntx.view_image_rotate)
        {
            case GDI_LCD_LAYER_ROTATE_0:
            case GDI_LCD_LAYER_ROTATE_90:
                abs_axis_dis = layer_offset;
                break;
            case GDI_LCD_LAYER_ROTATE_180:
            case GDI_LCD_LAYER_ROTATE_270:
                abs_axis_dis = -layer_offset;
                break;
            default:
                break;
        }
    }

    return abs_axis_dis;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_changed_view_switch_distance
 * DESCRIPTION
 *  Get the move absolute distance
 * PARAMETERS
 *
 * RETURNS
 *  distance by pixel unit
 *****************************************************************************/
void mmi_ivex_get_changed_view_switch_distance(S32 abs_axis_dis, S32 abs_axis_move, S32* layer_offset)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 sign;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (abs_axis_dis * (*layer_offset) == 0)
    {
        sign = mmi_ivex_get_layer_mvoe_orient_sign();
        *layer_offset += sign * abs_axis_move;
    }
    else if (abs_axis_dis * (*layer_offset) > 0)
    {
        *layer_offset += abs_axis_move;
    }
    else
    {
        *layer_offset -= abs_axis_move;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_view_switch_distance
 * DESCRIPTION
 *  Get the move absolute distance
 * PARAMETERS
 *
 * RETURNS
 *  distance by pixel unit
 *****************************************************************************/
S32 mmi_ivex_get_view_switch_distance(U8 ui_angle, U8 view_angle, S32 distance_x, S32 distance_y, MMI_BOOL is_abs)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 orien_axis;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    orien_axis = mmi_ivex_get_curr_img_switch_axis_orien(ui_angle, view_angle);
    if (orien_axis == MMI_IVEX_SWITCH_AXIS_X)
    {
        if (is_abs)
        {
            return abs(distance_x);
        }
        else
        {
            return distance_x;
        }
    }
    else
    {
        if (is_abs)
        {
            return abs(distance_y);
        }
        else
        {
            return distance_y;
        }
    }
}

#endif /* __MMI_TOUCH_SCREEN__ */

#define MMI_IVEX_OSD_MGR
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_reset_app
 * DESCRIPTION
 *  This function reset flags used by ivex.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_reset_app(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_RESET_APP,g_ivex_cntx.view_one_from_other_app);
    g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_SHOW;
    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
    g_ivex_cntx.pre_image_state = MMI_IVEX_IMAGE_STATE_STILL;
    g_ivex_cntx.is_move_two = MMI_FALSE;
    /* init view and switch layer dimension */
    if (g_ivex_cntx.view_image_rotate == 0)
    {
        g_ivex_cntx.view_layer_height = LCD_HEIGHT;
        g_ivex_cntx.view_layer_width = LCD_WIDTH;
    }
    else
    {
        /* camcorder maybe view at horizon when entry */
        g_ivex_cntx.view_layer_height = LCD_WIDTH;
        g_ivex_cntx.view_layer_width = LCD_HEIGHT;
    }
    g_ivex_cntx.switch_layer_height= LCD_HEIGHT;
    g_ivex_cntx.switch_layer_width = LCD_WIDTH;
    g_ivex_cntx.osd_fade_percent = 100;
    g_ivex_cntx.is_play_start = MMI_FALSE;
#ifdef __MMI_IMGVIEWEX_MAV_MOTION__
    g_ivex_cntx.mav_motion_is_enabled = MMI_FALSE;
    g_ivex_cntx.mav_motion_angle_x = -1;
    g_ivex_cntx.mav_motion_angle_y = -1;
    g_ivex_cntx.mav_motion_angle_z = -1;
    g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NONE;
    g_ivex_cntx.mav_motion_pulse_started = MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_draw_icon_item
 * DESCRIPTION
 *  This function is called to get the specified icon info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_ivex_osd_draw_icon_item(gdi_handle des_layer_hdlr, gdi_handle src_layer_hdlr, ivex_osd_icon_struct *item, U16 img_icon_up, U16 img_icon_down)
{
#if defined(__MMI_FTE_SUPPORT__)

    {
        U16 icon_id = img_icon_up;
        S32 offx, offy;

        offx = item->offset_x;
        offy = item->offset_y;
        if(IMG_ID_IVEX_LSK_UP_P <= img_icon_up){ /* draw softkey */
            if(item->is_press == MMI_TRUE){
                icon_id = img_icon_down;
            }
        }else{ /* draw panel icon */
            U16 bg_id;
            S32 w, h;

            if(g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0){
                bg_id = IMG_ID_IVEX_BTN_BG;
            }else{
                bg_id = IMG_ID_IVEX_BTN_BG_H;
            }
            if(item->is_press == MMI_TRUE){
              bg_id++;   
            }
            gdi_layer_push_and_set_active(des_layer_hdlr);
            gdi_push_and_set_alpha_blending_source_layer(src_layer_hdlr);
            gdi_image_draw_resized_id(item->offset_x, item->offset_y, item->width, item->height, bg_id);
            gdi_pop_and_restore_alpha_blending_source_layer();
            gdi_layer_pop_and_restore_active();

            gdi_image_get_dimension_id((U16)(icon_id), &w, &h);
            offx = item->offset_x + ((item->width - w)>>1);
            offy = item->offset_y + ((item->height - h)>>1);
        }

        mmi_ivex_draw_alpha_bmp_id_nb_concurrent(des_layer_hdlr, offx, offy, src_layer_hdlr, icon_id);
        
    }
#else
    if (item->is_press == MMI_FALSE)
    {
        mmi_ivex_draw_alpha_bmp_id_nb_concurrent(des_layer_hdlr, item->offset_x, item->offset_y, src_layer_hdlr, img_icon_up);
    }
    else
    {
        mmi_ivex_draw_alpha_bmp_id_nb_concurrent(des_layer_hdlr, item->offset_x, item->offset_y, src_layer_hdlr, img_icon_down);
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_panel_draw_bg
 * DESCRIPTION
 *  This function is called to draw background image.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_panel_draw_bg(gdi_handle des_layer_hdlr, gdi_handle src_layer_hdlr, ivex_osd_icon_struct *item, U16 img_icon)
{
#if defined(__MMI_FTE_SUPPORT__)
    /* draw 9 slice */
    gdi_layer_push_and_set_active(des_layer_hdlr);
    gdi_image_draw_resized_id(item->offset_x, item->offset_y, item->width, item->height, img_icon);
    gdi_layer_pop_and_restore_active();

#else
    mmi_ivex_draw_alpha_bmp_id_nb_concurrent(des_layer_hdlr, item->offset_x, item->offset_y, src_layer_hdlr, img_icon);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_panel_draw_disable_icon
 * DESCRIPTION
 *  This function is called to draw icon.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_panel_draw_disable_icon(gdi_handle des_layer_hdlr, gdi_handle src_layer_hdlr, ivex_osd_icon_struct *item, U16 img_icon_disable)
{
#if defined(__MMI_FTE_SUPPORT__)

    {
        U16 bg_id;
        S32 w, h, offx, offy;

        if(g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0){
            bg_id = IMG_ID_IVEX_BTN_BG;
        }else{
            bg_id = IMG_ID_IVEX_BTN_BG_H;
        }
        gdi_layer_push_and_set_active(des_layer_hdlr);
        gdi_push_and_set_alpha_blending_source_layer(src_layer_hdlr);
        gdi_image_draw_resized_id(item->offset_x, item->offset_y, item->width, item->height, bg_id);
        gdi_pop_and_restore_alpha_blending_source_layer();
        gdi_layer_pop_and_restore_active();

        gdi_image_get_dimension_id((U16)(img_icon_disable), &w, &h);
        offx = item->offset_x + ((item->width - w)>>1);
        offy = item->offset_y + ((item->height - h)>>1);
        mmi_ivex_draw_alpha_bmp_id_nb_concurrent(des_layer_hdlr, offx, offy, src_layer_hdlr, img_icon_disable);
     }   
#else
    mmi_ivex_draw_alpha_bmp_id_nb_concurrent(des_layer_hdlr, item->offset_x, item->offset_y, src_layer_hdlr, img_icon_disable);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_set_icon_item_info
 * DESCRIPTION
 *  This function is called to get the specified icon info.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_set_icon_item_info(ivex_osd_icon_struct *item, U16 img_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_FTE_SUPPORT__)
    if(img_id >= IMG_ID_IVEX_LSK_UP_P)
    {
        gdi_image_get_dimension_id((U16)(img_id), &(item->width), &(item->height));
    }

#else
    gdi_image_get_dimension_id((U16)(img_id), &(item->width), &(item->height));

#endif
    item->is_press = MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_init_osd_icon_info
 * DESCRIPTION
 *  This function is called to initilize osd icon positions.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_init_osd_icon_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layout_struct  *active_ivex_osd_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    gdi_image_get_dimension_id((U16)(IMG_ID_IVEX_HINT_LOADING_0), &(g_ivex_osd_cntx_0.loading_hint.width), &(g_ivex_osd_cntx_0.loading_hint.height));
    g_ivex_osd_cntx_270.loading_hint.width = g_ivex_osd_cntx_0.loading_hint.width;
    g_ivex_osd_cntx_270.loading_hint.height = g_ivex_osd_cntx_0.loading_hint.height;
    g_ivex_osd_cntx_0.loading_hint.offset_x = (LCD_WIDTH - g_ivex_osd_cntx_0.loading_hint.width) /2;
    g_ivex_osd_cntx_0.loading_hint.offset_y = (LCD_HEIGHT - g_ivex_osd_cntx_0.loading_hint.height) /2;
    g_ivex_osd_cntx_270.loading_hint.offset_x = (LCD_HEIGHT - g_ivex_osd_cntx_270.loading_hint.width) /2;
    g_ivex_osd_cntx_270.loading_hint.offset_y = (LCD_WIDTH - g_ivex_osd_cntx_270.loading_hint.height) /2;
    active_ivex_osd_ptr = &g_ivex_osd_cntx_0;
    /* rember the icon drawn on view layer position */
    lock_drm_hint[0] = g_ivex_osd_cntx_0.drm_hint;
    lock_error_hint[0] = g_ivex_osd_cntx_0.error_hint;
    lock_loading_hint[0] = g_ivex_osd_cntx_0.loading_hint;

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->panel_shadow, IMG_ID_IVEX_PANEL_SHADOW_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->panel_bg, IMG_ID_IVEX_PANEL_BG_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->sk_bg, IMG_ID_IVEX_SK_BG_P);

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->zoomin, IMG_ID_IVEX_ZOOMIN_UP_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->zoomout, IMG_ID_IVEX_ZOOMOUT_UP_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->cwr, IMG_ID_IVEX_CWR_UP_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->ccwr, IMG_ID_IVEX_CCWR_UP_P);

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->lsk, IMG_ID_IVEX_LSK_UP_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->rsk, IMG_ID_IVEX_RSK_UP_P);

    if (!MMI_IVEX_LANDSCAPE)
    {
    #ifdef __MMI_IMGVIEWEX_MOTION__
        #ifdef DEBUGE_IVEX_UI_ROTATE
        mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_P);
        #else
        mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_PLAY_UP_P);
        #endif
    #else
        mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_P);
    #endif
    }
    else
    {
        mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_PLAY_UP_P);
    }

    /* these icons will not draw on osd, it will draw on display layer */
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->drm_hint, IMG_ID_IVEX_HINT_DRM);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->error_hint, IMG_ID_IVEX_HINT_FILE_ERR);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->loading_hint, IMG_ID_IVEX_HINT_LOADING_0);

    active_ivex_osd_ptr = &g_ivex_osd_cntx_270;
    /* rember the icon drawn on view layer position */
    lock_drm_hint[1] = g_ivex_osd_cntx_270.drm_hint;
    lock_error_hint[1] = g_ivex_osd_cntx_270.error_hint;
    lock_loading_hint[1] = g_ivex_osd_cntx_270.loading_hint;

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->panel_shadow, IMG_ID_IVEX_PANEL_SHADOW_H);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->panel_bg, IMG_ID_IVEX_PANEL_BG_H);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->sk_bg, IMG_ID_IVEX_SK_BG_H);

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->zoomin, IMG_ID_IVEX_ZOOMIN_UP_H);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->zoomout, IMG_ID_IVEX_ZOOMOUT_UP_H);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->cwr, IMG_ID_IVEX_CWR_UP_H);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->ccwr, IMG_ID_IVEX_CCWR_UP_H);

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->lsk, IMG_ID_IVEX_LSK_UP_P);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->rsk, IMG_ID_IVEX_RSK_UP_P);

#ifdef __MMI_IMGVIEWEX_MOTION__
    #ifdef DEBUGE_IVEX_UI_ROTATE
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_H);
    #else
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_PLAY_UP_P);
    #endif
#else
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_H);
#endif

    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->drm_hint, IMG_ID_IVEX_HINT_DRM);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->error_hint, IMG_ID_IVEX_HINT_FILE_ERR);
    mmi_ivex_osd_set_icon_item_info(&active_ivex_osd_ptr->loading_hint, IMG_ID_IVEX_HINT_LOADING_0);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_active_osd_cntx
 * DESCRIPTION
 *  This function is called to set ivex active osd cntx.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_get_active_osd_cntx(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* layer rotate 90 (cw) equals lcd rotate 270 (ccw) */
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        g_ivex_cntx.active_osd_layout_ptr = &g_ivex_osd_cntx_270;
    }
    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        g_ivex_cntx.active_osd_layout_ptr = &g_ivex_osd_cntx_0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_construct_title_strings
 * DESCRIPTION
 *  construct title strings
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_construct_title_strings(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    CHAR   buffer[30];  /* for xxxx/xxxx */
    WCHAR* name_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset((void*)g_ivex_cntx.title_str, 0, SRV_FMGR_PATH_BUFFER_SIZE);
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_FILENAME])
    {
        mmi_ucs2cat(g_ivex_cntx.title_str, (const CHAR*)(L" "));
        name_ptr = srv_fmgr_path_get_filename_ptr((WCHAR*)g_ivex_cntx.image_info.filepath);
        mmi_ucs2cat(g_ivex_cntx.title_str, (CHAR*)name_ptr);
        srv_fmgr_path_hide_extension((WCHAR*)(g_ivex_cntx.title_str));
    }
    else if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_TITLE])
    {
        /* Need parent prepare, so need provide a cui API for cui user */
        mmi_ucs2cpy(g_ivex_cntx.title_str, g_imgview_cui_ptr->title_confing.title_string);
    }
    else if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_COUNTER])
    {
        if (!g_ivex_cntx.view_from_fmgr)// && MMI_FALSE)
        {
            /* prepare xxxx/xxxx string */
            sprintf(buffer, "%d/%d", (U16) g_imgview_fl_idx + 1, (U16) g_ivex_cntx.total_image_count);
            mmi_asc_to_ucs2(g_ivex_cntx.title_str, buffer);
           /* end of prepare xxxx/xxxx string */
        }
    }
    else
    {
        /* Draw nothing on title area */
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_truncated_style_text
 * DESCRIPTION
 *  This function is called to draw style text.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_truncated_style_text(CHAR *str, S32 offset_x, S32 offset_y, S32 width, MMI_BOOL is_truncated)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (r2lMMIFlag)
    {
        if (is_truncated)
        {
            offset_x += g_ivex_cntx.active_osd_layout_ptr->title_string.width;
        }
        else
        {
            offset_x += gui_get_string_width((UI_string_type) str);
        }
    }

    gdi_push_and_set_alpha_blending_source_layer(g_ivex_cntx.osd_title_layer);
    gui_move_text_cursor(offset_x, offset_y);
    gui_set_text_color(gui_color(255, 255, 255));
    gui_set_text_border_color(gui_color(0, 0, 0));
    if (is_truncated == MMI_TRUE)
    {
        gui_print_truncated_borderd_text(offset_x, offset_y, width, (UI_string_type) str);
    }
    else
    {
        gui_print_bordered_text((UI_string_type) str);
    }
    gdi_pop_and_restore_alpha_blending_source_layer();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_osd_title_layer
 * DESCRIPTION
 *  draw index and file name
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_osd_title_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 str_width, str_height;
    S32 offset_x;
    MMI_BOOL is_truncated;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* CUI control part, user can reset it */
    if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_FILENAME] == MMI_FALSE &&
        g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_COUNTER] == MMI_FALSE &&
        g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_TITLE] == MMI_FALSE)
    {
        return;
    }

#if defined(__IMAGE_VIEWER_EX_MEM_SLIM__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
    /* Don't draw title */
    return;
#endif

    mmi_ivex_construct_title_strings();
    gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_TITLE));
    gui_measure_string((UI_string_type) g_ivex_cntx.title_str, &str_width, &str_height);

    gdi_layer_push_and_set_active(g_ivex_cntx.osd_title_layer);
    gdi_draw_solid_rect(g_ivex_cntx.active_osd_layout_ptr->title_string.offset_x,
                        g_ivex_cntx.active_osd_layout_ptr->title_string.offset_y,
                        g_ivex_cntx.active_osd_layout_ptr->title_string.offset_x+g_ivex_cntx.active_osd_layout_ptr->title_string.width,
                        g_ivex_cntx.active_osd_layout_ptr->title_string.offset_y+g_ivex_cntx.active_osd_layout_ptr->title_string.height,
                        GDI_COLOR_TRANSPARENT);

    if ( str_width > g_ivex_cntx.active_osd_layout_ptr->title_string.width )
    {
        offset_x = g_ivex_cntx.active_osd_layout_ptr->title_string.offset_x;
        is_truncated = MMI_TRUE;
    }
    else
    {
        offset_x = g_ivex_cntx.active_osd_layout_ptr->title_string.offset_x + ((g_ivex_cntx.active_osd_layout_ptr->title_string.width - str_width)>>1);
        is_truncated = MMI_FALSE;
    }

    mmi_ivex_draw_truncated_style_text(
        g_ivex_cntx.title_str,
        offset_x,
        g_ivex_cntx.active_osd_layout_ptr->title_string.offset_y + 1,
        g_ivex_cntx.active_osd_layout_ptr->title_string.width,
        is_truncated);
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_osd_panel_layer
 * DESCRIPTION
 *  This function is called to draw osd.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_osd_panel_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle des_hdlr;
    cui_imgview_lskicon_event_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    des_hdlr = g_ivex_cntx.osd_panel_layer;

    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        gdi_push_and_set_alpha_blending_source_layer(GDI_LAYER_EMPTY_HANDLE);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (mmi_ivex_should_show_sliding_bar())
        {
            /* clear background for sliding bar */
            gdi_layer_push_and_set_active(des_hdlr);
            gdi_draw_solid_rect(0, 0, MMI_IVEX_OSD_SLIDING_BAR_LAYER_WIDTH_0-1, MMI_IVEX_OSD_SLIDING_BAR_LAYER_HEIGHT_0-1, GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->sk_bg, IMG_ID_IVEX_SK_BG_P);
        }
        else
        {
#endif
#if !defined(__MMI_FTE_SUPPORT__)
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->panel_shadow, IMG_ID_IVEX_PANEL_SHADOW_P);
#endif
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->panel_bg, IMG_ID_IVEX_PANEL_BG_P);
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->sk_bg, IMG_ID_IVEX_SK_BG_P);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        }
#endif
        gdi_pop_and_restore_alpha_blending_source_layer();
        /* CUI control part, user can reset it */
        if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_OPTION] == MMI_FALSE)
        {
            /* Do not draw or draw grey icon, or draw select icon etc */
            if (g_imgview_cui_ptr->lsk_setting.is_customized)
            {
                if (mmi_ivex_lsk_custmize_is_enable())
                {
                    evt.evt_id = EVT_ID_IMGVIEW_GET_LSK_ICON;
                    evt.sender_id = g_ivex_cui_gid;
                    evt.size = sizeof(cui_imgview_lskicon_event_struct);
                    evt.icon_id = 0;
                    evt.type = g_ivex_cntx.active_osd_layout_ptr->lsk.is_press ? IMGVIEW_ICON_PRESS : IMGVIEW_ICON_NORMAL;
                    evt.ui_rotate = GDI_LCD_LAYER_ROTATE_0;
                    if(mmi_frm_group_send_to_parent(g_ivex_cui_gid, (mmi_group_event_struct*)(&evt))== 1){
                        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->lsk, evt.icon_id, evt.icon_id);
                    }
                    
                }
                else
                {
                    /* Draw grey */
                }
            }
            else
            {
                /* Draw nothing */
            }
        }
        else
        {
            mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->lsk, IMG_ID_IVEX_LSK_UP_P, IMG_ID_IVEX_LSK_DOWN_P);
        }
        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->rsk, IMG_ID_IVEX_RSK_UP_P, IMG_ID_IVEX_RSK_DOWN_P);
        if (MMI_IVEX_LANDSCAPE)
        {
            /* CUI control part, user can reset it */
            if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_SLIDESHOW] == MMI_FALSE)
            {
                /* Do not draw or draw grey icon */;
            }
            else
            {
                if (g_ivex_cntx.total_image_count > 1 &&
                    g_ivex_cntx.view_from_fmgr == MMI_FALSE)
                {
                    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                    {
                        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_STOP_UP_P, IMG_ID_IVEX_CSK_STOP_DOWN_P);
                    }
                    else
                    {
                        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_PLAY_UP_P, IMG_ID_IVEX_CSK_PLAY_DOWN_P);
                    }
                }
            }
        }
        else
        {
        #ifdef __MMI_IMGVIEWEX_MOTION__
            #ifdef DEBUGE_IVEX_UI_ROTATE
            /* CUI control part, user can reset it */
            if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_UI_ROTATE] == MMI_FALSE)
            {
                /* Do not draw or draw grey icon */;
            }
            else
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_P, IMG_ID_IVEX_CSK_ROTATE_DOWN_P);
            }
            #else
            /* CUI control part, user can reset it */
            if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_SLIDESHOW] == MMI_FALSE)
            {
                /* Do not draw or draw grey icon */;
            }
            else
            {
                if (g_ivex_cntx.total_image_count > 1 &&
                    g_ivex_cntx.view_from_fmgr == MMI_FALSE)
                {
                    if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                    {
                        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_STOP_UP_P, IMG_ID_IVEX_CSK_STOP_DOWN_P);
                    }
                    else
                    {
                        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_PLAY_UP_P, IMG_ID_IVEX_CSK_PLAY_DOWN_P);
                    }
                }
            }
            #endif
        #else
            /* CUI control part, user can reset it */
            if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_UI_ROTATE] == MMI_FALSE)
            {
                /* Do not draw or draw grey icon */;
            }
            else
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_P, IMG_ID_IVEX_CSK_ROTATE_DOWN_P);
            }
        #endif
        }

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (!mmi_ivex_should_show_sliding_bar())
        {
#endif
            if (mmi_ivex_rotate_is_valid())
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->ccwr, IMG_ID_IVEX_CCWR_UP_P, IMG_ID_IVEX_CCWR_DOWN_P);
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->cwr, IMG_ID_IVEX_CWR_UP_P, IMG_ID_IVEX_CWR_DOWN_P);
            }
            else
            {
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->ccwr, IMG_ID_IVEX_CCWR_DISABLE_P);
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->cwr, IMG_ID_IVEX_CWR_DISABLE_P);
            }

            if (g_ivex_cntx.image_info.is_zoomin_able == MMI_FALSE || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
            {
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomin, IMG_ID_IVEX_ZOOMIN_DISABLE_P);
            }
            else
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomin, IMG_ID_IVEX_ZOOMIN_UP_P, IMG_ID_IVEX_ZOOMIN_DOWN_P);
            }
            if (g_ivex_cntx.image_info.is_zoomout_able == MMI_FALSE || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
            {
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomout, IMG_ID_IVEX_ZOOMOUT_DISABLE_P);
            }
            else
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomout, IMG_ID_IVEX_ZOOMOUT_UP_P, IMG_ID_IVEX_ZOOMOUT_DOWN_P);
            }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        }
#endif
    }
    else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        gdi_push_and_set_alpha_blending_source_layer(GDI_LAYER_EMPTY_HANDLE);
        
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (mmi_ivex_should_show_sliding_bar())
        {
            /* clear background for sliding bar */
            gdi_layer_push_and_set_active(des_hdlr);
            gdi_draw_solid_rect(0, 0, MMI_IVEX_OSD_SLIDING_BAR_LAYER_HEIGHT_270-1, MMI_IVEX_OSD_SLIDING_BAR_LAYER_WIDTH_270-1, GDI_COLOR_TRANSPARENT);
            gdi_layer_pop_and_restore_active();
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->sk_bg, IMG_ID_IVEX_SK_BG_H);
        }
        else
        {
#endif
#if !defined(__MMI_FTE_SUPPORT__)
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->panel_shadow, IMG_ID_IVEX_PANEL_SHADOW_H);
#endif
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->panel_bg, IMG_ID_IVEX_PANEL_BG_H);
            mmi_ivex_osd_panel_draw_bg(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->sk_bg, IMG_ID_IVEX_SK_BG_H);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        }
#endif
        gdi_pop_and_restore_alpha_blending_source_layer();

        /* CUI control part, user can reset it */
        if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_OPTION] == MMI_FALSE)
        {
            /* Do not draw or draw grey icon, or draw select icon etc */
            if (g_imgview_cui_ptr->lsk_setting.is_customized)
            {
                if (mmi_ivex_lsk_custmize_is_enable())
                {
                    evt.evt_id = EVT_ID_IMGVIEW_GET_LSK_ICON;
                    evt.sender_id = g_ivex_cui_gid;
                    evt.size = sizeof(cui_imgview_lskicon_event_struct);
                    evt.icon_id = 0;
                    evt.type = g_ivex_cntx.active_osd_layout_ptr->lsk.is_press ? IMGVIEW_ICON_PRESS : IMGVIEW_ICON_NORMAL;
                    evt.ui_rotate = GDI_LCD_LAYER_ROTATE_90;
                    if(mmi_frm_group_send_to_parent(g_ivex_cui_gid, (mmi_group_event_struct*)(&evt))== 1){
                        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->lsk, evt.icon_id, evt.icon_id);
                    }
                }
                else
                {
                    /* Draw grey */
                }
            }
            else
            {
                /* Draw nothing */
            }
        }
        else
        {
            mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->lsk, IMG_ID_IVEX_LSK_UP_H, IMG_ID_IVEX_LSK_DOWN_H);
        }
        mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->rsk, IMG_ID_IVEX_RSK_UP_H, IMG_ID_IVEX_RSK_DOWN_H);
    #ifdef __MMI_IMGVIEWEX_MOTION__
        #ifdef DEBUGE_IVEX_UI_ROTATE
        /* CUI control part, user can reset it */
        if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_UI_ROTATE] == MMI_FALSE)
        {
            /* Do not draw or draw grey icon */;
        }
        else
        {
            mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_H, IMG_ID_IVEX_CSK_ROTATE_DOWN_H);
        }
        #else
        /* CUI control part, user can reset it */
        if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_SLIDESHOW] == MMI_FALSE)
        {
            /* Do not draw or draw grey icon */;
        }
        else
        {
            if (g_ivex_cntx.total_image_count > 1 &&
                g_ivex_cntx.view_from_fmgr == MMI_FALSE)
            {
                if (g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_PLAY)
                {
                    mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_STOP_UP_H, IMG_ID_IVEX_CSK_STOP_DOWN_H);
                }
                else
                {
                    mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_PLAY_UP_H, IMG_ID_IVEX_CSK_PLAY_DOWN_H);
                }
            }
        }
        #endif
    #else
        /* CUI control part, user can reset it */
        if (g_imgview_cui_ptr->cap_enable[CUI_IMGVIEW_CAP_UI_ROTATE] == MMI_FALSE)
        {
            /* Do not draw or draw grey icon */;
        }
        else
        {
            mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->csk, IMG_ID_IVEX_CSK_ROTATE_UP_H, IMG_ID_IVEX_CSK_ROTATE_DOWN_H);
        }
    #endif
    
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        if (!mmi_ivex_should_show_sliding_bar())
        {
#endif
            if (mmi_ivex_rotate_is_valid())
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->ccwr, IMG_ID_IVEX_CCWR_UP_H, IMG_ID_IVEX_CCWR_DOWN_H);
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->cwr, IMG_ID_IVEX_CWR_UP_H, IMG_ID_IVEX_CWR_DOWN_H);
            }
            else
            {
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->ccwr, IMG_ID_IVEX_CCWR_DISABLE_H);
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->cwr, IMG_ID_IVEX_CWR_DISABLE_H);
            }

            if (g_ivex_cntx.image_info.is_zoomin_able == MMI_FALSE || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
            {
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomin, IMG_ID_IVEX_ZOOMIN_DISABLE_H);
            }
            else
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomin, IMG_ID_IVEX_ZOOMIN_UP_H, IMG_ID_IVEX_ZOOMIN_DOWN_H);
            }
            if (g_ivex_cntx.image_info.is_zoomout_able == MMI_FALSE || g_ivex_cntx.image_info.is_loading == MMI_TRUE)
            {
                mmi_ivex_osd_panel_draw_disable_icon(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomout, IMG_ID_IVEX_ZOOMOUT_DISABLE_H);
            }
            else
            {
                mmi_ivex_osd_draw_icon_item(des_hdlr, des_hdlr, &g_ivex_cntx.active_osd_layout_ptr->zoomout, IMG_ID_IVEX_ZOOMOUT_UP_H, IMG_ID_IVEX_ZOOMOUT_DOWN_H);
            }
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
        }
#endif
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_display_error_sg
 * DESCRIPTION
 *  This function shows display popup.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_display_error_sg(mmi_id parent_gid, UI_string_type str_ptr, mmi_event_notify_enum event, U16 rotate, mmi_imgview_popup_result_process_enum process)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_screen_rotate_enum lcd_rotate = MMI_FRM_SCREEN_ROTATE_0;
    mmi_popup_property_struct arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* IVEX ui use layer rotate */
    mmi_popup_property_init(&arg);

#if defined(__MMI_SCREEN_ROTATE__)
    if (rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        lcd_rotate = MMI_FRM_SCREEN_ROTATE_270;
    }
#endif

    if (parent_gid == GRP_ID_INVALID)
    {
        arg.parent_id = GRP_ID_ROOT;
    }
    else
    {
        arg.parent_id = parent_gid;
        arg.user_tag = (void*)process;
    }

    arg.rotation = lcd_rotate;

    mmi_popup_display((WCHAR*)str_ptr, event, &arg);
}


#if defined(__DRM_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_drm_consume_rights
 * DESCRIPTION
 *  deal with start consume or resume.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_drm_consume_rights(ivex_image_info_struct* img_info, MMI_BOOL is_resume)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (img_info->is_drm)
    {
        if (!is_resume || (is_resume && img_info->need_drm_right))
        {
            mmi_ivex_start_drm_consume(img_info);
        }
        else
        {
            mmi_ivex_resume_drm_consume(img_info, is_resume);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_drm_consume
 * DESCRIPTION
 *  start consume DRM right when the whole image is shown on screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_drm_consume(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(img_info->drm_state == MMI_IVEX_DRM_STATE_EXIT);

    if ((img_info->drm_handle = DRM_open_file((kal_wchar*) img_info->filepath, FS_READ_ONLY, DRM_PERMISSION_DISPLAY)) >= FS_NO_ERROR)
    {
        img_info->drm_id
            = DRM_consume_rights(img_info->drm_handle, DRM_PERMISSION_DISPLAY, mmi_ivex_drm_callback_hdlr);
        DRM_close_file(img_info->drm_handle);
        img_info->need_drm_right = MMI_FALSE;
        img_info->drm_state = MMI_IVEX_DRM_STATE_CONSUME;
        img_info->result = MMI_IVEX_IMG_HEALTH_OK;
    }
    img_info->drm_handle = -1;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_pause_drm_consume
 * DESCRIPTION
 *  pause consume DRM right when interrupting
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_pause_drm_consume(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(img_info->drm_state == MMI_IVEX_DRM_STATE_CONSUME);
    MMI_ASSERT(img_info->drm_handle == -1);
    DRM_pause_consume(img_info->drm_id);
    img_info->drm_state = MMI_IVEX_DRM_STATE_PAUSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_resume_drm_consume
 * DESCRIPTION
 *  resume consume DRM right when come form history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_resume_drm_consume(ivex_image_info_struct* img_info, MMI_BOOL is_resume)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(img_info->drm_state == MMI_IVEX_DRM_STATE_PAUSE);
    MMI_ASSERT(is_resume == MMI_TRUE);

    /* check print right again */
    if (DRM_get_object_method(-1,(PU16) img_info->filepath) != DRM_METHOD_NONE)
    {
        if (!DRM_validate_permission(-1, (PU16)img_info->filepath, DRM_PERMISSION_DISPLAY))
        {
            img_info->drm_valid &= ~(MMI_IVEX_DRM_RET_DISPLAY_VALID);
        }
    }

    DRM_resume_consume(img_info->drm_id);
    img_info->drm_state = MMI_IVEX_DRM_STATE_CONSUME;
    img_info->result = MMI_IVEX_IMG_HEALTH_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_drm_consume
 * DESCRIPTION
 *  stop consume DRM right when destroy view screen or switch image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_drm_consume(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_ivex_cntx.image_info.drm_handle == -1);

    if ((g_ivex_cntx.image_info.drm_state == MMI_IVEX_DRM_STATE_CONSUME) ||
        (g_ivex_cntx.image_info.drm_state == MMI_IVEX_DRM_STATE_PAUSE))
    {
        DRM_stop_consume(g_ivex_cntx.image_info.drm_id);
        g_ivex_cntx.image_info.drm_id = 0;
        g_ivex_cntx.image_info.drm_state = MMI_IVEX_DRM_STATE_EXIT;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_drm_consume
 * DESCRIPTION
 *  stop consume DRM right when destroy view screen or switch image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_drm_callback_hdlr(kal_int32 result, kal_int32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_ivex_cntx.image_info.drm_id == id);

    if (mmi_frm_scrn_get_active_id() == SCR_ID_IMGVIEW_VIEW)
    {
        mmi_ivex_stop_drm_consume();
        g_ivex_cntx.image_info.result = MMI_IVEX_IMG_HEALTH_DRM_INVALID;
        g_ivex_cntx.image_info.err_str_ptr = GetString(STR_GLOBAL_DRM_PROHIBITED);
        /* re-check if the current image need more right, so deside if need right item will show at option screen */
        g_ivex_cntx.image_info.need_drm_right = MMI_FALSE;
        mmi_ivex_check_file_drm_right(&g_ivex_cntx.image_info);
    }
    else if (mmi_frm_scrn_is_present(g_ivex_cui_gid, SCR_ID_IMGVIEW_VIEW, MMI_FRM_NODE_EXCLUDE_ACTIVE_SCRN_FLAG))
    {
        mmi_ivex_stop_drm_consume();
        g_ivex_cntx.image_info.need_drm_right = MMI_FALSE;
        mmi_ivex_check_file_drm_right(&g_ivex_cntx.image_info);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_check_file_drm_right
 * DESCRIPTION
 *  check file's DRM right
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_check_file_drm_right(ivex_image_info_struct *img_info)
{
    if (img_info->drm_state == MMI_IVEX_DRM_STATE_EXIT)
    {
        img_info->result = MMI_IVEX_IMG_HEALTH_DRM_INVALID;
        img_info->drm_valid = mmi_ivex_process_drm_hdlr(img_info);

        if (img_info->drm_valid & MMI_IVEX_DRM_RET_OTHER_ERROR)
        {
            /* Open file fail */
            img_info->result = MMI_IVEX_IMG_HEALTH_ERROR;
            img_info->err_str_ptr = GetString(srv_fmgr_fs_error_get_string(img_info->drm_handle));
            img_info->err_img_id = IMG_ID_IVEX_HINT_FILE_ERR;
            img_info->drm_handle = -1;
        }
        else if ((img_info->drm_valid & MMI_IVEX_DRM_RET_DRM_FILE) == 0)
        {
            /* not DRM file */
            img_info->result = MMI_IVEX_IMG_HEALTH_OK;
            img_info->drm_valid |= MMI_IVEX_DRM_RET_PRINT_VALID;
            img_info->drm_valid |= MMI_IVEX_DRM_RET_DISPLAY_VALID;
        }
        else if (((MMI_IVEX_DRM_RET_MULTI_PART & img_info->drm_valid)!= 0))
        {
            /* MULTI-PART */
            img_info->result = MMI_IVEX_IMG_HEALTH_DRM_INVALID;
            img_info->err_str_ptr = GetString(STR_ID_IMGVIEW_NOTIFY_MULTIPART_NOT_SUPPORT);
        }
        else if ((MMI_IVEX_DRM_RET_DRM_NEED_RIGHT & img_info->drm_valid) != 0)
        {
            if ((MMI_IVEX_DRM_RET_DISPLAY_VALID & img_info->drm_valid) != 0)
            {
                img_info->result = MMI_IVEX_IMG_HEALTH_OK;
            }
            else
            {
                img_info->result = MMI_IVEX_IMG_HEALTH_DRM_NEED_RIGHT;
            }
            img_info->err_str_ptr = GetString(STR_ID_IMGVIEW_VIEW_DRM_NEED_RIGHT);
            img_info->err_img_id = IMG_ID_IVEX_HINT_DRM;
            img_info->need_drm_right = MMI_TRUE;
        }
        else if ((MMI_IVEX_DRM_RET_OTHER_ERROR & img_info->drm_valid) != 0)
        {
            /* The error from fmgr */
            img_info->result = MMI_IVEX_IMG_HEALTH_ERROR;
        }
        else if ((MMI_IVEX_DRM_RET_DRM_NO_PERMISSION & img_info->drm_valid) != 0)
        {
            /* has not display permission */
            img_info->result = MMI_IVEX_IMG_HEALTH_DRM_INVALID;
            img_info->err_str_ptr = GetString(STR_GLOBAL_DRM_PROHIBITED);
        }
        else
        {
            img_info->result = MMI_IVEX_IMG_HEALTH_OK;
        }
    }
    else if (img_info->drm_state == MMI_IVEX_DRM_STATE_PAUSE)
    {
        /* check print right again */
        if (DRM_get_object_method(-1,(PU16) img_info->filepath) != DRM_METHOD_NONE)
        {
            if (!DRM_validate_permission(-1, (PU16)img_info->filepath, DRM_PERMISSION_PRINT))
            {
                img_info->drm_valid &= ~(MMI_IVEX_DRM_RET_PRINT_VALID);
            }
        }
    }
    else
    {
        /* Do nothing, image rotated also will get image info and to here, so will be consume state, in this time not do nothing */
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_process_drm_hdlr
 * DESCRIPTION
 *  This function check DRM right of the file.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
ivex_drm_ret_enum mmi_ivex_process_drm_hdlr(ivex_image_info_struct *img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_drm_ret_enum ret = MMI_IVEX_DRM_RET_NOT_DRM_FILE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    img_info->is_drm = MMI_FALSE;
    /* check multipart or single part first */

#ifdef __DRM_V02__
    if (srv_fmgr_types_find_type_by_filepath((WCHAR*)img_info->filepath) == FMGR_TYPE_ODF)
    {
        ret = MMI_IVEX_DRM_RET_DRM_FILE;
        ret |= MMI_IVEX_DRM_RET_MULTI_PART;
        img_info->is_drm = MMI_TRUE;
    }
    else
#endif
    {
        if ((img_info->drm_handle = DRM_open_file((PU16) img_info->filepath, FS_READ_ONLY, DRM_PERMISSION_DISPLAY)) >= FS_NO_ERROR)
        {

            if (DRM_get_object_method(img_info->drm_handle, NULL) == DRM_METHOD_NONE)
            {
                ret = MMI_IVEX_DRM_RET_NOT_DRM_FILE;
                DRM_close_file(img_info->drm_handle);
                img_info->drm_handle = -1;
                return ret;
            }

            ret = MMI_IVEX_DRM_RET_DRM_FILE;
            img_info->is_drm = MMI_TRUE;

            DRM_close_file(img_info->drm_handle);
            img_info->drm_handle = -1;

            if (DRM_validate_permission(-1, (kal_wchar *)img_info->filepath, DRM_PERMISSION_PRINT))
                ret |= MMI_IVEX_DRM_RET_PRINT_VALID;

            if (DRM_rights_extendable((kal_wchar *)img_info->filepath))
            {
                ret |= MMI_IVEX_DRM_RET_DRM_NEED_RIGHT;
            }

            if (DRM_validate_permission(-1, (kal_wchar *)img_info->filepath, DRM_PERMISSION_DISPLAY))
            {
                ret |= MMI_IVEX_DRM_RET_DISPLAY_VALID;
            }
            else
            {
                ret |= MMI_IVEX_DRM_RET_DRM_NO_PERMISSION;
            }
        }
        else  /* file open error */
        {
            ret = MMI_IVEX_DRM_RET_OTHER_ERROR;
        }
    }
    return ret;
}
#endif /* __DRM_SUPPORT__ */


#define MMI_IVEX_IMG_OPERATION

/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_calculate_real_zoom_factor
 * DESCRIPTION
 *  Calculate base raised to the power of index
 * PARAMETERS
 *  base    [IN]
 *  index   [IN]
 * RETURNS
 *  Return the value: base raised to the power of index
 *****************************************************************************/
float mmi_ivex_calculate_real_zoom_factor(float base, U16 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    float ret = 1;
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < index; i++)
    {
        ret = ret * base;
    }
    return ret;
}


#define MMI_IVEX_DRAW_EFFECT_ICON
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_switch_loading_effect_cyclic
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_switch_loading_effect_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    TMP_TRACE_TIME("[IVAPP][SWITCH] switch_loading_effect_cyclic entry: %d");
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.switch_layer_handle, GDI_COLOR_BLACK);
    //gui_start_timer(MMI_IVEX_DRAW_LOADING_EFFECT_TIMER_INTERVAL, mmi_ivex_draw_switch_loading_effect_cyclic);
    mmi_ivex_draw_alpha_bmp_id_nb_concurrent(g_ivex_cntx.switch_layer_handle,
        g_ivex_cntx.active_osd_layout_ptr->loading_hint.offset_x,
        g_ivex_cntx.active_osd_layout_ptr->loading_hint.offset_y,
        g_ivex_cntx.switch_layer_handle,
        (U16)(IMG_ID_IVEX_HINT_LOADING_0 + g_ivex_cntx.switch_image_info.loading_hint_index));
    g_ivex_cntx.switch_image_info.loading_hint_index++;
    if(g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_NEXT &&
       g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_PREV){
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
    if (g_ivex_cntx.switch_image_info.loading_hint_index == MMI_IVEX_LOADING_IMAGE_NUMBER)
    {
        g_ivex_cntx.switch_image_info.loading_hint_index = 0;
    }
    TMP_TRACE_TIME("[IVAPP][SWITCH] switch_loading_effect_cyclic exit: %d");
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_switch_loading_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_switch_loading_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_ivex_cntx.switch_image_info.is_loading == KAL_FALSE);
    g_ivex_cntx.switch_image_info.loading_hint_index = 0;
    g_ivex_cntx.switch_image_info.is_loading = MMI_TRUE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_START_SWI_LOADING);
    mmi_ivex_draw_switch_loading_effect_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_switch_loading_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_switch_loading_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_draw_switch_loading_effect_cyclic);
    if(g_ivex_cntx.switch_image_info.is_loading)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_STOP_SWI_LOADING);
        g_ivex_cntx.switch_image_info.is_loading = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_current_loading_effect_cyclic
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_current_loading_effect_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* this case is for rotate view layer under loading, other for switch case of different oriention between view layer and switch layer */
    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90 ||
        g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
    {
        index = 1;
    }
    gdi_layer_clear_nb_concurrent(g_ivex_cntx.display_layer_handle, GDI_COLOR_BLACK);
    gui_start_timer(MMI_IVEX_DRAW_LOADING_EFFECT_TIMER_INTERVAL, mmi_ivex_draw_current_loading_effect_cyclic);
    mmi_ivex_draw_alpha_bmp_id_nb_concurrent(g_ivex_cntx.display_layer_handle,
        lock_loading_hint[index].offset_x,
        lock_loading_hint[index].offset_y,
        g_ivex_cntx.display_layer_handle,
        (U16)(IMG_ID_IVEX_HINT_LOADING_0 + g_ivex_cntx.image_info.loading_hint_index));
    g_ivex_cntx.image_info.loading_hint_index++;
    if(g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_NEXT &&
       g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_SWITCH_PREV){
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
    if (g_ivex_cntx.image_info.loading_hint_index == MMI_IVEX_LOADING_IMAGE_NUMBER)
    {
        g_ivex_cntx.image_info.loading_hint_index = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_curr_loading_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_curr_loading_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_ivex_cntx.image_info.is_loading == KAL_FALSE);
    g_ivex_cntx.image_info.is_loading = MMI_TRUE;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_START_CUR_LOADING);
    /* loading state is not allowed zoom, so grey zoom icon */
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    mmi_ivex_draw_current_loading_effect_cyclic();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_curr_loading_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_curr_loading_effect(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_draw_current_loading_effect_cyclic);
    if(g_ivex_cntx.image_info.is_loading)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_STOP_CUR_LOADING);
        g_ivex_cntx.image_info.is_loading = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_error_string
 * DESCRIPTION
 *  matching ivsrv error code.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_adjust_error_icon_disp_orient(MMI_BOOL is_switch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (!is_switch)
    {
        if ((g_ivex_cntx.view_image_rotate != g_ivex_cntx.ui_display_rotate)  ||
            g_ivex_cntx.rot_oriention != MMI_IVEX_ROTATE_NONE)
        {
            if (g_ivex_cntx.rot_oriention != MMI_IVEX_ROTATE_NONE)
            {
                /* ui rotate case, error->error, this case process when error icon has rotate over, but osd not, motion callback at the same direction again */
                if (g_ivex_cntx.rot_oriention == MMI_IVEX_ROTATE_JUST_CW)
                {
                    g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_90;
                }

                if (g_ivex_cntx.rot_oriention == MMI_IVEX_ROTATE_JUST_CCW)
                {
                    g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_0;
                }
            }
            else
            {
                if (g_ivex_cntx.ui_rotating == MMI_TRUE)
                {
                    /* ui rotating, at this time, has not changed orientation */
                    g_ivex_cntx.view_image_rotate = (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)?GDI_LCD_LAYER_ROTATE_90 : GDI_LCD_LAYER_ROTATE_0;
                }
                else
                {
                    /* view rotate case, especially for the rotated image error back from history */
                    g_ivex_cntx.view_image_rotate = g_ivex_cntx.ui_display_rotate;
                }
            }
        }
        mmi_ivex_view_layer_resizer(g_ivex_cntx.display_layer_handle, MMI_FALSE);
        gdi_layer_set_rotate_nb_concurrent(g_ivex_cntx.display_layer_handle, g_ivex_cntx.view_image_rotate);
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_error_string
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_error_string(gdi_handle draw_layer_hdlr, MMI_BOOL is_switch, ivex_image_info_struct *img_info, ivex_osd_icon_struct *icon_struct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 offset_x,offset_y;
    S32 layer_w,layer_h;
    S32 str_len, line_height;
    S32 mult_w, mult_h, fit_w, fit_h;
    MMI_BOOL is_vertical = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90 || g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
    {
        is_vertical = MMI_TRUE;
    }
    gdi_layer_push_and_set_active(draw_layer_hdlr);
    gdi_layer_get_dimension(&layer_w, &layer_h);

    gui_set_font((UI_font_type)gui_font_get_type(GUI_FONT_SIZE_TITLE));

    str_len = mmi_ucs2strlen(img_info->err_str_ptr);
    create_multiline_inputbox_set_buffer((UI_string_type)img_info->err_str_ptr, str_len, str_len, 0);
    /* Set border flag */
    MMI_multiline_inputbox.normal_text_color = gui_color(160, 160, 160);
    gui_set_multi_line_input_box_default_bg_color(&MMI_multiline_inputbox, gui_color(0, 0, 0), MMI_TRUE);
    /* Set as center alignment & other parameters */
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW |
                                                         UI_MULTI_LINE_INPUT_BOX_VIEW_MODE |
                                                         UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY |
                                                         UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
    MMI_multiline_inputbox.ext_flags |= GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER;
    /* Medium font */
    MMI_multiline_inputbox.text_font = gui_font_get_type(GUI_FONT_SIZE_TITLE);
    show_multiline_inputbox_no_draw();
    line_height = get_multiline_inputbox_line_height();
    if ((!is_vertical && !is_switch) || (is_switch && (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)))
    {
        offset_x = 10;
        mult_w = layer_w - 20;
    }
    else
    {
        offset_x = layer_w - g_ivex_osd_cntx_270.panel.offset_x - g_ivex_osd_cntx_270.panel_shadow.offset_x;
        mult_w = layer_w - offset_x * 2;
    }
    mult_h = (MMI_multiline_inputbox.n_lines * line_height) + MULTILINE_INPUTBOX_HEIGHT_PAD;
    offset_y = icon_struct->offset_y + icon_struct->height + 10;
    wgui_inputs_ml_resize_fit(mult_w, mult_h, &fit_w, &fit_h);
    move_multiline_inputbox(offset_x, offset_y);
    gdi_layer_lock_frame_buffer();
    show_multiline_inputbox();
    gdi_layer_unlock_frame_buffer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_splash_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_splash_effect(gdi_handle draw_layer_hdlr, MMI_BOOL is_switch, U16 icon_enum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_icon_struct *icon_struct;
    U8 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_adjust_error_icon_disp_orient(is_switch);
    /* this case is for rotate view layer under loading, other for switch case of different oriention between view layer and switch layer */
    if (g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_90 || g_ivex_cntx.view_image_rotate == GDI_LCD_LAYER_ROTATE_270)
    {
        index = 1;
    }

    switch (icon_enum)
    {
        case IMG_ID_IVEX_HINT_DRM:
            if (is_switch)
            {
                icon_struct = &g_ivex_cntx.active_osd_layout_ptr->drm_hint;
            }
            else
            {
                icon_struct = &lock_drm_hint[index];
            }
            break;
        case IMG_ID_IVEX_HINT_FILE_ERR:
            if (is_switch)
            {
                icon_struct = &g_ivex_cntx.active_osd_layout_ptr->error_hint;
            }
            else
            {
                icon_struct = &lock_error_hint[index];
            }
            break;
        default:
            icon_struct = &g_ivex_cntx.active_osd_layout_ptr->error_hint;
            break;
    }
    gdi_image_get_dimension_id((U16)(icon_enum), &(icon_struct->width), &(icon_struct->height));

    gdi_layer_clear_nb_concurrent(draw_layer_hdlr, GDI_COLOR_BLACK);

    mmi_ivex_draw_alpha_bmp_id_nb_concurrent(draw_layer_hdlr, icon_struct->offset_x, icon_struct->offset_y, draw_layer_hdlr, icon_enum);

    if (is_switch)
    {
        mmi_ivex_draw_error_string(draw_layer_hdlr,is_switch,&g_ivex_cntx.switch_image_info,icon_struct);
        g_ivex_cntx.switch_image_info.is_err = MMI_TRUE;
    }
    else
    {
        mmi_ivex_draw_error_string(draw_layer_hdlr,is_switch,&g_ivex_cntx.image_info,icon_struct);
        g_ivex_cntx.image_info.is_err = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_drm_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_drm_effect(gdi_handle draw_layer_hdlr, MMI_BOOL is_switch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* this case is for rotate view layer under loading, other for switch case of different oriention between view layer and switch layer */
    mmi_ivex_draw_splash_effect(draw_layer_hdlr, is_switch, IMG_ID_IVEX_HINT_DRM);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_err_effect
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_draw_err_effect(gdi_handle draw_layer_hdlr, MMI_BOOL is_switch)
    {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ivex_draw_splash_effect(draw_layer_hdlr, is_switch, IMG_ID_IVEX_HINT_FILE_ERR);
}


#define MMI_IVEX_CALCULAT_OFFSET
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_calculate_zoom_cnt
 * DESCRIPTION
 *  Calculate base raised to the power of index
 * PARAMETERS
 *  base    [IN]
 *  index   [IN]
 * RETURNS
 *  Return the value: base raised to the power of index
 *****************************************************************************/
U16 mmi_ivex_calculate_zoom_cnt(float base, float curr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i;
    float temp_curr = curr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(temp_curr >= base);

#ifndef __IVEX_SUPPOERT_ANIM_ZOOM__
    if(g_ivex_cntx.image_info.is_animation)
    {
        return 0;
    }
#endif /*__IVEX_SUPPOERT_ANIM_ZOOM__*/
    for (i = 0; ; i++)
    {
        if ((temp_curr / g_ivex_cntx.image_info.zoom_factor) >= base)
        {
            temp_curr = temp_curr / g_ivex_cntx.image_info.zoom_factor;
        }
        else
        {
            break;
        }
    }
    return i;
}


#define MMI_IVEX_OSD_FADE_OUT
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_update_osd_opacity
 * DESCRIPTION
 *  fade imgadv osd
 * PARAMETERS
 *  sleep       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_update_osd_opacity(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_set_opacity_nb_concurrent(g_ivex_cntx.osd_title_layer, MMI_TRUE, (U8) g_ivex_cntx.osd_opacity);

    gdi_layer_set_opacity_nb_concurrent(g_ivex_cntx.osd_panel_layer, MMI_TRUE, (U8) g_ivex_cntx.osd_opacity);

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    gdi_layer_set_opacity_nb_concurrent(g_ivex_cntx.osd_sliding_bar.panel_layer, MMI_TRUE, (U8) g_ivex_cntx.osd_opacity);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_enable_osd_fade
 * DESCRIPTION
 *  fade imgadv osd
 * PARAMETERS
 *  sleep       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_enable_osd_fade(MMI_BOOL is_start)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* start fade out timer */
    gui_cancel_timer(mmi_ivex_start_osd_fade_out);
    if (is_start)
    {
        gui_start_timer(MMI_IVEX_OSD_FADE_OUT_DURATION, mmi_ivex_start_osd_fade_out);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_fade_update_position
 * DESCRIPTION
 *  fade slidin osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_fade_update_position(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ivex_osd_layer_struct position_pan;
    ivex_osd_layer_struct position_title;
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    ivex_osd_layer_struct position_sliding_bar;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0)
    {
        position_pan.offset_y = LCD_HEIGHT - (g_ivex_cntx.active_osd_layout_ptr->panel.height * g_ivex_cntx.osd_opacity) / MMI_IVEX_OSD_FADE_OPACITY_VALUE;
        position_pan.offset_x = 0;
    }
    else
    {
        position_pan.offset_x = LCD_HEIGHT - (g_ivex_cntx.active_osd_layout_ptr->panel.width * g_ivex_cntx.osd_opacity) / MMI_IVEX_OSD_FADE_OPACITY_VALUE;
        position_pan.offset_y = 0;
    }

#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    position_sliding_bar.offset_x = g_ivex_cntx.osd_sliding_bar.active_layout->panel_rect.x;
    position_sliding_bar.offset_y = g_ivex_cntx.osd_sliding_bar.active_layout->panel_rect.y;
#endif

    if (g_ivex_cntx.ui_display_rotate == GDI_LAYER_ROTATE_90)
    {
        position_title.offset_y = - g_ivex_cntx.active_osd_layout_ptr->title.height;
    }
    else
    {
        position_title.offset_y = (g_ivex_cntx.active_osd_layout_ptr->title.height * g_ivex_cntx.osd_opacity) / MMI_IVEX_OSD_FADE_OPACITY_VALUE - g_ivex_cntx.active_osd_layout_ptr->title.height;
    }
    position_title.offset_x = 0;

    mmi_ivex_layer_set_position(g_ivex_cntx.osd_panel_layer, &position_pan);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_layer_set_position(g_ivex_cntx.osd_sliding_bar.panel_layer, &position_sliding_bar);
#endif
    mmi_ivex_layer_set_position(g_ivex_cntx.osd_title_layer, &position_title);
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_osd_fade_out
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_osd_fade_out(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.osd_fade_percent != 0 ||
        g_ivex_cntx.ui_rotating == MMI_TRUE)
    {
        mmi_ivex_stop_osd_fade_in();
        g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_FADE_OUT;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_START_OSD_FOUT);
        mmi_ivex_layer_set_blt_layer();
        g_ivex_cntx.is_fading = MMI_TRUE;
        mmi_ivex_osd_fade_out_cyclic();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_osd_fade_out
 * DESCRIPTION
 *  this function is for interrupt under fade state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_osd_fade_out(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    gui_cancel_timer(mmi_ivex_shortcut_osd_hide_unhide_switch);
#endif
    gui_cancel_timer(mmi_ivex_osd_fade_out_cyclic);
    gui_cancel_timer(mmi_ivex_start_osd_fade_out);
    if(g_ivex_cntx.is_fading == MMI_TRUE && g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_FADE_OUT)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_STOP_OSD_FOUT);
        g_ivex_cntx.is_fading = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_osd_fade_in
 * DESCRIPTION
 *  draw loading effect.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_osd_fade_in(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.osd_fade_percent != 100)
    {
        mmi_ivex_stop_osd_fade_out();
        g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_FADE_IN;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_START_OSD_FIN);
        mmi_ivex_layer_set_blt_layer();
        g_ivex_cntx.is_fading = MMI_TRUE;
        mmi_ivex_osd_fade_in_cyclic();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_osd_fade_in
 * DESCRIPTION
 *  this function is for interrupt under fade state.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_osd_fade_in(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_TOUCH_SCREEN__
    gui_cancel_timer(mmi_ivex_shortcut_osd_hide_unhide_switch);
#endif
    gui_cancel_timer(mmi_ivex_osd_fade_in_cyclic);
    if(g_ivex_cntx.is_fading == MMI_TRUE && g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_FADE_IN)
    {
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_STOP_OSD_FIN);
        g_ivex_cntx.is_fading = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_fade_in_cyclic
 * DESCRIPTION
 *  fade slidin osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_fade_in_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 percent = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reset osd fade out timer */
    ASSERT(g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_FADE_IN);
    if (g_ivex_cntx.osd_fade_percent + MMI_IVEX_OSD_FADE_IN_STEP_VALUE < 100)
    {
        g_ivex_cntx.osd_fade_percent += MMI_IVEX_OSD_FADE_IN_STEP_VALUE;
    }
    else
    {
        g_ivex_cntx.osd_fade_percent = 100;
    }
    percent = mmi_ivex_animator_ease_out(g_ivex_cntx.osd_fade_percent);
    g_ivex_cntx.osd_opacity = MMI_IVEX_OSD_FADE_OPACITY_VALUE * percent / 100;
    mmi_ivex_update_osd_opacity();
    mmi_ivex_osd_fade_update_position();
    if (percent == 100 && g_ivex_cntx.is_fading == MMI_TRUE)
    {
        g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_SHOW;
        g_ivex_cntx.is_fading = MMI_FALSE;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_OSD_FIN_OVER);
        mmi_ivex_layer_set_blt_layer();
	 mmi_ivex_enable_osd_fade(MMI_TRUE);
        mmi_ivex_adjust_to_align_motion();
    }
    else
    {
        gui_start_timer(MMI_IVEX_OSD_FADE_INTERVAL_DURATION, mmi_ivex_osd_fade_in_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_osd_fade_out_cyclic
 * DESCRIPTION
 *  fade slidshow osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_osd_fade_out_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 percent = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(g_ivex_cntx.osd_state == MMI_IVEX_OSD_STATE_FADE_OUT);
    if (g_ivex_cntx.osd_fade_percent > MMI_IVEX_OSD_FADE_OUT_STEP_VALUE)
    {
        g_ivex_cntx.osd_fade_percent -= MMI_IVEX_OSD_FADE_OUT_STEP_VALUE;
    }
    else
    {
        g_ivex_cntx.osd_fade_percent = 0;
    }
    percent = mmi_ivex_animator_ease_out(g_ivex_cntx.osd_fade_percent);
    g_ivex_cntx.osd_opacity = MMI_IVEX_OSD_FADE_OPACITY_VALUE * percent / 100;
    mmi_ivex_update_osd_opacity();
    mmi_ivex_osd_fade_update_position();
    if (percent == 0 && g_ivex_cntx.is_fading == MMI_TRUE)
    {
        g_ivex_cntx.osd_state = MMI_IVEX_OSD_STATE_HIDE;
        MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_OSD_FOUT_OVER);
        g_ivex_cntx.is_fading = MMI_FALSE;

        if (g_ivex_cntx.ui_rotating == MMI_TRUE)
        {
            /* make sure osd completely disappear and then appear */
            GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
            g_ivex_cntx.ui_rotating = MMI_FALSE;
            mmi_ivex_update_layers_after_rotated();
            mmi_ivex_start_osd_fade_in();
        }
    }
    else
    {
        gui_start_timer(MMI_IVEX_OSD_FADE_INTERVAL_DURATION, mmi_ivex_osd_fade_out_cyclic);
    }
}


#define MMI_IVEX_RENDERER
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_renderer_cyclic
 * DESCRIPTION
 *  fade slidshow osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_renderer_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.renderer_ref_count > 0)
    {
        gui_start_timer(MMI_IVEX_RENDERER_TIMER_DURATION, mmi_ivex_renderer_cyclic);
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_start_renderer
 * DESCRIPTION
 *  fade slidshow osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_start_renderer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_START_RENDER,g_ivex_cntx.renderer_ref_count);
    g_ivex_cntx.renderer_ref_count++;
    /* first time to use renderer: start it */
    if (g_ivex_cntx.renderer_ref_count == 1)
    {
        mmi_ivex_renderer_cyclic();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_renderer
 * DESCRIPTION
 *  fade slidshow osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_renderer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_ASSERT(g_ivex_cntx.renderer_ref_count != 0);
    if(g_ivex_cntx.renderer_ref_count == 0)
        return;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_STOP_RENDER,g_ivex_cntx.renderer_ref_count);
    g_ivex_cntx.renderer_ref_count--;
    if (g_ivex_cntx.renderer_ref_count == 0)
    {
        /* render last frame */
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
        /* no one is unsing renderer */
        gui_cancel_timer(mmi_ivex_renderer_cyclic);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_renderer_cyclic
 * DESCRIPTION
 *  force stop render and reset count as 0 when exit, this only use in exit and is the last one stop;
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_stop_renderer_cyclic(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_cancel_timer(mmi_ivex_renderer_cyclic);
    g_ivex_cntx.renderer_ref_count = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_get_ext_ui_width
 * DESCRIPTION
 *  This function is called to set position.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL if has done
 *****************************************************************************/
S32 mmi_ivex_get_ext_ui_width(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ui_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90)
    {
        ui_width = LCD_HEIGHT + MMI_IVEX_IMAGE_SPACING;
    }
    else
    {
        ui_width = LCD_WIDTH + MMI_IVEX_IMAGE_SPACING;
    }
    return ui_width;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_stop_renderer
 * DESCRIPTION
 *  fade slidshow osd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 mmi_ivex_animator_ease_out(S32 cur_percent)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 start_kf_idx;
    S32 end_kf_idx;
    S32 dy1, x, y;
    S32 count;
    S32 percent;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cur_percent >= 100)
    {
        percent = 100;
    }
    else
    {
        percent = cur_percent;
    }
    count = sizeof(mmi_ivex_keyframe_ease_out)/sizeof(mmi_ivex_keyframe_ease_out[0]);
    start_kf_idx = percent / 10;
    end_kf_idx = start_kf_idx + 1;
    x = percent - (start_kf_idx * 10);
    if (end_kf_idx != count)
    {
        dy1 = (mmi_ivex_keyframe_ease_out[end_kf_idx] - mmi_ivex_keyframe_ease_out[start_kf_idx]);
    }
    else
    {
        dy1 = 0;
    }
    y = mmi_ivex_keyframe_ease_out[start_kf_idx] + (x * dy1)/10;
    return  y;
}


#define MMI_IMGVIEW_CUI_APP
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_lsk_custmize_confirmed
 * DESCRIPTION
 *  Left softkey pressed to confirm the operation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_lsk_custmize_confirmed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_group_event_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VIEW_IVEX_CUI_LSK_CONFIRM, g_ivex_cui_gid;
    evt.evt_id = EVT_ID_IMGVIEW_FILE_SELECT;
    evt.sender_id = g_ivex_cui_gid;
    evt.size = sizeof(mmi_group_event_struct);
    mmi_frm_group_post_to_parent(g_ivex_cui_gid, &evt);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_lsk_custmize_is_enable
 * DESCRIPTION
 *  If enable custmized lsk
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL mmi_ivex_lsk_custmize_is_enable(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL enable = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_ivex_cntx.image_info.is_loading == MMI_TRUE)
    {
        enable = MMI_FALSE;
    }

    /* CUI control part, user can reset it */
    if (g_ivex_cntx.image_info.result < MMI_IVEX_IMG_HEALTH_OK &&
        g_imgview_cui_ptr->lsk_setting.is_force_enable == MMI_FALSE)
    {
        enable = MMI_FALSE;
    }
    return enable;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_set_fl_and_start_idx
 * DESCRIPTION
 *  Set filelist and start index for APP runing
 * PARAMETERS
 *  filelist           :   [IN] caller filelist.
 *  start_index        :   [IN] start index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_set_fl_and_start_idx(SRV_FMGR_FILELIST_HANDLE filelist, U32 start_index, U32 total_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VIEW_FL_IDX,g_imgview_fl_hdl,g_imgview_fl_idx,filelist,start_index);
    g_imgview_fl_hdl = filelist;
    g_imgview_fl_idx = start_index;
    g_ivex_cntx.total_image_count = total_count;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_fetch_file_name
 * DESCRIPTION
 *  For prefetch mode to fetch file name
 * PARAMETERS
 *  filelist           :   [IN] caller filelist.
 *  start_index        :   [IN] start index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_fetch_file_name(WCHAR *path_buffer, U32 bufer_size, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_imgview_get_filename_event_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VIEW_FETCH,g_imgview_fl_hdl,g_imgview_fl_idx,filelist,start_index);
    evt.index = index;
    evt.path_buffer = path_buffer;
    evt.path_buffer_size = bufer_size;
    evt.evt_id = EVT_ID_IMGVIEW_GET_FILENAME;
    evt.sender_id = g_ivex_cui_gid;
    evt.size = sizeof(cui_imgview_get_filename_event_struct);
    mmi_frm_group_send_to_parent(g_ivex_cui_gid, (mmi_group_event_struct*)&evt);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_show_fetch_file
 * DESCRIPTION
 *  Show fetched file
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_show_fetch_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* deal with current image info */
    mmi_ivex_stop_all_ext();
    mmi_ivex_stop_anim_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_stop_mav_if_need(&g_ivex_cntx.image_info, g_ivex_cntx.display_layer_handle);
#endif
    srv_mediacache_stop(g_ivex_cntx.srv_mediacache_handle);
#ifdef __DRM_SUPPORT__
    if (g_ivex_cntx.image_info.is_drm)
    {
        mmi_ivex_stop_drm_consume();
    }
#endif

    /* make sure at initiation state*/
    mmi_ivex_init_variable();
    /* prepare for new file show */
    g_ivex_cntx.view_from_fmgr = MMI_TRUE;
    mmi_ivex_init_osd_icon_info();
    mmi_ivex_get_active_osd_cntx();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    sliding_bar_init(&g_ivex_cntx.osd_sliding_bar,
                     IMG_ID_IVEX_SLIDING_BAR_BG,
                     IMG_ID_IVEX_SLIDER_UP,
                     IMG_ID_IVEX_SLIDER_DOWN,
                     g_ivex_cntx.ui_display_rotate);
    sliding_bar_set_progress_observer(&g_ivex_cntx.osd_sliding_bar, mmi_ivex_sliding_bar_progess_observer, NULL);
#endif

    mmi_ivex_reset_image_info(&g_ivex_cntx.image_info);
    mmi_ivex_get_image_base_info(0, MMI_TRUE, &g_ivex_cntx.image_info);
    mmi_ivex_init_image_display_info(&g_ivex_cntx.image_info, MMI_FALSE);

    /*Draw osd */
    mmi_ivex_draw_osd_title_layer();
    mmi_ivex_draw_osd_panel_layer();
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
    mmi_ivex_draw_osd_sliding_bar_layer();
#endif
    mmi_ivex_layer_set_blt_layer();

    srv_mediacache_config_work_mode_to_filename(g_ivex_cntx.srv_mediacache_handle, (WCHAR*)g_ivex_cntx.image_info.filepath);
    srv_mediacache_start(g_ivex_cntx.srv_mediacache_handle, 0);

    if (g_ivex_cntx.image_info.result == MMI_IVEX_IMG_HEALTH_OK)
    {
        /* first entry or has gained the right from net successfully and come from history or is loading before interrupt */
        g_ivex_cntx.image_info.is_first_ok = MMI_FALSE;
        ret = mmi_ivex_get_curr_img(IVEX_IMG_QTY_HIGH);
        if (ret >= SRV_MEDIACACHE_OK)
        {
            mmi_ivex_draw_animation_file(&g_ivex_cntx.image_info);
#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__
            mmi_ivex_draw_mav_file(&g_ivex_cntx.image_info);
#endif
            g_ivex_cntx.image_info.is_first_ok = MMI_TRUE;
        #ifdef __DRM_SUPPORT__
            mmi_ivex_drm_consume_rights(&g_ivex_cntx.image_info, g_ivex_cntx.is_resume);
        #endif
        }
        else
        {
            mmi_ivex_process_curr_image_decode_abnormal(ret);
        }
    }
    else
    {
        mmi_ivex_process_abnormal_image(g_ivex_cntx.display_layer_handle, &g_ivex_cntx.image_info, MMI_FALSE);
    }
    /* blt to lcd */
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);//mmi_ivex_layer_nb_concurrentcy_blt();
    g_ivex_cntx.image_state = MMI_IVEX_IMAGE_STATE_STILL;
    mmi_ivex_enable_osd_fade(MMI_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_prefetch_image
 * DESCRIPTION
 *  This function switch image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_prefetch_image(MMI_BOOL is_next)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IVAPP_NEXT_RELEASE,
        CUI_IMGVIEW_VIEWMODE_PREFETCH,CUI_IMGVIEW_VIEWMODE_PREFETCH);
    if (g_imgview_cui_ptr->view_mode.total_count == 1)
    {
        return;
    }
    else
    {
        if (is_next)
        {
            g_imgview_cui_ptr->view_mode.start_index++;
            if (g_imgview_cui_ptr->view_mode.start_index >= g_imgview_cui_ptr->view_mode.total_count)
            {
                g_imgview_cui_ptr->view_mode.start_index = 0;
            }
        }
        else
        {
            if (g_imgview_cui_ptr->view_mode.start_index == 0)
            {
                g_imgview_cui_ptr->view_mode.start_index = g_imgview_cui_ptr->view_mode.total_count - 1;
            }
            else
            {
                g_imgview_cui_ptr->view_mode.start_index--;
            }
        }
    }
    mmi_ivex_fetch_file_name((WCHAR*)g_imgview_cui_ptr->view_mode.buff_ptr, SRV_FMGR_PATH_BUFFER_SIZE, g_imgview_cui_ptr->view_mode.start_index);
    MMI_ASSERT(g_ivex_cntx.image_info.filepath != NULL);
    mmi_ucs2cpy(g_ivex_cntx.image_info.filepath, g_imgview_cui_ptr->view_mode.buff_ptr);
    mmi_ivex_show_fetch_file();
}


#define MMI_IMGVIEW_CUI
extern void cui_imgview_set_filelist_config_fun(mmi_id image_viewer_id, void(*filelist_config)(SRV_FMGR_FILELIST_HANDLE filelist, U32 start_index, U32 total_count));
extern void cui_imgview_set_enter_view_fun(mmi_id image_viewer_id, void(*enter_view_screen)(void));
extern void cui_imgview_enter_before_play(mmi_id image_viewer_id);
/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_app_reset
 * DESCRIPTION
 *  Reset app variable
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_app_reset(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ivex_cui_gid = GRP_ID_INVALID;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_set_ui_direct
 * DESCRIPTION
 *  Set UI direction of viewing image
 * PARAMETERS
 *  image_viewer_id  :   [IN]  Image view group id.
 *  rotation               :   [IN] UI direction
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_set_ui_direct(mmi_id image_viewer_id, cui_imgview_ui_direction_enum direction)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (direction == CUI_IMGVIEW_UI_DIRECTION_HORIZONTAL)
    {
        if (MMI_IVEX_LANDSCAPE)
        {
            g_ivex_cntx.ui_display_rotate = GDI_LCD_LAYER_ROTATE_0;
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_90;
        }
        else
        {
            g_ivex_cntx.ui_display_rotate = GDI_LCD_LAYER_ROTATE_90;
            g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_90;
        }
    }
    else
    {
        g_ivex_cntx.ui_display_rotate = GDI_LCD_LAYER_ROTATE_0;
        g_ivex_cntx.view_image_rotate = GDI_LCD_LAYER_ROTATE_0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_enter_view_from_cui
 * DESCRIPTION
 *  View entrance for cui
 * PARAMETERS
 *  image_viewer_id  :   [IN]  Image view group id.
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_ivex_enter_view_from_cui(mmi_id image_viewer_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    g_ivex_cntx.view_state = MMI_IVEX_VIEW_STATE_EXIT;
    g_ivex_cntx.view_from_fmgr = MMI_FALSE;
    g_ivex_cntx.view_one_from_other_app = MMI_FALSE;
    g_ivex_cntx.srv_mediacache_handle = NULL;
    g_ivex_cui_gid = image_viewer_id;
    /* For multi-instance, it will get itself data */
    g_imgview_cui_ptr = (cui_imgview_context_struct*)mmi_frm_group_get_user_data(g_ivex_cui_gid);

    if (g_ivex_cui_gid != g_imgview_cui_ptr->imgview_cui_gid)
    {
        MMI_ASSERT(0);
    }
    mmi_ivex_set_curr_app_id(g_imgview_cui_ptr->parent_app_id);

    //MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_VIEW_FROM_CUI,g_ivex_cui_gid,g_imgview_cui_ptr->view_mode.viewmode);
    switch (g_imgview_cui_ptr->view_mode.viewmode)
    {
        case CUI_IMGVIEW_VIEWMODE_FILENAME:
            g_ivex_cntx.view_one_from_other_app = MMI_TRUE;
            mmi_ivex_view_image_hdlr(g_imgview_cui_ptr->view_mode.buff_ptr, g_imgview_cui_ptr->parent_app_id);
            break;
        case CUI_IMGVIEW_VIEWMODE_PREFETCH:
            /* This case has not switch effect because prefetch has not list so can not let ivsrv to cache
            Base on current solution, only support key switch*/
            g_ivex_cntx.view_one_from_other_app = MMI_TRUE;
            mmi_ivex_fetch_file_name((WCHAR*)g_imgview_cui_ptr->view_mode.buff_ptr, SRV_FMGR_PATH_BUFFER_SIZE, g_imgview_cui_ptr->view_mode.start_index);
            mmi_ivex_view_image_hdlr(g_imgview_cui_ptr->view_mode.buff_ptr, g_imgview_cui_ptr->parent_app_id);
            break;
        case CUI_IMGVIEW_VIEWMODE_FILELIST:
            g_ivex_cntx.view_one_from_other_app = MMI_FALSE;
            mmi_ivex_reset_app();
            cui_imgview_set_filelist_config_fun(g_ivex_cui_gid, mmi_ivex_set_fl_and_start_idx);
            cui_imgview_set_enter_view_fun(g_ivex_cui_gid, mmi_ivex_entry_view_screen);
            cui_imgview_enter_before_play(g_ivex_cui_gid);
            break;
        case CUI_IMGVIEW_VIEWMODE_FILENAME_ARRAY:
            break;
        case CUI_IMGVIEW_VIEWMODE_IMAGEID_ARRAY:
            break;
        case CUI_IMGVIEW_VIEWMODE_FOLDER:
            g_ivex_cntx.view_one_from_other_app = MMI_FALSE;
            g_ivex_cntx.view_from_fmgr = MMI_FALSE;
            mmi_ivex_reset_app();
            cui_imgview_set_filelist_config_fun(g_ivex_cui_gid, mmi_ivex_set_fl_and_start_idx);
            cui_imgview_set_enter_view_fun(g_ivex_cui_gid, mmi_ivex_entry_view_screen);
            cui_imgview_enter_before_play(g_ivex_cui_gid);
            break;
        default:
            MMI_ASSERT(0);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_ivex_draw_alpha_bmp_id_nb_concurrent
 * DESCRIPTION
 *  Used to draw alpha bmp(png resource is generated to abm or ab2)
 * PARAMETERS
 *  dst_layer       [IN]
 *  dst_layer_x     [IN]
 *  dst_layer_y     [IN]
 *  src_layer       [IN]
 *  ImageId         [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static GDI_RESULT mmi_ivex_draw_alpha_bmp_id_nb_concurrent(
    gdi_handle dst_layer,
    S32 dst_layer_x,
    S32 dst_layer_y,
    gdi_handle src_layer,
    U16 ImageId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16         img_type = gdi_image_get_type_from_id(ImageId);
    GDI_RESULT  ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(GDI_IMAGE_TYPE_AB2 == img_type)
    {
        ret = gdi_image_ab2_draw_id_nb_concurrent(
            dst_layer,
            dst_layer_x,
            dst_layer_y,
            src_layer,
            ImageId);
    }
    else if(GDI_IMAGE_TYPE_ABM == img_type)
    {
        ret = gdi_image_abm_draw_id_nb_concurrent(
            dst_layer,
            dst_layer_x,
            dst_layer_y,
            src_layer,
            ImageId);
    }
    else
    {
        MMI_ASSERT(0);
    }

    return ret;
}


#ifdef __MULTIPLE_ANGLE_VIEW_SUPPORT__

static void mmi_ivex_draw_osd_sliding_bar_layer(void)
{
    if (mmi_ivex_should_show_sliding_bar())
        sliding_bar_redraw(&(g_ivex_cntx.osd_sliding_bar));
}

MMI_BOOL current_image_is_mav(void) {
    return g_ivex_cntx.image_info.is_mav;
}

static void mmi_ivex_mav_draw_callback(GDI_RESULT result, gdi_handle handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void *buffer_ptr;
    S32   buffer_size;
    ivex_image_info_struct *img_info = NULL;

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_DRAW_CALLBACK, result, handle);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_scrn_get_active_id()!=SCR_ID_IMGVIEW_VIEW)
    {
        return;
    }
    if (result == GDI_SUCCEED)
    {
        buffer_ptr = (void*)(((gdi_layer_struct*)g_ivex_cntx.display_layer_handle)->buf_ptr);
    #if defined(MAIN_MEDIA_LAYER_BITS_PER_PIXEL) && (MAIN_MEDIA_LAYER_BITS_PER_PIXEL == 24)
        buffer_size = MMI_IVEX_SHOWN_IMAGE_LAYER_24BIT;
    #else
        buffer_size = MMI_IVEX_LAYER_SIZE;
    #endif
        memcpy(buffer_ptr, g_ivex_cntx.temp_display_layer.temp_layer_buffer, buffer_size);
        GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
    }

    mmi_ivex_display_layer_temp_free();

    if (g_ivex_cntx.image_info.handle == handle) {
        img_info = &g_ivex_cntx.image_info;
    }
    else if (g_ivex_cntx.switch_image_info.handle == handle) {
        img_info = &g_ivex_cntx.switch_image_info;
    }

    if (img_info != NULL) {
        img_info->is_mav_decoding = MMI_FALSE;
        img_info->handle = 0;
    }
}


static void mmi_ivex_stop_mav_if_need(ivex_image_info_struct* img_info, gdi_handle layer_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_STOP_DECODING, img_info->is_mav,img_info->handle);
    if (img_info->is_mav && img_info->handle)
    {
        gdi_image_nb_stop(img_info->handle);
        mmi_ivex_display_layer_temp_free();
        img_info->handle = 0;
        img_info->is_mav_decoding = MMI_FALSE;
    }
}


static void mmi_ivex_draw_mav_file(ivex_image_info_struct* img_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle temp_layer_handle;
#if 0
/* under construction !*/
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_DRAW_FILE, img_info->is_mav, img_info->is_mav_decoding);

    if (!img_info->is_mav)
        return;

    if (img_info->is_mav_decoding) {
        gdi_image_nb_stop(img_info->handle);
        mmi_ivex_display_layer_temp_free();
        img_info->is_mav_decoding = MMI_FALSE;
        img_info->handle = 0;
    }

    temp_layer_handle = mmi_ivex_display_layer_temp_create();

    MMI_ASSERT(img_info->filepath != NULL);
    gdi_layer_push_and_set_active(temp_layer_handle);
    gdi_push_and_set_alpha_blending_source_layer(temp_layer_handle);
    gdi_nb_set_done_callback(mmi_ivex_mav_draw_callback);
    gdi_nb_set_blt(MMI_FALSE,MMI_FALSE);
    srv_mediacache_pause_decode(g_ivex_cntx.srv_mediacache_handle);
    img_info->handle = gdi_image_nb_draw_resized_file_frames(
                                img_info->draw_offset_x,
                                img_info->draw_offset_y,
                                img_info->resized_width,
                                img_info->resized_height,
                                img_info->filepath,
                                img_info->mav_current_frame);
    img_info->is_mav_decoding = MMI_TRUE;
#if 0
/* under construction !*/
/* under construction !*/
#endif
    srv_mediacache_resume_decode(g_ivex_cntx.srv_mediacache_handle);
    MMI_ASSERT(img_info->handle != 0);
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_DRAW_FILE_STARTED, img_info->handle);
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_and_restore_active();
}

static void mmi_ivex_shortcut_mav_prev_frame_press_int(void) {
    SlidingBar *sb = &g_ivex_cntx.osd_sliding_bar;
    ivex_image_info_struct *image_info = &g_ivex_cntx.image_info;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_PREV_KEY_PRESS);
    if (!image_info->is_mav)
        return;

    if (image_info->mav_current_frame > 0) {
        sliding_bar_set_progress(sb, (image_info->mav_current_frame-1) * 100.0 / (image_info->mav_total_frames - 1));
    }
}

static void mmi_ivex_shortcut_mav_prev_frame_press(void) {
    mmi_ivex_shortcut_mav_prev_frame_press_int();
}

static void mmi_ivex_shortcut_mav_next_frame_press_int(void) {
    SlidingBar *sb = &g_ivex_cntx.osd_sliding_bar;
    ivex_image_info_struct *image_info = &g_ivex_cntx.image_info;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_NEXT_KEY_PRESS);
    if (!image_info->is_mav)
        return;

    if (image_info->mav_current_frame < (image_info->mav_total_frames - 1)) {
        sliding_bar_set_progress(sb, (image_info->mav_current_frame+1) * 100.0 / (image_info->mav_total_frames - 1));
    }
}

static void mmi_ivex_shortcut_mav_next_frame_press(void) {
    mmi_ivex_shortcut_mav_next_frame_press_int();
}

static void mmi_ivex_shortcut_mav_prev_frame_repeat(void) {
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_PREV_KEY_REPEAT);
    mmi_ivex_shortcut_mav_prev_frame_press_int();
}

static void mmi_ivex_shortcut_mav_next_frame_repeat(void) {
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_NEXT_KEY_REPEAT);
    mmi_ivex_shortcut_mav_next_frame_press_int();
}

static void mmi_ivex_shortcut_mav_prev_frame_release(void) {
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_PREV_KEY_RELEASE);
}

static void mmi_ivex_shortcut_mav_next_frame_release(void) {
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_NEXT_KEY_RELEASE);
}

static void mmi_ivex_sliding_bar_progess_observer(SlidingBar *sb, void *userdata) {
    S32 new_frame_index;
    ivex_image_info_struct *image_info = &g_ivex_cntx.image_info;
    
    MMI_ASSERT(sb != NULL);
    
    new_frame_index = (S32) (sb->progress * (image_info->mav_total_frames - 1) / 100);
    if (new_frame_index < 0) {
        new_frame_index = 0;
    }
    else if (new_frame_index > (image_info->mav_total_frames - 1)) {
        new_frame_index = image_info->mav_total_frames - 1;
    }

    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_SLIDING_BAR_OBSERVER, new_frame_index);

    if (new_frame_index != image_info->mav_current_frame) {
        image_info->mav_current_frame = new_frame_index;
        mmi_ivex_draw_mav_file(image_info);
    }
    mmi_ivex_layer_set_blt_layer();
    GDI_LAYER_BLT_PREVIOUS_NB_CONCURRENT(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}

static MMI_BOOL mmi_ivex_should_show_sliding_bar(void) {
    if (g_ivex_cntx.image_info.is_mav)
        return MMI_TRUE;
    else
        return MMI_FALSE;
}

static void mmi_ivex_sliding_bar_convert_touch_coordinate(mmi_pen_point_struct *pos)
{
    SlidingBarLayout *layout = g_ivex_cntx.osd_sliding_bar.active_layout;
    pos->x = pos->x - layout->panel_rect.x;
    pos->y = pos->y - layout->panel_rect.y;
}

#ifdef __MMI_IMGVIEWEX_MAV_MOTION__

#define MAV_MOTION_SLOPE (15)
#define MAV_MOTION_PROTRAIT_PREV_ANGLE (90 + MAV_MOTION_SLOPE)
#define MAV_MOTION_PROTRAIT_NEXT_ANGLE (90 - MAV_MOTION_SLOPE)
#define MAV_MOTION_LANDSCAPE_PREV_ANGLE (90 - MAV_MOTION_SLOPE)
#define MAV_MOTION_LANDSCAPE_NEXT_ANGLE (90 + MAV_MOTION_SLOPE)
#define MAV_MOTION_PULSE_DURATION (180)

static void mmi_ivex_mav_motion_pulse(void) {
#ifdef __MMI_TOUCH_SCREEN__
    if (g_ivex_cntx.is_pen_down == MMI_TRUE) {
        gui_start_timer(MAV_MOTION_PULSE_DURATION, mmi_ivex_mav_motion_pulse);
        return;
    }
#endif
    if (g_ivex_cntx.key_press == MMI_TRUE) {
        gui_start_timer(MAV_MOTION_PULSE_DURATION, mmi_ivex_mav_motion_pulse);
        return;
    }

    if (!(g_ivex_cntx.image_state == MMI_IVEX_IMAGE_STATE_STILL && g_ivex_cntx.image_info.is_mav)) {
        gui_start_timer(MAV_MOTION_PULSE_DURATION, mmi_ivex_mav_motion_pulse);
        return;
    }
    
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MAV_PULSE, g_ivex_cntx.mav_motion_direction);

    if (g_ivex_cntx.mav_motion_direction == MAV_MOTION_DIRECTION_PREV) {
        mmi_ivex_shortcut_mav_prev_frame_press_int();
    }
    else if (g_ivex_cntx.mav_motion_direction == MAV_MOTION_DIRECTION_NEXT) {
        mmi_ivex_shortcut_mav_next_frame_press_int();
    }

    gui_start_timer(MAV_MOTION_PULSE_DURATION, mmi_ivex_mav_motion_pulse);
}

static void mmi_ivex_mav_motion_start_pulse(void) {
    if (g_ivex_cntx.mav_motion_pulse_started)
        return;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MAV_START_PULSE);
    g_ivex_cntx.mav_motion_pulse_started = MMI_TRUE;
    gui_start_timer(MAV_MOTION_PULSE_DURATION, mmi_ivex_mav_motion_pulse);
}

static void mmi_ivex_mav_motion_stop_pulse(void) {
    if (!g_ivex_cntx.mav_motion_pulse_started)
        return;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MAV_STOP_PULSE);
    gui_cancel_timer(mmi_ivex_mav_motion_pulse);
    g_ivex_cntx.mav_motion_pulse_started = MMI_FALSE;
}

static void mmi_ivex_mav_image_tilt_callback(
        srv_sensor_type_enum sensor_type,
        void *sensor_data,
        void *user_data)
{
    srv_sensor_motion_tilt_struct *p_tilt = (srv_sensor_motion_tilt_struct *) sensor_data;
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_IMGVIEW_MAV_TILT,
        p_tilt->angle.gx,
        p_tilt->angle.gy,
        p_tilt->angle.gz);

#ifdef __MMI_TOUCH_SCREEN__
    if (g_ivex_cntx.is_pen_down == MMI_TRUE )
        return;
#endif
    if (g_ivex_cntx.key_press == MMI_TRUE)
        return;
    
    if (g_ivex_cntx.image_state != MMI_IVEX_IMAGE_STATE_STILL) 
        return;

    if (g_ivex_cntx.image_info.is_mav) {
        g_ivex_cntx.mav_motion_angle_x = p_tilt->angle.gx;
        g_ivex_cntx.mav_motion_angle_y = p_tilt->angle.gy;
        g_ivex_cntx.mav_motion_angle_z = p_tilt->angle.gz;
        if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_0) {
            if (g_ivex_cntx.mav_motion_angle_x >= MAV_MOTION_PROTRAIT_PREV_ANGLE) {
                g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_PREV;
                mmi_ivex_mav_motion_start_pulse();
            }
            else if (g_ivex_cntx.mav_motion_angle_x <= MAV_MOTION_PROTRAIT_NEXT_ANGLE) {
                g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NEXT;
                mmi_ivex_mav_motion_start_pulse();
            }
            else {
                g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NONE;
                mmi_ivex_mav_motion_stop_pulse();
            }
        }
        else if (g_ivex_cntx.ui_display_rotate == GDI_LCD_LAYER_ROTATE_90) {
            if (g_ivex_cntx.mav_motion_angle_y <= MAV_MOTION_LANDSCAPE_PREV_ANGLE) {
                g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_PREV;
                mmi_ivex_mav_motion_start_pulse();
            }
            else if (g_ivex_cntx.mav_motion_angle_y >= MAV_MOTION_LANDSCAPE_NEXT_ANGLE) {
                g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NEXT;
                mmi_ivex_mav_motion_start_pulse();
            }
            else {
                g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NONE;
                mmi_ivex_mav_motion_stop_pulse();
            }
        }
        else {
            MMI_ASSERT(0);
        }
    }
    else {
        g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NONE;
        mmi_ivex_mav_motion_stop_pulse();
    }
}


static void mmi_ivex_mav_start_listen_motion(void)
{
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MAV_LISTEN_START);

    if (g_ivex_cntx.mav_motion_is_enabled)
        return;
    
    g_ivex_cntx.mav_motion_angle_x = -1;
    g_ivex_cntx.mav_motion_angle_y = -1;
    g_ivex_cntx.mav_motion_angle_z = -1;
    g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NONE;
    g_ivex_cntx.mav_motion_pulse_started = MMI_FALSE;
    g_ivex_cntx.mav_motion_handle = srv_sensor_start_listen(SRV_SENSOR_MOTION_TILT,
                                                            NULL, 
                                                            mmi_ivex_mav_image_tilt_callback,
                                                            NULL);
    g_ivex_cntx.mav_motion_is_enabled = MMI_TRUE;
}

static void mmi_ivex_mav_stop_listen_motion(void)
{
    MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_MAV_LISTEN_STOP);

    if (!g_ivex_cntx.mav_motion_is_enabled)
        return;
    
    if (g_ivex_cntx.mav_motion_is_enabled && (g_ivex_cntx.mav_motion_handle >= 0))
    {
        srv_sensor_stop_listen(g_ivex_cntx.mav_motion_handle);
    }
    mmi_ivex_mav_motion_stop_pulse();
    g_ivex_cntx.mav_motion_angle_x = -1;
    g_ivex_cntx.mav_motion_angle_y = -1;
    g_ivex_cntx.mav_motion_angle_z = -1;
    g_ivex_cntx.mav_motion_direction = MAV_MOTION_DIRECTION_NONE;
    g_ivex_cntx.mav_motion_is_enabled = MMI_FALSE;
    g_ivex_cntx.mav_motion_pulse_started = MMI_FALSE;
}

#endif /*__MMI_IMGVIEWEX_MAV_MOTION__ */

#endif /* __MULTIPLE_ANGLE_VIEW_SUPPORT__ */

#ifdef __MMI_SNS_PHOTO_UPLOAD__
/*****************************************************************************
 * FUNCTION
 *  mmi_imgview_sns_photo_upload_check
 * DESCRIPTION
 *  check limit for image
 * PARAMETERS
 *  const WCHAR* filepath
 * RETURNS
 *  MMI_BOOL     
 *****************************************************************************/
extern MMI_BOOL mmi_imgview_sns_photo_upload_check(const WCHAR* filepath)
{
    FS_HANDLE hd;
    ivex_image_info_struct img_info;
    
    MMI_ASSERT(filepath != NULL);

    hd = FS_Open(filepath, FS_READ_ONLY);
    if (hd >= 0) {
        FS_Close(hd);
    }
    else {
        return MMI_FALSE;
    }

    mmi_ivex_reset_image_info(&img_info);
    img_info.result = MMI_IVEX_IMG_HEALTH_OK;
    img_info.filepath = (CHAR *)filepath;

    /* DRM check */
#if defined(__DRM_SUPPORT__)
    mmi_ivex_check_file_drm_right(&img_info);
#endif
    /* limitation check */
    if (img_info.result >= MMI_IVEX_IMG_HEALTH_OK){
        if(mmi_fmgr_util_file_limit_check3(FMGR_LIMIT_IMAGE_VIEWER, img_info.filepath, NULL, FMGR_GROUP_IMAGE))
        {
            img_info.result = MMI_IVEX_IMG_HEALTH_ERROR;
        }
    }

    if(img_info.result == MMI_IVEX_IMG_HEALTH_OK) {
        return MMI_TRUE;
    }
    else {
        return MMI_FALSE;
    }
}

#endif /* __MMI_SNS_PHOTO_UPLOAD__ */

#endif /* __MMI_IMAGE_VIEWER_EX__ */

