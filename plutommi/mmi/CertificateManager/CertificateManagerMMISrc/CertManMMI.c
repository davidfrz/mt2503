/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*******************************************************************************
 *  Modification Notice:
 *  --------------------------
 *  This software is modified by MediaTek Inc. and the information contained
 *  herein is confidential. The software may not be copied and the information
 *  contained herein may not be used or disclosed except with the written
 *  permission of MediaTek Inc. (C) 2001
 *
 *******************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  CertManMMI.c
 *
 * Project:
 * --------
 *  Certificate Manager
 *
 * Description:
 * ------------
 *   This file is intends for Certificate Manager MMI
 *
 * Author:
 * ------------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *============================================================================== 
************************************************************************************/
#ifdef __PLUTO_MMI_PACKAGE__ 
#ifdef __CERTMAN_SUPPORT__
#include "ctype.h"      /* Is space */
#include "kal_release.h"
#include "MMIDataType.h"
#include "kal_trace.h"
#include "CertManMMIGProts.h"
#include "CertManMMIResDef.h"
#include "CertManMMITypes.h"
#include "CertManMMIProts.h"
#include "FSEditorCuiGprot.h"
#include "mmi_rp_app_mmi_certman_def.h"
#include "GlobalResDef.h"
#include "certman_defs.h"
#include "kal_general_types.h"
#include "mmi_frm_events_gprot.h"
#include "MMI_inet_app_trc.h"
#include "DebugInitDef_Int.h"
#include "string.h"
#include "custom_mmi_default_value.h"
#include "GlobalConstants.h"
#include "CustDataRes.h"
#include "Unicodexdcl.h"
#include "certman_struct.h"
#include "certman_api.h"
#include "AlertScreen.h"
#include "gui_data_types.h"
#include "mmi_frm_history_gprot.h"
#include "custpack_certs.h"
#include "kal_public_api.h"
#include "stack_config.h"

extern int  certman_cfg_get_num_cert_in_database(void);
extern kal_int8 mmi_dmui_is_phone_lock(void);
extern MMI_BOOL mmi_scr_locker_is_locked(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_init
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __OCSP_SUPPORT__
    U8* temp;
    S32 len;
#endif /*__OCSP_SUPPORT__*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_set_protocol_events();
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_INIT);
    mmi_certman_mem_init();
    g_mmi_certman_context.curr_handle_value = 0;
#ifdef __OCSP_SUPPORT__
    mmi_certman_read_nvram_settings();

    /* set ocsp setting to certman. Set NULL if memory allocation fails */
    len = mmi_ucs2strlen((S8*)g_mmi_certman_context.default_ocsp_responder);
    if (len>0)
    {
        temp = mmi_certman_malloc(len+1);
        if (temp!=NULL)
        {
            mmi_ucs2_to_asc((S8*)temp, (S8*)g_mmi_certman_context.default_ocsp_responder);
            mmi_certman_send_ocsp_settings(temp);
            mmi_certman_free(temp);
            return;
        }
    }
    mmi_certman_send_ocsp_settings(NULL);
    certman_ocsp_set_default_id((U16)STR_ID_CERTIFICATE_MANAGER, (U16)IMG_ID_CERTMAN_CERT_MANAGER);
#endif /*__OCSP_SUPPORT__*/
}

#ifdef __OCSP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_certman_send_ocsp_settings
 * DESCRIPTION
 *  Sets the ocsp settings to certman core
 * PARAMETERS
 *  URL  [IN]  Default OCSP responder
 * RETURNS
 *  certman_error_enum
 *****************************************************************************/
certman_error_enum mmi_certman_send_ocsp_settings(U8* url)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    certman_error_enum error;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_SEND_OCSP_SETTINGS, url);
    if (g_mmi_certman_context.selected_ocsp_option == MMI_CERTMAN_OCSP_ON)
    {
        error = certman_ocsp_set_config(1, 0, (S8*)url);
    }
    else if (g_mmi_certman_context.selected_ocsp_option == MMI_CERTMAN_OCSP_OFF)
    {
        error = certman_ocsp_set_config(0, 0, (S8*)url);
    }
#ifdef __MMI_CERTMAN_OCSP_MUST_BE_PASSED_OPTION__
    else if (g_mmi_certman_context.selected_ocsp_option == MMI_CERTMAN_OCSP_MUST_BE_PASSED)
    {
        error = certman_ocsp_set_config(1, 1, (S8*)url);
    }
#endif /* __MMI_CERTMAN_OCSP_MUST_BE_PASSED_OPTION__ */
    else
    {
        error = certman_ocsp_set_config(1, 0, (S8*)url);
    }
    return error;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_read_nvram_settings
 * DESCRIPTION
 *  Read OCSP configuration settings from NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_read_nvram_settings(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 nvram_error;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ReadValue(NVRAM_CERTMAN_OCSP_SETTING, (U8*)&g_mmi_certman_context.selected_ocsp_option, 
              DS_BYTE, &nvram_error);
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_READ_NVRAM_CACHE_ERR, nvram_error);
    if (nvram_error != NVRAM_READ_SUCCESS)
    {   /* fail safe: use default value if read from NVRAM fails */
        g_mmi_certman_context.selected_ocsp_option = MMI_CERTMAN_OCSP_ON;
    }
	
    ReadRecord(NVRAM_EF_CERTMAN_OCSP_URL_LID, 1, g_mmi_certman_context.default_ocsp_responder, 
       NVRAM_EF_CERTMAN_OCSP_URL_SIZE, &nvram_error);
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_READ_NVRAM_CACHE_ERR, nvram_error);
    if(nvram_error!=NVRAM_READ_SUCCESS)
    {
        g_mmi_certman_context.default_ocsp_responder[0] = '\0';
        g_mmi_certman_context.default_ocsp_responder[1] = '\0';
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_write_nvram_settings
 * DESCRIPTION
 *  Write OCSP configuration settings to NVRAM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMINVRAMERRORSENUM mmi_certman_write_nvram_settings(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 nvram_error;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_WRITE_NVRAM_OCSP_SETTINGS);
    WriteValue(NVRAM_CERTMAN_OCSP_SETTING, (U8*)&g_mmi_certman_context.selected_ocsp_option, 
              DS_BYTE, &nvram_error);
    if (nvram_error != NVRAM_WRITE_SUCCESS)
    {
        return nvram_error;
    }
    WriteRecord(NVRAM_EF_CERTMAN_OCSP_URL_LID, 1, g_mmi_certman_context.default_ocsp_responder, 
               NVRAM_EF_CERTMAN_OCSP_URL_SIZE, &nvram_error);
    return nvram_error;
}
#endif /*__OCSP_SUPPORT__*/
/**************************************************************************/
/*****************************IMPORT CERTIFICATES**************************/
/**************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_init
 * DESCRIPTION
 *  functiom to init import
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_init(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_install_cert_ind_struct *install_certificate_ind = (mmi_certman_install_cert_ind_struct*) msg;

    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_IMPORT_INIT);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetProtocolEventHandler(mmi_certman_parse_begin_cnf_handler, MSG_ID_CERTMAN_PARSE_BEGIN_CNF);
    SetProtocolEventHandler(mmi_certman_certificates_detail_cnf_handler, MSG_ID_CERTMAN_PARSE_CERT_DETAIL_CNF);
    SetProtocolEventHandler(mmi_certman_import_cnf_handler, MSG_ID_CERTMAN_IMPORT_CNF);
    SetProtocolEventHandler(mmi_certman_send_parse_end_cnf_handler, MSG_ID_CERTMAN_PARSE_END_CNF);
    mmi_cermtan_entry_import();
    g_mmi_certman_context.import_context_p = mmi_certman_malloc(sizeof(mmi_certman_import_context_struct));

    if (g_mmi_certman_context.import_context_p == NULL)
    {
        mmi_certman_handle_error_with_callback(CERTMAN_ERR_MEMFULL, mmi_certman_import_grp_close_callback,(MMI_ID)MMI_CERTMAN_IMPORT);
        return;
    }
    g_mmi_certman_context.current_status = MMI_CERTMAN_IMPORT;
    /* Generate new trans_id to differentiate between different responses received from core.
       trans_id supplied by applications cannot be used as it may be duplicated */
    g_mmi_certman_context.import_context_p->ext_trans_id = install_certificate_ind->trans_id;
    g_mmi_certman_context.import_context_p->trans_id = mmi_certman_new_handle();
    mmi_certman_start_import((void*)install_certificate_ind->cert_filename);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_exit_from_import_with_gobackhistory
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_exit_from_import_with_gobackhistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_exit_from_import();
    mmi_certman_read_queue_task_if_present();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_grp_close_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_grp_close_callback(void)
{
    mmi_frm_group_close(GRP_ID_CERTMAN_IMPORT);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_select_grp_close_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_select_grp_close_callback(void)
{
    mmi_frm_group_close(GRP_ID_CERTMAN_SELECT);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_launch_grp_close_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_launch_grp_close_callback(void)
{
    mmi_frm_group_close(GRP_ID_CERTMAN_LAUNCH);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_lview_grp_close_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_view_grp_close_callback(void)
{
    mmi_frm_group_close(GRP_ID_CERTMAN_VIEW);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_invalid_grp_close_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_invalid_grp_close_callback(void)
{
    mmi_frm_group_close(GRP_ID_CERTMAN_INVALID);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_state
 * DESCRIPTION
 *  functions for import's state
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_state(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 error;
    certman_encoding_enum encoding_type = CERTMAN_ENC_UNSUPPORTED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_IMPORT_STATE, g_mmi_certman_context.import_context_p->current_state);
    switch (g_mmi_certman_context.import_context_p->current_state)
    {
        case MMI_CERTMAN_IMPORT_IDLE:
        {
            U8 *filename_p;

            filename_p = (U8*) msg;
            error = certman_parse_get_encoding_type_by_file((kal_wchar*) filename_p, &encoding_type);
            if (error != CERTMAN_ERR_NONE)
            {
                mmi_certman_handle_error_with_callback((certman_error_enum)error, mmi_certman_import_grp_close_callback, (MMI_ID)GRP_ID_CERTMAN_IMPORT);
                break;
            }
            error = certman_ctx_parse_new_by_file(
                        (kal_wchar*) filename_p,
                        encoding_type,
                        &(g_mmi_certman_context.import_context_p->ctx_parse_p));

            if (error != CERTMAN_ERR_NONE)
            {
                mmi_certman_handle_error_with_callback((certman_error_enum)error, mmi_certman_import_grp_close_callback, (MMI_ID)GRP_ID_CERTMAN_IMPORT);
                break;
            }
            g_mmi_certman_context.import_context_p->count = 0;
            g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_CHECK_ENCODING;
            mmi_certman_import_state(&encoding_type);
        }
            break;
        case MMI_CERTMAN_IMPORT_CHECK_ENCODING:
            encoding_type = *((certman_encoding_enum*) msg);
            g_mmi_certman_context.import_context_p->file_encoding = (certman_error_enum)encoding_type;
            if (encoding_type == CERTMAN_ENC_PK12)
            {
                g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_GET_DECR_PWD;
                mmi_certman_import_state(NULL);
            }
            else
            {
                mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
                g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_PARSING;
                certman_send_parse_begin_req(
                    MOD_MMI,
                    g_mmi_certman_context.import_context_p->trans_id,
                    g_mmi_certman_context.import_context_p->ctx_parse_p);
            }
            break;
        case MMI_CERTMAN_IMPORT_GET_DECR_PWD:
            mmi_certman_pre_entry_get_decryption_password();
            break;

        case MMI_CERTMAN_IMPORT_PARSING:
        {
            U16 temp_count = 0;
            certman_parse_begin_cnf_struct *parsed_begin_cnf_p;

            parsed_begin_cnf_p = (certman_parse_begin_cnf_struct*) msg;
            g_mmi_certman_context.import_context_p->job_id = parsed_begin_cnf_p->job_id;
            g_mmi_certman_context.import_context_p->trans_id = parsed_begin_cnf_p->trans_id;
            if (parsed_begin_cnf_p->status == CERTMAN_ERR_INCORRECT_PASSWORD)
            {
                mmi_certman_handle_error_with_callback(
                    parsed_begin_cnf_p->status,
                    mmi_certman_import_incorrect_pwd_continue,
                    GRP_ID_CERTMAN_IMPORT);
                return;
            }
            /* Now that password has been verified, close the editor CUI MAUI_02441916 */
            else if (g_mmi_certman_context.import_context_p->file_encoding == CERTMAN_ENC_PK12)
            {
                cui_fseditor_close(g_mmi_certman_context.import_context_p->fseditor->id);
                mmi_certman_free(g_mmi_certman_context.import_context_p->fseditor);
                g_mmi_certman_context.import_context_p->fseditor = NULL;
            }
            if (parsed_begin_cnf_p->status != CERTMAN_ERR_NONE)
            {
                mmi_certman_handle_error_with_callback(
                    parsed_begin_cnf_p->status,
                    mmi_certman_import_grp_close_callback,
                    GRP_ID_CERTMAN_IMPORT);
                return;
            }

            certman_ctx_parse_free(g_mmi_certman_context.import_context_p->ctx_parse_p);
            g_mmi_certman_context.import_context_p->cert_total =
                parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_ALL].cert_count;

            ASSERT(g_mmi_certman_context.import_context_p->cert_total <= CERTMAN_NUM_PARSED_CERT);

            for (temp_count = 0; temp_count < g_mmi_certman_context.import_context_p->cert_total; temp_count++)
            {
                g_mmi_certman_context.import_context_p->cert_ref_ids[temp_count] =
                    parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_ALL].cert_ref_ids[temp_count];
            }
            if ((parsed_begin_cnf_p->num_private_key) > 0)
            {
                g_mmi_certman_context.import_context_p->num_priv_key = parsed_begin_cnf_p->num_private_key;
                g_mmi_certman_context.import_context_p->num_authority_cert =
                    parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_ROOTCA].cert_count +
                    parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_OTHERCA].cert_count;
                g_mmi_certman_context.import_context_p->num_user_cert =
                    parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_OTHERUSER].cert_count +
                    parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_PERSONAL].cert_count;
                g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DISPLAY_FILE_INFO;
                mmi_certman_import_state(NULL);
            }
            else
            {
                g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
                mmi_certman_import_state(NULL);
            }
        }
            break;
        case MMI_CERTMAN_IMPORT_DISPLAY_FILE_INFO:
            mmi_certman_pre_entry_display_file_info();
            break;
        case MMI_CERTMAN_IMPORT_DETAIL_REQUEST:
            mmi_certman_certificates_detail();
            break;
        case MMI_CERTMAN_IMPORT_DISPLAY:
        {
            certman_parse_cert_detail_cnf_struct *cert_detail_p = (certman_parse_cert_detail_cnf_struct*) msg;

            if (cert_detail_p->status == CERTMAN_ERR_NONE)
            {
                mmi_certman_pre_entry_display_certificate_contents();
            }
            else
            {
                certman_parsed_data_free(g_mmi_certman_context.import_context_p->parsed_data_p);
				g_mmi_certman_context.import_context_p->parsed_data_p = NULL;
                g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
                mmi_certman_handle_error_with_callback(cert_detail_p->status, mmi_certman_import_state_with_null, GRP_ID_CERTMAN_IMPORT);
            }
        }
            break;
        case MMI_CERTMAN_IMPORT_GET_CERT_INFO:
if(g_mmi_certman_context.import_context_p->parsed_data_p){
            g_mmi_certman_context.import_context_p->key_purpose =
                g_mmi_certman_context.import_context_p->parsed_data_p->key_purposes;
            g_mmi_certman_context.import_context_p->key_purpose_all =
                g_mmi_certman_context.import_context_p->parsed_data_p->key_purposes;
           }
            if (g_mmi_certman_context.import_context_p->key_purpose_all == 0)
            {
                mmi_ucs2cpy((S8*) g_mmi_certman_context.show_string, (S8*) GetString(STR_GLOBAL_NONE));
            }
            else
            {
                mmi_ucs2cpy((S8*) g_mmi_certman_context.show_string, (S8*) GetString(STR_ID_CERTMAN_KP_ALL));
            }
            g_mmi_certman_context.import_context_p->protection_method = CERTMAN_PROTECT_NONE;
            mmi_certman_pre_entry_get_certificate_inputs();
            break;
        case MMI_CERTMAN_IMPORT_IMPORT:
        {
            certman_import_cnf_struct *import_cnf_p;

            import_cnf_p = (certman_import_cnf_struct*) msg;
            error = import_cnf_p->status;
            g_mmi_certman_context.import_context_p->cert_id = import_cnf_p->cert_id;

            if (error != CERTMAN_ERR_NONE)
            {
                if (error == CERTMAN_ERR_MEMFULL || error == CERTMAN_ERR_DISK_FULL
                    || error == CERTMAN_ERR_DISK_FULL || error == CERTMAN_ERR_INVALID_JOB
                    || error == CERTMAN_ERR_INVALID_CONTEXT || error == CERTMAN_ERR_FS_ERROR)
                {
                    mmi_certman_handle_error_with_callback(
                        (certman_error_enum)error,
                        mmi_certman_import_grp_close_callback,
                        (MMI_ID)GRP_ID_CERTMAN_IMPORT);
                    break;
                }
                else
                {
                    GoBackHistory();
                    certman_ctx_import_free(g_mmi_certman_context.import_context_p->ctx_import_p);
                    mmi_certman_handle_error_with_callback((certman_error_enum)error, mmi_certman_import_error, (MMI_ID)GRP_ID_CERTMAN_IMPORT);
                    break;
                }
            }
            certman_ctx_import_free(g_mmi_certman_context.import_context_p->ctx_import_p);
            g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_SET_KEY_PURPOSE;
            mmi_certman_display_message_with_callback(
                STR_ID_CERTMAN_CERTIFICATE_IMPORTED,
                MMI_EVENT_SUCCESS,
                mmi_certman_import_key_purpose_request,
                GRP_ID_CERTMAN_IMPORT);
            mmi_frm_scrn_close (GRP_ID_CERTMAN_IMPORT, SCR_ID_CERTMAN_PROGRESS_SCREEN);
        }
            break;
        case MMI_CERTMAN_IMPORT_SET_KEY_PURPOSE:
        {
            certman_update_key_purpose_cnf_struct *purpose_cnf_p;
            mmi_frm_scrn_multiple_close(
                GRP_ID_CERTMAN_IMPORT, 
                SCR_ID_CERTMAN_PROGRESS_SCREEN,
                MMI_TRUE,
                0,
                SCR_ID_CERTMAN_CERTIFICATE_INPUTS,
                MMI_TRUE);
            purpose_cnf_p = (certman_update_key_purpose_cnf_struct*) msg;
            error = purpose_cnf_p->status;
            mmi_certman_handle_error((certman_error_enum)error, (MMI_ID)GRP_ID_CERTMAN_IMPORT);
            g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
            mmi_certman_import_state(NULL);
        }
            break;

        case MMI_CERTMAN_IMPORT_END_PARSING:
        {
            certman_parse_end_cnf_struct *parse_end_cnf_p;

            parse_end_cnf_p = (certman_parse_end_cnf_struct*) msg;
            error = parse_end_cnf_p->status;
            break;
        }
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_invalid_error
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_invalid_error(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.current_status == MMI_CERTMAN_INVALID)
    {
        g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
        mmi_certman_pre_entry_progress_screen(g_mmi_certman_context.g_mmi_certman_active_grp);
        certman_send_parse_end_req(
            MOD_MMI,
            g_mmi_certman_context.view_invalid_context_p->trans_id,
            g_mmi_certman_context.view_invalid_context_p->job_id);

        mmi_certman_invalid_certificates_rsp(
            MMI_CERTMAN_INVALID_CERT_INSTALL,
            g_mmi_certman_context.view_invalid_context_p->trans_id);
        return;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_error
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_error(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GoBackHistory();
    if (g_mmi_certman_context.current_status == MMI_CERTMAN_INVALID)
    {
        g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
        mmi_certman_pre_entry_progress_screen(g_mmi_certman_context.g_mmi_certman_active_grp);
        certman_send_parse_end_req(
            MOD_MMI,
            g_mmi_certman_context.view_invalid_context_p->trans_id,
            g_mmi_certman_context.view_invalid_context_p->job_id);
    }
    else if (g_mmi_certman_context.current_status == MMI_CERTMAN_IMPORT)
    {
        g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
        mmi_certman_import_state(NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_check_decryption_pwd
 * DESCRIPTION
 *  function to check the decrytion password
 * PARAMETERS
 *  pwd     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_check_decryption_pwd(U8 *pwd)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 password[CERTMAN_PASSWORD_SIZE];
    certman_error_enum error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2_to_asc((S8*) password, (S8*) pwd);
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_CHECK_DECR_PWD);
    error = certman_parse_set_decrypt_password(g_mmi_certman_context.import_context_p->ctx_parse_p, password);
    if (error == CERTMAN_ERR_INVALID_PASSWORD)
    {
        g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_GET_DECR_PWD;
        mmi_certman_import_state(NULL);
        mmi_certman_handle_error(error, GRP_ID_CERTMAN_IMPORT);
        return;
    }
    if (error != CERTMAN_ERR_NONE)
    {
        mmi_certman_handle_error_with_callback(error, mmi_certman_import_grp_close_callback, GRP_ID_CERTMAN_IMPORT);
        return;
    }
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
    g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_PARSING;
    certman_send_parse_begin_req(
        MOD_MMI,
        g_mmi_certman_context.import_context_p->trans_id,
        g_mmi_certman_context.import_context_p->ctx_parse_p);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_certificates_detail
 * DESCRIPTION
 *  function for certifcate detail
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_certificates_detail(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 total;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_CERTIFICATES_DETAIL);
    total = certman_get_cert_count(CERTMAN_CERTGRP_NONE, CERTMAN_KP_NONE);
    if ((g_mmi_certman_context.import_context_p->count < g_mmi_certman_context.import_context_p->cert_total)
        && (total < MMI_CERTMAN_CERTIFICATES_MAX))
    {
        mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
        certman_send_parse_cert_detail_req(
            MOD_MMI,
            g_mmi_certman_context.import_context_p->trans_id,
            g_mmi_certman_context.import_context_p->job_id,
            g_mmi_certman_context.import_context_p->cert_ref_ids[g_mmi_certman_context.import_context_p->count]);
        g_mmi_certman_context.import_context_p->count++;
    }
    else
    {
        if (total >= MMI_CERTMAN_CERTIFICATES_MAX)
        {
            mmi_certman_display_message_with_callback(
                STR_ID_CERTMAN_MAX_LIMIT,
                MMI_EVENT_PROPLEM,
                mmi_certman_import_grp_close_callback,
                GRP_ID_CERTMAN_IMPORT);
        }
        else
        {
            mmi_frm_group_close(GRP_ID_CERTMAN_IMPORT);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_finish_import
 * DESCRIPTION
 *  function to finish the import
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_finish_import(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
    g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_END_PARSING;
    certman_send_parse_end_req(
        MOD_MMI,
        g_mmi_certman_context.import_context_p->trans_id,
        g_mmi_certman_context.import_context_p->job_id);
    mmi_certman_read_queue_task_if_present();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_deinit
 * DESCRIPTION
 *  function to deinit the import
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.import_context_p)
    {
        certman_parsed_data_free(g_mmi_certman_context.import_context_p->parsed_data_p);
		g_mmi_certman_context.import_context_p->parsed_data_p = NULL;
        mmi_certman_free(g_mmi_certman_context.import_context_p);
        g_mmi_certman_context.import_context_p = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_start_import
 * DESCRIPTION
 *  function to start import
 * PARAMETERS
 *  filename        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_start_import(void *filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_IDLE;
    mmi_certman_import_state(filename);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_key_purpose_request
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_key_purpose_request(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* GoBackHistory(); */
    SetProtocolEventHandler(mmi_certman_import_update_key_purpose_cnf_handler, MSG_ID_CERTMAN_UPDATE_KEY_PURPOSE_CNF);
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
    certman_send_update_key_purpose_req(
        MOD_MMI,
        g_mmi_certman_context.import_context_p->trans_id,
        g_mmi_certman_context.import_context_p->cert_id,
        g_mmi_certman_context.import_context_p->key_purpose);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_check_label
 * DESCRIPTION
 *  function to check label
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_check_label(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    certman_error_enum error;
    U8* temp_label;
    /* U8 label[CERTMAN_LABEL_SIZE]; */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_CHECK_LABEL);
    /* if given file is PKCS#12 and private key is password protected) */
    if (g_mmi_certman_context.import_context_p->protection_method == CERTMAN_PROTECT_USAGE_PASSWORD)
    {
        /* If private key pwd and confirm pwd are not equal */
        if (mmi_ucs2cmp(
                (PS8) g_mmi_certman_context.import_context_p->privatekey_pwd,
                (PS8) g_mmi_certman_context.import_context_p->privatekey_cnf_pwd))
        {
            memset(
                g_mmi_certman_context.import_context_p->privatekey_pwd,
                0,
                sizeof(g_mmi_certman_context.import_context_p->privatekey_pwd));
            memset(
                g_mmi_certman_context.import_context_p->privatekey_cnf_pwd,
                0,
                sizeof(g_mmi_certman_context.import_context_p->privatekey_cnf_pwd));
            mmi_popup_display((WCHAR*)((PU16)GetString((U16)STR_ID_CERTMAN_MISMATCHED)), MMI_EVENT_ERROR, NULL);
            return;
        }
    }
    temp_label = mmi_certman_left_trim_label(g_mmi_certman_context.import_context_p->certificate_label);
    error = certman_import_check_label_exists(temp_label, CERTMAN_DCS_UCS2);
    if (!error)
    {    
        mmi_ucs2cpy(
            (S8*) g_mmi_certman_context.import_context_p->certificate_label,
            (S8*) temp_label);
    }
    switch (error)
    {
        case CERTMAN_ERR_LABEL_EXISTS:
            mmi_certman_handle_error(error, g_mmi_certman_context.g_mmi_certman_active_grp);
            break;
        case CERTMAN_ERR_INVALID_LABEL:
            mmi_certman_handle_error(error, g_mmi_certman_context.g_mmi_certman_active_grp);
            break;
        default:

            error = certman_ctx_import_new(
                        g_mmi_certman_context.import_context_p->job_id,
                        g_mmi_certman_context.import_context_p->cert_ref_ids[g_mmi_certman_context.import_context_p->count - 1],
                        &(g_mmi_certman_context.import_context_p->ctx_import_p));

            error = certman_import_set_label(
                        g_mmi_certman_context.import_context_p->ctx_import_p,
                        g_mmi_certman_context.import_context_p->certificate_label,
                        CERTMAN_DCS_UCS2);

            if (g_mmi_certman_context.import_context_p->cert_group == CERTMAN_CERTGRP_PERSONAL)
            {
                U8 temp_string[CERTMAN_PASSWORD_SIZE];

                mmi_ucs2_to_asc((S8*) temp_string, (S8*) g_mmi_certman_context.import_context_p->privatekey_pwd);
                error = certman_import_set_privkey_protection(
                            g_mmi_certman_context.import_context_p->ctx_import_p,
                            (certman_privkey_protection_enum)g_mmi_certman_context.import_context_p->protection_method,
                            temp_string);
                mmi_certman_handle_error(
                    error,
                    g_mmi_certman_context.import_context_p->inline_cui_id);
                if (error != CERTMAN_ERR_NONE)
                {
                    certman_ctx_import_free(g_mmi_certman_context.import_context_p->ctx_import_p);
                    break;
                }
            }

            ASSERT(error <= CERTMAN_ERR_NONE);
            g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_IMPORT;
            mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
            certman_send_import_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->ctx_import_p);
            cui_inline_close(g_mmi_certman_context.import_context_p->inline_cui_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_left_trim_label
 * DESCRIPTION
 *  function to trim string from left
 * PARAMETERS
 *  label       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
U8 *mmi_certman_left_trim_label(U8 *label)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 cntr = 0;
    U16 len = 0;
    U8 *temp_label = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_label = label;
    len = (mmi_ucs2strlen((S8*) label)) * ENCODING_LENGTH;
    while (isspace(temp_label[cntr]) && (temp_label[cntr + 1] == 0))
    {
        temp_label += ENCODING_LENGTH;
        if (cntr >= len)
        {
            break;
        }
    }
    return temp_label;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_exit_from_import
 * DESCRIPTION
 *  function to exit form import
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_exit_from_import(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 ext_trans_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_INET_TRC_G3_CER_MAN,
        MMI_CERTMAN_EXIT_FROM_IMPORT,
        g_mmi_certman_context.import_context_p->current_state,
        g_mmi_certman_context.import_context_p->current_state);
    if (g_mmi_certman_context.current_status != MMI_CERTMAN_IMPORT)
    {
        return;
    }
    ext_trans_id = g_mmi_certman_context.import_context_p->ext_trans_id;
    switch (g_mmi_certman_context.import_context_p->current_state)
    {
        case MMI_CERTMAN_IMPORT_IDLE:
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_CHECK_ENCODING:
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_GET_DECR_PWD:
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            certman_ctx_parse_free(g_mmi_certman_context.import_context_p->ctx_parse_p);
            if ((g_mmi_certman_context.import_context_p)&&(g_mmi_certman_context.import_context_p->fseditor))
            {   /* also close the editor CUI if exit in this state */
                cui_fseditor_close(g_mmi_certman_context.import_context_p->fseditor->id);
                mmi_certman_free(g_mmi_certman_context.import_context_p->fseditor);
                g_mmi_certman_context.import_context_p->fseditor = NULL;
            }
            break;
        case MMI_CERTMAN_IMPORT_PARSING:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            certman_ctx_parse_free(g_mmi_certman_context.import_context_p->ctx_parse_p);
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_DISPLAY_FILE_INFO:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_DETAIL_REQUEST:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_DISPLAY:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            certman_parsed_data_free(g_mmi_certman_context.import_context_p->parsed_data_p);
			g_mmi_certman_context.import_context_p->parsed_data_p = NULL;
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_GET_CERT_INFO:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_IMPORT:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            certman_ctx_import_free(g_mmi_certman_context.import_context_p->ctx_import_p);
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_SET_KEY_PURPOSE:
            certman_send_parse_end_req(
                MOD_MMI,
                g_mmi_certman_context.import_context_p->trans_id,
                g_mmi_certman_context.import_context_p->job_id);
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            break;
        case MMI_CERTMAN_IMPORT_END_PARSING:
            mmi_certman_install_certificates_rsp(MMI_TRUE, ext_trans_id);
            break;
        default:
            mmi_certman_install_certificates_rsp(MMI_FALSE, ext_trans_id);
            return;
    }
    mmi_certman_import_deinit();
    g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_exit_from_select_launch
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_exit_from_select_launch(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 trans_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.current_status != MMI_CERTMAN_SELECT &&
        g_mmi_certman_context.current_status != MMI_CERTMAN_LAUNCH)
    {
        return;
    }
    trans_id = g_mmi_certman_context.launch_select_context_p->trans_id;
    if (g_mmi_certman_context.current_status == MMI_CERTMAN_SELECT)
    {
        switch (g_mmi_certman_context.launch_select_context_p->current_state)
        {
            case MMI_CERTMAN_LAUNCH_SELECT_VIEW_CERT:
                certman_cert_display_content_free(g_mmi_certman_context.launch_select_context_p->display_p);
                /* 20071108 Sanity Test Fail Tmp Patch */
                free_ctrl_buffer(g_mmi_certman_context.launch_select_context_p->display_p);
                g_mmi_certman_context.launch_select_context_p->display_p = 0;
                break;
        }
        mmi_certman_select_certificates_rsp(MMI_FALSE, 0, 0, trans_id);
    }
    else
    {
        mmi_certman_launch_certificates_rsp(MMI_FALSE, trans_id);
    }
    mmi_certman_launch_deinit();
    g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
    mmi_certman_read_queue_task_if_present();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_get_no_of_private_keys
 * DESCRIPTION
 *  function to get no. of private keys
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U16 mmi_certman_get_no_of_private_keys(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_mmi_certman_context.import_context_p->num_priv_key;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_get_no_of_authority_certificates
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U16 mmi_certman_get_no_of_authority_certificates(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_mmi_certman_context.import_context_p->num_authority_cert;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_get_no_of_user_certificates
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U16 mmi_certman_get_no_of_user_certificates(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_mmi_certman_context.import_context_p->num_user_cert;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_save_file
 * DESCRIPTION
 *  function to save file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_save_file()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
    mmi_certman_import_state(NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_save_certificate
 * DESCRIPTION
 *  function to save certficate
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_save_certificate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_SAVE_CERTIFICATE);
   // mmi_frm_scrn_close (GRP_ID_CERTMAN_IMPORT, SCR_ID_CERTMAN_CERTIFICATE_DETAILS);
    if (g_mmi_certman_context.import_context_p->parsed_data_p->cert_exists != 0)
    {
        certman_parsed_data_free(g_mmi_certman_context.import_context_p->parsed_data_p);
		g_mmi_certman_context.import_context_p->parsed_data_p = NULL;
        g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
        mmi_certman_display_message_with_callback(
            STR_ID_CERTMAN_CERT_EXISTS,
            MMI_EVENT_ERROR,
            mmi_certman_save_file,
            GRP_ID_CERTMAN_IMPORT);
        return;
    }

    if (g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_COMMON_NAME])
    {
        mmi_certman_cert_strncpy(
            g_mmi_certman_context.import_context_p->certificate_label,
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_COMMON_NAME],
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.dcs[CERTMAN_NAMETYPE_COMMON_NAME],
            CERTMAN_LABEL_SIZE);
    }
    else if (g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_ORGANISATION])
    {
        mmi_certman_cert_strncpy(
            g_mmi_certman_context.import_context_p->certificate_label,
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_ORGANISATION],
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.dcs[CERTMAN_NAMETYPE_ORGANISATION],
            CERTMAN_LABEL_SIZE);
    }
    else if (g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.
             names[CERTMAN_NAMETYPE_ORGANISATION_UNIT])
    {
        mmi_certman_cert_strncpy(
            g_mmi_certman_context.import_context_p->certificate_label,
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_ORGANISATION_UNIT],
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.dcs[CERTMAN_NAMETYPE_ORGANISATION_UNIT],
            CERTMAN_LABEL_SIZE);
    }
    else if (g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_TITLE])
    {
        mmi_certman_cert_strncpy(
            g_mmi_certman_context.import_context_p->certificate_label,
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_TITLE],
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.dcs[CERTMAN_NAMETYPE_TITLE],
            CERTMAN_LABEL_SIZE);
    }
    else if (g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_GIVEN_NAME])
    {
        mmi_certman_cert_strncpy(
            g_mmi_certman_context.import_context_p->certificate_label,
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.names[CERTMAN_NAMETYPE_GIVEN_NAME],
            g_mmi_certman_context.import_context_p->parsed_data_p->cert.subject.dcs[CERTMAN_NAMETYPE_GIVEN_NAME],
            CERTMAN_LABEL_SIZE);
    }
    g_mmi_certman_context.import_context_p->cert_group =
        g_mmi_certman_context.import_context_p->parsed_data_p->cert_group;

   // certman_parsed_data_free(g_mmi_certman_context.import_context_p->parsed_data_p);
    g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_GET_CERT_INFO;
    mmi_certman_import_state(NULL);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_discard_certificate
 * DESCRIPTION
 *  function to discard certiifcate
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_discard_certificate(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* GoBackHistory(); */
    mmi_frm_scrn_close (GRP_ID_CERTMAN_IMPORT, SCR_ID_CERTMAN_CERTIFICATE_DETAILS);
    certman_parsed_data_free(g_mmi_certman_context.import_context_p->parsed_data_p);
    g_mmi_certman_context.import_context_p->parsed_data_p = NULL;
    g_mmi_certman_context.import_context_p->current_state = MMI_CERTMAN_IMPORT_DETAIL_REQUEST;
    mmi_certman_import_state(NULL);
}

/**************************************************************************/
/*****************************lAUNCH /SELECT CERTIFICATES******************/
/**************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_launch_init
 * DESCRIPTION
 *  init function for launch
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_launch_init(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 max_certificate_num;
    mmi_certman_launch_cert_ind_struct *launch_certificate_ind = (mmi_certman_launch_cert_ind_struct*) msg;

    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_LAUNCH_INIT);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Launch & Select */
    SetProtocolEventHandler(mmi_certman_get_cert_list_by_group_cnf_handler, MSG_ID_CERTMAN_GET_CERT_LIST_BY_GROUP_CNF);
    SetProtocolEventHandler(mmi_certman_send_get_cert_disp_by_id_cnf_handler, MSG_ID_CERTMAN_GET_CERT_DISP_BY_ID_CNF);
    SetProtocolEventHandler(mmi_certman_send_delete_cert_cnf_handler, MSG_ID_CERTMAN_DELETE_CERT_CNF);

    g_mmi_certman_context.launch_select_context_p = mmi_certman_malloc(sizeof(mmi_certman_launch_select_context_struct));
    
    max_certificate_num = certman_cfg_get_num_cert_in_database();
	g_mmi_certman_context.launch_select_context_p->is_selected= (kal_uint8*)mmi_certman_malloc(sizeof(kal_uint8)*max_certificate_num);
	g_mmi_certman_context.launch_select_context_p->certificate_list= (mmi_certman_certificate_list_struct*)mmi_certman_malloc(sizeof(mmi_certman_certificate_list_struct)*max_certificate_num);
	
    mmi_certman_entry_launch_group();
    if (g_mmi_certman_context.launch_select_context_p == NULL)
    {
        mmi_certman_handle_error_with_callback(
            CERTMAN_ERR_MEMFULL,
            mmi_certman_launch_grp_close_callback ,
            GRP_ID_CERTMAN_LAUNCH);
        return;

    }
    g_mmi_certman_context.launch_select_context_p->trans_id = launch_certificate_ind->trans_id;
    g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_IDLE;
    
    /* ask for all key types */
    g_mmi_certman_context.launch_select_context_p->key_type =MMI_CERTMAN_CERT_TYPE_ALL;
    g_mmi_certman_context.current_status = MMI_CERTMAN_LAUNCH;
    mmi_certman_launch_select_state(NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_launch_deinit
 * DESCRIPTION
 *  deinit function for launch
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_launch_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_free(g_mmi_certman_context.launch_select_context_p->is_selected);
	  mmi_certman_free(g_mmi_certman_context.launch_select_context_p->certificate_list);
	
    mmi_certman_free(g_mmi_certman_context.launch_select_context_p);
    g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_select_init
 * DESCRIPTION
 *  init function for select
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_select_init(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 max_certificate_num;
    mmi_certman_select_cert_ind_struct *select_certificate_ind = (mmi_certman_select_cert_ind_struct*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_SELECT_INIT);
    SetProtocolEventHandler(mmi_certman_get_cert_list_by_group_cnf_handler, MSG_ID_CERTMAN_GET_CERT_LIST_BY_GROUP_CNF);
    SetProtocolEventHandler(mmi_certman_send_get_cert_disp_by_id_cnf_handler, MSG_ID_CERTMAN_GET_CERT_DISP_BY_ID_CNF);

    g_mmi_certman_context.launch_select_context_p = mmi_certman_malloc(sizeof(mmi_certman_launch_select_context_struct));
    
    max_certificate_num = certman_cfg_get_num_cert_in_database();
	g_mmi_certman_context.launch_select_context_p->certificate_list = (mmi_certman_certificate_list_struct*)mmi_certman_malloc(sizeof(mmi_certman_certificate_list_struct)*max_certificate_num);
	g_mmi_certman_context.launch_select_context_p->is_selected= (U8*)mmi_certman_malloc(sizeof(U8)*max_certificate_num);
	
    mmi_certman_entry_select_group();
    if (g_mmi_certman_context.launch_select_context_p == NULL)
    {
        mmi_certman_handle_error_with_callback(
            CERTMAN_ERR_MEMFULL,
            mmi_certman_select_grp_close_callback,
            GRP_ID_CERTMAN_SELECT);
        return;
    }
    g_mmi_certman_context.launch_select_context_p->certificate_count = 0;
    g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_GROUP_REQ;
    g_mmi_certman_context.current_status = MMI_CERTMAN_SELECT;
    switch (select_certificate_ind->cert_group)
    {
        case MMI_CERTMAN_CERT_GROUP_ALL:
            g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_NONE;
            break;
        case MMI_CERTMAN_CERT_GROUP_ROOT_CA:
            g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_ROOTCA;
            break;
        case MMI_CERTMAN_CERT_GROUP_INTERMEDIATE_CA:
            g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_CA;
            break;
        case MMI_CERTMAN_CERT_GROUP_AUTHORITY:
            g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_ROOTCA | CERTMAN_CERTGRP_CA;
            break;
        case MMI_CERTMAN_CERT_GROUP_OTHER_USER:
            g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_OTHERUSER;
            break;
        case MMI_CERTMAN_CERT_GROUP_PERSONAL:
            g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_PERSONAL;
            break;
        case MMI_CERTMAN_CERT_GROUP_USER:
            g_mmi_certman_context.launch_select_context_p->cert_group =
                CERTMAN_CERTGRP_OTHERUSER | CERTMAN_CERTGRP_PERSONAL;
            break;
    }
    g_mmi_certman_context.launch_select_context_p->key_type = select_certificate_ind->key_type;
    g_mmi_certman_context.launch_select_context_p->multiple_selection_flag =
        select_certificate_ind->multiple_selection_flag;
    g_mmi_certman_context.launch_select_context_p->trans_id = select_certificate_ind->trans_id;

    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_SELECT);
    mmi_certman_launch_select_state(NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_launch_select_state
 * DESCRIPTION
 *  function for the state of knowing the state fo launch/select
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_launch_select_state(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 more = 0;

    /* certman_encoding_enum encoding_type = 0; */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_INET_TRC_G3_CER_MAN,
        MMI_CERTMAN_LAUNCH_SELECT_STATE,
        g_mmi_certman_context.launch_select_context_p->current_state);

    switch (g_mmi_certman_context.launch_select_context_p->current_state)
    {
        case MMI_CERTMAN_LAUNCH_SELECT_IDLE:
            mmi_certman_launch_scr_entry();
            break;
        case MMI_CERTMAN_LAUNCH_SELECT_GROUP_REQ:
            more = (kal_uint32) msg;
            g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_CREATE_LIST;

            certman_send_get_cert_list_by_group_req(
                MOD_MMI,
                g_mmi_certman_context.launch_select_context_p->trans_id,
                g_mmi_certman_context.launch_select_context_p->cert_group,
                CERTMAN_KP_NONE,
                g_mmi_certman_context.launch_select_context_p->key_type,
                more);
            break;
        case MMI_CERTMAN_LAUNCH_SELECT_CREATE_LIST:
        {
            certman_get_cert_list_by_group_cnf_struct *group_cnf;

            group_cnf = (certman_get_cert_list_by_group_cnf_struct*) msg;

            if (g_mmi_certman_context.current_status == MMI_CERTMAN_LAUNCH)
            {
                mmi_certman_handle_error_with_callback(
                    group_cnf->status,
                    mmi_certman_launch_grp_close_callback,
                    g_mmi_certman_context.g_mmi_certman_active_grp);
            }
            else
            {
                mmi_certman_handle_error_with_callback(
                    group_cnf->status,
                    mmi_certman_select_grp_close_callback,
                    g_mmi_certman_context.g_mmi_certman_active_grp);            
            }
            if (group_cnf->status == CERTMAN_ERR_MEMFULL)
            {
                break;
            }

            if (group_cnf->more > 0)
            {
                mmi_certman_update_certificate_list(group_cnf);
                g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_GROUP_REQ;
                mmi_certman_launch_select_state((void*)group_cnf->more);
                break;
            }
            else
            {
                mmi_certman_update_certificate_list(group_cnf);
                g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_DISPLAY_LIST;
                mmi_certman_launch_select_state(NULL);
                break;
            }

        }
        case MMI_CERTMAN_LAUNCH_SELECT_DISPLAY_LIST:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_LAUNCH)
            {
                mmi_certman_pre_entry_display_certificate_list();

            }
            else if (g_mmi_certman_context.current_status == MMI_CERTMAN_SELECT)
            {
                mmi_certman_pre_entry_certificates_selection_list();
            }
            return;
        case MMI_CERTMAN_LAUNCH_SELECT_VIEW_CERT:
        {
            certman_get_cert_disp_by_id_cnf_struct *disp_cnf = (certman_get_cert_disp_by_id_cnf_struct*) msg;

            if (disp_cnf->status == CERTMAN_ERR_NONE)
            {

                mmi_certman_pre_entry_view_certificate_content();
            }
            else
            {
                /* test this case in IT*/
                /*if (MMI_TRUE == mmi_certman_check_screen_in_history())
                {
                    mmi_certman_handle_error_with_callback(disp_cnf->status, GoBackHistory);
                }
                else
                {
                    mmi_certman_handle_error(disp_cnf->status);
                }*/
                mmi_certman_handle_error_with_callback(disp_cnf->status, GoBackHistory, g_mmi_certman_context.g_mmi_certman_active_grp);
            }
        }
            break;
        default:
            ASSERT(0);

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_display_authority_certificates
 * DESCRIPTION
 *  function to initialize for authority certificates
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_display_authority_certificates(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 more = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_DISPLAY_AUTHORITY_CERTIFICATES);
    g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_ROOTCA 
                                                              | CERTMAN_CERTGRP_CA
                                                              | CERTMAN_CERTGRP_OTHERUSER;
    g_mmi_certman_context.popup_string_id = STR_ID_CERTMAN_AUTHORITY_CERT;
    g_mmi_certman_context.launch_select_context_p->certificate_count = 0;
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_LAUNCH);  

    g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_GROUP_REQ;
    mmi_certman_launch_select_state((void*)more);

}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_display_user_certificates
 * DESCRIPTION
 *  function to initialize for user certificates
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_display_user_certificates(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 more = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_certman_context.launch_select_context_p->cert_group = CERTMAN_CERTGRP_PERSONAL;
    g_mmi_certman_context.popup_string_id = STR_ID_CERTMAN_USER_CERT;
    g_mmi_certman_context.launch_select_context_p->certificate_count = 0;
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_LAUNCH);
    g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_GROUP_REQ;
    mmi_certman_launch_select_state((void*)more);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_update_certificate_list
 * DESCRIPTION
 *  function to update list
 * PARAMETERS
 *  group_cnf       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_update_certificate_list(certman_get_cert_list_by_group_cnf_struct *group_cnf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_INET_TRC_G3_CER_MAN,
        MMI_CERTMAN_UPDATE_CERTIFICATE_LIST,
        g_mmi_certman_context.launch_select_context_p->current_state);
    ASSERT(group_cnf->size <= CERTMAN_NUM_CERT_IN_LIST);
    for (count = 0; count < group_cnf->size; count++)
    {
        if (g_mmi_certman_context.launch_select_context_p->certificate_count >= MMI_CERTMAN_CERTIFICATES_MAX)
        {
            g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_DISPLAY_LIST;
            mmi_certman_launch_select_state(NULL);
            break;
        }

        g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->
                                                                        certificate_count].cert_id =
            group_cnf->cert_list[count].id;
        g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->
                                                                        certificate_count].cert_group =
            group_cnf->cert_list[count].group;
        g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->
                                                                        certificate_count].key_purpose =
            group_cnf->cert_list[count].key_purpose_allowed;
        g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->
                                                                        certificate_count].key_purpose_all =
            group_cnf->cert_list[count].key_purpose_all;
        g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->
                                                                        certificate_count].cert_prop =
            group_cnf->cert_list[count].properties;

        g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->
                                                                        certificate_count].certificate_dcs =
            group_cnf->cert_list[count].dcs;

        memcpy(
            g_mmi_certman_context.launch_select_context_p->certificate_list[g_mmi_certman_context.launch_select_context_p->certificate_count].cert_label,
            group_cnf->cert_list[count].label,
            CERTMAN_LABEL_SIZE);
        g_mmi_certman_context.launch_select_context_p->certificate_count++;

        ASSERT(g_mmi_certman_context.launch_select_context_p->certificate_count <= MMI_CERTMAN_CERTIFICATES_MAX);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_view_certificates
 * DESCRIPTION
 *  function to send request for certificate contents
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_view_certificates(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 index = g_mmi_certman_context.launch_select_context_p->selected_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_LAUNCH); 
    certman_send_get_cert_disp_by_id_req(
        MOD_MMI,
        g_mmi_certman_context.launch_select_context_p->trans_id,
        g_mmi_certman_context.launch_select_context_p->certificate_list[index].cert_id);

    g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_VIEW_CERT;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_delete_certificates
 * DESCRIPTION
 *  request to delete certificate
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_delete_certificates(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 index = g_mmi_certman_context.launch_select_context_p->selected_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_mmi_certman_context.string_status = MMI_TRUE;
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_LAUNCH);
    g_mmi_certman_context.string_status = MMI_FALSE;
    certman_send_delete_cert_req(
        MOD_MMI,
        g_mmi_certman_context.launch_select_context_p->trans_id,
        g_mmi_certman_context.launch_select_context_p->certificate_list[index].cert_id);
}

/*********************************************************************************/
/*****************************PRIVATE KEY PASSWORD REQUEST ***********************/
/*********************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_privkey_usage_password_ind
 * DESCRIPTION
 *  function for private key password ind
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_privkey_usage_password_ind(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    certman_privkey_usage_password_ind_struct *privkey_usage_password
        = (certman_privkey_usage_password_ind_struct*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_PRIVATEKEY_USAGE_PASSWORD_IND);
    g_mmi_certman_context.private_key_status = MMI_CERTMAN_PRIVATE_KEY_PWD;
    g_mmi_certman_context.priv_key_context_p = mmi_certman_malloc(sizeof(mmi_certman_private_key_context_struct));
    if (g_mmi_certman_context.priv_key_context_p == NULL)
    {
        mmi_certman_handle_error(CERTMAN_ERR_MEMFULL, GRP_ID_CERTMAN_PRIV_KEY);
        g_mmi_certman_context.private_key_status = MMI_CERTMAN_PRIVATE_KEY_IDLE;
        mmi_certman_use_priv_key_queue();
        return;
    }
    g_mmi_certman_context.priv_key_context_p->trans_id = privkey_usage_password->trans_id;
    g_mmi_certman_context.priv_key_context_p->cert_id = privkey_usage_password->cert_id;
    mmi_certman_cert_strncpy(
        g_mmi_certman_context.priv_key_context_p->label,
        privkey_usage_password->label,
        privkey_usage_password->dcs,
        CERTMAN_LABEL_SIZE);
    g_mmi_certman_context.priv_key_context_p->pwd_callback = privkey_usage_password->pcb;
    switch (privkey_usage_password->state)
    {
        case CERTMAN_PWDAUTH_FIRST:
            mmi_certman_entry_priv_key_group();
            mmi_certman_pre_entry_get_priv_key_password();
            break;
        case CERTMAN_PWDAUTH_FAILED_RETRY_AGAIN:
            mmi_certman_display_message_with_callback(
                STR_ID_CERTMAN_INCORRECT_PASSWORD,
                MMI_EVENT_ERROR,
                mmi_certman_pre_entry_get_priv_key_password,
                GRP_ID_CERTMAN_PRIV_KEY);
            break;
        case CERTMAN_PWDAUTH_FAILED_ABORT:
            mmi_popup_display_simple((WCHAR*)((UI_string_type)GetString((U16)STR_ID_CERTMAN_INCORRECT_PASSWORD)), MMI_EVENT_ERROR, GRP_ID_CERTMAN_PRIV_KEY, NULL);
        case CERTMAN_PWDAUTH_SUCCEEDED:
            if (g_mmi_certman_context.priv_key_context_p)
            {
                mmi_certman_free(g_mmi_certman_context.priv_key_context_p);
                g_mmi_certman_context.priv_key_context_p = NULL;
            }
            g_mmi_certman_context.private_key_status = MMI_CERTMAN_PRIVATE_KEY_IDLE;
            mmi_certman_use_priv_key_queue();
            break;
        default:
            ASSERT(0);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_check_priv_key_pwd
 * DESCRIPTION
 *  function to check private key pwd
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_check_priv_key_pwd(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 temp_string[CERTMAN_PASSWORD_SIZE];
    U16 pwd_length;
    U32 trans_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_CHECK_PRIV_KEY_PWD);
    ASSERT(g_mmi_certman_context.priv_key_context_p != NULL);
    mmi_ucs2_to_asc((S8*) temp_string, (S8*) g_mmi_certman_context.priv_key_context_p->privatekey_pwd);
    pwd_length = strlen((S8*) temp_string);
    if (g_mmi_certman_context.priv_key_context_p->pwd_callback)
    {
        g_mmi_certman_context.priv_key_context_p->pwd_callback(
                                                    g_mmi_certman_context.priv_key_context_p->trans_id,
                                                    g_mmi_certman_context.priv_key_context_p->cert_id,
                                                    (kal_uint8*) temp_string,
                                                    pwd_length);
    }
    trans_id = g_mmi_certman_context.priv_key_context_p->trans_id;
    mmi_certman_free(g_mmi_certman_context.priv_key_context_p);
    g_mmi_certman_context.priv_key_context_p = NULL;
    certman_send_privkey_usage_password_rsp(MOD_MMI, trans_id, MMI_TRUE);
}

/***************************************************************************/
/*****************************PRIVATE KEY CONFIRMATION**********************/
/***************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_send_privkey_usage_confirm_ind
 * DESCRIPTION
 *  function to confirm private key
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_send_privkey_usage_confirm_ind(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    certman_privkey_usage_confirm_ind_struct *privkey_usage_confirm = (certman_privkey_usage_confirm_ind_struct*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_SEND_PRIVAKEY_CONFIRM_IND);
    g_mmi_certman_context.private_key_status = MMI_CERTMAN_PRIVATE_KEY_CONFIRM;
    g_mmi_certman_context.priv_key_context_p = mmi_certman_malloc(sizeof(mmi_certman_private_key_context_struct));
    if (g_mmi_certman_context.priv_key_context_p == NULL)
    {
        mmi_certman_handle_error(CERTMAN_ERR_MEMFULL, GRP_ID_CERTMAN_PRIV_KEY);
        g_mmi_certman_context.private_key_status = MMI_CERTMAN_PRIVATE_KEY_IDLE;
        mmi_certman_use_priv_key_queue();
        return;
    }
    g_mmi_certman_context.priv_key_context_p->trans_id = privkey_usage_confirm->trans_id;
    g_mmi_certman_context.priv_key_context_p->cert_id = privkey_usage_confirm->cert_id;
    mmi_certman_cert_strncpy(
        g_mmi_certman_context.priv_key_context_p->label,
        privkey_usage_confirm->label,
        privkey_usage_confirm->dcs,
        CERTMAN_LABEL_SIZE);
    mmi_certman_priv_key_confirmation();
}

/***************************************************************************/
/*****************************View Certificate******************************/
/***************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_view_init
 * DESCRIPTION
 *  
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_view_init(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_view_cert_ind_struct *view_certificate_ind = (mmi_certman_view_cert_ind_struct*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_VIEW_INIT);
    SetProtocolEventHandler(mmi_certman_parse_begin_cnf_handler, MSG_ID_CERTMAN_PARSE_BEGIN_CNF);
    SetProtocolEventHandler(mmi_certman_certificates_detail_cnf_handler, MSG_ID_CERTMAN_PARSE_CERT_DETAIL_CNF);
    SetProtocolEventHandler(mmi_certman_import_cnf_handler, MSG_ID_CERTMAN_IMPORT_CNF);
    SetProtocolEventHandler(mmi_certman_send_parse_end_cnf_handler, MSG_ID_CERTMAN_PARSE_END_CNF);

    g_mmi_certman_context.view_invalid_context_p = mmi_certman_malloc(sizeof(mmi_certman_view_invalid_context_struct));
    g_mmi_certman_context.current_status = MMI_CERTMAN_VIEW;
    mmi_certman_entry_view_group();
    if (g_mmi_certman_context.view_invalid_context_p == NULL)
    {
        mmi_certman_handle_error_with_callback(
            CERTMAN_ERR_MEMFULL,
            mmi_certman_view_grp_close_callback,
            GRP_ID_CERTMAN_VIEW);
        return;
    }
    g_mmi_certman_context.view_invalid_context_p->trans_id = view_certificate_ind->trans_id;
    g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_IDLE;
    mmi_certman_view_invalid_state((void*)view_certificate_ind->filename);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_invalid_certificate_init
 * DESCRIPTION
 *  
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_invalid_certificate_init(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_invalid_cert_ind_struct *invalid_certificate_ind = (mmi_certman_invalid_cert_ind_struct*) msg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_INVALID_CERTIFICATE_INIT);
    SetProtocolEventHandler(mmi_certman_parse_begin_cnf_handler, MSG_ID_CERTMAN_PARSE_BEGIN_CNF);
    SetProtocolEventHandler(mmi_certman_certificates_detail_cnf_handler, MSG_ID_CERTMAN_PARSE_CERT_DETAIL_CNF);
    SetProtocolEventHandler(mmi_certman_import_cnf_handler, MSG_ID_CERTMAN_IMPORT_CNF);
    SetProtocolEventHandler(mmi_certman_send_parse_end_cnf_handler, MSG_ID_CERTMAN_PARSE_END_CNF);

    g_mmi_certman_context.view_invalid_context_p = mmi_certman_malloc(sizeof(mmi_certman_view_invalid_context_struct));
    g_mmi_certman_context.current_status = MMI_CERTMAN_INVALID;
    mmi_certman_entry_invalid_group();

    if (g_mmi_certman_context.view_invalid_context_p == NULL)
    {
        mmi_certman_handle_error_with_callback(
            CERTMAN_ERR_MEMFULL,
            mmi_certman_invalid_grp_close_callback,
            GRP_ID_CERTMAN_INVALID);
        return;
    }
    g_mmi_certman_context.view_invalid_context_p->install_option = invalid_certificate_ind->disable_install_option;
    g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_IDLE;
    g_mmi_certman_context.view_invalid_context_p->error = invalid_certificate_ind->error;
    g_mmi_certman_context.view_invalid_context_p->trans_id = invalid_certificate_ind->trans_id;
    g_mmi_certman_context.view_invalid_context_p->mod_name = invalid_certificate_ind->mod_name;
    mmi_certman_view_invalid_state((void*)invalid_certificate_ind->cert_filename);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_view_invalid_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_view_invalid_state(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    certman_error_enum error = CERTMAN_ERR_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_INET_TRC_G3_CER_MAN,
        MMI_CERTMAN_VIEW_INVALID_STATE,
        g_mmi_certman_context.view_invalid_context_p->current_state);
    switch (g_mmi_certman_context.view_invalid_context_p->current_state)
    {
        case MMI_CERTMAN_VIEW_INVALID_IDLE:
        {
            U8 *filename;
            certman_encoding_enum encoding_type = CERTMAN_ENC_UNSUPPORTED;

            filename = (U8*) msg;
            error = certman_parse_get_encoding_type_by_file((kal_wchar*) filename, &encoding_type);
            if (error != CERTMAN_ERR_NONE)
            {
                if (g_mmi_certman_context.g_mmi_certman_active_grp == GRP_ID_CERTMAN_INVALID)
                {
                    mmi_certman_handle_error_with_callback(
                        error,
                        mmi_certman_invalid_grp_close_callback,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    break;
                }
                else
                {
                    mmi_certman_handle_error_with_callback(
                        error,
                        mmi_certman_view_grp_close_callback,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    break;
                }
            }
            error = certman_ctx_parse_new_by_file(
                        (kal_wchar*) filename,
                        encoding_type,
                        &(g_mmi_certman_context.view_invalid_context_p->ctx_parse_p));
            if (error != CERTMAN_ERR_NONE)
            {
                if (g_mmi_certman_context.g_mmi_certman_active_grp == GRP_ID_CERTMAN_INVALID)
                {
                    mmi_certman_handle_error_with_callback(
                        error,
                        mmi_certman_invalid_grp_close_callback,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    break;
                }
                else
                {
                    mmi_certman_handle_error_with_callback(
                        error,
                        mmi_certman_view_grp_close_callback,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    break;
                }
            }
            if (encoding_type == CERTMAN_ENC_DER)
            {
                mmi_certman_pre_entry_progress_screen(g_mmi_certman_context.g_mmi_certman_active_grp);
                certman_send_parse_begin_req(
                    MOD_MMI,
                    g_mmi_certman_context.view_invalid_context_p->trans_id,
                    g_mmi_certman_context.view_invalid_context_p->ctx_parse_p);
                g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSING;
            }
            else
            {
                if (g_mmi_certman_context.g_mmi_certman_active_grp == GRP_ID_CERTMAN_INVALID)
                {
                    mmi_certman_handle_error_with_callback(
                        CERTMAN_ERR_INVALID_DATA,
                        mmi_certman_invalid_grp_close_callback,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    break;
                }
                else
                {
                    mmi_certman_handle_error_with_callback(
                        CERTMAN_ERR_INVALID_DATA,
                        mmi_certman_view_grp_close_callback,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    break;
                }
            }

        }
            break;
        case MMI_CERTMAN_VIEW_INVALID_PARSING:
        {
            certman_parse_begin_cnf_struct *parsed_begin_cnf_p;

            parsed_begin_cnf_p = (certman_parse_begin_cnf_struct*) msg;
            certman_ctx_parse_free(g_mmi_certman_context.view_invalid_context_p->ctx_parse_p);
            g_mmi_certman_context.view_invalid_context_p->job_id = parsed_begin_cnf_p->job_id;
            g_mmi_certman_context.view_invalid_context_p->trans_id = parsed_begin_cnf_p->trans_id;
            g_mmi_certman_context.view_invalid_context_p->ref_id =
                parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_ALL].cert_ref_ids[0];
            if (parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_ALL].cert_count > 0)
            {
                mmi_certman_pre_entry_progress_screen(g_mmi_certman_context.g_mmi_certman_active_grp);
                certman_send_parse_cert_detail_req(
                    MOD_MMI,
                    parsed_begin_cnf_p->trans_id,
                    parsed_begin_cnf_p->job_id,
                    parsed_begin_cnf_p->parsed_info[CERTMAN_PARSED_CERTGRP_ALL].cert_ref_ids[0]);
                g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_DETAIL;
            }
            else
            {
                mmi_certman_display_message_with_callback(
                    STR_ID_CERTMAN_CERTIFICATE_NOT_FOUND,
                    MMI_EVENT_PROPLEM,
                    mmi_certman_exit_view_invalid_certificate_contents_only_with_gobackhistory,
                    g_mmi_certman_context.g_mmi_certman_active_grp);
            }
        }
            break;
        case MMI_CERTMAN_VIEW_INVALID_DETAIL:
        {
            certman_parse_cert_detail_cnf_struct *cert_detail_p = (certman_parse_cert_detail_cnf_struct*) msg;

            if (cert_detail_p->status != CERTMAN_ERR_NONE)
            {
                mmi_certman_handle_error(cert_detail_p->status, g_mmi_certman_context.g_mmi_certman_active_grp);
                mmi_certman_exit_view_invalid_certificate_contents_only();
            }
            else
            {
                g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_DISPLAY;
                mmi_certman_view_invalid_state(msg);
            }
            break;
        }
        case MMI_CERTMAN_VIEW_INVALID_DISPLAY:
        {
            certman_parse_cert_detail_cnf_struct *cert_detail_p = (certman_parse_cert_detail_cnf_struct*) msg;

            if (cert_detail_p->status == CERTMAN_ERR_NONE)
            {
                mmi_certman_pre_entry_view_certificate_contents_only();
            }
            else
            {
                certman_parsed_data_free(g_mmi_certman_context.view_invalid_context_p->parsed_data_p);
				g_mmi_certman_context.view_invalid_context_p->parsed_data_p = NULL;
                g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_DETAIL;
                mmi_certman_handle_error_with_callback(
                    cert_detail_p->status,
                    mmi_certman_view_invalid_state_when_null,
                    g_mmi_certman_context.g_mmi_certman_active_grp);
            }

        }
            break;
        case MMI_CERTMAN_VIEW_INVALID_OPTIONS:
            mmi_certman_invalid_certificate_option();
            break;
        case MMI_CERTMAN_VIEW_INVALID_CERT_LABEL:
            mmi_certman_pre_entry_invalid_cert_label();
            break;
        case MMI_CERTMAN_VIEW_INVALID_IMPORT:
        {
            certman_import_cnf_struct *import_cnf_p;

            import_cnf_p = (certman_import_cnf_struct*) msg;
            error = import_cnf_p->status;
            if (error != CERTMAN_ERR_NONE)
            {
                if (error == CERTMAN_ERR_MEMFULL || error == CERTMAN_ERR_DISK_FULL
                    || error == CERTMAN_ERR_INVALID_JOB || error == CERTMAN_ERR_FS_ERROR
                    || error == CERTMAN_ERR_INVALID_CONTEXT || error == CERTMAN_ERR_INVALID_CERT_ID)
                {
                    mmi_certman_handle_error(error, g_mmi_certman_context.g_mmi_certman_active_grp);
                    mmi_certman_exit_view_invalid_certificate_contents_only();
                    break;
                }
                else
                {
                    mmi_certman_handle_error_with_callback(
                        error,
                        mmi_certman_invalid_error,
                        g_mmi_certman_context.g_mmi_certman_active_grp);
                    certman_ctx_import_free(g_mmi_certman_context.view_invalid_context_p->ctx_import_p);
                    break;
                }
            }
            certman_ctx_import_free(g_mmi_certman_context.view_invalid_context_p->ctx_import_p);
            g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;

            mmi_certman_display_message_with_callback(
                STR_ID_CERTMAN_CERTIFICATE_IMPORTED,
                MMI_EVENT_SUCCESS,
                mmi_certman_invalid_certificate_imported,
                GRP_ID_CERTMAN_INVALID);

        }

            break;

        case MMI_CERTMAN_VIEW_INVALID_PARSE_END:
        {
            certman_parse_end_cnf_struct *parse_end_cnf_p;

            parse_end_cnf_p = (certman_parse_end_cnf_struct*) msg;
            error = parse_end_cnf_p->status;
            mmi_certman_exit_view_invalid_certificate_contents_only_with_gobackhistory();
        }
            break;
        default:
            ASSERT(g_mmi_certman_context.view_invalid_context_p->current_state <= MMI_CERTMAN_VIEW_INVALID_PARSE_END);

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_invalid_certificate_imported
 * DESCRIPTION
 *  function to indicate that invalid certificate is imported
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_invalid_certificate_imported(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_invalid_certificates_rsp(
        MMI_CERTMAN_INVALID_CERT_INSTALL,
        g_mmi_certman_context.view_invalid_context_p->trans_id);

    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_IMPORT);
    certman_send_parse_end_req(
        MOD_MMI,
        g_mmi_certman_context.view_invalid_context_p->trans_id,
        g_mmi_certman_context.view_invalid_context_p->job_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_exit_view_invalid_certificate_contents_only
 * DESCRIPTION
 *  exit function for view invalid certifcate contents only
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_exit_view_invalid_certificate_contents_only(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 trans_id;
    U16 job_id;
    U16 curr_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.current_status != MMI_CERTMAN_INVALID &&
        g_mmi_certman_context.current_status != MMI_CERTMAN_VIEW)
    {
        return;
    }
    trans_id = g_mmi_certman_context.view_invalid_context_p->trans_id;
    job_id = g_mmi_certman_context.view_invalid_context_p->job_id;
    curr_state = g_mmi_certman_context.view_invalid_context_p->current_state;
    if (curr_state == MMI_CERTMAN_VIEW_INVALID_PARSE_END)
    {
        mmi_certman_view_invalid_deinit();
        g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
    }
    switch (curr_state)
    {
        case MMI_CERTMAN_VIEW_INVALID_IDLE:
            certman_ctx_parse_free(g_mmi_certman_context.view_invalid_context_p->ctx_parse_p);
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_VIEW)
            {
                mmi_certman_view_certificates_rsp(MMI_FALSE, trans_id);
            }
            else
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
            }
            mmi_certman_view_invalid_deinit();
            g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
            break;
        case MMI_CERTMAN_VIEW_INVALID_PARSING:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_VIEW)
            {
                mmi_certman_view_certificates_rsp(MMI_FALSE, trans_id);
            }
            else
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
            }
            g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
            certman_send_parse_end_req(MOD_MMI, trans_id, job_id);
            break;
        case MMI_CERTMAN_VIEW_INVALID_DETAIL:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_VIEW)
            {
                mmi_certman_view_certificates_rsp(MMI_FALSE, trans_id);
            }
            else
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
            }
            g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
            certman_send_parse_end_req(MOD_MMI, trans_id, job_id);
            break;
        case MMI_CERTMAN_VIEW_INVALID_DISPLAY:
            certman_parsed_data_free(g_mmi_certman_context.view_invalid_context_p->parsed_data_p);
			 g_mmi_certman_context.view_invalid_context_p->parsed_data_p = NULL;
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_VIEW)
            {
                mmi_certman_view_certificates_rsp(MMI_FALSE, trans_id);
            }
            else
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
            }
            certman_send_parse_end_req(MOD_MMI, trans_id, job_id);
            mmi_certman_view_invalid_deinit();
            g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
            break;
        case MMI_CERTMAN_VIEW_INVALID_OPTIONS:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_VIEW)
            {
                mmi_certman_view_certificates_rsp(MMI_FALSE, trans_id);
            }
            else
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
            }
            g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
            certman_send_parse_end_req(MOD_MMI, trans_id, job_id);
            mmi_certman_view_invalid_deinit();
            g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
            break;
        case MMI_CERTMAN_VIEW_INVALID_CERT_LABEL:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_INVALID)
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
                if (g_mmi_certman_context.view_invalid_context_p->fseditor)
                {
                    cui_fseditor_close(g_mmi_certman_context.view_invalid_context_p->fseditor->id);
                    mmi_certman_free(g_mmi_certman_context.view_invalid_context_p->fseditor);
                    g_mmi_certman_context.view_invalid_context_p->fseditor = NULL;
                }
            }
            else
            {
                ASSERT(0);
            }
            g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
            certman_send_parse_end_req(MOD_MMI, trans_id, job_id);
            mmi_certman_view_invalid_deinit();
            g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
            break;
        case MMI_CERTMAN_VIEW_INVALID_IMPORT:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_INVALID)
            {
                mmi_certman_invalid_certificates_rsp(MMI_CERTMAN_INVALID_CERT_DENY, trans_id);
                mmi_certman_read_queue_task_if_present();
            }
            else
            {
                ASSERT(0);
            }
            g_mmi_certman_context.view_invalid_context_p->current_state = MMI_CERTMAN_VIEW_INVALID_PARSE_END;
            certman_send_parse_end_req(MOD_MMI, trans_id, job_id);
            break;
        case MMI_CERTMAN_VIEW_INVALID_PARSE_END:
            if (g_mmi_certman_context.current_status == MMI_CERTMAN_VIEW)
            {

                break;
            }

            break;
        default:
            ASSERT(0);

    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_view_invalid_deinit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_view_invalid_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.view_invalid_context_p)
    {
        mmi_certman_free(g_mmi_certman_context.view_invalid_context_p);
        g_mmi_certman_context.view_invalid_context_p = NULL;
    }
}

/**************************************************************************/
/*****************************User Certificates List***********************/
/**************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_select_user_certificates_init
 * DESCRIPTION
 *  
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_select_user_certificates_init(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 max_certificate_num;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_USER_CERTIFICATE_INIT);
    SetProtocolEventHandler(
        mmi_certman_get_cert_list_by_issuers_file_cnf_handler,
        MSG_ID_CERTMAN_GET_CERT_LIST_BY_ISSUERS_FILE_CNF);
    SetProtocolEventHandler(
        mmi_certman_get_cert_list_by_issuers_data_ind_handler,
        MSG_ID_CERTMAN_GET_CERT_LIST_BY_ISSUERS_DATA_IND);

    mmi_certman_entry_select_user_group();
    g_mmi_certman_context.user_cert_list_context_p = mmi_certman_malloc(sizeof(mmi_certman_user_certificates_list));
    
    max_certificate_num =certman_cfg_get_num_cert_in_database();
	g_mmi_certman_context.user_cert_list_context_p->certificate_list= (mmi_certman_certificate_list_struct*)mmi_certman_malloc(sizeof(mmi_certman_certificate_list_struct)*max_certificate_num);
	
    if (g_mmi_certman_context.user_cert_list_context_p == NULL)
    {
        mmi_certman_handle_error(CERTMAN_ERR_MEMFULL, GRP_ID_CERTMAN_SELECT_USER);
        mmi_certman_select_user_certificates_rsp(
            0,
            MMI_FALSE,
            ((mmi_certman_select_user_cert_ind_struct*) msg)->trans_id);
        mmi_certman_read_queue_task_if_present();
        return;
    }
    g_mmi_certman_context.current_status = MMI_CERTMAN_USER_CERT_LIST;
    g_mmi_certman_context.user_cert_list_context_p->current_state = MMI_CERTMAN_USER_CERT_LIST_IDLE;
    mmi_certman_select_user_certificate_state(msg);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_select_user_certificate_state
 * DESCRIPTION
 *  
 * PARAMETERS
 *  msg     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_select_user_certificate_state(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_INET_TRC_G3_CER_MAN,
        MMI_CERTMAN_SELECT_USER_CERTIFICATE_STATE,
        g_mmi_certman_context.user_cert_list_context_p->current_state);
    switch (g_mmi_certman_context.user_cert_list_context_p->current_state)
    {
        case MMI_CERTMAN_USER_CERT_LIST_IDLE:
        {
            mmi_certman_select_user_cert_ind_struct *user_cert_list;
            mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_SELECT);
            user_cert_list = (mmi_certman_select_user_cert_ind_struct*) msg;
            g_mmi_certman_context.user_cert_list_context_p->trans_id = user_cert_list->trans_id;
            g_mmi_certman_context.user_cert_list_context_p->mod_name = user_cert_list->mod_name;
            certman_send_get_cert_list_by_issuers_file_req(
                MOD_MMI,
                g_mmi_certman_context.user_cert_list_context_p->trans_id,
                CERTMAN_CERTGRP_PERSONAL,
                user_cert_list->key_purpose,
                user_cert_list->cert_types,
                user_cert_list->cert_type_len,
                user_cert_list->issuer_filename);
            g_mmi_certman_context.user_cert_list_context_p->current_state =
                MMI_CERTMAN_USER_CERT_LIST_BY_ISSUERS_FILE_REQ;
            break;
        }
        case MMI_CERTMAN_USER_CERT_LIST_BY_ISSUERS_FILE_REQ:
        {
            certman_get_cert_list_by_issuers_file_cnf_struct *cert_list =
                (certman_get_cert_list_by_issuers_file_cnf_struct*) msg;
            g_mmi_certman_context.user_cert_list_context_p->cert_count = 0;
            if (cert_list->status != CERTMAN_ERR_NONE)
            {
                mmi_certman_handle_error_with_callback(
                    cert_list->status,
                    mmi_certman_exit_user_certificates_list_with_goback_history,
                    (MMI_ID)GRP_ID_CERTMAN_SELECT_USER);
            }
            else
            {
                if (cert_list->num_certs == 0)
                {
                    g_mmi_certman_context.user_cert_list_context_p->current_state = MMI_CERTMAN_USER_CERT_LIST_DISPLAY;
                    mmi_certman_select_user_certificate_state(NULL);
                    break;
                }
                g_mmi_certman_context.user_cert_list_context_p->current_state =
                    MMI_CERTMAN_USER_CERT_LIST_BY_ISSUERS_DATA_IND;
            }
            break;
        }
        case MMI_CERTMAN_USER_CERT_LIST_BY_ISSUERS_DATA_IND:
        {
            certman_get_cert_list_by_issuers_data_ind_struct *issuer_data_ind =
                (certman_get_cert_list_by_issuers_data_ind_struct*) msg;
            certman_update_issuer_cert_list(issuer_data_ind);
            if (issuer_data_ind->last == 1)
            {
                g_mmi_certman_context.user_cert_list_context_p->current_state = MMI_CERTMAN_USER_CERT_LIST_DISPLAY;
                mmi_certman_select_user_certificate_state(NULL);
            }
            break;

        }
        case MMI_CERTMAN_USER_CERT_LIST_DISPLAY:
        {
            mmi_certman_pre_entry_display_user_certificate_list_by_issuer();
        }
            break;
        default:
            ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  certman_update_issuer_cert_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  issuer_data     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void certman_update_issuer_cert_list(certman_get_cert_list_by_issuers_data_ind_struct *issuer_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(
        MMI_INET_TRC_G3_CER_MAN,
        CERTMAN_UPDATE_ISSUER_CERT_LIST,
        g_mmi_certman_context.user_cert_list_context_p->cert_count);

    for (count = 0;
         count < issuer_data->size &&
         g_mmi_certman_context.user_cert_list_context_p->cert_count < CERTMAN_NUM_CERT_IN_LIST; count++)
    {
        if (g_mmi_certman_context.user_cert_list_context_p->cert_count >= MMI_CERTMAN_CERTIFICATES_MAX)
        {
            g_mmi_certman_context.user_cert_list_context_p->current_state = MMI_CERTMAN_USER_CERT_LIST_DISPLAY;
            mmi_certman_select_user_certificate_state(NULL);
            break;
        }

        g_mmi_certman_context.user_cert_list_context_p->certificate_list[g_mmi_certman_context.
                                                                         user_cert_list_context_p->cert_count].cert_id =
            issuer_data->cert_list[count].id;
        g_mmi_certman_context.user_cert_list_context_p->certificate_list[g_mmi_certman_context.
                                                                         user_cert_list_context_p->cert_count].
            cert_group = issuer_data->cert_list[count].group;
        g_mmi_certman_context.user_cert_list_context_p->certificate_list[g_mmi_certman_context.
                                                                         user_cert_list_context_p->cert_count].
            key_purpose = issuer_data->cert_list[count].key_purpose_allowed;
        g_mmi_certman_context.user_cert_list_context_p->certificate_list[g_mmi_certman_context.
                                                                         user_cert_list_context_p->cert_count].
            cert_prop = issuer_data->cert_list[count].properties;
        g_mmi_certman_context.user_cert_list_context_p->certificate_list[g_mmi_certman_context.
                                                                         user_cert_list_context_p->cert_count].
            certificate_dcs = issuer_data->cert_list[count].dcs;

        memcpy(
            g_mmi_certman_context.user_cert_list_context_p->certificate_list[g_mmi_certman_context.user_cert_list_context_p->cert_count].cert_label,
            issuer_data->cert_list[count].label,
            CERTMAN_LABEL_SIZE);
        g_mmi_certman_context.user_cert_list_context_p->cert_count++;

        ASSERT(g_mmi_certman_context.user_cert_list_context_p->cert_count <= MMI_CERTMAN_CERTIFICATES_MAX);
    }

}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_exit_user_certificates_list_with_goback_history
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_exit_user_certificates_list_with_goback_history(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_exit_user_certificates_list();
    mmi_certman_read_queue_task_if_present();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_exit_user_certificates_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_exit_user_certificates_list()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 trans_id = g_mmi_certman_context.user_cert_list_context_p->trans_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_user_certificates_list_deinit();
    mmi_certman_select_user_certificates_rsp(0, MMI_FALSE, trans_id);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_user_certificates_list_deinit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_user_certificates_list_deinit()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.current_status == MMI_CERTMAN_IDLE)
    {
        return;
    }
    if (g_mmi_certman_context.user_cert_list_context_p)
    {
        mmi_certman_free(g_mmi_certman_context.user_cert_list_context_p->certificate_list);
        mmi_certman_free(g_mmi_certman_context.user_cert_list_context_p);
        g_mmi_certman_context.user_cert_list_context_p = NULL;
    }
    g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
}

/**************************************************************************/
/*****************************Common Functions**************************/
/**************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_cert_strncpy
 * DESCRIPTION
 *  
 * PARAMETERS
 *  Destination     [IN]        
 *  Source          [IN]        
 *  dcs_type        [IN]        
 *  dest_size       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_cert_strncpy(U8 *Destination, U8 *Source, certman_dcs_enum dcs_type, U32 dest_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (dcs_type == CERTMAN_DCS_ASCII)
    {
        mmi_asc_n_to_ucs2((S8*) Destination, (S8*) Source, (dest_size - ENCODING_LENGTH) / ENCODING_LENGTH);
    }
    else
    {
        mmi_ucs2ncpy((S8*) Destination, (S8*) Source, (dest_size - ENCODING_LENGTH) / ENCODING_LENGTH);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_mem_init
 * DESCRIPTION
 *  function to init buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_mem_init()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.adm_id == 0)
    {
        g_mmi_certman_context.adm_id = kal_adm_create(g_mmi_certman_context.mem_pool, MMI_CERTMAN_MEM_SIZE, NULL, KAL_FALSE);
        ASSERT(g_mmi_certman_context.adm_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_malloc
 * DESCRIPTION
 *  wrapper for malloc
 * PARAMETERS
 *  size        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void *mmi_certman_malloc(kal_uint32 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    void *mem_output_ptr = NULL;

    /* KAL_ADM_ID jdd_mem_adm_id = 0; */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_MALLOC, size);

    if (g_mmi_certman_context.adm_id != 0 && size > 0)
    {
        mem_output_ptr = kal_adm_alloc(g_mmi_certman_context.adm_id, size);
    }
    if (mem_output_ptr == NULL)
    {
        return mem_output_ptr;
    }
    memset(mem_output_ptr, 0, size);
    return mem_output_ptr;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_free
 * DESCRIPTION
 *  wrapper for free
 * PARAMETERS
 *  free_mem_p      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_free(void *free_mem_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_FREE);
    if (g_mmi_certman_context.adm_id != 0 && free_mem_p != NULL)
    {
        kal_adm_free(g_mmi_certman_context.adm_id, free_mem_p);
        free_mem_p = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_refresh_display_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_refresh_display_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 more = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    g_mmi_certman_context.launch_select_context_p->certificate_count = 0;
    mmi_certman_pre_entry_progress_screen(GRP_ID_CERTMAN_LAUNCH);
    g_mmi_certman_context.launch_select_context_p->current_state = MMI_CERTMAN_LAUNCH_SELECT_GROUP_REQ;
    mmi_certman_launch_select_state((void*)more);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_deinit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_certman_deinit(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    evt = evt; 
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_DEINIT, g_mmi_certman_context.current_status);
    switch (g_mmi_certman_context.current_status)
    {
        case MMI_CERTMAN_IMPORT:
            mmi_certman_exit_from_import();
            break;
        case MMI_CERTMAN_LAUNCH:
        case MMI_CERTMAN_SELECT:
            mmi_certman_exit_from_select_launch();
            break;

        case MMI_CERTMAN_VIEW:
        case MMI_CERTMAN_INVALID:
            if (g_mmi_certman_context.view_invalid_context_p)
            {
                mmi_certman_exit_view_invalid_certificate_contents_only();
            }
            break;
        case MMI_CERTMAN_USER_CERT_LIST:
            mmi_certman_exit_user_certificates_list();
            break;
        case MMI_CERTMAN_IDLE:
            /* Do Nothing */
            break;
        default:
            ASSERT(0);
    }

    switch (g_mmi_certman_context.private_key_status)
    {
        case MMI_CERTMAN_PRIVATE_KEY_PWD:
            if (g_mmi_certman_context.priv_key_context_p)
            {
                certman_send_privkey_usage_password_rsp(
                    MOD_MMI,
                    g_mmi_certman_context.priv_key_context_p->trans_id,
                    MMI_FALSE);
                mmi_certman_free(g_mmi_certman_context.priv_key_context_p);
                g_mmi_certman_context.priv_key_context_p = NULL;
            }
            break;
        case MMI_CERTMAN_PRIVATE_KEY_CONFIRM:
            if (g_mmi_certman_context.priv_key_context_p)
            {
                certman_send_privkey_usage_confirm_rsp(
                    MOD_MMI,
                    g_mmi_certman_context.priv_key_context_p->trans_id,
                    MMI_FALSE);
                mmi_certman_free(g_mmi_certman_context.priv_key_context_p);
                g_mmi_certman_context.priv_key_context_p = NULL;
            }
            break;
        case MMI_CERTMAN_PRIVATE_KEY_IDLE:
            /* Do Nothing */
            break;
        default:
            ASSERT(0);
    }
    g_mmi_certman_context.current_status = MMI_CERTMAN_IDLE;
    g_mmi_certman_context.private_key_status = MMI_CERTMAN_PRIVATE_KEY_IDLE;
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_get_cert_label
 * DESCRIPTION
 *  retrieves certificate label given the specified certificate ID
 * PARAMETERS
 *  cert_id             [IN]            ID of the certificate label to retrieve
 *  label_buffer        [IN/OUT]        Buffer provided by caller in which label will be filled into
 *  buf_size            [IN]            Buffer size (the number of usable bytes in buffer, include zero-terminate)
 * RETURNS
 *  KAL_TRUE
 *  KAL_FALSE
 *****************************************************************************/
kal_bool mmi_certman_get_cert_label(kal_uint32 cert_id, kal_uint8 *label_buffer, kal_uint32 buf_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 error;
    kal_uint8 *label;
    certman_dcs_enum dcs;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cert_id == 0)
    {
        mmi_ucs2ncpy((PS8) label_buffer, (PS8) GetString(STR_GLOBAL_NONE), buf_size);
        return KAL_TRUE;
    }
    label = mmi_certman_malloc(buf_size);
    error = certman_get_cert_label(cert_id, label, buf_size, &dcs);
    if (error == CERTMAN_ERR_NONE)
    {
        mmi_certman_cert_strncpy(label_buffer, label, dcs, buf_size);
        mmi_certman_free(label);
        return KAL_TRUE;
    }
    else
    {
        mmi_certman_free(label);
        return KAL_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_import_state_with_null
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_import_state_with_null(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_import_state(NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_view_invalid_state_when_null
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_view_invalid_state_when_null(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_view_invalid_state(NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_insert_task_queue
 * DESCRIPTION
 *  Function for entering the node in task queue
 * PARAMETERS
 *  src_mod         [IN]        
 *  event_id        [IN]        
 *  data            [IN]        
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL mmi_certman_insert_task_queue(module_type src_mod, U16 event_id, void *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 count = 0;
    mmi_certman_task_queue_struct *queue_node;
    mmi_certman_task_queue_struct *temp_node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_INSERT_TASK_QUEUE);
    queue_node = (mmi_certman_task_queue_struct*) mmi_certman_malloc(sizeof(mmi_certman_task_queue_struct));
    if (queue_node == NULL)
    {
        return MMI_FALSE;
    }
    queue_node->src_module = src_mod;
    queue_node->event_id = event_id;

    /* Queue length is 5 */
    temp_node = g_mmi_certman_context.head_task_queue;
    while (temp_node != NULL)
    {
        temp_node = temp_node->next;
        count++;
    }
    if (count >= MMI_CERTMAN_QUEUE_LENGTH)
    {
        mmi_certman_free(queue_node);
        return MMI_FALSE;
    }
    switch (event_id)
    {
        case MSG_ID_MMI_CERTMAN_INSTALL_CERT_IND:
        {
            mmi_certman_install_cert_ind_struct *install_node;

            install_node =
                (mmi_certman_install_cert_ind_struct*) mmi_certman_malloc(sizeof(mmi_certman_install_cert_ind_struct));
            if (install_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE; 
            }
            install_node->ref_count = ((mmi_certman_install_cert_ind_struct*) data)->ref_count;
            install_node->msg_len = ((mmi_certman_install_cert_ind_struct*) data)->msg_len;
            install_node->action = ((mmi_certman_install_cert_ind_struct*) data)->action;
            install_node->trans_id = ((mmi_certman_install_cert_ind_struct*) data)->trans_id;
            memcpy(
                install_node->cert_filename,
                ((mmi_certman_install_cert_ind_struct*) data)->cert_filename,
                MMI_CERTMAN_MAX_FILE_PATH_LENGTH * sizeof(kal_wchar));

            queue_node->data = (void*)install_node;
            break;
        }

        case MSG_ID_MMI_CERTMAN_LAUNCH_CERT_IND:
        {
            mmi_certman_launch_cert_ind_struct *launch_node;

            launch_node =
                (mmi_certman_launch_cert_ind_struct*) mmi_certman_malloc(sizeof(mmi_certman_launch_cert_ind_struct));
            if (launch_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE; 
            }
            launch_node->ref_count = ((mmi_certman_launch_cert_ind_struct*) data)->ref_count;
            launch_node->msg_len = ((mmi_certman_launch_cert_ind_struct*) data)->msg_len;
            launch_node->action = ((mmi_certman_launch_cert_ind_struct*) data)->action;
            launch_node->trans_id = ((mmi_certman_launch_cert_ind_struct*) data)->trans_id;

            queue_node->data = (void*)launch_node;
            break;
        }
        case MSG_ID_MMI_CERTMAN_SELECT_CERT_IND:
        {
            mmi_certman_select_cert_ind_struct *select_node;

            select_node =
                (mmi_certman_select_cert_ind_struct*) mmi_certman_malloc(sizeof(mmi_certman_select_cert_ind_struct));
            if (select_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE; 
            }
            select_node->ref_count = ((mmi_certman_select_cert_ind_struct*) data)->ref_count;
            select_node->msg_len = ((mmi_certman_select_cert_ind_struct*) data)->msg_len;
            select_node->action = ((mmi_certman_select_cert_ind_struct*) data)->action;
            select_node->multiple_selection_flag =
                ((mmi_certman_select_cert_ind_struct*) data)->multiple_selection_flag;
            select_node->trans_id = ((mmi_certman_select_cert_ind_struct*) data)->trans_id;
            select_node->cert_group = ((mmi_certman_select_cert_ind_struct*) data)->cert_group;

            queue_node->data = (void*)select_node;
            break;
        }
        case MSG_ID_MMI_CERTMAN_VIEW_CERT_IND:
        {
            mmi_certman_view_cert_ind_struct *view_node;

            view_node =
                (mmi_certman_view_cert_ind_struct*) mmi_certman_malloc(sizeof(mmi_certman_view_cert_ind_struct));
            if (view_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE; 
            }
            view_node->ref_count = ((mmi_certman_view_cert_ind_struct*) data)->ref_count;
            view_node->msg_len = ((mmi_certman_view_cert_ind_struct*) data)->msg_len;
            view_node->action = ((mmi_certman_view_cert_ind_struct*) data)->action;
            view_node->trans_id = ((mmi_certman_view_cert_ind_struct*) data)->trans_id;
            memcpy(view_node->filename, ((mmi_certman_view_cert_ind_struct*) data)->filename, MMI_CERTMAN_MAX_FILE_PATH_LENGTH * sizeof(kal_wchar));
            queue_node->data = (void*)view_node;
            break;
        }
        case MSG_ID_MMI_CERTMAN_INVALID_CERT_IND:
        {
            mmi_certman_invalid_cert_ind_struct *invalid_node;

            invalid_node =
                (mmi_certman_invalid_cert_ind_struct*) mmi_certman_malloc(sizeof(mmi_certman_invalid_cert_ind_struct));
            if (invalid_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE; 
            }
            invalid_node->ref_count = ((mmi_certman_invalid_cert_ind_struct*) data)->ref_count;
            invalid_node->msg_len = ((mmi_certman_invalid_cert_ind_struct*) data)->msg_len;
            invalid_node->action = ((mmi_certman_invalid_cert_ind_struct*) data)->action;
            invalid_node->disable_install_option =
                ((mmi_certman_invalid_cert_ind_struct*) data)->disable_install_option;
            invalid_node->error = ((mmi_certman_invalid_cert_ind_struct*) data)->error;
            invalid_node->mod_name = ((mmi_certman_invalid_cert_ind_struct*) data)->mod_name;
            invalid_node->trans_id = ((mmi_certman_invalid_cert_ind_struct*) data)->trans_id;
            memcpy(
                invalid_node->cert_filename,
                ((mmi_certman_invalid_cert_ind_struct*) data)->cert_filename,
                MMI_CERTMAN_MAX_FILE_PATH_LENGTH * sizeof(kal_wchar));

            queue_node->data = (void*)invalid_node;
            break;
        }
        case MSG_ID_MMI_CERTMAN_SELECT_USER_CERT_IND:
        {
            mmi_certman_select_user_cert_ind_struct *select_user_cert_node;

            select_user_cert_node =
                (mmi_certman_select_user_cert_ind_struct*)
                mmi_certman_malloc(sizeof(mmi_certman_select_user_cert_ind_struct));
            if (select_user_cert_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE; 
            }
            select_user_cert_node->ref_count = ((mmi_certman_select_user_cert_ind_struct*) data)->ref_count;
            select_user_cert_node->msg_len = ((mmi_certman_select_user_cert_ind_struct*) data)->msg_len;
            select_user_cert_node->action = ((mmi_certman_select_user_cert_ind_struct*) data)->action;
            select_user_cert_node->cert_type_len = ((mmi_certman_select_user_cert_ind_struct*) data)->cert_type_len;
            memcpy(
                select_user_cert_node->cert_types,
                ((mmi_certman_select_user_cert_ind_struct*) data)->cert_types,
                MMI_CERTMAN_MAX_CERT_TYPES);
            select_user_cert_node->key_purpose = ((mmi_certman_select_user_cert_ind_struct*) data)->key_purpose;
            select_user_cert_node->mod_name = ((mmi_certman_select_user_cert_ind_struct*) data)->mod_name;
            select_user_cert_node->trans_id = ((mmi_certman_select_user_cert_ind_struct*) data)->trans_id;
            memcpy(
                select_user_cert_node->issuer_filename,
                ((mmi_certman_select_user_cert_ind_struct*) data)->issuer_filename,
                MMI_CERTMAN_MAX_FILE_PATH_LENGTH * sizeof(kal_wchar));

            queue_node->data = (void*)select_user_cert_node;
            break;
        }
        default:
            ASSERT(0);
    }

    if (g_mmi_certman_context.head_task_queue == NULL)
    {
        g_mmi_certman_context.head_task_queue = queue_node;
        g_mmi_certman_context.head_task_queue->prev = NULL;
        g_mmi_certman_context.head_task_queue->next = NULL;
    }
    else
    {
        temp_node = g_mmi_certman_context.head_task_queue;
        while (temp_node->next != NULL)
        {
            temp_node = temp_node->next;
        }
        temp_node->next = queue_node;
        queue_node->prev = temp_node;
        queue_node->next = NULL;
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_use_task_queue
 * DESCRIPTION
 *  Function to pop certficate manager task from queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_use_task_queue(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_task_queue_struct *temp_node;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_USE_TASK_QUEUE);
    if (g_mmi_certman_context.current_status != MMI_CERTMAN_IDLE)
    {
        /* not able to process request here. This must be processed by calling
           mmi_certman_read_queue_task_if_present when the current operation 
           ends (MAUI_02057952). Not calling mmi_certman_read_queue_task_if_present
           here to avoid checking queue again and again. */
        return;
    }

#ifdef __DM_LAWMO_SUPPORT__
    if (TRUE == mmi_dmui_is_phone_lock())
    {
        return;
    }
#endif


    if (g_mmi_certman_context.head_task_queue)
    {
        temp_node = g_mmi_certman_context.head_task_queue;
        g_mmi_certman_context.head_task_queue = g_mmi_certman_context.head_task_queue->next;
        if (g_mmi_certman_context.head_task_queue != NULL)
        {
            g_mmi_certman_context.head_task_queue->prev = NULL;
        }
        g_mmi_certman_context.curr_module = temp_node->src_module;
        switch (temp_node->event_id)
        {
            case MSG_ID_MMI_CERTMAN_INSTALL_CERT_IND:
            {
                mmi_certman_import_init(temp_node->data);
                break;
            }
            case MSG_ID_MMI_CERTMAN_LAUNCH_CERT_IND:
            {
                mmi_certman_launch_init(temp_node->data);
                break;
            }
            case MSG_ID_MMI_CERTMAN_SELECT_CERT_IND:
            {
                mmi_certman_select_init(temp_node->data);
                break;
            }
            case MSG_ID_MMI_CERTMAN_VIEW_CERT_IND:
            {
                mmi_certman_view_init(temp_node->data);
                break;
            }
            case MSG_ID_MMI_CERTMAN_INVALID_CERT_IND:
            {
                mmi_certman_invalid_certificate_init(temp_node->data);
                break;
            }
            case MSG_ID_MMI_CERTMAN_SELECT_USER_CERT_IND:
            {
                mmi_certman_select_user_certificates_init(temp_node->data);
                break;
            }
            default:
                ASSERT(0);
        }
        mmi_certman_free(temp_node->data);
        mmi_certman_free(temp_node);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_delete_task_queue
 * DESCRIPTION
 *  Function to delete certficate manager task from queue while canceling the request
 * PARAMETERS
 *  src_mod         [IN]        
 *  event_id        [IN]        
 *  data            [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_delete_task_queue(module_type src_mod, U16 event_id, void *data)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_task_queue_struct *temp_node;
    pBOOL delete_node = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_DELETE_TASK_QUEUE);

    for (temp_node = g_mmi_certman_context.head_task_queue; temp_node != NULL; temp_node = temp_node->next)
    {
        if (temp_node->src_module == src_mod && temp_node->event_id == event_id)
        {
            switch (event_id)
            {
                case MSG_ID_MMI_CERTMAN_INSTALL_CERT_IND:
                {
                    if (((mmi_certman_install_cert_ind_struct*) temp_node->data)->trans_id ==
                        ((mmi_certman_install_cert_ind_struct*) data)->trans_id)
                    {
                        mmi_certman_free(temp_node->data);
                        delete_node = MMI_TRUE;
                    }
                    break;
                }
                case MSG_ID_MMI_CERTMAN_LAUNCH_CERT_IND:
                {
                    if ((((mmi_certman_launch_cert_ind_struct*) temp_node->data)->trans_id ==
                         ((mmi_certman_launch_cert_ind_struct*) data)->trans_id))
                    {
                        mmi_certman_free(temp_node->data);
                        delete_node = MMI_TRUE;
                    }
                    break;
                }
                case MSG_ID_MMI_CERTMAN_SELECT_CERT_IND:
                {
                    if (((mmi_certman_select_cert_ind_struct*) temp_node->data)->trans_id ==
                        ((mmi_certman_select_cert_ind_struct*) data)->trans_id)
                    {
                        mmi_certman_free(temp_node->data);
                        delete_node = MMI_TRUE;
                    }
                    break;
                }
                case MSG_ID_MMI_CERTMAN_VIEW_CERT_IND:
                {
                    if (((mmi_certman_view_cert_ind_struct*) temp_node->data)->trans_id ==
                        ((mmi_certman_view_cert_ind_struct*) data)->trans_id)
                    {
                        mmi_certman_free(temp_node->data);
                        delete_node = MMI_TRUE;
                    }
                    break;
                }
                case MSG_ID_MMI_CERTMAN_INVALID_CERT_IND:
                {
                    if (((mmi_certman_invalid_cert_ind_struct*) temp_node->data)->trans_id ==
                        ((mmi_certman_invalid_cert_ind_struct*) data)->trans_id)
                    {
                        mmi_certman_free(temp_node->data);
                        delete_node = MMI_TRUE;
                    }
                    break;
                }
                case MSG_ID_MMI_CERTMAN_SELECT_USER_CERT_IND:
                {
                    if (((mmi_certman_select_user_cert_ind_struct*) temp_node->data)->trans_id ==
                        ((mmi_certman_select_user_cert_ind_struct*) data)->trans_id)
                    {
                        mmi_certman_free(temp_node->data);
                        delete_node = MMI_TRUE;
                    }
                    break;
                }
            }
            if (delete_node == MMI_TRUE)
            {
                /* Only one node */
                if (temp_node->prev == NULL && temp_node->next == NULL)
                {
                    g_mmi_certman_context.head_task_queue = NULL;
                    mmi_certman_free(temp_node);
                }   /* Delete first node */
                else if (temp_node->prev == NULL)
                {
                    g_mmi_certman_context.head_task_queue = temp_node->next;
                    g_mmi_certman_context.head_task_queue->prev = NULL;
                    mmi_certman_free(temp_node);
                }   /* Delete last node */
                else if (temp_node->next == NULL)
                {
                    temp_node->prev->next = NULL;
                    mmi_certman_free(temp_node);
                }
                else    /* Delete middle node */
                {
                    temp_node->prev->next = temp_node->next;
                    temp_node->next->prev = temp_node->prev;
                    mmi_certman_free(temp_node);
                }
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_empty_task_queue
 * DESCRIPTION
 *  Function to empty certficate manager task queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_empty_task_queue(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_task_queue_struct *temp_node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_EMPTY_TASK_QUEUE);
    while (g_mmi_certman_context.head_task_queue)
    {
        temp_node = g_mmi_certman_context.head_task_queue;
        g_mmi_certman_context.head_task_queue = g_mmi_certman_context.head_task_queue->next;
        if (g_mmi_certman_context.head_task_queue != NULL)
        {
            g_mmi_certman_context.head_task_queue->prev = NULL;
        }
        g_mmi_certman_context.curr_module = temp_node->src_module;
        switch (temp_node->event_id)
        {
            case MSG_ID_MMI_CERTMAN_INSTALL_CERT_IND:
            {
                mmi_certman_install_certificates_rsp(
                    MMI_FALSE,
                    ((mmi_certman_install_cert_ind_struct*) temp_node->data)->trans_id);
                break;
            }
            case MSG_ID_MMI_CERTMAN_LAUNCH_CERT_IND:
            {
                mmi_certman_launch_certificates_rsp(
                    MMI_FALSE,
                    ((mmi_certman_launch_cert_ind_struct*) temp_node->data)->trans_id);
                break;
            }
            case MSG_ID_MMI_CERTMAN_SELECT_CERT_IND:
            {
                mmi_certman_select_certificates_rsp(
                    MMI_FALSE,
                    0,
                    0,
                    ((mmi_certman_select_cert_ind_struct*) temp_node->data)->trans_id);
                break;
            }
            case MSG_ID_MMI_CERTMAN_VIEW_CERT_IND:
            {
                mmi_certman_view_certificates_rsp(
                    MMI_FALSE,
                    ((mmi_certman_view_cert_ind_struct*) temp_node->data)->trans_id);
                break;
            }
            case MSG_ID_MMI_CERTMAN_INVALID_CERT_IND:
            {
                mmi_certman_invalid_certificates_rsp(
                    MMI_CERTMAN_INVALID_CERT_DENY,
                    ((mmi_certman_invalid_cert_ind_struct*) temp_node->data)->trans_id);
                break;
            }
            case MSG_ID_MMI_CERTMAN_SELECT_USER_CERT_IND:
            {
                mmi_certman_select_user_certificates_rsp(
                    0,
                    MMI_FALSE,
                    ((mmi_certman_select_user_cert_ind_struct*) temp_node->data)->trans_id);
                break;
            }
            default:
                ASSERT(0);
        }
        mmi_certman_free(temp_node->data);
        mmi_certman_free(temp_node);

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_insert_priv_key_queue
 * DESCRIPTION
 *  Function to pop private key task into the queue
 * PARAMETERS
 *  event_id        [IN]        
 *  data            [IN]        
 * RETURNS
 *  pBOOL
 *****************************************************************************/
pBOOL mmi_certman_insert_priv_key_queue(U16 event_id, void *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 count = 0;
    mmi_certman_task_queue_struct *queue_node;
    mmi_certman_task_queue_struct *temp_node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_INSERT_PRIV_KEY_QUEUE);
    queue_node = (mmi_certman_task_queue_struct*) mmi_certman_malloc(sizeof(mmi_certman_task_queue_struct));
    if (queue_node == NULL)
    {
        return MMI_FALSE;
    }
    queue_node->src_module = MOD_NIL;
    queue_node->event_id = event_id;

    /* Queue length is 5 */
    temp_node = g_mmi_certman_context.head_priv_key_queue;
    while (temp_node != NULL)
    {
        temp_node = temp_node->next;
        count++;
    }
    if (count >= MMI_CERTMAN_QUEUE_LENGTH)
    {
        mmi_certman_free(queue_node);
        return MMI_FALSE;
    }
    switch (event_id)
    {
        case MSG_ID_CERTMAN_PRIVKEY_USAGE_PASSWORD_IND:
        {
            certman_privkey_usage_password_ind_struct *priv_key_pwd_node;

            priv_key_pwd_node =
                (certman_privkey_usage_password_ind_struct*)
                mmi_certman_malloc(sizeof(certman_privkey_usage_password_ind_struct));
            if (priv_key_pwd_node ==  NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE;            
            }
            priv_key_pwd_node->ref_count = ((certman_privkey_usage_password_ind_struct*) data)->ref_count;
            priv_key_pwd_node->msg_len = ((certman_privkey_usage_password_ind_struct*) data)->msg_len;
            priv_key_pwd_node->trans_id = ((certman_privkey_usage_password_ind_struct*) data)->trans_id;
            priv_key_pwd_node->cert_id = ((certman_privkey_usage_password_ind_struct*) data)->cert_id;
            memcpy(
                priv_key_pwd_node->label,
                ((certman_privkey_usage_password_ind_struct*) data)->label,
                CERTMAN_LABEL_SIZE);
            priv_key_pwd_node->dcs = ((certman_privkey_usage_password_ind_struct*) data)->dcs;
            priv_key_pwd_node->pcb = ((certman_privkey_usage_password_ind_struct*) data)->pcb;
            priv_key_pwd_node->state = ((certman_privkey_usage_password_ind_struct*) data)->state;
            queue_node->data = (void*)priv_key_pwd_node;
            break;
        }

        case MSG_ID_CERTMAN_PRIVKEY_USAGE_CONFIRM_IND:
        {
            certman_privkey_usage_confirm_ind_struct *priv_key_confirm_node;

            priv_key_confirm_node =
                (certman_privkey_usage_confirm_ind_struct*)
                mmi_certman_malloc(sizeof(certman_privkey_usage_confirm_ind_struct));
            if (priv_key_confirm_node == NULL)
            {
                mmi_certman_free(queue_node);
                return MMI_FALSE;
            }
            priv_key_confirm_node->ref_count = ((certman_privkey_usage_confirm_ind_struct*) data)->ref_count;
            priv_key_confirm_node->msg_len = ((certman_privkey_usage_confirm_ind_struct*) data)->msg_len;
            priv_key_confirm_node->trans_id = ((certman_privkey_usage_confirm_ind_struct*) data)->trans_id;
            priv_key_confirm_node->cert_id = ((certman_privkey_usage_confirm_ind_struct*) data)->cert_id;
            memcpy(
                priv_key_confirm_node->label,
                ((certman_privkey_usage_confirm_ind_struct*) data)->label,
                CERTMAN_LABEL_SIZE);
            priv_key_confirm_node->dcs = ((certman_privkey_usage_confirm_ind_struct*) data)->dcs;
            queue_node->data = (void*)priv_key_confirm_node;
            break;
        }
        default:
            ASSERT(0);
    }
    if (g_mmi_certman_context.head_priv_key_queue == NULL)
    {
        g_mmi_certman_context.head_priv_key_queue = queue_node;
        g_mmi_certman_context.head_priv_key_queue->prev = NULL;
        g_mmi_certman_context.head_priv_key_queue->next = NULL;
    }
    else
    {
        temp_node = g_mmi_certman_context.head_priv_key_queue;
        while (temp_node->next != NULL)
        {
            temp_node = temp_node->next;
        }
        temp_node->next = queue_node;
        queue_node->prev = temp_node;
        queue_node->next = NULL;
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_use_priv_key_queue
 * DESCRIPTION
 *  Function to pop private key task from queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_use_priv_key_queue(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_task_queue_struct *temp_node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_USE_PRIV_KEY_QUEUE);
    if (g_mmi_certman_context.private_key_status != MMI_CERTMAN_PRIVATE_KEY_IDLE)
    {
        return;
    }


#ifdef __DM_LAWMO_SUPPORT__
	if (TRUE == mmi_dmui_is_phone_lock())
	{
		return;
	}
#endif
    


    if (g_mmi_certman_context.head_priv_key_queue)
    {
        temp_node = g_mmi_certman_context.head_priv_key_queue;
        g_mmi_certman_context.head_priv_key_queue = g_mmi_certman_context.head_priv_key_queue->next;
        if (g_mmi_certman_context.head_priv_key_queue != NULL)
        {
            g_mmi_certman_context.head_priv_key_queue->prev = NULL;
        }
        switch (temp_node->event_id)
        {
            case MSG_ID_CERTMAN_PRIVKEY_USAGE_PASSWORD_IND:
            {
                mmi_certman_privkey_usage_password_ind(temp_node->data);
                break;
            }
            case MSG_ID_CERTMAN_PRIVKEY_USAGE_CONFIRM_IND:
            {
                mmi_certman_send_privkey_usage_confirm_ind(temp_node->data);
                break;
            }
            default:
                ASSERT(0);

        }
        mmi_certman_free(temp_node->data);
        mmi_certman_free(temp_node);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_empty_priv_key_queue
 * DESCRIPTION
 *  Function to empty private key queue
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_empty_priv_key_queue(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_certman_task_queue_struct *temp_node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_EMPTY_PRIV_KEY_QUEUE);
    while (g_mmi_certman_context.head_priv_key_queue)
    {
        temp_node = g_mmi_certman_context.head_priv_key_queue;
        g_mmi_certman_context.head_priv_key_queue = g_mmi_certman_context.head_priv_key_queue->next;
        if (g_mmi_certman_context.head_priv_key_queue != NULL)
        {
            g_mmi_certman_context.head_priv_key_queue->prev = NULL;
        }
        switch (temp_node->event_id)
        {
            case MSG_ID_CERTMAN_PRIVKEY_USAGE_PASSWORD_IND:
            {
                certman_send_privkey_usage_password_rsp(
                    MOD_MMI,
                    ((certman_privkey_usage_password_ind_struct*) temp_node->data)->trans_id,
                    MMI_FALSE);
                break;
            }
            case MSG_ID_CERTMAN_PRIVKEY_USAGE_CONFIRM_IND:
            {
                mmi_certman_free((certman_privkey_usage_confirm_ind_struct*) temp_node->data);
                certman_send_privkey_usage_password_rsp(
                    MOD_MMI,
                    ((certman_privkey_usage_confirm_ind_struct*) temp_node->data)->trans_id,
                    MMI_FALSE);
                break;
            }
            default:
                ASSERT(0);
        }
        mmi_certman_free(temp_node->data);
        mmi_certman_free(temp_node);

    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_is_task_queue_empty
 * DESCRIPTION
 *  Function to check whether queue is empty
 * PARAMETERS
 *  void
 * RETURNS
 *  pBOOL   [OUT]
 *****************************************************************************/
pBOOL mmi_certman_is_task_queue_empty(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_mmi_certman_context.head_task_queue == NULL)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_read_queue_task_if_present
 * DESCRIPTION
 *  Function to read task from queue if present
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_read_queue_task_if_present(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_USE_TASK_QUEUE_IF_PRESENT);
    if (!mmi_certman_is_task_queue_empty())
    {
        mmi_certman_read_task_queue_ind();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_idle_check
 * DESCRIPTION
 *  Function to check for idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_certman_idle_check(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_INET_TRC_G3_CER_MAN, MMI_CERTMAN_IDLE_CHECK);
    mmi_certman_empty_priv_key_queue();
    if (mmi_scr_locker_is_locked())
    {
        return 0;
    }
    return (!mmi_certman_is_task_queue_empty());
}

/*****************************************************************************
 * FUNCTION
 *  mmi_certman_new_handle
 * DESCRIPTION
 * 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 mmi_certman_new_handle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return ++g_mmi_certman_context.curr_handle_value;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_certman_ui_entry_idle_screen
 * DESCRIPTION
 *  Function to read task from certman queue on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_certman_ui_entry_idle_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_certman_use_task_queue();
    mmi_certman_empty_task_queue();
}


void mmi_certman_bootup_notify(mmi_event_struct *evt)
{
    mmi_frm_send_ilm(MOD_CERTMAN, MSG_ID_MMI_READY_NOTIFY_REQ, NULL, NULL);
}
#endif /* __CERTMAN_SUPPORT__ */ 
#endif /* __PLUTO_MMI_PACKAGE__  */
/* Shrikant */

