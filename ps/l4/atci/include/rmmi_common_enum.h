/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 * rmmi_common_enum.h
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#ifndef _RMMI_COMMON_ENUM_H
#define _RMMI_COMMON_ENUM_H
#ifdef __CMUX_SUPPORT__
#include "cmux_vp_num.h"
#endif

#include "csmss_common_enums.h"
#include "smu_common_enums.h"
#include "ps_public_enum.h"
#include "layer4_context.h"

//For feature phone project which need long AT command support 
#if defined (__LONG_AT_CMD_SUPPORT__) 
#define MAX_DATA_QUEUE_LENGTH       2048  
#elif defined (__ULC_AT__)
#define MAX_DATA_QUEUE_LENGTH       192 
#elif defined (__SLIM_AT__)
#define MAX_DATA_QUEUE_LENGTH       350
#elif defined (__GATI_ENABLE__)||defined (__GAS_SUPPORT__)
#define MAX_DATA_QUEUE_LENGTH	1500
#elif defined(__MRE_PACKAGE_FULL__) || defined(__MRE_PACKAGE_NORMAL__) || defined(__MRE_PACKAGE_SLIM__)
#define MAX_DATA_QUEUE_LENGTH	1500
#elif defined (__MMI_FMI__)
#define MAX_DATA_QUEUE_LENGTH       512
#else 
#define MAX_DATA_QUEUE_LENGTH       2048  
#endif 

#if defined(__DISABLE_SIM2_AT_SUPPORT__)
#define RMMI_MAX_SIM_NUM      (1)
#else
#define RMMI_MAX_SIM_NUM      (L4_MAX_SIM_NUM)
#endif

//mtk00924: output queue
//#define MAX_DATA_OUTPUT_QUEUE_LENGTH       2048 

#define MAX_UART_LENGTH             128

#define RMMI_MAX_EXT_CMD_NAME_LEN   10

#define RMMI_MAX_ERR_STR_LEN        80
//#define RMMI_MAX_ERROR_NUM          256
#define RMMI_MAX_ERROR_NUM          160

#define RMMI_MAX_ARG_NUM            16

#define RMMI_VALIDATOR_ERROR        255
#define RMMI_DEF_VALUE              0

#define RMMI_SHORT_RSP_LEN          80

#define RMMI_MAX_MELODY_LEN         64

#define RMMI_EXTEND_SYMBOL_HASH_BASE 79235168           // 38^5

#define RMMI_MAX_MSG_BASED_AT_CHANNEL 20

#if defined(__OP01__)
#define CMCC_AT_CMD_MAIN_VER   2
#define CMCC_AT_CMD_MAJOR_VER  0
#define CMCC_AT_CMD_MINOR_VER  0
#endif


#ifdef __SMS_ADDR_INTERNATIONAL_FORMAT__
#define SMS_ADDR_INTERNATIONAL_TYPE    0x91
#endif

/* 
* this enum is used to caculate the value of RMMI_MAX_CHANNEL_NUMBER
* Please don't remove any constant if you just think that it is not used in the code.
*/
enum
{
        RMMI_FIRST_CHANNEL,

    #ifdef __CMUX_SUPPORT__
        RMMI_CMUX_CHANNELS_START = RMMI_FIRST_CHANNEL,
        RMMI_CMUX_CHANNELS_END = (RMMI_CMUX_CHANNELS_START + CMUX_VP_NUM_FOR_SINGLE_SIM*RMMI_MAX_SIM_NUM - 1),
    #else
    #ifdef __BT_SUPPORT__
        RMMI_BT_CHANNELS_START,
        RMMI_BT_CHANNELS_END = RMMI_BT_CHANNELS_START + VIRTUAL_PORTS_NUM - 1,
    #endif /*__BT_SUPPORT__*/
    #endif /*__CMUX_SUPPORT__*/

    #ifdef __DUAL_TALK_MODEM_SUPPORT__
   		RMMI_USB_CHANNEL,
   	#endif
    #ifdef __USB_MULTIPLE_COMPORT_SUPPORT__
        RMMI_USB2_CHANNEL,
    #endif
    
    #if defined(__ATCI_MULTI_UART_PORT_SUPPORT__)
        RMMI_EXTRA_CHANNEL_START,
        RMMI_EXTRA_CHANNEL_END = RMMI_EXTRA_CHANNEL_START + MAX_ATCI_EXTRA_CHANNEL - 1,
    #endif

        RMMI_MAX_CHANNEL_NUMBER
};

//#if (RMMI_MAX_CHANNEL_NUMBER > 9) //from RMMI_SRC to RMMI_9 and exclude RMMI_SAT
//#error rmmi source number is less than UART port number!!
//#endif /* __USB_MULTIPLE_COMPORT_SUPPORT__, mtk02285_usb2 */

enum
{
#if defined(__LONG_MULTIPLE_CMD_SUPPORT__)
    MAX_MULTIPLE_CMD_INFO_LEN = 350,
#elif defined(__SLIM_AT__) 
    /* mtk01616_100112: Only support multiple basic cmd(ex:ATL will use),no multiple extended cmd. 20 shall be enough */
    MAX_MULTIPLE_CMD_INFO_LEN = 20,
#else 
    MAX_MULTIPLE_CMD_INFO_LEN = 40,
#endif 
#if defined(__GATI_ENABLE__) ||defined (__GAS_SUPPORT__)
    MAX_SINGLE_CMD_INFO_LEN = 1500,
#elif defined(__MRE_PACKAGE_FULL__) || defined(__MRE_PACKAGE_NORMAL__) || defined(__MRE_PACKAGE_SLIM__)
    MAX_SINGLE_CMD_INFO_LEN = 1500,
#else
    MAX_SINGLE_CMD_INFO_LEN = 700,
#endif
    MAX_PRE_ALLOCATED_BASIC_CMD_STRUCT_NODES = 3
};

typedef enum
{
    RMMI_NONE_PRESENT = 0,
    RMMI_EXTENDED_COMMAND_PRESENT,
    RMMI_BASIC_COMMAND_PRESENT,
    RMMI_WRONG_PREV_COMMAND,
    RMMI_EXECUTION_COMMAND_PRESENT
} rmmi_cmd_present_enum;

typedef enum
{
    RMMI_ECHO_OFF,
    RMMI_ECHO_ON
} rmmi_cmd_echo_enum;

typedef enum
{
    RMMI_INVALID_CMD_TYPE = 0,
    RMMI_PREV_CMD,
    RMMI_BASIC_CMD,
    RMMI_EXTENDED_CMD,
    RMMI_EXTENDED_CUSTOM_CMD,  // __RMMI_EXTEND_CUSTOM_CMD__
    RMMI_CUSTOMER_CMD
} rmmi_cmd_type_enum;



typedef enum
{
    RMMI_EXTEND_HASH_PLUS = RMMI_EXTEND_SYMBOL_HASH_BASE*0,             // + : 0*38^5
    RMMI_EXTEND_HASH_HAT = RMMI_EXTEND_SYMBOL_HASH_BASE*1,              // ^ : 1*38^5
    RMMI_EXTEND_HASH_PERCENT = RMMI_EXTEND_SYMBOL_HASH_BASE*2,       // % : 2*38^5
    RMMI_EXTEND_HASH_MONEY = RMMI_EXTEND_SYMBOL_HASH_BASE*3          // $ : 3*38^5
} rmmi_extend_symbol_hash_enum;

typedef enum
{
    RMMI_WRONG_MODE,
    RMMI_SET_OR_EXECUTE_MODE,
    RMMI_READ_MODE,
    RMMI_TEST_MODE,
    RMMI_ACTIVE_MODE
} rmmi_cmd_mode_enum;

typedef enum
{
    /* --- standard result codes, defined in V.25 Table1 --- */
    RMMI_RCODE_OK,                //0
    RMMI_RCODE_CONNECT,           //1
    RMMI_RCODE_RING,              //2
    RMMI_RCODE_NO_CARRIER,        //3
    RMMI_RCODE_ERROR,             //4
    //there is no 5 in V.25 spec.
    //RMMI_RCODE_NO_DIALTONE = 6, //6
    RMMI_RCODE_BUSY = 7,          //7
    //RMMI_RCODE_NO_ANSWER = 8,   //8

    /* --- MTK Proprietary result codes --- */
    RMMI_RCODE_CONNECT_PS = 100, //MAUI_02956467, mtk02285, for PS call
} rmmi_rsp_type_enum;

typedef enum
{
    RMMI_SPACE = ' ',
    RMMI_EQUAL = '=',
    RMMI_COMMA = ',',
    RMMI_SEMICOLON = ';',
    RMMI_COLON = ':',
    RMMI_AT = '@',
    RMMI_HAT = '^',
    RMMI_DOUBLE_QUOTE = '"',
    RMMI_QUESTION_MARK = '?',
    RMMI_EXCLAMATION_MARK = '!',
    RMMI_FORWARD_SLASH = '/',
    RMMI_L_ANGLE_BRACKET = '<',
    RMMI_R_ANGLE_BRACKET = '>',
    RMMI_L_SQ_BRACKET = '[',
    RMMI_R_SQ_BRACKET = ']',
    RMMI_L_CURLY_BRACKET = '{',
    RMMI_R_CURLY_BRACKET = '}',
    RMMI_CHAR_STAR = '*',
    RMMI_CHAR_POUND = '#',
    RMMI_CHAR_AMPSAND = '&',
    RMMI_CHAR_PERCENT = '%',
    RMMI_CHAR_PLUS = '+',
    RMMI_CHAR_MINUS = '-',
    RMMI_CHAR_DOT = '.',
    RMMI_CHAR_ULINE = '_',
    RMMI_CHAR_TILDE = '~',
    RMMI_CHAR_REVERSE_SOLIDUS = '\\',
    RMMI_CHAR_VERTICAL_LINE = '|',
    RMMI_END_OF_STRING_CHAR = '\0',
    RMMI_CHAR_0 = '0',
    RMMI_CHAR_1 = '1',
    RMMI_CHAR_2 = '2',
    RMMI_CHAR_3 = '3',
    RMMI_CHAR_4 = '4',
    RMMI_CHAR_5 = '5',
    RMMI_CHAR_6 = '6',
    RMMI_CHAR_7 = '7',
    RMMI_CHAR_8 = '8',
    RMMI_CHAR_9 = '9',
    RMMI_CHAR_A = 'A',
    RMMI_CHAR_B = 'B',
    RMMI_CHAR_C = 'C',
    RMMI_CHAR_D = 'D',
    RMMI_CHAR_E = 'E',
    RMMI_CHAR_F = 'F',
    RMMI_CHAR_G = 'G',
    RMMI_CHAR_H = 'H',
    RMMI_CHAR_I = 'I',
    RMMI_CHAR_J = 'J',
    RMMI_CHAR_K = 'K',
    RMMI_CHAR_L = 'L',
    RMMI_CHAR_M = 'M',
    RMMI_CHAR_N = 'N',
    RMMI_CHAR_O = 'O',
    RMMI_CHAR_P = 'P',
    RMMI_CHAR_Q = 'Q',
    RMMI_CHAR_R = 'R',
    RMMI_CHAR_S = 'S',
    RMMI_CHAR_T = 'T',
    RMMI_CHAR_U = 'U',
    RMMI_CHAR_V = 'V',
    RMMI_CHAR_W = 'W',
    RMMI_CHAR_X = 'X',
    RMMI_CHAR_Y = 'Y',
    RMMI_CHAR_Z = 'Z',
    rmmi_char_a = 'a',
    rmmi_char_b = 'b',
    rmmi_char_c = 'c',
    rmmi_char_d = 'd',
    rmmi_char_e = 'e',
    rmmi_char_f = 'f',
    rmmi_char_g = 'g',
    rmmi_char_h = 'h',
    rmmi_char_i = 'i',
    rmmi_char_j = 'j',
    rmmi_char_k = 'k',
    rmmi_char_l = 'l',
    rmmi_char_m = 'm',
    rmmi_char_n = 'n',
    rmmi_char_o = 'o',
    rmmi_char_p = 'p',
    rmmi_char_q = 'q',
    rmmi_char_r = 'r',
    rmmi_char_s = 's',
    rmmi_char_t = 't',
    rmmi_char_u = 'u',
    rmmi_char_v = 'v',
    rmmi_char_w = 'w',
    rmmi_char_x = 'x',
    rmmi_char_y = 'y',
    rmmi_char_z = 'z',
    RMMI_R_BRACKET = ')',  
    RMMI_L_BRACKET = '(', 
    RMMI_MONEY = '$'
} rmmi_char_enum;

typedef enum
{
    /* 07.07 Sec 9.2.1 */
    RMMI_ERR_PHONE_FAILURE,
    OPERATION_NOT_ALLOWED_ERR = 3,
    RMMI_ERR_OPERATION_NOT_SUPPORTED = 4,
    PH_SIM_PIN_REQUIRED = 5,
   PH_FSIM_PIN_REQUIRED = 6, //Kinki: SIM-ME lock [MAUI_01264994]
   PH_FSIM_PUK_REQUIRED = 7, //Kinki: SIM-ME lock [MAUI_01264994]
    SIM_NOT_INSERTED = 10,
    SIM_PIN_REQUIRED = 11,
    SIM_PUK_REQUIRED = 12,
    SIM_FAILURE = 13,
    SIM_BUSY = 14,
    SIM_WRONG = 15,
    INCORRECT_PASSWD = 16,
    SIM_PIN2_REQUIRED = 17,
    SIM_PUK2_REQUIRED = 18,
    RMMI_ERR_MEM_FULL = 20,
    RMMI_ERR_INVALID_INDEX = 21,
    RMMI_ERR_NO_FOUND = 22,
    TEXT_ERRSTRING_TOO_LONG_ERR = 24,
    INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR = 25,
    DIAL_ERRSTRING_TOO_LONG_ERR = 26, 
    INVALID_CHARACTERS_IN_DIAL_ERRSTRING_ERR = 27,
    NO_NW_SERVICE = 30,
    RMMI_ERR_NETWORK_TIMEOUT = 31,
    RMMI_ERR_NETWORK_NOT_ALLOWED = 32,
    RMMI_ERR_NW_PERSON_PIN_REQUIRED = 40,
    RMMI_ERR_NW_PERSON_PUK_REQUIRED = 41,
    RMMI_ERR_NW_SUB_PERSON_PIN_REQUIRED = 42,
    RMMI_ERR_NW_SUB_PERSON_PUK_REQUIRED = 43,
    RMMI_ERR_SP_PERSON_PIN_REQUIRED = 44,
    RMMI_ERR_SP_PERSON_PUK_REQUIRED = 45,
    RMMI_ERR_CORP_PERSON_PIN_REQUIRED = 46,
    RMMI_ERR_CORP_PERSON_PUK_REQUIRED = 47,
    RMMI_ERR_UNKNOWN = 100,

    RMMI_ERR_ILLEGAL_MS = 103,
    RMMI_ERR_ILLEGAL_ME = 106,
    RMMI_ERR_GPRS_NOT_ALLOWED = 107,
    RMMI_ERR_PLMN_NOT_ALLOWED = 111,
    RMMI_ERR_LA_NOT_ALLOWED = 112,
    RMMI_ERR_ROAMING_AREA_NOT_ALLOWED = 113,
    RMMI_ERR_SERV_OPTION_NOT_SUPPORTED = 132,
    RMMI_ERR_REQ_SERV_OPTION_NOT_SUBSCRIBED = 133,
    RMMI_ERR_SERV_OPTION_TEMP_OUT_OF_ORDER = 134,
    RMMI_ERR_GPRS_UNSPECIFIED_ERROR = 148,
    RMMI_ERR_PDP_AUTH_FAIL = 149,
    RMMI_ERR_INVALID_MOBILE_CLASS = 150,

   RMMI_ERR_LINK_NS_SP_PERSON_PIN_REQUIRED = 151, //Kinki: SIM-ME lock [MAUI_01264994]
   RMMI_ERR_LINK_NS_SP_PERSON_PUK_REQUIRED = 152, //Kinki: SIM-ME lock [MAUI_01264994]
   RMMI_ERR_LINK_SIM_C_PERSON_PIN_REQUIRED = 153, //Kinki: SIM-ME lock [MAUI_01264994]
   RMMI_ERR_LINK_SIM_C_PERSON_PUK_REQUIRED = 154, //Kinki: SIM-ME lock [MAUI_01264994]

    /* following are proprietary error cause : the cause below WON'T be showed as +CME ERROR. */
    RMMI_ERR_COMMAND_CONFLICT = 302,    //same as operation not allowed in 07.05 Sec 3.2.5
    // will be convert to +CME ERROR: 3  or +CMS ERROR: 302
    RMMI_NO_ERR = 600,

    /* following: error is related to syntax, invalid parameters.. */
    /* according to spec 07.07 Sec 9.1, only "ERROR" will be returned to TE side */
    RMMI_ERR_UNRECOGNIZED_CMD = 601,
    RMMI_ERR_RETURN_ERROR = 602,
    RMMI_ERR_SYNTEX_ERROR = 603,
    RMMI_ERR_UNSPECIFIED = 604, //unspecified parsing error
    RMMI_ERR_DATA_TRANSFER_ALREADY = 605,
    RMMI_ERR_ACTION_ALREADY = 606,
    RMMI_ERR_NOT_AT_CMD = 607,
    RMMI_ERR_MULTI_CMD_TOO_LONG = 608,
    RMMI_ERR_ABORT_COPS = 609,
    RMMI_ERR_NO_CALL_DISC = 610,
    RMMI_ERR_BT_SAP_UNDEFINED = 611,
    RMMI_ERR_BT_SAP_NOT_ACCESSIBLE = 612,
    RMMI_ERR_BT_SAP_CARD_REMOVED = 613,

    RMMI_ERR_AT_NOT_ALLOWED_BY_CUSTOMER = 614
} rmmi_err_id_enum;

typedef enum
{
    FAC_NOT_SUPPORTED,
    SS_FAC_BEGIN = L4_BAOC,
    SS_FAC_END = L4_BIC,
#ifdef __MOD_SMU__
    SIM_FAC_BEGIN = TYPE_CHV1,  /* need to add sim sec type */
    SIM_FAC_END = TYPE_IMSI_LOCK
#endif /* __MOD_SMU__ */ 
} rmmi_clck_fac_enum;

typedef enum
{
    RMMI_PLAY = 1,
    RMMI_STOP,
    RMMI_PAUSE,
    RMMI_RESUME
} rmmi_audio_mode_enum;

typedef enum
{
    CCBS_Interrotage = 14,
    CCBS_EarseCCEntry = 77
} rmmi_ccbs_opcode_enum;

typedef enum
{
    RMMI_FS_OPEN,
    RMMI_FS_CLOSE,
    RMMI_FS_READ,
    RMMI_FS_WRITE,
    RMMI_FS_DELETE,
    RMMI_FS_DIR,
    RMMI_FS_CREATEDIR,
    RMMI_FS_DELETEDIR,
    RMMI_FS_RENAME
} rmmi_fs_opcode_enum;

typedef enum
{
    CSSI_CFU_ACTIVE,
    CSSI_CFC_ACTIVE,
    CSSI_CALL_FORWARDED,
    CSSI_CALL_WAITING,
    CSSI_CUG_CALL,
    CSSI_OUTGOING_BARRED,
    CSSI_INCOMING_BARRED,
    CSSI_CLIR_REJECTED,
    CSSI_CALL_DEFLECTED
} rmmi_cssi_enum;       //refer to 07.07 +CSSN

typedef enum
{
    CSSU_FORWARDED_CALL,
    CSSU_CUG_CALL,
    CSSU_CALL_HOLD,
    CSSU_CALL_RETRIEVED,
    CSSU_MPTY_CALL,
    CSSU_HOLDCALL_RELEASED,
    CSSU_FORWARD_CHECK_SS,
    CSSU_ECT_ALERTING,
    CSSU_ECT_ACTIVE,
    CSSU_DEFLECTED_CALL,
    CSSU_INCOMING_FORWARDED
} rmmi_cssu_enum;       //refer to 07.07 +CSSN

/* mtk00714 add on 2004/03/02 */
/* first 10 items (except GPRS_REQ) 
   should be consistant with "l4ccsm_cc_call_mode_enum" */
typedef enum
{
    RMMI_CRING_VOICE,
    RMMI_CRING_DATA,
    RMMI_CRING_FAX,
    RMMI_CRING_VOICE_DATA,
    RMMI_CRING_ALT_VOICE_DATA,
    RMMI_CRING_ALT_VOICE_FAX,
    RMMI_CRING_DATA_VOICE,
    RMMI_CRING_ALT_DATA_VOICE,
    RMMI_CRING_ALT_FAX_VOICE,
    RMMI_CRING_UNKNOWN_TYPE,
    RMMI_CRING_GPRS,
    RMMI_CRING_VOICE_AUX,
    RMMI_CRING_VIDEO
} rmmi_cring_type_enum;

typedef enum
{
    RMMI_DCS_DEFAULT = 0x00,    /* GSM 7-bit */
    RMMI_DCS_8BIT = 0x04,       /* 8-bit */
    RMMI_DCS_UCS2 = 0x08        /* UCS2 */
}
rmmi_dcs_enum;

typedef enum
{
    RMMI_PARSE_OK,
    RMMI_PARSE_ERROR,   //out of range
    RMMI_PARSE_NOT_FOUND,
    RMMI_PARSE_TEXT_TOO_LONG
} rmmi_validator_cause_enum;

typedef enum
{
    RMMI_PHB_NONE,
    RMMI_PHB_SM,
    RMMI_PHB_ME,
    RMMI_PHB_FD,
    RMMI_PHB_LD,
    RMMI_PHB_MC,
    RMMI_PHB_RC,
    RMMI_PHB_MT,
    RMMI_PHB_EN,
    RMMI_PHB_ON,
    RMMI_PHB_DC,
    /* mtk02514 ** MAUI_01321633  ** 2009/02/16 **********
    * for the storage containing LD(DC), MC, RC                                     //mtk02514_la
    * We only support AT+CPBS, AT+CPBR for the RMMI_PHB_LA
    ************************************************/
    RMMI_PHB_LA        
} rmmi_phb_type_enum;

typedef enum
{
    RMMI_EIND_SMS_READY_BIT,
    RMMI_EIND_PHB_READY_BIT = 1,
    RMMI_EIND_PLMN_CHANGED_BIT = 2,
    RMMI_EIND_EONS_CHANGED_BIT = 3,    
    RMMI_EIND_INVALID_SIM_BIT = 4,
    RMMI_EIND_AT_READY_BIT = 7
} rmmi_eind_bit_enum;


#ifdef __SP_RIL_SUPPORT__
//Make sure the order of einfo bit is identical to MOLY
typedef enum
{
    RMMI_ESMLA_BIT,     /* bit 1 is for +ESMLA */
    RMMI_ECFU_BIT,      /* bit 2 is for +ECFU */
    RMMI_ECELLINFO_BIT, /* bit 3 is for +ECELLINFO */ 
    RMMI_ENWINFO_BIT,   /* bit 4 is for +ENWINFO */ 
    RMMI_ESPEECH_BIT,   /* bit 5 is for +ESPEECH */
    RMMI_STKPCI_BIT,    /* bit 6 is for +STKPCI */
    RMMI_ECIPH_BIT,     /* bit 7 is for +ECIPH */
    RMMI_EMMRRS_BIT,    /* bit 8 is for +EMMRRS, for GEMINI project, report MMRR service status */
    RMMI_EPKTFI_BIT,    /* bit 9 is for +EPKTFI, this is for RATDM to notify AP there is packet flush due to RB release, AP will do retransmission */
    RMMI_EWARNING_BIT,  /* bit 10 is for +EWARNIN */
    RMMI_STKCTRL_BIT    /* bit 11 is for +STKCTRL */
}rmmi_einfo_bit_enum;

#else

typedef enum
{
    RMMI_ESMLA_BIT,        /* bit 1 is for +ESMLA */
    RMMI_ECFU_BIT,         /* bit 2 is for +ECFU */
    RMMI_ECELLINFO_BIT,	   /* bit 3 is for +ECELLINFO */   
    RMMI_ENWINFO_BIT,      /* bit 4 is for +ENWINFO */      
    RMMI_ESPEECH_BIT,       /* bit 5 is for +ESPEECH */
    RMMI_EUSIM_BIT,       /* bit 6 is for +EUSIM */
    RMMI_ECIPH_BIT,       /* bit 7 is for +ECIPH */
	RMMI_STKPCI_BIT		  /* bit 8 is for +ECIPH */
} rmmi_einfo_bit_enum;
#endif /* __SP_RIL_SUPPORT__ */

typedef enum
{
    RMMI_IMEI_NO_ACTION = 0,
    RMMI_IMEI_READ,
    RMMI_IMEI_WRITE,
    RMMI_IMEI_2_WRITE,
    RMMI_IMEI_3_WRITE,
    RMMI_IMEI_4_WRITE
} rmmi_imei_action_enum;

/* battchg    1 */
/* signal     2 */
/* service    3 */
/* message    4 */
/* call       5 */
/* roam       6 */
/* smsfull    7 */
/* call_setup 8 */

/*
 * typedef enum
 * {
 * RMMI_CCSR_IDLE,
 * RMMI_CCSR_CALLING,
 * RMMI_CCSR_CONNECTING,
 * RMMI_CCSR_ACTIVE,
 * RMMI_CCSR_HOLD,
 * RMMI_CCSR_WAITING,
 * RMMI_CCSR_ALERTING,
 * RMMI_CCSR_BUSY
 * 
 * } rmmi_ccsr_rsp_code_enum;
 * 
 */

typedef enum
{
    RMMI_EADP_NO_ACTION = 0,
    RMMI_EADP_GET,
    RMMI_EADP_SET
} rmmi_eadp_action_enum;

typedef enum
{
    RMMI_EAPS_NO_ACION = 0,
    RMMI_EAPS_GET,
    RMMI_EAPS_SET,
    RMMI_EAPS_WB_INPUT_FIR_GET,
    RMMI_EAPS_WB_INPUT_FIR_SET,
    RMMI_EAPS_WB_OUTPUT_FIR_GET,
    RMMI_EAPS_WB_OUTPUT_FIR_SET,
    RMMI_EAPS_WB_MODE_PARAM_GET,
    RMMI_EAPS_WB_MODE_PARAM_SET
} rmmi_eaps_action_enum;

/* For VoIP, call management is controlled by MMI */
typedef enum
{
    RMMI_CM_ATD = 0,
    RMMI_CM_ATH,
    RMMI_CM_ATA,
    RMMI_CM_CHLD,
    RMMI_CM_BLDN
} rmmi_cm_action_enum;

/* for +EMMISTR proprietary command */
typedef enum
{
    RMMI_EMMISTR_DISABLE = 0,
    RMMI_EMMISTR_ENABLE,
    RMMI_EMMISTR_DATA_FROM_MMI
} rmmi_emmistr_action_enum;

#if defined(__GEMINI__) && !defined(__MMI_FMI__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__GEMINI__) && !defined(__MMI_FMI__) */

typedef enum
{
    RMMI_SML_NP_CATEGORY,
    RMMI_SML_NSP_CATEGORY,
    RMMI_SML_SP_CATEGORY,
    RMMI_SML_CP_CATEGORY,
    RMMI_SML_SIM_CATEGORY
} rmmi_sml_catagory_enum;

/* mtk01616_090116: for atd> memory dial to distinguish call_type */
typedef enum
{
    RMMI_MEM_DIAL_NONE = 0,
    RMMI_MEM_DIAL_VOICE = 1,
    RMMI_MEM_DIAL_DATA = 2    
} rmmi_mem_dial_enum;

//mtk01616_091024: ATCI internal used enum,intended for rmmi_fax_support_check()
typedef enum
{
    RMMI_SERV_CLASS_0   = 0x01,
    RMMI_SERV_CLASS_1   = 0x02,
    RMMI_SERV_CLASS_1_0 = 0x04,
    RMMI_SERV_CLASS_2   = 0x08,
    RMMI_SERV_CLASS_2_0 = 0x10
} rmmi_fax_check_type_enum;

typedef enum
{
  	RMMI_USM_ATCMD_CGSMS,
	RMMI_USM_ATCMD_CSCA,
	RMMI_USM_ATCMD_CSMP,
	RMMI_USM_ATCMD_CSCB,
  	RMMI_USM_ATCMD_CMGL,
  	RMMI_USM_ATCMD_CMGR,
  	RMMI_USM_ATCMD_CMSS,
  	RMMI_USM_ATCMD_CMGW,
  	RMMI_USM_ATCMD_CMGD,
  	RMMI_USM_ATCMD_CNMI,
  	RMMI_USM_ATCMD_NULL
} rmmi_usm_atcmd_enum;	
typedef enum
{
	RMMI_USM_DOMAIN_PS_ONLY, 
	RMMI_USM_DOMAIN_CS_ONLY,
	RMMI_USM_DOMAIN_PS_PREFERRED, 
	RMMI_USM_DOMAIN_CS_PREFERRED,
	RMMI_USM_DOMAIN_NULL
} rmmi_usm_domain_enum;
typedef enum
{
  	RMMI_USM_SM = 0,			
  	RMMI_USM_ME = 1, 			
  	RMMI_USM_SR = 2, 
  	RMMI_USM_BM =3,
  	RMMI_USM_TA = 4,
  	RMMI_USM_SM_PREFER = 5,
  	RMMI_USM_ME_PREFER = 6,
  	RMMI_USM_MT = 7,
  	RMMI_USMSTORAGE_UNSPECIFIED = 7
} rmmi_usm_memory_enum;
typedef enum
{
  	RMMI_USM_REC_UNREAD = 0,
	RMMI_USM_REC_READ,
	RMMI_USM_STO_UNSENT,
	RMMI_USM_STO_SENT,
	RMMI_USM_ALL,
	RMMI_USM_STAT_NULL
}rmmi_usm_message_stat_enum;
typedef enum
{
  	RMMI_FKPD_PRESS = 0,
	RMMI_FKPD_RELEASE,
	RMMI_FKPD_NULL
}rmmi_fkpd_stat_enum;

typedef enum
{
    RMMI_DIAG_FOR_TST = 0,
    RMMI_DIAG_FOR_AT,
    RMMI_DIAG_FOR_UNKNOWN = 0xff
} rmmi_diag_func_enum; /* __USB_MULTIPLE_COMPORT_SUPPORT__, mtk02285_usb2 */


typedef enum 
{
   RMMI_FM_TURN_OFF,
   RMMI_FM_SET,
   RMMI_FM_SEARCH_UP,
   RMMI_FM_SEARCH_DOWN
}rmmi_fm_opcode_enum;

typedef enum 
{
   RMMI_CPBW_ENCODE_IRA,
   RMMI_CPBW_ENCODE_UCS2,
   RMMI_CPBW_ENCODE_UCS2_81,
   RMMI_CPBW_ENCODE_UCS2_82,
   RMMI_CPBW_ENCODE_MAX
}rmmi_cpbw_encode_enum;

typedef enum 
{
    RMMI_EPBUM_EF_ANR,
    RMMI_EPBUM_EF_EMAIL,
    RMMI_EPBUM_EF_SNE,
    RMMI_EPBUM_EF_AAS,
    RMMI_EPBUM_EF_GAS,
    RMMI_EPBUM_EF_GRP,
    RMMI_EPBUM_EF_MAX
}rmmi_epbum_ef_type_enum;

typedef enum 
{
    RMMI_EPBUM_OP_QUERY,
    RMMI_EPBUM_OP_READ,
    RMMI_EPBUM_OP_WRITE,
    RMMI_EPBUM_OP_DELETE,
    RMMI_EPBUM_OP_MAX
}rmmi_epbum_op_enum;

#ifdef __OP01__
typedef enum //for ^ORIG, ^CONF, ^CONN, ^CEND
{
    RMMI_MO_STATE_NONE,
    RMMI_MO_STATE_ORIG,
    RMMI_MO_STATE_CONF,
    RMMI_MO_STATE_CONN,
    RMMI_MO_STATE_CEND
} rmmi_mo_state_enum;

typedef enum
{
    RMMI_MO_CALL_TYPE_VOICE = 0,
    RMMI_MO_CALL_TYPE_CS_DATA = 1,
    RMMI_MO_CALL_TYPE_PS_DATA = 2,
    RMMI_MO_CALL_TYPE_EMERGENCY = 9,
    RMMI_MO_CALL_TYPE_UNKNOWN
} rmmi_mo_call_type_enum;

typedef enum
{
    CM_CALL_END_OFFLINE = 0, //respond NO CARRIER, no ^CEND
    CM_CALL_END_NO_SRV = 27, //respond NO CARRIER, no ^CEND
    CM_CALL_END_CLIENT_END = 29,
    CM_CALL_END_CONF_FAILED = 101,
    CM_CALL_END_NETWORK_END = 104
} rmmi_cm_call_end_status_enum;

typedef enum //refer to clcc_state_enum
{
    RMMI_DSCI_STATE_ACTIVE = 0,
    RMMI_DSCI_STATE_HELD,
    RMMI_DSCI_STATE_MO_DIALING,
    RMMI_DSCI_STATE_MO_ALERT,
    RMMI_DSCI_STATE_MT_INCOMING,
    RMMI_DSCI_STATE_MT_WAITING,
    RMMI_DSCI_STATE_CALL_END,
    RMMI_DSCI_STATE_NONE
} rmmi_dsci_call_state_enum;

typedef enum
{
    RMMI_DSCI_TYPE_VOICE = 0,
    RMMI_DSCI_TYPE_DATA
} rmmi_dsci_call_type_enum;

typedef enum
{
    RMMI_DSCI_ASYNC = 0,
    RMMI_DSCI_SYNC,
    RMMI_DSCI_REL_ASYNC,
    RMMI_DSCI_REL_SYNC,
    RMMI_DSCI_UNKNOWN_DATA_TYPE
} rmmi_dsci_data_type_enum;
#endif /* __OP01__ */

typedef enum
{
    RMMI_ETWS_IS_NEEDED = 0x01,
    RMMI_ETWS_IS_SECURITY_NEEDED = 0x02,
    RMMI_ETWS_IS_TESTING_ON = 0x04,
    RMMI_ETWS_SETTING_MAX = 0x07    /*Please update this value if adding setting flag*/
}rmmi_etws_setting_enum;

typedef enum
{
    RMMI_WAKE_UP_MD,
    RMMI_WAKE_UP_AP
} rmmi_wakeup_type_enum;

#if defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__)
typedef enum
{
/* refer to DCL_UART_DEV defined in dcl_uart.h */
    ETSTLP_UART_PORT1,
    ETSTLP_UART_PORT2,
    ETSTLP_USB1,
    ETSTLP_USB2,
    ETSTLP_DT_PORT
} rmmi_etstlp_port_enum;
#endif /* defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__) */

#endif /* _RMMI_COMMON_ENUM_H */
