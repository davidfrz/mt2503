/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   wgui_categories_idlescreen.c
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 * Idle Screen related categories.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"
#include "CustThemesRes.h"
#include "wgui_softkeys.h"
#include "gui_font_size.h"
#include "IdleAppDef.h"
#include "IdleHomescreenGprot.h"
#include "DialerGprot.h"
#include "SettingGprots.h"
#include "PhoneSetup.h"
#include "gui_hardware_dependent.h"
#include "wgui_status_icon_bar.h"
#include "wgui_softkeys.h"
#ifdef __MMI_AUDIO_PLAYER__
/* dependent headers for AudioPlayerXXX.h" */
#include "Conversions.h"
#endif /* __MMI_AUDIO_PLAYER__ */


#ifdef __MMI_AUDIO_PLAYER__
#include "AudioPlayerType.h"
#endif /* __MMI_AUDIO_PLAYER__ */ 

#include "SATGProts.h"

#include "fs_type.h"

#if defined(__MMI_OP01_DCD__)
#include "DCDGprot.h"
#include "ui_dcd_porting.h"   /* for DCD idle screen */
#endif /* defined(__MMI_OP01_DCD__) */

#include "Drm_gprot.h"  /* DRM check */

#if defined(__MMI_CALENDAR_ON_IDLE_SCREEN__)
#include "CalendarGprot.h"
#endif /* defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) */

#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif	/* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_IDLE_SCREEN_ICON_SHORTCUT__
#include "wgui_icon_bar.h"
#endif /* __MMI_IDLE_SCREEN_ICON_SHORTCUT__ */

#include "lcd_if.h"

#include "IdleHomescreenGprot.h"
#ifdef __PLUTO_MMI_PACKAGE__
#include "UMGProt.h"
#endif

#include "IdleGprot.h"

#if defined(__MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)   
#include "HomeScreenOp11V32Gprot.h"     
#endif /* defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__) */

/*RHR changes*/
#include "gdi_const.h"
#include "gdi_include.h"
#include "gdi_datatype.h"
#include "MMIDataType.h"
#include "gui_config.h"
#include "wgui_categories_idlescreen.h"
#include "gui_data_types.h"
#include "gui_windows.h"
#include "kal_general_types.h"
#include "gui_buttons.h"
#include "mmi_rp_app_uiframework_def.h"
#include "gui_effect_oem.h"
#include "gui.h"
#include "wgui.h"
#include "wgui_categories_util.h"
#include "gui_typedef.h"
#include "wgui_include.h"
#include "gui_themes.h"
#include "l4c_nw_cmd.h"
#include "mmi_rp_srv_status_icons_def.h"
#include "PixcomFontEngine.h"
#include "gui_switch.h"
#include "wgui_draw_manager.h"
#include "string.h"
#include "Unicodexdcl.h"
#ifndef __OPTR_NONE__
#include "operator_gui.h"
#endif
#include "wgui_categories_idlescreen_op.h"
#include "app_datetime.h"
#include "PhoneSetupResList.h"
#include "lcd_sw_inc.h"
#include "Gui_Setting.h"
#include "drm_def.h"
#include "fs_errcode.h"
#include "GlobalResDef.h"
#include "MessagesMiscell.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "CustDataRes.h"
#include "mmi_frm_input_gprot.h"
#include "wgui_touch_screen.h"
#include "mmi_frm_events_gprot.h"
#include "wgui_categories_enum.h"
#include "wgui_categories_list.h"
#include "drm_errcode.h"
#include "custom_mmi_default_value.h"
#include "mmi_rp_app_idle_def.h"
#include "IdleAppResDef.h"
#include "wgui_inputs.h"
#include "gui_inputs.h"
#include "ScrLockerGprot.h"
#include "WguiCategoryGprot.h"
/*RHR changes*/

#if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
#include "UcmSrvGprot.h"
#include "VolumeHandler.h"

#define MMI_BT_BOX_IDLE_SHORTCUTS_Y  179
static MMI_BOOL g_up_down_key_change_volume = MMI_FALSE;
#endif /* __MMI_BT_BOX_IDLE_SHORTCUTS__ */

#ifdef __MMI_BT_DIALER_SUPPORT__
#include "BtcmSrvGprot.h"
#include "mmi_rp_app_bluetooth_def.h"

#ifdef __MMI_MAINLCD_128X128__
#define MMI_IDLE_STATUS_BT_NAME_GAP 2
#else
#ifdef __MMI_DUAL_SIM__
/* under construction !*/
#else
#define MMI_IDLE_STATUS_BT_NAME_GAP 8
#endif
#endif /* __MMI_MAINLCD_128X128__ */
#endif /* __MMI_BT_DIALER_SUPPORT__ */

#define  NORMAL_IDLE_SCREEN        0
#define  ANALOG_IDLE_SCREEN        1
#define  DIGITAL_IDLE_SCREEN       2

#define  NORMAL_SCREEN_SAVER       0
#define  ANALOG_SCREEN_SAVER       1
#define  DIGITAL_SCREEN_SAVER      2

#ifndef __MMI_PHNSET_SLIM__
#define  VIEW_WALLPAPER_CLOCK      1
#define  VIEW_SCREENSAVER_CLOCK    2
#define  PREVIEW_CLOCK             3
#endif

#define  min(a,b)    (((a) < (b)) ? (a) : (b))

#ifndef WIN32
extern MMI_BOOL srv_backlight_is_lcd_sleep(void);
#endif

GDI_HANDLE wgui_layer_1 = GDI_LAYER_EMPTY_HANDLE;
GDI_HANDLE wgui_base_layer = GDI_LAYER_EMPTY_HANDLE;

U8 idle_screen_type = NORMAL_IDLE_SCREEN;
/*
#ifdef __MMI_WALLPAPER_ON_BOTTOM__
static U8 gIsWallpaperChange = 0;
#endif 
*/
static S32 gis_on_idlescreen = 0;
#ifdef __MMI_SEARCH_WEB__
static scrolling_text g_search_tab_scroll_text;
#endif
#ifdef __DRM_SUPPORT__
static S32 consumer;
#endif

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
static wgui_cat033_reminder_area_info g_wgui_cat033_reminder[wgui_cat033_reminder_total] = {0};  /* reminder array */
#endif
#if defined(__MMI_SEARCH_WEB__)
static wgui_cat033_search_area_info g_wgui_cat033_search;
#endif
UI_string_type idle_screen_network_name = NULL;    /* idle screen netwrok name */
UI_string_type idle_screen_network_status = NULL;  /* idle screen network status */

#ifdef __MMI_BT_DIALER_SUPPORT__
//#define BT_PROFILES_LINK_NUM (BT_PROFILES_LINK_NUM) //__BT_MAX_LINK_NUM__
srv_bt_cm_dev_struct *g_idle_scr_bt_dev_info[BT_PROFILES_LINK_NUM];
WCHAR g_idle_scr_bt_pairing_name[SRV_BT_CM_BD_FNAME_LEN];
WCHAR g_pairing_name_output_buf[BT_PROFILES_LINK_NUM][SRV_BT_CM_BD_FNAME_LEN + 20];
MMI_BOOL g_idle_scr_bt_dialer_connected = MMI_FALSE;  /* idle screen BT dialer connection status */
static scrolling_text g_bt_dialer_pairing_names_scroll;
S32 g_disconn_sel_idx;
U32 g_scroll_count;
#endif

scrolling_text extra_scrolling_text;    /* idle screen scrolling text */
scrolling_text *extra_scrolling_text_ptr = NULL;  /* idle screen scrolling text pointer */
S32 extra_text_x1 = -1;
S32 extra_text_y1 = -1;
S32 extra_text_x2 = -1;
S32 extra_text_y2 = -1;
static MMI_BOOL g_wgui_cat033_redraw_scrolling_text = MMI_TRUE;    /* record if need to redraw scrolling text */
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
static MMI_BOOL g_wgui_cat033_techno_text_scroll = MMI_FALSE;      /* record if scroll network name & network status on techno bar */
#endif
static GDI_HANDLE g_wgui_cat033_text_abm_layer = GDI_NULL_HANDLE;  /* abm source layer for print text */
/* VIJAYAN*/
#ifdef __MMI_LAUNCHER_APP_LIST__
typedef enum
{
    NETWORK1_NAME_TEXT_ON_IDLE,
    NETWORK2_NAME_TEXT_ON_IDLE,
    TECHNO_TEXT_TYPE_TOTAL
} wgui_cat030_text_type;

#define WGUI_CAT030_TECHNO_STRING_SPACE (1.4)
#define WGUI_CAT030_PAUSE_TIMER (5000)
#define WGUI_CAT030_VSCROLL_TIMER (500)

static MMI_BOOL g_wgui_cat030_redraw_scrolling_text = MMI_TRUE;    /* record if need to redraw scrolling text */
static S32 g_wgui_cat030_lock_network_scroll_count = 0;
static U8 g_wgui_cat030_current_text_type = NETWORK1_NAME_TEXT_ON_IDLE;
static U8 g_wgui_cat030_operator_on_fancy_lock_screen = 0;
#endif

S32 cat33_image_x;         /* x position of wallpaer */
S32 cat33_image_y;         /* y position of wallpaer */
S32 cat33_image_width;     /* image width of wallpaer */
S32 cat33_image_height;    /* image height of wallpaper */

S32 cat33_n_frames = 0;      /* total number frames of animation wallpaper */
S32 cat33_frame_number = 0;  /* current frame number of animation wallppaer */
S32 cat33_animation_delay = 1000;  /* the delay time to show next frame of animation wallpapaer */

U8 screen_saver_type = NORMAL_SCREEN_SAVER;   /* type of screen saver (normal, analog, digital) */
PU8 ScreenSaverName;

#ifdef __MMI_ANALOG_CLOCK__
void analog_clock_initialize(void);
#endif

void draw_wallpaper(void);


extern S32 MAIN_LCD_device_width;   /* Main lcd width */
extern S32 MAIN_LCD_device_height;  /* Main LCD height */

extern BOOL r2lMMIFlag;  /* R2L characters */

extern U16 on_idle_screen;

#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
extern GDI_HANDLE animation_handle;
#endif 

extern MMI_ID_TYPE idle_screen_wallpaper_ID;       /* image id of wallpaper */
extern CHAR *idle_screen_wallpaper_name;             /* image name of wallpaper */
extern CHAR *idle_screen_wallpaper_name_original;
extern CHAR *idle_screen_screensaver_name;
#ifndef __MMI_VIEW_SETTING_DISABLE_CACHE__
extern CHAR *idle_screen_cache_name;
extern MMI_ID_TYPE idle_screen_cache_id;
#endif
extern S32 PhnsetScreenSaverBadFileCallBack(U16 StrID);
extern void PhnsetWallpaperBadFileCallBack(U16 imgID);

extern void dm_set_scr_bg_image_no_draw(U16 image_id, CHAR *file_name, S32 x, S32 y, U8 opacity);

//extern U16 title_bg_id;

extern icontext_button MMI_softkeys[];

extern void leave_idle_screen(void);

#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
extern void mmi_um_entry_main_message_menu(void);
#endif

#if defined (__MMI_TOUCH_SCREEN__) && defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__)
extern void gui_touch_feedback_play(gui_touch_feedback_enum event_enum);
#endif

#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
#endif /* __MMI_DUAL_SIM_MASTER__ */

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
typedef enum
{
    NETWORK_NAME_TEXT_ON_IDLE,
    NETWORK_STATUS_TEXT_ON_IDLE,
    TECHNO_TEXT_TYPE_TOTAL
} wgui_cat033_techno_text_type;

#define WGUI_CAT033_TECHNO_STRING_SPACE (1.4)
#define WGUI_CAT033_PAUSE_TIMER (5000)
#define WGUI_CAT033_VSCROLL_TIMER (500)

MMI_ID_TYPE idlescreen_bar_id = IMG_TECHNO_ANALOG_CLOCK;
static U8 g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;
static S32 g_wgui_cat033_techno_scroll_count = 0;

extern MMI_BOOL PhnsetGetShowDateTimeStatus(void);

#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
#endif /* __MMI_DUAL_SIM_MASTER__ */
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 


#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
typedef enum
{
    SIM1_TEXT_ON_IDLE,
    SIM2_TEXT_ON_IDLE
} wgui_cat033_dual_sim_text_type;
static U8 g_wgui_cat033_dual_sim_current_text_type = SIM1_TEXT_ON_IDLE;
#endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */


#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
#if 0
/* under construction !*/
/* under construction !*/
#endif
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
#if defined(__MMI_MAINLCD_96X64__) || defined(__MMI_BT_DIALER_SUPPORT__)
    static scrolling_text g_network_names_scroll;
#endif

S32 wgui_get_idle_screen_is_extra_text(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(wgui_cat033_get_extra_text())
    {
        return 1;
    }
    return 0;

    
}

/*****************************************************************************
 * FUNCTION
 *  is_on_idlescreen
 * DESCRIPTION
 *  Get is on idlescreen
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 is_on_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return gis_on_idlescreen;
}


/*****************************************************************************
 * FUNCTION
 *  set_on_idlescreen
 * DESCRIPTION
 *  is on idlescreen
 * PARAMETERS
 *  temp_on_idlescreen      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void set_on_idlescreen(S32 temp_on_idlescreen)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gis_on_idlescreen = temp_on_idlescreen;
}

#ifdef __GDI_MEMORY_PROFILE_2__

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_set_text_abm_layer
 * DESCRIPTION
 *  set category33 text abm layer
 *  before print text, it should set abm source layer.
 * PARAMETERS
 *  abm_layer      [IN]        ABM source layer
  * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_set_text_abm_layer(GDI_HANDLE abm_layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_text_abm_layer = abm_layer;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_reset_text_abm_layer
 * DESCRIPTION
 *  reset category33 abm layer
 * PARAMETERS
 *  void
  * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_reset_text_abm_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_text_abm_layer = GDI_NULL_HANDLE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_text_abm_layer
 * DESCRIPTION
 *  get category33 abm layer
 *  this function is used before printing text
 * PARAMETERS
 *  void
  * RETURNS
 *  GDI_HANDLE
 *****************************************************************************/
static GDI_HANDLE wgui_cat033_get_text_abm_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE handle;	

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_text_abm_layer != GDI_NULL_HANDLE)
    {
        handle = g_wgui_cat033_text_abm_layer;
    }
    else
    {
        gdi_layer_get_active(&handle);
    }
    return handle;	
}

#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_draw_region_with_wallpaper
 * DESCRIPTION
 *  redraw a region by using the wallpaper
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_draw_region_with_wallpaper(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#endif
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);

    if (idle_screen_wallpaper_ID == 0)
    {
        S32 disp_height = UI_device_height, disp_width = UI_device_width;

    #ifndef __MMI_IDLE_FULL_SCREEN__
        disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
        disp_width = UI_device_width - 1;
    #endif /* __MMI_IDLE_FULL_SCREEN__ */ 

        if ((disp_width >= cat33_image_width) && (disp_height >= cat33_image_height)) /* image can be displayed entirely */
        {
            S32 offset_x = 0;
            S32 offset_y = 0;

            /* align preview window at the center of screen */
            offset_x = (disp_width - cat33_image_width) >> 1;
            offset_y = (disp_height - cat33_image_height) >> 1;

            gdi_image_draw_file(offset_x, offset_y, (CHAR *) idle_screen_wallpaper_name);
        }
        else    /* image is larger than screen size */
        {
            S32 resized_offset_x;
            S32 resized_offset_y;
            S32 resized_width;
            S32 resized_height;

            gdi_image_util_fit_bbox(
                disp_width,
                disp_height,
                cat33_image_width,
                cat33_image_height,
                &resized_offset_x,
                &resized_offset_y,
                &resized_width,
                &resized_height);

            gdi_image_draw_resized_file(
                resized_offset_x,
                resized_offset_y,
                resized_width,
                resized_height,
                (CHAR *) idle_screen_wallpaper_name);
        }
    }
    else
    {
        idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
        if (cat33_n_frames > 1)
        {
            gui_show_animated_image_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
        }
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gui_show_image(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_draw_region_with_background_color
 * DESCRIPTION
 *  clear a region to background color
 * PARAMETERS
 *  x1       [IN]     start x position
 *  y1       [IN]     start y position
 *  x2       [IN]     end x position
 *  y2       [IN]     end y position
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_draw_region_with_background_color(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#endif
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gdi_layer_pop_clip();
}


#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_border_string_right_align
 * DESCRIPTION
 *  show border string in right align of x, center align of y in techno bar region
 *  If the string widther than given region, the string will be truncated
 * PARAMETERS
 *  void
 * RETURNS
 *  S32 :  x1 position (left position of string)
 *****************************************************************************/
static S32 wgui_cat033_show_techno_border_string_right_align(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, x_pos = 0, y_pos = 0;
#ifdef __GDI_MEMORY_PROFILE_2__
    GDI_HANDLE wallpaper_layer;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __GDI_MEMORY_PROFILE_2__
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
#endif
    /* get string information */
    gui_measure_string(string, &string_w, &string_h);
    string_w += 2;  /* border text */
    string_h += 2;  /* border text */
    
    y_pos = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) - 1;

#ifdef __GDI_MEMORY_PROFILE_2__
    /* set alpha blending layer */
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
#endif
    
    if (string_w < x2 - x1 + 1) /* full display */
    {
        x_pos = (r2lMMIFlag) ? (x2) : (x2 - string_w + 1);
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_move_text_cursor(x_pos, y_pos);
        gui_print_bordered_text(string);
    }
    else
    {
        x_pos = (r2lMMIFlag) ? (x2) : (x1);
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_print_truncated_borderd_text(x_pos, y_pos, x2 - x1 - 1, string);
    }
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif
    return ((r2lMMIFlag) ? (x_pos + 1) : (x_pos - 1));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_draw_background_with_technobar
 * DESCRIPTION
 *  draw a region with technobar background
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_draw_region_with_technobar(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
    gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    gdi_layer_pop_clip();
}


static U32 wgui_cat033_techno_clock_date = WGUI_CLOCK_INVALID_INDEX;
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_techno_init_date
 * DESCRIPTION
 *  init date on technobar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_techno_init_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width = 0, height = 0, x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    UI_font_type text_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    text_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_DATE);

    /* date */
    wgui_clock_create(
        &wgui_cat033_techno_clock_date,               /* local date */
        0, 0, 0, 0,                           /* will move & assign layer */
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);         /* display date and day */

    /* set date string attribute */
    wgui_clock_set_text_border_enable(wgui_cat033_techno_clock_date, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat033_techno_clock_date, *current_MMI_theme->idle_scr_date_border_color);
    wgui_clock_set_date_text_color(wgui_cat033_techno_clock_date, *current_MMI_theme->idle_scr_date_color);
    wgui_clock_set_date_text_font(wgui_cat033_techno_clock_date, text_font); 

    /* set date string clear function */
    wgui_clock_set_hide_function(wgui_cat033_techno_clock_date, wgui_cat033_draw_region_with_technobar);

    /* set date string position & size */
    wgui_clock_measure_date_text(wgui_cat033_techno_clock_date, &width, &height, text_font);

    /* calculate date max region */
    x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
    x2 = UI_device_width - MMI_SIGNAL_WIDTH;

#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
#else
    y1 = MMI_status_bar_height + (MMI_IDLESCREEN_BAR_HEIGHT >> 1) - 1;
    y2 = y1 + (MMI_IDLESCREEN_BAR_HEIGHT >> 1) - 1;
#endif /* __MMI_DUAL_SIM_MASTER__ */
        
    wgui_clock_move(wgui_cat033_techno_clock_date, x1, y1);
    wgui_clock_resize(wgui_cat033_techno_clock_date, x2 - x1 + 1, y2 - y1 + 1);

    wgui_clock_set_digital_align_type(wgui_cat033_techno_clock_date, GUI_CLOCK_DIGITAL_ALIGN_RIGHT);   
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_techno_text_change_processor
 * DESCRIPTION
 *  handle network name & network status scroll on the techno bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_techno_text_change_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_techno_scroll_count += 1;

    g_wgui_cat033_techno_text_scroll = MMI_TRUE;     /* scroll text on techno bar */
    g_wgui_cat033_redraw_scrolling_text = MMI_FALSE; /* not redraw scrolling text */
    
    idle_screen_show_network_details();

    g_wgui_cat033_techno_text_scroll = MMI_FALSE;
    g_wgui_cat033_redraw_scrolling_text = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_techno_set_text_and_date
 * DESCRIPTION
 *  Set text and date position and clear background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_techno_set_text_and_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* text process: alternate string */
    if (g_wgui_cat033_techno_text_scroll == MMI_TRUE)
    {
        gui_cancel_timer(wgui_cat033_techno_text_change_processor);
        if (g_wgui_cat033_techno_scroll_count == 4) /* change text */
        {
            g_wgui_cat033_techno_scroll_count = 0;
            if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
            {
                g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;
                
            }
            else if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
            {
                g_wgui_cat033_techno_current_text_type = NETWORK_STATUS_TEXT_ON_IDLE;
            }
            gui_start_timer(WGUI_CAT033_PAUSE_TIMER, wgui_cat033_techno_text_change_processor);
        }
        else
        {
            gui_start_timer(WGUI_CAT033_VSCROLL_TIMER, wgui_cat033_techno_text_change_processor);
        }
    }

    /* clear text region */
    x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
    y1 = MMI_status_bar_height;
    x2 = UI_device_width - MMI_SIGNAL_WIDTH;

    {
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
#else
        S32 max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
#endif /* __MMI_DUAL_SIM_MASTER__ */

        y2 = MMI_status_bar_height + max_region_height - 1;
    }

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#endif /* __GDI_MEMORY_PROFILE_2__ */
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE) /* show technobar image */
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_network_name
 * DESCRIPTION
 *  show network name on techno bar (if has network status, it will vertical scroll)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_techno_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0, max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_name = idle_screen_network_name;
    PU8 dual_sim_img = NULL;
    S32 img_width = 0, img_height = 0;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
#else
    max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
#endif /* __MMI_DUAL_SIM_MASTER__ */

    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);

#if defined( __MMI_DUAL_SIM_MASTER__) && !defined(__MMI_WLAN_FEATURES__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined( __MMI_DUAL_SIM_MASTER__) && !defined(__MMI_WLAN_FEATURES__) */
    
    if (network_name != NULL)
    {
        is_display = MMI_TRUE;
        
        /* set attribute */
        gui_set_font(network_name_font);        
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);
        
        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat033_techno_scroll_count; /* scroll count */
        
        /* calculate clip region */
        if ((S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE) <= max_region_height)
        {
            clip_height = (S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE);
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height + (max_region_height >> 1) - (clip_height >> 1);
            clip_y2 = clip_y1 + clip_height - 1;
        }
        else
        {
            clip_height = max_region_height;
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height;
            clip_y2 = clip_y1 + clip_height - 1;
        }

        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        
        if (idle_screen_network_status != NULL) /* have network status: vertical scroll */
        {
            /* calculate the position of network name string */
            if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
            {
                region_y2 = clip_y2 - count * (clip_height >> 2);
                region_y1 = region_y2 - clip_height + 1;
            }
            else if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
            {
                region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
                region_y2 = region_y1 + clip_height - 1;
            }
            
            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else /* no image */
            {
                wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2, region_y2);
            }
        }
        else /* no network status: static string */
        {
            region_y2 = clip_y2;
            region_y1 = clip_y1;

            if (dual_sim_img != NULL) /* dual sim show sim1 image */
            {
                S32 img_y =  region_y1 + ((region_y2 - region_y1 + 1) >> 1) - (img_height >> 1) - 1;

                if (r2lMMIFlag)
                {
                    wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, region_y1, clip_x2 - img_width, region_y2);
                    gdi_image_draw_blend2layers(clip_x2 - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                }
                else
                {
                    if ((gui_get_string_width(network_name) + 2) >= clip_x2 - clip_x1 + 1 - img_width) /* too long: trancated string */
                    {
                        wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);                        
                        gdi_image_draw_blend2layers(clip_x1 + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                    else
                    {
                        S32 x;

                        x = wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1 + img_width, region_y1, clip_x2, region_y2);
                        gdi_image_draw_blend2layers(x - img_width + MMI_IDLE_NETWORK_NAME_ICON_GAP, img_y, dual_sim_img);
                    }
                }
            }
            else
            {
                wgui_cat033_show_techno_border_string_right_align(network_name, clip_x1, clip_y1, clip_x2, clip_y2);
            }
        }
        gdi_layer_pop_clip();
    }
    return is_display;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_network_status
 * DESCRIPTION
 *  show network status on techno bar (vertical scroll)
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_techno_network_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
    S32 count = 0, region_y1 = 0, region_y2 = 0;
    S32 string_max_h = 0, max_region_height = 0;
    MMI_BOOL is_display = MMI_FALSE;
    UI_string_type network_status = idle_screen_network_status;
    UI_font_type network_name_font, network_status_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
#else
    max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
#endif /* __MMI_DUAL_SIM_MASTER__ */

    /* get font */
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    
	if (idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN && network_status != NULL)
	{
        is_display = MMI_TRUE;

        /* set attribute */
        gui_set_font(network_status_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_status_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_status_border_color);

        string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
        count = g_wgui_cat033_techno_scroll_count; /* scroll count */

        /* calculate clip region */
        if ((S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE) <= max_region_height)
        {
            clip_height = (S32)(string_max_h * WGUI_CAT033_TECHNO_STRING_SPACE);
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;  
            clip_y1 = MMI_status_bar_height + (max_region_height >> 1) - (clip_height >> 1);
            clip_y2 = clip_y1 + clip_height - 1;
        }
        else
        {
            clip_height = max_region_height;
            clip_x1 = DIGITAL_BACKGROUND_X + DIGITAL_BACKGROUND_WIDTH;
            clip_x2 = UI_device_width - MMI_SIGNAL_WIDTH;
            clip_y1 = MMI_status_bar_height;
            clip_y2 = clip_y1 + clip_height - 1;
        }

        /* calculate the position of network status string */
        if (g_wgui_cat033_techno_current_text_type == NETWORK_STATUS_TEXT_ON_IDLE)
        {
            region_y2 = clip_y2 - count * (clip_height >> 2) + 1;
            region_y1 = region_y2 - clip_height + 1;
        }
        else if (g_wgui_cat033_techno_current_text_type == NETWORK_NAME_TEXT_ON_IDLE)
        {
            region_y1 = clip_y2 - count * (clip_height >> 2) + 1;
            region_y2 = region_y1 + clip_height - 1;            
        }

        /* show network status string */
        gdi_layer_push_clip();
        gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
        wgui_cat033_show_techno_border_string_right_align(network_status, clip_x1, region_y1, clip_x2, region_y2);
        gdi_layer_pop_clip();
    }
	return is_display;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techno_date
 * DESCRIPTION
 *  show date on techno bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_techno_date(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // S32 x1 = 0, y1 = 0, x2 = 0, y2 = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        wgui_clock_show_clock(wgui_cat033_techno_clock_date);
    }        
}


#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if !defined(__MMI_WLAN_FEATURES__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_DUAL_SIM_MASTER__ */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_techo_date_and_static_network_name
 * DESCRIPTION
 *  show date and static network name on techno bar
 *  THIS FUNCTION IS ONLY FOR CALL CATEGORY, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_show_techo_date_and_static_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    gdi_layer_lock_frame_buffer();

    /* stop vertical scroll because only network name */
    g_wgui_cat033_techno_text_scroll = MMI_FALSE;
    g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;

    /* date */
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        wgui_cat033_techno_init_date();
    }
    wgui_cat033_techno_set_text_and_date();
    wgui_cat033_show_techno_date();    

    /* SIM 1 */
    wgui_cat033_show_techno_network_name();

    /* SIM 2 */    
#if defined(__MMI_DUAL_SIM_MASTER__)
/* under construction !*/
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */

    gdi_layer_unlock_frame_buffer();        
    gdi_lcd_repaint_all();
}


#else  /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_network_status
 * DESCRIPTION
 *  show network status (the seconde line) in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_network_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    MMI_BOOL is_display = MMI_FALSE;    
#ifndef __OP01_FWPBW__
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)                
    S32 width = 0;
#endif
#endif
    S32 x = 0, y = 0;
    UI_font_type network_name_font, network_status_font;
    
#ifdef __GDI_MEMORY_PROFILE_2__
    GDI_HANDLE wallpaper_layer;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* get font */
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    
#ifdef __GDI_MEMORY_PROFILE_2__
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
#endif

	/* show network status */
	if (idle_screen_type != ANALOG_IDLE_SCREEN && idle_screen_type != DIGITAL_IDLE_SCREEN)
	{
		S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
		S32 max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size);
        
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        S32 min_y = UI_device_height - 1, i = 0;
#endif

        is_display = MMI_TRUE;
        
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        /* find min y of all reminders*/
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
            {
                min_y = min(min_y, g_wgui_cat033_reminder[i].y);
            }
        }
#endif
		gui_set_font(network_status_font);
		gui_set_text_color(*current_MMI_theme->idle_scr_network_status_color);
		gui_set_text_border_color(*current_MMI_theme->idle_scr_network_status_border_color);

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
		if (min_y < UI_device_height - 1) /* have reminders */
		{
			y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER + 
				Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
				MMI_IDLE_DETAILS_VGAP_WITH_REMINDER;
			if ((y + max_str_h - 1) >= min_y)
			{
				is_display = MMI_FALSE;
			}
		}
		else
#endif
		{
			y = MMI_IDLE_NETWORK_STATUS_Y;
		}

    #ifdef __OP01_FWPBW__
        // OP01 FWPBW needs to show SPN on the same line as operator name
        if (idle_screen_network_status != NULL)
        {
            is_display = MMI_TRUE;
            y = MMI_IDLE_NETWORK_NAME_Y;
        }
    #endif
		
		if (is_display == MMI_TRUE)
		{
		    S32 x1 = w_inset;
            S32 x2 = UI_device_width - w_inset;
	#ifdef __OP01_FWPBW__        
            // OP01 FWPBW needs to show SPN on the same line as operator name
            if (idle_screen_network_status != NULL)
            {
                x1 = MMI_IDLE_NETWORK_INFO_MARGIN_GAP + MMI_IDLE_NETWORK_NAME_AREA_WIDTH;
                x2 = UI_device_width - MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
            }
        #endif
			/* clear background */
			gdi_layer_push_clip();
			gdi_layer_set_clip(x1, y, x2, y + max_str_h);
#ifdef __GDI_MEMORY_PROFILE_2__
			gdi_draw_solid_rect(x1, y, x2, y + max_str_h, GDI_COLOR_TRANSPARENT);
#else
			draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */
			
			if (idle_screen_network_status != NULL)
			{
			
#ifdef __GDI_MEMORY_PROFILE_2__
			    /* set alpha blending layer */
			    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
#endif

            #ifndef __OP01_FWPBW__
            #if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)				
                                width = gui_get_string_width(idle_screen_network_status) + 2;
				if (width <= (UI_device_width - (w_inset * 2)))
				{
					x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (width >> 1)) : ((UI_device_width >> 1) - (width >> 1));
					x += (r2lMMIFlag) ? (-1) : (1); /* border text */
					y += 1; /* border text */
					gui_move_text_cursor(x, y);
					gui_print_bordered_text(idle_screen_network_status);
				}
				else
				{
					S32 w;
					
					x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
					x += (r2lMMIFlag) ? (-1) : (1); /* border text */
					y += 1; /* border text */
					w = UI_device_width - (w_inset * 2) - 2/* border text */;
					gui_print_truncated_borderd_text(x, y, w, idle_screen_network_status);
				}
#elif(MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN) /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
				{
					S32 w;
					
					x = (r2lMMIFlag) ? (UI_device_width - w_inset) : (w_inset/2);
					w = UI_device_width - w_inset - w_inset/2 - 2;
					x += (r2lMMIFlag) ? (-1) : (1); /* border text */
					y += 1; /* border text */
					gui_print_truncated_borderd_text(x, y, w, idle_screen_network_status);
				}
#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
				MMI_ASSERT(0);
#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            #else /* __OP01_FWPBW__ */
                if (width <= MMI_IDLE_NETWORK_STATUS_AREA_WIDTH)
                {
                    x = UI_device_width - MMI_IDLE_NETWORK_INFO_MARGIN_GAP - width;
                    gui_move_text_cursor(x, y);
                    gui_print_text(idle_screen_network_status);
                }
                else
                {
                    S32 w = MMI_IDLE_NETWORK_STATUS_AREA_WIDTH;
                    x = UI_device_width - MMI_IDLE_NETWORK_INFO_MARGIN_GAP - MMI_IDLE_NETWORK_STATUS_AREA_WIDTH;
                    gui_print_truncated_text(x, y, w, idle_screen_network_status);
                }
                //wgui_cat033_show_network_name();
            #endif /* __OP01_FWPBW__ */
#ifdef __GDI_MEMORY_PROFILE_2__
                gdi_pop_and_restore_alpha_blending_source_layer();
#endif
			}
			gdi_layer_pop_clip();
		}
	}
    return is_display;
}


#if defined(__MMI_DUAL_SIM_MASTER__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if !defined(__MMI_MAINLCD_96X64__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #if !defined(__MMI_BT_DIALER_SUPPORT__)
/* under construction !*/
        #else
/* under construction !*/
        #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#else
/* under construction !*/
#endif /* __GDI_MEMORY_PROFILE_2__ */
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __MMI_MAINLCD_96X64__
/* under construction !*/
    #ifdef __MMI_BIDI_ALG__
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_BIDI_ALG__ */ 
    #ifndef __MMI_ENHANCED_UI_LAYOUT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #else
/* under construction !*/
    #endif
    #ifdef __MMI_BIDI_ALG__
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifndef __MMI_ENHANCED_UI_LAYOUT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #else
/* under construction !*/
    #endif
/* under construction !*/
    #endif /* __MMI_BIDI_ALG__ */
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#elif(MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN) /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
/* under construction !*/
#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
#if !defined(__MMI_MAINLCD_96X64__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#else
/* under construction !*/
#endif /* __GDI_MEMORY_PROFILE_2__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
/* under construction !*/
#endif
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#elif (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
/* under construction !*/
#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
/* under construction !*/
#ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */
#endif  /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)

#if defined(__MMI_MAINLCD_96X64__) || defined(__MMI_BT_DIALER_SUPPORT__)

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_handle_extra_text_scroll
 * DESCRIPTION
 *  handle scrolling text of extra text of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_handle_network_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&g_network_names_scroll);
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw_extra_text_background
 * DESCRIPTION
 *  redraw the background of scrolling text area
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_redraw_network_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    gui_pop_clip();
}

#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_network_name
 * DESCRIPTION
 *  show network name (the first line) on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_network_name(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_display = MMI_FALSE;
    UI_font_type network_name_font;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);    
    
    if (idle_screen_network_name != NULL)
    {
    

#ifndef __OP01_FWPBW__
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
        S32 width = 0; 
#endif
#endif
        S32 x = 0, y = 0, img_width = 0;
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        S32 min_y = UI_device_height - 1, i = 0;
#endif
#if defined(__MMI_DUAL_SIM_MASTER__)&&!defined(__MMI_MAINLCD_96X64__)
/* under construction !*/
/* under construction !*/
#endif
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        S32 max_str_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);

        is_display = MMI_TRUE;

#if defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__) 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__)  */

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        /* find min y of all reminders*/
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
            {
                min_y = min(min_y, g_wgui_cat033_reminder[i].y);
            }
        }
#endif
        /* set attribute */
        gui_set_font(network_name_font);
        gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);

        if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
        {
            y = MMI_IDLE_NETWORK_NAME_Y_WITH_CLOCK_BG;
        }
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        else if (min_y < UI_device_height - 1) /* have reminders */
        {
            y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER;
            if ((y + max_str_h - 1) >= min_y)
            {
                is_display = MMI_FALSE;
            }
        }
#endif
        else
        {
            y = MMI_IDLE_NETWORK_NAME_Y;
        }
		
        if (is_display == MMI_TRUE)
        {
            gdi_layer_push_clip();
        
            /* get string information */
            
#ifndef __OP01_FWPBW__
#if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
            width = gui_get_string_width(idle_screen_network_name) + 2 /* border */;
#endif
#endif
        #if defined (__OP01_FWPBW__) || defined (__MMI_MAINLCD_96X64__)
            w_inset = MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
        #endif
        
            /* clear background */            
            gdi_layer_set_clip(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1);
#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
            gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1, GDI_COLOR_BLACK);
#else
            gdi_draw_solid_rect(0, y - 1, UI_device_width - w_inset - 1, y + max_str_h - 1, GDI_COLOR_TRANSPARENT);
#endif
#else
            draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */
			

        #ifndef __OP01_FWPBW__
        #if (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN)
            if (width <= (UI_device_width - (w_inset * 2) - img_width))
            {
                x = (r2lMMIFlag) ? ((UI_device_width >> 1) + ((width + img_width) >> 1)) : ((UI_device_width >> 1) - ((width + img_width) >> 1));
                x = (r2lMMIFlag) ? (x - img_width) : (x + img_width);
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
              //  y += 1; /* border text */
                gui_move_text_cursor(x, y + 1);
                gui_print_bordered_text(idle_screen_network_name);
            }
            else
            {
                S32 w = 0;
#ifdef __MMI_MAINLCD_96X64__
    
    #ifdef __MMI_BIDI_ALG__
        if (!r2lMMIFlag)
        {
    #endif /* __MMI_BIDI_ALG__ */ 
    #ifndef __MMI_ENHANCED_UI_LAYOUT__

            if (width < UI_device_width - (2 * w_inset))
            {
                x = UI_device_width/2 - width/2;
				if(x<w_inset)
					x = w_inset;
            }
            else
            {
                x = w_inset;
            }
    #else
         x = w_inset;
    #endif
    #ifdef __MMI_BIDI_ALG__
        }
        else
        {
    #ifndef __MMI_ENHANCED_UI_LAYOUT__
	        if (width < UI_device_width - (2 * w_inset))
            {
                x = UI_device_width/2 + width/2;
            }
            else
            {
	            x = UI_device_width - (2 * w_inset);
            }
    #else
            x = UI_device_width - (2 * w_inset);
    #endif
        }
    #endif /* __MMI_BIDI_ALG__ */
                w = UI_device_width - (w_inset * 2) - 2;
#else
                x = (r2lMMIFlag) ? (UI_device_width - w_inset - 1) : (w_inset + 1);
                w = UI_device_width - (w_inset * 2) - 2;
#endif
                x += (r2lMMIFlag) ? (-1) : (1); /* border text */
                x = (r2lMMIFlag) ? (x - img_width) : (x + img_width);
          //      y += 1; /* border text */
                gui_print_truncated_borderd_text(x, y + 1, w, idle_screen_network_name);
            }
#elif(MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_LEFT_ALIGN) /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            {
                S32 w = 0;
				
#if !defined(__MMI_MAINLCD_96X64__) && !defined(__MMI_BT_DIALER_SUPPORT__)
                x = (r2lMMIFlag) ? (UI_device_width - img_width - w_inset - w_inset/2) : (w_inset/2 + img_width);
                w = UI_device_width - w_inset - w_inset/2 - img_width - 2;
                gui_print_truncated_borderd_text(x + 1, y + 1, w, idle_screen_network_name);
#else
                x = (r2lMMIFlag) ? (UI_device_width - img_width - w_inset) : (w_inset + img_width);
                w = UI_device_width - 2*w_inset - img_width;                
                gui_create_scrolling_text(
                    &g_network_names_scroll,
                    x, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
                    y + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
                    w, /* scrolling text reserve 4 pixels in x-coordinate */
                    max_str_h - 2, /* scrolling text reserve 2 pixels in y-coordinate */
                    idle_screen_network_name,
                    wgui_cat033_handle_network_text_scroll,
                    wgui_cat033_redraw_network_text_background,
                    *current_MMI_theme->idle_scr_network_name_color,
                    *current_MMI_theme->idle_scr_network_name_border_color);
                g_network_names_scroll.scroll_gap = 20;
                g_network_names_scroll.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
                gui_show_scrolling_text(&g_network_names_scroll);

#endif
            }
#else /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
            MMI_ASSERT(0);
#endif /* (MMI_IDLE_TEXT_ALIGN_TYPE == IDLE_TEXT_CENTER_ALIGN) */
        #else /* __OP01_FWPBW__ */
            if (idle_screen_network_status != NULL)
            {
                S32 w = MMI_IDLE_NETWORK_NAME_AREA_WIDTH;
                x = MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
                // Left allign because SPN needs to be shown on the right half side
                gui_print_truncated_text(x, y, w, idle_screen_network_name);
            }
            else
            {
                // Center allign
                S32 w = UI_device_width - (MMI_IDLE_NETWORK_INFO_MARGIN_GAP << 1);
                if (width <= w)
                {
                    x = (UI_device_width - width) >> 1;
                    gui_move_text_cursor(x, y);
                    gui_print_text(idle_screen_network_name);
                }
                else
                {
                    x = MMI_IDLE_NETWORK_INFO_MARGIN_GAP;
                    gui_print_truncated_text(x, y, w, idle_screen_network_name);
                }
            }
        #endif /* __OP01_FWPBW__ */			

#if defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
#endif /* defined(__MMI_DUAL_SIM_MASTER__) &&!defined(__MMI_MAINLCD_96X64__) */

            gdi_layer_pop_clip();
        }
    }
    return is_display;
}

#endif


#ifdef __MMI_BT_DIALER_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_handle_BT_dialer_text_scroll
 * DESCRIPTION
 *  handle scrolling text of extra text of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_handle_BT_dialer_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    scrolling_text s = g_bt_dialer_pairing_names_scroll;
    U32 dev_num = GetIdleScreenPairingDeviceNum();
    MMI_BOOL is_scroll_done = MMI_FALSE;
    
    if (mmi_fe_get_r2l_state())
    {
        s.scroll_x += s.scroll_size;
        if (s.force_scroll && (s.width > s.text_width))
        {
            if (s.scroll_x >= (s.width + s.scroll_gap))
            {
                is_scroll_done = MMI_TRUE;
            }
        }
        else
        {
            if (s.scroll_x >= (s.text_width + s.scroll_gap))
            {
                is_scroll_done = MMI_TRUE;
            }
        }
    }
    else
    {
        s.scroll_x -= s.scroll_size;
        if (s.force_scroll && (s.width > s.text_width + s.scroll_gap))
        {
            if (s.scroll_x <= -s.width)
            {
                is_scroll_done = MMI_TRUE;
            }
        }
        else
        {   
            if (s.scroll_x <= (-(s.text_width + s.scroll_gap)))
            {
                is_scroll_done = MMI_TRUE;
            }
        }
    }

    if (is_scroll_done && dev_num > 1)
    {
        g_scroll_count++;
        wgui_cat033_show_BT_dialer_info();
    }
    else
    {
        gui_handle_scrolling_text(&g_bt_dialer_pairing_names_scroll);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw_BT_dialer_text_background
 * DESCRIPTION
 *  redraw the background of scrolling text area
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_redraw_BT_dialer_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenBTDialerPairingName
 * DESCRIPTION
 *  Sets the BT dialer pairing name to be displayed by the idle screen
 * PARAMETERS
 *  s      : [IN] (C033_1)     BT dialer pairing name string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenBTDialerPairingName(const WCHAR *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                  */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //idle_screen_BT_dialer_paring_name = (UI_string_type) s;
    mmi_wcscpy(g_idle_scr_bt_pairing_name, s);
}


/*****************************************************************************
 * FUNCTION
 *  AddIdleScreenBTDeviceInfo
 * DESCRIPTION
 *  Add the bt device info into array
 * PARAMETERS
 *  dev_info      : [IN] BT device info
 * RETURNS
 *  void
 *****************************************************************************/
void AddIdleScreenBTDeviceInfo(srv_bt_cm_dev_struct *dev_info)
{
    U32 i;
    S32 j = -1;
    for (i = 0; i < BT_PROFILES_LINK_NUM; i++)
    {
        //first - fit
        if (g_idle_scr_bt_dev_info[i] == NULL && j == -1)
        {
            j = i;
            break;
        }
        
        if (g_idle_scr_bt_dev_info[i] == dev_info)
        {
            //already exist, no need to add.
            return;
        }
    }  

	if (-1 == j)
	{
		return;
	}
    g_idle_scr_bt_dev_info[j] = dev_info;
}


/*****************************************************************************
 * FUNCTION
 *  DelIdleScreenBTDeviceInfo
 * DESCRIPTION
 *  Delete the bt device from array
 * PARAMETERS
 *  dev_info      : [IN] BT device info
 * RETURNS
 *  void
 *****************************************************************************/
void DelIdleScreenBTDeviceInfo(srv_bt_cm_dev_struct *dev_info)
{
    U32 i, j;
    for (i = 0; i < BT_PROFILES_LINK_NUM; i++)
    {
        if (dev_info == g_idle_scr_bt_dev_info[i])
        {
            for (j = i; j < BT_PROFILES_LINK_NUM - 1; j++)
            {
                //shift array
                g_idle_scr_bt_dev_info[j] = g_idle_scr_bt_dev_info[j + 1];
            }
            g_idle_scr_bt_dev_info[BT_PROFILES_LINK_NUM - 1] = NULL;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  ClearIdleScreenBTDeviceInfo
 * DESCRIPTION
 *  Delete all bt device in array
 * PARAMETERS
 *  dev_info      : [IN] BT device info
 * RETURNS
 *  void
 *****************************************************************************/
void ClearIdleScreenBTDeviceInfo(void)
{
    memset(g_idle_scr_bt_dev_info, 0, BT_PROFILES_LINK_NUM * sizeof(srv_bt_cm_dev_struct*));
}

/*****************************************************************************
 * FUNCTION
 *  GetIdleScreenPairingDeviceNum
 * DESCRIPTION
 *  Get the device number
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U32 GetIdleScreenPairingDeviceNum(void)
{
    U32 count = 0;
    U32 i;
    for (i = 0; i < BT_PROFILES_LINK_NUM; i++)
    {
        if (g_idle_scr_bt_dev_info[i] != NULL)
        {
            count++;
        }
    }
    MMI_ASSERT(count <= BT_PROFILES_LINK_NUM);
    return  count;
}


/*****************************************************************************
 * FUNCTION
 *  CheckIsIdleScreenBTDeviceInfoEmpty
 * DESCRIPTION
 *  Check if there is no bt device info or not
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL CheckIsIdleScreenBTDeviceInfoEmpty(void)
{
    U32 i;
    for (i = 0 ; i < BT_PROFILES_LINK_NUM; i++)
    {
        if (g_idle_scr_bt_dev_info[i] != NULL)
        {
            return MMI_FALSE;
        }
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  CheckIsIdleScreenBTDeviceInfoFull
 * DESCRIPTION
 *  Check if the bt device info is fulfill with array or not
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL CheckIsIdleScreenBTDeviceInfoFull(void)
{
    U32 i;
    for (i = 0; i < BT_PROFILES_LINK_NUM; i++)
    {
        if (g_idle_scr_bt_dev_info[i] == NULL)
        {
            return MMI_FALSE;
        }
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenBTDialerConnectStatus
 * DESCRIPTION
 *  Sets the BT dialer connection status to be displayed by the idle screen
 * PARAMETERS
 *  s      : [IN] (C033_2)     status string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenBTDialerConnectionStatus(MMI_BOOL status)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/
	g_idle_scr_bt_dialer_connected = status;
}


/*****************************************************************************
 * FUNCTION
 *  GetIdleScreenBTDialerConnectionStatus
 * DESCRIPTION
 *  Get the BT dialer connection status
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL GetIdleScreenBTDialerConnectionStatus()
{
    return g_idle_scr_bt_dialer_connected;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_BT_dialer_info
 * DESCRIPTION
 *  Show Bt dailer connect information
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_show_BT_dialer_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    UI_font_type pairing_name_font;
    UI_string_type pairing_name = NULL;
    S32 x = 0, max_width = 0, real_width = 0;
    S32 y = 0;
    S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
    S32 max_str_h = 0;
    U32 i;
    S32 cx1, cy1, cx2, cy2;
    srv_bt_cm_dev_struct *dev_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    pairing_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    max_str_h = Get_CharDisplayHeightOfAllLangAndType(pairing_name_font->size);
#ifdef __MMI_BT_BOX_IDLE_SHORTCUTS__ //lu
	y = max_str_h + MMI_IDLE_STATUS_BT_NAME_GAP;
#else
    if (idle_screen_network_name != NULL)
    {
         y = MMI_IDLE_NETWORK_NAME_Y + max_str_h + MMI_IDLE_STATUS_BT_NAME_GAP;
    }
    else
    {
          y = MMI_IDLE_NETWORK_NAME_Y; // only display bt dev name without network name.
    }
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
#endif
#endif /* __MMI_BT_BOX_IDLE_SHORTCUTS__ */

    gdi_layer_push_clip();
    
    gui_set_font(pairing_name_font);
    gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
    gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);

    gui_scrolling_text_stop(&g_bt_dialer_pairing_names_scroll);

    gdi_layer_set_clip(
        0, 
        y - 1, 
        UI_device_width - w_inset + 1, 
    #if (BT_PROFILES_LINK_NUM == 2)
        y + 2 * max_str_h - 1);
    #else
        y + max_str_h - 1);
    #endif
    
    gdi_draw_solid_rect(
        0, 
        y - 1, 
        UI_device_width - w_inset + 1, 
    #if (BT_PROFILES_LINK_NUM == 2)
        y + 2 * max_str_h - 1, 
    #else
        y + max_str_h - 1, 
    #endif
        GDI_COLOR_TRANSPARENT);

	gdi_layer_get_clip(&cx1, &cy1, &cx2, &cy2);
#if (BT_PROFILES_LINK_NUM > 1)

    if (g_idle_scr_bt_dialer_connected)
    {
        x = (r2lMMIFlag) ? (UI_device_width - w_inset) : (w_inset);
        max_width = UI_device_width - 2*w_inset;  
        
        for (i = 0; i < BT_PROFILES_LINK_NUM; i++)
        {
            if (g_idle_scr_bt_dev_info[i] != NULL)
            {
                dev_p = g_idle_scr_bt_dev_info[i];
                mmi_chset_utf8_to_ucs2_string(
                    (kal_uint8*)g_pairing_name_output_buf[i],
                    (SRV_BT_CM_BD_UCS2_NAME_LEN * 2),
                    (kal_uint8*)dev_p->name);

                mmi_wcscat(g_pairing_name_output_buf[i], (const WCHAR*)GetString(STR_BT_CONN_POP));
            }
            else
            {
                continue;
            }

            real_width = gui_get_string_width(g_pairing_name_output_buf[i]);
            if (real_width > max_width)
            {
                if (g_scroll_count % BT_PROFILES_LINK_NUM == i)
                {
                    //scrolling text
                    gui_create_scrolling_text(
                        &g_bt_dialer_pairing_names_scroll,
                        x, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
                        y + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
                        max_width - 1, /* scrolling text reserve 4 pixels in x-coordinate */
                        max_str_h - 2, /* scrolling text reserve 2 pixels in y-coordinate */
                        g_pairing_name_output_buf[i],
                        wgui_cat033_handle_BT_dialer_text_scroll,
                        wgui_cat033_redraw_BT_dialer_text_background,
                        *current_MMI_theme->idle_scr_network_name_color,
                        *current_MMI_theme->idle_scr_network_name_border_color);
                    g_bt_dialer_pairing_names_scroll.scroll_gap = 20;
                    g_bt_dialer_pairing_names_scroll.scroll_counter = 0;
                    g_bt_dialer_pairing_names_scroll.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;

                    gui_show_scrolling_text(&g_bt_dialer_pairing_names_scroll);
                }
                else
                {
                    gui_print_truncated_borderd_text(x, y + 1, max_width - 1, g_pairing_name_output_buf[i]);
                }
            }
            else
            {
                //align center
                x = (UI_device_width - real_width)/2;
                gui_move_text_cursor(x, y + 1);
                gui_print_bordered_text(g_pairing_name_output_buf[i]);
            }
            y += max_str_h;
        }
    }

    gdi_layer_pop_clip();
    gui_BLT_double_buffer(cx1,cy1, cx2, cy2);
    
#else //before v3.0, only 1 bt link
    if (g_idle_scr_bt_dialer_connected && g_idle_scr_bt_dev_info[0] != NULL)
    {
        mmi_chset_utf8_to_ucs2_string(
                    (kal_uint8*)g_pairing_name_output_buf[0],
                    (SRV_BT_CM_BD_UCS2_NAME_LEN * 2),
                    (kal_uint8*)g_idle_scr_bt_dev_info[0]->name);
        mmi_wcscat(g_pairing_name_output_buf[0], (const WCHAR*)GetString(STR_BT_CONN_POP));
    }
    else
    {
        gdi_layer_pop_clip();
        return;
    }

    x = (r2lMMIFlag) ? (UI_device_width - w_inset) : (w_inset);
    max_width = UI_device_width - 2*w_inset;  

    real_width = gui_get_string_width(g_pairing_name_output_buf[0]);
    if (real_width > max_width)  //scrolling
    {
        gui_create_scrolling_text(
            &g_bt_dialer_pairing_names_scroll,
            x, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
            y + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
            max_width - 1, /* scrolling text reserve 4 pixels in x-coordinate */
            max_str_h - 2, /* scrolling text reserve 2 pixels in y-coordinate */
            g_pairing_name_output_buf[0],
            wgui_cat033_handle_BT_dialer_text_scroll,
            wgui_cat033_redraw_BT_dialer_text_background,
            *current_MMI_theme->idle_scr_network_name_color,
            *current_MMI_theme->idle_scr_network_name_border_color);
        g_bt_dialer_pairing_names_scroll.scroll_gap = 20;
        g_bt_dialer_pairing_names_scroll.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;

        gui_show_scrolling_text(&g_bt_dialer_pairing_names_scroll);
    }
    else  //static
    {
        //align center
        x = (UI_device_width - real_width)/2;
        gui_move_text_cursor(x, y + 1);
        gui_print_bordered_text(g_pairing_name_output_buf[0]);
    }

    gdi_layer_pop_clip();
#endif
}

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_dialer_disconnect_direct
 * DESCRIPTION
 *  Disconnect the paired device directly while only one device paired.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_dialer_disconnect_direct(void)
{
    MMI_BOOL ret;
    srv_bt_cm_dev_struct *dev_p = NULL;

    //close confirm screen by itself.
    mmi_frm_scrn_close_active_id();
    
    dev_p = g_idle_scr_bt_dev_info[0];
    if (dev_p)
    {
        ret = mmi_bt_dialer_disconnect_by_dev_info(dev_p);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_dialer_candidate_lsk_hdlr
 * DESCRIPTION
 *  Disconnect candidate screen lsk handler, we will disconnect the device user selected.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_dialer_candidate_lsk_hdlr(void)
{
    MMI_BOOL ret;
    srv_bt_cm_dev_struct *dev_p = NULL;
    dev_p = g_idle_scr_bt_dev_info[g_disconn_sel_idx];
        
    ret = mmi_bt_dialer_disconnect_by_dev_info(dev_p);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_dialer_candidate_list_hilite_handler
 * DESCRIPTION
 *  Disconnect candidate screen highlight handler, will change the selected index.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_dialer_candidate_list_hilite_handler(S32 idx)
{
    g_disconn_sel_idx = idx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_dialer_show_candidate_list_scr
 * DESCRIPTION
 *  Show disconnect candidate screen.
 * PARAMETERS
 *  param    : [IN] mmi_frm_scrn_first_enter param
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_dialer_show_candidate_list_scr(mmi_scrn_essential_struct *param)
{
    WCHAR *item_list[BT_PROFILES_LINK_NUM];
    U32 dev_num = GetIdleScreenPairingDeviceNum();
    U32 i;
    void *gui_buffer;
    
    if (mmi_frm_scrn_enter(
            param->group_id, 
            param->scrn_id, 
            (FuncPtr)NULL, 
            (FuncPtr)mmi_bt_dialer_show_candidate_list_scr, 
            NULL) == MMI_FALSE)
    {
        return;
    }

    for (i = 0; i < dev_num; i++)
    {
        mmi_chset_utf8_to_ucs2_string(
            (kal_uint8*)g_pairing_name_output_buf[i],
            SRV_BT_CM_BD_FNAME_LEN,
            (U8*)(g_idle_scr_bt_dev_info[i]->name));
        item_list[i] = (WCHAR*)(g_pairing_name_output_buf[i]);
    }
    
    gui_buffer = mmi_frm_scrn_get_active_gui_buf();        /* get current guibuffer */
    RegisterHighlightHandler(mmi_bt_dialer_candidate_list_hilite_handler);
    if (GetIdleScreenPairingDeviceNum() > 1)
    {
        ShowCategory6Screen_ext(
            GetString(STR_ID_IDLE_BTDIALER_CONNECTED_DEVICE),
            NULL,
            (U8*)get_string(STR_GLOBAL_OK),
            get_image(IMG_GLOBAL_OK),
            (U8*)get_string(STR_GLOBAL_BACK),
            get_image(IMG_GLOBAL_BACK),
            dev_num,
            (U8**)item_list,
            0,
            0,
            gui_buffer);
            
        SetLeftSoftkeyFunction(mmi_bt_dialer_candidate_lsk_hdlr, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_bt_dialer_candidate_lsk_hdlr, KEY_EVENT_UP);
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    }
    else
    {
        ShowCategory163Screen(
                (UI_string_type) GetString(STR_GLOBAL_YES),
                (PU8)GetImage(IMG_GLOBAL_YES),
                (UI_string_type) GetString(STR_GLOBAL_NO),
                (PU8)GetImage(IMG_GLOBAL_NO),
                (UI_string_type) GetString(STR_BT_DISCONN_PROMPT),
                mmi_get_event_based_image(MMI_EVENT_PROGRESS),
                NULL);
        SetLeftSoftkeyFunction(mmi_bt_dialer_disconnect_direct, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_bt_dialer_disconnect_direct, KEY_EVENT_UP);
        SetRightSoftkeyFunction(GoBackHistory, KEY_EVENT_UP);
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_dialer_enter_disconnect_candidate_list
 * DESCRIPTION
 *  Entry disconnect candidate screen.
 * PARAMETERS
 *  group_id    : [IN] idle app group id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_dialer_enter_disconnect_candidate_list(mmi_id group_id)
{
    mmi_frm_scrn_first_enter(group_id, SCR_BT_DIALER_DISCONNECT_ASK, mmi_bt_dialer_show_candidate_list_scr, NULL);
}
#endif /*__MMI_BT_DIALER_SUPPORT__*/


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_handle_extra_text_scroll
 * DESCRIPTION
 *  handle scrolling text of extra text of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_handle_extra_text_scroll(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&extra_scrolling_text);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw_extra_text_background
 * DESCRIPTION
 *  redraw the background of scrolling text area
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y poistion
 *  x2      [IN]        End x position
 *  y2      [IN]        End y postion
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_redraw_extra_text_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    gui_pop_clip();
}

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_reset_reminder_state
 * DESCRIPTION
 *  reset reminder state
 *  THIS FUNCTION IS ONLY FOR IDLE APP, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_reset_reminder_state(void)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        memset(&g_wgui_cat033_reminder[i], 0, sizeof(wgui_cat033_reminder_area_info));
    }
}
#endif

#ifndef __MMI_PHNSET_SLIM__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_number_of_informaiont_line
 * DESCRIPTION
 *  Caculate if show network status for phone setup (the second line in idlescreen)
 *  THIS FUNCTION IS ONLY FOR IDLE APP, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
S32 wgui_cat033_get_number_of_informaiont_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    S32 y_end = 0;
    
    #if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        S32 min_y = UI_device_height - 1, i = 0;
    #endif
    #endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    S32 number_of_line = 0;
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    UI_font_type network_name_font, network_status_font;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
#endif

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    /* if there have techno bar, 3 information lines will be displayed in idle screen */
    number_of_line = 3;
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    /* find min y of all reminders */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].init != NULL)
        {
            min_y = min(min_y, g_wgui_cat033_reminder[i].y);
        }
    }
#endif
    if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
    {
        number_of_line = 1; /* only network name */
    }
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    else if (min_y < UI_device_height - 1)
    {
        y_end = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER + 
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) - 1;

        if (y_end >= min_y) /* no network name */
        {
            number_of_line = 0;
        }
        else  /* have network name */
        {
            y_end += MMI_IDLE_DETAILS_VGAP_WITH_REMINDER + 
                     Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 
                     MMI_IDLE_DETAILS_VGAP_WITH_REMINDER - 1;
            if (y_end >= min_y) 
            {
                number_of_line = 1;
            }
            else /* have network status */
            {
                y_end += MMI_IDLE_DETAILS_VGAP_WITH_REMINDER + 
                         Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 
                         MMI_IDLE_DETAILS_VGAP_WITH_REMINDER - 1;
                if (y_end >= min_y)
                {
                    number_of_line = 2;
                }
                else /* have extra information */
                {
                    number_of_line = 3;
                }
            }
        }
    }
#endif
    else /* normal state: have network name, network status, extra information */
    {
        number_of_line = 3;
    }
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

    return number_of_line;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_extra_text
 * DESCRIPTION
 *  get idle screen extra text
 *  1. CB display
 *  2. audio player
 *  3. FM radio
 *  4. SAT
 * PARAMETERS
 *  void
 * RETURNS
 *  UI_string_type  [OUT]   extra text
 *****************************************************************************/
UI_string_type wgui_cat033_get_extra_text(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CBS_SUPPORT__
#ifdef __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__
    extern U8* mmi_cbs_get_idle_content(void);
#endif /* __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__ */
#endif
#ifdef __MMI_AUDIO_PLAYER__
    extern audply_struct g_audply;
    extern BOOL mmi_audply_is_playing(void);
#endif /* __MMI_AUDIO_PLAYER__ */

#ifdef __MMI_MEDIA_PLAYER__
    extern MMI_BOOL mmi_medply_if_show_idle_string(void);
    extern UI_string_type mmi_medply_get_idle_string(void);
#endif

#ifdef __MMI_FM_RADIO__
    extern BOOL mmi_fmrdo_is_power_on(void);
#ifdef __MMI_FM_RADIO_RDS__
    extern BOOL mmi_fmrdo_rds_is_power_on(void);
    extern UI_string_type mmi_fmrdo_rds_get_rds_text(void);
#endif/*__MMI_FM_RADIO_RDS__*/
    extern UI_string_type mmi_fmrdo_get_channel_name_or_freq(void);
#endif /* __MMI_FM_RADIO__ */
#ifdef __A8BOX_SUPPORT__
    extern BOOL mmi_a8box_is_playing(void);
    extern UI_string_type mmi_a8box_get_song_name(void);
#endif

#if defined(__MMI_WLAN_FEATURES__) && defined(__MMI_TELEPHONY_SUPPORT__)
    extern const U8 *mmi_netset_get_wlan_provider_name(void);
#endif

    UI_string_type extra_text = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CBS_SUPPORT__
#ifdef __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__
    extra_text = (UI_string_type) mmi_cbs_get_idle_content();
    if (extra_text != NULL)
    {
        return extra_text;
    }
#endif /* __MMI_MESSAGES_CB_DISPLAY_IN_IDLE__ */
#endif

#if defined(__MMI_AUDIO_PLAYER__) && !defined(__MMI_VUI_HOMESCREEN_AUDIO_PLAYER__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
    if (mmi_audply_is_playing())
    {
        return (UI_string_type) g_audply.title;
    }
#endif /* __MMI_AUDIO_PLAYER__ */

#if defined(__MMI_MEDIA_PLAYER__) && !defined(__MMI_VUI_HOMESCREEN_AUDIO_PLAYER__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
    if (mmi_medply_if_show_idle_string())
    {
        return mmi_medply_get_idle_string();
    }
#endif

#if defined(__MMI_FM_RADIO__) && !defined(__MMI_VUI_HOMESCREEN_FM_RADIO__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__)
    if (mmi_fmrdo_is_power_on())
    {
    #ifdef __MMI_FM_RADIO_RDS__
    #if !defined __COSMOS_MMI__
        if(mmi_fmrdo_rds_is_on())
        {
            return (UI_string_type) mmi_fmrdo_rds_get_rds_text();
        }
        else
    #endif
    #endif/*__MMI_FM_RADIO_RDS__*/
        {
        #if !defined __COSMOS_MMI__
            return (UI_string_type) mmi_fmrdo_get_channel_name_or_freq();
        #endif
        }
    }
#endif /* __MMI_FM_RADIO__ */

#ifdef __A8BOX_SUPPORT__
    if(mmi_a8box_is_playing())
    {
        return mmi_a8box_get_song_name();
    }
#endif

#ifdef __SAT__

#if defined(__MMI_TELEPHONY_SUPPORT__)
    extra_text = (UI_string_type) GetSATIdleText();
#endif

    if (extra_text != NULL)
    {
        return extra_text;
    }
#endif /* __SAT__ */

#if defined(__MMI_WLAN_FEATURES__) && !defined(__MMI_VUI_SHELL_OP01_HOMESCREEN__) && defined(__MMI_TELEPHONY_SUPPORT__)
		extra_text = (UI_string_type)mmi_netset_get_wlan_provider_name();
		if (extra_text && mmi_ucs2strlen((const CHAR *)extra_text) > 0)
		{
			return extra_text;
		}
#endif /* defined(__MMI_WLAN_FEATURES__) */


    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_bracket
 * DESCRIPTION
 *  show bracket of extra information line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_bracket(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bracket_width = 0, bracket_height = 0, x = 0, y = 0, start_y = 0, region_height = 0;
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    S32 min_y = UI_device_height - 1, i = 0;
#endif
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    UI_font_type network_name_font;
#endif
    UI_font_type network_status_font;
#ifdef __GDI_MEMORY_PROFILE_2__
    GDI_HANDLE wallpaper_layer;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* get font */   
#if !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#endif
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
    
    region_height = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 2;
    
#ifdef __GDI_MEMORY_PROFILE_2__
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
#endif

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    /* find min y of all reminders */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
        {
            min_y = min(min_y, g_wgui_cat033_reminder[i].y);
        }
    }
#endif

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    #ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    if (MMI_TRUE)
    {
        start_y = UI_device_height - wgui_cat033_get_shortcut_max_height()- region_height - 1;
    }
    else
    #elif defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__)
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
    {
		start_y = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y - region_height;
    }
    else
    #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
        start_y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - region_height - 1; 
    }
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    if (min_y < UI_device_height - 1)
    {
        start_y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER +
            Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
            MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
            Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
            MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        #ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
                ;
    }
    else
#endif
    {
    #if defined(__MMI_BT_DIALER_SUPPORT__)
	#ifdef __MMI_BT_BOX_IDLE_SHORTCUTS__ 
		start_y = 2 * (region_height - 2 + MMI_IDLE_STATUS_BT_NAME_GAP);
	#else
    #ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
    #else
        start_y = MMI_IDLE_NETWORK_NAME_Y + 2 * (region_height - 2 + MMI_IDLE_STATUS_BT_NAME_GAP);  
    #endif
	#endif /* __MMI_BT_BOX_IDLE_SHORTCUTS__ */
    #else
        start_y = MMI_IDLE_EXTRA_Y;
    #endif

    }
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

    /* set attribute */
    gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
    gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);
    gui_set_font(network_status_font);

#ifdef __GDI_MEMORY_PROFILE_2__
    /* set alpha blending layer */
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
#endif

    /* print "[" */
    gui_measure_character((UI_character_type)'[', &bracket_width, &bracket_height);
    bracket_width += 2;  /* border text */
    bracket_height += 2; /* border text */
    x = (r2lMMIFlag) ? (MMI_IDLE_STRING_MARGIN_GAP + bracket_width - 1) : (MMI_IDLE_STRING_MARGIN_GAP);
    x += (r2lMMIFlag) ? (-1) : (1); /* border text */
    y = start_y + ((region_height - bracket_height) >> 1);   /* central y in refresh region */
    y += 1; /* border text */
    gui_move_text_cursor(x, y);
    gui_print_bordered_text(L"[");
            
    /* print "]" */
    gui_measure_character((UI_character_type)']', &bracket_width, &bracket_height);
    bracket_width += 2;  /* border text */
    bracket_height += 2; /* border text */
    x = (r2lMMIFlag) ? (UI_device_width - MMI_IDLE_STRING_MARGIN_GAP - 1) : (UI_device_width - MMI_IDLE_STRING_MARGIN_GAP - 1 - bracket_width + 1);
    x += (r2lMMIFlag) ? (-1) : (1); /* border text */
    y = start_y + ((region_height - bracket_height) >> 1);
    y += 1; /* border text */
    gui_move_text_cursor(x, y);
    gui_print_bordered_text(L"]");

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif

}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_extra_information
 * DESCRIPTION
 *  show extra information (the third line) in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_extra_information(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL show_extra = MMI_FALSE;
    UI_string_type extra_text = NULL;
    S32 width = 0, height = 0, x = 0, y = 0;    
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    S32 min_y = UI_device_height - 1, i = 0;
#endif

#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    UI_font_type network_name_font;
#endif
    UI_font_type network_status_font;

#ifdef __GDI_MEMORY_PROFILE_2__
    GDI_HANDLE wallpaper_layer;
#endif
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#endif
    network_status_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_STATUS);
#ifdef __GDI_MEMORY_PROFILE_2__
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
#endif
    if (extra_scrolling_text_ptr != NULL) /* previous time has scrolling text */
    {
        UI_string_type text = wgui_cat033_get_extra_text();

        if (g_wgui_cat033_redraw_scrolling_text == MMI_FALSE 
            && (extra_scrolling_text_ptr->flags & UI_SCROLLING_TEXT_ENABLE_SCROLL)
            && text != NULL)
        {
            /* animation callback and have extra string -> redraw scrolling text */
            wgui_cat033_show_bracket();
            
#ifdef __GDI_MEMORY_PROFILE_2__
            gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
#endif
            gui_redraw_scrolling_text(extra_scrolling_text_ptr);
#ifdef __GDI_MEMORY_PROFILE_2__
            gdi_pop_and_restore_alpha_blending_source_layer();
#endif
            return MMI_TRUE;
        }
        else
        {
            /* refresh to new string: stop previous text scrolling */
            gui_scrolling_text_stop(extra_scrolling_text_ptr);
            extra_scrolling_text_ptr = NULL;
        }        
    }
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)    
    /* find min y of all reminders */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
        {
            min_y = min(min_y, g_wgui_cat033_reminder[i].y);
        }
    }
#endif
	
    /* configure extra text */
    if (idle_screen_type == ANALOG_IDLE_SCREEN || idle_screen_type == DIGITAL_IDLE_SCREEN)
    {
        show_extra = MMI_FALSE;
        extra_scrolling_text_ptr = NULL;
    }
    else
    {
        MMI_BOOL is_display = MMI_TRUE;

#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        if (min_y < UI_device_height - 1)
        {
            y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        #ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
                ;
            if ((y + Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) - 1) >= min_y)
            {
                is_display = MMI_FALSE;
            }
        }
#endif

#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

        if (is_display == MMI_FALSE)
        {
            show_extra = MMI_FALSE;
            extra_scrolling_text_ptr = NULL;
        }
        else
        {
            extra_text = wgui_cat033_get_extra_text();			
            show_extra = (extra_text != NULL) ? (MMI_TRUE) : (MMI_FALSE);
            extra_scrolling_text_ptr = (show_extra == MMI_TRUE) ? (&extra_scrolling_text) : (NULL);
        }
    }
	
    /* show extra information */
    if (show_extra == MMI_TRUE && extra_scrolling_text_ptr != NULL)
    {
        S32 w_inset = MMI_IDLE_STRING_MARGIN_GAP;
        S32 bracket_width = 0, text_bracket_gap = 5;
		S32 extra_string_width = 0, extra_string_height = 0;

        gui_set_font(network_status_font);

        /* get extra string width & height */
        gui_measure_string(extra_text, &extra_string_width, &extra_string_height);
        height = Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) + 2;
   
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
        /* set refresh region */        
    #ifdef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
        if (MMI_TRUE)
        {
            extra_text_x1 = w_inset;
            extra_text_y1 = UI_device_height - wgui_cat033_get_shortcut_max_height() - height - 1;
            extra_text_x2 = UI_device_width - w_inset - 1;
            extra_text_y2 = extra_text_y1 + height - 1;
        }
        else
    #elif defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__)
        if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
        {
            extra_text_x1 = w_inset;
			extra_text_x2 = UI_device_width - w_inset - 1;
			extra_text_y2 = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y - 1;
            extra_text_y1 = extra_text_y2 - height + 1;
        }
        else
    #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
        {
            extra_text_x1 = w_inset;
            extra_text_y1 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - height - 1;
            extra_text_x2 = UI_device_width - w_inset - 1;
            extra_text_y2 = extra_text_y1 + height - 1;
        }
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

        /* set refresh region */
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        if (min_y < UI_device_height - 1)
        {
            y = MMI_IDLE_DETAILS_START_Y_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_name_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER +
                Get_CharDisplayHeightOfAllLangAndType(network_status_font->size) +
                MMI_IDLE_DETAILS_VGAP_WITH_REMINDER
        #ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
                ;
        }
        else
#endif
        {
        #if defined(__MMI_BT_DIALER_SUPPORT__)
		#ifdef __MMI_BT_BOX_IDLE_SHORTCUTS__ //lu
			y = 2 * (height - 2 + MMI_IDLE_STATUS_BT_NAME_GAP);  
		#else
        #ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
        #else
            y = MMI_IDLE_NETWORK_NAME_Y + 2 * (height - 2 + MMI_IDLE_STATUS_BT_NAME_GAP);  
        #endif
		#endif /* __MMI_BT_BOX_IDLE_SHORTCUTS__ */
        #else
            y = MMI_IDLE_EXTRA_Y;
        #endif
        }
        extra_text_x1 = w_inset;
        extra_text_y1 = y;
        extra_text_x2 = UI_device_width - w_inset - 1;
        extra_text_y2 = y + height - 1;
#ifdef __MMI_MAINLCD_96X64__
        wgui_cat033_draw_region_with_background_color(0, extra_text_y1, UI_device_width - 1, extra_text_y2);
#endif
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */        
		
        gdi_layer_push_clip();
#ifdef __GDI_MEMORY_PROFILE_2__
        if (extra_text_x1 >= 0)
        {
            gdi_layer_set_clip(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2);
        }
#endif /* __GDI_MEMORY_PROFILE_2__ */
        gdi_layer_pop_clip();

        /* show bracket */
        wgui_cat033_show_bracket();

        /* show extra information */
        gui_set_text_color(*current_MMI_theme->idle_scr_network_extra_color);
        gui_set_text_border_color(*current_MMI_theme->idle_scr_network_extra_border_color);
        
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);        
#endif
        
		extra_string_width += 2;  /* border text */
		extra_string_height += 2; /* border text */

        bracket_width = gui_get_character_width('[') + 2; /* bracket width */
        if (extra_string_width <= (UI_device_width - ((w_inset + text_bracket_gap + 2/*bordered text*/*3/*"[","]",content*/) * 2)))
        {
            x = (r2lMMIFlag) ? ((UI_device_width >> 1) + (extra_string_width >> 1)) : ((UI_device_width >> 1) - (extra_string_width >> 1));
			x += (r2lMMIFlag) ? (-1) : (1); /* border text */
            y = extra_text_y1 + ((height - extra_string_height) >> 1);  /* central y in refesh region */
			y += 1; /* border text */
            gui_move_text_cursor(x, y);
            gui_print_bordered_text(extra_text);
        }
        else
        {
            x = w_inset + bracket_width + text_bracket_gap;
            y = extra_text_y1 + ((height - extra_string_height) >> 1); /* central y in refresh region */
            width = UI_device_width - x - (w_inset + gui_get_character_width(']') + 2 + text_bracket_gap);
            gui_create_scrolling_text(
				extra_scrolling_text_ptr,
				x + 2, /* scrolling text reserve 4 pixels in x-coordinate, x have to move 2 pixels */
				y + 1, /* scrolling text reserve 2 pixels in y-coordinate, y have to move 1 pixel */
				width - 4, /* scrolling text reserve 4 pixels in x-coordinate */
				extra_string_height - 2, /* scrolling text reserve 2 pixels in y-coordinate */
				extra_text,
				wgui_cat033_handle_extra_text_scroll,
				wgui_cat033_redraw_extra_text_background,
				*current_MMI_theme->idle_scr_network_extra_color,
				*current_MMI_theme->idle_scr_network_extra_border_color);
            extra_scrolling_text_ptr->scroll_gap = 20;
            extra_scrolling_text_ptr->flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
            gui_show_scrolling_text(extra_scrolling_text_ptr);
        }
        
#ifdef __GDI_MEMORY_PROFILE_2__
        gdi_pop_and_restore_alpha_blending_source_layer();
#endif
    }
    else
    {
	/* for indicate no draw extra_text this time,
		* so no need to clean it next time */
        extra_text_x1 = -1;
    }

    return show_extra;
}


#if defined(__SAT__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_SAT_icon
 * DESCRIPTION
 *  show SAT icon on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL wgui_cat033_show_SAT_icon(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8* SAT_icon = NULL;
    S32 x = 0, y = 0, width = 0, height = 0, i = 0;
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    S32 min_y = UI_device_height - 1;
#endif

    MMI_BOOL is_display = MMI_FALSE;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
    /* show SAT icon */
    /* the rule to display the SAT icon is a little complicated,
	* can be revised in the future */
#if defined(__MMI_TELEPHONY_SUPPORT__) 
	SAT_icon = GetSATIdleIcon();
#endif
	if (SAT_icon != NULL)
	{
		S32 display_x_offset, display_y_offset;
		S32 display_width, display_height;

        is_display = MMI_TRUE;

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)

        /* find min y of all reminders*/
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].state != cat33_reminder_area_state_deinit)
            {
                min_y = min(min_y, g_wgui_cat033_reminder[i].y);
            }
        }
#endif
		gui_measure_image(SAT_icon, &width, &height);
		gdi_util_fit_box(
			GDI_UTIL_MODE_LONG_SIDE_FIT,
			26, 26, /* available display area, can be defined in wgui.h in the future */
			width, height,
			&display_x_offset, &display_y_offset,
			&display_width, &display_height);

#if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
        x = (UI_device_width >> 1) - (display_width >> 1);
        y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 26;
        is_display = MMI_TRUE;
#else /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
    #if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
		x = 1;  /* can be defined in wgui.h in the future */
		y = 22; /* can be defined in wgui.h in the future */
    #elif defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
		x = 1;  /* can be defined in wgui.h in the future */
		y = 24; /* can be defined in wgui.h in the future */
    #else /* defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
		x = (UI_device_width >> 1) - (display_width >> 1);
		y = MMI_IDLE_SATICON_Y;
    #endif /* defined(__MMI_MAINLCD_176X220__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
		if (min_y < UI_device_height - 1) /* have reminder */
		{
			if ((y + display_height - 1) >= min_y)
			{
				is_display = MMI_FALSE;
			}
		}
#endif

#endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */

		if (is_display == MMI_TRUE)
		{
			gui_push_clip();
			gui_set_clip(x, y, x + display_width, y + display_height);
			gdi_image_draw_resized(x, y, display_width, display_height, SAT_icon);
			gui_pop_clip();
		}
	}
    return is_display;
}
#endif /* defined(__SAT__) */


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_show_details
 * DESCRIPTION
 *  show network name, network status, extra information, and SAT on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_show_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL status_extra_text = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
        
    if (extra_text_x1 >= 0)
    {
        wgui_cat033_draw_region_with_background_color(extra_text_x1, extra_text_y1, extra_text_x2, extra_text_y2);
    }
    
#if defined(__MMI_DUAL_SIM_MASTER__)
/* under construction !*/
/* under construction !*/
  #if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
  #else  /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
    #if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #else    
/* under construction !*/
    #if !defined(__MMI_MAINLCD_96X64__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
    #endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */
  #endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
/* under construction !*/
#else /* defined(__MMI_DUAL_SIM_MASTER__) */
    
  /* single SIM */
  #if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
        wgui_cat033_techno_set_text_and_date();
        wgui_cat033_show_techno_network_name();
        wgui_cat033_show_techno_network_status();
  #else
        wgui_cat033_show_network_name();
  #ifndef __MMI_MAINLCD_96X64__
        wgui_cat033_show_network_status();
  #endif
  #endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */
        
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */
    
    /* show extra information */
#if defined(__MMI_SEARCH_WEB__) && (defined(__MMI_MAINLCD_128X160__) || (defined(__MMI_MAINLCD_240X320__) || defined(__MMI_MAINLCD_320X240__))&&(defined(__MMI_CALENDAR_ON_IDLE_SCREEN__)))
    if(g_wgui_cat033_search.image == NULL && g_wgui_cat033_search.string == NULL)
#endif  /*__MMI_SEARCH_WEB__ */
    {
        status_extra_text = wgui_cat033_show_extra_information();
    }
#ifdef __MMI_MAINLCD_96X64__
    if(status_extra_text == MMI_TRUE)
    {
        deactive_main_lcd_update_date_time();
    }
    else
    {
        enactive_main_lcd_update_date_time();
    }
    #ifdef __GDI_MEMORY_PROFILE_2__
            update_mainlcd_dt_display();
    #else /* __GDI_MEMORY_PROFILE_2__ */
            show_main_LCD_dt_display();
    #endif /* __GDI_MEMORY_PROFILE_2__ */
#endif
#if defined(__SAT__)
    /* show SAT icon */
    wgui_cat033_show_SAT_icon();
#endif /* defined(__SAT__) */

#ifdef __MMI_BT_DIALER_SUPPORT__
    wgui_cat033_show_BT_dialer_info();
#endif
    
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


#ifdef __MMI_BT_DIALER_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  idle_screen_show_BT_dailer_details
 * DESCRIPTION
 *  show BT dialer pairing name, status and extra information on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_show_BT_dailer_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_idle_is_active())
    {
        wgui_cat033_show_details();
    }
}
#endif


/*****************************************************************************
 * FUNCTION
 *  idle_screen_show_network_details
 * DESCRIPTION
 *  show network name and network status on idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_show_network_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_OP11_CAT433_SUPPORT__)
    if (mmi_hs_is_enable())
    {
        wgui_cat433_update_details();
    }
    else
#elif defined(__MMI_OP12_CAT533_SUPPORT__)
    if (mmi_tb_is_enable())
    {
        wgui_cat533_update_details();
    }
    else
#elif defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)   
    if (mmi_op11_hs32_is_enable())
    {
        mmi_idle_update_service_area();
    }
    else
#elif defined(__MMI_VUI_SHELL_APP__)
    if (MMI_TRUE)
    {
        mmi_idle_shell_update_idle_text();
    }
    else
#endif
    {
        wgui_cat033_show_details();
    }
}
#if defined(__MMI_SEARCH_WEB__)
static void gui_search_bar_timer_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     gui_handle_scrolling_text(&g_search_tab_scroll_text);
}

/*****************************************************************************
 * FUNCTION
 *  gui_search_background
 * DESCRIPTION
 *  draw hilight menuitem text, callback function for scrolling text
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 static void gui_search_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */  
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_search_show
 * DESCRIPTION
 *  for category 33 to show searching screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_search_show()
{
    S32 img_w = 0, img_h = 0;
    S32 string_w = 0, string_h = 0;
    S32 string_x = 0;
	gui_push_clip();
	gui_set_clip(g_wgui_cat033_search.x, g_wgui_cat033_search.y, g_wgui_cat033_search.x + g_wgui_cat033_search.w, g_wgui_cat033_search.y + g_wgui_cat033_search.h);
    gui_measure_image(g_wgui_cat033_search.image, &img_w, &img_h);
    gui_set_font(&MMI_medium_font);
    gui_measure_string((UI_string_type)g_wgui_cat033_search.string, &string_w, &string_h);
     #ifdef __MMI_BIDI_ALG__
	if(r2lMMIFlag)
	{
            string_x =  g_wgui_cat033_search.x - g_wgui_cat033_search.w + 1;
	    gui_show_transparent_image(string_x, g_wgui_cat033_search.y + ((g_wgui_cat033_search.h - img_h)>>1) , g_wgui_cat033_search.image, 0);  
        }
        else
     #endif
        {
           gui_show_transparent_image(g_wgui_cat033_search.x, g_wgui_cat033_search.y + ((g_wgui_cat033_search.h - img_h)>>1) , g_wgui_cat033_search.image, 0);  
           string_x = g_wgui_cat033_search.x + img_w + MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP; 
        } 
	gui_create_scrolling_text(
            &g_search_tab_scroll_text,
            string_x,
            g_wgui_cat033_search.y + ((g_wgui_cat033_search.h - string_h)>>1),
            UI_DEVICE_WIDTH - (MMI_status_bar_height<<1) - img_w - MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP, //g_wgui_cat033_search.w - img_w - MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP,
            string_h,
            (UI_string_type) g_wgui_cat033_search.string,
            gui_search_bar_timer_callback,
            gui_search_background,
            *current_MMI_theme->idle_scr_network_name_color,
            *current_MMI_theme->idle_scr_network_name_border_color
        );
	g_search_tab_scroll_text.text_font = MMI_medium_font;
    g_search_tab_scroll_text.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
    gui_show_scrolling_text(&g_search_tab_scroll_text);
    gui_pop_clip();
}

/*****************************************************************************
 * FUNCTION
 *  idle_screen_enable_searching_screen
 * DESCRIPTION
 *  for category 33 to show searching screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 void idle_screen_enable_search_bar(const U8 *image, const WCHAR* text, FuncPtr touch_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_h = 0, img_w = 0;
    S32 string_w = 0, string_h = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_search.y = MMI_IDLE_STATIC_SEARCH_START_Y;
    g_wgui_cat033_search.image = (U8 *)image;
    g_wgui_cat033_search.string = (U8 *)text;
    gui_measure_image(g_wgui_cat033_search.image, &img_w, &img_h);
    gui_set_font(&MMI_medium_font);
    gui_measure_string((UI_string_type)g_wgui_cat033_search.string, &string_w, &string_h);
    if(img_w + MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP + string_w <= UI_DEVICE_WIDTH - (MMI_status_bar_height<<1))
    {
        g_wgui_cat033_search.w = img_w + MMI_IDLE_STATIC_SEARCH_IMAGE_STRING_GAP + string_w;
    }
    else
    {
         g_wgui_cat033_search.w = UI_DEVICE_WIDTH - (MMI_status_bar_height<<1);
    }
    #ifdef __MMI_BIDI_ALG__
		if(r2lMMIFlag)
		{
			g_wgui_cat033_search.x = (UI_DEVICE_WIDTH + g_wgui_cat033_search.w)>>1;
		}
		else
	#endif
		{
    		g_wgui_cat033_search.x = (UI_DEVICE_WIDTH - g_wgui_cat033_search.w)>>1;
		}
    if(img_h >= string_h)
    {
        g_wgui_cat033_search.h = img_h;
    }
    else
    {
        g_wgui_cat033_search.h = string_h;
    }
#if defined(__MMI_TOUCH_SCREEN__) 
#ifdef __MMI_ICON_BAR_SUPPORT__
	g_wgui_cat033_search.pen_event_handler = wgui_icon_bar_translate_pen_event;
#endif
#endif
	g_wgui_cat033_search.handler = touch_handler;
}
#endif /*__MMI_SEARCH_WEB__*/

#if defined(__MMI_CALENDAR_ON_IDLE_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_init
 * DESCRIPTION
 *  for category 33 to init calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    applib_time_struct max_time, min_time, current_time;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state == cat33_reminder_area_state_deinit)
    {
        memset(&min_time, 0, sizeof(applib_time_struct));
        memset(&max_time, 0, sizeof(applib_time_struct));
        memset(&current_time, 0, sizeof(applib_time_struct));
        min_time.nYear = GUI_CALENDAR_DEFAULT_FIRST_NAVI_YEAR;
        min_time.nMonth = 1;
        min_time.nDay = 1;
        max_time.nYear = GUI_CALENDAR_DEFAULT_LAST_NAVI_YEAR;
        max_time.nMonth = 12;
        max_time.nDay = 31;
        applib_dt_get_date_time(&current_time);
        /* init calendar GUI component before init application's data */
        wgui_calendar_create(
            GUI_CALENDAR_TYPE_MONTH,
            max_time,
            min_time,
            current_time,
            0);
        wgui_calendar_set_flags_on(GUI_CALENDAR_DISABLE_PREV_NEXT_SWITCH);
        wgui_calendar_set_on_idle(MMI_TRUE);

        /* init calendar data of applicaion */
        mmi_clndr_create_calendar_on_idle();

        /* init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state = cat33_reminder_area_state_init;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_deinit
 * DESCRIPTION
 *  for category 33 to de-init calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state != cat33_reminder_area_state_deinit)
    {
        /* de-init calendar GUI component */
        wgui_calendar_close();

        /* de-init calendar data of application */
        mmi_clndr_exit_set_calendar_on_idle();

        /* de-init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state = cat33_reminder_area_state_deinit;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_show
 * DESCRIPTION
 *  for category 33 to show calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* display calendar GUI component */
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state == cat33_reminder_area_state_init)
    {
        wgui_calendar_show();

        /* show successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state = cat33_reminder_area_state_show;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_calendar_redraw
 * DESCRIPTION
 *  for category 33 to redraw calendar display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_calendar_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* redraw calendar GUI component */
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].state == cat33_reminder_area_state_show)
    {
        wgui_calendar_idle_update();
    }
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_enable_calendar_display
 * DESCRIPTION
 *  for idle app to display calendar on idle screen category
 *  this function must be called before show category funcion
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_enable_calendar_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].init = wgui_cat033_calendar_init;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].show = wgui_cat033_calendar_show;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].redraw = wgui_cat033_calendar_redraw;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].deinit = wgui_cat033_calendar_deinit;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].x = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_X;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].y = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_Y;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].w = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_WIDTH;
    g_wgui_cat033_reminder[wgui_cat033_reminder_calendar].h = MMI_IDLE_STATIC_CALENDAR_MONTH_FRAME_START_HEIGHT;
}
#endif /* defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) */

#if defined(__MMI_OP01_DCD__)

typedef struct _wgui_cat033_dcd_data_struct
{
    GDI_HANDLE* dcd_layer;
    U8* dcd_mem;
    void* dcd_agent;
} wgui_cat033_dcd_data_struct;

static wgui_cat033_dcd_data_struct g_wgui_cat033_dcd_data = {0};
extern UI_dcd_theme *current_dcd_theme;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_draw_background
 * DESCRIPTION
 *  for category 33 to draw dcd background
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_draw_background(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x;
    y1 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y;
    x2 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x + g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].w - 1;
    y2 = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y + g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].h - 1;

	gui_push_clip();
	gui_set_clip(x1, y1, x2, y2);
	/* show DCD background */
	gui_draw_filled_area(x1, y1, x2, y2, current_dcd_theme->dcd_idle_bkg_filler);
	gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_redraw
 * DESCRIPTION
 *  for category 33 to redraw dcd 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_redraw(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state == cat33_reminder_area_state_show)
    {
		wgui_cat033_dcd_draw_background();
	}
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_init
 * DESCRIPTION
 *  for category 33 to init dcd display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state == cat33_reminder_area_state_deinit)
    {        
        /* init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state = cat33_reminder_area_state_init;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_deinit
 * DESCRIPTION
 *  for category 33 to de-init dcd display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_dcd_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state != cat33_reminder_area_state_deinit)
    {
        ptr = (wgui_cat033_dcd_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data);

        mmi_dcd_exit_idlescreen();
        
        /* de-init DCD component */
        ui_dcd_deinit(); 

        /* free dcd layer */
        ptr->dcd_layer = NULL;
        
        /* free dcd memory */
        if (ptr->dcd_mem != NULL)
        {
            mmi_frm_scrmem_free(ptr->dcd_mem);
            ptr->dcd_mem = NULL;
        }        
        memset(ptr, 0, sizeof(wgui_cat033_dcd_data_struct));
               
        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state = cat33_reminder_area_state_deinit;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dcd_show
 * DESCRIPTION
 *  for category 33 to show dcd display
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_dcd_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_dcd_data_struct* ptr = NULL;
    S32 x, y, w, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state == cat33_reminder_area_state_init)
    {            
        ptr = (wgui_cat033_dcd_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data);
        x = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x;
        y = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y;
        w = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].w;
        h = g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].h;

        wgui_cat033_dcd_draw_background();

        /* init DCD layer: allocate memory */
        MMI_ASSERT(ptr->dcd_mem == NULL);
        ptr->dcd_mem = (U8*)mmi_frm_scrmem_alloc_framebuffer(SCRMEM_CAT33_POOL_SIZE);
        MMI_ASSERT(ptr->dcd_mem);
        
        /* create layer */
        MMI_ASSERT(ptr->dcd_layer == NULL);
        dm_create_layer_using_outside_memory(
                x, y, w, h, 
                &(ptr->dcd_layer), ptr->dcd_mem, 
                SCRMEM_CAT33_POOL_SIZE,
                DM_LAYER_TOP);
        MMI_ASSERT(ptr->dcd_layer);

        /* init layer */
        gdi_layer_push_and_set_active(*(ptr->dcd_layer));
        gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
        gdi_layer_clear(GDI_COLOR_TRANSPARENT);
        gdi_layer_pop_and_restore_active();

        /* init DCD component */
		ui_dcd_init(x, y, w, h, *(ptr->dcd_layer), ptr->dcd_agent);

        /* show DCD component */
        ui_dcd_show_start();        

        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state = cat33_reminder_area_state_show;
    }
}


#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
 * FUNCTION
 *  idle_screen_set_dcd_pen_event_callback
 * DESCRIPTION
 *  for idle app to set pen event callback function
 * PARAMETERS
 *  agent   [IN]        DCD agent
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_register_dcd_pen_handler(cat33_reminder_pen_handler pen_handler)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].pen_event_handler = pen_handler;
}
#endif /* defined(__MMI_TOUCH_SCREEN__)  */


/*****************************************************************************
 * FUNCTION
 *  idle_screen_enable_dcd_display
 * DESCRIPTION
 *  for idle app to display DCD on idle screen category
 *  this function must be called before show category funcion
 * PARAMETERS
 *  agent   [IN]        DCD agent
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_enable_dcd_display(void* agent)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_dcd_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].init = wgui_cat033_dcd_init;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].show = wgui_cat033_dcd_show;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].redraw = wgui_cat033_dcd_redraw;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].deinit = wgui_cat033_dcd_deinit;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].x = 0;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].y = MMI_IDLE_DCD_START_Y;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].w = MAIN_LCD_DEVICE_WIDTH;
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].h = MMI_IDLE_DCD_HEIGHT;
#if defined(__MMI_TOUCH_SCREEN__) 
    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].pen_event_handler = NULL;
#endif /* defined(__MMI_TOUCH_SCREEN__)  */

    g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data = &g_wgui_cat033_dcd_data;
    ptr = (wgui_cat033_dcd_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].data);
    ptr->dcd_agent = agent;
}
#endif /* defined(__MMI_OP01_DCD__) */


#ifdef __MMI_IDLE_SCREEN_ICON_SHORTCUT__

typedef struct
{
    PU8* hint_array;
    PU8* pressed_icon_array;
    PU8* unpressed_icon_array;
    GUIIconbarItemCallback function_array;   /* icon_bar_item_callback will called when key/pen up */
    S32 number_of_item;        /* icon number */
} wgui_cat033_icon_shortcut_bar_data_struct;

static wgui_cat033_icon_shortcut_bar_data_struct g_wgui_cat033_icon_shortcut_bar_data = {0};

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_is_active
 * DESCRIPTION
 *  get if icon shortcut bar is active
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_icon_shortcut_bar_is_active(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_ICON_BAR_SUPPORT__ 	
    return (wgui_icon_bar_is_active());
#else
    return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_update_icon_shortcut_bar
 * DESCRIPTION
 *  update icon shorcut bar (callback function from icon bar component)
 * PARAMETERS
 *  start_index             [IN]       data start index
 *  number_of_items         [IN]       number of shorcut items 
 *  unpressed_icon_array    [IN/OUT]   unpressed icon array
 *  pressed_icon_array      [IN/OUT]   pressed icon array 
 *  hint_array              [IN/OUT]   hint array
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_icon_shortcut_bar_update(
                           U32 start_index, 
                           U32 number_of_items, 
                           U8** unpressed_icon_array,
                           U8** pressed_icon_array,
                           U8** content_icon_array,
                           U8** disabled_content_icon_array,
                           U8** hint_array)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i = 0;    
    wgui_cat033_icon_shortcut_bar_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ptr = (wgui_cat033_icon_shortcut_bar_data_struct*)g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data;
    
    for (i = 0; i < number_of_items; i++)
    {
        unpressed_icon_array[i] = (ptr->unpressed_icon_array)[i + start_index];
        pressed_icon_array[i] = (ptr->pressed_icon_array)[i + start_index];
        content_icon_array[i] = NULL;
        disabled_content_icon_array[i] = NULL;
        hint_array[i] = (ptr->hint_array)[i + start_index];
    }
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_redraw
 * DESCRIPTION
 *  redraw icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_icon_shortcut_bar_redraw(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state == cat33_reminder_area_state_show)
    {        
        wgui_icon_bar_show();
	}
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_init
 * DESCRIPTION
 *  init icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_icon_shortcut_bar_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h, count, i;
    wgui_cat033_icon_shortcut_bar_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state == cat33_reminder_area_state_deinit)
    {        
        ptr = (wgui_cat033_icon_shortcut_bar_data_struct*)g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data;
    
        x = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].x;
        y = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y;
        w = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].w;
        h = g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].h;
        count = ptr->number_of_item;
        
        wgui_cat033_draw_region_with_background_color(x, y, x + w - 1, y + h - 1);
        wgui_icon_bar_create(x, y, w, h, count, MMI_FALSE, MMI_FALSE);
        wgui_icon_bar_move(x, y);
        wgui_icon_bar_resize(w, h);
        wgui_icon_bar_set_align(GUI_ICON_BAR_ALIGN_BY_CENTER);
        
        /* set items icon and hint */
        for (i = 0; i < count; i++)
        {
            wgui_icon_bar_set_item(
                    i,
                    (ptr->unpressed_icon_array)[i],
                    (ptr->pressed_icon_array)[i],
                    NULL,
                    NULL,
                    (ptr->hint_array)[i],
                    ptr->function_array);
        }
        
        /* set arrow icon */
        wgui_icon_bar_register_update_handler(wgui_cat033_icon_shortcut_bar_update);
        
        wgui_icon_bar_active();

        /* init successfully, set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state = cat33_reminder_area_state_init;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_deinit
 * DESCRIPTION
 *  deinit icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_icon_shortcut_bar_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
    {
        wgui_icon_bar_close();
        
        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state = cat33_reminder_area_state_deinit;
    }     
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_show
 * DESCRIPTION
 *  show icon shorcut bar in idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_icon_shortcut_bar_show(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state == cat33_reminder_area_state_init)
    {
        wallpaper_layer = dm_get_wallpaper_layer();
        wgui_icon_bar_set_abm_layer(wallpaper_layer);    
        wgui_icon_bar_show();

        /* set state */
        g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state = cat33_reminder_area_state_show;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_bar_set_history
 * DESCRIPTION
 *  set icon shorcut bar history
 * PARAMETERS
 *  history_buffer       [IN]   history buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_icon_shortcut_bar_set_history(void* history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_icon_bar_set_history((wgui_icon_bar_history_struct*)history_buffer);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_icon_shortcut_get_history
 * DESCRIPTION
 *  get icon shorcut bar history
 * PARAMETERS
 *  history_buffer       [IN]   history buffer
 * RETURNS
 *  U8*
 *****************************************************************************/
U8* wgui_cat033_icon_shortcut_bar_get_history(void* history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_icon_bar_get_history((wgui_icon_bar_history_struct*) history_buffer);
    return history_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enable_icon_shortcut_bar_display
 * DESCRIPTION
 *  enalbe icon shortcut bar display in idle screen
 * PARAMETERS
 *  number_of_item       [IN]   number of shortcut item
 *  function_array       [IN]   shortcut item function
 *  hint_array           [IN]   hint of shortcut item
 *  pressed_icon_array   [IN]   pressed shorcut item icon array
 *  unpressed_icon_array [IN]   unpressed shorcut item icon array
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_enable_icon_shortcut_bar_display(
              S32 number_of_item, 
              GUIIconbarItemCallback function_array, 
              PU8* hint_array, 
              PU8* pressed_icon_array, 
              PU8* unpressed_icon_array)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wgui_cat033_icon_shortcut_bar_data_struct* ptr = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].init = wgui_cat033_icon_shortcut_bar_init;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].show = wgui_cat033_icon_shortcut_bar_show;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].redraw = wgui_cat033_icon_shortcut_bar_redraw;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].deinit = wgui_cat033_icon_shortcut_bar_deinit;
#ifdef __MMI_ICON_BAR_SUPPORT__ 	
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].get_history_size_function = wgui_icon_bar_get_history_size;
#else 
	g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].get_history_size_function = 0;  
#endif
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].get_history_function = wgui_cat033_icon_shortcut_bar_get_history;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].set_history_function = wgui_cat033_icon_shortcut_bar_set_history;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].x = 0;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].y = UI_device_height - MMI_BUTTON_BAR_HEIGHT - WGUI_IDLE_SCREEN_ICON_SHORTCUT_HEIGHT;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].w = UI_device_width;
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].h = WGUI_IDLE_SCREEN_ICON_SHORTCUT_HEIGHT;
#if defined(__MMI_TOUCH_SCREEN__) 
#ifdef __MMI_ICON_BAR_SUPPORT__
    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].pen_event_handler = wgui_icon_bar_translate_pen_event;
#endif /*__MMI_ICON_BAR_SUPPORT__*/
#endif /* defined(__MMI_TOUCH_SCREEN__)  */

    g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data = &g_wgui_cat033_icon_shortcut_bar_data;

    ptr = (wgui_cat033_icon_shortcut_bar_data_struct*)(g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].data);
    ptr->function_array = function_array;
    ptr->number_of_item = number_of_item;
    ptr->hint_array = hint_array;
    ptr->pressed_icon_array = pressed_icon_array;
    ptr->unpressed_icon_array = unpressed_icon_array;
}
#endif /* __MMI_IDLE_SCREEN_ICON_SHORTCUT__ */


/*****************************************************************************
 * FUNCTION
 *  dummy_dt_hide_function
 * DESCRIPTION
 *  dummy func of hide date
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void dummy_dt_hide_function(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x1);
    UI_UNUSED_PARAMETER(y1);
    UI_UNUSED_PARAMETER(x2);
    UI_UNUSED_PARAMETER(y2);
}

#ifdef __MMI_ANALOG_CLOCK__
/*****************************************************************************
 * FUNCTION
 *  cat33_analog_clock_hide_dt_display
 * DESCRIPTION
 *  hide function of date display of analog clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_analog_clock_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = 0;
    x2 = UI_device_width - 1;

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at analog clock */
    if (is_on_idlescreen())
    {
        y1 = 0;
        y2 = (UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 4);
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */
    {
    #if defined(__MMI_OP01_DCD__) 
        if (!(MMI_TRUE == mmi_dcd_is_switch_on() && MMI_TRUE == mmi_dcd_is_idle_on()))
        {
    #endif    
        y1 = MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
        y2 = UI_device_height - MMI_button_bar_height - 1;
    #if defined(__MMI_OP01_DCD__) 
        }
    #endif     
    }

    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#else /* __GDI_MEMORY_PROFILE_2__ */ 
    if (idle_screen_wallpaper_ID == 0)
    {
        ASSERT(idle_screen_wallpaper_ID == 0);  /* analog clock idle screen should predefined image */
        gdi_image_draw_file(cat33_image_x, cat33_image_y, idle_screen_wallpaper_name);
    }
    else
    {
        if (cat33_n_frames > 1)
        {
            gui_show_animated_image_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
        }
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gui_show_image(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
    idle_screen_show_network_details();
}
#endif


#ifdef __MMI_DIGITAL_CLOCK__
/*****************************************************************************
 * FUNCTION
 *  cat33_digital_clock_hide_dt_display
 * DESCRIPTION
 *  hide function of date display of digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
/* Assumes that the wallpaper displayed behind the digital clock is always full screen */
void cat33_digital_clock_hide_dt_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __GDI_MEMORY_PROFILE_2__
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* To retain passing coordinates to the clip window */
    x1 = 0;
    x2 = UI_device_width - 1;

#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    /* for proper display of the status bar at digital clock */
    if (is_on_idlescreen())
    {
        y1 = 0;
        y2 = (UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 4);
    }
    else
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    {
    #if defined(__MMI_OP01_DCD__) 
        if (!(MMI_TRUE == mmi_dcd_is_switch_on() && MMI_TRUE == mmi_dcd_is_idle_on()))
        {
    #endif     
        y1 = MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
        /* change for idlescreen shortcuts as their height is greater
           than MMI_button_bar_height */
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
        y2 = UI_device_height - wgui_cat033_get_shortcut_max_height() - 1;
#else 
        y2 = UI_device_height - MMI_button_bar_height - 1;
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    #if defined(__MMI_OP01_DCD__) 
        }
    #endif 
    }

    gdi_layer_push_clip();
    gdi_layer_set_clip(x1, y1, x2, y2);

#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */  
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
    gdi_layer_pop_clip();

    idle_screen_show_network_details();
}
#endif


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_time_display
 * DESCRIPTION
 *  hide function of time display of analog/digital  clock
 * PARAMETERS
 *  x1      [IN]        Start x position
 *  y1      [IN]        Start y position
 *  x2      [IN]        End x position
 *  y2      [IN]        End y position
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_time_display(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, y1, MAIN_LCD_device_width - 1, y2);
    wgui_cat033_draw_region_with_wallpaper(x1, y1, x2, y2);
    #ifdef WGUI_STATUS_ICON_SHOW_V_BAR
        wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR); /* redraw horizontal status bar */
    #endif
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  idle_screen_hide_status_icons_bar0
 * DESCRIPTION
 *  hide function of stats icon horizontal bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_hide_status_icons_bar0(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
#ifndef __MMI_IDLE_FULL_SCREEN__
    UI_filled_area *f = current_MMI_theme->status_icon_bar_filler;
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_H_BAR, &x1, &y1, &x2, &y2);
    gdi_layer_set_clip(x1, y1, x2, y2);
#ifdef __MMI_IDLE_FULL_SCREEN__
    #ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_MAINLCD_96X64__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_BLACK); 
#else
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT); 
#endif
    #else /* __GDI_MEMORY_PROFILE_2__ */ 
        draw_wallpaper();
    #endif /* __GDI_MEMORY_PROFILE_2__ */ 
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_draw_filled_area(x1, y1, x2 -x1 + 1, y2 - y1 + 1, f);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gdi_layer_pop_clip();
}

#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
/*****************************************************************************
 * FUNCTION
 *  idle_screen_hide_status_icons_bar1
 * DESCRIPTION
 *  hide function of stats icon vertical  bar of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void idle_screen_hide_status_icons_bar1(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_status_icon_bar_get_clip(WGUI_STATUS_ICON_BAR_V_BAR, &x1, &y1, &x2, &y2);
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
//    y1 = y1 + 4;    /* To restrict the clip area below from the time date area lines. */
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */

    wgui_cat033_draw_region_with_background_color(x1, y1, x2, y2);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaper
 * DESCRIPTION
 *  Sets the Image to be used by the idle screen
 * PARAMETERS
 *  image_ID        [IN]        wallpaper image ID
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaper(U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__    
#ifdef __MMI_ANALOG_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_ANALOG_CLK))
    {
        idle_screen_type = ANALOG_IDLE_SCREEN;
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_ANALOG_CLK;
    }
    else
#endif /* __MMI_ANALOG_CLOCK__ */ 

#ifdef __MMI_DIGITAL_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_DIGITAL_CLK))
    {
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_DIGITAL_CLK;
        idle_screen_type = DIGITAL_IDLE_SCREEN;
    }
    else
#endif /* __MMI_DIGITAL_CLOCK__ */ 
#endif /* !__MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        idle_screen_type = NORMAL_IDLE_SCREEN;
        idle_screen_wallpaper_ID = image_ID;
    }
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    gui_measure_image(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
    cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
    cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
    cat33_image_y = (UI_device_height - cat33_image_height) >> 1;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenNetworkName
 * DESCRIPTION
 *  Sets the network name to be displayed by the idle screen
 * PARAMETERS
 *  s       [IN]     network name string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenNetworkName(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_network_name = (UI_string_type) s;
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenNetworkStatus
 * DESCRIPTION
 *  Sets the network status to be displayed by the idle screen
 * PARAMETERS
 *  s       [IN]     status string
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenNetworkStatus(U8 *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_network_status = (UI_string_type) s;
}


#if defined(__MMI_DUAL_SIM_MASTER__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MMI_DUAL_SIM_MASTER__) */

#ifndef __GDI_MEMORY_PROFILE_2__
/*****************************************************************************
 * FUNCTION
 *  cat33_animation_processor
 * DESCRIPTION
 *  a function which shows frames of animated wallpaper
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_animation_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat33_frame_number++;
    if (cat33_frame_number >= cat33_n_frames)
    {
        cat33_frame_number = 0;
    }
    gui_start_timer(cat33_animation_delay, cat33_animation_processor);

    gui_lock_double_buffer();

#ifndef __MMI_IDLE_FULL_SCREEN__
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - MMI_button_bar_height);
#else /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_reset_clip();
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
    gui_show_animated_image_frame(cat33_image_x, cat33_image_y, idle_screen_wallpaper, (S16) cat33_frame_number);

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));//070306 Alpha layer
    }
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
    show_main_LCD_dt_display();
#ifdef __MMI_IDLE_FULL_SCREEN__
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_H_BAR);
#endif 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_redraw(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
    idle_screen_show_network_details();

#ifdef __MMI_IDLE_FULL_SCREEN__
    if (cat33_image_height < UI_device_height)
    {
        show_softkey_background();
    }
    show_left_softkey();
    show_right_softkey();
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}
#endif

#ifdef __MMI_WALLPAPER_ON_BOTTOM__
/*****************************************************************************
 * FUNCTION
 *  wgui_set_wallpaper_change
 * DESCRIPTION
 *  Sets the Image to be used by the idle screen using ID
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_set_wallpaper_change(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   // gIsWallpaperChange = 1;
}


/*****************************************************************************
 * FUNCTION
 *  SetListWallpaperID
 * DESCRIPTION
 *  set list wallpaper ID
 * PARAMETERS
 *  image_ID        [IN]        wallpaper ID
 * RETURNS
 *  void
 *****************************************************************************/
void SetListWallpaperID(U16 image_ID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;
    S32 disp_height = UI_device_height, disp_width = UI_device_width;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_type = NORMAL_IDLE_SCREEN;
    idle_screen_wallpaper_ID = image_ID;
    
    idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
    cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
    gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
    cat33_image_x = (disp_width - cat33_image_width) >> 1;
    cat33_image_y = (disp_height - cat33_image_height) >> 1;
    
    #ifndef __MMI_VIEW_SETTING_DISABLE_CACHE__
    idle_screen_cache_id = idle_screen_wallpaper_ID;
    idle_screen_cache_name = NULL;
    #endif
}
#endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaperID
 * DESCRIPTION
 *  set Idle screen wall paper ID
 * PARAMETERS
 *  image_ID        [IN]        wallpaper ID
 *  is_default      [IN]        Save the layer of wallpaper as fast format
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaperID(U16 image_ID, MMI_BOOL is_default)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 idle_screen_wallpaper;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(is_default);

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
    if (idle_screen_wallpaper_ID != 0 && !mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
    {
        mmi_frm_resmem_dereg_retain((U16)idle_screen_wallpaper_ID);
    }
#endif /* __MMI_RESOURCE_ENFB_SUPPORT__ */ 

#ifndef __MMI_UI_TECHNO_IDLESCREEN_BAR__
#ifdef __MMI_ANALOG_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_ANALOG_CLK))
    {
        idle_screen_type = ANALOG_IDLE_SCREEN;
        /* __CUSTPACK_MULTIBIN Calvin BEGIN */
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_ANALOG_CLK;
        /* __CUSTPACK_MULTIBIN Calvin END */
    }
    else
#endif /* __MMI_ANALOG_CLOCK__ */ 
#ifdef __MMI_DIGITAL_CLOCK__
    if ((image_ID == IMG_ID_DISPCHAR_DIGITAL_CLK))
    {
        idle_screen_wallpaper_ID = IMG_ID_DISPCHAR_DIGITAL_CLK;
        idle_screen_type = DIGITAL_IDLE_SCREEN;
    }
    else
#endif /* __MMI_DIGITAL_CLOCK__ */ 
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    {
        idle_screen_type = NORMAL_IDLE_SCREEN;
        idle_screen_wallpaper_ID = image_ID;
    }
    
    if (mmi_phnset_check_themeid_wallpaper(idle_screen_wallpaper_ID))
    {
        cat33_n_frames = 1;
        cat33_image_width = MAIN_LCD_DEVICE_WIDTH;
        cat33_image_height = MAIN_LCD_DEVICE_HEIGHT;
        cat33_image_x = 0;
        cat33_image_y = 0;
    }
    else
    {
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
        mmi_frm_resmem_reg_retain((U16)idle_screen_wallpaper_ID);
#endif
        
        idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
        gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
        gdi_image_get_frame_count_id(idle_screen_wallpaper_ID, &cat33_n_frames);
        cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
        cat33_image_y = (UI_device_height - cat33_image_height) >> 1;
    }

    #ifndef __MMI_VIEW_SETTING_DISABLE_CACHE__
    #ifdef __MMI_WALLPAPER_ON_BOTTOM__
        idle_screen_cache_id = idle_screen_wallpaper_ID;
        idle_screen_cache_name = NULL;
    #endif /* __MMI_WALLPAPER_ON_BOTTOM__ */ 
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  SetIdleScreenWallpaperName
 * DESCRIPTION
 *  set idle screen wallpaper name
 * PARAMETERS
 *  name        [IN]        image file name
 * RETURNS
 *  void
 *****************************************************************************/
void SetIdleScreenWallpaperName(UI_string_type name)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 disp_height = UI_device_height, disp_width = UI_device_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__ 
    if (idle_screen_wallpaper_ID != 0)
    {
        mmi_frm_resmem_dereg_retain((U16)idle_screen_wallpaper_ID);
    }
#endif /* __MMI_RESOURCE_ENFB_SUPPORT__ */ 
    idle_screen_wallpaper_ID = 0;
    idle_screen_type = NORMAL_IDLE_SCREEN;

#ifndef __MMI_IDLE_FULL_SCREEN__
    disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
    disp_width = UI_device_width - 1;
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    gdi_image_get_dimension_file((CHAR*) name, &cat33_image_width, &cat33_image_height);
    cat33_image_x = (disp_width - cat33_image_width) >> 1;
    cat33_image_y = (disp_height - cat33_image_height) >> 1;

    gdi_image_get_frame_count_file((U8 *)name, &cat33_n_frames);

    mmi_ucs2cpy(idle_screen_wallpaper_name_original, (CHAR*) name);
    idle_screen_wallpaper_name = idle_screen_wallpaper_name_original;

}


#ifdef __DRM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_scrsvr_drm_callback
 * DESCRIPTION
 *  Screen saver DRM consume callback
 * PARAMETERS
 *  point       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_wallpaper_drm_callback(S32 res, S32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DRM_stop_consume(consumer);
    PhnsetWallpaperBadFileCallBack(0);
}
#endif /* __DRM_SUPPORT__ */

#ifdef __MMI_LAUNCHER_APP_LIST_VIDEO_WALLPAPER__
extern S32 is_vlw_file;
#endif

#ifdef __MMI_LAUNCHER_APP_LIST_INTERACTIVE_VIDEO_WALLPAPER__
extern S32 is_ivlw_file;
#endif

/*****************************************************************************
 * FUNCTION
 *  draw_wallpaper
 * DESCRIPTION
 *  Redraws the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void draw_wallpaper(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID_TYPE wallpaper_ID = idle_screen_wallpaper_ID;
    
    PU8 idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);

    /* Robin 1208 Display user define wallpaper */
    S32 disp_height = UI_device_height, disp_width = UI_device_width;

    GDI_RESULT ret = GDI_SUCCEED;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_LAUNCHER_APP_LIST_VIDEO_WALLPAPER__
    if(is_vlw_file == 1)
    {
        wallpaper_ID = IMG_ID_PHNSET_WP_START;
        idle_screen_wallpaper = get_image(wallpaper_ID);
    }
#endif

#ifdef __MMI_LAUNCHER_APP_LIST_INTERACTIVE_VIDEO_WALLPAPER__
    if(is_ivlw_file == 1)
    {
        wallpaper_ID = IMG_ID_PHNSET_WP_START;
        idle_screen_wallpaper = get_image(wallpaper_ID);
    }
#endif


#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 

#if defined(__MMI_OP12_CAT533_SUPPORT__)
    /* draw specific color designed by artist: RGB: 154,185,187 */
    gdi_draw_solid_rect(0, 0, UI_device_width - 1, UI_device_height - 1, gdi_act_color_from_rgb(255, 154, 185, 187));
#else
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
#endif /* defined(__MMI_OP12_CAT533_SUPPORT__) */

#ifndef __MMI_DM_BW_WITHOUT_WALLPAPER__
#ifndef __MMI_IDLE_FULL_SCREEN__
    /* Robin 1208 Display user define wallpaper */
    disp_height = UI_device_height - MMI_status_bar_height - MMI_button_bar_height;
    disp_width = UI_device_width - 1;
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - MMI_button_bar_height);
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
    if (wallpaper_ID != 0)  /* image comes from resource */
    {
        gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
        cat33_image_x = (UI_device_width - cat33_image_width) >> 1;
        cat33_image_y = (UI_device_height - cat33_image_height) >> 1;  
        if (cat33_n_frames > 1)
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
            gdi_image_draw_animation_frames(
            cat33_image_x,
            cat33_image_y,
            idle_screen_wallpaper,
            &animation_handle,
            (S16) cat33_frame_number);
#else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
        {
            gdi_image_draw_animation_single_frame(
                cat33_image_x,
                cat33_image_y,
                idle_screen_wallpaper,
                (S16) cat33_frame_number);
            cat33_animation_delay = gdi_image_get_animation_delay();
        }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
        else
        {
            if (mmi_phnset_check_themeid_wallpaper(wallpaper_ID))
            {
                gui_draw_filled_area(0, 0, UI_device_width, UI_device_height, current_MMI_theme->idle_bkg_filler);
            }
            else
            {
                gdi_image_draw(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
                
            }
        }
    }
    else
    {
        /* 102406 DRM check Start */
        FS_HANDLE handle = 0;
        kal_bool is_allowed = KAL_TRUE;

        if (idle_screen_wallpaper_name_original == NULL)
        {
            ret = GDI_IMAGE_ERR_INVALID_FILE;
        }
        else
        {
            handle = DRM_open_file((PU16) idle_screen_wallpaper_name_original, FS_READ_ONLY, DRM_PERMISSION_DISPLAY);
            if (handle >= FS_NO_ERROR)
            {
            #ifdef __DRM_SUPPORT__
                if (DRM_validate_forward_rule(handle, DRM_PERMISSION_DISPLAY))
                {
                    consumer = DRM_consume_rights(handle, DRM_PERMISSION_DISPLAY, mmi_wallpaper_drm_callback);
                    is_allowed = KAL_TRUE;
                }
                else
                {
                    is_allowed = KAL_FALSE;
                    ret = GDI_IMAGE_ERR_INVALID_FILE;
                }
            #endif /* __DRM_SUPPORT__ */ 

                DRM_close_file(handle);
            }
            else
            {
                ret = GDI_IMAGE_ERR_INVALID_FILE;
            }
            
         }
        
        if (ret != GDI_IMAGE_ERR_INVALID_FILE)
        {
            S32 offset_x = 0;
            S32 offset_y = 0;

            gdi_image_get_dimension_file(idle_screen_wallpaper_name, &cat33_image_width, &cat33_image_height);
            cat33_image_x = (disp_width - cat33_image_width) >> 1;
            cat33_image_y = (disp_height - cat33_image_height) >> 1;

            if ((disp_width >= cat33_image_width) && (disp_height >= cat33_image_height))       /* image can be displayed entirely */
            {
                /* align preview window at the center of screen */
                offset_x = (disp_width - cat33_image_width) >> 1;
                offset_y = (disp_height - cat33_image_height) >> 1;

            #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                ret = gdi_image_draw_animation_file(
                        offset_x,
                        offset_y,
                        (CHAR *) idle_screen_wallpaper_name,
                        &animation_handle);
            #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                ret = gdi_image_draw_file(offset_x, offset_y, (CHAR *) idle_screen_wallpaper_name);
            #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            }
            else    /* image is larger than screen size */
            {
                S32 resized_offset_x;
                S32 resized_offset_y;
                S32 resized_width;
                S32 resized_height;

                gdi_image_util_fit_bbox(
                    disp_width,
                    disp_height,
                    cat33_image_width,
                    cat33_image_height,
                    &resized_offset_x,
                    &resized_offset_y,
                    &resized_width,
                    &resized_height);

                /* for images of other formats, try to set center alignment */
            #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                ret = gdi_image_draw_animation_resized_file(
                        resized_offset_x,
                        resized_offset_y,
                        resized_width,
                        resized_height,
                        (CHAR *) idle_screen_wallpaper_name,
                        &animation_handle);
                /* ret = gdi_image_draw_resized_file(resized_offset_x, resized_offset_y, resized_width, resized_height, (PS8)idle_screen_wallpaper_name); */
            #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                ret = gdi_image_draw_resized_file(
                        resized_offset_x,
                        resized_offset_y,
                        resized_width,
                        resized_height,
                        (CHAR *) idle_screen_wallpaper_name);
            #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            }
        }

        if (ret < 0 && ret != GDI_GIF_ERR_OUT_OF_CLIP_REGION && ret != GDI_BMP_ERR_OUT_OF_CLIP_REGION)
        {
            if (is_allowed)
                PhnsetWallpaperBadFileCallBack(0);
            else
                PhnsetWallpaperBadFileCallBack(STR_GLOBAL_DRM_PROHIBITED);
            
            idle_screen_wallpaper = get_image(idle_screen_wallpaper_ID);
            cat33_n_frames = gui_image_n_frames(idle_screen_wallpaper);
            gdi_image_get_dimension(idle_screen_wallpaper, &cat33_image_width, &cat33_image_height);
            cat33_image_x = (disp_width - cat33_image_width) >> 1;
            cat33_image_y = (disp_height - cat33_image_height) >> 1;
            if (cat33_n_frames > 1)
        #if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
                gdi_image_draw_animation_frames(
                    cat33_image_x,
                    cat33_image_y,
                    idle_screen_wallpaper,
                    &animation_handle,
                    (S16) cat33_frame_number);
        #else /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
                gdi_image_draw_animation_single_frame(
                    cat33_image_x,
                    cat33_image_y,
                    idle_screen_wallpaper,
                    (S16) cat33_frame_number);
        #endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 
            else
            {
                gdi_image_draw(cat33_image_x, cat33_image_y, idle_screen_wallpaper);
            }
        }
    }
    #endif
}


#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
#if defined(__MMI_BT_DIALER_SUPPORT__) && !defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
#define WGUI_CAT033_MAX_SHORTCUTS_NUM   3
#else
#define WGUI_CAT033_MAX_SHORTCUTS_NUM   4
#endif


typedef struct
{
    S32 x;
    S32 y;
    S32 width;
    S32 height;
    MMI_BOOL is_pressed;
    FuncPtr entryfn;
} wgui_cat033_shortcut_struct;

static wgui_cat033_shortcut_struct g_wgui_cat033_shortcut[WGUI_CAT033_MAX_SHORTCUTS_NUM];
static S32 g_wgui_cat033_highlighted_shortcut_item;
static MMI_BOOL g_wgui_cat033_highlight_changed;
static MMI_BOOL g_wgui_cat033_setup_shortcut = MMI_FALSE;

/* when press shortcut, these entry functions will be executed */
#ifndef __COSMOS_MMI_PACKAGE__
extern void mmi_phb_entry_main_menu(void);
extern void EntryScrMessagesMenuList(void);
extern void EntryMainMenuFromIdleScreen(void);
#endif /* __COSMOS_MMI_PACKAGE__ */

extern void gui_sse_save_wallpaper(void);


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_get_mainmenu_area
 * DESCRIPTION
 *  get main menu area for SSE, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  x        [IN/OUT]     x position of main menu shortcut icon
 *  y        [IN/OUT]     y position of main menu shortcut icon
 *  w        [IN/OUT]     width of main menu shortcut icon
 *  h        [IN/OUT]     height of main menu shortcut icon
 * RETURNS
 *  MMI_BOOL
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF SHORTCUT IMAGE SEQUENCE
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_get_mainmenu_area(S32* x, S32* y, S32* w, S32* h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_setup_shortcut == MMI_TRUE)
    {
        *x = g_wgui_cat033_shortcut[0].x;
        *y = g_wgui_cat033_shortcut[0].y;
        *w = g_wgui_cat033_shortcut[0].width;
        *h = g_wgui_cat033_shortcut[0].height;
    }
    return g_wgui_cat033_setup_shortcut;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_clear_mainmenu_area
 * DESCRIPTION
 *  clear main menu area for SSE, PLEASE DO NOT USE ARBITRARILY
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF SHORTCUT IMAGE SEQUENCE
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_clear_mainmenu_area(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x = 0, y = 0, w = 0, h = 0;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = wgui_cat033_shortcut_get_mainmenu_area(&x, &y, &w, &h);
    if (ret == MMI_TRUE)
    {
        wgui_cat033_draw_region_with_background_color(x, y, x + w - 1, y + h - 1);
    }
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_display_shortcut_item
 * DESCRIPTION
 *  display individual shortcut item on touch idle screen according pressed status
 * PARAMETERS
 *  index        [IN]     idle screen shortcut
 *  is_pressed   [IN]     if pressed shortcut
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_display_shortcut_item(S32 shortcut_index, MMI_BOOL is_pressed)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(shortcut_index >= 0 && shortcut_index < WGUI_CAT033_MAX_SHORTCUTS_NUM);
    MMI_ASSERT((is_pressed == MMI_FALSE) || (is_pressed == MMI_TRUE));

    /* set shortcut information */
    g_wgui_cat033_shortcut[shortcut_index].is_pressed = is_pressed;    
    x1 = g_wgui_cat033_shortcut[shortcut_index].x;
    y1 = g_wgui_cat033_shortcut[shortcut_index].y;
    x2 = g_wgui_cat033_shortcut[shortcut_index].x + g_wgui_cat033_shortcut[shortcut_index].width - 1;
    y2 = g_wgui_cat033_shortcut[shortcut_index].y + g_wgui_cat033_shortcut[shortcut_index].height - 1;
    
    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);

    /* clear background */
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
#else /* __GDI_MEMORY_PROFILE_2__ */     
    draw_wallpaper();
#endif /* __GDI_MEMORY_PROFILE_2__ */ 

    /* show shortcut image */
    if (is_pressed == MMI_FALSE)
    {
    #if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + shortcut_index)));
    #elif defined(__MMI_BT_DIALER_SUPPORT__)
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_DIALING_SCREEN_SHORTCUT + shortcut_index)));
    #else
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + shortcut_index)));
    #endif  
    }
    else
    {
    #if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    //    gdi_image_draw_id_with_transparent_color(x1, y1, ((U16) (IMG_IDLE_MAINMENU_SHORCUT_PRESSED + shortcut_index)));    
    //    gdi_image_draw_id_with_transparent_color(x1, y1, ((U16) (IMG_IDLE_MAINMENU_SHORCUT + shortcut_index)));
    //   gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT_PRESSED + shortcut_index)));
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT_PRESSED + shortcut_index)));
        gdi_image_draw_resized(
            x1+2, 
            y1+2, 
            g_wgui_cat033_shortcut[shortcut_index].width - 4,
            g_wgui_cat033_shortcut[shortcut_index].height - 4,
            (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + shortcut_index)));
    #elif defined(__MMI_BT_DIALER_SUPPORT__)
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_DIALING_SCREEN_SHORTCUT_PRESSED + shortcut_index)));
    #else
        gui_show_image(x1, y1, (PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT_PRESSED + shortcut_index)));
    #endif
    }

    gui_pop_clip();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(x1, y1, x2, y2);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_display_shortcut
 * DESCRIPTION
 *  Draw touch screen shortcuts
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF IMAGE ID's
 *****************************************************************************/
static void wgui_cat033_display_shortcut(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, max_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        if (g_wgui_cat033_shortcut[i].is_pressed == MMI_TRUE)
        { 
            wgui_cat033_display_shortcut_item(i, MMI_TRUE);      
        }
        else
        {
            wgui_cat033_display_shortcut_item(i, MMI_FALSE);
        }
    }
    max_height = wgui_cat033_get_shortcut_max_height();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, UI_device_height - max_height, UI_device_width, UI_device_height);
}


#if defined(__MMI_BT_DIALER_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_bt_dialer
 * DESCRIPTION
 *  enter bt_dialer from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_bt_dialer(void)
{
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
    mmi_entry_bt_dialer_application_scr();
}
#endif


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_mainmenu
 * DESCRIPTION
 *  enter mainmenu from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_mainmenu(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* save wallpaper for SSE icon flip effect */
    gui_sse_save_wallpaper();
#ifndef __COSMOS_MMI_PACKAGE__

    EntryMainMenuFromIdleScreen();
#endif	
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    /* override default main menu SSE effect */
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_IDLE_SHORTCUT_TO_MAINMENU);
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_um
 * DESCRIPTION
 *  enter UM from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_um(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
    mmi_um_entry_main_message_menu();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_phb
 * DESCRIPTION
 *  enter PHB from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_phb(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
#ifndef __COSMOS_MMI_PACKAGE__
    mmi_phb_entry_main_menu();
#endif  /* __COSMOS_MMI_PACKAGE__*/
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_enter_dialer
 * DESCRIPTION
 *  enter dialer from touch shortcut of idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_enter_dialer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_FROM_IDLE_SHORTCUT);
    mmi_dialer_launch();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_setup_shortcut
 * DESCRIPTION
 *  Set up touch screen shortcuts
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 * REMARKS
 *  This routine is dependent on Order of Image Id's of Shortcut Item Images.
 *  DON'T CHANGE THE ORDER OF IMAGE ID's
 *****************************************************************************/
static void wgui_cat033_setup_shortcut(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width[WGUI_CAT033_MAX_SHORTCUTS_NUM], image_height[WGUI_CAT033_MAX_SHORTCUTS_NUM];
    S32 i, total_width = 0, x, x_margin;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
    #if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
        gui_measure_image((PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + i)), &image_width[i], &image_height[i]);
    #elif defined(__MMI_BT_DIALER_SUPPORT__)
        gui_measure_image((PU8) GetImage((U16) (IMG_IDLE_DIALING_SCREEN_SHORTCUT + i)), &image_width[i], &image_height[i]);
    #else
        gui_measure_image((PU8) GetImage((U16) (IMG_IDLE_MAINMENU_SHORCUT + i)), &image_width[i], &image_height[i]);
    #endif
        total_width += image_width[i];
        g_wgui_cat033_shortcut[i].height = image_height[i];
        g_wgui_cat033_shortcut[i].width = image_width[i];
        g_wgui_cat033_shortcut[i].is_pressed = MMI_FALSE;
    }

    MMI_ASSERT(total_width >= 0 && total_width <= UI_device_width);

    #if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    g_wgui_cat033_shortcut[g_wgui_cat033_highlighted_shortcut_item].is_pressed = MMI_TRUE;

    g_wgui_cat033_shortcut[0].entryfn = wgui_cat033_enter_mainmenu;
    g_wgui_cat033_shortcut[1].entryfn = wgui_cat033_enter_dialer;
    g_wgui_cat033_shortcut[2].entryfn = wgui_cat033_enter_phb;
    g_wgui_cat033_shortcut[3].entryfn = wgui_cat033_enter_bt_dialer;
    #else
    
    #if defined(__MMI_BT_DIALER_SUPPORT__) 
    g_wgui_cat033_shortcut[0].entryfn = wgui_cat033_enter_dialer;
    g_wgui_cat033_shortcut[1].entryfn = wgui_cat033_enter_phb;
    g_wgui_cat033_shortcut[2].entryfn = wgui_cat033_enter_bt_dialer;
    #else
    g_wgui_cat033_shortcut[0].entryfn = wgui_cat033_enter_mainmenu;
    g_wgui_cat033_shortcut[1].entryfn = wgui_cat033_enter_um;
    g_wgui_cat033_shortcut[2].entryfn = wgui_cat033_enter_phb;
    g_wgui_cat033_shortcut[3].entryfn = wgui_cat033_enter_dialer;
    #endif   
    #endif


    /* Margin between shortcut Images,Leave margin on front and back also */
    x_margin = (UI_device_width - total_width) / ((WGUI_CAT033_MAX_SHORTCUTS_NUM - 1) + 2);

    x = x_margin;

    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        g_wgui_cat033_shortcut[i].x = x;
        #if defined(__MMI_BT_DIALER_SUPPORT__)
		#ifdef __MMI_BT_BOX_IDLE_SHORTCUTS__
            g_wgui_cat033_shortcut[i].y = MMI_BT_BOX_IDLE_SHORTCUTS_Y;
		#else
            g_wgui_cat033_shortcut[i].y = UI_device_height - g_wgui_cat033_shortcut[i].height
                                  - MMI_BUTTON_BAR_HEIGHT;
		#endif
        #else
        g_wgui_cat033_shortcut[i].y = UI_device_height - g_wgui_cat033_shortcut[i].height;
        #endif
        x += g_wgui_cat033_shortcut[i].width + x_margin;
    }
    g_wgui_cat033_setup_shortcut = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_get_shortcut_max_height
 * DESCRIPTION
 *  Get the maximum height of idlescreen shortcut
 * PARAMETERS
 *  void
 * RETURNS
 *  S32 max_height 
 *****************************************************************************/
S32 wgui_cat033_get_shortcut_max_height(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, max_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* In case Image's are of different height, Find the maximum height image */
    max_height = g_wgui_cat033_shortcut[0].height;

    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        if (max_height < g_wgui_cat033_shortcut[i].height)
        {
            max_height = g_wgui_cat033_shortcut[i].height;
        }
    }
    return max_height;
}
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */ 

#ifdef __MMI_BT_BOX_IDLE_SHORTCUTS__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_translate_pen_position
 * DESCRIPTION
 *  This function finds index of shorcut item on which pen event came
 * PARAMETERS
 *  x           [IN]        Pen's x position
 *  y           [IN]        Pen's y position
 *  index       [OUT]       Index of selected item
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_shortcut_update_highlight_icon(MMI_BOOL isLeft)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    g_wgui_cat033_shortcut[g_wgui_cat033_highlighted_shortcut_item].is_pressed == MMI_FALSE;
    wgui_cat033_display_shortcut_item(g_wgui_cat033_highlighted_shortcut_item, MMI_FALSE);

    if(isLeft) //left
    {
        if(g_wgui_cat033_highlighted_shortcut_item == 0)
            g_wgui_cat033_highlighted_shortcut_item = WGUI_CAT033_MAX_SHORTCUTS_NUM - 1;
        else
            g_wgui_cat033_highlighted_shortcut_item --;
    }
    else  //right
    {
        g_wgui_cat033_highlighted_shortcut_item ++;
        g_wgui_cat033_highlighted_shortcut_item %= WGUI_CAT033_MAX_SHORTCUTS_NUM;
    }

    g_wgui_cat033_shortcut[g_wgui_cat033_highlighted_shortcut_item].is_pressed == MMI_TRUE;
    wgui_cat033_display_shortcut_item(g_wgui_cat033_highlighted_shortcut_item, MMI_TRUE);    
    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_left_key_handler
 * DESCRIPTION
 *  left key down handler when there are shortcuts
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
static void wgui_cat033_shortcut_left_key_handler()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(g_up_down_key_change_volume)
    {
        g_up_down_key_change_volume = MMI_FALSE;
        return;
    }
    wgui_cat033_shortcut_update_highlight_icon(MMI_TRUE);   
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_right_key_handler
 * DESCRIPTION
 *  right key down handler when there are shortcuts
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
static void wgui_cat033_shortcut_right_key_handler()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(g_up_down_key_change_volume)
    {
        g_up_down_key_change_volume = MMI_FALSE;
        return;
    }

    wgui_cat033_shortcut_update_highlight_icon(MMI_FALSE);         
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_entry_handler
 * DESCRIPTION
 *  up key or down key handler, enter shortcuts entryfunc.
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static void wgui_cat033_shortcut_entry_handler()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat033_shortcut[g_wgui_cat033_highlighted_shortcut_item].entryfn();
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_entry_handler
 * DESCRIPTION
 *  up key or down key longpress handler, start to change volum, icon highlight not change in this status.
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static void wgui_idle_up_key_long_press_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    g_up_down_key_change_volume = MMI_TRUE;
    
    SetKeyPadVolUp();
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_entry_handler
 * DESCRIPTION
 *  up key or down key longpress handler, start to change volum, icon highlight not change in this status.
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static void wgui_idle_down_key_long_press_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    g_up_down_key_change_volume = MMI_TRUE;
    
    SetKeyPadVolDown();
}


#endif /* __MMI_BT_BOX_IDLE_SHORTCUTS__ */ 


#ifdef __MMI_TOUCH_SCREEN__
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_translate_pen_position
 * DESCRIPTION
 *  This function finds index of shorcut item on which pen event came
 * PARAMETERS
 *  x           [IN]        Pen's x position
 *  y           [IN]        Pen's y position
 *  index       [OUT]       Index of selected item
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_shortcut_translate_pen_position(S32 x, S32 y, S32 *index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *index = -1;

    for (i = 0; i < WGUI_CAT033_MAX_SHORTCUTS_NUM; i++)
    {
        if (x >= g_wgui_cat033_shortcut[i].x && 
            x <= g_wgui_cat033_shortcut[i].x + g_wgui_cat033_shortcut[i].width &&
            y >= g_wgui_cat033_shortcut[i].y && 
            y <= g_wgui_cat033_shortcut[i].y + g_wgui_cat033_shortcut[i].height)
        {
            *index = i;
            break;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_pen_down_handler
 * DESCRIPTION
 *  pen down handler when there are touch shortcuts
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, y2;
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    y2 = UI_device_height;  /* N CASE IDLE SCREEN SHORTCUTS ARE DISPLAYED, BUTTON BAR IS NOT DISPLAYED */

    if (pos_x > 0 && pos_x < UI_device_width - 1 && pos_y > MMI_content_y && pos_y < y2)
    {
        S32 index;
        wgui_cat033_shortcut_translate_pen_position(pos_x, pos_y, &index);
        if (index >= 0 && index < WGUI_CAT033_MAX_SHORTCUTS_NUM)
        {
        #if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
            g_wgui_cat033_shortcut[g_wgui_cat033_highlighted_shortcut_item].is_pressed = MMI_FALSE;
            wgui_cat033_display_shortcut_item(g_wgui_cat033_highlighted_shortcut_item, MMI_FALSE);
        #endif
            g_wgui_cat033_highlighted_shortcut_item = index;
            g_wgui_cat033_highlight_changed = MMI_FALSE;
	        gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN_VIBRATE);
            wgui_cat033_display_shortcut_item(index, MMI_TRUE);
        }
        result = MMI_TRUE;
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_pen_up_handler
 * DESCRIPTION
 *  pen up handler when there are touch shortcuts
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, index;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_shortcut_translate_pen_position(pos_x, pos_y, &index);
    if (index >= 0 && index < WGUI_CAT033_MAX_SHORTCUTS_NUM)
    {
        wgui_cat033_display_shortcut_item(index, MMI_FALSE);
        if (g_wgui_cat033_highlight_changed == MMI_FALSE)
        {
            if ((g_wgui_cat033_shortcut[index].entryfn) != NULL)
            {
                g_wgui_cat033_shortcut[index].entryfn();
                
            #if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
                ret = MMI_TRUE;
            #endif
            }
        }
    }
#if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    if(!ret)  
    {
        for (index = 0; index < WGUI_CAT033_MAX_SHORTCUTS_NUM; index++)
        {
            if(g_wgui_cat033_highlighted_shortcut_item == index)          
            {
                g_wgui_cat033_shortcut[index].is_pressed = MMI_TRUE;
                wgui_cat033_display_shortcut_item(index, MMI_TRUE);
            }
            else
            {
                g_wgui_cat033_shortcut[index].is_pressed = MMI_FALSE;
            }
        }            
    }
#endif

    //ret = MMI_TRUE;    
    //return ret;
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_pen_move_handler
 * DESCRIPTION
 *  pen move handler when there are touch shortcuts
 * PARAMETERS
 *  point       [IN]       pen position 
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_shortcut_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y, index;
    MMI_BOOL ret = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_shortcut_translate_pen_position(pos_x, pos_y, &index);
    if (index != g_wgui_cat033_highlighted_shortcut_item)
    {
        g_wgui_cat033_highlight_changed = MMI_TRUE;
        /* Unpressed Image */
        wgui_cat033_display_shortcut_item(g_wgui_cat033_highlighted_shortcut_item, MMI_FALSE);
    }
    if (index >= 0 && index < WGUI_CAT033_MAX_SHORTCUTS_NUM)
    {
        g_wgui_cat033_highlighted_shortcut_item = index;
        /* Pressed Image */
        wgui_cat033_display_shortcut_item(index, MMI_TRUE);
    }
    ret = MMI_TRUE;

    return ret;
}
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_down_handler
 * DESCRIPTION
 *  pen down handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_down_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    S32 pos_x = point.x, pos_y = point.y, y2;
#endif
    S32 i = 0;
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)\
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_DOWN);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
#endif

#if defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
        /* shortcuts*/
	    if(!mmi_scr_locker_is_locked())	
	    {
            result = wgui_cat033_shortcut_pen_down_handler(point);
            if (result == MMI_TRUE);
            {
                break;
            }
	    }
#else /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
        /* no shortcuts */
        y2 = UI_device_height - 1 - MMI_button_bar_height;    
        if (pos_x > 0 && pos_x < UI_device_width - 1 && pos_y > MMI_content_y && pos_y < y2)
        {
            result = MMI_TRUE;
            break;
        }
#endif /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
    } while (0);
    
    return result;
}
#if defined(__MMI_SEARCH_WEB__)
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_shortcut_translate_pen_position
 * DESCRIPTION
 *  This function finds index of shorcut item on which pen event came
 * PARAMETERS
 *  x           [IN]        Pen's x position
 *  y           [IN]        Pen's y position
 *  index       [OUT]       Index of selected item
 * RETURNS
 *  void
 * REMARKS
 *  void
 *****************************************************************************/
static void wgui_cat033_translate_pen_position2(S32 x, S32 y, MMI_BOOL *result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *result = MMI_FALSE;

        if (x >= g_wgui_cat033_search.x && 
            x <= g_wgui_cat033_search.x + g_wgui_cat033_search.w &&
            y >= g_wgui_cat033_search.y && 
            y <= g_wgui_cat033_search.y + g_wgui_cat033_search.h)
        {
            *result = MMI_TRUE;
        }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_up_handler
 * DESCRIPTION
 *  pen up handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_up_handler2(mmi_pen_point_struct point)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	S32 pos_x = point.x, pos_y = point.y;
	MMI_BOOL result = MMI_FALSE;
	wgui_cat033_translate_pen_position2(pos_x, pos_y, &result);
	if((result == MMI_TRUE) && g_wgui_cat033_search.handler)
		{
			g_wgui_cat033_search.handler();
		}
	return result;		
}
#endif
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_long_tap_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
    S32 pos_x = point.x, pos_y = point.y;
#endif
    S32 i = 0;
    MMI_BOOL result = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//#ifndef __MMI_TOUCH_IDLESCREEN_SHORTCUTS__
#if !defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && !defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)

    if (mmi_scr_locker_is_locked() == MMI_FALSE && pos_x >= UI_device_width >> 2 &&
        pos_x <= UI_device_width - (UI_device_width << 2) && pos_y >= UI_device_height >> 2 &&
        pos_y <= UI_device_height - (MMI_button_bar_height >> 2))
    {
        result = MMI_TRUE;     
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_LONG_TAP);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
    } while (0);
#endif
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_repeat_handler
 * DESCRIPTION
 *  pen repeat handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_repeat_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = MMI_TRUE;
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_REPEAT);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
    } while (0);
#endif
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_abort_handler
 * DESCRIPTION
 *  pen abort handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_abort_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    do
    {
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_ABORT);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
    } while (0);
#endif
    
    return result;  
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_up_handler
 * DESCRIPTION
 *  pen up handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_up_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_UP);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
#endif

#if defined (__MMI_SEARCH_WEB__)
        if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
        {
		    result = wgui_cat033_pen_up_handler2(point);
		    if(result == MMI_TRUE)
			{
				break;
			}
        }
#endif
#if defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
        /* shortcuts */
        result = wgui_cat033_shortcut_pen_up_handler(point);
        if (result == MMI_TRUE);
        {
            break;
        }
#endif /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
    } while (0);
    
    return result;    
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_pen_move_handler
 * DESCRIPTION
 *  pen move handler for category33
 * PARAMETERS
 *  point       [IN]        pen position
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL wgui_cat033_pen_move_handler(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do
    {
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
        /* reminder */
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].pen_event_handler != NULL)
            {
                result = g_wgui_cat033_reminder[i].pen_event_handler(point, MMI_PEN_EVENT_MOVE);
                if (result == MMI_TRUE)
                {
                    break;
                }
            }
        }
#endif
#if defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
        /* shortcuts */
        result = wgui_cat033_shortcut_pen_move_handler(point);
        if (result == MMI_TRUE);
        {
            break;
        }
#endif /* defined (__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */
    } while (0);
    
    return result; 
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
/*****************************************************************************
 * FUNCTION
 *  show_boundries_to_status_bar_at_bottom_idlescreen
 * DESCRIPTION
 *  redraw status bar
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_boundries_to_status_bar_at_bottom_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c = gui_color(255, 255, 255);
    gui_draw_horizontal_line(0, UI_device_width - 1, UI_device_height - 1 - MMI_button_bar_height, c);
    gui_draw_horizontal_line(
        0,
        UI_device_width - 1,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height - 2,
        c);
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        gui_draw_horizontal_line(0, UI_device_width - 1, 0, c);
        
#ifdef __MMI_MAINLCD_128X128__
        gui_draw_horizontal_line(0, UI_device_width - 1, MMI_status_bar_height + 2, c);
#else 
        gui_draw_horizontal_line(0, UI_device_width - 1, MMI_status_bar_height, c);
#endif /* __MMI_MAINLCD_128X128__ */
	}
}
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 

#ifndef __MMI_PHNSET_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_cat33_get_cache_wallpaper_info
 * DESCRIPTION
 *  get cat33 cache wallpaper information, used after ShowCategory33Screen and before entering another new screen
 * PARAMETERS
 *  id                  [IN]    Current wallpaper id to determine whether to cache
 *  filename            [IN]    Current wallpaper filename to determine whether to cache
 *  wallpaper_layer     [OUT]   layer handle of wallpaper
 *  output_image_type   [OUT]   output image type (GDI image type)
 * RETURNS
 *  MMI_BOOL            whether to enable cache wallpaper mechanism
 *****************************************************************************/
MMI_BOOL mmi_cat33_get_cache_wallpaper_info (MMI_ID_TYPE id, CHAR * filename, GDI_HANDLE *wallpaper_layer, U16 *output_image_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_cache_image_type_enum cache_test = GUI_CACHE_IMAGE_NONE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 //   *wallpaper_layer = dm_get_wallpaper_layer();
    
    cache_test = gui_image_query_cache_type(id, filename);

    switch(cache_test)
    {
        case GUI_CACHE_IMAGE_PBM:
            *output_image_type = GDI_IMAGE_TYPE_DEVICE_BMP_FILE;
            break;
            
        case GUI_CACHE_IMAGE_JPG:
            *output_image_type = GDI_IMAGE_TYPE_JPG_FILE;
            break;
            
        default:
            return MMI_FALSE;
    }

    return MMI_TRUE;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_redraw
 * DESCRIPTION
 *  redraw category 33 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat033_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;
    
#ifdef __GDI_MEMORY_PROFILE_2__
    GDI_HANDLE wallpaper_layer;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#ifdef __GDI_MEMORY_PROFILE_2__
#if defined(__MMI_SWFLASH__) || defined(__MMI_AVATAR__)
    if (g_dm_data.s32CatId == MMI_CATEGORY34_ID)
    {
        wgui_cat033_set_text_abm_layer(GetSWFlashPlayerLayer());
    }
    else
#endif /* defined(__MMI_SWFLASH__) || defined(__MMI_AVATAR__) */
    {
    
        wgui_cat033_set_text_abm_layer(dm_get_wallpaper_layer());

    }
#endif
#ifndef __GDI_MEMORY_PROFILE_2__
    gui_cancel_timer(cat33_animation_processor);
#endif 

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    gui_push_clip();
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - 1);
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gui_pop_clip();
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
// VIJAYAN
#ifdef __MMI_MAINLCD_96X64__
if ((PhnsetGetShowDateTimeStatus()) && (!wgui_get_idle_screen_is_extra_text()))
#endif
{
    #ifdef __GDI_MEMORY_PROFILE_2__
        update_mainlcd_dt_display();
    #else /* __GDI_MEMORY_PROFILE_2__ */
        show_main_LCD_dt_display();
    #endif /* __GDI_MEMORY_PROFILE_2__ */
}
#ifndef __MMI_IDLE_FULL_SCREEN__
    idle_screen_hide_status_icons_bar0();
#endif /* __MMI_IDLE_FULL_SCREEN__ */
    in_idle_screen();
#ifdef __GDI_MEMORY_PROFILE_2__
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        wallpaper_layer);
#endif

    idle_screen_show_network_details();

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].show != NULL)    /* show */
        {
            g_wgui_cat033_reminder[i].show();
        }
    }
#endif

    on_idle_screen = 1;
    set_on_idlescreen(1);
    
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    show_boundries_to_status_bar_at_bottom_idlescreen();
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM_ */

#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    wgui_cat033_display_shortcut();
#endif /* defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) */ 
#if defined(__MMI_SEARCH_WEB__)
    if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
    {
    wgui_cat033_search_show();
    }
#endif
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        idle_screen_hide_status_icons_bar0);
#if !defined(__MMI_MAINLCD_320X480__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        idle_screen_hide_status_icons_bar1);
#endif
#endif
    wgui_status_icon_bar_update();

#if defined(ENABLE_ANIMATED_WALLPAPERS)
#ifndef __GDI_MEMORY_PROFILE_2__
    if (cat33_n_frames > 1 && idle_screen_wallpaper_ID != 0)
    {
        gui_start_timer(cat33_animation_delay, cat33_animation_processor);
    }
#endif /* __GDI_MEMORY_PROFILE_2__ */ 
#endif /* (ENABLE_ANIMATED_WALLPAPERS) */ 
}


/*****************************************************************************
 * FUNCTION
 *  dm_category_33_controlled_area
 * DESCRIPTION
 *  This function is used to draw the category controlled area of idle screen
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void dm_category_33_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    UI_UNUSED_PARAMETER(coordinate);
    wgui_cat033_redraw();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_lsk
 * DESCRIPTION
 *  category 33 hide left softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_lsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_draw_region_with_background_color(
        MMI_softkeys[MMI_LEFT_SOFTKEY].x,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y,
        MMI_softkeys[MMI_LEFT_SOFTKEY].x + MMI_softkeys[MMI_LEFT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_LEFT_SOFTKEY].y + MMI_softkeys[MMI_LEFT_SOFTKEY].height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_rsk
 * DESCRIPTION
 *  category 33 hide right softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_rsk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_draw_region_with_background_color(
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].x + MMI_softkeys[MMI_RIGHT_SOFTKEY].width - 1,
        MMI_softkeys[MMI_RIGHT_SOFTKEY].y + MMI_softkeys[MMI_RIGHT_SOFTKEY].height - 1);
}
#ifndef __MMI_WGUI_DISABLE_CSK__
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_hide_csk
 * DESCRIPTION
 *  category 33 hide center softkey
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_hide_csk(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat033_draw_region_with_background_color(
        MMI_softkeys[MMI_CENTER_SOFTKEY].x,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y,
        MMI_softkeys[MMI_CENTER_SOFTKEY].x + MMI_softkeys[MMI_CENTER_SOFTKEY].width - 1,
        MMI_softkeys[MMI_CENTER_SOFTKEY].y + MMI_softkeys[MMI_CENTER_SOFTKEY].height - 1);
}

#endif
/*****************************************************************************
 * FUNCTION
 *  ShowCategory33Screen_ext_int
 * DESCRIPTION
 *  Displays the Idle screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  right_softkey           [IN]        Right softkey label
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory33Screen_ext_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __MMI_UI_STATUS_BAR_AT_BOTTOM__
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    S32 status_bar1_y1;
    S32 status_bar1_y2;
#endif
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */
    S32 i = 0, history_size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    GDI_LOCK;
    gui_lock_double_buffer();

    on_idle_screen = 1;
    set_on_idlescreen(1);

#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    g_wgui_cat033_setup_shortcut = MMI_FALSE;
#endif

#ifdef __MMI_OP12_CAT533_SUPPORT__
	wgui_set_wallpaper_on_bottom(MMI_TRUE);
#endif /* __MMI_OP12_CAT533_SUPPORT__ */

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    /* init all reminder */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].init != NULL)    
        {
            g_wgui_cat033_reminder[i].init();

            /* set reminder history */
            if (history_buffer != NULL && g_wgui_cat033_reminder[i].set_history_function != NULL)
            {
                g_wgui_cat033_reminder[i].set_history_function(history_buffer + history_size);
                history_size += g_wgui_cat033_reminder[i].get_history_size_function();
            }        
        }
    }
#endif

#if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) 
    /* network name & network status on the same line */
    g_wgui_cat033_techno_current_text_type = NETWORK_NAME_TEXT_ON_IDLE;
    g_wgui_cat033_techno_scroll_count = 0;
    gui_start_timer(WGUI_CAT033_PAUSE_TIMER, wgui_cat033_techno_text_change_processor);
#endif /*defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)  */

#ifdef __MMI_IDLE_FULL_SCREEN__
  #if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
    disable_softkey_background();
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
  #endif /* __MMI_MAINLCD_128X128__ || __MMI_MAINLCD_128X160__ */
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 

    cat33_frame_number = 0;
    wgui_title_set_menu_shortcut_number(-1);

    /* No need to set the default handlers for Left and Right Softkeys in case of
       Idlescreen Shortcuts. So passing the value 0 for string ID and icon ID. */
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    change_left_softkey(0, 0);
    change_right_softkey(0, 0);
#else /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 
    change_left_softkey(left_softkey, 0);
    change_right_softkey(right_softkey, 0);
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 

#ifdef __MMI_FTE_SUPPORT__
	disable_softkey_background();
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
    set_softkey_flags_on(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
#endif

    SetupCategoryKeyHandlers();

    /* No need to register the hide functions for Left and Right Sofkeys
       when Idle Screen Shortcuts are present.   */
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    if(MMI_FALSE)
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
#ifndef __MMI_OP12_CAT533_SUPPORT__
        {
            register_hide_left_softkey(wgui_cat033_hide_lsk);
            register_hide_right_softkey(wgui_cat033_hide_rsk);
        #ifndef __MMI_WGUI_DISABLE_CSK__
            register_hide_softkey(wgui_cat033_hide_csk, MMI_CENTER_SOFTKEY);
        #endif
        }
#endif /* __MMI_OP12_CAT533_SUPPORT__ */
    }



    /* status bar 0 (horizontal status bar) */
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR,
        UI_dummy_function);
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 
                0,
        UI_device_height - 1 - MMI_button_bar_height - MMI_status_bar_height);
#else /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    /* status bar 0 is y center aligned in status bar area (status bar area = idle_y + status_bar_h + idle_y) */
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        0, 
        MMI_STATUS_BAR_IDLE_Y);
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);

    


    /* status bar 1 (vertical status bar) */
#if !defined(__MMI_MAINLCD_320X480__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        UI_dummy_function);
#endif

#if defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_V_BAR,
        UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
        MMI_status_bar_height + STATUS_ICON_Y_GAP);
    wgui_status_icon_bar_resize(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        MMI_IDLE_STRING_MARGIN_GAP, 
        UI_device_height - MMI_button_bar_height - (MMI_status_bar_height << 1) - (STATUS_ICON_Y_GAP << 1) - 1);
#endif
#else /* defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */

    /* y1 of vertical status bar */
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
  #ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__

    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        /* status bar 0 is y center aligned in status bar area (status bar area = idle_y + status_bar_h + idle_y) */
        status_bar1_y1 = MMI_STATUS_BAR_IDLE_Y + MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y + MMI_IDLESCREEN_BAR_HEIGHT;
    }
    else
    {
      #ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
      #else
        S32 max_region_height = (MMI_IDLESCREEN_BAR_HEIGHT >> 1);
      #endif /* __MMI_DUAL_SIM_MASTER__ */
      
        status_bar1_y1 = MMI_STATUS_BAR_IDLE_Y + MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y + max_region_height;
    }
  #else
    {
        /* status bar 0 is y center aligned in status bar area (status bar area = idle_y + status_bar_h + idle_y) */
        status_bar1_y1 = MMI_STATUS_BAR_IDLE_Y + MMI_status_bar_height + MMI_STATUS_BAR_IDLE_Y;
    }
  #endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */


    /* y2 of vertical status bar */
  #if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    if (MMI_TRUE)
    {
        status_bar1_y2 = UI_device_height - WGUI_TOUCH_IDLESCREEN_SHORTCUTS_HEIGHT - 2;
    }
    else
  #elif defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__)
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_icon_shortcut_bar].state != cat33_reminder_area_state_deinit)
    {
        status_bar1_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - WGUI_IDLE_SCREEN_ICON_SHORTCUT_HEIGHT - 2;
    }
    else
  #elif defined(__MMI_OP01_DCD__)
    if (g_wgui_cat033_reminder[wgui_cat033_reminder_dcd].state != cat33_reminder_area_state_deinit)
    {
        status_bar1_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - MMI_IDLE_DCD_HEIGHT - 2;
    }
    else
  #endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
    {
        status_bar1_y2 = UI_device_height - MMI_BUTTON_BAR_HEIGHT - 2;
    }
#endif
  #ifdef __MMI_KLG__
  #ifdef WGUI_STATUS_ICON_SHOW_V_BAR
  wgui_status_icon_bar_move(
    WGUI_STATUS_ICON_BAR_V_BAR,
    UI_device_width - MMI_IDLE_STRING_MARGIN_GAP, 
    status_bar1_y1);
  wgui_status_icon_bar_resize(
    WGUI_STATUS_ICON_BAR_V_BAR,
    MMI_IDLE_STRING_MARGIN_GAP,
    (UI_device_height >> 1) - status_bar1_y1 - 1);
  #endif
  #else /* __MMI_KLG__ */
  #ifdef WGUI_STATUS_ICON_SHOW_V_BAR
  wgui_status_icon_bar_move(
    WGUI_STATUS_ICON_BAR_V_BAR,
    UI_device_width - MMI_IDLE_STRING_MARGIN_GAP,
    status_bar1_y1);
  wgui_status_icon_bar_resize(
    WGUI_STATUS_ICON_BAR_V_BAR,
    MMI_IDLE_STRING_MARGIN_GAP, 
    status_bar1_y2 - status_bar1_y1 + 1);
  #endif
  #endif /* __MMI_KLG__ */

#endif /* !defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */
    
#if !defined(__MMI_MAINLCD_128X64__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_V_BAR);
#endif
#endif

#endif /* __MMI_MAINLCD_320X480__ */


#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    /* clear the memory of touch_idle_shortcuts when the Flight Mode is ON. */
    if (MMI_TRUE)
    {
        wgui_cat033_setup_shortcut();
    }
    else
    {
        memset(g_wgui_cat033_shortcut, 0, sizeof(wgui_cat033_shortcut_struct) * WGUI_CAT033_MAX_SHORTCUTS_NUM);
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 


    switch (idle_screen_type)
    {
        case NORMAL_IDLE_SCREEN:
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
            set_main_LCD_dt_date_hide_function(wgui_cat033_draw_region_with_technobar);
            analog_clock_initialize();
            set_main_LCD_dt_time_hide_function(dummy_dt_hide_function);
            set_main_LCD_day_hide_function(wgui_cat033_draw_region_with_technobar);
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(wgui_cat033_hide_time_display);
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */ 

#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
			set_dt_display(DT_IDLE_SCREEN_NO_DAY);
            if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
            {
                wgui_cat033_techno_init_date();
            }
#else /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */
    #if defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) || (defined(__MMI_MAINLCD_320X240__) && !defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)) || defined(__MMI_MAINLCD_96X64__)
            set_dt_display(DT_IDLE_SCREEN_2);
    #else /* defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
            set_dt_display(DT_IDLE_SCREEN);
    #endif /* defined(__MMI_KLG__) || defined(__MMI_UI_STATUS_BAR_AT_BOTTOM__) */ 
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

            break;

#ifdef __MMI_ANALOG_CLOCK__
        case ANALOG_IDLE_SCREEN:
            analog_clock_initialize();
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_analog_clock_hide_dt_display);
            set_dt_display(DT_ANALOG_CLOCK_SC);
            break;
#endif /* __MMI_ANALOG_CLOCK__ */ 

#ifdef __MMI_DIGITAL_CLOCK__
        case DIGITAL_IDLE_SCREEN:
            set_main_LCD_dt_date_hide_function(dummy_dt_hide_function);
            set_main_LCD_dt_time_hide_function(cat33_digital_clock_hide_dt_display);
            set_dt_display(DT_DIGITAL_CLOCK_SC1);
            break;
#endif /* __MMI_DIGITAL_CLOCK__ */ 
    }

    gui_unlock_double_buffer();


#if defined (__MMI_TOUCH_SCREEN__)
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_down_handler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_repeat_handler, MMI_PEN_EVENT_REPEAT);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_long_tap_handler, MMI_PEN_EVENT_LONG_TAP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_up_handler, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_abort_handler, MMI_PEN_EVENT_ABORT);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat033_pen_move_handler, MMI_PEN_EVENT_MOVE);
#endif /* (defined __MMI_TOUCH_SCREEN__) */ 
#ifdef __GDI_MEMORY_PROFILE_2__
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
#endif
    GDI_UNLOCK;

    /* register the custom SSE effect handler */
#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)    
   // gui_screen_switch_effect_register_custom_callback(wgui_category_sse_idle_custom_handler);
#endif
}


#ifdef __MMI_ALPHA_BLENDING__
#ifdef __GDI_MEMORY_PROFILE_2__
/*****************************************************************************
 * FUNCTION
 *  cat33_redraw_alpha_images
 * DESCRIPTION
 *  Redraw alpha images when wallpaper animation updates
 *  1. draw shortcuts
 *  2. draw techno bar and date time
 *  3. draw reminder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat33_redraw_alpha_images(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer;
    S32 i = 0;
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    GDI_HANDLE wallpaper_layer;
#endif
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_get_base_handle(&base_layer);
    gdi_layer_push_and_set_active(base_layer);

    // TODO: redraw only if images contain alpha
    
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) || defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    /* draw idle screen shortcuts */
    wgui_cat033_display_shortcut();
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */
/*
#if defined(__MMI_SEARCH_WEB__)
    if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
    {
    wgui_cat033_search_show();
    }
#endif
*/
#ifdef __MMI_UI_TECHNO_IDLESCREEN_BAR__
    /* draw techno idlescreen bar (including clock) */
    gui_push_clip();
    gui_set_clip(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + MMI_IDLESCREEN_BAR_HEIGHT - 1);
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE) /* no idlescreen bar when data and time is off */
    {
        gui_show_image(0, MMI_status_bar_height, get_image(idlescreen_bar_id));
    }
    gui_pop_clip();
    
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        wallpaper_layer);
    wgui_status_icon_bar_update();

    /* draw date & time */
#ifdef __GDI_MEMORY_PROFILE_2__
    update_mainlcd_dt_display();
#else /* __GDI_MEMORY_PROFILE_2__ */
    show_main_LCD_dt_display();
#endif /* __GDI_MEMORY_PROFILE_2__ */
#endif /* __MMI_UI_TECHNO_IDLESCREEN_BAR__ */

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    /* reminder */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].redraw != NULL)
        {
            g_wgui_cat033_reminder[i].redraw();
        }
    }
#endif

#ifdef __MMI_OP12_CAT533_SUPPORT__
    show_softkey_background();
    redraw_left_softkey();
    redraw_right_softkey();
    redraw_center_softkey();
#endif /* __MMI_OP12_CAT533_SUPPORT__ */

    g_wgui_cat033_redraw_scrolling_text = MMI_FALSE;
    idle_screen_show_network_details();
    g_wgui_cat033_redraw_scrolling_text = MMI_TRUE;

    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
}

#endif
#endif /* __MMI_ALPHA_BLENDING__ */

#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
/*****************************************************************************
 * FUNCTION
 *  wgui_cat033_dual_sim_text_change_processor
 * DESCRIPTION
 *  dual SIM show at same posotion
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat033_dual_sim_text_change_processor(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_wgui_cat033_dual_sim_current_text_type == SIM1_TEXT_ON_IDLE)
    {
        g_wgui_cat033_dual_sim_current_text_type = SIM2_TEXT_ON_IDLE;
    }
    else
    {
        g_wgui_cat033_dual_sim_current_text_type = SIM1_TEXT_ON_IDLE;
    }
    gui_start_timer(5000, wgui_cat033_dual_sim_text_change_processor);
    idle_screen_show_network_details();
}
#endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */


/*****************************************************************************
 * FUNCTION
 *  GetCategory33HistorySize
 * DESCRIPTION
 *  Gets the history buffer size of category 33
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory33HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size = 0, i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].init != NULL && g_wgui_cat033_reminder[i].get_history_size_function != NULL)
        {
            size += (g_wgui_cat033_reminder[i].get_history_size_function());
        } 
    }
#endif
    return size;
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory33History
 * DESCRIPTION
 *  Gets the history buffer of category33
 * PARAMETERS
 *  history_buffer      [OUT]        Is the buffer into which the history data is stored
 * RETURNS
 *  return history buffer
 *****************************************************************************/
U8 *GetCategory33History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0, size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    if (history_buffer != NULL)
    {
        for (i = 0; i < wgui_cat033_reminder_total; i++)
        {
            if (g_wgui_cat033_reminder[i].init != NULL && g_wgui_cat033_reminder[i].get_history_function != NULL)
            {
                g_wgui_cat033_reminder[i].get_history_function(history_buffer + size);
                size += g_wgui_cat033_reminder[i].get_history_size_function();
            }
        }
    }
#endif
    return (history_buffer);
}


#if 0// defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0
#endif

/*****************************************************************************
 * FUNCTION
 *  ShowCategory33Screen
 * DESCRIPTION
 *  Show category 33 screen
 * PARAMETERS
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the Left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory33Screen_int(
        U16 left_softkey,
        U16 right_softkey,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    g_wgui_cat033_dual_sim_current_text_type = SIM1_TEXT_ON_IDLE;
    gui_start_timer(5000, wgui_cat033_dual_sim_text_change_processor);
#endif /* defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) */

#ifdef __GDI_MEMORY_PROFILE_2__
#ifdef __MMI_ALPHA_BLENDING__    
    dm_register_wallpaper_anim_update_callback(cat33_redraw_alpha_images);
#endif /* __MMI_ALPHA_BLENDING__ */
#endif
    ShowCategory33Screen_ext_int(
        left_softkey,
        right_softkey,
        history_buffer);
#if defined(__MMI_BT_DIALER_SUPPORT__)
    enable_softkey_background();
#endif
    
    GDI_LOCK;

    dm_register_category_controlled_callback(dm_category_33_controlled_area);
    
    ExitCategoryFunction = ExitCategory33Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory33History, GetCategory33HistorySize);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY33_ID;
#ifdef __MMI_MAINLCD_96X64__
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
#else
    dm_data.s32flags = 0;
#endif
#if defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) 
    if (MMI_TRUE)
    {
        #if !defined(__MMI_BT_DIALER_SUPPORT__) 
        dm_data.s32flags |= DM_NO_SOFTKEY;
        #endif
    }
#endif /* __MMI_TOUCH_IDLESCREEN_SHORTCUTS__ */ 

#if defined(__MMI_BT_BOX_IDLE_SHORTCUTS__)
    dm_data.s32flags |= DM_NO_SOFTKEY;

    SetKeyHandler(wgui_cat033_shortcut_entry_handler, KEY_LSK, KEY_EVENT_DOWN);
//    SetKeyHandler(wgui_cat033_shortcut_entry_handler, KEY_RSK, KEY_EVENT_DOWN);
    SetKeyHandler(wgui_cat033_shortcut_left_key_handler, KEY_UP_ARROW, KEY_EVENT_UP); //KEY_EVENT_DOWN
    SetKeyHandler(wgui_cat033_shortcut_right_key_handler, KEY_DOWN_ARROW, KEY_EVENT_UP); //KEY_EVENT_DOWN
    
    SetKeyHandler(wgui_idle_up_key_long_press_handler, KEY_UP_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(SetKeyPadVolUp, KEY_UP_ARROW, KEY_REPEAT);
    SetKeyHandler(wgui_idle_down_key_long_press_handler, KEY_DOWN_ARROW, KEY_LONG_PRESS);
    SetKeyHandler(SetKeyPadVolDown, KEY_DOWN_ARROW, KEY_REPEAT);
//    SetKeyHandler(power_off, KEY_RSK, KEY_LONG_PRESS);       
#endif

    dm_setup_data(&dm_data);
    dm_redraw_category_screen();

    GDI_UNLOCK;
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory33Screen
 * DESCRIPTION
 *  Exits the Idle screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory33Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_BT_DIALER_SUPPORT__)
    disable_softkey_background();
#endif

#if defined(__DUAL_SIM_IDLE_TEXT_AT_SAME_POSITION__) /* Dual SIM show at same position. */
    gui_cancel_timer(wgui_cat033_dual_sim_text_change_processor);
#endif
#if defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) 
    gui_cancel_timer(wgui_cat033_techno_text_change_processor);
    g_wgui_cat033_techno_scroll_count = 0;
    if (PhnsetGetShowDateTimeStatus() == MMI_TRUE)
    {
        wgui_clock_close(wgui_cat033_techno_clock_date);
        wgui_cat033_techno_clock_date = WGUI_CLOCK_INVALID_INDEX;
    }
#endif /* defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */

    leave_idle_screen();

    on_idle_screen = 0;
    set_on_idlescreen(0);

#if defined(__MMI_IDLE_SCREEN_ICON_SHORTCUT__) || defined(__MMI_CALENDAR_ON_IDLE_SCREEN__) || defined(__MMI_OP01_DCD__)
    /* reminder */
    for (i = 0; i < wgui_cat033_reminder_total; i++)
    {
        if (g_wgui_cat033_reminder[i].deinit != NULL)
        {
            g_wgui_cat033_reminder[i].deinit();
        }
        memset(&g_wgui_cat033_reminder[i], 0, sizeof(wgui_cat033_reminder_area_info));
    }
#endif

#if defined(__MMI_SEARCH_WEB__)
    gui_scrolling_text_stop(&g_search_tab_scroll_text);
    if(g_wgui_cat033_search.image != NULL || g_wgui_cat033_search.string != NULL)
    {
    memset(&g_wgui_cat033_search, 0, sizeof(wgui_cat033_search_area_info));
    }
#endif
    if (extra_scrolling_text_ptr)
    {
        gui_scrolling_text_stop(extra_scrolling_text_ptr);
        extra_scrolling_text_ptr = NULL;
    }

    extra_text_x1 = -1;
    extra_text_y1 = -1;
    extra_text_x2 = -1;
    extra_text_y2 = -1;

#if defined(__MMI_MAINLCD_96X64__) || defined(__MMI_BT_DIALER_SUPPORT__)
        gui_scrolling_text_stop(&g_network_names_scroll);
        memset(&g_network_names_scroll, 0, sizeof(g_network_names_scroll));
#endif

#ifdef __MMI_BT_DIALER_SUPPORT__
		gui_scrolling_text_stop(&g_bt_dialer_pairing_names_scroll);
		memset(&g_bt_dialer_pairing_names_scroll, 0, sizeof(g_bt_dialer_pairing_names_scroll));
#endif

#ifndef __GDI_MEMORY_PROFILE_2__
    gui_cancel_timer(cat33_animation_processor);
#endif
#if defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__)
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
        animation_handle = GDI_ERROR_HANDLE;
    }
#endif /* defined(ENABLE_ANIMATED_WALLPAPERS) && defined(__GDI_MEMORY_PROFILE_2__) */ 

#ifdef __GDI_MEMORY_PROFILE_2__
    /* reserve wallpaper layer content for multi-event screen */
    wgui_cat110_cache_status_bg(wgui_cat033_get_text_abm_layer());
#endif

    wgui_status_icon_bar_reset();

#if !defined(__MMI_MAINLCD_320X480__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        MMI_dummy_function);
#endif
#endif

    close_main_LCD_dt_display();
    reset_softkeys();
    enable_softkey_background();
#ifdef __MMI_UI_STATUS_BAR_AT_BOTTOM__
#if defined(__MMI_KLG__)
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        UI_device_width - 16,
        MMI_status_bar_height);
    wgui_status_icon_bar_resize(
        WGUI_STATUS_ICON_BAR_V_BAR,
        17,
        (UI_device_height >> 1) - MMI_status_bar_height + 1);
#endif
#else /* defined(__MMI_KLG__) */ 
#ifdef WGUI_STATUS_ICON_SHOW_V_BAR
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_V_BAR, 
        UI_device_width - 16,
        MMI_status_bar_height);
    wgui_status_icon_bar_resize(
        WGUI_STATUS_ICON_BAR_V_BAR,
        17,
        UI_device_height - MMI_status_bar_height - MMI_softkey_height - 1);
#endif
#endif /* defined(__MMI_KLG__) */ 
#endif /* __MMI_UI_STATUS_BAR_AT_BOTTOM__ */ 
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        0, 
        0);
#ifdef __GDI_MEMORY_PROFILE_2__
    wgui_cat033_reset_text_abm_layer();
#endif
    /* release DRM handler */
#ifdef __DRM_SUPPORT__
	if (consumer >= DRM_RESULT_OK)
	{
		DRM_stop_consume(consumer);
	}
#endif /* __DRM_SUPPORT__ */
#ifdef __MMI_IDLE_FULL_SCREEN__
  #if defined(__MMI_MAINLCD_128X128__) || defined(__MMI_MAINLCD_128X160__)
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
  #endif /* __MMI_MAINLCD_128X128__ || __MMI_MAINLCD_128X160__ */
#endif /* __MMI_IDLE_FULL_SCREEN__ */ 
#ifdef __MMI_FTE_SUPPORT__
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_LEFT_SOFTKEY);
        set_softkey_flags_off(UI_BUTTON_TEXT_WITH_BORDER, MMI_RIGHT_SOFTKEY);
#endif
}

#ifdef __GDI_MEMORY_PROFILE_2__
extern gdi_handle animation_handle;
#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_cat106_redraw
 * DESCRIPTION
 *  redraw category106 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat106_redraw(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 SScallbackID, n_frames = 0;    
    S32 img_width = 0, img_height = 0;
    S32 offset_x = 0, offset_y = 0;
    PU8 image;    
    U16 img_type;
    color c = gui_color(0, 0, 0);
    GDI_RESULT ret;
    gdi_handle handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    c.alpha = 100;

    gui_lock_double_buffer();
    gui_reset_clip();
    clear_screen();
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);
    if (ScreenSaverName == NULL) /* from resource */
    {
        wgui_show_animation();
    }
    else /* from file */
    {
        gdi_image_gif_get_frame_count_file((CHAR*) ScreenSaverName, &n_frames);
        gdi_image_get_dimension_file((CHAR*) ScreenSaverName, &img_width, &img_height);

        if (n_frames > 1)
        {
            ret = gdi_image_draw_animation_file(
                    (UI_device_width - img_width) >> 1,
                    (UI_device_height - img_height) >> 1,
                    (CHAR*) ScreenSaverName,
                    &handle);
        }
        else
        {
            /* The orignal implementation seems just to fill whole screen */
            if ((UI_device_width >= img_width) && (UI_device_height >= img_height))
            {
                /* align in the center */
                offset_x = (UI_device_width - img_width) >> 1;
                offset_y = (UI_device_height - img_height) >> 1;
                ret = gdi_image_draw_file(offset_x, offset_y, (CHAR *) ScreenSaverName);
            }
            else
            {
                img_type = gdi_image_get_type_from_file((CHAR *) ScreenSaverName);
                
                if (img_type == GDI_IMAGE_TYPE_JPG_FILE)
                {
                
                    S32 resized_offset_x;
                    S32 resized_offset_y;
                    S32 resized_width;
                    S32 resized_height;
                    
                    gdi_image_util_fit_bbox(
                        UI_device_width,
                        UI_device_height,
                        img_width,
                        img_height,
                        &resized_offset_x,
                        &resized_offset_y,
                        &resized_width,
                        &resized_height);
                    
                    ret = gdi_image_draw_resized_file(
                            resized_offset_x,
                            resized_offset_y,
                            resized_width,
                            resized_height,
                            (CHAR *) ScreenSaverName);
                }
                else
                {
                    ret = gdi_image_draw_file(offset_x, offset_y, (CHAR *) ScreenSaverName);
                }
            }
        }

        if (ret < 0 && ret != GDI_GIF_ERR_OUT_OF_CLIP_REGION && ret != GDI_BMP_ERR_OUT_OF_CLIP_REGION)
        {
            SScallbackID = PhnsetScreenSaverBadFileCallBack(0);
            image = (PU8)GetImage((U32)SScallbackID);
            gui_measure_image(image, &img_width, &img_height);

            /* align in center */
            gdi_image_draw_animation(
                (UI_device_width - img_width) >> 1,
                (UI_device_height - img_height) >> 1,
                image,
                &animation_handle);
        }
    }
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory106Screen
 * DESCRIPTION
 *  Exit category106 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory106Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (animation_handle != GDI_ERROR_HANDLE)
    {
        gdi_image_stop_animation(animation_handle);
    }
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory106Screen
 * DESCRIPTION
 *  Show category106 screen (an animated icon)
 * PARAMETERS
 *  icon_screensaver        [IN]        screen saver image ID
 *  filename                [IN]        screen saver image file path
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory106Screen(U16 icon_screensaver, U8 *filename, U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(history_buffer);

    entry_full_screen();
    gui_lock_double_buffer();
    clear_category_screen_key_handlers();
    screen_saver_type = NORMAL_SCREEN_SAVER;
    if (icon_screensaver != 0) /* from resource */
    {
        wgui_set_animation((UI_device_width >> 1), (UI_device_height >> 1), icon_screensaver);
        ScreenSaverName = NULL;
    }
    else /* from file */
    {
        ScreenSaverName = filename;
    }

    gui_unlock_double_buffer();
    ExitCategoryFunction = ExitCategory106Screen;
    dm_setup_category_functions(wgui_cat106_redraw, dummy_get_history, dummy_get_history_size);
    wgui_cat106_redraw();
}


#ifdef __MMI_LCD_PARTIAL_ON__

#if defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__)
#define WGUI_CAT161_X_GAP    (2)
#else 
#define WGUI_CAT161_X_GAP    (3)
#endif /* defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__) */

static UI_time g_wgui_cat161_time;
static S32 g_wgui_cat161_last_y_offset;

extern stFontAttribute wgui_dialer_box_f1;

/*****************************************************************************
 * FUNCTION
 *  Category161ChangeTime
 * DESCRIPTION
 *  change the time of category161 screen
 * PARAMETERS
 *  t       [IN]        Time
 * RETURNS
 *  void
 *****************************************************************************/
void Category161ChangeTime(UI_time *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_wgui_cat161_time = *t;
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory161Screen
 * DESCRIPTION
 *  Redraw category161 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory161Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;
    S32 twidth, theight;
    S32 y_round, partial_on_height = UI_LCD_PARTIAL_ON_HEIGHT;
    S32 x1, x2, y1, y2, y2_last = 0;
    S32 text_x;
    S32 icon_width, icon_height;
    int icon_index, num_icon_displayed;
    U8 timestr[64];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();

#if defined(BLACK_BACKLIGHT)
    c.r = c.g = c.b = 0;
#elif defined(BLUE_BACKLIGHT)
    c.r = c.g = 0;
    c.b = 255;
#elif defined(WHITE_BACKLIGHT)
    c.r = c.g = c.b = 255;
#else 
    c.r = c.g = c.b = 255;
#endif /* defined(BLACK_BACKLIGHT) */

    c.alpha = 100;

#ifndef WIN32
    if(!srv_backlight_is_lcd_sleep())
    {
    y_round = lcd_partial_display_align_line(MAIN_LCD);
    if (y_round > 1 && (partial_on_height % y_round) != 0)
    {
        partial_on_height += (y_round - (partial_on_height % y_round));
    }
    }
#endif /* WIN32 */ 
    y_round = UI_device_height / partial_on_height;

    x1 = 0;
    y1 = (g_wgui_cat161_time.nMin % y_round) * partial_on_height;
    x2 = UI_device_width - 1;
    y2 = y1 + partial_on_height - 1;
    if (g_wgui_cat161_last_y_offset >= 0 && g_wgui_cat161_last_y_offset != y1)
    {
        y2_last = g_wgui_cat161_last_y_offset + partial_on_height - 1;
    }

    /* Dialing font has only english characters */
    time_string(&g_wgui_cat161_time, (UI_string_type) timestr, DT_IDLE_SCREEN_ENGLISH_ONLY);

    gui_push_clip();
    gui_push_text_clip();

    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    gui_set_text_clip(0, 0, UI_device_width - 1, UI_device_height - 1);

    if (g_wgui_cat161_last_y_offset >= 0 && g_wgui_cat161_last_y_offset != y1)
    {
        gui_fill_rectangle(x1, g_wgui_cat161_last_y_offset, x2, y2_last, c); /* last time region */
    }
    gui_fill_rectangle(x1, y1, x2, y2, c); /* new region */

#if defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__)
    gui_set_font(&MMI_large_font);
#else /* defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__) */
    gui_set_font(&wgui_dialer_box_f1);
#endif /* defined(__MMI_MAINLCD_128X128__) || defined (__MMI_MAINLCD_128X160__) */

    gui_measure_string((UI_string_type) timestr, &twidth, &theight);
    text_x = (UI_device_width - twidth) >> 1;
    wgui_status_icon_bar_arrange_partial();
    if (wgui_status_icon_bar_partial_display_icon_number > 0)
    {
        gui_measure_image(get_image(wgui_status_icon_bar_get_icon_image_id(0)), &icon_width, &icon_height);
        if ((WGUI_CAT161_X_GAP + (icon_width + WGUI_CAT161_X_GAP) * wgui_status_icon_bar_partial_display_icon_number)
            * 2 + twidth > UI_device_width)
        {
            /* Do not center the text */
            num_icon_displayed = (UI_device_width - twidth - (WGUI_CAT161_X_GAP * 2)) / (icon_width + WGUI_CAT161_X_GAP);
            if (num_icon_displayed > wgui_status_icon_bar_partial_display_icon_number)
            {
                num_icon_displayed = wgui_status_icon_bar_partial_display_icon_number;
            }
            text_x = WGUI_CAT161_X_GAP + (icon_width + WGUI_CAT161_X_GAP) * num_icon_displayed;
        }
        else
        {
            text_x = (UI_device_width - twidth) >> 1;
            num_icon_displayed = wgui_status_icon_bar_partial_display_icon_number;
        }

        for (icon_index = 0; icon_index < num_icon_displayed; icon_index++)
        {
            if (icon_height > partial_on_height)
            {
                break;  /* Abnormal case */
            }

            gui_show_transparent_image(
                WGUI_CAT161_X_GAP + (WGUI_CAT161_X_GAP + icon_width) * icon_index,
                y1 + ((partial_on_height - icon_height) >> 1),
                get_image(wgui_status_icon_bar_get_icon_image_id(wgui_status_icon_bar_partial_list_display[icon_index])),
                0);
        }
    }

#if defined(BLACK_BACKLIGHT)
    gui_set_text_color(gui_color(255, 255, 255));
#else
    gui_set_text_color(gui_color(0, 0, 0));
#endif /* defined(BLACK_BACKLIGHT) */

    if (r2lMMIFlag)
    {
        gui_move_text_cursor((text_x + twidth - 1), y1 + ((partial_on_height - theight) >> 1));
    }
    else
    {
        gui_move_text_cursor(text_x, y1 + ((partial_on_height - theight) >> 1));
    }
    gui_print_text((UI_string_type) timestr);
    gui_set_font(&MMI_medium_font);

    gui_pop_text_clip();
    gui_pop_clip();

    gui_unlock_double_buffer();

    /* Try to reduce the BLT region in order to save computation power */
    if (g_wgui_cat161_last_y_offset == -1) /* First time */
    {
        gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
    }
    else
    {
        if (g_wgui_cat161_last_y_offset != y1)
        {
            gui_BLT_double_buffer(x1, g_wgui_cat161_last_y_offset, x2, y2_last);
        }
        gui_BLT_double_buffer(x1, y1, x2, y2);
    }
    g_wgui_cat161_last_y_offset = y1;

#ifndef WIN32
    lcd_partial_on(MAIN_LCD, y1, y2);
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory161Screen
 * DESCRIPTION
 *  Exit category161 screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory161Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef WIN32
    lcd_partial_off(MAIN_LCD);
#endif 
    /* Because partial display is text on white background,
       it looks weird if new popup comes and we don't clear background here. */
#if defined(BLACK_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_BLACK);
#elif defined(BLUE_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_BLUE);
#elif defined(WHITE_BACKLIGHT)
    gdi_layer_clear(GDI_COLOR_WHITE);
#else
    gdi_layer_clear(GDI_COLOR_WHITE);
#endif /* defined(BLACK_BACKLIGHT) */

    leave_full_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ShowCategory161Screen
 * DESCRIPTION
 *  Show category161 screen (time screen saver)
 * PARAMETERS
 *  t       [IN]        Time
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory161Screen(UI_time *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color c;

    g_wgui_cat161_time = *t;
    g_wgui_cat161_last_y_offset = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(BLACK_BACKLIGHT)
    c.r = c.g = c.b = 0;
#elif defined(BLUE_BACKLIGHT)
    c.r = c.g = 0;
    c.b = 255;
#elif defined(WHITE_BACKLIGHT)
    c.r = c.g = c.b = 255;
#else 
    c.r = c.g = c.b = 255;
#endif  /* defined(BLACK_BACKLIGHT) */

    c.alpha = 100;

    entry_full_screen();

    gui_lock_double_buffer();
    gui_push_clip();
    gui_set_clip(0, 0, UI_device_width - 1, UI_device_height - 1);
    
    /* Delay filling white until RedrawCategory161Screen. We do not redraw the whole screen for each update. */
    gui_fill_rectangle(0, 0, UI_device_width - 1, UI_device_height - 1, c);

    gui_pop_clip();
    gui_unlock_double_buffer();

    ExitCategoryFunction = ExitCategory161Screen;
    dm_setup_category_functions(RedrawCategory161Screen, dummy_get_history, dummy_get_history_size);

    RedrawCategory161Screen();
}
#endif /* __MMI_LCD_PARTIAL_ON__ */ 


#ifdef __MMI_UI_ANIMATED_TITLE_EFFECT__
/*****************************************************************************
 * FUNCTION
 *  show_network_detail_on_animated_highlighter_on_idlescreen
 * DESCRIPTION
 *  Handle title text on idlescreen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void show_network_detail_on_animated_highlighter_on_idlescreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    idle_screen_show_network_details();
}

#endif /* __MMI_UI_ANIMATED_TITLE_EFFECT__ */ 


#if defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__)
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __GDI_MEMORY_PROFILE_2__
/* under construction !*/
        #else /* __GDI_MEMORY_PROFILE_2__ */
/* under construction !*/
        #endif /* __GDI_MEMORY_PROFILE_2__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) && defined(__MMI_TOUCH_IDLESCREEN_SHORTCUTS__) && defined(__MMI_UI_TECHNO_IDLESCREEN_BAR__) */


#if defined(__MMI_LAUNCHER_APP_LIST__)

#define WGUI_CAT30_PLAY_BUTTON_BAR_SEQ (200)

#define WGUI_CAT30_LONG_PRESS_SIMULATION_INTERVAL (300)

static U32 wgui_cat30_clock_time = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat30_clock_date = WGUI_CLOCK_INVALID_INDEX;
static U32 wgui_cat30_clock_day = WGUI_CLOCK_INVALID_INDEX;

/*Icon Text Info coordinates macros */
#define WGUI_CAT30_ICON_TEXT_V_GAP (2)
#define WGUI_CAT30_ICON_H_MARGIN   (10)    
#define WGUI_CAT30_MAX_ICON_WIDTH  (20)
#define WGUI_CAT30_MIN_ICON_TEXT_H_GAP (2)


typedef struct _wgui_cat30_cntx_struct
{
    S32 date_time_bar_y;
    FuncPtr callback_to_app; 
    U16* unlock_bar_str;
    U16 *text_info1;
    PU8 icon_info1; 
    U16 *text_info2;
    PU8 icon_info2; 
    U16 *text_info3;
    PU8 icon_info3;
    U16 unlock_bar_image_index;
} wgui_cat30_cntx_struct;


wgui_cat30_cntx_struct wgui_cat30_cntx_obj;
static MMI_BOOL g_wgui_cat30_is_normal_exit = MMI_FALSE;


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_set_line_info 
 * DESCRIPTION
 *  Its sets the icon and text information for the lines
 * PARAMETERS
 *  index           [IN]    index of the line
 *  info_str        [IN]    information string
 *  info_img        [IN]    information image
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_set_line_info(S32 index, U16 * info_str, PU8 info_img)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(index)
    {
        case WGUI_CAT30_ICON_TEXT_INFO1:
        {
            wgui_cat30_cntx_obj.text_info1 = info_str;
            wgui_cat30_cntx_obj.icon_info1 = info_img;
            break;
        }
        case WGUI_CAT30_ICON_TEXT_INFO2:
        {
            wgui_cat30_cntx_obj.text_info2 = info_str;
            wgui_cat30_cntx_obj.icon_info2 = info_img;
            break;
        }
        case WGUI_CAT30_ICON_TEXT_INFO3:
        {
            wgui_cat30_cntx_obj.text_info3 = info_str;
            wgui_cat30_cntx_obj.icon_info3 = info_img;
            break;
        }
        default:
            MMI_ASSERT(0);
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_string 
 * DESCRIPTION
 *  Draw border text in given region
 *  If the string width is longer than giver region, it will show trancated text.
 * PARAMETERS
 *  string    :[IN]    string
 *  x1        :[IN]    start x
 *  y1        :[IN]    start y
 *  x2        :[IN]    end x
 *  y2        :[IN]    end y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_string(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2, color text_color, color border_color)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, w = 0, x = 0, y = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (string != NULL)
    {     
        gui_set_font(&MMI_medium_font);
        gui_set_text_border_color(border_color);
        gui_set_text_color(text_color);

        gui_measure_string(string, &string_w, &string_h);
        string_w += 2; /* border text */
        string_h += 2; /* border text */       
        
        gdi_layer_push_clip();
        gdi_layer_set_clip(x1, y1, x2, y2);
        #ifdef __GDI_MEMORY_PROFILE_2__
        gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);
        #endif  //__GDI_MEMORY_PROFILE_2__


        y = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) + 1 /* border text */;
        x = (r2lMMIFlag) ? (x2) : (x1);
        x += (r2lMMIFlag) ? (-1) : (1); 
        if (string_w < x2 - x1 + 1)
        {
            gui_move_text_cursor(x, y);
            gui_print_bordered_text(string);
        }
        else
        {
            w = x2 - x1 + 1;
            gui_print_truncated_borderd_text(x, y, w, string);
        }
        gdi_layer_pop_clip();
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_image
 * DESCRIPTION
 *  Draw image in the given position with vertically center alignment
  * PARAMETERS
 *  image     :[IN]    image
 *  x1        :[IN]    start x
 *  y1        :[IN]    start y
 *  h         :[IN]    height
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_image(U8* image, S32 x1, S32 y1, S32 h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_w = 0, img_h = 0;
    S32 y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_measure_image(image, &img_w, &img_h);
    y = y1 + ((h - img_h) >> 1);
    gui_show_image(x1, y, image);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_details 
 * DESCRIPTION
 *  Draw the displayed details of category30,
 *  It draw the icon txt information  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 str_x, str_y, str_h;
    S32 bk_image_w1 = 0, bk_image_h1 = 0;
    PU8 bk_image1 = NULL;
    PU8 bk_image2 = NULL;
    S32 bk_image_w2 = 0, bk_image_h2 = 0;
    S32 text_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image1 = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(bk_image1, &bk_image_w1, &bk_image_h1);
    bk_image2 = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image2, &bk_image_w2, &bk_image_h2);

    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              MMI_STATUS_BAR_HEIGHT + bk_image_h2,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - bk_image_h1 - 1);


    #ifdef __GDI_MEMORY_PROFILE_2__
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    /* clear all */
    gdi_draw_solid_rect(
              0, 
              MMI_STATUS_BAR_HEIGHT + bk_image_h2,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - bk_image_h1 - 1,
              GDI_COLOR_TRANSPARENT);
    #endif  //__GDI_MEMORY_PROFILE_2__

    str_x = WGUI_CAT30_ICON_H_MARGIN + WGUI_CAT30_MAX_ICON_WIDTH + WGUI_CAT30_MIN_ICON_TEXT_H_GAP;
    str_h = Get_CharDisplayHeightOfAllLangAndType(MMI_medium_font.size);
    str_y = MMI_STATUS_BAR_HEIGHT + bk_image_h2 + WGUI_CAT30_ICON_TEXT_V_GAP;
	/* draw info 1 */
	if (wgui_cat30_cntx_obj.text_info1 != NULL)
	{
        wgui_cat30_draw_image(wgui_cat30_cntx_obj.icon_info1, WGUI_CAT30_ICON_H_MARGIN, str_y, str_h);
        wgui_cat30_draw_string(
                      wgui_cat30_cntx_obj.text_info1, 
                      str_x,
                      str_y,
                      UI_device_width - WGUI_CAT30_ICON_H_MARGIN - 1,
                      str_y + str_h - 1,
					  gui_color(255, 255, 255),
					  gui_color(0, 0, 0));
        str_y += (str_h + WGUI_CAT30_ICON_TEXT_V_GAP);
	}

    /* draw info 2 */
    if (wgui_cat30_cntx_obj.text_info2 != NULL)
    {
        wgui_cat30_draw_image(wgui_cat30_cntx_obj.icon_info2, WGUI_CAT30_ICON_H_MARGIN, str_y, str_h);   
        wgui_cat30_draw_string(
                      wgui_cat30_cntx_obj.text_info2, 
                      str_x,
                      str_y,
                      UI_device_width - WGUI_CAT30_ICON_H_MARGIN - 1,
                      str_y + str_h - 1,
					  gui_color(255, 255, 255),
					  gui_color(0, 0, 0));
        str_y += (str_h + WGUI_CAT30_ICON_TEXT_V_GAP);

    }
    /* draw info 3 */
    if (wgui_cat30_cntx_obj.text_info3 != NULL)
    {
        wgui_cat30_draw_image(wgui_cat30_cntx_obj.icon_info3, WGUI_CAT30_ICON_H_MARGIN, str_y, str_h);   
        wgui_cat30_draw_string(
                      wgui_cat30_cntx_obj.text_info3, 
                      str_x,
                      str_y,
                      UI_device_width - WGUI_CAT30_ICON_H_MARGIN - 1,
                      str_y + str_h - 1,
					  gui_color(255, 255, 255),
					  gui_color(0, 0, 0));
    }
    #ifdef __GDI_MEMORY_PROFILE_2__
    gdi_pop_and_restore_alpha_blending_source_layer();
    #endif  //__GDI_MEMORY_PROFILE_2__
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_hide_date_time_bar 
 * DESCRIPTION
 *  Hide function for category 30 date time bar
 * PARAMETERS
 *  x1      : [IN] 
 *  y1      : [IN]
 *  x2      : [IN]
 *  y2      : [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_hide_date_time_bar(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 bk_image_y;
    PU8 bk_image =NULL;
    S32 text_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    bk_image_y = wgui_cat30_cntx_obj.date_time_bar_y;
    gui_push_clip();
    gui_set_clip(x1, y1, x2, y2);
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    gui_show_image(0, bk_image_y, bk_image); 
    gdi_pop_and_restore_alpha_blending_source_layer();
    gui_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_init_date_time_bar 
 * DESCRIPTION
 *  Init date time bar 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_init_date_time_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 time_x = 0, time_y = 0;
    S32 time_width = 0, time_height = 0;
    S32 date_x = 0, date_y = 0;
    S32 date_width = 0, date_height = 0;
    S32 day_x = 0, day_y = 0;
    S32 day_width = 0, day_height = 0; 
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    /* Time */
    wgui_clock_create(
        &wgui_cat30_clock_time,         
        0, 0, 0, 0,                             
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_TIME_IMAGE);   
    //wgui_clock_set_text_border_enable(wgui_cat30_clock_time, MMI_TRUE);
    //wgui_clock_set_time_text_border_color(wgui_cat30_clock_time, gui_color(0, 0, 0));
    //wgui_clock_set_time_text_color(wgui_cat30_clock_time, gui_color(255, 255, 255));
    //wgui_clock_set_time_text_font(wgui_cat30_clock_time, &MMI_large_font);
    wgui_clock_set_hide_function(wgui_cat30_clock_time, wgui_cat30_hide_date_time_bar);
    wgui_clock_measure_digital_clock(wgui_cat30_clock_time, &time_width, &time_height);
    //wgui_clock_measure_time_text(wgui_cat30_clock_time, &time_width, &time_height, &MMI_large_font);
    wgui_clock_resize(wgui_cat30_clock_time, time_width, time_height);
    wgui_clock_set_digital_align_type(wgui_cat30_clock_time, GUI_CLOCK_DIGITAL_ALIGN_CENTER);
    wgui_clock_set_abm_layer(wgui_cat30_clock_time, GDI_LAYER_MAIN_BASE_LAYER_HANDLE);

    /* Date */
    wgui_clock_create(
        &wgui_cat30_clock_date,          
        0, 0, 0, 0,                             
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DATE);  
    wgui_clock_set_text_border_enable(wgui_cat30_clock_date, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat30_clock_date, gui_color(0, 0, 0));
    wgui_clock_set_date_text_color(wgui_cat30_clock_date, gui_color(255, 255, 255));
    wgui_clock_set_date_text_font(wgui_cat30_clock_date, &MMI_medium_font);
    wgui_clock_set_hide_function(wgui_cat30_clock_date, wgui_cat30_hide_date_time_bar);
    wgui_clock_measure_date_text(wgui_cat30_clock_date, &date_width, &date_height, &MMI_medium_font);
    wgui_clock_resize(wgui_cat30_clock_date, date_width, date_height);
    wgui_clock_set_digital_align_type(wgui_cat30_clock_date, GUI_CLOCK_DIGITAL_ALIGN_CENTER);

    /* Day */
    wgui_clock_create(
        &wgui_cat30_clock_day,          
        0, 0, 0, 0,                             
        GUI_CLOCK_MAINLCD_TYPE_DIGITAL_DAY);  
    wgui_clock_set_text_border_enable(wgui_cat30_clock_day, MMI_TRUE);
    wgui_clock_set_date_text_border_color(wgui_cat30_clock_day, gui_color(0, 0, 0));
    wgui_clock_set_date_text_color(wgui_cat30_clock_day, gui_color(255, 255, 255));
    wgui_clock_set_date_text_font(wgui_cat30_clock_day, &MMI_medium_font);
    wgui_clock_set_hide_function(wgui_cat30_clock_day, wgui_cat30_hide_date_time_bar);
    wgui_clock_measure_date_text(wgui_cat30_clock_day, &day_width, &day_height, &MMI_medium_font);
    wgui_clock_resize(wgui_cat30_clock_day, day_width, day_height);
    wgui_clock_set_digital_align_type(wgui_cat30_clock_day, GUI_CLOCK_DIGITAL_ALIGN_CENTER);

    height_offset = bk_image_h - time_height - date_height;
    height_offset /= 3;
    time_y = MMI_STATUS_BAR_HEIGHT + height_offset;
    day_y = date_y = time_y + time_height + height_offset;
    time_x = ((UI_device_width - time_width)>>1);
    width_offset = UI_device_width - date_width - day_width;  
    width_offset /= 3;
    date_x = width_offset;
    day_x = date_x + width_offset + date_width;

    wgui_clock_move(wgui_cat30_clock_time, time_x, time_y);
    wgui_clock_move(wgui_cat30_clock_date, date_x, date_y);
    wgui_clock_move(wgui_cat30_clock_day, day_x, day_y);

    wgui_cat30_cntx_obj.date_time_bar_y = MMI_STATUS_BAR_HEIGHT;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_move_and_draw_date_time_bar 
 * DESCRIPTION
 *  It is to used by the SSE to show the expand effect
 * PARAMETERS
 *  x              : [IN] x coordinate for the date time bar
 *  y              : [IN] y coordinate for the date time bar
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_move_and_draw_date_time_bar(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 time_x = 0, time_y = 0;
    S32 time_width = 0, time_height = 0;
    S32 date_x = 0, date_y = 0;
    S32 date_width = 0, date_height = 0;
    S32 day_x = 0, day_y = 0;
    S32 day_width = 0, day_height = 0; 
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(x);
    close_status_icons();
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              (y < MMI_STATUS_BAR_HEIGHT) ? (MMI_STATUS_BAR_HEIGHT) : (y),
              MAIN_LCD_DEVICE_WIDTH - 1,
              MMI_STATUS_BAR_HEIGHT +  bk_image_h - 1);

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    /* Time */
    //wgui_clock_measure_time_text(wgui_cat30_clock_time, &time_width, &time_height, &MMI_large_font);
    wgui_clock_measure_digital_clock(wgui_cat30_clock_time, &time_width, &time_height);
    /* Date */
    wgui_clock_measure_date_text(wgui_cat30_clock_date, &date_width, &date_height, &MMI_medium_font);
    /* Day */
    wgui_clock_measure_date_text(wgui_cat30_clock_day, &day_width, &day_height, &MMI_medium_font);

    height_offset = bk_image_h - time_height - date_height;
    height_offset /= 3;
    time_y = y + height_offset;
    day_y = date_y = time_y + time_height + height_offset;
    time_x = ((UI_device_width - time_width)>>1);
    width_offset = UI_device_width - date_width - day_width;  
    width_offset /= 3;
    date_x = width_offset;
    day_x = date_x + width_offset + date_width;


    wgui_clock_move(wgui_cat30_clock_time, time_x, time_y);
    wgui_clock_move(wgui_cat30_clock_date, date_x, date_y);
    wgui_clock_move(wgui_cat30_clock_day, day_x, day_y);

    wgui_cat30_cntx_obj.date_time_bar_y = y;

    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    gui_show_image(0, y, bk_image); 
      /* display date time */
    wgui_clock_show_main_lcd();
    gdi_pop_and_restore_alpha_blending_source_layer();
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    //gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/* VIJAYAN*/

#if defined( __MMI_DUAL_SIM_MASTER__)  
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if !defined(__MMI_WLAN_FEATURES__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
static S32 wgui_cat030_show_techno_border_string_center_align(UI_string_type string, S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 string_w = 0, string_h = 0, x_pos = 0, y_pos = 0;
    GDI_HANDLE wallpaper_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __GDI_MEMORY_PROFILE_2__
    wallpaper_layer = wgui_cat033_get_text_abm_layer();
    #else
    wallpaper_layer = dm_get_wallpaper_layer();
    #endif
    
    /* get string information */
    gui_measure_string(string, &string_w, &string_h);
    string_w += 2;  /* border text */
    string_h += 2;  /* border text */
    
    y_pos = y1 + ((y2 - y1 + 1) >> 1) - (string_h >> 1) - 1;

    /* set alpha blending layer */
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    
    if (string_w < x2 - x1 + 1) /* full display */
    {
        x_pos = (r2lMMIFlag) ? x2 - (((x2 - x1)>>1) - (string_w>>1)) :  x1 + (((x2 - x1)>>1) - (string_w>>1));
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_move_text_cursor(x_pos, y_pos);
        gui_print_bordered_text(string);
    }
    else
    {
        x_pos = (r2lMMIFlag) ? (x2) : (x1);
        x_pos += (r2lMMIFlag) ? (-1) : (1); /* border text */
        y_pos += 1; /* border text */
        gui_print_truncated_borderd_text(x_pos, y_pos, x2 - x1 - 1, string);
    }

    gdi_pop_and_restore_alpha_blending_source_layer();
    
    return ((r2lMMIFlag) ? (x_pos + 1) : (x_pos - 1));
}



static MMI_BOOL wgui_cat030_show_network_name()
{
        /*----------------------------------------------------------------*/
        /* Local Variables                                                */
        /*----------------------------------------------------------------*/
        S32 clip_x1 = 0, clip_y1 = 0, clip_x2 = 0, clip_y2 = 0, clip_height = 0;
        S32 count = 0, region_y1 = 0, region_y2 = 0;
        S32 string_max_h = 0;// max_region_height = 0;
        MMI_BOOL is_display = MMI_FALSE;
        UI_string_type network_name = idle_screen_network_name;
        PU8 dual_sim_img = NULL;
        S32 img_width = 0, img_height = 0;
        UI_font_type network_name_font;
    
        /*----------------------------------------------------------------*/
        /* Code Body                                                      */
        /*----------------------------------------------------------------*/
      //  max_region_height = WGUI_CAT030_FANCY_NETWORK_HEIGHT;    
        network_name_font = gui_font_get_type(GUI_FONT_SIZE_IDLE_NETWORK_NAME);
#if defined( __MMI_DUAL_SIM_MASTER__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined( __MMI_DUAL_SIM_MASTER__) */
        if (network_name != NULL)
        {
            is_display = MMI_TRUE;
            
            /* set attribute */
            gui_set_font(network_name_font);        
            gui_set_text_color(*current_MMI_theme->idle_scr_network_name_color);
            gui_set_text_border_color(*current_MMI_theme->idle_scr_network_name_border_color);
            
            string_max_h = Get_CharDisplayHeightOfAllLangAndType(network_name_font->size);
            count = g_wgui_cat030_lock_network_scroll_count; /* scroll count */
            clip_height = string_max_h + 2;
            clip_x1 = 0;
            clip_x2 = UI_device_width - 1;
            clip_y1 = wgui_cat30_cntx_obj.date_time_bar_y + 10;
            clip_y2 = clip_y1 + clip_height - 1;
    
            gdi_layer_push_clip();
            gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
#if defined( __MMI_DUAL_SIM_MASTER__)            
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
            {
                wgui_cat030_show_techno_border_string_center_align(network_name, clip_x1, clip_y1, clip_x2, clip_y2);                
            }
            
            gdi_layer_pop_clip();
        }
        return is_display;
    }


    void idle_screen_show_lock_details()
    {
        #if defined( __MMI_DUAL_SIM_MASTER__)  
/* under construction !*/
        #endif
            wgui_cat030_show_network_name();
        #if defined( __MMI_DUAL_SIM_MASTER__)  
/* under construction !*/
        #endif
    }



/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_date_time_bar 
 * DESCRIPTION
 *  It is to used to simply draw the date time bar at the initial position
 * PARAMETERS
 *  void         
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_draw_date_time_bar(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              MMI_STATUS_BAR_HEIGHT,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MMI_STATUS_BAR_HEIGHT +  bk_image_h - 1);
    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    
    #ifdef __GDI_MEMORY_PROFILE_2__
    /* clear all */
    gdi_draw_solid_rect(
              0, 
              MMI_STATUS_BAR_HEIGHT,
              MAIN_LCD_DEVICE_WIDTH - 1,
              MMI_STATUS_BAR_HEIGHT +  bk_image_h - 1,
              GDI_COLOR_TRANSPARENT);
    #endif
    
    #if !defined(__FTE_NON_SLIM_RES__)
        gdi_image_draw_resized_id(0, MMI_STATUS_BAR_HEIGHT, MAIN_LCD_DEVICE_WIDTH, bk_image_h, IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG);
    #else
        gui_show_image(0, MMI_STATUS_BAR_HEIGHT, bk_image);   
    #endif
    /*VIJAYAN*/
    if(g_wgui_cat030_operator_on_fancy_lock_screen == 1)
    {
        idle_screen_show_lock_details();
    }
      /* display date time */
    wgui_clock_show_main_lcd();
    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_move_and_draw_unlock_bar 
 * DESCRIPTION
 *  It is to used by the SSE to show the expand effect
 * PARAMETERS
 *  x              : [IN] x coordinate for the unlock bar
 *  y              : [IN] y coordinate for the unlock bar
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_move_and_draw_unlock_bar(S32 x, S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;
    S32 button_x = 0, button_y = 0;
    S32 button_width = 0, button_height = 0; 
    PU8 button_image = NULL;
    S32 string_w = 0, string_h = 0;
    S32 string_x = 0, string_y = 0;
    S32 ml_x, ml_y;
    S32 ml_width, ml_height;
    S32 actual_width = 0, actual_height = 0;
    GDI_HANDLE wallpaper_layer = dm_get_wallpaper_layer();
    GDI_HANDLE active_layer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_active(&active_layer);

    UI_UNUSED_PARAMETER(x);
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    button_image = get_image((U16)(IMG_KEYPAD_LOCK_UNLOCK_BUTTON5));
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gui_measure_image(button_image, &button_width, &button_height);
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_and_set_active(GDI_LAYER_MAIN_BASE_LAYER_HANDLE);
    gdi_layer_push_clip();
    gdi_layer_set_clip(
              0, 
              (y > (MAIN_LCD_DEVICE_HEIGHT - bk_image_h)) ? (y) : (MAIN_LCD_DEVICE_HEIGHT - bk_image_h),
              MAIN_LCD_DEVICE_WIDTH - 1,
              MAIN_LCD_DEVICE_HEIGHT - 1);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);
    
    #if !defined(__FTE_NON_SLIM_RES__)
        gdi_image_draw_resized_id(0, y, MAIN_LCD_DEVICE_WIDTH, bk_image_h, IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);    
    #else
        gui_show_image(0, y, bk_image);
    #endif
    gdi_pop_and_restore_alpha_blending_source_layer();

    height_offset = ((bk_image_h - button_height)>>1);
    button_y = y + height_offset;
    width_offset = WGUI_CAT30_ICON_H_MARGIN;
    if (r2lMMIFlag)
    {
        button_x = UI_device_width - width_offset - button_width;
    }
    else
    {
        button_x = width_offset;  

    }

    gdi_push_and_set_alpha_blending_source_layer(active_layer);
    if(wgui_cat30_cntx_obj.unlock_bar_image_index <= 0)
    {
        gui_show_image(button_x,button_y, get_image((U16)(IMG_KEYPAD_LOCK_UNLOCK_BUTTON0)));    
    }
    else
    {
        gui_draw_image_with_alpha_transparent(button_image, button_x ,button_y, 255*(wgui_cat30_cntx_obj.unlock_bar_image_index)/5);
    }
    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_push_and_set_alpha_blending_source_layer(wallpaper_layer);

    ml_y = y + (WGUI_CAT30_ICON_TEXT_V_GAP * 3);
    ml_height = bk_image_h - (3 * WGUI_CAT30_ICON_TEXT_V_GAP); 
    ml_width = UI_device_width - button_width - (2* WGUI_CAT30_ICON_H_MARGIN) + 1;
    if (r2lMMIFlag)
    {
        ml_x = ((WGUI_CAT30_ICON_H_MARGIN)>>1);

    }
    else
    {
        ml_x = (button_x + button_width + ((WGUI_CAT30_ICON_H_MARGIN)>>1));
    }

    move_multiline_inputbox(ml_x, ml_y);
    resize_multiline_inputbox_fit(
        ml_width,
        ml_height,
        &actual_width,
        &actual_height);
    if(actual_height > ml_height)
    {
        wgui_inputs_ml_resize(actual_width, ml_height);
    }
    show_multiline_inputbox();

    gdi_pop_and_restore_alpha_blending_source_layer();

    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
    gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_draw_ctrl_area 
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_draw_ctrl_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 unlock_bg_image = NULL;
    S32 width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    UI_UNUSED_PARAMETER(coordinate);
    unlock_bg_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(unlock_bg_image, &width, &height);
    wgui_cat30_draw_date_time_bar();
    wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - height);
    wgui_cat30_draw_details();
    //show_status_icons();
    wgui_status_icon_bar_update();
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR, 
        idle_screen_hide_status_icons_bar0);

}



/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_update_details 
 * DESCRIPTION
 *
 *  This API is for application to update the icon, text info etc.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_update_details(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    /* draw details */
    wgui_cat30_draw_details();
    gdi_layer_unlock_frame_buffer();
    gdi_lcd_repaint_all();
}


#ifdef __MMI_ALPHA_BLENDING__
/*****************************************************************************
 * FUNCTION
 *  cat33_redraw_alpha_images
 * DESCRIPTION
 *  Redraw alpha images when wallpaper animation updates
 *  1. draw shortcuts
 *  2. draw techno bar and date time
 *  3. draw reminder
 * PARAMETERS
 *  void
 * RETURNS
 *  void    
 *****************************************************************************/
void wgui_cat30_redraw_alpha_images(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle base_layer;
    PU8 unlock_bg_image = NULL;
    S32 width, height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();
    gdi_layer_get_base_handle(&base_layer);
    gdi_layer_push_and_set_active(base_layer);
    wgui_cat30_draw_date_time_bar();
    unlock_bg_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(unlock_bg_image, &width, &height);
    wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - height);
    wgui_cat30_update_details();
    gdi_layer_pop_and_restore_active();
    gdi_layer_unlock_frame_buffer();
}

#endif /* __MMI_ALPHA_BLENDING__ */

/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_play_button_image_seq_and_exec_callback
 * DESCRIPTION
 *  It plays the button image sequence and executes the call back.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static void wgui_cat30_play_button_image_seq_and_exec_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    PU8 unlock_bg_image = NULL;
    S32 width, height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    unlock_bg_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    gui_measure_image(unlock_bg_image, &width, &height);
    if(wgui_cat30_cntx_obj.unlock_bar_image_index < 5)
    {
        wgui_cat30_cntx_obj.unlock_bar_image_index++;
        wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - height);
        gui_start_timer(WGUI_CAT30_PLAY_BUTTON_BAR_SEQ, wgui_cat30_play_button_image_seq_and_exec_callback);
    }
    else
    {
        gui_cancel_timer(wgui_cat30_play_button_image_seq_and_exec_callback);
        g_wgui_cat30_is_normal_exit = MMI_TRUE;
        wgui_cat30_cntx_obj.callback_to_app();
        g_wgui_cat30_is_normal_exit = MMI_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_pen_long_tap_handler
 * DESCRIPTION
 *  pen long tap handler for category30
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_long_press_simulation(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_cat30_play_button_image_seq_and_exec_callback();
}


static MMI_BOOL wgui_cat30_pen_down_handler(mmi_pen_point_struct point)
{
        /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 pos_x = point.x, pos_y = point.y;
    S32 button_x = 0, button_y = 0;
    S32 button_width = 0, button_height = 0; 
    PU8 button_image = NULL;
    PU8 bk_image = NULL;
    S32 bk_image_w = 0, bk_image_h = 0;
    S32 height_offset = 0;
    S32 width_offset = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bk_image = get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG);
    button_image = get_image((U16)(IMG_KEYPAD_LOCK_UNLOCK_BUTTON0));
    gui_measure_image(bk_image, &bk_image_w, &bk_image_h);
    gui_measure_image(button_image, &button_width, &button_height);
    height_offset = ((bk_image_h - button_height)>>1);
    button_y = UI_device_height - bk_image_h  + height_offset;
    width_offset = WGUI_CAT30_ICON_H_MARGIN;
    if(r2lMMIFlag)
    {
        button_x = UI_device_width - width_offset - button_width;
    }
    else
    {
        button_x = width_offset;  

    }
    if((pos_x >= button_x) && (pos_y >= button_y) && (pos_x <= (button_x + button_width - 1)) && (pos_y <= (button_y + button_height - 1)) )
    {
        gui_start_timer(WGUI_CAT30_LONG_PRESS_SIMULATION_INTERVAL, wgui_cat30_long_press_simulation);
        return MMI_TRUE; 
    }
    else
    {
        return MMI_FALSE;
    }
}

void wgui_cat30_key_down_handler(void)
{
    gui_start_timer(WGUI_CAT30_LONG_PRESS_SIMULATION_INTERVAL, wgui_cat30_long_press_simulation);
}

void wgui_cat30_key_up_handler(void)
{
    gui_cancel_timer(wgui_cat30_long_press_simulation);
}

static MMI_BOOL wgui_cat30_pen_up_handler(mmi_pen_point_struct point)
{
    gui_cancel_timer(wgui_cat30_long_press_simulation);
    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  wgui_category_sse_popup_effect_draw_frame
 * DESCRIPTION
 *  category 30 leaving SSE draw frame callback handler
 * PARAMETERS
 *  effect_type               [IN]  effect type
 *  current_frame_index       [IN]  current frame index
 *  total_frame_num           [IN]  total frame num
 * RETURNS
 *  MMI_FALSE if to stop the effect; otherwise, MMI_TRUE.
 *****************************************************************************/
static MMI_BOOL wgui_cat30_sse_leaving_effect_draw_frame(
                    gui_screen_switch_effect_type_enum effect_type,
                    S32 current_frame_index,
                    S32 total_frame_num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 img_w, img_h;
    S32 h1, h2, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    /* clear the content area in 1st frame */
    if (current_frame_index == 0)
    {
        gdi_draw_solid_rect(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);
    }

    /* clear time bar */
    gui_measure_image(get_image(IMG_KEYPAD_LOCK_UNLOCK_TIME_BAR_BG), &img_w, &img_h);
    h1 = img_h * (total_frame_num + 1 - current_frame_index) / (total_frame_num);
    gdi_draw_solid_rect(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + h1 - 1, GDI_COLOR_TRANSPARENT);

    /* draw time bar */
    if (current_frame_index != total_frame_num - 1) /* do not draw the last frame */
    {
        h = img_h * (current_frame_index + 1) / (total_frame_num);
        wgui_cat30_move_and_draw_date_time_bar(0, MMI_status_bar_height - h);
    }

    /* clear unlock bar */
    gui_measure_image(get_image(IMG_KEYPAD_LOCK_UNLOCK_BAR_BG), &img_w, &img_h);
    h2 = img_h * (total_frame_num - current_frame_index) / (total_frame_num);
    gdi_draw_solid_rect(0, UI_device_height - h2, UI_device_width - 1, UI_device_height - 1, GDI_COLOR_TRANSPARENT);

    /* draw unlock bar */
    if (current_frame_index != total_frame_num - 1) /* do not draw the last frame */
    {
        h = img_h * (total_frame_num - current_frame_index - 1) / (total_frame_num);
        wgui_cat30_move_and_draw_unlock_bar(0, UI_device_height - h);
    }

    gdi_layer_unlock_frame_buffer();

    /* clear blt region */
    gdi_lcd_freeze(TRUE);
    gdi_layer_blt_previous(0, 0, 0, 0);
    gdi_lcd_freeze(FALSE);

    /* blt update region */
    if (current_frame_index == 0)
    {
        gdi_layer_blt_previous(0, MMI_status_bar_height, UI_device_width - 1, UI_device_height - 1);
    }
    else
    {
        gdi_layer_blt_previous(0, MMI_status_bar_height, UI_device_width - 1, MMI_status_bar_height + h1 - 1);
        gdi_layer_blt_previous(0, UI_device_height - h2, UI_device_width - 1, UI_device_height - 1);
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_sse_custom_handler
 * DESCRIPTION
 *  SSE handler for leaving effect
 * PARAMETERS
 *  stage_type  [IN] type
 *  param       [IN] parameters
 * RETURNS
 *  gui_screen_switch_effect_custom_return_code_enum
 *****************************************************************************/
static gui_screen_switch_effect_custom_return_code_enum wgui_cat30_sse_custom_handler(
                    gui_screen_switch_effect_stage_enum stage_type,
                    gui_screen_switch_effect_custom_param_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #define WGUI_CAT30_SSE_LEAVING_FRAMES   4

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (stage_type)
    {
        case GUI_SSE_STAGE_EXIT:
            if (g_wgui_cat30_is_normal_exit)
            {
                /* setup SSE */
                gui_screen_switch_effect_register_owner_draw_frame_callback(wgui_cat30_sse_leaving_effect_draw_frame);
                gui_screen_switch_effect_setup_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW1, WGUI_CAT30_SSE_LEAVING_FRAMES, GUI_SCREEN_SWITCH_EFFECT_TIMER_UNIT);
                gui_screen_switch_effect_run_effect(GUI_SCREEN_SWITCH_EEFECT_OWNER_DRAW1);
            }
            break;
    }

    return GUI_SSE_CUSTOM_RETURN_CODE_DEFAULT;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_exit 
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_cat30_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    close_status_icons();
    memset(&wgui_cat30_cntx_obj, 0, sizeof(wgui_cat30_cntx_obj));
    /* close date time component */
    wgui_clock_close(wgui_cat30_clock_date);
    wgui_clock_close(wgui_cat30_clock_time);
    wgui_clock_close(wgui_cat30_clock_day);
    wgui_cat30_clock_date = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat30_clock_time = WGUI_CLOCK_INVALID_INDEX;
    wgui_cat30_clock_day = WGUI_CLOCK_INVALID_INDEX;
    gui_cancel_timer(wgui_cat30_play_button_image_seq_and_exec_callback);
    gui_cancel_timer(wgui_cat30_long_press_simulation);
    on_idle_screen = 0;
    reset_multiline_inputbox();
    /* VIJAYAN*/
    if(g_wgui_cat030_operator_on_fancy_lock_screen == 1)
    {
#if defined( __MMI_DUAL_SIM_MASTER__)  
/* under construction !*/
#endif
		g_wgui_cat030_lock_network_scroll_count = 0;
        g_wgui_cat030_operator_on_fancy_lock_screen = 0;
    }
    
}

/*****************************************************************************
 * FUNCTION
 *  wgui_cat31_show
 * DESCRIPTION
 *  Show category 31 screen
 * PARAMETERS
 *  phone_unlock_str            [IN]      phone unlock string
 *  callback_to_app             [IN]        callback to APP on long press
 *  history_buffer              [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/

void wgui_cat31_show(UI_string_type phone_unlock_str,
                     FuncPtr callback_to_app,
                     U8 flag,
                     U8 *history_buffer)
{
    g_wgui_cat030_operator_on_fancy_lock_screen = flag;
    wgui_cat30_show(phone_unlock_str,
                    callback_to_app,
                    history_buffer);
}
/*****************************************************************************
 * FUNCTION
 *  wgui_cat30_show
 * DESCRIPTION
 *  Show category 30 screen
 * PARAMETERS
 *  phone_unlock_str            [IN]      phone unlock string
 *  callback_to_app             [IN]        callback to APP on long press
 *  history_buffer              [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_cat30_show(UI_string_type phone_unlock_str,
                     FuncPtr callback_to_app,
                     U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_SWITCH_EFFECT__)
    gui_screen_switch_effect_register_custom_callback(wgui_cat30_sse_custom_handler);
#endif /* defined(__MMI_SCREEN_SWITCH_EFFECT__) */

    on_idle_screen = 1;
    gdi_layer_lock_frame_buffer();
#ifdef __MMI_ALPHA_BLENDING__    
    dm_register_wallpaper_anim_update_callback(wgui_cat30_redraw_alpha_images);
#endif /* __MMI_ALPHA_BLENDING__ */
    change_left_softkey(0, 0);
    change_right_softkey(0, 0);
    SetupCategoryKeyHandlers();
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR,
        UI_dummy_function);
    wgui_status_icon_bar_move(
        WGUI_STATUS_ICON_BAR_H_BAR, 0, 0);
    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
    /* create date-time bar */
    wgui_cat30_init_date_time_bar();
    wgui_cat30_cntx_obj.unlock_bar_image_index = 0;
    wgui_cat30_cntx_obj.callback_to_app = callback_to_app;
    wgui_cat30_cntx_obj.unlock_bar_str = phone_unlock_str;
    l = gui_strlen(wgui_cat30_cntx_obj.unlock_bar_str);
    create_multiline_inputbox_set_buffer(wgui_cat30_cntx_obj.unlock_bar_str, l, l, 0);
	MMI_multiline_inputbox.normal_text_color = gui_color(255, 255, 255);
    MMI_multiline_inputbox.text_font = &MMI_medium_font;
    MMI_multiline_inputbox.border_color = gui_color(0, 0, 0);
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE;
    MMI_multiline_inputbox.ext_flags |= (GUI_MULTI_LINE_INPUT_BOX_USE_BORDER_FONT | GUI_MULTI_LINE_INPUT_BOX_SINGLE_BORDER);
	MMI_multiline_inputbox.text_x = 0;
    MMI_multiline_inputbox.text_y = 0;
    #if defined (__MMI_TOUCH_SCREEN__)
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat30_pen_down_handler, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(wgui_cat30_pen_up_handler, MMI_PEN_EVENT_UP);
    #endif /* (defined __MMI_TOUCH_SCREEN__) */ 
    gdi_layer_unlock_frame_buffer();
    ExitCategoryFunction = wgui_cat30_exit;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(wgui_cat30_draw_ctrl_area);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY30_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}

#endif /*defined (__MMI_FANCY_SCREEN_LOCK__)*/

