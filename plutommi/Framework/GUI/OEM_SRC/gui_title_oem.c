/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gui_title_oem.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  Extract the codes related drawing into this file for oem
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *     HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/


#include "MMI_features.h"
#include "gui_config.h"
#include "wgui.h"
#include "gui_title_pre_oem.h"
#include "gui_title.h"
#include "gui_title_post_oem.h"
#include "wgui_categories_util.h"

#include "MMIDataType.h"
#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gdi_include.h"
#include "gui.h"
#include "kal_general_types.h"
#include "CustDataRes.h"
#include "gui_switch.h"
#include "wgui_inputs.h"
#include "gui_menu_shortcut.h"
#include "gui_themes.h"
#include "gui_data_types.h"
#include "kal_public_api.h"
#include "DebugInitDef_Int.h"
#include "gui_windows.h"


#if 0//def __MMI_UI_TITLE_MINI_INDICATOR__
/* under construction !*/
#endif


/*****************************************************************************
 * Local Function
 *****************************************************************************/
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
static void gui_title_show_area1(gui_title_struct *t, U32 part);
static void gui_title_show_area2(gui_title_struct *t, U32 part);
#else/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
#define gui_title_show_area1(_arg1, _arg2) 
#define gui_title_show_area2(_arg1, _arg2) 
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
static void gui_title_show_text(gui_title_struct *t, U32 part);

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
static void gui_title_animate1_before_callback(GDI_RESULT result);
static void gui_title_animate2_before_callback(GDI_RESULT result);
static void gui_title_animate_after_callback(GDI_RESULT result);
#else/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
#define gui_title_animate1_before_callback 
#define gui_title_animate2_before_callback 
#define gui_title_animate_after_callback  
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

static gui_title_struct *current_title = NULL;

/*****************************************************************************
 * FUNCTION
 *  gui_title_setup_target_lcd_and_layer
 * DESCRIPTION
 *  set up title target lcd , target layer and alpha blend layer
 * PARAMETERS
 *  t       [IN]        Is the struct of title
 * RETURNS
 *  the old lcd handle
 *****************************************************************************/
gdi_handle gui_title_setup_target_lcd_and_layer(gui_title_struct *t)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_lcd_handle = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SUBLCD__  
    gdi_lcd_get_active (&old_lcd_handle);
    if(t->target_lcd == GDI_LCD_SUB_LCD_HANDLE && old_lcd_handle == GDI_LCD_MAIN_LCD_HANDLE)
    {
        UI_set_sub_LCD_graphics_context();
    }
    if(t->target_lcd == GDI_LCD_MAIN_LCD_HANDLE && old_lcd_handle == GDI_LCD_SUB_LCD_HANDLE)
    {
        UI_set_main_LCD_graphics_context();
    }
#endif/*__MMI_SUBLCD__*/	
    if(t->target_layer != GDI_NULL_HANDLE)
    {
        gdi_layer_push_and_set_active(t->target_layer);
    }
    if(t->alpha_blend_layer != GDI_NULL_HANDLE)
    {
        gdi_push_and_set_alpha_blending_source_layer(t->alpha_blend_layer);
    }
    return old_lcd_handle;
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_restore_target_lcd_and_layer
 * DESCRIPTION
 *  restore title target lcd , target layer and alpha blend layer
 * PARAMETERS
 *  t               [IN]        Is the struct of title
 *  old_lcd_handle  [IN]        the olcd lcd handle
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_restore_target_lcd_and_layer(
                gui_title_struct *t,
                gdi_handle old_lcd_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(t->alpha_blend_layer != GDI_NULL_HANDLE)
    {
        gdi_pop_and_restore_alpha_blending_source_layer();
    }
    if(t->target_layer != GDI_NULL_HANDLE)
    {
        gdi_layer_pop_and_restore_active();
    }
#ifdef __MMI_SUBLCD__	
    if(t->target_lcd == GDI_LCD_SUB_LCD_HANDLE && old_lcd_handle == GDI_LCD_MAIN_LCD_HANDLE)
    {
        UI_set_main_LCD_graphics_context();
    }
    if(t->target_lcd == GDI_LCD_MAIN_LCD_HANDLE && old_lcd_handle == GDI_LCD_SUB_LCD_HANDLE)
    {
        UI_set_sub_LCD_graphics_context();
    }
#endif/*__MMI_SUBLCD__*/	
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_oem_show_background
 * DESCRIPTION
 *  draw background of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 *  w       [IN]
 *  h       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_oem_show_background(
	gui_title_struct *t, 
	S32 x, 
	S32 y, 
	S32 w, 
	S32 h)
{
#ifdef __MMI_SUBLCD__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle old_lcd_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    old_lcd_handle = gui_title_setup_target_lcd_and_layer(t);
#endif/*__MMI_SUBLCD__*/
    gdi_layer_push_and_set_clip(x, y, x + w - 1, y + h - 1);

    if (t->hide_callback)
    {
        t->hide_callback(x, y, w, h);
    }
    else
    {
        /* modified to support wallpaper on bottom */
        if (!(t->style & GUI_TITLE_STYLE_DISABLEBG))
        {
            if (wgui_is_wallpaper_on_bottom())// == MMI_TRUE
            {
                gdi_draw_solid_rect(
					t->x, 
					t->y, 
					t->x + t->width - 1, 
					t->y + t->height - 1, 
					GDI_COLOR_TRANSPARENT);  /* 061705 Calvin added */
            }
            else
            {
                gdi_draw_solid_rect(
					t->x, 
					t->y, 
					t->x + t->width - 1, 
					t->y + t->height - 1, 
					GDI_COLOR_WHITE);        /* 090605 Title Calvin added */
            }
#if 0            
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif//0
         //   {
                gui_draw_filled_area(
                	t->x, 
                	t->y, 
                	t->x + t->width - 1, 
                	t->y + t->height - 1, 
                	t->active_filler);
           // }
        #if 0//def __MMI_UI_ANIMATED_TITLE_EFFECT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* __MMI_UI_ANIMATED_TITLE_EFFECT__ */
        }
        else
        {
            gdi_draw_solid_rect(
				t->x, 
				t->y, 
				t->x + t->width - 1, 
				t->y + t->height - 1, 
				GDI_COLOR_TRANSPARENT);
        }
    }
    gdi_layer_pop_clip();
#ifdef __MMI_SUBLCD__
    gui_title_restore_target_lcd_and_layer(t, old_lcd_handle);
#endif/*__MMI_SUBLCD__*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_measure_oem
 * DESCRIPTION
 *  restore title target lcd , target layer and alpha blend layer
 * PARAMETERS
 *  t               [IN]        Is the struct of title
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_measure_oem(
	gui_title_struct *t, 
	U32 part, 
	S32 *x1, 
	S32 *x2, 
	S32 *h)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width, height;
    S32 left_width, right_width;
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__		
    S32 gap;
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

#ifdef __MMI_SUBLCD__	
    gdi_handle active_lcd;
#endif/*__MMI_SUBLCD__*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    left_width = 1;
    right_width = 1;
#ifdef  MMI_SHOW_STATUS_ICON_IN_TITLE
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_SIGNAL_STRENGTH, &width, &height);
    left_width += width;
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
#endif/*__MMI_DUAL_SIM_MASTER__*/
    if (part == GUI_TITLE_PART_SIGNAL)
    {
        *x1 = t->x + 1;
        *x2 = *x1 + left_width - 1;
        *h = height;
        return;
    }
    
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_BATTERY_STRENGTH, &width, &height);
    right_width += width;
#ifdef __MMI_CALL_INDICATOR__
    #ifndef __MMI_DUAL_SIM_MASTER__
    if(!wgui_is_touch_title_bar_buttons())
    {
    #endif/*__MMI_DUAL_SIM_MASTER__*/
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_CALL_INDICATOR, &width, &height);
        right_width += width + STATUS_ICON_X_GAP;
    #ifndef __MMI_DUAL_SIM_MASTER__
    }
    #endif/*__MMI_DUAL_SIM_MASTER__*/
#endif  /* __MMI_CALL_INDICATOR__ */

#if 0//def __OP02__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifndef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #else /* __MMI_DUAL_SIM_MASTER__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_DUAL_SIM_MASTER__ */
/* under construction !*/
#endif /* __OP02__ */

    if (part == GUI_TITLE_PART_BATTERY)
    {
        *x2 = t->x + t->width - 1 - 1;
        *x1 = *x2 - right_width + 1;
        *h = height;
        return;
    }
#endif/*MMI_SHOW_STATUS_ICON_IN_TITLE*/

    width = 0;
    height = 0;
	
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if (t->icon != NULL)
    {
    #if defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)
        if (mmi_frm_is_screen_width_height_swapped() && t->height == MMI_THIN_TITLE_HEIGHT)
        {
            gap = GUI_TITLE_NON_ICON_GAP;
        }
        else
    #endif/*defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)*/
        {
            gdi_image_get_dimension((U8*) t->icon, &width, &height);
            if (width <= 0 || height <= 0)
            {
                gap = GUI_TITLE_NON_ICON_GAP;
            }
            else
            {
                gap = width + GUI_TITLE_ICON_GAP;
            }
        }
    }
    else
    {
        gap = GUI_TITLE_NON_ICON_GAP;
    }

    if (mmi_fe_get_r2l_state())
    {
       right_width += gap; 
    }
    else
    {
       left_width += gap;
    }

    if (part == GUI_TITLE_PART_ICON)
    {
        if (!mmi_fe_get_r2l_state())
        {
            *x1 = t->x + t->width - right_width;
            *x2 = *x1 + width - 1;
        }
        else
        {		
            *x2 = t->x + left_width - 1;
            *x1 = *x2 - width + 1;
        }
        *h = height;
        return;
    }

    width = 0;
    height = 0;
    if (t->no_icon_shct == MMI_FALSE)
    {
    #ifdef __MMI_TITLE_BAR_NO_ICON_SHCT__
        if (wgui_if_mini_tab_bar_enable())
        {
            gdi_image_get_dimension((U8*) get_image(RIGHT_RED_ARROW), &width, &height);
            gap = width + GUI_TITLE_ICON_GAP;
        }
        else
        {
            gap = GUI_TITLE_NON_ICON_GAP;
        }
    #else /* __MMI_TITLE_BAR_NO_ICON_SHCT__ */
        if (t->icon2 != NULL)
        {
            gdi_image_get_dimension((U8*) t->icon2, &width, &height);
            gap = width + GUI_TITLE_ICON_GAP;;
        }
        else
        {
			if (gui_shortcut_is_show(&t->sc))
			{
				width = gui_shortcut_get_width(&t->sc);
				gap = width + GUI_TITLE_NON_ICON_GAP + GUI_SHORTCUT_INSERT_GAP;
				if (!r2lMMIFlag)
				{
					gui_shortcut_move(&t->sc, t->x + t->width - right_width - width, t->sc.y);
				}
				else
				{
					gui_shortcut_move(&t->sc, t->x + left_width + GUI_TITLE_NON_ICON_GAP, t->sc.y);
				}
			}
			else
            	gap = GUI_TITLE_NON_ICON_GAP;
        }

    #endif /* __MMI_TITLE_BAR_NO_ICON_SHCT__ */
    }
    else if (t->icon2 != NULL)
    {
        gdi_image_get_dimension((U8*) t->icon2, &width, &height);
        gap = width + GUI_TITLE_ICON_GAP;
    }
    else if (gui_shortcut_is_show(&t->sc))
    {
        width = gui_shortcut_get_width(&t->sc);
        gap = width + GUI_TITLE_NON_ICON_GAP + GUI_SHORTCUT_INSERT_GAP;
        if (mmi_fe_get_r2l_state())
        {
        	gui_shortcut_move(&t->sc, t->x + left_width + GUI_TITLE_NON_ICON_GAP, t->sc.y);            
        }
        else
        {
	        gui_shortcut_move(&t->sc, t->x + t->width - right_width - width, t->sc.y);
        }
    }
    else
    {
        gap = GUI_TITLE_NON_ICON_GAP;
    }

    if (mmi_fe_get_r2l_state())
    {
        right_width += gap;
    }
    else
    {
        left_width += gap;
    }

    if (part == GUI_TITLE_PART_ICON2)
    {
        if (mmi_fe_get_r2l_state())
        {
            *x1 = t->x + t->width  - right_width;
            *x2 = *x1 + width - 1;
        }
        else
        {
            *x2 = t->x + left_width - 1;
            *x1 = *x2 - width + 1;
        }
        *h = height;
        return;
    }
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

#ifdef __MMI_SUBLCD__
    gdi_lcd_get_active(&active_lcd);
    if(active_lcd == GDI_LCD_SUB_LCD_HANDLE)
    {
        gui_set_font(&MMI_sublcd_font);
    }
    else
#endif/*__MMI_SUBLCD__*/		
    //{
        gui_set_font(t->normal_font);
    //}
    
    gui_measure_string((UI_string_type) t->text, &width, &height);
    /* all title text have border,so width add 2 */
    width += 2;
    if (width <= t->width - left_width - right_width && !(t->style & GUI_TITLE_STYLE_LEFTALIGN))
    {
        *x1 = t->x + left_width + ((t->width - left_width - right_width - width) >> 1);
        *x2 = *x1 + width - 1;
    }
    else// if (width > t->width - left_width - right_width)
    {
        *x1 = t->x + left_width - 1 + GUI_TITLE_TEXT_GAP + GUI_TITLE_ICON_GAP;
        *x2 = t->x + t->width - right_width - GUI_TITLE_TEXT_GAP - GUI_TITLE_ICON_GAP;
        // Add the gap for title border
        *x1 += 2;
        *x2 -= 2;
    }
    *h = height;
    MMI_ASSERT(part == GUI_TITLE_PART_TEXT);
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_show_scrolling_background
 * DESCRIPTION
 *  Fill the title bar with default color when text is scrolling
 * PARAMETERS
 *  x1      [IN]        Left-top x,y position of title bar
 *  y1      [IN]        Left-top x,y position of title bar
 *  x2      [IN]        Right-bottom x,y position of title bar
 *  y2      [IN]        Right-bottom x,y position of title bar
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_scrolling_background(S32 x1, S32 y1, S32 x2, S32 y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_oem_show_background(
    	g_current_title,//current_title 
    	x1, 
    	y1, 
    	x2 - x1 + 1, 
    	y2 - y1 + 1);
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_scrolling_timer_callback
 * DESCRIPTION
 *  scrolling title bat timer callback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_scrolling_timer_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_handle_scrolling_text(&g_current_title->scrolling_text);//current_title
}

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
/*****************************************************************************
 * FUNCTION
 *  gui_title_measure_area1
 * DESCRIPTION
 *  t->icon or leftarrow of mini tab bar
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  width       [IN/OUT]        Get the width of area1
 *  height      [IN/OUT]        Get the height of area1
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_measure_area1(gui_title_struct *t, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_ICON, &x1, &x2, height);
    if (mmi_fe_get_r2l_state())
    {
    	*width = t->x + t->width - x1;        
    }
    else
    {
        *width = x2 - t->x;
    }
}

/*****************************************************************************
 * FUNCTION
 *  gui_title_measure_area2
 * DESCRIPTION
 *  get the width of t->icon2 or t->sc or right arrow of mini tab bar
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  width       [IN/OUT]        Get the width of area2
 *  height      [IN/OUT]        Get the height of area2
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_measure_area2(gui_title_struct *t, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    gui_title_measure_oem(t, GUI_TITLE_PART_ICON2, &x1, &x2, height);
    if (mmi_fe_get_r2l_state())
    {
    	*width = x2 - t->x;     
    }
    else
    {
        *width = t->x + t->width - x1;
    }
}

/*****************************************************************************
 * FUNCTION
 *  gui_title_animate_before_callback
 * DESCRIPTION
 *  title animate draw before callback funciton, show the background and set alpha blending layer
 * PARAMETERS
 *  result       [IN/OUT]        result
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_animate1_before_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;
    S32 h;
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle active_layer;
#endif


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(
    	g_current_title, 
    	GUI_TITLE_PART_ICON, 
    	&x1, 
    	&x2, 
    	&h);//
    gui_title_oem_show_background(
		g_current_title, 
		x1, 
		g_current_title->y, 
		x2 - x1 + 1, 
		g_current_title->height);
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
    gdi_layer_get_active(&active_layer);
    gdi_push_and_set_alpha_blending_source_layer(active_layer);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_animate_before_callback
 * DESCRIPTION
 *  title animate draw before callback funciton, show the background and set alpha blending layer
 * PARAMETERS
 *  result       [IN/OUT]        result
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_animate2_before_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;
    S32 h;
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle active_layer;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(
    	g_current_title, 
    	GUI_TITLE_PART_ICON2, 
    	&x1, 
    	&x2, 
    	&h);

    gui_title_oem_show_background(
		g_current_title, 
		x1, 
		g_current_title->y, 
		x2 - x1 + 1, 
		g_current_title->height);

#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
    gdi_layer_get_active(&active_layer);
    gdi_push_and_set_alpha_blending_source_layer(active_layer);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_animate_after_callback
 * DESCRIPTION
 *  the animate draw after callback function, restore the alpha blend layer
 * PARAMETERS
 *  result       [IN/OUT]        Is the struct of title
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_animate_after_callback(GDI_RESULT result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif/*gui_title_animate_after_callback*/
}
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
/*****************************************************************************
 * FUNCTION
 *  gui_title_show_status_icon
 * DESCRIPTION
 *  draw icon of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_show_status_icon_oem(gui_title_struct *t)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 w, h;
    S32 width;
#ifdef __MMI_CALL_INDICATOR__
    S32 w1, h1;
#endif
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
#endif
    S32 x1, x2;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gui_title_measure_oem(t, GUI_TITLE_PART_SIGNAL, &x1, &x2, &h);
    gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    
    gdi_layer_set_clip(x1, t->y, x2, t->y + t->height - 1);
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_SIGNAL_STRENGTH, &w, &h);
    wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_SIGNAL_STRENGTH, t->x, t->y + t->height - h);
#ifdef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    gui_title_measure_oem(t, GUI_TITLE_PART_BATTERY, &x1, &x2, &h);
    gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    
    gdi_layer_set_clip(x1, t->y, x2, t->y + t->height - 1);
    wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_BATTERY_STRENGTH, &w, &h);
    width = w;
    wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_BATTERY_STRENGTH, t->x + t->width - width, t->y + t->height - h);
#ifdef __MMI_CALL_INDICATOR__
    #ifndef __MMI_DUAL_SIM_MASTER__
    if(wgui_is_touch_title_bar_buttons() == MMI_FALSE)
    {
    #endif
        wgui_status_icon_bar_get_integrated_icon_size(STATUS_ICON_CALL_INDICATOR, &w1, &h1);
        width += w1 + STATUS_ICON_X_GAP;
        wgui_status_icon_bar_show_integrated_icon(STATUS_ICON_CALL_INDICATOR, t->x + t->width - width + 1, t->y + t->height - h);
    #ifndef __MMI_DUAL_SIM_MASTER__
    }
    #endif
#endif /* __MMI_CALL_INDICATOR__ */

#if 0//def __OP02__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifndef __MMI_DUAL_SIM_MASTER__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #else /* __MMI_DUAL_SIM_MASTER__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __MMI_DUAL_SIM_MASTER__ */
/* under construction !*/
#endif /* __OP02__ */

    gdi_layer_pop_clip();
}
#endif /* MMI_SHOW_STATUS_ICON_IN_TITLE */

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
/*****************************************************************************
 * FUNCTION
 *  gui_title_show_area1
 * DESCRIPTION
 *  draw icon of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_area1(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle act_layer;
#endif/*__MMI_WALLPAPER_ON_BOTTOM__*/
    U16 image_type;
    S32 x1, x2, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_ICON, &x1, &x2, &h);
 //   gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, t->y, x2, t->y + t->height - 1);

    if (part != GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    }
    
    if (t->icon != NULL)
    {
        image_type = gdi_image_get_buf_type(t->icon);
        /* Set active layer as the abm source layer for png title icon*/
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_layer_get_active(&act_layer);
            gdi_push_and_set_alpha_blending_source_layer(act_layer);
        }
    #endif/*__MMI_WALLPAPER_ON_BOTTOM__*/

    #if defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)
        if (mmi_frm_is_screen_width_height_swapped() && t->height == MMI_THIN_TITLE_HEIGHT)
        {
        }
        else
    #endif/*defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)*/
        {
            if ((image_type != GDI_IMAGE_TYPE_GIF) && (image_type != GDI_IMAGE_TYPE_GIF_FILE))
            {
                gdi_anim_set_draw_before_callback(gui_title_animate1_before_callback);
                gdi_anim_set_draw_after_callback (gui_title_animate_after_callback);
            }
            gdi_image_draw_animation(x1, t->y + ((t->height - h) >> 1), (U8*) t->icon, &t->icon_ani_handle);
        }
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
    #endif/*__MMI_WALLPAPER_ON_BOTTOM__*/
    }
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_show_area2
 * DESCRIPTION
 *  draw icon of title
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x       [IN]
 *  y       [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_area2(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2;
    S32 h;
    U16 image_type;
#if defined(__MMI_WALLPAPER_ON_BOTTOM__)	
    gdi_handle act_layer;
#endif/*__MMI_WALLPAPER_ON_BOTTOM__*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_ICON2, &x1, &x2, &h);

    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, t->y, x2, t->y + t->height - 1);

    if (part != GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    }
	
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
  t->sc.display_disabled = t->no_icon_shct;
/*
    if (t->no_icon_shct == MMI_FALSE)
    {
        t->sc.display_disabled = MMI_TRUE;
    }
    else
    {
        t->sc.display_disabled = MMI_FALSE;
    }
*/
#if 0//def __MMI_WGUI_MINI_TAB_BAR__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
//#else
    if (t->icon2 != NULL)
    {
        image_type = gdi_image_get_buf_type(t->icon2);
        /* When show gif animate image, we can't register function to clear background,
         * Should set the right alpha blend layer here
         */
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_layer_get_active(&act_layer);
            gdi_push_and_set_alpha_blending_source_layer(act_layer);
        }
    #endif/*__MMI_WALLPAPER_ON_BOTTOM__*/

    #if defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)
        if (mmi_frm_is_screen_width_height_swapped() && t->height == MMI_THIN_TITLE_HEIGHT)
        {
        }
        else
    #endif/*defined(__MMI_SCREEN_ROTATE__) && defined(GUI_COMMON_USE_THICK_TITLE)*/
        {
            if ((image_type != GDI_IMAGE_TYPE_GIF) && (image_type != GDI_IMAGE_TYPE_GIF_FILE))
            {
                gdi_anim_set_draw_before_callback(gui_title_animate2_before_callback);
                gdi_anim_set_draw_after_callback (gui_title_animate_after_callback);
            }
            gdi_image_draw_animation(x1, t->y + ((t->height - h) >> 1), (U8*) t->icon2, &t->icon2_ani_handle);
        }
    #if defined(__MMI_WALLPAPER_ON_BOTTOM__)
        if ((image_type == GDI_IMAGE_TYPE_GIF) || (image_type == GDI_IMAGE_TYPE_GIF_FILE))
        {
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
    #endif/*__MMI_WALLPAPER_ON_BOTTOM__*/
    }
#endif /* __MMI_TITLE_BAR_NO_ICON_SHCT__ */
    
    gdi_layer_pop_clip();
}
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

/*****************************************************************************
 * FUNCTION
 *  gui_title_show_text
 * DESCRIPTION
 *  draw title text
 * PARAMETERS
 *  t       [IN/OUT]        Is the struct of title
 *  x1      [IN]
 *  y1      [IN]
 *  x2      [IN]
 *  y2      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_title_show_text(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef __MMI_SUBLCD__	
    gdi_handle active_lcd;
#endif/*__MMI_SUBLCD__*/
    S32 x1, x2, y;
    S32 h;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_measure_oem(t, GUI_TITLE_PART_TEXT, &x1, &x2, &h);
    y = t->y + ((t->height - h) >> 1);
    //gdi_layer_push_clip();
    gdi_layer_push_and_set_clip(x1, t->y, x2, t->y + t->height - 1);

    if (part != GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, x1, t->y, x2 - x1 + 1, t->height);
    }
#ifdef __MMI_SUBLCD__
    gdi_lcd_get_active(&active_lcd);
    if(active_lcd == GDI_LCD_SUB_LCD_HANDLE)
    {
        gui_set_font(&MMI_sublcd_font);
    }
    else
#endif/*__MMI_SUBLCD__*/
    //{
        gui_set_font(t->normal_font);
    //}

    gui_set_text_color(t->text_color);
    gui_set_text_border_color(t->text_border_color);

#if 0//def __MMI_UI_TITLE_TRANSITION__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __MMI_SCREEN_SWITCH_EFFECT__
/* under construction !*/
        #else
/* under construction !*/
        #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __MMI_SCREEN_SWITCH_EFFECT__
/* under construction !*/
        #else
/* under construction !*/
        #endif
/* under construction !*/
    #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
/* under construction !*/
    #else
/* under construction !*/
    #endif
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TITLE_TRANSITION__ */
    //{   
        if (t->style & GUI_TITLE_STYLE_SCROLLING)
        {
            gui_create_scrolling_text(
                &(t->scrolling_text),
                x1,
                t->y + ((t->height - h) >> 1),
                x2 - x1 + 1,
                h, 
                (UI_string_type)(t->text),
                gui_title_scrolling_timer_callback,
                gui_title_show_scrolling_background, 
                t->text_color,
                t->text_border_color);
#ifndef __MMI_FTE_SUPPORT__
            t->scrolling_text.flags |= UI_SCROLLING_TEXT_BORDERED_TEXT;
#endif
            gui_change_scrolling_text_font(&t->scrolling_text, t->normal_font);
            gui_show_scrolling_text(&t->scrolling_text);
        }
        else
        {
            if (mmi_fe_get_r2l_state())
            {
            #ifdef __MMI_SCREEN_SWITCH_EFFECT__
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x2 + t->offset_x - 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x2 + t->offset_x - 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #else
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x2 - 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x2 - 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #endif
            }
            else
            {			
            #ifdef __MMI_SCREEN_SWITCH_EFFECT__
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x1 + t->offset_x + 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x1 + t->offset_x + 1, y + t->offset_y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #else
                #if defined(__MMI_FTE_SUPPORT__) && defined(__MMI_VECTOR_FONT_SUPPORT__)
                gui_print_truncated_text(x1 + 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #else
                gui_print_truncated_borderd_text(x1 + 1, y, x2 - x1 + 1, (UI_string_type) t->text);
                #endif
            #endif
            }
        }
    //}
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_show_mini_inidcator
 * DESCRIPTION
 *  Draw title mini inidcator
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 * RETURNS
 *  void
 *****************************************************************************/
#if 0//def __MMI_UI_TITLE_MINI_INDICATOR__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TITLE_MINI_INDICATOR__ */


/*****************************************************************************
 * FUNCTION
 *  gui_title_oem_show_normal_ex
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  part        [IN]            the part to be redraw (icon, icon2, text, shortcut, all)
 * RETURNS
 *  void
 *****************************************************************************/
void gui_title_oem_show_normal_ex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_title_oem_show_normal(
    	g_current_title, 
    	GUI_TITLE_PART_SIGNAL | GUI_TITLE_PART_BATTERY);
#ifdef __MMI_VUI_ENGINE__
    if(current_title->venus_update_screen_callback)
    {
        current_title->venus_update_screen_callback(g_current_title->venus_update_screen_handle);
    }
    else
    {
#endif/*__MMI_VUI_ENGINE__*/
        gdi_layer_blt_previous(
            g_current_title->x,
            g_current_title->y,
            g_current_title->x + g_current_title->width - 1,
            g_current_title->y + g_current_title->height - 1);
#ifdef __MMI_VUI_ENGINE__
    }
#endif/*__MMI_VUI_ENGINE__*/
}


/*****************************************************************************
 * FUNCTION
 *  gui_title_oem_show_normal
 * DESCRIPTION
 *  draw title
 * PARAMETERS
 *  t           [IN/OUT]        Is the struct of title
 *  part        [IN]            the part to be redraw (icon, icon2, text, shortcut, all)
 * RETURNS
 *  void
 *****************************************************************************/
S32 gui_title_oem_show_normal(gui_title_struct *t, U32 part)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL bitblt = MMI_TRUE;
    gdi_handle old_lcd_handle;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//disable title icon in 96X64
#ifdef __MMI_MAINLCD_96X64__
	t->icon  = NULL;
#endif/*__MMI_MAINLCD_96X64__*/
    g_current_title = t;

    old_lcd_handle = gui_title_setup_target_lcd_and_layer(t);
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if ((part & GUI_TITLE_PART_ICON))// && (t->icon_ani_handle != GDI_ERROR_HANDLE))
    {
    	gui_stop_image_anim(t->icon_ani_handle);
//        gdi_image_stop_animation(t->icon_ani_handle);
//        t->icon_ani_handle = GDI_ERROR_HANDLE;
    }

    if ((part & GUI_TITLE_PART_ICON2))// && (t->icon2_ani_handle != GDI_ERROR_HANDLE))
    {
    	gui_stop_image_anim(t->icon2_ani_handle);
        //gdi_image_stop_animation(t->icon2_ani_handle);
        //t->icon2_ani_handle = GDI_ERROR_HANDLE;
    }
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    
#if 0//def __MMI_UI_TITLE_TRANSITION__
/* under construction !*/
#endif

    gui_lock_double_buffer();
    if (part == GUI_TITLE_PART_ALL)
    {
        gui_title_oem_show_background(t, t->x, t->y, t->width, t->height);
    }
#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    if (part & GUI_TITLE_PART_SIGNAL || part & GUI_TITLE_PART_BATTERY)
    {
        wgui_status_icon_bar_register_integrated_redraw(gui_title_oem_show_normal_ex);
        gui_title_show_status_icon_oem(t);
    }
#endif/*MMI_SHOW_STATUS_ICON_IN_TITLE*/

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if (part & GUI_TITLE_PART_ICON)
    {
        gui_title_show_area1(t, part);
    }

    if (part & GUI_TITLE_PART_ICON2)
    {
        gui_title_show_area2(t, part);
    }
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

    if (part & GUI_TITLE_PART_TEXT)
    {
        gui_title_show_text(t, part);
    }

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	

#if 0//def __MMI_UI_TITLE_TRANSITION__
/* under construction !*/
#endif
   // {
        if (t->icon2 == NULL && (part & GUI_TITLE_PART_SHORTCUT))
        {
            gui_shortcut_show(&t->sc);
        }
   // }
#endif

#if 0//def __MMI_UI_TITLE_MINI_INDICATOR__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_UI_TITLE_MINI_INDICATOR__ */

    gui_unlock_double_buffer();
    gui_title_restore_target_lcd_and_layer(t, old_lcd_handle);
    return bitblt;
}


