/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#define _FMGR_INTERNAL_SOURCE_C_
/****************************************************************************
* Include Files                                                                
*****************************************************************************/
#include "MMI_features.h"

#if defined (__MMI_FILE_MANAGER__)

#include "CommonScreens.h"
#include "ProtocolEvents.h"

#include "FileMgrGProt.h"
#include "FileMgrProt.h"
#include "FileMgrInstance.h"
#include "FileMgrGUI.h"
#include "FileMgrFSData.h"
#include "FileMgrService.h"
#include "FileMgrMain.h"

#include "FileMgrCuiGProt.h"

#ifdef __DRM_SUPPORT__                
#include "RightsMgrGProt.h"
#endif

#include "USBSrvGprot.h"

#if defined(__MMI_FMGR_MULTI_SELECT_SUPPORT__) && defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
#include "PictCuiGProt.h"
#endif

#include "MMIDataType.h"
#include "kal_general_types.h"
#include "string.h"
#include "custom_mmi_default_value.h"
#include "MMI_common_app_trc.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "mmi_common_app_trc.h"
#include "app_mem.h"
#include "mmi_rp_app_filemanager_def.h"
#include "kal_public_api.h"
#include "FileMgrSrvGProt.h"
#include "Unicodexdcl.h"
#include "wgui_categories_fmgr.h"
#include "fs_type.h"
#include "fs_func.h"
#include "GlobalConstants.h"
#include "wgui_categories_util.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_rp_file_type_def.h"
#include "gui_typedef.h"
#include "mmi_frm_input_gprot.h"
#include "GlobalResDef.h"
#include "mmi_rp_srv_filemanager_def.h"
#include "CustMenuRes.h"
#include "mmi_frm_history_gprot.h"
#include "CustDataRes.h"
#include "gui_data_types.h"
#include "mmi_res_range_def.h"
#include "mmi_frm_scenario_gprot.h"
#include "fs_errcode.h"
/****************************************************************************
* Define
*****************************************************************************/

/********************************* Setting **********************************/

#ifdef __MMI_VUI_3D_CUBE_APP_IMGVIEW__
    #define MMI_FMGR_FILELIST_MAX   3
#else /* __MMI_VUI_3D_CUBE_APP_IMGVIEW__ */
    #define MMI_FMGR_FILELIST_MAX   2
#endif /* __MMI_VUI_3D_CUBE_APP_IMGVIEW__ */

/********************************** Macro **********************************/


#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
#if (FMGR_MAX_MARK_ITEM > 128)
#error "If this value > 128, need adjust mmi_fmgr_service_msa_struct.count to S16"
#endif
#endif

/********************************* Enum ************************************/

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
typedef enum
{
    FMGR_MSA_ERROR_OK = 0,
    FMGR_MSA_ERROR_ALREADY_EXIST = -1,
    FMGR_MSA_ERROR_EXCEED_MAX = -2,
    FMGR_MSA_ERROR_NOT_FOUND = -3,

    FMGR_MSA_TOTAL

} fmgri_msa_enum;
#endif

/********************************* Typedef ********************************/

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
typedef struct _mmi_fmgr_service_msa_struct
{    
    S8  used;
    S8  count;
    U16 sort_option;
    U32 *size_array;
    U32 *time_array;
    S8  *name_array[FMGR_MAX_MARK_ITEM];
    S8  *flag_array;
} mmi_fmgr_service_msa_struct;

#else
typedef struct _mmi_fmgr_service_msa_struct
{
    S8  used;
    S8  count;
    U16 sort_option;
    U32 size_array[FMGR_MAX_MARK_ITEM];
    U32 time_array[FMGR_MAX_MARK_ITEM];
    S8  name_array[FMGR_MAX_MARK_ITEM][(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) * ENCODING_LENGTH];
    S8  flag_array[FMGR_MAX_MARK_ITEM];
} mmi_fmgr_service_msa_struct;
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__ */
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
typedef struct _mmi_fmgr_service_context_struct
{
    mmi_fmgr_service_msa_struct msa_buffer;
} mmi_fmgr_service_context_struct;
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */

typedef struct _mmi_fmgr_serv_browse_info_struct
{
    mmi_fmgr_browse_setting_struct  setting;
    U16                             basepath_len;
    U16                             link_opt_scr_id;

} mmi_fmgr_serv_browse_info_struct;

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
typedef struct {
    
    S32 msa_id;
    mmi_fmgri_multi_sel_close_callback callback;
	U16 action;
    U16 option_menu_id;
    U16 jpeg_count;
    U16 folder_count;
   
} mmi_fmgr_serv_multi_sel_info_struct;
#endif

/****************************************************************************
* Global Variable
*****************************************************************************/

/****************************************************************************
* Static Variable
*****************************************************************************/

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
static mmi_fmgr_service_context_struct g_fmgr_service_context;
static mmi_fmgr_service_context_struct* fmgr_serv_p = &g_fmgr_service_context;
#endif /* __MMI_FMGR_MULTI_SELECT_SUPPORT__ */

#if defined(__MMI_FMGR_MULTI_SELECT_SUPPORT__) && defined(__MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__)
static U8 *g_fmgr_msa_app_mem_ptr = NULL;
static U8 g_parent_instance_id = 0;
static U16 g_fmgr_msa_app_mem_action = 0;
#endif

/****************************************************************************
* Function Forward Declaration
*****************************************************************************/

#ifdef __DRM_V02__
static mmi_ret fmgr_archive_key_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type);
static void fmgr_archive_notify_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type, U32 data);
static BOOL fmgr_archive_error_hdlr(mmi_fmgr_instance_struct *instance, S32 error);
#endif
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
static mmi_ret fmgr_multi_sel_key_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type);
static void fmgr_multi_sel_notify_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type, U32 data);
static void fmgr_multi_sel_highlight_hdlr(mmi_fmgr_instance_struct *instance, S32 idx);
static MMI_BOOL fmgr_multi_sel_error_hdlr(mmi_fmgr_instance_struct *instance, S32 error);
static S32  fmgr_multi_sel_command_hdlr(mmi_fmgr_instance_struct *instance, S32 cmd, S32 para, void* data);
static mmi_ret fmgr_multi_sel_event_proc_handler(mmi_fmgr_instance_struct *instance, mmi_event_struct *param);

S32 mmi_fmgr_general_option_mul_sel_enabler(mmi_menu_id item_id, const WCHAR* filepath, const srv_fmgr_fileinfo_struct* fileinfo);
#endif

#ifdef __DRM_V02__
const mmi_fmgri_instance_callback_table_struct mmi_fmgri_serv_archive_table =
{
    fmgr_archive_key_event_hdlr,
    fmgr_archive_notify_event_hdlr,
    NULL,
    fmgr_archive_error_hdlr,
#ifdef __FMGR_HYPERLINK_SUPPORT__
    NULL,
#endif /* __FMGR_HYPERLINK_SUPPORT__ */
    NULL,
    NULL
};
#endif
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
const mmi_fmgri_instance_callback_table_struct mmi_fmgri_serv_multi_select_table = 
{
    fmgr_multi_sel_key_event_hdlr,
    fmgr_multi_sel_notify_event_hdlr,
    fmgr_multi_sel_highlight_hdlr,
    fmgr_multi_sel_error_hdlr,
#ifdef __FMGR_HYPERLINK_SUPPORT__
    NULL,
#endif /* __FMGR_HYPERLINK_SUPPORT__ */
    fmgr_multi_sel_command_hdlr,
    fmgr_multi_sel_event_proc_handler
};
#endif


// TODO: need to revise
extern void fmgr_main_copy_select_folder_done(mmi_fmgr_instance_struct *instance, cui_folder_selector_result_event_struct* evt);

#define END_OF_FUNCTION_DECLARATION

/****************************************************************************
* Function Body
*****************************************************************************/

void mmi_fmgri_service_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
    memset(&g_fmgr_service_context, 0, sizeof(g_fmgr_service_context));
#endif /*__MMI_FMGR_MULTI_SELECT_SUPPORT__ */
}

#if defined(__DRM_V02__)
#define ARCHIVE_INSTANCE

//mick todo
static U16 fmgr_archive_options_hdlr(U16 opt_menu_id, U16 menu_id, U32 data, U16 keyCode, FuncPtr hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct* instance;
    FMGR_FILE_INFO_STRUCT   file_info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(!menu_id)
        return 0;

    /* do general option first */
    if(mmi_fmgri_instance_general_option_handler(opt_menu_id, menu_id, data, keyCode) >= 0)
        return 0;

    /* setup file_info */
    instance = mmi_fmgri_get_instance_by_id((U8)data);

    switch(menu_id)
    {
    default:
        //mmi_fmgri_general_dispatch_file(instance, hdlr, TRUE);
        break;
    }
    return 0;
}

static mmi_ret fmgr_archive_key_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    S8 *buffer;
    U16 file_type, icon_id;
    mmi_fmgr_filetype_info_struct info;
    srv_fmgr_fileinfo_struct f_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);

    switch (event_type)
    {
        case FMGRI_EVENT_RSK:
        case FMGRI_EVENT_LEFT_ARROW:
            mmi_fmgri_instance_general_close(instance);
            break;

        case FMGRI_EVENT_LSK:
            /* Show option */
            buffer = mmi_fmgri_get_and_lock_buffer();
            if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1), instance->file_path, &file_info, MMI_FALSE))
            {
                FMGR_ASSERT(0);
            }
            file_type = srv_fmgr_types_get_main_type(&file_info.file_type);
            mmi_fmgr_get_filetype_info((U16)file_type, MMI_FMGR_FILETYPE_OPT_MENU, &info);
            f_info.type = srv_fmgr_types_get_main_type(&file_info.file_type);
            f_info.attribute = file_info.attribute;
            f_info.size = file_info.file_size;
            memcpy(&f_info.datetime, &file_info.time, sizeof(MYTIME));
            srv_fmgr_prepare_option_menu(info->option_menu_id, (WCHAR *)buffer, &f_info);
            mmi_fmgri_prepare_option(instance, info->option_menu_id, &file_info);
            mmi_fmgri_free_and_unlock_buffer(buffer);
            mmi_fmgri_instance_get_title_info(instance->id, NULL, &icon_id);
            mmi_fmgri_show_option(GRP_ID_ROOT, info.option_menu_id, fmgr_archive_options_hdlr, instance->id, icon_id);
            break;
    }

    return MMI_RET_OK;
}

static void fmgr_archive_notify_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type, U32 data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(event_type)
    {
        case FMGRI_EVENT_DRIVE_UNMOUNT:
            if (srv_fmgr_drv_is_accessible((U8)instance->file_path[0]) == MMI_TRUE)
            {
                break;
            }

            /* Cancel operation */
            mmi_fmgri_main_cancel_operation(instance);
        
            /* Close option */
            mmi_fmgri_close_options(instance->id);

            /* Remove instance */        
            mmi_fmgri_instance_general_close(instance);
            break;
    }
}

static MMI_BOOL fmgr_archive_error_hdlr(mmi_fmgr_instance_struct *instance, S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(error)
    {
        case MMI_FMGR_ERROR_EMPTY:
           /* Popup error */
            FMGR2_DisplayPopup(instance, STR_GLOBAL_EMPTY, MMI_EVENT_FAILURE);
            break;

    #ifdef __USB_IN_NORMAL_MODE__
        case MMI_FMGR_ERROR_USB_MODE:
            mmi_usb_app_unavailable_popup(0);
            break;
    #endif /* __USB_IN_NORMAL_MODE__ */

    default:
        /* Popup error */
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(error), MMI_EVENT_FAILURE);
    }

    mmi_fmgri_instance_general_close(instance);

    return MMI_FALSE;
}

U32 mmi_fmgri_open_archive(mmi_id parent_id, U16 app_id, S8* archive_filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_fmgri_main_get_async_fs_state() != FMGR_ACTION_NONE)
    {
        FMGR3_DisplayPopup(parent_id, FMGR_FS_DEVICE_BUSY_TEXT, MMI_EVENT_FAILURE);
        return 0;
    }

    mmi_frm_scrn_enter(parent_id, SCR_ID_FMGR_GENERAL_DUMMY, NULL, mmi_frm_display_dummy_screen_ex, MMI_FRM_FG_ONLY_SCRN);

    instance = mmi_fmgri_instance_create(parent_id, MMI_FMGR_TYPE_VIEW_ARCHIVE);
    
    if (!instance)
    {
        FMGR3_DisplayPopup(parent_id, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return 0;
    }

    /* Save releated information */
    instance->app_id = app_id;
    instance->type = MMI_FMGR_TYPE_VIEW_ARCHIVE;
    instance->flag = 0;
    instance->cust_data = 0;

    mmi_ucs2ncpy(instance->file_path, (S8*)archive_filepath, SRV_FMGR_PATH_MAX_LEN - 2);
    mmi_ucs2cat(instance->file_path, (S8*)L"\\");
    FMGR_FILTER_SET_ALL(&instance->filter_type);

    /* Set drv type, don't display unmounted memory card */
    instance->drv_type = SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY;

    /* GUI */
    instance->display_type = FMGR_DISPLAY_TYPE_BANNER_LIST;
    instance->dirty_level = 0;
    instance->cur_index = 0;
    instance->arrow_type = CAT213_ARROW_UP | CAT213_ARROW_DOWN;
    instance->key_binding = MMI_FMGRI_KEY_ALL;
    
    mmi_fmgri_instance_general_entry_explorer(instance, NULL);
    
    return mmi_fmgri_instance_get_export_id(instance);
}

void mmi_fmgri_close_archive(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if(!instance)
        return;
    
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_VIEW_ARCHIVE);

    mmi_frm_group_close(mmi_fmgri_instance_get_screen_id(instance->id));
}
#endif

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__
#define MSA_API

static U32 fmgr_msa_convert_time(MYTIME* time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return 0xFFFFFFFF - (((time->nYear-1980)*12*31*24*60*60) +
                          (time->nMonth*31*24*60*60) +
                          (time->nDay*24*60*60) +
                          (time->nHour*60*60) +
                          (time->nMin*60) +
                          (time->nSec));
}

static mmi_fmgr_instance_struct* mmi_fmgri_msa_get_instance(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    U8 i = 0;
    mmi_fmgr_instance_struct *instance = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Close mark several instance */
    for (i = 0; i < MMI_FMGR_INSTANCE_MAX_NUM; i++)
    {
        if (mmi_fmgri_is_instance_id_valid(i))
        {
            instance = mmi_fmgri_get_instance_by_id(i);
            if (instance != NULL && instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI)
            {
                break;
            }
        }
    }

    FMGR_TRACE3(TRC_MMI_FMGR_STOP_APPMEM_START, "[MMIFMGR]mmi_fmgri_msa_stop_callback(), instance: 0x%08x, i: %d, max: %d", instance, i, MMI_FMGR_INSTANCE_MAX_NUM);

    return instance;    
}

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
static void mmi_fmgri_msa_free_app_mem(void)
{
    /* Release app mem */
    if (g_fmgr_msa_app_mem_ptr != NULL)
    {
        FMGR_TRACE1(TRC_MMI_FMGR_FREE_APPMEM_START, "[MMIFMGR]mmi_fmgri_msa_free_app_mem(), address: 0x%08x", g_fmgr_msa_app_mem_ptr);
        
        applib_mem_ap_free(g_fmgr_msa_app_mem_ptr);
        g_fmgr_msa_app_mem_ptr = NULL;
    }

    FMGR_TRACE0(TRC_MMI_FMGR_FREE_APPMEM_DONE, "[MMIFMGR]mmi_fmgri_msa_free_app_mem() done");
}

static void mmi_fmgri_msa_stop_callback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance = NULL;    
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_msa_get_instance();
    
    if (instance != NULL)
    {
        mmi_fmgri_instance_general_close(instance);
    }

    /* Release app mem */
    mmi_fmgri_msa_free_app_mem();
       
    applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_MARK_SEVERAL, KAL_TRUE);

    FMGR_TRACE0(TRC_MMI_FMGR_STOP_APPMEM_DONE, "[MMIFMGR]mmi_fmgri_msa_stop_callback(), done");
}

static void mmi_fmgri_msa_init_app_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_TRACE0(TRC_MMI_FMGR_INIT_APPMEM_START, "[MMIFMGR]mmi_fmgri_msa_init_app_mem() start");
    g_parent_instance_id = 0;
    applib_mem_ap_register(APPLIB_MEM_AP_ID_MARK_SEVERAL, STR_FMGR_TITLE, 0, mmi_fmgri_msa_stop_callback);
    FMGR_TRACE0(TRC_MMI_FMGR_INIT_APPMEM_DONE, "[MMIFMGR]mmi_fmgri_msa_init_app_mem() done");
}

static void mmi_fmgri_msa_assign_buffer(mmi_fmgr_service_msa_struct* msa_obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(g_fmgr_msa_app_mem_ptr != NULL);
    
    msa_obj->size_array = (U32 *)g_fmgr_msa_app_mem_ptr;
    FMGR_TRACE2(TRC_MMI_FMGR_ASSIGN_APPMEM_SIZE_ARRAY, "[MMIFMGR]mmi_fmgri_msa_assign_buffer(), size_array: 0x%08x, len: %d", msa_obj->size_array, SIZE_OF_MSA_STRUCT_SIZE_ARRAY);
    
    msa_obj->time_array = (U32 *)((U8 *)msa_obj->size_array + SIZE_OF_MSA_STRUCT_SIZE_ARRAY);
    FMGR_TRACE2(TRC_MMI_FMGR_ASSIGN_APPMEM_TIME_ARRAY, "[MMIFMGR]mmi_fmgri_msa_assign_buffer(), time_array: 0x%08x, len: %d", msa_obj->time_array, SIZE_OF_MSA_STRUCT_TIME_ARRAY);
    
    msa_obj->name_array[0] = (S8 *)((U8 *)msa_obj->time_array + SIZE_OF_MSA_STRUCT_TIME_ARRAY);
    FMGR_TRACE2(TRC_MMI_FMGR_ASSIGN_APPMEM_NAME_ARRAY, "[MMIFMGR]mmi_fmgri_msa_assign_buffer(), name_array: 0x%08x, len: %d", msa_obj->name_array[0], SIZE_OF_MSA_STRUCT_NAME_ARRAY);
    for (i = 1; i < FMGR_MAX_MARK_ITEM; i++)
    {
        msa_obj->name_array[i] = (S8 *)((U8 *)msa_obj->name_array[0] + (SRV_FMGR_PATH_MAX_FILE_NAME_LEN+1)*ENCODING_LENGTH*i);
    }
    msa_obj->flag_array = (S8 *)((U8 *)msa_obj->name_array[FMGR_MAX_MARK_ITEM-1] + (SRV_FMGR_PATH_MAX_FILE_NAME_LEN+1)*ENCODING_LENGTH);
    FMGR_TRACE2(TRC_MMI_FMGR_ASSIGN_APPMEM_FLAG_ARRAY, "[MMIFMGR]mmi_fmgri_msa_assign_buffer(), name_array: 0x%08x, len: %d", msa_obj->flag_array, SIZE_OF_MSA_STRUCT_FLAG_ARRAY);
}

static void mmi_fmgri_msa_get_app_mem(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance = NULL;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_fmgr_msa_app_mem_ptr != NULL)
    {
        return;
    }
    
    g_fmgr_msa_app_mem_ptr = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_MARK_SEVERAL, MMI_FMGR_MARK_SEVERAL_MEM_SIZE);

    FMGR_ASSERT(g_fmgr_msa_app_mem_ptr != NULL);

    memset(g_fmgr_msa_app_mem_ptr, 0, MMI_FMGR_MARK_SEVERAL_MEM_SIZE);       

    instance = mmi_fmgri_get_instance_by_id(g_parent_instance_id);

    FMGR_ASSERT(instance != NULL);

    g_parent_instance_id = 0;
    
	mmi_fmgri_main_mark_several(instance, g_fmgr_msa_app_mem_action);
}

#endif

static S32 mmi_fmgri_msa_create()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (fmgr_serv_p->msa_buffer.used)
    {
        return 0;
    }
    memset(&(fmgr_serv_p->msa_buffer), 0, sizeof(mmi_fmgr_service_msa_struct));

    fmgr_serv_p->msa_buffer.used = 1;
    fmgr_serv_p->msa_buffer.sort_option = srv_fmgr_sort_get();
    
    return 1;
}

static void mmi_fmgri_msa_free(S32 msa_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    fmgr_serv_p->msa_buffer.used = 0;
}

#if defined (__MMI_FMGR_FOLDER_COPY_SUPPORT__)
MMI_BOOL mmi_fmgri_msa_is_src_folder(U32 instance_id, S8 *dst_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    U8 i = 0;
    mmi_fmgr_service_msa_struct *msa_obj = NULL;
    mmi_fmgr_instance_struct *instance = NULL;   
    S8 *buffer = NULL, *foldername = NULL, count = 0;
    S32 path_len = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    instance = mmi_fmgri_get_instance_by_id((U8)instance_id);
    
    msa_obj = &fmgr_serv_p->msa_buffer;
    count = msa_obj->count;
    
    buffer = mmi_fmgri_get_and_lock_buffer();
    mmi_ucs2ncpy(buffer, instance->file_path, SRV_FMGR_PATH_MAX_LEN); /* reserve for \0 */
    path_len = mmi_ucs2strlen(buffer);
    path_len = SRV_FMGR_PATH_MAX_LEN - path_len; /* reserve for \0 */
    
	if (path_len > 0)
	{
	    if (count > 0)
        {   
			do {
    			if (msa_obj->flag_array[count-1] & MMI_FMGRI_MSA_FOLDER)
    			{
    				/* This is a folder */
    				foldername = msa_obj->name_array[count-1];
    				mmi_ucs2ncat((CHAR *)buffer, (const CHAR *)foldername, path_len); /* reserve for \0 */
    				path_len = mmi_ucs2strlen(buffer);
    				if ((SRV_FMGR_PATH_MAX_LEN - path_len) > 0)
    				{
    					mmi_ucs2ncat((CHAR *)buffer, (const CHAR *)L"\\", (SRV_FMGR_PATH_MAX_LEN - path_len));
    					path_len++;
    				}
    				if (mmi_ucs2ncmp((const CHAR *)buffer, (const CHAR *)dst_path, path_len) == 0) /* Compare all characters without the last "\" */
    				{
    					result = MMI_TRUE;
    					break;
    				}
    				srv_fmgr_path_remove_filename((WCHAR *) buffer);
    			}
			} while(0);
        }
	}
    mmi_fmgri_free_and_unlock_buffer(buffer);

    return result;
}

MMI_BOOL mmi_fmgri_msa_is_src_folder_for_compare_all(U32 instance_id, const S8 *dst_path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result = MMI_FALSE;
    U8 i = 0;
    mmi_fmgr_service_msa_struct *msa_obj = NULL;
    mmi_fmgr_instance_struct *instance = NULL;   
    S8 *buffer = NULL, *foldername = NULL, count = 0;
    S32 path_len = 0, full_path_len = 0, dst_path_len = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    instance = mmi_fmgri_get_instance_by_id((U8)instance_id);
    
    msa_obj = &fmgr_serv_p->msa_buffer;
    count = msa_obj->count;
    
    buffer = mmi_fmgri_get_and_lock_buffer();
    mmi_ucs2ncpy(buffer, instance->file_path, SRV_FMGR_PATH_MAX_LEN); /* reserve for \0 */
    path_len = mmi_ucs2strlen(buffer);
    path_len = SRV_FMGR_PATH_MAX_LEN - path_len; /* reserve for \0 */
    
	if (path_len > 0)
	{
		dst_path_len = mmi_ucs2strlen(dst_path);
	    for (i = 0; i < count; i++)
        {   
			foldername = msa_obj->name_array[i];
			mmi_ucs2ncat((CHAR *)buffer, (const CHAR *)foldername, path_len); /* reserve for \0 */
			full_path_len = mmi_ucs2strlen(buffer);                            
			if ((dst_path[(mmi_ucs2strlen(dst_path)-1)*ENCODING_LENGTH] == '\\') &&
				(SRV_FMGR_PATH_MAX_LEN - full_path_len) > 0)
			{
				mmi_ucs2ncat((CHAR *)buffer, (const CHAR *)L"\\", (SRV_FMGR_PATH_MAX_LEN - full_path_len));
				full_path_len++;
			}
			if (mmi_ucs2ncmp((const CHAR *)buffer, (const CHAR *)dst_path, dst_path_len) == 0 &&
				(buffer[dst_path_len*ENCODING_LENGTH] == 0 && buffer[dst_path_len*ENCODING_LENGTH+1] == 0)) /* Compare all characters without the last "\" */
			{
				result = MMI_TRUE;
				break;
			}
			srv_fmgr_path_remove_filename((WCHAR *) buffer);
        }
	}
    mmi_fmgri_free_and_unlock_buffer(buffer);

    return result;
}
#endif

S32 mmi_fmgri_msa_add(S32 msa_id, S8* filename, U32 size, MYTIME* time, U8 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i, ins_pos, cmp_result;
    U32 time_value;
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
    S8 *tmp_name_array_element = NULL;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    /* Make sure sort option is not changed */
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.sort_option == srv_fmgr_sort_get());
    FMGR_ASSERT(!CHECK_UCS2STR_EMPTY(filename));
    
    msa_obj = &fmgr_serv_p->msa_buffer;

    time_value = fmgr_msa_convert_time(time);

    /* Check if already exist */
    ins_pos = msa_obj->count;
    for ( i = 0; i < msa_obj->count; i++)
    {
        cmp_result = mmi_ucs2cmp(filename, msa_obj->name_array[i]);
        if (cmp_result == 0)
        {
            return FMGR_MSA_ERROR_ALREADY_EXIST;
        }

        /* "<" : ascending order  0 -> 1 -> 2 -> 3
         * ">" : descending order 3 -> 2 -> 1 -> 0
         */
    #ifdef __FS_SORT_SUPPORT__         
        switch (fmgr_serv_p->msa_buffer.sort_option)
        {
            case FS_SORT_NAME:
            default:
                cmp_result = FS_SortCompareFileName((WCHAR*)filename, (WCHAR*)msa_obj->name_array[i]);
                break;

            case FS_SORT_TYPE:
                cmp_result = FS_SortCompareFileType((WCHAR*)filename, (WCHAR*)msa_obj->name_array[i]);
                break;

            case FS_SORT_SIZE:
                if (msa_obj->size_array[i] != size)
                {
                    cmp_result = (msa_obj->size_array[i] < size) ? 1 : -1;
                }
                break;

            case FS_SORT_TIME:
                if (msa_obj->time_array[i] != time_value)
                {
                    cmp_result = (msa_obj->time_array[i] < time_value) ? 1 : -1;
                }
                break;
        }
    #endif /* __FS_SORT_SUPPORT__ */
        if (cmp_result > 0)
        {
            ins_pos = i;
            break;
        }
    }

    if (msa_obj->count == FMGR_MAX_MARK_ITEM)
    {
        return FMGR_MSA_ERROR_EXCEED_MAX;
    }

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
    tmp_name_array_element = msa_obj->name_array[msa_obj->count];
#endif    
    /* Not found, insert */
    for ( i = msa_obj->count - 1; i >= ins_pos; i--)
    {
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
        msa_obj->name_array[i+1] = msa_obj->name_array[i];
#else
        mmi_ucs2cpy(msa_obj->name_array[i+1], msa_obj->name_array[i]);
#endif
        msa_obj->size_array[i+1] = msa_obj->size_array[i];
        msa_obj->time_array[i+1] = msa_obj->time_array[i];
        msa_obj->flag_array[i+1] = msa_obj->flag_array[i];
    }
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__    
    msa_obj->name_array[ins_pos] = tmp_name_array_element;
#endif
    mmi_ucs2cpy(msa_obj->name_array[ins_pos], filename);
    msa_obj->size_array[ins_pos] = size;
    msa_obj->time_array[ins_pos] = time_value;
    msa_obj->flag_array[ins_pos] = flag;
    msa_obj->count++;

    FMGR_TRACE2(TRC_MMI_FMGR_9730796B794143BFBB498AB3C0928242,
        "[MMIFMGR] > MS > mmi_fmgri_msa_add > ins=%d,total=%d\n",
        ins_pos, msa_obj->count);
    return FMGR_MSA_ERROR_OK;
}

void mmi_fmgri_msa_remove_idx(S32 msa_id, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i;
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
    S8 *tmp_name_array_element = NULL;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    if (index < 0 || index >= msa_obj->count)
    {
        return;
    }
    i = index;

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
	tmp_name_array_element = msa_obj->name_array[i];
#endif

    /* Shift entry */
    for ( ; i < msa_obj->count - 1; i++)
    {
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
        msa_obj->name_array[i] = msa_obj->name_array[i+1];
#else
        mmi_ucs2cpy(msa_obj->name_array[i], msa_obj->name_array[i+1]);
#endif
        msa_obj->size_array[i] = msa_obj->size_array[i+1];
        msa_obj->time_array[i] = msa_obj->time_array[i+1];
        msa_obj->flag_array[i] = msa_obj->flag_array[i+1];
    }
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__    
    msa_obj->name_array[i] = tmp_name_array_element;
#endif
    SET_UCS2STR_EMPTY(msa_obj->name_array[i]);
    msa_obj->size_array[i] = 0;
    msa_obj->time_array[i] = 0;
    msa_obj->flag_array[i] = 0;
    msa_obj->count--;
}

S32 mmi_fmgri_msa_remove(S32 msa_id, S8* filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    FMGR_ASSERT(!CHECK_UCS2STR_EMPTY(filename));
    msa_obj = &fmgr_serv_p->msa_buffer;

    /* find the entry */
    for ( i = 0; i < msa_obj->count; i++)
    {
        if (mmi_ucs2cmp(filename, msa_obj->name_array[i]) == 0)
        {
            break;
        }
    }

    if (i == msa_obj->count)
    {
        return FMGR_MSA_ERROR_NOT_FOUND;
    }

    /* Shift entry */
    mmi_fmgri_msa_remove_idx(msa_id, i);

    return FMGR_MSA_ERROR_OK;
}

void mmi_fmgri_msa_pop(S32 msa_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    mmi_fmgr_instance_struct *instance = NULL;
    mmi_fmgr_serv_multi_sel_info_struct *info = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    msa_obj->count--;

    if (msa_obj->flag_array[msa_obj->count] & MMI_FMGRI_MSA_FOLDER)
    {
        instance = mmi_fmgri_msa_get_instance();
        if (instance != NULL)
        {
            info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;
            
            info->folder_count--;
        }
    }
    
    SET_UCS2STR_EMPTY(msa_obj->name_array[msa_obj->count]);
    msa_obj->size_array[msa_obj->count] = 0;
    msa_obj->time_array[msa_obj->count] = 0;
    msa_obj->flag_array[msa_obj->count] = 0;
}

S8* mmi_fmgri_msa_top(S32 msa_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;
    
    if (msa_obj->count)
    {
        return msa_obj->name_array[msa_obj->count-1];
    }
    else
    {
        return NULL;
    }
}

MMI_BOOL mmi_fmgri_msa_is_exist(S32 msa_id, S8* filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    FMGR_ASSERT(!CHECK_UCS2STR_EMPTY(filename));
    msa_obj = &fmgr_serv_p->msa_buffer;

    for (i = 0; i < msa_obj->count; i++)
    {
        if (mmi_ucs2cmp(filename, msa_obj->name_array[i]) == 0)
        {
            return 1;
        }
    }
    return 0;
}

S32 mmi_fmgri_msa_count(S32 msa_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;
    
    return msa_obj->count;
}

S32 mmi_fmgri_msa_count_filter(S32 msa_id, U8 with_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i, count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    for(i=0,count=0; i<msa_obj->count; i++)
    {
        if(msa_obj->flag_array[i] & with_flag)
            count++;
    }
    
    return count;
}

void mmi_fmgri_msa_set_flags(S32 msa_id, U8 match_flag, U8 apply_flag, U8 remove_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    for(i=0; i<msa_obj->count; i++)
    {
        if(msa_obj->flag_array[i] & match_flag)
        {
            if(apply_flag)
                msa_obj->flag_array[i] |= apply_flag;
            if(remove_flag)
                msa_obj->flag_array[i] &= ~remove_flag;
        }
    }

}

void mmi_fmgri_msa_set_notmatch_flags(S32 msa_id, U8 notmatch_flag, U8 apply_flag, U8 remove_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    for(i=0; i<msa_obj->count; i++)
    {
        if(!(msa_obj->flag_array[i] & notmatch_flag))
        {
            if(apply_flag)
                msa_obj->flag_array[i] |= apply_flag;
            if(remove_flag)
                msa_obj->flag_array[i] &= ~remove_flag;
        }
    }

}


void mmi_fmgri_msa_set_item_flag(S32 msa_id, S32 idx, U8 apply_flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    FMGR_ASSERT(idx < msa_obj->count);
    msa_obj->flag_array[idx] |= apply_flag;
}

S32 mmi_fmgri_msa_find_item_index(S32 msa_id, U8 flag_must_have, U8 flag_must_not_have)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_service_msa_struct* msa_obj;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    for(i=msa_obj->count-1; i>=0; i--)
    {
        if(((msa_obj->flag_array[i] & flag_must_have)==flag_must_have) &&
           !(msa_obj->flag_array[i] & flag_must_not_have)
          )
            return i;        
    }
    return -1;
}


#endif

#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT__

#define MULTI_SEL_INSTANCE

static MMI_BOOL fmgr_multi_sel_is_send_protect(S8* folder_path, FMGR_FILE_INFO_STRUCT* info)
{
#ifdef __DRM_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8* buffer;
    S32 fwd_rule;
    BOOL ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ret = MMI_FALSE;
    buffer = mmi_fmgri_get_and_lock_buffer();
    if (mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1), folder_path, info, MMI_FALSE))
    {
        fwd_rule = mmi_rmgr_check_forward((U16*)buffer);
        if (fwd_rule >= 0 && !(fwd_rule & MMI_RMGR_USAGE_SEND))
        {
            ret = MMI_TRUE;
        }
    }
    mmi_fmgri_free_and_unlock_buffer(buffer);
    return ret;
#else /* __DRM_SUPPORT__ */
    return MMI_FALSE;
#endif /* __DRM_SUPPORT__ */
}

static void fmgr_multi_sel_popup_exceed_max(mmi_fmgr_instance_struct *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 error_buf[MAX_SUBMENU_CHARACTERS *  ENCODING_LENGTH];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(error_buf, 0, sizeof(error_buf));
    mmi_ucs2cpy((S8*)error_buf, (S8*)get_string(STR_FMGR_MARK_MAX_FILE));
    kal_wsprintf((WCHAR*)error_buf + mmi_ucs2strlen((S8*)error_buf), "%d", FMGR_MAX_MARK_ITEM);
    FMGR2_DisplayPopupStr(instance, error_buf, MMI_EVENT_FAILURE);
}

static MMI_BOOL fmgr_multi_sel_toggle(mmi_fmgr_instance_struct *instance, S8 redraw)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_serv_multi_sel_info_struct *info;
    FMGR_FILE_INFO_STRUCT *file_info = NULL;
    S32 fs_ret, count;
    U8 flag;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);

    info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

    file_info = OslMalloc(sizeof(FMGR_FILE_INFO_STRUCT));
    memset(file_info, 0, sizeof(FMGR_FILE_INFO_STRUCT));
    
    fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, file_info);
    if (fs_ret < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), 
                     MMI_EVENT_FAILURE);
        OslMfree(file_info);
        return MMI_FALSE;
    }

    count = mmi_fmgri_msa_count(info->msa_id);
    if (mmi_fmgri_msa_is_exist(info->msa_id, file_info->file_name))
    {
        fs_ret = mmi_fmgri_msa_remove(info->msa_id, file_info->file_name);
        if (fs_ret >= 0 && file_info->attribute & FS_ATTR_DIR)
        {
            info->folder_count--;
        }
    }
    else
    {
        flag = 0;
        if (!fmgr_multi_sel_is_send_protect(instance->file_path, file_info))
        {
            flag |= MMI_FMGRI_MSA_SENDABLE;
        }
        if (file_info->attribute & FS_ATTR_DIR)
        {
            flag |= MMI_FMGRI_MSA_FOLDER;
        }
        fs_ret = mmi_fmgri_msa_add(info->msa_id, file_info->file_name, file_info->file_size, &file_info->time, flag);

        if (fs_ret >= 0 && file_info->attribute & FS_ATTR_DIR)
        {
            info->folder_count++;
        }
    }

    if (fs_ret < 0)
    {
        switch (fs_ret)
        {
            case FMGR_MSA_ERROR_EXCEED_MAX:
                fmgr_multi_sel_popup_exceed_max(instance);
                OslMfree(file_info);
                return MMI_FALSE;

            default:
                FMGR_ASSERT(0);
                break;
        }
    }
    else
    {
        /* Update app info */
        if (FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPG) || FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPEG))
        {
            info->jpeg_count += (mmi_fmgri_msa_count(info->msa_id) - count);
        }
        
        if (redraw)
        {
            RedrawCategoryFunction();
        }
    }
    OslMfree(file_info);
    return MMI_TRUE;
}

static void fmgr_multi_sel_toggle_key(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fmgr_multi_sel_toggle(mmi_fmgri_get_active_instance(), MMI_TRUE);
}

static U16 fmgr_multi_sel_options_handler(U16 opt_menu_id, U16 menu_id, U32 data, U16 keyCode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_serv_multi_sel_info_struct *info;
    mmi_fmgr_instance_struct *instance;
    FMGR_FILE_INFO_STRUCT *file_info = NULL;
    MMI_BOOL close_opt;
    S32 fs_ret, i;
    U8 flag;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (menu_id == 0)
    {
        return 0;
    }

    instance = mmi_fmgri_get_instance_by_id((U8)data);
    
    info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

    file_info = OslMalloc(sizeof(FMGR_FILE_INFO_STRUCT));
    memset(file_info, 0, sizeof(FMGR_FILE_INFO_STRUCT));
    
    fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, file_info);
    if (fs_ret < 0)
    {
        FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), 
                     MMI_EVENT_FAILURE);
        OslMfree(file_info);
        return 0;
    }

    close_opt = 1;

    switch (menu_id)
    {
		case MENU_ID_FMGR_GEN_OPTION_MARK_DONE:
		{
			switch (info->action)
			{
        case MENU_ID_FMGR_GEN_OPTION_MARK_DELETE:
            mmi_fmgri_main_mark_delete(instance);
            break;
        case MENU_ID_FMGR_GEN_OPTION_MARK_COPY:
            mmi_fmgri_main_mark_copy(instance);
            break;
        case MENU_ID_FMGR_GEN_OPTION_MARK_MOVE:
            mmi_fmgri_main_mark_move(instance);
            break;
    #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
        case MENU_ID_FMGR_GEN_OPTION_MARK_PRINT:
            	{
            mmi_fmgri_main_mark_print(instance);
            close_opt = 0;
            break;
            	}
    #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */
    #ifdef __MMI_OPP_SUPPORT__
        case MENU_ID_FMGR_MARK_OPTION_TO_BT:
		            mmi_fmgri_main_mark_send(instance, MENU_ID_FMGR_MARK_OPTION_TO_BT);
            break;
    #endif
				case MENU_ID_FMGR_GEN_OPTION_MARK_APP_COPY:
		            mmi_fmgri_main_mark_copy(instance);
		            break;
        		case MENU_ID_FMGR_GEN_OPTION_MARK_APP_MOVE:
		            mmi_fmgri_main_mark_move(instance);
		            break;
			}
			break;
		}
        case MENU_ID_FMGR_GEN_OPTION_MARK_MARK:
            flag = 0;
            if (!fmgr_multi_sel_is_send_protect(instance->file_path, file_info))
            {
                flag |= MMI_FMGRI_MSA_SENDABLE;
            }

			if (file_info->attribute & FS_ATTR_DIR)
			{
				flag |= MMI_FMGRI_MSA_FOLDER;
			}

            fs_ret = mmi_fmgri_msa_add(info->msa_id, file_info->file_name, file_info->file_size, &file_info->time, flag);
            if (fs_ret >= 0)
            {
                /* Add a file */
                if (FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPG) || FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPEG))
                {
                    info->jpeg_count ++;
                }

                if (file_info->attribute & FS_ATTR_DIR)
                {
                    info->folder_count++;
                }
            }
            else
            {
                switch (fs_ret)
                {
                    case FMGR_MSA_ERROR_EXCEED_MAX:
                        fmgr_multi_sel_popup_exceed_max(instance);
                        break;

                    default:
                        FMGR_ASSERT(0);
                        break;
                }
            }
            break;
        
        case MENU_ID_FMGR_GEN_OPTION_MARK_UNMARK:
            fs_ret = mmi_fmgri_msa_remove(info->msa_id, file_info->file_name);
            if (fs_ret >= 0)
            {
                /* Remove a file */
                if (FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPG) || FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPEG))
                {
                    info->jpeg_count --;
                }

                if (file_info->attribute & FS_ATTR_DIR)
                {
                    info->folder_count--;
                }
            }
            break;
#ifdef FMGR_INTERNAL_TEST
        case MENU_ID_FMGR_GEN_OPTION_MARK_MARK_ALL:
            for ( i = 0; ; i++)
            {
                fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, i, file_info);
                if (fs_ret < 0)
                {
                    break;
                }

                flag = 0;
                if (!fmgr_multi_sel_is_send_protect(instance->file_path, file_info))
                {
                    flag |= MMI_FMGRI_MSA_SENDABLE;
                }

                fs_ret = mmi_fmgri_msa_add(info->msa_id, file_info->file_name, file_info->file_size, &file_info->time, flag);
                if (fs_ret >= 0)
                {
                    /* Add a file */
                    if (FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPG) || FMGR_FILTER_IS_SET(&file_info->file_type, FMGR_TYPE_JPEG))
                    {
                        info->jpeg_count ++;
                    }
                }
                if (fs_ret == FMGR_MSA_ERROR_EXCEED_MAX)
                {
                    /* Exceed */
                    break;
                }
            }
            break;
#endif
        case MENU_ID_FMGR_GEN_OPTION_MARK_UNMARK_ALL:
            while (mmi_fmgri_msa_count(info->msa_id))
            {
                mmi_fmgri_msa_pop(info->msa_id);
            }

            /* Reset app info */
            info->jpeg_count = 0;
            break;

        case MENU_ID_FMGR_GEN_OPTION_MARK_EXIT:
            break;

        default:
            close_opt = 0;
            break;
    }

    if (close_opt)
    {
        mmi_fmgri_close_option(opt_menu_id, data); 
    }
    OslMfree(file_info);
    return 0;
}

static void fmgr_multi_sel_highlight_hdlr(mmi_fmgr_instance_struct *instance, S32 idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (idx < 0)
    {
        ChangeLeftSoftkey(0, 0);
        ClearKeyHandler(KEY_STAR, KEY_EVENT_UP);
        return;
    }

    /* Options */
    ChangeLeftSoftkey(STR_GLOBAL_OPTIONS, 0);
#ifndef __MMI_WGUI_DISABLE_CSK__
#ifdef __FMGR_KEY_RULE__
    ChangeCenterSoftkey(0, IMG_GLOBAL_MARK_CSK);
#endif /* __FMGR_KEY_RULE__ */    
#endif
}

static mmi_ret fmgr_multi_sel_key_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_serv_multi_sel_info_struct *info;
    U16 icon_id;
    S32 fs_ret;
    S8 *buffer;
    FMGR_FILE_INFO_STRUCT file_info;
    srv_fmgr_fileinfo_struct f_info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

    switch (event_type)
    {
        case FMGRI_EVENT_RSK:
            mmi_fmgri_instance_general_close(instance);
            break;

        case FMGRI_EVENT_CSK:
            fmgr_multi_sel_toggle_key();
            break;

    #ifdef __MMI_TOUCH_SCREEN__
        case FMGRI_EVENT_TOUCH_CLICK:
            /* BD team suggest do nothing when click on item for mark several list */
            break;
    #endif /* __MMI_TOUCH_SCREEN__ */
        case FMGRI_EVENT_LSK:
            fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, instance->cur_index, &file_info);
            if (fs_ret < 0)
            {
                FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(fs_ret), MMI_EVENT_FAILURE);
                return MMI_RET_OK;
            }

            /* Prepare option menu */
            buffer = mmi_fmgri_get_and_lock_buffer();
            if (!mmi_fmgri_filepath_compose(buffer, (SRV_FMGR_PATH_MAX_LEN + 1), instance->file_path, &file_info, MMI_FALSE))
            {
                mmi_fmgri_free_and_unlock_buffer(buffer);
                FMGR2_DisplayPopup(instance, FMGR_FS_PATH_OVER_LEN_ERROR_TEXT, MMI_EVENT_FAILURE);
                return MMI_RET_OK;
            }

            /* Prepare forward menu */
            f_info.type = srv_fmgr_types_get_main_type(&file_info.file_type);
            f_info.attribute = file_info.attribute;
            f_info.size = file_info.file_size;
            memcpy(&f_info.datetime, &file_info.time, sizeof(MYTIME));
            srv_fmgr_prepare_option_menu(info->option_menu_id, (WCHAR *)buffer, &f_info);
            mmi_fmgri_prepare_option(instance, info->option_menu_id, &file_info);
            mmi_fmgri_free_and_unlock_buffer(buffer);
        
		#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif
            mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_EXIT);
        #ifndef FMGR_INTERNAL_TEST
            /* Due to behavior not clearly defined, disable this temporary */
            mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_MARK_ALL);
        #endif /* FMGR_INTERNAL_TEST */

            /* MS general option */
            if (mmi_fmgri_msa_is_exist(info->msa_id, file_info.file_name))
            {
                mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_MARK);
            }
            else
            {
                mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_UNMARK);
            }

            if (mmi_fmgri_msa_count(info->msa_id) == 0)
            {
				mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_DONE);
                mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_UNMARK_ALL);
				#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
/* under construction !*/
            #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */
            #ifdef __MMI_OPP_SUPPORT__
/* under construction !*/
            #endif
				#endif
            }
            else
            {
			#if 0
            #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */
			#endif

                if (mmi_fmgri_msa_count(info->msa_id) == info->folder_count)
                {
			#if 0
            #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)                
/* under construction !*/
            #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */            
            #ifdef __MMI_OPP_SUPPORT__
/* under construction !*/
            #endif            
			#endif
                }
            }
            /* Remove menu items of file type begin */
			#if 0
        #ifdef __FS_CARD2_SUPPORT__
        #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
/* under construction !*/
        #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */
/* under construction !*/
        #endif
			#endif
            /* Remove menu items of file type end */

            if (!GetNumOfChild_Ext(info->option_menu_id))
            {
                FMGR2_DisplayPopup(instance, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
                return MMI_RET_OK;
            }

            /* Show option menu */
            mmi_fmgri_instance_get_title_info(instance->id, NULL, &icon_id);
            mmi_fmgri_show_option(
            mmi_fmgri_instance_get_screen_id(instance->id), 
            info->option_menu_id, fmgr_multi_sel_options_handler, instance->id, icon_id);
            break;
    }

    return MMI_RET_OK;
}

void mmi_fmgr_mark_several_option_enabler(mmi_menu_id item_id, const WCHAR* filepath, const srv_fmgr_fileinfo_struct* fileinfo)
{
	//TODO;
}

S32 mmi_fmgr_general_option_mul_sel_enabler(mmi_menu_id item_id, const WCHAR* filepath, const srv_fmgr_fileinfo_struct* fileinfo)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (item_id != MENU_ID_FMGR_GEN_OPTION_MARK_SEVERAL) return;

	mmi_fmgr_reset_menu_set(item_id);

    mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_APP_COPY);
    mmi_frm_hide_menu_item(MENU_ID_FMGR_GEN_OPTION_MARK_APP_MOVE);
    #ifdef __FS_CARD2_SUPPORT__
    #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_GEN_OPTION_MARK_PRINT, filepath);
    #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */
        mmi_fmgr_util_hide_menuid_for_2nd_card(MENU_ID_FMGR_MARK_OPTION_TO_BT, filepath);
    #endif
}

static void fmgr_multi_sel_notify_event_hdlr(mmi_fmgr_instance_struct *instance, S32 event_type, U32 data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_serv_multi_sel_info_struct *info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (event_type)
    {
        case FMGRI_EVENT_SCREEN_DELETING:
            /* Reset global buffer */
            info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

            if (info->callback)
            {
                info->callback(mmi_fmgri_instance_get_export_id(instance), instance->user_data);
            }
            mmi_fmgri_msa_free(info->msa_id);

            FMGR_ASSERT(instance->cust_data);
            OslMfree((void*)instance->cust_data);
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
            /* Release app mem */
            mmi_fmgri_msa_free_app_mem();
#endif
			mmi_fmgri_main_cancel_operation(instance);
            break;
        
        case FMGRI_EVENT_INSTANCE_CREATING:			
            mmi_fmgri_main_cancel_operation(instance);
            break;

        case FMGRI_EVENT_DRIVE_UNMOUNT:
            if (srv_fmgr_drv_is_accessible((U8)instance->file_path[0]) == MMI_TRUE)
            {
                break;
            }

            /* Cancel new folder/delete operation */
            mmi_fmgri_main_cancel_operation(instance);
        
            /* Close option */
            mmi_fmgri_close_options(instance->id);
        
            /* Remove instance */
            mmi_fmgri_instance_general_close(instance);
            break;
    }
}

static MMI_BOOL fmgr_multi_sel_error_hdlr(mmi_fmgr_instance_struct *instance, S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(error)
    {
        case MMI_FMGR_ERROR_EMPTY:
            return MMI_TRUE;
            break;

    #ifdef __USB_IN_NORMAL_MODE__
        case MMI_FMGR_ERROR_USB_MODE:
            mmi_usb_app_unavailable_popup(0);
            mmi_fmgri_instance_general_close(instance);
            break;
    #endif /* __USB_IN_NORMAL_MODE__ */

        case MMI_FMGR_ERROR_LOADING_CANCEL:
            mmi_fmgri_instance_general_close(instance);
            break;

        default:
            /* Popup error */
            FMGR2_DisplayPopup(instance, srv_fmgr_fs_error_get_string(error), MMI_EVENT_FAILURE);
            mmi_fmgri_instance_general_close(instance);
            break;
    }

    return MMI_FALSE;
}

static S32 fmgr_multi_sel_command_hdlr(mmi_fmgr_instance_struct *instance, S32 cmd, S32 para, void* data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_serv_multi_sel_info_struct *info;
    FMGR_FILE_INFO_STRUCT file_info;
    S32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch (cmd)
    {
        case FMGRI_CMD_GET_MARK_STATE:
            info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;
            /* Mark state query is from GUI, use Non-blocking call */
            fs_ret = mmi_fmgri_fsdata_instance_get_file_info_ex(instance->id, para, &file_info);
            if (fs_ret < 0)
            {
                return 0;
            }

            if (mmi_fmgri_msa_is_exist(info->msa_id, file_info.file_name))
            {
                *((S32*)data) = 1;
            }
            else
            {
                *((S32*)data) = 0;
            }
            break;
        
        case FMGRI_CMD_TOGGLE_MARK_STATE:
            return fmgr_multi_sel_toggle(instance, MMI_FALSE);
    }

    return 0;
}

static mmi_ret fmgr_multi_sel_event_proc_handler(mmi_fmgr_instance_struct *instance, mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
    cui_pict_result_event_struct *evt;
#endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_CUI_FOLDER_SELECTOR_RESULT:
            fmgr_main_copy_select_folder_done(instance, (cui_folder_selector_result_event_struct*)param);
            break;
    #if defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__)
        case EVT_ID_CUI_PICT_GET_FILE_INFO:
            fmgr_main_mark_print_next();
            break;
        case EVT_ID_CUI_PICT_RESULT:
            evt = (cui_pict_result_event_struct *)param;
            if (evt->result != CUI_PICT_RESULT_NOT_READY)
            {
                mmi_fmgr_multi_print_done();
            }
            break;
    #endif /* defined(__MMI_PICT_BRIDGE_SUPPORT__) && !defined(__MMI_PICT_BRIDGE_MULTI_FILE_PRINT__) */
    }

    return MMI_RET_OK;
}


U32  mmi_fmgri_serv_multi_sel_internal(mmi_id parent_id, U16 app_id, U16 action, FMGR_FILTER* filter, S8* base_path,
                                       mmi_fmgri_multi_sel_close_callback callback,
                                       U16 option_menu_id,
                                       S8* default_highlight_name,
                                       U32 user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_serv_multi_sel_info_struct *info;
    mmi_fmgr_instance_struct *instance;
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
    mmi_fmgr_service_msa_struct* msa_obj;
#endif    
    S32 msa_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Do nothing if called in small screen */
    if (mmi_is_redrawing_bk_screens())
    {
        return 0;
    }

#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode())   /* Check is in mass storage mode */
    {
        mmi_usb_app_unavailable_popup(0);
        return 0;
    }
#endif /* __USB_IN_NORMAL_MODE__ */

    /* If file path is root, immediately return. 
	   User may plug out memory card during ASM insufficient memory screen */
    if (mmi_ucs2cmp(base_path, (PS8)SRV_FMGR_PATH_ROOT) == 0)
    {
        /* Release app mem */
        mmi_fmgri_msa_free_app_mem();
        return 0;
    }
    
    msa_id = mmi_fmgri_msa_create();
    if (msa_id == 0)
    {
        FMGR3_DisplayPopup(parent_id, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return 0;
    }
    
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
    if (g_fmgr_msa_app_mem_ptr == NULL)
    {           
        mmi_fmgri_msa_init_app_mem();

        g_fmgr_msa_app_mem_ptr = applib_mem_ap_alloc(APPLIB_MEM_AP_ID_MARK_SEVERAL, MMI_FMGR_MARK_SEVERAL_MEM_SIZE);

        if (g_fmgr_msa_app_mem_ptr == NULL)
        {
            mmi_fmgri_msa_free(msa_id);
            g_parent_instance_id = (U8)user_data;
			g_fmgr_msa_app_mem_action = action;
            mmi_frm_appmem_prompt_to_release_mem(APPLIB_MEM_AP_ID_MARK_SEVERAL, 0, MMI_FMGR_MARK_SEVERAL_MEM_SIZE, mmi_fmgri_msa_get_app_mem);
            FMGR_TRACE0(TRC_MMI_FMGR_ALLOC_APPMEM_FAIL, "[MMIFMGR]Get appmem fail");
            return 0;
        }

        FMGR_TRACE2(TRC_MMI_FMGR_ALLOC_APPMEM_DONE, "[MMIFMGR]Get appmem, address: 0x%08x, len: %d", g_fmgr_msa_app_mem_ptr, MMI_FMGR_MARK_SEVERAL_MEM_SIZE);
        memset(g_fmgr_msa_app_mem_ptr, 0, MMI_FMGR_MARK_SEVERAL_MEM_SIZE);                        
    }
	
	msa_obj = &(fmgr_serv_p->msa_buffer);

	mmi_fmgri_msa_assign_buffer(msa_obj);
#endif    
    
    /* Request/create a FMGR instance */
    instance = mmi_fmgri_instance_create_ex(parent_id, MMI_FMGR_TYPE_SEL_FILE_MUlTI);
    
    if (!instance)
    {
#ifdef __MMI_FMGR_MULTI_SELECT_SUPPORT_WITH_ASM__
        mmi_fmgri_msa_free_app_mem();
#endif
        FMGR3_DisplayPopup(parent_id, STR_GLOBAL_ERROR, MMI_EVENT_FAILURE);
        return 0;
    }

    info = (mmi_fmgr_serv_multi_sel_info_struct*)OslMalloc(sizeof(mmi_fmgr_serv_multi_sel_info_struct));
    info->callback = callback;
    info->option_menu_id = option_menu_id;
    info->msa_id = msa_id;
	info->action = action;
    /* Init app info */
    info->jpeg_count = 0;
	info->folder_count = 0;
    
    /* Save releated information */
    instance->app_id = app_id;
    instance->type = MMI_FMGR_TYPE_SEL_FILE_MUlTI;
    instance->flag = 0;
    instance->cust_data = (U32)info;
    instance->user_data = user_data;

    /* FSData */
    FMGR_ASSERT(mmi_ucs2cmp(instance->file_path, (S8*)SRV_FMGR_PATH_ROOT));
    mmi_ucs2ncpy((S8*)instance->file_path, base_path, SRV_FMGR_PATH_MAX_LEN);
    instance->filter_type = *filter;

    /* Set drv type, don't display unmounted memory card */
    instance->drv_type = SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY;

    /* GUI */
    if(app_id == APP_FILEMANAGER)
    {
        instance->display_type = FMGR_GUI_APP_MS_STYLE;
    }
    else
    {
        instance->display_type = FMGR_GUI_OTHER_MS_STYLE;
    }
    instance->dirty_level = 0;
    instance->cur_index = 0;
    instance->arrow_type = CAT213_ARROW_UP | CAT213_ARROW_DOWN;
    instance->key_binding = MMI_FMGRI_KEY_ALL | MMI_FMGRI_KEY_CSK | MMI_FMGRI_KEY_TOUCH;

#if 0
#ifndef __MMI_FMGR_FOLDER_COPY_SUPPORT__
/* under construction !*/
#endif
#endif

    mmi_fmgri_instance_general_entry_explorer(instance, default_highlight_name);

    return mmi_fmgri_instance_get_export_id(instance);
}

void mmi_fmgri_serv_multi_sel_close(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if (!instance)
    {
        return;
    }
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);
    mmi_frm_group_close(mmi_fmgri_instance_get_screen_id(instance->id));
}

S32  mmi_fmgri_serv_multi_sel_get_path(U32 id, S8* buffer, S32 buffer_length)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if (!instance)
    {
        return MMI_FMGR_ERROR_INVALID_PARAM;
    }
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);

    mmi_ucs2ncpy(buffer, instance->file_path, buffer_length);
    return 0;
}

S32  mmi_fmgri_serv_multi_sel_get_index(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if (!instance)
    {
        return MMI_FMGR_ERROR_INVALID_PARAM;
    }
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);

    return instance->cur_index;
}

S32  mmi_fmgri_serv_multi_sel_get_file_by_index(U32 id, S32 index, FMGR_FILE_INFO_STRUCT* info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if (!instance)
    {
        return MMI_FMGR_ERROR_INVALID_PARAM;
    }
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);

    return mmi_fmgri_fsdata_instance_get_file_info(instance->id, index, info);
}

S32  mmi_fmgri_serv_multi_sel_get_mark_array(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    mmi_fmgr_serv_multi_sel_info_struct *info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if (!instance)
    {
        return MMI_FMGR_ERROR_INVALID_PARAM;
    }
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);
    info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

    return info->msa_id;
}

S32  mmi_fmgri_serv_multi_sel_set_mark_array_dirty(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_fmgr_instance_struct *instance;
    mmi_fmgr_serv_multi_sel_info_struct *info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    instance = mmi_fmgri_instance_get_instance_by_export_id(id);
    if (!instance)
    {
        return MMI_FMGR_ERROR_INVALID_PARAM;
    }
    FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);
    info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

    /* Refresh the list and highlight on mas top file */
    if (mmi_fmgri_msa_count(info->msa_id))
    {
        /* Force refresh */
        mmi_fmgri_fsdata_instance_release_load(instance->id);
        /* Set search */
        mmi_fmgri_instance_general_set_search_filename(instance, mmi_fmgri_msa_top(info->msa_id));
    }
    return 0;
}

#ifndef __MMI_SLIM_FILE_MANAGER__
S32  mmi_fmgri_serv_multi_sel_find_non_mark(U32 id, S32 start_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FMGR_FILE_INFO_STRUCT file_info;
    mmi_fmgr_instance_struct *instance;
    mmi_fmgr_serv_multi_sel_info_struct *info;
    S32 i, total;
    S32 fs_ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    do {
        total = 0;
        instance = mmi_fmgri_instance_get_instance_by_export_id(id);
        if (!instance)
        {
            fs_ret = MMI_FMGR_ERROR_INVALID_PARAM;
            break;
        }
        FMGR_ASSERT(instance->type == MMI_FMGR_TYPE_SEL_FILE_MUlTI);
        info = (mmi_fmgr_serv_multi_sel_info_struct*)instance->cust_data;

        if (start_index < 0)
        {
            start_index = instance->cur_index;
        }

        total = mmi_fmgri_fsdata_instance_get_total_count(instance->id);

        if (total < 0)
        {
            fs_ret = total;
            break;
        }

        if (total > FMGR_MAX_SORT)   /* In case the loop cause MMI queue full */
        {
            fs_ret = FS_TOO_MANY_DRIVES;
            break;
        }

        /* search for non-mark item, starting from start_index */
        fs_ret = 0;
        
        /* search forward */
        for (i = start_index; i < total; i++)
        {
            fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, i, &file_info);

            if(fs_ret < 0)
            {
                break;
            }

            if (!mmi_fmgri_msa_is_exist(info->msa_id, file_info.file_name))
            {
                fs_ret = i;
                break;
            }
        }

        if (i != total)
        {
            break;
        }

        /* Search backward */
        for (i = start_index - 1; i >= 0; i--)
        {
            fs_ret = mmi_fmgri_fsdata_instance_get_file_info(instance->id, i, &file_info);
            if (fs_ret < 0)
            {
                break;
            }

            if (!mmi_fmgri_msa_is_exist(info->msa_id, file_info.file_name))
            {
                fs_ret = i;
                break;
            }
        }
        if (i < 0)
        {
            fs_ret = FS_FILE_NOT_FOUND;
        }
    } while(0);

    FMGR_TRACE3(TRC_MMI_FMGR_AA16CE834F334FC69FA9C5D4C4C68A3B,
        "[MMIFMGR] > MS > mmi_fmgri_serv_multi_sel_find_non_mark > start=%d,total=%d,found=%d\n",
        start_index, total, fs_ret);
    
    return fs_ret;
}
#endif

#ifdef __MMI_OPP_SUPPORT__
S32 mmi_fmgr_multi_sel_lock_curr(U32 fmgr_id, mmi_fmgr_multi_sel_item_struct* item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id, idx;
    S8* buffer;
    mmi_fmgr_service_msa_struct* msa_obj;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_id);
    if (msa_id < 0)
    {
        return FS_NO_MORE_FILES;
    }
    FMGR_ASSERT(fmgr_serv_p->msa_buffer.used);
    msa_obj = &fmgr_serv_p->msa_buffer;

    /* Find curr index */
    idx = mmi_fmgri_msa_find_item_index(msa_id, 0, MMI_FMGRI_MSA_PROCESSED);
    if (idx < 0)
    {
        return FS_NO_MORE_FILES;
    }
    buffer = mmi_fmgri_get_and_lock_buffer();
    mmi_fmgri_serv_multi_sel_get_path(fmgr_id, buffer, (SRV_FMGR_PATH_MAX_LEN + 1));

    if (mmi_ucs2strlen(buffer) + mmi_ucs2strlen(msa_obj->name_array[idx]) >= (SRV_FMGR_PATH_MAX_LEN + 1))
    {
        mmi_fmgri_free_and_unlock_buffer(buffer);
        return FS_PATH_OVER_LEN_ERROR;
    }

    mmi_ucs2cat(buffer, msa_obj->name_array[idx]);

    item->filepath = buffer;
    item->send_protected = (msa_obj->flag_array[idx] & MMI_FMGRI_MSA_SENDABLE) ? 0 : 1;
    return 0;    
}

void mmi_fmgr_multi_sel_unlock_curr(U32 fmgr_id, mmi_fmgr_multi_sel_item_struct* item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    mmi_fmgri_free_and_unlock_buffer((S8*)item->filepath);
}

void mmi_fmgr_multi_sel_unmark_curr(U32 fmgr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id, idx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_id);
    if(msa_id < 0)
        return;

    // find curr index
    idx = mmi_fmgri_msa_find_item_index(msa_id, 0, MMI_FMGRI_MSA_PROCESSED);
    if(idx < 0)
        return;

    // remove it
    mmi_fmgri_msa_remove_idx(msa_id, idx);
}

void mmi_fmgr_multi_sel_process_next(U32 fmgr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id, idx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_id);
    if(msa_id < 0)
        return;

    // find curr index
    idx = mmi_fmgri_msa_find_item_index(msa_id, 0, MMI_FMGRI_MSA_PROCESSED);
    if(idx < 0)
        return;

    // set flag
    mmi_fmgri_msa_set_item_flag(msa_id, idx, MMI_FMGRI_MSA_PROCESSED);
}

void mmi_fmgr_multi_sel_filter(U32 fmgr_id, U8 flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_id);
    if(msa_id < 0)
        return;

    switch(flag)
    {
    case MMI_FMGR_MULTI_SEL_NON_SENDABLE:
        mmi_fmgri_msa_set_notmatch_flags(msa_id, MMI_FMGRI_MSA_SENDABLE, MMI_FMGRI_MSA_PROCESSED, 0);
        /* Filter out folder */        
    	mmi_fmgri_msa_set_flags(msa_id, MMI_FMGRI_MSA_FOLDER, MMI_FMGRI_MSA_PROCESSED, 0);
        break;
            
    default:
        break;
    }
}

U32  mmi_fmgr_multi_sel_get_remain_count(U32 fmgr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 msa_id, count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msa_id = mmi_fmgri_serv_multi_sel_get_mark_array(fmgr_id);
    if(msa_id < 0)
        return 0;
    
    count = mmi_fmgri_msa_count(msa_id) - mmi_fmgri_msa_count_filter(msa_id, MMI_FMGRI_MSA_PROCESSED);
    FMGR_ASSERT(count >= 0);
    return (U32)count;
}
#endif
#endif

#endif /* __MMI_FILE_MANAGER__ */
