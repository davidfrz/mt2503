#*****************************************************************************
#
#  Copyright Statement:
#  --------------------
#  This software is protected by Copyright and the information contained
#  herein is confidential. The software may not be copied and the information
#  contained herein may not be used or disclosed except with the written
#  permission of MediaTek Inc. (C) 2005
#
#  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
#  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
#  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
#  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
#  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
#  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
#  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
#  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
#  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
#  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
#
#  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
#  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
#  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
#  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
#  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
#
#  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
#  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
#  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
#  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
#  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
#
#*****************************************************************************
#
# Filename: 
# ---------
#   mslt_parse_info.pl
#
# Description: 
# ------------
#   Retrieve the information for MSLT (MoDIS String Length Tool) usage.
#       [usage] mslt_parse_info.pl
#
# Auther: 
# -------
#   Fred
# 
# Note:
# -----
#
# Log: 
# -----
#  2008/07/31   Create.
#
#*****************************************************************************

#!/usr/bin/perl

# open files
&PrintDependency($0);
open(INIFILE, "<..\\..\\Framework\\MSLT\\MSLTSrc\\mslt_region.ini") or die "Cannot open mslt_region.ini.";
&PrintDependency("..\\..\\Framework\\MSLT\\MSLTSrc\\mslt_region.ini");
open(RESFILE1, "<:raw:encoding(UCS-2LE):crlf", ".\\debug\\language_usage.txt") or die "Cannot open language_usage.txt";
open(RESFILE2, "<.\\debug\\string_resource_usage.txt") or die "Cannot open string_resource_usage.txt";
open(OUTFILE1, ">..\\..\\Framework\\MSLT\\MSLTInc\\mslt_table.h") or die "Cannot open mslt_table.h";
open(OUTFILE2, ">..\\..\\Framework\\MSLT\\MSLTInc\\mslt_modis.h") or die "Cannot open mslt_modis.h";

$path = "..\\..\\Framework\\MSLT\\MSLTInc\\MSLT_INFO";
if(! -e $path)
{
    system "mkdir $path";
}
open(OUTFILE3, ">$path\\mmi_mslt_language.txt") or die "Cannot open mmi_mslt_language.txt";
open(OUTFILE4, ">$path\\mmi_mslt_string.txt") or die "Cannot open mmi_mslt_string.txt";
open(OUTFILE5, ">$path\\mmi_mslt_region_id.txt") or die "Cannot open mmi_mslt_region_id.txt";

# copy mslt_region.ini for STMT usage
system "copy /Y ..\\..\\Framework\\MSLT\\MSLTSrc\\mslt_region.ini ..\\CustResource\\PLUTO_MMI\\mslt_region.ini > nul";


# read mslt_region.ini
$id = "invalid";
while(<INIFILE>)
{
    $id = $1 if (/^\s*ID\s*=\s*(.*)$/i);                # get ID
    push(@IDS, $id) if (/^\s*ID\s*=\s*(.*)$/i);         # store ID in order
    $ID2FUNC{$id} = $1 if (/^\s*FUNC\s*=\s*(.*)$/i);    # get FUNC
    $ID2DISP{$id} = $1 if (/^\s*DISP\s*=\s*(.*)$/i);    # get DISP
}
#print $_."\t".$ID2DISP{$_}."\t".$ID2FUNC{$_}."\n" foreach @IDS;


# read language_usage.txt
<RESFILE1>;         # skip title row
while(<RESFILE1>)
{
    split(/\t/);                    # split tab
    push(@SSCS, @_[1]);             # store SSC in order
}
#print $_."\n" foreach @SSCS;


# read string_resource_usage.txt
<RESFILE2>;         # skip title row
%SID2STRING = ();
while(<RESFILE2>)
{
    split(/\t/);                                            # split tab
    push(@SIDS, @_[2]) unless exists $SID2STRING{@_[2]};    # store enum values in order
    $SID2STRING{@_[2]} = @_[3];                             # get enum value and string ID name
}
#print $_."\t".$SID2STRING{$_}."\n" foreach @SIDS;


# output mslt_table.h for string length tool usage
select OUTFILE1;
print "/\* This file is automatically generated by mslt_parse_info.pl. Do not modify it. \*/\n\n";
print "#ifndef __MSLT_TABLE_H__\n#define __MSLT_TABLE_H__\n\n";
print "#ifndef __MTK_TARGET__\n\n";
print "#define MMI_MSLT_REGION_ID_NUM    ".scalar(@IDS)."\n\n";
print "typedef enum\n{\n";
print "    MMI_MSLT_REGION_$_,\n" foreach @IDS;
print "};\n\n";
print "extern S32 $ID2FUNC{$_}(S32, mmi_mslt_font_struct*);\n" foreach @IDS;
print "\nstatic const mmi_mslt_query_func_tbl_strc g_mmi_mslt_query_func_ptrs[] =\n{\n";
print "    {MMI_MSLT_REGION_$_, \"$_\", $ID2FUNC{$_}},\n" foreach @IDS;
print "};\n\n";
print "#endif /\* __MTK_TARGET__ \*/\n\n";
print "#endif /\* __MSLT_TABLE_H__ \*/\n";
select STDOUT;


# output mslt_modis.h for MoDIS UI usage
select OUTFILE2;
print "/\* This file is automatically generated by mslt_parse_info.pl. Do not modify it. \*/\n\n";
print "#ifndef __MSLT_MODIS_H__\n#define __MSLT_MODIS_H__\n\n";
print "#ifndef __MTK_TARGET__\n\n";
print "#define MMI_MSLT_REGION_ID_NUM    ".scalar(@IDS)."\n";
print "#define MMI_MSLT_LANGUAGE_NUM    ".scalar(@SSCS)."\n";
print "#define MMI_MSLT_STRING_NUM    ".scalar(@SIDS)."\n\n";
print "typedef enum\n{\n";
print "    MMI_MSLT_REGION_$_,\n" foreach @IDS;
print "};\n\n";
print "typedef struct\n{\n    int region_id;\n    wchar_t* name;\n    wchar_t* description;\n} mmi_mslt_region_id_table;\n\n";
print "typedef struct\n{\n    int string_id;\n    wchar_t* name;\n} mmi_mslt_string_id_table;\n\n";
print "static const mmi_mslt_region_id_table g_mmi_mslt_region_id_table[] =\n{\n";
print "    {MMI_MSLT_REGION_$_, L\"$_\", L\"$ID2DISP{$_}\"},\n" foreach @IDS;
print "};\n\n";
print "static const wchar_t* g_mmi_mslt_ssc_table[] =\n{\n";
print "    L\"$_\",\n" foreach @SSCS;
print "};\n\n";
print "static const mmi_mslt_string_id_table g_mmi_mslt_string_id_table[] =\n{\n";
print "    {$_, L\"$SID2STRING{$_}\"},\n" foreach @SIDS;
print "};\n\n";
print "#endif /\* __MTK_TARGET__ \*/\n\n";
print "#endif /\* __MSLT_MODIS_H__ \*/\n";
select STDOUT;


# output mmi_mslt_language.txt for MoDIS UI usage
select OUTFILE3;
print scalar(@SSCS)."\n";
print "$_\n" foreach @SSCS;
select STDOUT;


# output mmi_mslt_string.txt for MoDIS UI usage
select OUTFILE4;
print scalar(@SIDS)."\n";
print "$SID2STRING{$_}=$_\n" foreach @SIDS;
select STDOUT;


# output mmi_mslt_region_id.txt for MoDIS UI usage
select OUTFILE5;
print scalar(@IDS)."\n";
print "$_=$ID2DISP{$_}\n" foreach @IDS;
select STDOUT;


# close files
close(INIFILE);
close(RESFILE1);
close(RESFILE2);
close(OUTFILE1);
close(OUTFILE2);
close(OUTFILE3);
close(OUTFILE4);
close(OUTFILE5);

sub PrintDependency
{
	my $file = shift;
	if (-e $file)
	{
		my $path = Win32::GetCwd() . "\\" . $file;
		$path =~ s/\//\\/g;
		print STDERR "[Dependency] $path\n";
	}
}
