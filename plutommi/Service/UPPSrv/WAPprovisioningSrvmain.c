/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
*
* Filename:
* ---------
* WAPProvisioningSrvMain.c
*
* Project:
* --------
*   MAUI
*
* Description:
* ------------
*   This is source file for UPP Provisioning application.
*
* Author: 
* -------
* -------
*
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/
#include "MMI_features.h"
#include "MMIDataType.h"

#include "common_nvram_editor_data_item.h"


#ifdef WAP_SUPPORT

#include "DtcntSrvGprot.h"


#include "WAPProfSrvConfig.h"
#include "WAPProfileSrvType.h"
#ifdef PROV_SUPPORT
#include "WAPProvisioningSrvProt.h"
#include "WAPprovisioningSrvGProt.h"
#include "WAPProfileSrvGprot.h"
#include "WAPProfileSrvProt.h"
#include "WAPprovisioningSrvType.h"
#include "Conversions.h"
#include "GlobalResDef.h"

#ifdef SYNCML_DM_SUPPORT
#include "cbfunc.h"
#endif 
#ifdef __DM_LAWMO_SUPPORT__
#include "dmuigprot.h"         /* LAWMO/SCOMO */
#endif

#include "cbm_api.h"
#include "cbm_consts.h"

#ifdef PROV_SUPPORT
#include "CcaSrvGprot.h"
#include "CcaSrvProt.h"
#endif

srv_wap_prov_cntx_struct g_srv_wap_prov_cntx;

/* static API */
static MMI_BOOL srv_wap_prov_create_profile(
	srv_wap_prov_application_content_struct *app_node,
	srv_wap_prov_proxy_content_struct *proxy_node);
static MMI_BOOL srv_wap_prov_create_profile_bookmarks_n_mms_setting(srv_wap_prov_application_content_struct *app_node);



static void srv_wap_prov_install_mms_setting(void);
extern void srv_wap_prov_add_bookmark(U8 *name, U8 *url);
extern void srv_wap_prov_save_ota_mms_setting(srv_wap_prov_mms_setting_data_list_struct *data);
static srv_cca_status_enum srv_wap_prof_prov_handle_proxy_tag(srv_cca_iterator_struct *iter_datalist);

static srv_cca_status_enum srv_wap_prof_prov_handle_application_tag(srv_cca_iterator_struct *iter_datalist);
static void srv_wap_prof_prov_process_next_prov_profile_hdlr(void *msg);
static srv_cca_status_enum srv_wap_prof_prov_cca_doc_processor(srv_wap_prof_app_id_enum app_id, S32 hConfig);

#ifdef SYNCML_DM_SUPPORT

#ifndef OMADM
static bf_bool srv_wap_prov_dm_brw_check_func(void);
static bf_bool srv_wap_prov_dm_mms_check_func(void);
#else
static IBOOL srv_wap_prov_dm_brw_check_func(void);
static IBOOL srv_wap_prov_dm_mms_check_func(void);
#endif
#endif /* SYNCML_DM_SUPPORT */ 

extern int mmi_charset_utf8_to_ucs2_length_in_bytes(const kal_uint8 *raw);

//10ADA High priority
void srv_wap_prof_prov_cca_app_sim_status_ind_hdlr(srv_cca_app_sim_profile_status_ind_struct *sim_profile_status){}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_app_configure_ind_hdlr
* DESCRIPTION
*  Entry point for New Doc indication.
* PARAMETERS
*  newconfigdoc        [?]         
*  newConfigDoc(?)     [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_prov_app_configure_ind_hdlr(srv_cca_app_configure_ind_struct *newconfigdoc)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prov_dtcnt_ready_check_evt_struct evt;
	srv_cca_status_enum result = SRV_CCA_STATUS_INVALID_SETTING;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (NULL == g_srv_wap_prov_cntx.cca_config_doc)
	{
		g_srv_wap_prov_cntx.cca_config_doc =
			(srv_cca_app_configure_ind_struct*) srv_wap_prof_mem_allocate(sizeof(srv_cca_app_configure_ind_struct));
	}
	if (g_srv_wap_prov_cntx.cca_config_doc == NULL)
	{
		ASSERT(g_srv_wap_prov_cntx.cca_config_doc);
		return;
	}
	/* MAUI_01730813 starts */



	/* 
	* Not doing forceful kill because thats a rare scenario, not sure when it will occur, when
	* profile is waiting, and provisioning arrives, seems not possible.
	*/
	/* MAUI_01730813 ends */
	g_srv_wap_prov_cntx.cca_config_doc->config_id = newconfigdoc->config_id;
	g_srv_wap_prov_cntx.cca_config_doc->hConfig = newconfigdoc->hConfig;
	g_srv_wap_prov_cntx.cca_config_doc->prov_flag = newconfigdoc->prov_flag;
	g_srv_wap_prov_cntx.cca_config_doc->prov_type = newconfigdoc->prov_type;

	g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_DEFAULT;
#if (MMI_MAX_SIM_NUM >= 2)

switch(newconfigdoc->sim_id)
    {
case MMI_SIM2:
        g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_SIM2;
		  break;
#if (MMI_MAX_SIM_NUM>=3)
case MMI_SIM3:
	      g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_SIM3;
		  break;
#if (MMI_MAX_SIM_NUM>=4)
case MMI_SIM4:
	      g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_SIM4;
		  break;
#endif
#endif
    }
#endif /* __MMI_WAP_DUAL_SIM__ */ 
	g_srv_wap_prov_cntx.crnt_proxy_index = (S8) - 1;
	g_srv_wap_prov_cntx.crnt_app_index = (S8) - 1;
	g_srv_wap_prov_cntx.scrn_deleted = MMI_FALSE;
	g_srv_wap_prov_cntx.status_sent = MMI_FALSE;
	g_srv_wap_prof_cntx.end_key_pressed = MMI_FALSE;





	if (SRV_CCA_CONFIG_BROWSER == newconfigdoc->config_id)
	{
		g_srv_wap_prov_cntx.app_id = SRV_WAP_PROF_APPID_BRW;

#ifndef BROWSER_SUPPORT
		srv_wap_prov_send_response(SRV_CCA_STATUS_SETTING_SKIPPED, (&g_srv_wap_prov_cntx.cca_config_doc));
		return;
#endif /* BROWSER_SUPPORT */ 
	}
	else
	{
		g_srv_wap_prov_cntx.app_id = SRV_WAP_PROF_APPID_MMS;
		/* MAUI_01097065 starts */
#ifndef MMS_SUPPORT
		srv_wap_prov_send_response(SRV_CCA_STATUS_SETTING_SKIPPED, (&g_srv_wap_prov_cntx.cca_config_doc));
		return;
#endif /* MMS_SUPPORT */ 
		/* MAUI_01097065 ends */
	}
#ifndef __COSMOS_MMI_PACKAGE__
	srv_wap_prof_is_re_entry_allowed(g_srv_wap_prov_cntx.sim_id, g_srv_wap_prov_cntx.app_id);
#endif
	if (SRV_CCA_PROV_TYPE_OTA_PROV == g_srv_wap_prov_cntx.cca_config_doc->prov_type)
	{
		g_srv_wap_prof_cntx.profile_content_src = SRV_WAP_PROF_PROFILE_SRC_OTA_PROV;
		g_srv_wap_prov_cntx.provisioning_type = SRV_WAP_PROV_TYPE_OTA;
		g_srv_wap_prof_cntx.prov_activate_profile_flag = MMI_TRUE;

	}
	else
	{
		g_srv_wap_prof_cntx.profile_content_src = SRV_WAP_PROF_PROFILE_SRC_USIM_PROV;
		g_srv_wap_prov_cntx.provisioning_type = SRV_WAP_PROV_TYPE_USIM;
		g_srv_wap_prof_cntx.prov_activate_profile_flag = MMI_TRUE;  // 10 A DA critical
		
	}

	g_srv_wap_prov_cntx.crnt_prof_index = 0;
	g_srv_wap_prov_cntx.profile_count = 0;
	g_srv_wap_prof_cntx.setting_installed = 0;
	g_srv_wap_prov_cntx.crnt_profile_bookmark_idx = 0;
	g_srv_wap_prov_cntx.crnt_bkm_or_mms_setting_index = 0;  //10A DA
	g_srv_wap_prof_cntx.profile_activated_bkm_flag = MMI_FALSE; //10A DA



	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_NEW_DOC, g_srv_wap_prov_cntx.app_id);

	result = srv_wap_prof_prov_cca_doc_processor(g_srv_wap_prov_cntx.app_id, g_srv_wap_prov_cntx.cca_config_doc->hConfig);

	if (SRV_CCA_STATUS_OK == result)
	{
		if (SRV_CCA_PROV_TYPE_OTA_PROV != g_srv_wap_prov_cntx.cca_config_doc->prov_type)
		{
			g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_WAITING;
		}

    	MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_DTCNT_READY_CHECK_IND);
		evt.callback = srv_wap_prof_prov_dtcnt_ready_callback;
		evt.scrn_lock = MMI_TRUE;
		MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

	}
	else
	{
		srv_wap_prov_send_response(SRV_CCA_STATUS_INVALID_SETTING, (&g_srv_wap_prov_cntx.cca_config_doc));
		srv_wap_prov_free_proxy_app_nodes();
	}
}


/*****************************************************************************
* FUNCTION
* srv_wap_prof_prov_cca_doc_processor
* DESCRIPTION
*  Processes CCA doc.
* PARAMETERS
*  app_id      [IN]        
*  hConfig     [IN]        
* RETURNS
*  srv_cca_status_enum
*****************************************************************************/
static srv_cca_status_enum srv_wap_prof_prov_cca_doc_processor(srv_wap_prof_app_id_enum app_id, S32 hConfig)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_status_enum result = SRV_CCA_STATUS_INVALID_SETTING;
	const U16 cca_mapping_browser[] = 
	{
		SRV_CCA_NS_TRIGNODE, SRV_CCA_NS_OMA_PROXY, SRV_WAP_PROV_NODE_BRW_PROXY, 0xFFFF,

		SRV_CCA_NS_TRIGNODE, SRV_CCA_NS_OMA_APPLICATION, SRV_WAP_PROV_NODE_BRW_APP, 0xFFFF,
		SRV_CCA_NS_TRIGNODE, SRV_CCA_NS_OMA_APPLICATION, SRV_CCA_NS_OMA_RESOURCE, SRV_WAP_PROV_NODE_BRW_RESOURCE, 0xFFFF,

	};

	const U16 cca_mapping_mms[] = 
	{
		SRV_CCA_NS_TRIGNODE, SRV_CCA_NS_OMA_PROXY, SRV_WAP_PROV_NODE_MMS_PROXY, 0xFFFF,
		SRV_CCA_NS_TRIGNODE, SRV_CCA_NS_OMA_APPLICATION, SRV_WAP_PROV_NODE_MMS_APP, 0xFFFF,

	};

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (SRV_WAP_PROF_APPID_BRW == app_id)
	{
		result = srv_cca_doc_process(
			hConfig,
			cca_mapping_browser,
			sizeof(cca_mapping_browser) / sizeof(U16),
			0,
			srv_wap_prov_process_browser_nodes_callback,
			0);
	}
	else if (SRV_WAP_PROF_APPID_MMS == app_id)
	{
		result = srv_cca_doc_process(
			hConfig,
			cca_mapping_mms,
			sizeof(cca_mapping_mms) / sizeof(U16),
			0,
			srv_prov_process_mms_nodes_callback,
			0);
	}

	return result;
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_dtcnt_ready_callback
* DESCRIPTION
*  Callback func after Data account is ready.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_prov_dtcnt_ready_callback(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U8 i;
	U8 profile_with_boomarks_or_mms_settings_count = 0;
	U32 encoded_dtcnt_id = 0;
	U32 dtcnt_id_to_be_activated = (U32)-1;
    srv_wap_prov_create_prov_scrn_evt_struct evt;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	srv_wap_prov_merge_proxy_application_node_list();

	srv_wap_prov_free_proxy_app_nodes();



	/* loop for setting the homepage in data account app as per data account ids */
	for(i=0; i<g_srv_wap_prov_cntx.profile_count; i++)
	{

		if ((MMI_FALSE == g_srv_wap_prov_cntx.profile_list[i]->only_bookmarks) &&
			(MMI_FALSE == g_srv_wap_prov_cntx.profile_list[i]->only_mms_settings))
		{

			encoded_dtcnt_id = srv_wap_prof_encode_dtcnt(g_srv_wap_prov_cntx.profile_list[i]->primary_dataacc_id, 
				g_srv_wap_prov_cntx.profile_list[i]->secondary_dataacc_id, 
				g_srv_wap_prov_cntx.sim_id,  
				g_srv_wap_prov_cntx.app_id );



			if( dtcnt_id_to_be_activated ==  (U32)-1)
			{
				dtcnt_id_to_be_activated = encoded_dtcnt_id;
			}

			srv_dtcnt_set_homepage(encoded_dtcnt_id,
				(S8*) g_srv_wap_prov_cntx.profile_list[i]->url,
				NVRAM_WAP_PROF_URL_LEN);
		}

		if(g_srv_wap_prov_cntx.profile_list[i]->bookmark_count > 0 || g_srv_wap_prov_cntx.profile_list[i]->mms_setting_data_p )
		{
			profile_with_boomarks_or_mms_settings_count++;
		}
	}



	if (g_srv_wap_prov_cntx.profile_count > 0) // This count includes profiles without bkms/mms settings

	{
		//Count of bookmark profiles or mms settings profiles
		g_srv_wap_prov_cntx.profile_count = profile_with_boomarks_or_mms_settings_count;

		//To activate the recently installed data account
		if (g_srv_wap_prof_cntx.prov_activate_profile_flag == MMI_TRUE && dtcnt_id_to_be_activated != (U32)-1)
		{
			g_srv_wap_prof_cntx.prov_activate_profile_flag = MMI_FALSE;
			g_srv_wap_prof_cntx.profile_activated_bkm_flag = MMI_TRUE;
			srv_wap_prov_update_provisioning_response_to_cca(SRV_WAP_PROF_PROV_RESULT_SUCCESS);


			if (SRV_WAP_PROF_PROFILE_SRC_USIM_PROV == g_srv_wap_prof_cntx.profile_content_src) 
			{

				if(MMI_TRUE == srv_wap_prof_target_app_is_ready(g_srv_wap_prov_cntx.app_id))
				{
					
					srv_wap_prof_send_activate_account_ind(dtcnt_id_to_be_activated,MMI_TRUE,g_srv_wap_prov_cntx.sim_id,g_srv_wap_prov_cntx.app_id);
				}
				else
				{  

					srv_wap_prof_send_activate_account_ind(dtcnt_id_to_be_activated,MMI_FALSE,g_srv_wap_prov_cntx.sim_id,g_srv_wap_prov_cntx.app_id);

					srv_wap_prof_prov_mem_free_profile_list();

					if (SRV_WAP_PROF_WAITING == g_srv_wap_prof_cntx.module_status)
					{
						if (MMI_FALSE == g_srv_wap_prov_cntx.status_sent)
						{
							g_srv_wap_prov_cntx.status_sent = MMI_TRUE;
                            g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY;
							srv_wap_prov_send_response(SRV_CCA_STATUS_OK, (&g_srv_wap_prov_cntx.cca_config_doc));
						}
						/* Process next job. */
#ifndef __SRV_UPP_SLIM__
						srv_wap_prof_send_process_job_queue_ind();
#endif
					}
				}

			}
			else  //OTA provisioning
			{
				srv_wap_prof_send_activate_account_ind(dtcnt_id_to_be_activated,MMI_TRUE,g_srv_wap_prov_cntx.sim_id,g_srv_wap_prov_cntx.app_id);
			}

		}
		else  // Only bookmarks or only mms settings 
		{
			while((g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark_count == 0 ) &&
				( g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->mms_setting_data_p==NULL))
			{

				g_srv_wap_prov_cntx.crnt_prof_index++;
			}

			if(SRV_WAP_PROF_PROFILE_SRC_OTA_PROV == g_srv_wap_prof_cntx.profile_content_src ) // Provisioining screens will be shown
			{

				MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_CREATE_PROV_SCR_IND);
				MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

			}

		}
	}
	else
	{
		g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY;
		srv_wap_prov_send_response(SRV_CCA_STATUS_INVALID_SETTING, (&g_srv_wap_prov_cntx.cca_config_doc));
#ifndef __SRV_UPP_SLIM__
		srv_wap_prof_send_process_job_queue_ind();
#endif
	}
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_init
* DESCRIPTION
*  Initializes provisioning application module.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_prov_init(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

     g_srv_wap_prov_cntx.cui_id = GRP_ID_INVALID; 

#ifdef SYNCML_DM_SUPPORT
	mmi_dm_set_check_function(DM_SETTING_TYPE_WAP, srv_wap_prov_dm_brw_check_func);
	mmi_dm_set_check_function(DM_SETTING_TYPE_MMS, srv_wap_prov_dm_mms_check_func);
#endif /* SYNCML_DM_SUPPORT */ 



	SetProtocolEventHandler(srv_wap_prof_add_bookmark_rsp_hdlr, MSG_ID_MMI_WAP_PROF_ADD_BOOKMARK_RSP);

	SetProtocolEventHandler(
		srv_wap_prof_prov_process_next_prov_profile_hdlr,
		MSG_ID_MMI_WAP_PROF_PROCESS_NEXT_PROV_PROFILE_IND);
}

#ifdef SYNCML_DM_SUPPORT

#ifndef OMADM
/*****************************************************************************
 * FUNCTION
 *  mmi_wap_prov_app_dm_brw_check_func
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static bf_bool srv_wap_prov_dm_brw_check_func(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    bf_bool result = TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
	if((g_srv_wap_prof_cntx.profile_content_src == SRV_WAP_PROF_PROFILE_SRC_OTA_PROV) 
		|| (KAL_TRUE == srv_wap_prof_is_active_profile_in_use(SRV_WAP_PROF_SIMID_DEFAULT, SRV_WAP_PROF_APPID_BRW))) 
    {
        result = FALSE;
    }
    MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_DM_CHECK_RESULT, result, SRV_WAP_PROF_APPID_BRW);
    return result;
}


/*****************************************************************************
* FUNCTION
 *  mmi_wap_prov_app_dm_mms_check_func
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static bf_bool srv_wap_prov_dm_mms_check_func(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    bf_bool result = TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
	if((g_srv_wap_prof_cntx.profile_content_src == SRV_WAP_PROF_PROFILE_SRC_OTA_PROV) 
		|| (KAL_TRUE == srv_wap_prof_is_active_profile_in_use(SRV_WAP_PROF_SIMID_DEFAULT, SRV_WAP_PROF_APPID_MMS)))  
    {
        result = FALSE;
    }
    MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_DM_CHECK_RESULT, result, SRV_WAP_PROF_APPID_MMS);
    return result;
}
#else
/*****************************************************************************
 * FUNCTION
 *  mmi_wap_prov_app_dm_brw_check_func
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

static IBOOL srv_wap_prov_dm_brw_check_func(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    IBOOL result = TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
	if((g_srv_wap_prof_cntx.profile_content_src == SRV_WAP_PROF_PROFILE_SRC_OTA_PROV) 
		|| (KAL_TRUE == srv_wap_prof_is_active_profile_in_use(SRV_WAP_PROF_SIMID_DEFAULT, SRV_WAP_PROF_APPID_BRW))) 
    {
        result = FALSE;
    }
    MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_DM_CHECK_RESULT, result, SRV_WAP_PROF_APPID_BRW);
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_wap_prov_app_dm_mms_check_func
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static IBOOL srv_wap_prov_dm_mms_check_func(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    IBOOL result = TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
	if((g_srv_wap_prof_cntx.profile_content_src == SRV_WAP_PROF_PROFILE_SRC_OTA_PROV) 
		|| (KAL_TRUE == srv_wap_prof_is_active_profile_in_use(SRV_WAP_PROF_SIMID_DEFAULT, SRV_WAP_PROF_APPID_MMS)))  
    {
        result = FALSE;
    }
    MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_DM_CHECK_RESULT, result, SRV_WAP_PROF_APPID_MMS);
    return result;
}
#endif
#endif
/* MAUI_00795750 starts */


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_send_ilm
* DESCRIPTION
*  
* PARAMETERS
*  dest_mod_id     [IN]        
*  msg_id          [IN]        
*  local_para      [?]         
* RETURNS
*  void
*****************************************************************************/
static void srv_wap_prof_prov_send_ilm(oslModuleType dest_mod_id, oslMsgType msg_id, oslParaType *local_para)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	  mmi_frm_send_ilm(dest_mod_id, msg_id, local_para, NULL);
}


#ifdef SYNCML_DM_SUPPORT

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_send_cca_app_get_prof_rsp
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
extern void srv_wap_prof_prov_send_cca_app_get_prof_rsp(U16 sim_id, U16 app_id, S32 prof_id, S32 hConfig, srv_cca_status_enum result)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_app_get_prof_rsp_struct *data;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	data = (srv_cca_app_get_prof_rsp_struct*)OslConstructDataPtr(sizeof(srv_cca_app_get_prof_rsp_struct));

	data->sim_id = sim_id;
	data->app_id = app_id;
	data->prof_id = prof_id;
	data->hConfig = hConfig;
	data->result = result;

	srv_wap_prof_prov_send_ilm(MOD_MMI, MSG_ID_SRV_CCA_APP_GET_PROF_RSP, (oslParaType*) data);
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_send_cca_app_update_prof_rsp
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
extern void srv_wap_prof_prov_send_cca_app_update_prof_rsp(U16 sim_id, U16 app_id, S32 prof_id, S32 hConfig, srv_cca_status_enum result)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_app_update_prof_rsp_struct *data;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	data = (srv_cca_app_update_prof_rsp_struct*)OslConstructDataPtr(sizeof(srv_cca_app_update_prof_rsp_struct));

	data->sim_id = sim_id;
	data->app_id = app_id;
	data->prof_id = prof_id;
	data->hConfig = hConfig;
	data->result = result;

	srv_wap_prof_prov_send_ilm(MOD_MMI, MSG_ID_SRV_CCA_APP_UPDATE_PROF_RSP, (oslParaType*) data);
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_dm_app_update_prof_ind_hdlr
* DESCRIPTION
*  Handles update profile indication from DM, through CCA.
* PARAMETERS
*  msg     [?]     
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_dm_app_update_prof_ind_hdlr(void *msg)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_app_update_prof_ind_struct *data;
	srv_wap_prof_activate_profile_struct act_evt;
	srv_cca_status_enum result = SRV_CCA_STATUS_OK;


	U32 encoded_dtcnt_id = 0;



#if (defined (__MMI_WAP_PROF_CBM_WAP_FALLBACK_SUPPORT__) || defined (__MMI_WAP_PROF_CBM_MMS_FALLBACK_SUPPORT__))

	U32 cbm_encoded_dtcnt_id = 0;    /* MAUI_01730725 */
	cbm_account_info_struct data_account_info;

#endif

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	data = (srv_cca_app_update_prof_ind_struct*) msg;

	if (data->prof_id != SRV_CCA_PROF_CURRENT)
	{
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_ERR_DM_UPDATE_IND_INVALID_PROFILE_ID, data->prof_id);

		srv_wap_prof_prov_send_cca_app_update_prof_rsp(data->sim_id, data->app_id, data->prof_id, data->hConfig, SRV_CCA_STATUS_FAIL);
		return;
	}

	if (data->app_id != SRV_CCA_APP_BROWSER && data->app_id != SRV_CCA_APP_MMS)
	{
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_ERR_DM_UPDATE_IND_INVALID_APP_ID, data->app_id);

		srv_wap_prof_prov_send_cca_app_update_prof_rsp(
			data->sim_id,
			data->app_id,
			data->prof_id,
			data->hConfig,
			SRV_CCA_STATUS_INVALID_SETTING);
		return;
	}

	/* MAUI_01730813 starts */
	//mmi_wap_prof_app_is_re_entry_allowed();
	/* 
	* Not doing forceful kill because thats a rare scenario, not sure when it will occur, when
	* profile is waiting, and provisioning arrives, seems not possible.
	*/
	/* MAUI_01730813 ends */

	g_srv_wap_prov_cntx.crnt_proxy_index = (S8) - 1;
	g_srv_wap_prov_cntx.crnt_app_index = (S8) - 1;
	g_srv_wap_prof_cntx.end_key_pressed = MMI_FALSE;
	g_srv_wap_prof_cntx.profile_content_src = SRV_WAP_PROF_PROFILE_SRC_DM_PROV;
	g_srv_wap_prov_cntx.provisioning_type = SRV_WAP_PROV_TYPE_DM;
	g_srv_wap_prov_cntx.crnt_prof_index = 0;
	g_srv_wap_prov_cntx.profile_count = 0;


	g_srv_wap_prof_cntx.setting_installed = 0;

	g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_DEFAULT;
#if (MMI_MAX_SIM_NUM >= 2)

switch(data->sim_id)
    {
case MMI_SIM2:
        g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_SIM2;
		  break;
#if (MMI_MAX_SIM_NUM>=3)
case MMI_SIM3:
	      g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_SIM3;
		  break;
#if (MMI_MAX_SIM_NUM>=4)
case MMI_SIM4:
	      g_srv_wap_prov_cntx.sim_id = SRV_WAP_PROF_SIMID_SIM4;
		  break;
#endif
#endif
    }
#endif /* __MMI_WAP_DUAL_SIM__ */ 

	if (data->app_id == SRV_CCA_APP_BROWSER)
	{
		g_srv_wap_prov_cntx.app_id = SRV_WAP_PROF_APPID_BRW;

#ifndef BROWSER_SUPPORT
		srv_wap_prof_prov_send_cca_app_update_prof_rsp(
			data->sim_id,
			data->app_id,
			data->prof_id,
			data->hConfig,
			SRV_CCA_STATUS_INVALID_SETTING);
		return;
#endif /* BROWSER_SUPPORT */

	}
	else if (data->app_id == SRV_CCA_APP_MMS)
	{
		/* MAUI_01097065 starts */
#ifndef MMS_SUPPORT
		srv_wap_prof_prov_send_cca_app_update_prof_rsp(
			data->sim_id,
			data->app_id,
			data->prof_id,
			data->hConfig,
			SRV_CCA_STATUS_INVALID_SETTING);
		return;
#endif /* MMS_SUPPORT */ 
		/* MAUI_01097065 ends */
		g_srv_wap_prov_cntx.app_id = SRV_WAP_PROF_APPID_MMS;
	}

#ifndef __COSMOS_MMI_PACKAGE__
	srv_wap_prof_is_re_entry_allowed(g_srv_wap_prov_cntx.sim_id, g_srv_wap_prov_cntx.app_id);
#endif


	g_srv_wap_prov_cntx.cca_hconfig = data->hConfig;
	g_srv_wap_prov_cntx.cca_dm_prof_id = data->prof_id;


	result = srv_wap_prov_dm_handle_update_profile(data->hConfig, g_srv_wap_prov_cntx.app_id);

	if (SRV_CCA_STATUS_OK != result)
	{
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_ERR_DM_UPDATE_RSP_DONE, result);

		srv_wap_prof_prov_send_cca_app_update_prof_rsp(data->sim_id, data->app_id, data->prof_id, data->hConfig, result);
		srv_wap_prof_prov_mem_free_profile_list();
		g_srv_wap_prov_cntx.profile_count = 0;
		return;
	}


	//10ADA: critical : assuming only one profile and first profiles's dtcnt homepage changed and activated


	encoded_dtcnt_id = srv_wap_prof_encode_dtcnt(g_srv_wap_prov_cntx.profile_list[0]->primary_dataacc_id, 
		g_srv_wap_prov_cntx.profile_list[0]->secondary_dataacc_id, 
		g_srv_wap_prov_cntx.sim_id,
		g_srv_wap_prov_cntx.app_id );



	srv_dtcnt_set_homepage(encoded_dtcnt_id,
		(S8*)g_srv_wap_prov_cntx.profile_list[0]->url,
		NVRAM_WAP_PROF_URL_LEN); 


	if (g_srv_wap_prof_cntx.prov_activate_profile_flag == MMI_TRUE )
	{
		g_srv_wap_prof_cntx.prov_activate_profile_flag = MMI_FALSE;

        srv_wap_prof_send_activate_account_ind(encoded_dtcnt_id,MMI_TRUE,g_srv_wap_prov_cntx.sim_id,g_srv_wap_prov_cntx.app_id);
	}


	srv_wap_prof_prov_mem_free_profile_list();
	g_srv_wap_prov_cntx.profile_count = 0;
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_dm_app_recv_prof_ind_hdlr
* DESCRIPTION
*  DM GET profile handlers, creates CCA doc for the requested profile data.
* PARAMETERS
*  msg     [?]     
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_dm_app_recv_prof_ind_hdlr(void *msg)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_app_get_prof_ind_struct *data;

	srv_wap_prof_app_id_enum profile_type;
	srv_cca_status_enum status = SRV_CCA_STATUS_OK;
	S32 hconfig = -1;
	srv_wap_prof_sim_id_enum sim_id = SRV_WAP_PROF_SIMID_DEFAULT;
	U8 profile_index = 0;
	srv_dtcnt_prof_str_info_qry_struct homepage_struct;
	U32 active_data_account_id;
	S8 profile_url[NVRAM_WAP_PROF_URL_LEN] = {0};
	U32 smart_encoded_acc_id = 0;
	U8 primary_dtcnt_id = (U8) -1;
	U8 secondary_dtcnt_id = (U8) -1;
	cbm_account_info_struct data_account_info;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	ASSERT(msg);

	data = (srv_cca_app_get_prof_ind_struct*) msg;

	if (data->app_id == SRV_CCA_APP_BROWSER)
	{
		profile_type = SRV_WAP_PROF_APPID_BRW;
	}
	else
	{
		profile_type = SRV_WAP_PROF_APPID_MMS;
	}

#if (MMI_MAX_SIM_NUM >= 2)

switch(data->sim_id)
    {
case MMI_SIM2:
        sim_id = SRV_WAP_PROF_SIMID_SIM2;
		  break;
#if (MMI_MAX_SIM_NUM>=3)
case MMI_SIM3:
	     sim_id = SRV_WAP_PROF_SIMID_SIM3;
		  break;
#if (MMI_MAX_SIM_NUM>=4)
case MMI_SIM4:
	    sim_id = SRV_WAP_PROF_SIMID_SIM4;
		  break;
#endif
#endif
    }
#endif /* __MMI_WAP_DUAL_SIM__ */ 



	active_data_account_id  = srv_wap_prof_get_active_dtcnt_index(sim_id, profile_type);


	cbm_decode_data_account_id_ext(active_data_account_id, &data_account_info);

	primary_dtcnt_id = data_account_info.account[0].account_id;
	secondary_dtcnt_id = data_account_info.account[1].account_id;



	if(primary_dtcnt_id == CBM_DEFAULT_ACCT_ID )
	{
		smart_encoded_acc_id = active_data_account_id;
		smart_encoded_acc_id = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, secondary_dtcnt_id, sim_id,  profile_type);

		srv_dtcnt_get_auto_acc_id(smart_encoded_acc_id, &active_data_account_id); //10A Da return value: Critical
	}



	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_DM_RECV_IND, active_data_account_id);


	if (SRV_CCA_PROF_CURRENT == data->prof_id)
	{
		status = SRV_CCA_STATUS_OK;

		homepage_struct.dest = (S8*)srv_wap_prof_mem_allocate(NVRAM_WAP_PROF_URL_LEN);
		memset((S8*)homepage_struct.dest, 0, NVRAM_WAP_PROF_URL_LEN);
		homepage_struct.dest_len = NVRAM_WAP_PROF_URL_LEN;
		homepage_struct.req_len = 0; //10ADA check it

		if (MMI_FALSE ==  srv_dtcnt_get_homepage(
			active_data_account_id,
			&homepage_struct,
			SRV_DTCNT_ACCOUNT_PRIMARY))  // 10ADA use DA's enum for this + the return type of this API

		{
			status = SRV_CCA_STATUS_NOT_FOUND;
			strcpy((S8*) profile_url, (S8*) SRV_WAP_PROF_DEFAULT_URL);
		}
		else
		{
			strncpy((S8*) profile_url, (S8*) homepage_struct.dest, NVRAM_WAP_PROF_URL_LEN-1);
		}


		srv_wap_prof_mem_free(homepage_struct.dest);


	}
	else
	{
		status = SRV_CCA_STATUS_NOT_FOUND;
		strcpy((S8*) profile_url, (S8*) SRV_WAP_PROF_DEFAULT_URL);
	}



	hconfig = srv_wap_prof_prov_dm_contruct_doc(profile_url, (profile_index), status, profile_type);


	if (hconfig == -1)
	{
		status = SRV_CCA_STATUS_MEMFULL;
	}




	srv_wap_prof_prov_send_cca_app_get_prof_rsp(data->sim_id, data->app_id, data->prof_id, hconfig, status);
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_dm_contruct_doc
* DESCRIPTION
*  creates CCA doc for DM get profile request.
* PARAMETERS
*  profile_content     [?]         
*  prof_index          [IN]        
*  status              [IN]        
*  app_id              [IN]        
*  msg(?)
* RETURNS
*  void
*****************************************************************************/
extern S32 srv_wap_prof_prov_dm_contruct_doc(
	S8* profile_url,
	S32 prof_index,
	srv_cca_status_enum status,
	srv_wap_prof_app_id_enum app_id)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 hConfig, hRoot, hNode;


	S8 trace_string[NVRAM_WAP_PROF_URL_LEN * 4] = {0, };


	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	hRoot = srv_cca_doc_node_new(SRV_CCA_NS_DOCROOT);
	if (!hRoot)
	{
		return -1;
	}





	hNode = srv_cca_doc_node_new_and_attach(SRV_CCA_NS_OMA_APPLICATION, hRoot);

	if (SRV_WAP_PROF_APPID_BRW == app_id)
	{
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_APPID, "w2");
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_TO_PROXY, "PROXY_1");
		hNode = srv_cca_doc_node_new_and_attach(SRV_CCA_NS_OMA_RESOURCE, hNode);
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_URI, (S8*) profile_url);
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_STARTPAGE, "");
	}
	else
	{
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_APPID, "w4");
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_TO_PROXY, "PROXY_1");
		srv_cca_doc_nodedata_add_str(hNode, SRV_CCA_NS_OMA_ADDR, (S8*) profile_url);
	}

	hConfig = srv_cca_doc_new(hRoot);


	sprintf(
		(S8*) trace_string,
		(S8*) "[WAP_PROF][PROV] DM, RECV, create doc data.  url = %s, type = %d",
		(S8*) profile_url,
		app_id);


	MMI_PRINT(SRV_WAP_PROF_MOD_INET_APP, SRV_WAP_PROF_TRC_GRP9, (S8*) trace_string);

	return hConfig;
}




/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_dm_handle_update_profile
* DESCRIPTION
*  processes CCA doc from DM update profile request.
* PARAMETERS
*  hConfig             [IN]        
*  profile_type        [IN]        
*  i(?)                [IN]        
* RETURNS
*  pBOOL
*****************************************************************************/
srv_cca_status_enum srv_wap_prov_dm_handle_update_profile(S32 hConfig, srv_wap_prof_app_id_enum profile_type)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_status_enum status = SRV_CCA_STATUS_OK;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	g_srv_wap_prov_cntx.crnt_proxy_index = (S8) - 1;
	g_srv_wap_prov_cntx.crnt_app_index = (S8) - 1;


	status = srv_wap_prof_prov_cca_doc_processor(profile_type, hConfig);

	if (status == SRV_CCA_STATUS_OK)
	{
		srv_wap_prov_merge_proxy_application_node_list();

		if (g_srv_wap_prov_cntx.profile_count > 0)
		{
			g_srv_wap_prov_cntx.crnt_prof_index = 0;

			g_srv_wap_prov_cntx.prov_op =    SRV_WAP_PROV_OP_UPDATE_SELECT;


		}
		else
		{
			status = SRV_CCA_STATUS_FAIL;
		}
	}
	else
	{
		status = SRV_CCA_STATUS_FAIL;
	}
	srv_wap_prov_free_proxy_app_nodes();
	return status;
}
#endif /* SYNCML_DM_SUPPORT */ 

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_mem_allocate_app_node
* DESCRIPTION
*  
* PARAMETERS
*  void
*  hNode(?)                [IN]        
*  node_symbol(?)          [IN]        
*  iter_datalist(?)        [IN]        
*  hConfig(?)              [IN]        
*  user_data(?)            [IN]        
* RETURNS
*  void
*****************************************************************************/
static void srv_wap_prof_prov_mem_allocate_app_node(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S8 i = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if ((g_srv_wap_prov_cntx.crnt_app_index == (S8) - 1) ||
		(g_srv_wap_prov_cntx.crnt_app_index >= SRV_WAP_PROV_MAX_PROFILE_COUNT))
	{
		ASSERT(g_srv_wap_prov_cntx.crnt_app_index != (S8) - 1);
		ASSERT(g_srv_wap_prov_cntx.crnt_app_index < SRV_WAP_PROV_MAX_PROFILE_COUNT);
		return;
	}
	if (g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index] == NULL)
	{
		g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index] =
			(srv_wap_prov_application_content_struct*)
			srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_application_content_struct));
	}

	g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->mms_setting_data_p = NULL;
	g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count = 0;


	memset(
		g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->app_url,
		0,
		sizeof(g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->app_url));



	for (i = 0; i < SRV_WAP_PROV_MAX_PROFILE_COUNT; i++)
	{
		g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->app_to_proxy[i] = NULL;
	}
	for (i = 0; i < SRV_WAP_PROV_MAX_BOOKMARK_COUNT; i++)
	{
		g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark[i] = NULL;
	}
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_mem_allocate_proxy_node
* DESCRIPTION
*  Allocates 1 proxy node, at current proxy index.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void srv_wap_prof_prov_mem_allocate_proxy_node(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if ((g_srv_wap_prov_cntx.crnt_proxy_index == (S8) - 1) ||
		(g_srv_wap_prov_cntx.crnt_proxy_index >= SRV_WAP_PROV_MAX_PROFILE_COUNT))
	{
		ASSERT(g_srv_wap_prov_cntx.crnt_proxy_index != (S8) - 1);
		ASSERT(g_srv_wap_prov_cntx.crnt_proxy_index < SRV_WAP_PROV_MAX_PROFILE_COUNT);
		return;
	}

	if (g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index] == NULL)
	{
		g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index] =
			(srv_wap_prov_proxy_content_struct*) srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_proxy_content_struct));
	}
	memset(
		g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index]->px_id,
		'\0',
		sizeof(g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index]->px_id));

	memset(
		g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index]->px_startpage,
		'\0',
		sizeof(g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index]->px_startpage));


}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_handle_proxy_tag
* DESCRIPTION
*  Handles proxy tag from CCA doc.
* PARAMETERS
*  iter_datalist       [IN]        
* RETURNS
*  srv_cca_status_enum
*****************************************************************************/
static srv_cca_status_enum srv_wap_prof_prov_handle_proxy_tag(srv_cca_iterator_struct *iter_datalist)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	cca_core_data_struct *data = NULL;
	srv_cca_status_enum result = SRV_CCA_STATUS_OK;


	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_PROXY_TAG, g_srv_wap_prov_cntx.crnt_proxy_index);


	g_srv_wap_prov_cntx.crnt_proxy_index++;

	if (SRV_WAP_PROV_MAX_PROFILE_COUNT > g_srv_wap_prov_cntx.crnt_proxy_index)
	{

		srv_wap_prof_prov_mem_allocate_proxy_node();



		srv_cca_iterator_restart(iter_datalist);

		while (srv_cca_doc_nodedata_next(iter_datalist, &data) != SRV_CCA_STATUS_ENDLIST)
		{
			if(data!=NULL)
			{
				srv_wap_prov_handle_proxy_params(g_srv_wap_prov_cntx.proxy_list[g_srv_wap_prov_cntx.crnt_proxy_index], data);
			}
		}
	}
	else
	{
		g_srv_wap_prov_cntx.crnt_proxy_index--;
	}

	return result;
}




/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_handle_application_tag
* DESCRIPTION
*  Handles application tag from CCA doc.
* PARAMETERS
*  iter_datalist       [IN]        
* RETURNS
*  srv_cca_status_enum
*****************************************************************************/
static srv_cca_status_enum srv_wap_prof_prov_handle_application_tag(srv_cca_iterator_struct *iter_datalist)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	cca_core_data_struct *data = NULL;
	srv_cca_status_enum result = SRV_CCA_STATUS_OK;
	S32 to_proxy_count = 0, i = 0;
	srv_wap_prov_application_content_struct *application_content;
	S8 *trace_string = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_srv_wap_prov_cntx.application_flag = MMI_FALSE;
	g_srv_wap_prov_cntx.crnt_app_index++;

	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_APPLICATION_TAG, g_srv_wap_prov_cntx.crnt_app_index);

	if (SRV_WAP_PROV_MAX_PROFILE_COUNT > g_srv_wap_prov_cntx.crnt_app_index)
	{
		g_srv_wap_prov_cntx.application_flag = MMI_TRUE;
		srv_wap_prof_prov_mem_allocate_app_node();
		g_srv_wap_prov_cntx.startpage_flag = MMI_FALSE;

		application_content = g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index];

		while (srv_cca_doc_nodedata_next(iter_datalist, &data) != SRV_CCA_STATUS_ENDLIST)
		{
			if(data!=NULL)
			{
				switch (data->id)
				{

				case SRV_CCA_NS_OMA_TO_PROXY:
					to_proxy_count = (data->size < SRV_WAP_PROV_MAX_TO_PROXY) ? data->size : SRV_WAP_PROV_MAX_TO_PROXY;
					trace_string = (S8*) "[WAP_PROF][PROV] APP To Proxy = %s";
					for (i = 0; i < to_proxy_count; i++)
					{
						if (NULL == application_content->app_to_proxy[i])
						{
							application_content->app_to_proxy[i] = (U8*)srv_wap_prof_mem_allocate(SRV_WAP_PROV_PROXY_ID_LEN);
						}
						memset(application_content->app_to_proxy[i], 0, SRV_WAP_PROV_PROXY_ID_LEN);
						strncpy(
							(S8*) application_content->app_to_proxy[i],
							(S8*) data->values.s[i],
							SRV_WAP_PROV_PROXY_ID_LEN - 1);
					}
					break;

				case SRV_CCA_NS_OMA_ADDR:
					if (data->size)
					{
						if ((NULL != data->values.s[0]) &&
							(0 != data->values.s[0][0]) && (MMI_FALSE == g_srv_wap_prov_cntx.startpage_flag))
						{
							trace_string = (S8*) "[WAP_PROF][PROV] APP ADDR = %s";
							strncpy(
								(S8*) application_content->app_url,
								(S8*) data->values.s[0],
								sizeof(application_content->app_url) - 1);

							g_srv_wap_prov_cntx.startpage_flag = MMI_TRUE;
						}
					}
					break;

#ifdef __MMI_WAP_PROF_MMS_SETTING_OTA_SUPPORT__
				case SRV_CCA_NS_OMA_CM:
#ifdef __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__
				case SRV_CCA_NS_OMA_RM:
				case SRV_CCA_NS_OMA_MS:
				case SRV_CCA_NS_OMA_MA:
				case SRV_CCA_NS_OMA_PC_ADDR:
#endif /* __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__ */
					if (SRV_WAP_PROF_APPID_MMS == g_srv_wap_prov_cntx.app_id)
					{
						srv_wap_prov_handle_mms_setting_data(application_content, data);
					}
					break;
#endif /* __MMI_WAP_PROF_MMS_SETTING_OTA_SUPPORT__ */
				}
				if ((NULL != trace_string) && (data->values.s[0]))
				{
					MMI_PRINT(
						SRV_WAP_PROF_MOD_INET_APP,
						SRV_WAP_PROF_TRC_GRP9,
						(S8*) trace_string,
						(S8*) data->values.s[0]);
					trace_string = NULL;
				}
			}
		}
	}
	else
	{
		g_srv_wap_prov_cntx.crnt_app_index--;
	}

	return result;
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_process_browser_nodes_callback
* DESCRIPTION
*  Callback function called by CCA as per the node like (proxy, port, apllication & bookmark)
*  being triggered. Used only for browser.
* PARAMETERS
*  hConfig             [IN]        
*  hNode               [IN]        
*  node_symbol         [IN]        
*  iter_datalist       [IN]        
*  user_data           [IN]        
* RETURNS
*  srv_cca_status_enum
*****************************************************************************/
srv_cca_status_enum srv_wap_prov_process_browser_nodes_callback(
	S32 hConfig,
	S32 hNode,
	U16 node_symbol,
	srv_cca_iterator_struct *iter_datalist,
	void *user_data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_status_enum result = SRV_CCA_STATUS_OK;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (node_symbol)
	{


	case SRV_WAP_PROV_NODE_BRW_PROXY:
		result = srv_wap_prof_prov_handle_proxy_tag(iter_datalist);
		break;



	case SRV_WAP_PROV_NODE_BRW_APP:
		result = srv_wap_prof_prov_handle_application_tag(iter_datalist);
		break;

	case SRV_WAP_PROV_NODE_BRW_RESOURCE:
		if (MMI_TRUE == g_srv_wap_prov_cntx.application_flag)
		{
			if (g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count <
				SRV_WAP_PROV_MAX_BOOKMARK_COUNT)
			{
				if (g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count == -1)
				{
					ASSERT(g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count != -1);
					return SRV_CCA_STATUS_INVALID_SETTING;
				}
				if (NULL ==
					g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->
					bookmark[g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count])
				{
					g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->
						bookmark[g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count] =
						(srv_wap_prov_bookmark_struct*)
						srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_bookmark_struct));
				}

				memset(
					g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark[g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count]->bm_title,
					0,
					sizeof(g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark[g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count]->bm_title));

				memset(
					g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark[g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count]->bm_url,
					0,
					sizeof(g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark[g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index]->bookmark_count]->bm_url));

				srv_wap_prov_browser_handle_resource_params(
					g_srv_wap_prov_cntx.app_list[g_srv_wap_prov_cntx.crnt_app_index],
					iter_datalist);
			}
		}
		break;
	}

	return result;
}


/*****************************************************************************
* FUNCTION
*  mmi_prov_process_mms_nodes_callback
* DESCRIPTION
*  Callback function called by CCA as per the node like (proxy,port ,apllication & bookmark)
*  being triggered.Used only for MMS.
* PARAMETERS
*  hConfig             [IN]        
*  hNode               [IN]        
*  node_symbol         [IN]        
*  iter_datalist       [?]         [?]
*  user_data           [?]         [?]
* RETURNS
*  srv_cca_status_enum
*****************************************************************************/
srv_cca_status_enum srv_prov_process_mms_nodes_callback(
	S32 hConfig,
	S32 hNode,
	U16 node_symbol,
	srv_cca_iterator_struct *iter_datalist,
	void *user_data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_status_enum result = SRV_CCA_STATUS_OK;
	/*
	U8 temp_url[NVRAM_WAP_PROF_URL_LEN * ENCODING_LENGTH] = {0, };
	S16 validate_url = -1;
	*/   /* MAUI_01322829 */
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (node_symbol)
	{

	case SRV_WAP_PROV_NODE_MMS_PROXY:
		result = srv_wap_prof_prov_handle_proxy_tag(iter_datalist);
		break;


	case SRV_WAP_PROV_NODE_MMS_APP:
		result = srv_wap_prof_prov_handle_application_tag(iter_datalist);

		break;
	}

	return result;
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_merge_proxy_application_node_list
* DESCRIPTION
*  This API creates profile list based on the proxy list and application list.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_merge_proxy_application_node_list(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S16 proxy_index, app_index, app_to_proxy_index = 0;
	//S32 last_proxy_index;
	MMI_BOOL bkm_result = MMI_FALSE;
	MMI_BOOL prxy_result = MMI_FALSE;
	MMI_BOOL lb_proxy_present = MMI_FALSE;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	for (app_index = 0; (app_index < SRV_WAP_PROV_MAX_PROFILE_COUNT) && (g_srv_wap_prov_cntx.app_list[app_index] != NULL) && (g_srv_wap_prov_cntx.profile_count < SRV_WAP_PROV_MAX_PROFILE_COUNT);)       /* app_index++) */
	{
		/*        app_to_proxy_index = 0; */
		proxy_index = 0;
		//last_proxy_index = -1;
		bkm_result = MMI_FALSE;
		prxy_result = MMI_FALSE;
		lb_proxy_present = MMI_FALSE;

		/* Copy bookmark and mms setting value. */
		bkm_result = srv_wap_prov_create_profile_bookmarks_n_mms_setting(g_srv_wap_prov_cntx.app_list[app_index]);

		while ((proxy_index < SRV_WAP_PROV_MAX_PROFILE_COUNT) &&
			(g_srv_wap_prov_cntx.proxy_list[proxy_index] != NULL) &&
			(g_srv_wap_prov_cntx.app_list[app_index]->app_to_proxy[app_to_proxy_index] != NULL) &&
			(g_srv_wap_prov_cntx.profile_count < SRV_WAP_PROV_MAX_PROFILE_COUNT))
		{
			if ((strcmp(
				(S8*) g_srv_wap_prov_cntx.app_list[app_index]->app_to_proxy[app_to_proxy_index],
				(S8*) g_srv_wap_prov_cntx.proxy_list[proxy_index]->px_id) == 0) )
			{
				/* Proxy matches. */
				prxy_result = srv_wap_prov_create_profile(
					g_srv_wap_prov_cntx.app_list[app_index],
					g_srv_wap_prov_cntx.proxy_list[proxy_index]);
				if (MMI_TRUE == prxy_result)
				{
					/* set proxy present true even if 1 proxy is present. */
					lb_proxy_present = MMI_TRUE;
					//last_proxy_index = proxy_index;
					/* Break out at to_proxy has been used. */
					break;
					/* proxy_index = 0; *//* Reset proxy, value as to_proxy has been incremented. */
					/* app_to_proxy_index++; *//* increment to_proxy index, as it has been used. */
				}
				else
				{
					/* proxy matched but profile not created for that proxy, hence do not set it as last proxy. */
					proxy_index++;
				}
			}
			else
			{
				proxy_index++;
			}
		}

		/* 
		* Increment to_proxy and traverse proxy again.
		*/
		app_to_proxy_index++;

		if ((app_to_proxy_index >= SRV_WAP_PROV_MAX_PROFILE_COUNT) ||
			(g_srv_wap_prov_cntx.app_list[app_index]->app_to_proxy[app_to_proxy_index] == NULL))
		{
			/* 
			* As there are no more to_proxy in the current app, increment app_index
			* and reset to_proxy.
			*/
			app_to_proxy_index = 0;
			app_index++;
		}

		if (MMI_TRUE == bkm_result && MMI_FALSE == lb_proxy_present)
		{
			/* If profile was created only due to bkm or mms setting. */
			g_srv_wap_prov_cntx.profile_count++;
		}
	}

	g_srv_wap_prov_cntx.crnt_proxy_index = 0;
	g_srv_wap_prov_cntx.crnt_app_index = 0;
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prov_create_profile_bookmarks_n_mms_setting
* DESCRIPTION
*  This API creates bookmarks of the profile.
* PARAMETERS
*  app_node            [IN]        
*  proxy_index(?)      [IN]        
*  proxy_node(?)       [IN]        
* RETURNS
*  void
*****************************************************************************/
MMI_BOOL srv_wap_prov_create_profile_bookmarks_n_mms_setting(srv_wap_prov_application_content_struct *app_node)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_BOOL result = MMI_FALSE;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_CREATE_BKM_MMS_SETTING);

	if ((app_node->bookmark_count > 0) || (app_node->mms_setting_data_p))
	{
		srv_wap_prov_mem_allocate_prov_profile();

	}

	if (app_node->bookmark_count > 0)
	{
		srv_wap_prov_fill_bookmark_parm(app_node);
		/* Set only bookmarks flag to true here it will be corrected if proxy exists later. */
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_bookmarks = MMI_TRUE;
		result = MMI_TRUE;
	}

	if (app_node->mms_setting_data_p)
	{
		/* mms setting exists. */
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_PROFILE_MMS_SETTING_EXISTS);
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->mms_setting_data_p = app_node->mms_setting_data_p;
		app_node->mms_setting_data_p = NULL; //so that the next profile does not have the same settings pointer
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_mms_settings = MMI_TRUE;
		result = MMI_TRUE;
	}

	return result;
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prov_create_profile
* DESCRIPTION
*  This API creates the profile list.
* PARAMETERS
*  app_node        [IN]        
*  proxy_node      [IN]        
* RETURNS
*  void
*****************************************************************************/
MMI_BOOL srv_wap_prov_create_profile(
									 srv_wap_prov_application_content_struct *app_node,
									 srv_wap_prov_proxy_content_struct *proxy_node)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	U8 temp_url[NVRAM_WAP_PROF_URL_LEN * ENCODING_LENGTH] = {0,};   /* MAUI_01322829 */
	MMI_BOOL empty_url_valid = MMI_TRUE;   /* MAUI_01322829 */
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	srv_wap_prov_mem_allocate_prov_profile();

	if (g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count] != NULL)
	{
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_bookmarks = MMI_FALSE;
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_mms_settings = MMI_FALSE;

		srv_wap_prov_fill_url_parm(app_node, proxy_node);
		/* MAUI_01322829 starts */
		if (SRV_WAP_PROF_APPID_MMS == g_srv_wap_prov_cntx.app_id)
		{
			empty_url_valid = MMI_FALSE;
		}

		mmi_asc_to_ucs2((S8*) temp_url, (S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url);

		if (srv_wap_prof_validate_url((PU8) temp_url, empty_url_valid) < 0)
		{
			if (SRV_WAP_PROF_APPID_MMS == g_srv_wap_prov_cntx.app_id) //10ADA Check this case during UT/IT
			{
				if (!(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->mms_setting_data_p))
				{
					/* Delete MMS profile if mms_setting does not exist. */
					srv_wap_prof_mem_free(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]);
					g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count] = NULL;
				}
				else
				{
					g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_bookmarks = MMI_TRUE;
					g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_mms_settings = MMI_TRUE;
				}
				return MMI_FALSE;
			}
			else
			{
				/* Invalid URL for browser can be changed to Blank URL. */
				strcpy((S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url,
					(S8*) SRV_WAP_PROF_DEFAULT_URL);
			}
		}
		else
		{
			mmi_ucs2_to_asc((S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url, (S8*) temp_url);
		}
		/* MAUI_01322829 ends */
		srv_wap_prov_fill_other_parm(proxy_node);
		g_srv_wap_prov_cntx.profile_count++;
		return MMI_TRUE;
	}
	else
	{
		ASSERT(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]);
		return MMI_FALSE;
	}
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prov_mem_allocate_prov_profile
* DESCRIPTION
*  This API allocates memory for profile list.
* PARAMETERS
*  void
*  dcs(?)      [IN]        
*  name(?)     [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_mem_allocate_prov_profile(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 counter;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_ALLOCATE_PROFILE, g_srv_wap_prov_cntx.profile_count);

	if ((g_srv_wap_prov_cntx.profile_count == (S8)-1) || (g_srv_wap_prov_cntx.profile_count >= SRV_WAP_PROV_MAX_PROFILE_COUNT))
	{
		ASSERT(g_srv_wap_prov_cntx.profile_count != (S8)-1);
		ASSERT(g_srv_wap_prov_cntx.profile_count < SRV_WAP_PROV_MAX_PROFILE_COUNT);
		return;
	}

	if (!(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]))
	{
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count] =
			(srv_wap_prov_ota_profile_struct*) srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_ota_profile_struct));
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->mms_setting_data_p = NULL;
		for (counter = 0; counter < SRV_WAP_PROV_MAX_BOOKMARK_COUNT; counter++)
		{
			g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[counter] = NULL;
		}
		memset(
			g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url,
			0,
			sizeof(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url));



		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark_count = 0;
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_bookmarks = MMI_FALSE;
		g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->only_mms_settings = MMI_FALSE;
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_fill_bookmark_parm
* DESCRIPTION
*  Fills bookmark details in the bookmark list.
* PARAMETERS
*  app_node        [?]         
*  dcs(?)          [IN]        
*  name(?)         [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_fill_bookmark_parm(srv_wap_prov_application_content_struct *app_node)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S16 bm_index = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (app_node->bookmark_count > 0)
	{
		for (bm_index = 0; (bm_index < app_node->bookmark_count) &&
			(bm_index < SRV_WAP_PROV_MAX_BOOKMARK_COUNT); bm_index++)
		{
			if (NULL == g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index])
			{
				g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index] =
					(srv_wap_prov_bookmark_struct*) srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_bookmark_struct));
			}
			memset(
				g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_title,
				0,
				sizeof(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_title));
			memset(
				g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_url,
				0,
				sizeof(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_url));

			mmi_ucs2ncpy(
				(S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_title,
				(S8*) app_node->bookmark[bm_index]->bm_title,
				((sizeof (g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_title) / ENCODING_LENGTH) - 1));

			strncpy(
				(S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_url,
				(S8*) app_node->bookmark[bm_index]->bm_url,
				sizeof(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark[bm_index]->bm_url) - 1);

			srv_wap_prof_mem_free(app_node->bookmark[bm_index]);
			app_node->bookmark[bm_index] = NULL;
		}
		app_node->bookmark_count = 0;
	}

	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_PROFILE_BKM_COUNT, bm_index);
	g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->bookmark_count = bm_index;
}




/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_fill_url_parm
* DESCRIPTION
*  This API fill the URL to profile.
*  If Application URL is available then it will have higher priority than proxy node URL.
*  If Application URL is not available and proxy URL is available then URL for the profile will be created by proxy URL.
*  if Both Proxy and Application node URL is not available, then it will be filled by default URL.
* PARAMETERS
*  app_node        [IN]        
*  proxy_node      [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_fill_url_parm(
								srv_wap_prov_application_content_struct *app_node,
								srv_wap_prov_proxy_content_struct *proxy_node)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (app_node->app_url[0] != 0)
	{
		strncpy(
			(S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url,
			(S8*) app_node->app_url,
			sizeof(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url) - 1);
	}
	else if (proxy_node->px_startpage[0] != 0)
	{
		strncpy(
			(S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url,
			(S8*) proxy_node->px_startpage,
			sizeof(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url) - 1);
	}
	else
	{
		strcpy((S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->url, (S8*) SRV_WAP_PROF_DEFAULT_URL);
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_fill_other_parm
* DESCRIPTION
*  This API is used to fill Primary data accID ,Secondary data accID,
*  connection type, proxt port, Username, Password and sender's address.
* PARAMETERS
*  proxy_node      [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_fill_other_parm(srv_wap_prov_proxy_content_struct *proxy_node)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S8 trace_string[NVRAM_WAP_PROF_URL_LEN] = {0, };

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/


	g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->primary_dataacc_id = proxy_node->px_primary_dataacc_id;
	g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.profile_count]->secondary_dataacc_id =
		proxy_node->px_secondary_dataacc_id;




	sprintf(
		(S8*) trace_string,
		"Data account 1 = %d, 2 = %d ",        
		proxy_node->px_primary_dataacc_id,
		proxy_node->px_secondary_dataacc_id );


	MMI_PRINT(SRV_WAP_PROF_MOD_INET_APP, SRV_WAP_PROF_TRC_GRP9, (S8*) trace_string);
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_handle_proxy_params
* DESCRIPTION
*  Based on the namespace identifier, it fill the proxy list.
* PARAMETERS
*  proxy_content       [IN]        
*  data                [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_handle_proxy_params(srv_wap_prov_proxy_content_struct *proxy_content, cca_core_data_struct *data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	S8 *trace_string = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (data->id)
	{
	case SRV_CCA_NS_OMA_PROXY_ID:
		if (data->values.s[0])
		{
			trace_string = (S8*) "[WAP_PROF][PROV] Proxy ID = %s";
			strncpy((S8*) proxy_content->px_id, (S8*) data->values.s[0], sizeof(proxy_content->px_id) - 1);
		}
		break;



	case SRV_CCA_NS_DATAACCTID:
		if (SRV_WAP_PROF_APPID_BRW == g_srv_wap_prov_cntx.app_id)
		{

#if defined(__MMI_WAP_PROF_CBM_WAP_FALLBACK_SUPPORT__)
			proxy_content->px_primary_dataacc_id = (U8) cbm_get_original_account(data->values.i[0]);
			proxy_content->px_secondary_dataacc_id = (U8) - 1;
			if (data->size > 1)
			{
				U8 k = 1;

				while (k < data->size)
				{
					if (data->values.i[0] != data->values.i[k])     /* This will skip value duplicate to primary */
					{
						proxy_content->px_secondary_dataacc_id =
							(U8) cbm_get_original_account(data->values.i[k]);
						break;
					}
					k++;
				}
			}
#else /* defined(__MMI_WAP_PROF_CBM_WAP_FALLBACK_SUPPORT__) */
			proxy_content->px_primary_dataacc_id = (U8) cbm_get_original_account(data->values.i[0]);
			proxy_content->px_secondary_dataacc_id = (U8) - 1;
#endif /* defined(__MMI_WAP_PROF_CBM_WAP_FALLBACK_SUPPORT__) */
		}
		else if (SRV_WAP_PROF_APPID_MMS == g_srv_wap_prov_cntx.app_id)
		{

#if defined(__MMI_WAP_PROF_CBM_MMS_FALLBACK_SUPPORT__)
			proxy_content->px_primary_dataacc_id = (U8) cbm_get_original_account(data->values.i[0]);
			proxy_content->px_secondary_dataacc_id = (U8) - 1;
			if (data->size > 1)
			{
				U8 k = 1;

				while (k < data->size)
				{
					if (data->values.i[0] != data->values.i[k])     /* This will skip value duplicate to primary */
					{
						proxy_content->px_secondary_dataacc_id =
							(U8) cbm_get_original_account(data->values.i[k]);
						break;
					}
					k++;
				}
			}
#else /* defined(__MMI_WAP_PROF_CBM_MMS_FALLBACK_SUPPORT__) || defined(__MMI_WAP_PROF_OLD_STYLE_MMS_FALLBACK_SUPPORT__) */
			proxy_content->px_primary_dataacc_id = (U8) cbm_get_original_account(data->values.i[0]);
			proxy_content->px_secondary_dataacc_id = (U8) - 1;
#endif /* defined(__MMI_WAP_PROF_CBM_MMS_FALLBACK_SUPPORT__) || defined(__MMI_WAP_PROF_OLD_STYLE_MMS_FALLBACK_SUPPORT__) */
		}

		MMI_TRACE(
			SRV_WAP_PROF_TRC_GRP9,
			TRC_MMI_WAP_PROF_PROV_DATA_ACCOUNT_ID,
			proxy_content->px_primary_dataacc_id,
			proxy_content->px_secondary_dataacc_id);
		break;

	case SRV_CCA_NS_OMA_STARTPAGE:
		if (data->values.s[0])
		{
			trace_string = (S8*) "[WAP_PROF][PROV] Proxy startpage = %s";
			strncpy(
				(S8*) proxy_content->px_startpage,
				(S8*) data->values.s[0],
				sizeof(proxy_content->px_startpage) - 1);
		}
		break;

	}

	if ((NULL != trace_string) && (data->values.s[0]))
	{
		MMI_PRINT(SRV_WAP_PROF_MOD_INET_APP, SRV_WAP_PROF_TRC_GRP9, (S8*) trace_string, (S8*) data->values.s[0]);
		trace_string = NULL;
	}
}



#ifdef __MMI_WAP_PROF_MMS_SETTING_OTA_SUPPORT__
/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_handle_mms_setting_data
* DESCRIPTION
*  Handles MMS setting data OTA.
* PARAMETERS
*  application_content     [IN]        
*  data                    [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_handle_mms_setting_data(
	srv_wap_prov_application_content_struct *application_content,
	cca_core_data_struct *data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prov_mms_setting_data_list_struct *mms_setting_p = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (data->size)
	{
		if (NULL == application_content->mms_setting_data_p)
		{
			application_content->mms_setting_data_p =
				(srv_wap_prov_mms_setting_data_list_struct*)
				srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_mms_setting_data_list_struct));
			mms_setting_p = application_content->mms_setting_data_p;
		}
		else
		{
			mms_setting_p = application_content->mms_setting_data_p;
			while (mms_setting_p->next)
			{
				mms_setting_p = mms_setting_p->next;
			}
			mms_setting_p->next =
				(srv_wap_prov_mms_setting_data_list_struct*)
				srv_wap_prof_mem_allocate(sizeof(srv_wap_prov_mms_setting_data_list_struct));
			mms_setting_p = mms_setting_p->next;
		}
		memset(mms_setting_p->value_s, 0, sizeof(mms_setting_p->value_s));
		mms_setting_p->next = NULL;

		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_MMS_SETTING_TAG, data->id, data->values.i[0]);

		switch (data->id)
		{
		case SRV_CCA_NS_OMA_CM:
#ifdef __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__
		case SRV_CCA_NS_OMA_RM:
#endif
			{
				if (SRV_CCA_NS_OMA_CM == data->id)
				{
					mms_setting_p->key = SRV_WAP_PROV_MMS_SETTING_CM;
				}
#ifdef __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__
				else
				{
					mms_setting_p->key = SRV_WAP_PROV_MMS_SETTING_RM;
				}
#endif /* __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__ */

				mms_setting_p->value_type = SRV_WAP_PROV_VALUE_TYPE_INT;
				switch (data->values.i[0])
				{
				case SRV_CCA_NS_VAL_RESTRICTED:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_RESTRICTED;
					break;

				case SRV_CCA_NS_VAL_WARNING:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_WARNING;
					break;

				case SRV_CCA_NS_VAL_FREE:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_FREE;
					break;

				default:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_VALUE_INVALID;
					break;
				}
			}
			break;

#ifdef __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__

		case SRV_CCA_NS_OMA_MS:
			{
				mms_setting_p->key = SRV_WAP_PROV_MMS_SETTING_MS;
				mms_setting_p->value_type = SRV_WAP_PROV_VALUE_TYPE_INT;
				mms_setting_p->value_i = data->values.i[0];
			}
			break;

		case SRV_CCA_NS_OMA_MA:
			{
				mms_setting_p->key = SRV_WAP_PROV_MMS_SETTING_MA;
				mms_setting_p->value_type = SRV_WAP_PROV_VALUE_TYPE_INT;
				switch (data->values.i[0])
				{
				case SRV_CCA_NS_VAL_ENABLE:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_MA_ENABLE;
					break;

				case SRV_CCA_NS_VAL_DISABLE:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_MA_DISABLE;
					break;

				case SRV_CCA_NS_VAL_LOCKED:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_MA_LOCKED;
					break;

				default:
					mms_setting_p->value_i = SRV_WAP_PROV_MMS_SETTING_VALUE_INVALID;
					break;
				}
			}
			break;

		case SRV_CCA_NS_OMA_PC_ADDR:
			mms_setting_p->key = SRV_WAP_PROV_MMS_SETTING_PCADDR;
			mms_setting_p->value_type = SRV_WAP_PROV_VALUE_TYPE_STR;

			MMI_PRINT(
				SRV_WAP_PROF_MOD_INET_APP,
				SRV_WAP_PROF_TRC_GRP9,
				"[WAP_PROF][PROV] MMS setting type = %d, value = %s",
				(S8*) mms_setting_p->key,
				(S8*) data->values.s[0]);
			strncpy(
				(S8*) mms_setting_p->value_s,
				(const S8*)data->values.s[0],
				sizeof(mms_setting_p->value_s) - 1);
			mms_setting_p->value_s[sizeof(mms_setting_p->value_s) - 1] = 0;
			break;

		default:
			/* Cannot reach here as caller API has a switch. */
			ASSERT(0);
			break;
#endif /* __MMI_WAP_PROF_MMS_1_3_SETTING_OTA_SUPPORT__ */
		}
	}
}
#endif /* __MMI_WAP_PROF_MMS_SETTING_OTA_SUPPORT__ */


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_browser_handle_resource_params
* DESCRIPTION
*  Based on the namespace identifier ,it fill the resource list.
* PARAMETERS
*  application_content     [IN]        
*  iter_datalist           [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_browser_handle_resource_params(
	srv_wap_prov_application_content_struct *application_content,
	srv_cca_iterator_struct *iter_datalist)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U32 len_ucs2 = 0;
	MMI_BOOL lb_bkm_flag = MMI_FALSE;
	cca_core_data_struct *data = NULL;


	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	while (srv_cca_doc_nodedata_next(iter_datalist, &data) != SRV_CCA_STATUS_ENDLIST)
	{
		if(data!=NULL)
		{
			switch (data->id)
			{
			case SRV_CCA_NS_OMA_NAME:
				if (data->size)
				{
					if (data->values.s[0] != NULL && data->values.s[0][0] != '\0')
					{
						if (mmi_chset_utf8_strlen((const U8*)data->values.s[0]) == (S32) strlen(data->values.s[0]))
						{
							mmi_asc_n_to_ucs2(
								(S8*) application_content->bookmark[application_content->bookmark_count]->bm_title,
								(S8*) data->values.s[0],
								(sizeof (application_content->bookmark[application_content->bookmark_count]->bm_title) / ENCODING_LENGTH) - 1);
						}
						else
						{
							len_ucs2 = mmi_charset_utf8_to_ucs2_length_in_bytes((U8*) data->values.s[0]) + ENCODING_LENGTH;
							if (len_ucs2 >= sizeof(application_content->bookmark[application_content->bookmark_count]->bm_title))
							{
								/* Do not pass len_ucs2 with -1 as the length is already NULL termination length. */
								len_ucs2 =
									(sizeof
									(application_content->bookmark[application_content->bookmark_count]->bm_title));
							}
							mmi_chset_utf8_to_ucs2_string(
								(U8*) application_content->bookmark[application_content->bookmark_count]->bm_title,
								len_ucs2,
								(U8*) data->values.s[0]);
						}
					}
				}
				break;

			case SRV_CCA_NS_OMA_URI:
				if (data->size && data->values.s[0] != NULL && data->values.s[0][0] != '\0')
				{
					lb_bkm_flag = MMI_TRUE;
					strncpy(
						(S8*) application_content->bookmark[application_content->bookmark_count]->bm_url,
						(S8*) data->values.s[0],
						sizeof(application_content->bookmark[application_content->bookmark_count]->bm_url) - 1);
				}
				break;

			case SRV_CCA_NS_OMA_STARTPAGE:
				if (data->size)
				{
					MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_RESOURCE_STARTPAGE_TAG);
					if ((MMI_TRUE == lb_bkm_flag) && (MMI_FALSE == g_srv_wap_prov_cntx.startpage_flag))
					{
						strncpy(
							(S8*) application_content->app_url,
							(S8*) application_content->bookmark[application_content->bookmark_count]->bm_url,
							sizeof(application_content->app_url) - 1);
						/* MAUI_01322829 starts */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */
						/* MAUI_01322829 ends */
					}
					lb_bkm_flag = MMI_FALSE;
					g_srv_wap_prov_cntx.startpage_flag = MMI_TRUE;
				}
				break;
			}
		}
	}

	if (MMI_TRUE == lb_bkm_flag)
	{
		application_content->bookmark_count++;
	}
	else
	{
		srv_wap_prof_mem_free(application_content->bookmark[application_content->bookmark_count]);
		application_content->bookmark[application_content->bookmark_count] = NULL;
	}

	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_BKM_CNT, application_content->bookmark_count);
}







/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_mem_free_profile_list
* DESCRIPTION
*  Frees memory of profile list created.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_prov_mem_free_profile_list(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S16 bookmark_index;
	U32 index = 0;
	srv_wap_prov_mms_setting_data_list_struct *mms_setting_p = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_srv_wap_prov_cntx.crnt_prof_index = 0;
	g_srv_wap_prov_cntx.crnt_bkm_or_mms_setting_index = 0;
	g_srv_wap_prof_cntx.prov_activate_profile_flag = MMI_TRUE;

	while ((index < SRV_WAP_PROV_MAX_PROFILE_COUNT) && (g_srv_wap_prov_cntx.profile_list[index] != NULL))
	{
		bookmark_index = 0;
		while (g_srv_wap_prov_cntx.profile_list[index]->bookmark_count > 0)
		{
			if (g_srv_wap_prov_cntx.profile_list[index]->bookmark[bookmark_index])
			{
				srv_wap_prof_mem_free(g_srv_wap_prov_cntx.profile_list[index]->bookmark[bookmark_index]);
			}
			g_srv_wap_prov_cntx.profile_list[index]->bookmark[bookmark_index] = NULL;
			bookmark_index++;
			g_srv_wap_prov_cntx.profile_list[index]->bookmark_count--;
		}
		mms_setting_p = g_srv_wap_prov_cntx.profile_list[index]->mms_setting_data_p;
		while (mms_setting_p)
		{
			mms_setting_p = g_srv_wap_prov_cntx.profile_list[index]->mms_setting_data_p->next;
			srv_wap_prof_mem_free(g_srv_wap_prov_cntx.profile_list[index]->mms_setting_data_p);
			g_srv_wap_prov_cntx.profile_list[index]->mms_setting_data_p = mms_setting_p;
		}
		g_srv_wap_prov_cntx.profile_list[index]->mms_setting_data_p = NULL;
		srv_wap_prof_mem_free(g_srv_wap_prov_cntx.profile_list[index]);
		g_srv_wap_prov_cntx.profile_list[index] = NULL;
		index++;
	}
	g_srv_wap_prov_cntx.profile_count = 0;
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_process_next_prov_profile_hdlr
* DESCRIPTION
*  Process next prov_profile, thru a primitive
* PARAMETERS
*  msg     [?]     
*  void*(?)
* RETURNS
*  void
*****************************************************************************/
static void srv_wap_prof_prov_process_next_prov_profile_hdlr(void *msg)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
    srv_wap_prov_create_prov_scrn_evt_struct evt;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (MMI_FALSE == g_srv_wap_prov_cntx.status_sent)
	{
		/* 
		* Process request only if response not sent to SRV_CCA.
		*/
		while((MMI_FALSE == g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->only_bookmarks) &&
			(MMI_FALSE == g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->only_mms_settings))
		{   
			g_srv_wap_prov_cntx.crnt_prof_index++;
		}
#ifndef __COSMOS_MMI_PACKAGE__

		MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_PREENTRY_PROV_SCR_IND);
		evt.provisioning_type = g_srv_wap_prov_cntx.provisioning_type;
		evt.profile_count = g_srv_wap_prov_cntx.profile_count;
	    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
#endif 
	}
}



/* MAUI_00062290 starts */
/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_get_displayable_data
* DESCRIPTION
*  Adds displayable data characters in subMenuData, appends ... if necessary.
* PARAMETERS
*  input_buffer               [IN]
*  out_buffer                 [OUT]
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_prov_get_displayable_data(U8 *out_buffer, const S8* input_buffer, U8 input_dcs)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 i_max_disp_chars = SRV_WAP_PROF_PROV_MAX_DISPLAY_CHARS;
	S8 three_dots_ucs2[(3+1) * ENCODING_LENGTH] = {0, };
	MMI_BOOL display_three_dots = MMI_FALSE;
	S8 temp_buffer[(SRV_WAP_PROF_PROV_MAX_DISPLAY_CHARS + 4 + 1) * ENCODING_LENGTH];
	S8 new_line_info[SRV_WAP_PROV_NEW_LINE_SIZE];
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	mmi_asc_to_ucs2((S8*) three_dots_ucs2, (S8*) "...");
	mmi_asc_to_ucs2((S8*) new_line_info, (S8*) "\n");
	memset(temp_buffer, 0, sizeof(temp_buffer));

	if (SRV_WAP_PROF_DCS_UCS2 == input_dcs)
	{
		if (i_max_disp_chars >= mmi_ucs2strlen((S8*) input_buffer))
		{
			mmi_ucs2cpy((S8*) temp_buffer, 
				(S8*) input_buffer);
		}
		else
		{
			mmi_ucs2ncpy((S8*) temp_buffer, 
				(S8*) input_buffer,
				i_max_disp_chars);
			display_three_dots = MMI_TRUE;
		}
	}
	else
	{
		if (i_max_disp_chars >= (S32) strlen((S8*) input_buffer))
		{
			mmi_asc_to_ucs2((S8*) temp_buffer, (S8*) input_buffer);
		}
		else
		{
			mmi_asc_n_to_ucs2((S8*) temp_buffer, 
				(S8*) input_buffer,
				i_max_disp_chars);
			display_three_dots = MMI_TRUE;
		}
	}

	if (display_three_dots)
		mmi_ucs2cat((S8*) temp_buffer, (S8*) three_dots_ucs2);

	/* Append to final data. */
	mmi_ucs2ncat((PS8) out_buffer, (PS8) temp_buffer, (((MAX_SUB_MENUS * MAX_SUB_MENU_SIZE) / ENCODING_LENGTH) - 1 - mmi_ucs2strlen((PS8) out_buffer) - 1));
	mmi_ucs2cat((PS8) out_buffer, (S8*) new_line_info);
}
/* MAUI_00062290 ends */

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_delete_info_scr_hdlr_callback
* DESCRIPTION
*  If end key is pressed on any screen then this API sends end key event.
* PARAMETERS
*  delete_type     [?]     
* RETURNS
*  void
*****************************************************************************/

void srv_wap_prof_prov_reset_info_on_back(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_cca_status_enum response_type = SRV_CCA_STATUS_OK; 
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
		/* If screen is deleted from history. and by some action unknown to me or by End key. */
		srv_wap_prof_prov_mem_free_profile_list();
		g_srv_wap_prov_cntx.crnt_prof_index = 0;
		g_srv_wap_prov_cntx.profile_count = 0;
		g_srv_wap_prov_cntx.crnt_bkm_or_mms_setting_index = 0;
		srv_wap_prof_reset_status();
		g_srv_wap_prof_cntx.end_key_pressed = MMI_TRUE;
		g_srv_wap_prof_cntx.prov_activate_profile_flag = MMI_TRUE;
		g_srv_wap_prov_cntx.crnt_profile_bookmark_idx = 0;

		g_srv_wap_prov_cntx.status_sent = MMI_TRUE;
		g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY; /* MAUI_01080371 */
#ifndef __COSMOS_MMI_PACKAGE__

		switch(g_srv_wap_prof_cntx.setting_installed) 
	{
		case SRV_WAP_PROF_PROV_RESULT_SUCCESS: 	  response_type = SRV_CCA_STATUS_ENDKEY_SETTING_INSTALLED; break;

		case SRV_WAP_PROF_PROV_RESULT_SKIPPED:    response_type = SRV_CCA_STATUS_ENDKEY_SETTING_SKIPPED; break;

		case SRV_WAP_PROF_PROV_RESULT_INVALID:    response_type = SRV_CCA_STATUS_ENDKEY_INVALID_SETTING; break;

		case SRV_WAP_PROF_PROV_RESULT_UPDATED:    response_type = SRV_CCA_STATUS_ENDKEY_SETTING_UPDATED; break;

		default :    response_type = SRV_CCA_STATUS_ENDKEY_PRESSED; break;
		}

		g_srv_wap_prof_cntx.setting_installed = 0;
		srv_wap_prov_send_response(response_type, (&g_srv_wap_prov_cntx.cca_config_doc));

#else
		g_srv_wap_prof_cntx.setting_installed = 0;
		srv_wap_prov_send_response(SRV_CCA_STATUS_ENDKEY_PRESSED, (&g_srv_wap_prov_cntx.cca_config_doc));

#endif

	}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_prov_delete_info_scr_hdlr_callback
* DESCRIPTION
*  If end key is pressed on any screen then this API sends end key event.
* PARAMETERS
*  delete_type     [?]     
* RETURNS
*  void
*****************************************************************************/
mmi_ret srv_wap_prof_prov_delete_info_scr_hdlr_callback(mmi_event_struct *param)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	//U8 result = FALSE;  /* MAUI_01084787 */
	//U8 response_type = 0; 
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(
		SRV_WAP_PROF_TRC_GRP9,
		TRC_MMI_WAP_PROF_PROV_ERR_END_KEY_PRESSED,
		g_srv_wap_prov_cntx.scrn_deleted,
		g_srv_wap_prov_cntx.status_sent);
	if ((MMI_FALSE == g_srv_wap_prov_cntx.scrn_deleted) && (MMI_FALSE == g_srv_wap_prov_cntx.status_sent))
	{
		srv_wap_prof_prov_reset_info_on_back();		
				}
	g_srv_wap_prov_cntx.scrn_deleted = MMI_FALSE;   /* MAUI_01084787 */

	/* return TRUE if you want that screen should not be deleted. */
	//  return result;  /* MAUI_01084787 */

	return MMI_RET_ALLOW_CLOSE; 
				}
/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_set_srn_delete_status
 * DESCRIPTION
 *  set status of scrn deleted used in casse of end key pressesd.
 * PARAMETERS
 *  delete_status     [IN]        
 * RETURNS
 * void
 *****************************************************************************/
void  srv_wap_prov_set_srn_delete_status(srv_wap_prov_scrn_delete_status_enum delete_status)
				{
  	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/     

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
	switch(delete_status)
	 {
	 case SRV_WAP_PROV_UNSET_SCRN_DELETED:
		       g_srv_wap_prov_cntx.scrn_deleted = MMI_FALSE;
					break;
	 case SRV_WAP_PROV_SET_SCRN_DELETED:
		       g_srv_wap_prov_cntx.scrn_deleted = MMI_TRUE;
					break;
				default:
					break;
				}
		}
/*****************************************************************************
* FUNCTION
 *  srv_wap_prov_reset_status
* DESCRIPTION
 *  reset status in case of LAWMO .
* PARAMETERS
 *  void      [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_reset_status(void)
{
        
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	    srv_wap_prov_send_response(SRV_CCA_STATUS_ABORT, (&g_srv_wap_prov_cntx.cca_config_doc));
		srv_wap_prof_prov_mem_free_profile_list();
		g_srv_wap_prov_cntx.crnt_prof_index = 0;
		g_srv_wap_prov_cntx.profile_count = 0;
		g_srv_wap_prov_cntx.crnt_bkm_or_mms_setting_index = 0;
        g_srv_wap_prov_cntx.scrn_deleted = MMI_TRUE;
}

void srv_wap_prov_get_status_sent(MMI_BOOL *status_sent)
{
	*status_sent = g_srv_wap_prov_cntx.status_sent;
}
/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_get_current_bkm_mms_index
 * DESCRIPTION
 *  return current bookmark/mms setting index for a profile.
 * PARAMETERS
 *  void      [IN]        
 * RETURNS
 *  PU8(?)
 *****************************************************************************/
U8 srv_wap_prov_get_current_bkm_mms_index(void)
		{
  	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/	
	U8 index;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	index = g_srv_wap_prov_cntx.crnt_bkm_or_mms_setting_index;
	return index;
		}
/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_get_bkm_cnt
 * DESCRIPTION
 *  return count of bookmark.
 * PARAMETERS
 *  void       [IN]        
 * RETURNS
 *  PU8(?)
 *****************************************************************************/
U32 srv_wap_prov_get_profile_count(void)
{
  return  g_srv_wap_prov_cntx.profile_count;
}
/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_get_bkm_cnt
 * DESCRIPTION
 *  return count of bookmark.
 * PARAMETERS
 *  void       [IN]        
 * RETURNS
 *  PU8(?)
 *****************************************************************************/
S16 srv_wap_prov_get_bkm_cnt(void)
{
  	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S16 bkm_cnt = 0;
 	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	bkm_cnt = g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark_count;

	return bkm_cnt;
	}


/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_provisioning_ui_done
 * DESCRIPTION
 *  return bm_title.
 * PARAMETERS
 *  void       [IN]        
 * RETURNS
 * U8
 *****************************************************************************/
S8 *srv_wap_prov_get_bm_title(S32 bkm_index)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	 S32 index;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index = bkm_index;
	return ((S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark[index]->bm_title);
}

/*****************************************************************************
* FUNCTION
 *  srv_wap_prov_get_mms_setting_data
* DESCRIPTION
 *  return pointer to mms_setting list.
* PARAMETERS
 *  void       [IN]        
* RETURNS
 *  srv_wap_prov_mms_setting_data_list_struct
*****************************************************************************/
srv_wap_prov_mms_setting_data_list_struct *srv_wap_prov_get_mms_setting_data(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	//srv_wap_prov_mms_setting_data_list_struct *mms_setting_data_p = NULL;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	//mms_setting_data_p = g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->mms_setting_data_p;
	return g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->mms_setting_data_p;
}

/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_get_app_id
 * DESCRIPTION
 *  return app_id.
 * PARAMETERS
 *  void       [IN]        
 * RETURNS
 *  srv_wap_prof_app_id_enum
 *****************************************************************************/
srv_wap_prof_app_id_enum srv_wap_prov_get_app_id(void)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	srv_wap_prof_app_id_enum app_id;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	app_id = g_srv_wap_prov_cntx.app_id;
	return app_id;
}

/*****************************************************************************
* FUNCTION
 *  srv_wap_prov_get_bm_url
* DESCRIPTION
 * return bm_url.
* PARAMETERS
 *  bkm_index       [IN]        
* RETURNS
*  PU8(?)
*****************************************************************************/
S8 *srv_wap_prov_get_bm_url(S32 bkm_index)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 index;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	index = bkm_index;
	return ((S8*) g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark[index]->bm_url);
	}

/*****************************************************************************
 * FUNCTION
 *  srv_wap_prov_provisioning_ui_done
 * DESCRIPTION
 *  Handles Done for provisioning.
 * PARAMETERS
 *  screen_exists       [IN]        
 * RETURNS
 *  PU8(?)
 *****************************************************************************/
void srv_wap_prov_provisioning_ui_done(MMI_BOOL screen_exists)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef  SYNCML_DM_SUPPORT
    U16 cca_sim_id = MMI_SIM1;
    U16 cca_app_id = 0;
#endif
    U8 response_type = 0; 
    srv_wap_prov_create_prov_scrn_evt_struct  evt;
	//srv_wap_prov_recreate_prov_scrn_evt_struct re_evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* USIM starts */
    if ((SRV_WAP_PROF_PROFILE_SRC_OTA_PROV == g_srv_wap_prof_cntx.profile_content_src) ||
        (SRV_WAP_PROF_PROFILE_SRC_USIM_PROV == g_srv_wap_prof_cntx.profile_content_src))
        /* USIM ends */
	{

         if(g_srv_wap_prov_cntx.profile_count == 0)
                {
                    g_srv_wap_prov_cntx.status_sent = MMI_TRUE;
                    srv_wap_prof_prov_mem_free_profile_list();
				srv_wap_prov_send_response(SRV_CCA_STATUS_OK, (&g_srv_wap_prov_cntx.cca_config_doc)); //10ADA Check this response
				g_srv_wap_prof_cntx.setting_installed = 0;
				return;
               }

        if((g_srv_wap_prof_cntx.profile_activated_bkm_flag == TRUE && SRV_WAP_PROF_PROFILE_SRC_OTA_PROV == g_srv_wap_prof_cntx.profile_content_src)) // (g_srv_wap_prov_cntx.cui_id!=GRP_ID_INVALID))
        {
              srv_wap_prov_update_remaining_profile_count();
            while((g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark_count == 0 ) &&
				  (g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->mms_setting_data_p==NULL))
	{
		        g_srv_wap_prov_cntx.crnt_prof_index++;
            }

			g_srv_wap_prof_cntx.profile_activated_bkm_flag = MMI_FALSE;	
		
            MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_CREATE_PROV_SCR_IND);
			MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
            return;
	}

        /* This check will ensure no response is sent after END key is pressed. */
        if ((MMI_FALSE == g_srv_wap_prov_cntx.status_sent) && (g_srv_wap_prov_cntx.profile_count > 0))       /* This condition will ensure if count = 0 then this is not reached again. */
	{
            srv_wap_prov_update_remaining_profile_count();
            g_srv_wap_prov_cntx.crnt_profile_bookmark_idx = 0;

            if (SRV_WAP_PROF_PROFILE_SRC_OTA_PROV == g_srv_wap_prof_cntx.profile_content_src)   /* USIM */
		{
                if (0 == g_srv_wap_prov_cntx.profile_count)
			{
				  	g_srv_wap_prov_cntx.status_sent = MMI_TRUE;
	                srv_wap_prof_prov_mem_free_profile_list();

                    switch(g_srv_wap_prof_cntx.setting_installed) 
				{
									case SRV_WAP_PROF_PROV_RESULT_UPDATED:    
										response_type = SRV_CCA_STATUS_SETTING_UPDATED; 
										break;

									case SRV_WAP_PROF_PROV_RESULT_SUCCESS: 	  
										response_type = SRV_CCA_STATUS_OK; 
										break;

									case SRV_WAP_PROF_PROV_RESULT_SKIPPED:    
										response_type = SRV_CCA_STATUS_SETTING_SKIPPED; 
										break;
						                
									default :			                      
										response_type = SRV_CCA_STATUS_INVALID_SETTING; 
										break;
				}
					                
                    srv_wap_prov_send_response((srv_cca_status_enum)response_type, (&g_srv_wap_prov_cntx.cca_config_doc));  //10ADA check the response 		                
                    g_srv_wap_prof_cntx.setting_installed = 0;
				}

                if (g_srv_wap_prov_cntx.profile_count > 0)
				{

                        MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_IS_NOT_IN_CALL, g_srv_wap_prov_cntx.profile_count);
                        g_srv_wap_prov_cntx.scrn_deleted = MMI_TRUE;
						while((g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark_count == 0 ) &&
						 ( g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->mms_setting_data_p==NULL)) 
								{   
									g_srv_wap_prov_cntx.crnt_prof_index++;
				}
						 MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_RECREATE_PROV_SCR_IND);
						 evt.profile_count = g_srv_wap_prov_cntx.profile_count;
						 MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
                }
                else
				{
                    MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_IS_NOT_IN_CALL, g_srv_wap_prov_cntx.profile_count);
					  MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_RECREATE_PROV_SCR_IND);
                      evt.profile_count = 0;
                      MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
                }
            }
		    else /* USIM provisioning */
            {

                if (g_srv_wap_prov_cntx.profile_count > 0)
                {
                    srv_wap_prof_send_msg(MOD_MMI, MSG_ID_MMI_WAP_PROF_PROCESS_NEXT_PROV_PROFILE_IND, NULL, NULL);
				}
                else
                {
                    srv_wap_prof_prov_mem_free_profile_list();
                    g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY;

                  //10ADA new code
                  if (MMI_FALSE == g_srv_wap_prov_cntx.status_sent)
                        {
                      g_srv_wap_prov_cntx.status_sent = MMI_TRUE;
                      srv_wap_prov_send_response(SRV_CCA_STATUS_OK, (&g_srv_wap_prov_cntx.cca_config_doc));
                    }
#ifndef __SRV_UPP_SLIM__
                    srv_wap_prof_send_process_job_queue_ind(); //10ADA check this especially
#endif
                }
            }
        }
    }

#ifdef SYNCML_DM_SUPPORT
    else if (SRV_WAP_PROF_PROFILE_SRC_DM_PROV == g_srv_wap_prof_cntx.profile_content_src)
    {
        /* may wrap this flow with SYNCML_DM_SUPPORT */
        MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_DM_UPDATE_RSP_DONE);

        /* Send DM response */
switch(g_srv_wap_prov_cntx.sim_id)
    {
case SRV_WAP_PROF_SIMID_SIM1:
        cca_sim_id = MMI_SIM1;
		  break;
#if (MMI_MAX_SIM_NUM>=2)
case SRV_WAP_PROF_SIMID_SIM2:
	     cca_sim_id = MMI_SIM2;
		  break;
#if (MMI_MAX_SIM_NUM>=3)
case SRV_WAP_PROF_SIMID_SIM3:
	    cca_sim_id = MMI_SIM3;
		  break;
#if (MMI_MAX_SIM_NUM>=4)
case SRV_WAP_PROF_SIMID_SIM4:
	    cca_sim_id = MMI_SIM4;
		  break;
#endif
#endif
#endif
}

        if (SRV_WAP_PROF_APPID_BRW == g_srv_wap_prov_cntx.app_id)
        {
            cca_app_id = SRV_CCA_APP_BROWSER;
	}
        else
        {
            cca_app_id = SRV_CCA_APP_MMS;
}

        srv_wap_prof_prov_send_cca_app_update_prof_rsp(
            cca_sim_id,
            cca_app_id,
            g_srv_wap_prov_cntx.cca_dm_prof_id,
            g_srv_wap_prov_cntx.cca_hconfig,
            SRV_CCA_STATUS_OK);
         /* SYNCML_DM_SUPPORT */

        /* Reset the value after sending RSP. */
        g_srv_wap_prov_cntx.cca_hconfig = 0;
        g_srv_wap_prov_cntx.profile_count = 0;
    }
#endif
/* USIM starts */
#ifndef __SRV_UPP_SLIM__
    else if (SRV_WAP_PROF_PROFILE_SRC_SIM_STATUS_CHG == g_srv_wap_prof_cntx.profile_content_src)
{
        /* Process next SIM PROFILE job. */
        srv_wap_prof_send_process_job_queue_ind();
    }
#endif
    /* USIM ends */
    else
    {
        MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_ERR_DONE_SRC_ERROR, g_srv_wap_prov_cntx.app_id);
        ASSERT(0);
}
}

/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_skip_profile
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_skip_profile(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	srv_wap_prov_update_provisioning_response_to_cca(SRV_WAP_PROF_PROV_RESULT_SKIPPED);

	srv_wap_prov_provisioning_ui_done(MMI_TRUE);
}





/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_install_setting
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_install_setting(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	//   kal_bool is_busy = KAL_FALSE;   /* MAUI_1420567 */
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* MAUI_01080371 starts */
#ifndef __COSMOS_MMI_PACKAGE__
	if (SRV_WAP_PROV_TYPE_OTA == g_srv_wap_prov_cntx.provisioning_type)
	{
		/* Clear key handlers for OTA provisioning only. */
		ClearAllKeyHandler();
		ClearKeyHandler(KEY_END, KEY_EVENT_UP);
		ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
		ClearKeyHandler(KEY_END, KEY_LONG_PRESS);
		ClearKeyHandler(KEY_END, KEY_REPEAT);

	}
#endif

	srv_wap_prov_install_bookmark(SRV_WAP_PROF_SUCCESS);
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_free_proxy_app_nodes
* DESCRIPTION
*  This API frees all the memory used to create a profile.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_free_proxy_app_nodes(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S8 i = 0, j = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_FREE_APP_PROXY_NODES);

	while (i < SRV_WAP_PROV_MAX_PROFILE_COUNT && g_srv_wap_prov_cntx.proxy_list[i] != NULL  )
	{
		srv_wap_prof_mem_free(g_srv_wap_prov_cntx.proxy_list[i]);
		g_srv_wap_prov_cntx.proxy_list[i] = NULL;
		i++;
	}
	i = 0;
	while (i < SRV_WAP_PROV_MAX_PROFILE_COUNT && g_srv_wap_prov_cntx.app_list[i] != NULL)
	{
		while (j < SRV_WAP_PROV_MAX_TO_PROXY && g_srv_wap_prov_cntx.app_list[i]->app_to_proxy[j] != NULL)
		{
			srv_wap_prof_mem_free(g_srv_wap_prov_cntx.app_list[i]->app_to_proxy[j]);
			g_srv_wap_prov_cntx.app_list[i]->app_to_proxy[j] = NULL;
			j++;
		}
		j = 0;
		while (j < SRV_WAP_PROV_MAX_BOOKMARK_COUNT && g_srv_wap_prov_cntx.app_list[i]->bookmark[j] != NULL)
		{
			srv_wap_prof_mem_free(g_srv_wap_prov_cntx.app_list[i]->bookmark[j]);
			g_srv_wap_prov_cntx.app_list[i]->bookmark[j] = NULL;
			j++;
		}
		srv_wap_prof_mem_free(g_srv_wap_prov_cntx.app_list[i]);
		g_srv_wap_prov_cntx.app_list[i] = NULL;
		i++;
	}
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prov_update_remaining_profile_count
* DESCRIPTION
*  
* PARAMETERS
*  void
*  status(?)       [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_update_remaining_profile_count(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if(g_srv_wap_prof_cntx.profile_activated_bkm_flag == MMI_FALSE) // When first time only the profile is activated
	{
		g_srv_wap_prov_cntx.profile_count--;
		g_srv_wap_prov_cntx.crnt_prof_index++;
		g_srv_wap_prov_cntx.crnt_bkm_or_mms_setting_index++;
		if (SRV_WAP_PROV_TYPE_USIM == g_srv_wap_prov_cntx.provisioning_type)
		{
			if (g_srv_wap_prov_cntx.crnt_prof_index == SRV_WAP_PROF_MAX_SIM_PROFILES)
			{
				/* Put remaining profile count as 0 as MAX sim profile count reached. */
				g_srv_wap_prov_cntx.profile_count = 0;
				/* This would reset and send status. */
			}
		}
	}
	else
	{
		g_srv_wap_prof_cntx.profile_activated_bkm_flag = MMI_FALSE;
	}
}



/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_install_bookmark
* DESCRIPTION
*  Installs bookmark if present.
* PARAMETERS
*  result      [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_install_bookmark(srv_wap_prof_result_enum result)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_BOOL done_flag = MMI_FALSE;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* Change status to ready. */
	g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY; /* MAUI_01080371 */

	if (SRV_WAP_PROF_SUCCESS != result)
	{

		if (SRV_WAP_PROF_MEM_FULL_ERR == result)
		{
			srv_wap_prov_update_provisioning_response_to_cca( SRV_WAP_PROF_PROV_RESULT_SKIPPED);
		}
		else
		{
			srv_wap_prov_update_provisioning_response_to_cca(SRV_WAP_PROF_PROV_RESULT_INVALID);
		}


		/* MAUI_01746737 start */

		/* MAUI_01746737 ends */

	}
	if ((SRV_WAP_PROF_SUCCESS == result) || (SRV_WAP_PROF_MEM_FULL_ERR != result))
	{
		/* OK to send more bookmarks. */
		if (g_srv_wap_prov_cntx.status_sent)
		{
			return;
		}
		if (g_srv_wap_prov_cntx.crnt_profile_bookmark_idx <
			g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark_count)
		{
			if (NULL ==
				(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->
				bookmark[g_srv_wap_prov_cntx.crnt_profile_bookmark_idx]))
			{
				ASSERT(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->
					bookmark[g_srv_wap_prov_cntx.crnt_profile_bookmark_idx]);
				done_flag = MMI_TRUE;
				goto done;
			}
			MMI_TRACE(
				SRV_WAP_PROF_TRC_GRP9,
				TRC_MMI_WAP_PROF_PROV_INSTALL_BOOKMARK,
				g_srv_wap_prov_cntx.crnt_profile_bookmark_idx);

			g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_WAITING;   /* MAUI_01080371 */

			srv_wap_prov_add_bookmark(
				g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark[g_srv_wap_prov_cntx.crnt_profile_bookmark_idx]->bm_title,
				g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->bookmark[g_srv_wap_prov_cntx.crnt_profile_bookmark_idx]->bm_url);

			/* A bookmark once sent will not be sent again. */
			g_srv_wap_prov_cntx.crnt_profile_bookmark_idx++;
		}
		else
		{
			/* all Bookmarks finished. */
			done_flag = MMI_TRUE;
		}
	}
	else
	{
		/* Memory error dont send more bookmarks. */
		/* Continue with other settings. */
		done_flag = MMI_TRUE;
	}

done:
	if (MMI_TRUE == done_flag)
	{
		/* install mms settings if there are any. */
		srv_wap_prov_install_mms_setting();
	}
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prov_install_mms_setting
* DESCRIPTION
*  installs MMS settings.
* PARAMETERS
*  void
*  newConfigDoc(?)     [IN]        
* RETURNS
*  void
*****************************************************************************/
static void srv_wap_prov_install_mms_setting(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->mms_setting_data_p)
	{
		g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_WAITING;       /* MAUI_01080371 */
		srv_wap_prov_save_ota_mms_setting(g_srv_wap_prov_cntx.profile_list[g_srv_wap_prov_cntx.crnt_prof_index]->
			mms_setting_data_p);
	}
	else
	{

		{
			srv_wap_prov_provisioning_ui_done(MMI_FALSE);
		}
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_app_continue_provisioning
* DESCRIPTION
*  Continues the provisioning job where it was left.
* PARAMETERS
*  void
*  [IN](?)
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_app_continue_provisioning(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (SRV_WAP_PROF_PROFILE_SRC_OTA_PROV == g_srv_wap_prof_cntx.profile_content_src)
	{
		srv_wap_prov_install_bookmark(SRV_WAP_PROF_SUCCESS);
	}
	else
	{
		ASSERT(SRV_WAP_PROF_PROFILE_SRC_END != g_srv_wap_prof_cntx.profile_content_src);
		/* DM or USIM provisioning */
		/* Send response using Done API. */
		srv_wap_prov_provisioning_ui_done(MMI_FALSE);
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_wap_prov_save_mms_setting_rsp_callback
* DESCRIPTION
*  Callback function called by WAP2 to give result.
*  
*  PARAMETERS:
*  result      [IN]        
*****************************************************************************/
void srv_wap_prov_save_mms_setting_rsp_callback(srv_wap_prof_result_enum result)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_INSTALL_MMS_SETTING_RESULT, result);

	g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY; /* MAUI_01080371 */


	if (SRV_WAP_PROF_SUCCESS == result)
	{
		srv_wap_prov_update_provisioning_response_to_cca( SRV_WAP_PROF_PROV_RESULT_SUCCESS);
	}
	else
	{
		srv_wap_prov_update_provisioning_response_to_cca( SRV_WAP_PROF_PROV_RESULT_INVALID);
	}


	{
		srv_wap_prov_provisioning_ui_done(MMI_FALSE);
	}
}



/*****************************************************************************
* FUNCTION
* mmi_wap_prov_update_provisioning_response_to_cca
* DESCRIPTION
*  This API is used to set the correct response to SRV_CCA.
* PARAMETERS
* srv_wap_prof_prov_result_enum
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prov_update_provisioning_response_to_cca( srv_wap_prof_prov_result_enum  status)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/


	if(g_srv_wap_prof_cntx.setting_installed < status)
	{
		g_srv_wap_prof_cntx.setting_installed =  status;
	}

}


#endif /* WAP_SUPPORT */
#endif /* PROV_SUPPORT*/
