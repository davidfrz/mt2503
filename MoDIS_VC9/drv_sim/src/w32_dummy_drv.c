/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   w32_dummy_drv.c
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *   Driver dummy functions for WIN32 environment
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <windows.h>
#include <math.h>
#include "time.h"

#include "kal_release.h"

#include "stack_common.h"
#include "stack_msgs.h"
#include "app_ltlcom.h"

#include "stacklib.h"
#include "stack_timer.h"

#include "syscomp_config.h"
#include "task_config.h"

#include "device.h"
//#include "w32_timers.h"
#include "l4a.h"
#include "uart_sw.h"
#include "drvsignals.h"
//#include "l1audio.h"

//#include "alerter_sw.h"
#include "init.h"

#include "lcd_if.h"
#include "lcm_if.h"
//#include "gpio_sw.h"
#include "motion_sensor.h"
//#include "gpt_sw.h"


//#include "pwm_sw.h"
//#include "rwg_sw.h"
//#include "touch_panel.h"

#include "E_compass_sensor.h"

#ifdef TV_OUT_SUPPORT
#include "tv_out.h"
#endif

#include "custom_hw_default.h"
#include "mm_intmem.h"
#include "dcl.h"
#include "dcl_pmu_sw.h"

extern void w32_audio_init(void);
// main lcd backlight
extern int		mainlcd_backlight_level;
extern void w32_light_black_draw_mmi(void);


// ==================== GPT APIs (gpt_sw.h) ===================================
//void GPT_clock(kal_uint8 timerNum ,gpt_clock clock){}
void GPT_ResetTimer(kal_uint8 timerNum,kal_uint16 countValue,kal_bool autoReload){}
void GPT_Start(kal_uint8 timerNum){}
void GPT_Stop(kal_uint8 timerNum){}
void GPT_init(kal_uint8 timerNum, void (*GPT_Callback)(void)){}
void GPT_LISR(void){}
kal_uint8 GPTI_GetHandle(kal_uint8 *handle){return 0;}
kal_uint8 GPTI_ReleaseHandle(kal_uint8 *handle){return 1;}
kal_uint16 GPT_return_current_count(void){return 0;}
void GPT3_Init(void){}
// The following are implemented in w32_audio.c begin
//void GPTI_StartItem(void){}
//void GPTI_StopItem(void){}
// The following are implemented in w32_audio.c end
// ==================== GPT APIs (gpt_sw.h) ===================================
// ==================== Touch panel APIs (touch_panel.h) ======================
/*
void touch_panel_enable(kal_bool enable){}
kal_bool touch_panel_get_event(TouchPanelEventStruct *touch_data){return KAL_FALSE;}
void touch_panle_conf_timeout_period(kal_uint32 longtap,
                                     kal_uint32 repeat,
                                     kal_uint32 handwriting_longtap){}
void touch_panle_conf_sample_period(kal_uint32 low, kal_uint32 high){}
void touch_panel_flush(void){}
void touch_panel_start_cali(TouchPanelCoordStruct *point, kal_uint16 num){}
void touch_panel_stop_cali(void){}
void touch_panel_read_cali(TouchPanelCaliStruct *cali){}
void touch_panel_set_cali(TouchPanelCaliStruct cali){}
void touch_panel_reset(kal_bool skip_unrelease_enable){}
void touch_panel_reset_handwriting(void){}
void touch_panel_conf_move_offset(kal_uint16 pen_offset, kal_uint16 stroke_offset,
                                  kal_uint16 longtap_pen_offset,
                                  kal_uint16 longtap_stroke_offset){}
void touch_panel_conf_handwriting(TouchPanelHandAreaStruct *area, kal_uint16 n,
                              TouchPanelHandAreaStruct  *ext_area){}
void touch_panel_cb_registration (TP_EVENT_FUNC function, void *parameter){}

void touch_start_longtap(void){}
void touch_panel_event_cb(void *parameter){}
void touch_panel_event_hdr(void){}
void touch_panel_sendilm(void *para, Touch_Panel_Event_enum state){}
void touch_panel_longtap_cb(void *parameter){}
void touch_panel_init(void){}
void touch_panel_stroke_hdr(void){}
void touch_excute_cali(kal_int16 x_adc, kal_int16 y_adc){}
void touch_panel_stroke_cb(void *parameter){}
void touch_panel_up_hdr(void){}
void touch_start_handwriting_longtap(void){}
void tp_data_pop(Touch_Panel_Event_enum event, kal_int16 x, kal_int16 y){}
void touch_panel_repeat_cb(void *parameter){}
kal_bool touch_panel_adc_to_coordinate(kal_int16 *x, kal_int16 *y){return KAL_FALSE;}
void touch_panel_down_hdr(void){}
void touch_panel_read_adc(kal_int16 *x, kal_int16 *y){}
*/
void tp_task_create(void){}		// Is this necessary?
void tp_task_main(void){}			// Is this necessary?
// ==================== DCL common APIs (dcl_common.h) ======================
DCL_HANDLE DCL_Open(DCL_DEV dev, DCL_FLAGS flags){return DCL_HANDLE_INVALID;}
DCL_STATUS DCL_Control (
	DCL_HANDLE       	device_handle,
	DCL_CTRL_CMD       cmd, 
    void*   arg){
	return STATUS_FAIL;
}

DCL_STATUS DCL_Close(DCL_HANDLE      device_handle){
	return STATUS_FAIL;
}

DCL_STATUS DCL_RegisterCallback(
	DCL_HANDLE		device_handle,
	DCL_EVENT		event,
	DCL_CALLBACK	callback,
	void*			user_data,
	DCL_USER_ID  	user_id){
	return STATUS_FAIL;
}
	
DCL_STATUS DCL_Query(
	DCL_HANDLE     device_handle,
	void*   		handle_status){
	return STATUS_FAIL;
}
		 
DCL_STATUS  DCL_Read(
	DCL_HANDLE   	device_handle, 
	DCL_BUFF*       buf, 
	DCL_BUFF_LEN 	read_len, 
	DCL_BUFF_LEN *	returned_len,
	DCL_OPTIONS 	options){
	return STATUS_FAIL;
}
	
DCL_STATUS  DCL_Write(
	DCL_HANDLE 		device_handle, 
	DCL_BUFF* 		buf, 
	DCL_BUFF_LEN 	write_len, 
	DCL_BUFF_LEN* 	written_len,
	DCL_OPTIONS 	options){
	return STATUS_FAIL;
}

DCL_MODULE_TYPE DCL_GetDestinationID(DCL_USER_ID user_id){
	return 0;
}
// ==================== Touch panel APIs (touch_panel.h) ======================
// ==================== I2C APIs (dcl_i2c.h) ===================================
DCL_STATUS DclSI2C_Initialize(void){return STATUS_FAIL;}
DCL_HANDLE DclSI2C_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclSI2C_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSI2C_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSI2C_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_FAIL;}
DCL_STATUS DclSI2C_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSI2C_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_FAIL;}
DCL_STATUS DclSI2C_Close(DCL_HANDLE handle){return STATUS_FAIL;}
// ==================== I2C APIs (dcl_i2c.h) ===================================
// ==================== AUX APIs (dcl_aux.h) ===================================
DCL_STATUS DclAUX_Initialize(void){return STATUS_FAIL;}
DCL_HANDLE DclAUX_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclAUX_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclAUX_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclAUX_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_FAIL;}
DCL_STATUS DclAUX_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_UNSUPPORTED;}
DCL_STATUS DclAUX_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_FAIL;}
DCL_STATUS DclAUX_Close(DCL_HANDLE handle){return STATUS_FAIL;}
// ==================== AUX APIs (dcl_aux.h) ===================================
// ==================== ADC APIs (dcl_adc.h) ===================================
DCL_STATUS DclSADC_Initialize(void){return 0;}
DCL_HANDLE DclSADC_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclSADC_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return 0;}
DCL_STATUS DclSADC_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return 0;}
DCL_STATUS DclSADC_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return 0;}
DCL_STATUS DclSADC_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return 0;}
DCL_STATUS DclSADC_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return 0;}
DCL_STATUS DclSADC_Close(DCL_HANDLE handle){return 0;}
DCL_STATUS DclHADC_Initialize(void){return 0;}
DCL_HANDLE DclHADC_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclHADC_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return 0;}
DCL_STATUS DclHADC_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return 0;}
DCL_STATUS DclHADC_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return 0;}
DCL_STATUS DclHADC_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return 0;}
DCL_STATUS DclHADC_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return 0;}
DCL_STATUS DclHADC_Close(DCL_HANDLE handle){return 0;}
// ==================== ADC APIs (dcl_adc.h) ===================================
// ==================== RTC APIs (dcl_rtc.h) ===================================
kal_bool w32_is_poweron=KAL_FALSE;
static time_t poweron_time;
static time_t poweron_now;
typedef struct __rtc 
{
	kal_uint8		rtc_sec;    /* seconds after the minute   - [0,59]  */
	kal_uint8		rtc_min;    /* minutes after the hour     - [0,59]  */
	kal_uint8		rtc_hour;   /* hours after the midnight   - [0,23]  */
	kal_uint8		rtc_day;    /* day of the month           - [1,31]  */
	kal_uint8		rtc_mon;    /* months 		               - [1,12] */
	kal_uint8		rtc_wday;   /* days in a week 		      - [1,7] */
	kal_uint8		rtc_year;   /* years                      - [0,127] */
} t_rtc;

void RTC_Config(kal_uint8 AL_EN,kal_uint8 TC_EN){}
void RTC_InitTC_Time(t_rtc *rtctime)
{
	struct tm when;

	when.tm_sec     = rtctime->rtc_sec  ;
	when.tm_min     = rtctime->rtc_min  ;
	when.tm_hour    = rtctime->rtc_hour ;
	when.tm_mday    = rtctime->rtc_day  ;
	when.tm_mon     = rtctime->rtc_mon  -1;
	when.tm_wday    = rtctime->rtc_wday -1;
	when.tm_year    = rtctime->rtc_year +100;

	poweron_time = mktime(&when);
	time(&poweron_now);
}
void RTC_GetTime(t_rtc *rtctime )
{
	struct tm when;
	time_t now;

	time(&now);
	now = (now-poweron_now) + poweron_time;


	if (NULL != localtime(&now)){
		when = *localtime(&now);

		rtctime->rtc_sec = when.tm_sec;
		rtctime->rtc_min = when.tm_min;
		rtctime->rtc_hour = when.tm_hour;
		rtctime->rtc_day = when.tm_mday;
		rtctime->rtc_mon = when.tm_mon+1;
		rtctime->rtc_wday = when.tm_wday+1;

		rtctime->rtc_year = when.tm_year-100;
	}else{
		// When locatime return NULL, we return default date
		rtctime->rtc_sec = 0;
		rtctime->rtc_min = 0;
		rtctime->rtc_hour = 0;
		rtctime->rtc_day = 1;
		rtctime->rtc_mon = 1;
		rtctime->rtc_wday = 0;
		rtctime->rtc_year = 4;
	}
}
kal_bool RTC_is_Time_Valid(t_rtc *time)
{
   if((time->rtc_sec>59) ||
      (time->rtc_min>59) ||
      (time->rtc_hour>23)||
      (time->rtc_day>31) || (time->rtc_day == 0) ||
      (time->rtc_wday>7) || (time->rtc_wday == 0) ||
      (time->rtc_mon>12) || (time->rtc_mon == 0)  ||
      (time->rtc_year>127))
   {
      return KAL_FALSE;
   }
   return KAL_TRUE;
}
void CALLBACK RTC_TCintr(HWND hwnd,UINT uMsg,UINT idEvent, DWORD dwTime)
{
	ilm_struct *RTC_ilm;
	RTC_Primitive *RTC_Prim;

	if(!w32_is_poweron) return;


	RTC_ilm = allocate_ilm(MOD_RTC_HISR);
	RTC_Prim = (RTC_Primitive*)
				construct_local_para(sizeof(RTC_Primitive), TD_CTRL);
	RTC_Prim->rtc_ind = RTC_TC_IND;
	RTC_ilm->src_mod_id = MOD_RTC_HISR;
	RTC_ilm->dest_mod_id = MOD_UEM;
	RTC_ilm->sap_id = DRIVER_PS_SAP;
	RTC_ilm->msg_id = MSG_ID_DRVUEM_RTC_PERIOD_IND;
	RTC_ilm->local_para_ptr = (local_para_struct *)RTC_Prim;
	RTC_ilm->peer_buff_ptr = NULL;
	msg_send_ext_queue(RTC_ilm);
}
DCL_STATUS DclRTC_Initialize(void){return 0;}
DCL_HANDLE DclRTC_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclRTC_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return 0;}
DCL_STATUS DclRTC_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return 0;}
DCL_STATUS DclRTC_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return 0;}
DCL_STATUS DclRTC_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return 0;}
DCL_STATUS DclRTC_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data)
{
    DCL_STATUS return_status;

	switch (cmd)
	{

		case RTC_CMD_SET_TIME:
		{
			t_rtc rtc;
			RTC_CTRL_SET_TIME_T *prSetTime;
			prSetTime = &(data->rSetTime);
            
			rtc.rtc_sec = prSetTime->u1Sec;
			rtc.rtc_min = prSetTime->u1Min;
			rtc.rtc_hour = prSetTime->u1Hour;
			rtc.rtc_day = prSetTime->u1Day;
			rtc.rtc_mon = prSetTime->u1Mon;
			rtc.rtc_wday = prSetTime->u1WDay;
			rtc.rtc_year = prSetTime->u1Year;
            
			RTC_InitTC_Time(&rtc);
			return_status = STATUS_OK;
		}
		break;
		case RTC_CMD_GET_TIME:
		{
			t_rtc rtc;
			RTC_CTRL_GET_TIME_T *prGetTime;
			prGetTime = &(data->rGetTime);
			RTC_GetTime(&rtc);  

			prGetTime->u1Sec = rtc.rtc_sec;
			prGetTime->u1Min = rtc.rtc_min;
			prGetTime->u1Hour = rtc.rtc_hour;
			prGetTime->u1Day = rtc.rtc_day;
			prGetTime->u1Mon = rtc.rtc_mon;
			prGetTime->u1WDay = rtc.rtc_wday;
			prGetTime->u1Year = rtc.rtc_year;

			return_status = STATUS_OK;
		}
		break;		
        case RTC_CMD_IS_TIME_VALID:
        {
			t_rtc rtc;
			RTC_CTRL_IS_TIME_VALID_T *prIsTimeValid;
			prIsTimeValid = &(data->rIsTimeValid);
            
			rtc.rtc_sec = prIsTimeValid->u1Sec;
			rtc.rtc_min = prIsTimeValid->u1Min;
			rtc.rtc_hour = prIsTimeValid->u1Hour;
			rtc.rtc_day = prIsTimeValid->u1Day;
			rtc.rtc_mon = prIsTimeValid->u1Mon;
			rtc.rtc_wday = prIsTimeValid->u1WDay;
			rtc.rtc_year = prIsTimeValid->u1Year;

            prIsTimeValid->isTimeValid = (DCL_BOOLEAN)RTC_is_Time_Valid(&rtc);

            return_status = STATUS_OK;
        }
        break;
		default:
			return_status = STATUS_INVALID_CMD;
		break;        		
    }	
	return return_status;	
}

DCL_STATUS DclRTC_Close(DCL_HANDLE handle){return 0;}
// ==================== RTC APIs (dcl_rtc.h) ===================================
// ==================== GPIO APIs (dcl_gpio.h) ===================================
DCL_STATUS DclGPIO_Initialize(void){return STATUS_FAIL;}
DCL_HANDLE DclGPIO_Open(DCL_DEV dev, DCL_FLAGS flags){ return DCL_HANDLE_INVALID;}
DCL_STATUS DclGPIO_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclGPIO_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclGPIO_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_UNSUPPORTED;}
DCL_STATUS DclGPIO_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_FAIL;}
DCL_STATUS DclGPIO_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_FAIL;}
DCL_STATUS DclGPIO_Close(DCL_HANDLE handle){return STATUS_FAIL;}
// ==================== GPT APIs (dcl_gpt.h) ===================================
DCL_STATUS DclSGPT_Initialize(void){return STATUS_UNSUPPORTED;}
DCL_HANDLE DclSGPT_Open(DCL_DEV dev, DCL_FLAGS flags){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSGPT_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSGPT_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSGPT_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSGPT_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSGPT_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSGPT_Close(DCL_HANDLE *handle){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_Initialize(void){return STATUS_UNSUPPORTED;}
DCL_HANDLE DclFGPT_Open(DCL_DEV dev, DCL_FLAGS flags){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_UNSUPPORTED;}
DCL_STATUS DclFGPT_Close(DCL_HANDLE handle){return STATUS_UNSUPPORTED;}
// ==================== WDT APIs (dcl_wdt.h) ===================================
DCL_STATUS DclWDT_Initialize(void){return STATUS_UNSUPPORTED;}
DCL_HANDLE DclWDT_Open(DCL_DEV dev, DCL_FLAGS flags){return STATUS_UNSUPPORTED;}
DCL_STATUS DclWDT_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclWDT_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclWDT_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_UNSUPPORTED;}
DCL_STATUS DclWDT_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_UNSUPPORTED;}
DCL_STATUS DclWDT_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_UNSUPPORTED;}
DCL_STATUS DclWDT_Close(DCL_HANDLE handle){return STATUS_UNSUPPORTED;}
// ==================== PWMAPIs (dcl_pwm.h) ===================================
DCL_STATUS DclPWM_Initialize(void){return 0;}
DCL_STATUS DclPWM_Close(DCL_HANDLE handle){return 0;}
DCL_STATUS DclPWM_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return 0;}
DCL_STATUS DclPWM_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return 0;}
DCL_HANDLE DclPWM_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclPWM_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return 0;}
// ==================== touch panel APIs (dcl_sts.h) ===================================
DCL_STATUS DclSTS_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSTS_Initialize(void){return STATUS_UNSUPPORTED;}
DCL_HANDLE DclSTS_Open(DCL_DEV dev, DCL_FLAGS flags){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSTS_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN *buf_len, DCL_OPTIONS options){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSTS_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSTS_Close(DCL_HANDLE handle){return STATUS_UNSUPPORTED;}
DCL_STATUS DclSTS_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_UNSUPPORTED;}
// ==================== USBAPIs (dcl_usb_dev.h) ===================================
DCL_HANDLE DclUSB_DRV_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;};
DCL_STATUS DclUSB_DRV_Close(DCL_HANDLE handle){return 0;};
DCL_STATUS DclUSB_DRV_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return 0;};
// ==================== PXS APIs (dcl_pxs.h) ===================================
DCL_STATUS DclPXS_Initialize(void)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_HANDLE DclPXS_Open(DCL_DEV dev, DCL_FLAGS flags)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_STATUS DclPXS_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_STATUS DclPXS_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_STATUS DclPXS_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_STATUS DclPXS_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_STATUS DclPXS_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data)
{
	return STATUS_DEVICE_NOT_EXIST;
}
DCL_STATUS DclPXS_Close(DCL_HANDLE handle)
{
	return STATUS_DEVICE_NOT_EXIST;
}
// ==================== Motion Sensor APIs (motion_sensor.h) ==================
void motion_sensor_complete_cali(void){}
void motion_sensor_cancel_cali(void){}
void motion_sensor_start_cali(void){}
void motion_sensor_read_cali(MotionSensorCaliStruct *cali){}
void motion_sensor_set_cali(MotionSensorCaliStruct cali){}
kal_bool motion_sensor_power(kal_bool enable){return KAL_TRUE;}
void motion_sensor_conf_sample_period(kal_uint32 period){}
void motion_sensor_flush_buff(void){}
void motion_sensor_cb_registration(MS_DATA_FUNC cb_fun, void *para){}
void motion_sensor_sample(kal_bool enable){}
void motion_sensor_conf_filter(kal_uint32 acc_offset){}
kal_bool motion_sensor_get_data(MotionSensorDataStruct  *ms_data){return KAL_FALSE;}
void motion_sensor_int_cb_registration(MS_INT_CB_FUNC low_g_cb_fun, MS_INT_CB_FUNC high_g_cb_fun){}
void motion_sensor_int_config(kal_uint32 low_g_level, kal_uint32 high_g_level,
                              kal_uint32 low_g_debounce, kal_uint32 high_g_debounce){}
void motion_sensor_int_enable(kal_bool enable){}
// ==================== Motion Sensor APIs (motion_sensor.h) ==================
// ==================== Keypad APIs (keypad_sw.h) =============================
kal_bool PowerKey_Pressed(void){return KAL_FALSE;}
kal_bool kbd_is_mutiple_key(kal_uint8 key){return KAL_FALSE;}
void Jogball_Reset(void){}
void keypad_customize_init(void){}
kal_bool kbd_IsKeyPressed(kal_uint8 key){return KAL_FALSE;}
kal_uint32 Kbd_GetKeyEventCount(){return 0;}
// The following are implemented in w32_keys.c begin
//kal_bool kbd_key_det_mode_switch(kbd_key_det_mode mode);
//kal_bool kbd_IsKeyButtonSupported(kal_uint8 key);
// The following are implemented in w32_keys.c end
// ==================== Keypad APIs (keypad_sw.h) =============================
// ==================== BMT APIs (bmt.h) ======================================
void adc_sche_readback(void* msg_ptr){}
void adc_sche_measure(void* msg_ptr){}
kal_int32 volt2temp(kal_int32 _volt){return 0;}
//kal_uint8 custom_adc_get_channel(adc_channel_type type){return 0;}  ==> In \mcu\custom\...\adc_channel.c
//kal_bool bmt_support_usb_charge(void){return KAL_FALSE;}  ==> In \mcu\custom\...\chr_parameter.c
//VolToTempStruct *bmt_get_customized_volTOtemp(void);				 TBD
//bmt_customized_struct *bmt_get_customized_chr_para(void);			 TBD
//kal_int32 bmt_get_chr_usb_detect_volt(void);							 TBD
//kal_int32 bmt_get_chr_usb_detect_volt(kal_uint8 chann,double adcVoltage);	 TBD
void adc_sche_set_timer_page_align(kal_bool page_align){}
kal_uint8 adc_sche_create_object(module_type ownerid, kal_uint8 adc_channel,kal_uint32 period, kal_uint8 evaluate_count, kal_bool send_primitive){return 0;}
//extern bmt_usb_charger_enum IsUSBorCharger(void);								 TBD
void adc_pwrdown_enable(void){}
void adc_pwrdown_disable(void){}
kal_bool bmt_is_wdt_power(void){return KAL_FALSE;}
// ==================== BMT APIs (bmt.h) ======================================
// ==================== Ecompass APIs (ECompassProt.h) ==================
void e_compass_sensor_power_on(void){}
void e_compass_sensor_power_off(void){}
void e_compass_enable(kal_bool enable){}
void e_compass_sensor_start_cali(void){}
void e_compass_sensor_cancel_cali(void){}
void e_compass_sensor_data_cb_registration(EC_DATA_FUNC cb_fun,void *para){}
void e_compass_sensor_cali_cb_registration(EC_CALI_FUNC cb_fun,void *para){}
kal_bool e_compass_sensor_get_data(E_CompassSensorDataStruct *e_compass_data){}
void e_compass_sensor_manual_init(void){}
kal_bool ec_task_create(comptask_handler_struct **handle){}
// ==================== B2PSI APIs (b2psi_sw.h) ===============================
void B2PSI_init(void){}
kal_uint8 B2PSI_read(kal_uint16 register_index){return 0;}
void B2PSI_write(kal_uint8 data, kal_uint16 register_index){}
void B2PSI_write_fast(kal_uint8 data, kal_uint16 register_index){}
// ==================== B2PSI APIs (b2psi_sw.h) ===============================
// ==================== ADC APIs (adc.h) ======================================
kal_uint16 ADC_GetData(kal_uint8 sel){return 0;}				// TBD, is it a public API?
// ==================== ADC APIs (adc.h) ======================================
/*
// ==================== PWM APIs (rwg.h, pwm_sw.h) ============================
void PWM_Init(void){}
kal_bool PWM_Open(kal_uint8 owner, kal_uint32 pwm_num){return KAL_TRUE;}
kal_bool PWM_Seq_Open(kal_uint8 owner){return KAL_TRUE;}
kal_bool PWM_Close(kal_uint8 owner, kal_uint32 pwm_num){return KAL_TRUE;}
kal_bool PWM_Seq_Close(kal_uint8 owner){return KAL_TRUE;}
void PWM_CLK_Init(kal_uint8 owner, kal_uint32 pwm_num, kal_uint32 clk_sel, kal_uint32 clk_div){}
kal_bool PWM_Configure(kal_uint8 owner, kal_uint32 pwm_num, kal_uint32 mode, void *para){return KAL_TRUE;}
void PWM_Start(kal_uint8 owner, kal_uint32 pwm_num){}
void PWM_Stop(kal_uint8 owner, kal_uint32 pwm_num){}
void PMW_Set_Delay(kal_uint8 owner, kal_uint32 pwm_num, kal_uint32 clk_sel, kal_uint16 delay_cnt){}
void PWM_Seq_Start(kal_uint8 owner, kal_uint8 en_cnt){}
void PWM_Seq_Stop(kal_uint8 owner){}
void PWM_Set_Buf_Valid(kal_uint8 owner, kal_uint32 pwm_num, kal_uint32 *buf_addr, kal_uint16 buf_size, kal_bool is_buf0){}
void PWM3_Configure(kal_uint32 freq, kal_uint8 duty){}
void PWM3_Start(void){}
void PWM3_Stop(void){}
void PWM4_Configure(kal_uint32 freq, kal_uint8 duty){}
void PWM5_Configure(kal_uint32 freq, kal_uint8 duty){}
void PWM6_Configure(kal_uint32 freq, kal_uint8 duty){}
void PWM4_Start(void){}
void PWM5_Start(void){}
void PWM6_Start(void){}
void PWM4_Stop(void){}
void PWM5_Stop(void){}
void PWM6_Stop(void){}
kal_uint8  PMW4_GetCurrentDuty(void){return 0;}
kal_uint32 PMW4_GetCurrentFreq(void){return 0;}
kal_uint8  PMW5_GetCurrentDuty(void){return 0;}
kal_uint32 PMW5_GetCurrentFreq(void){return 0;}
kal_uint8  PMW6_GetCurrentDuty(void){return 0;}
kal_uint32 PMW6_GetCurrentFreq(void){return 0;}
kal_uint8  PMW1_GetCurrentDuty(void){return 0;}
kal_uint32 PMW1_GetCurrentFreq(void){return 0;}
kal_uint8  PMW2_GetCurrentDuty(void){return 0;}
kal_uint32 PMW2_GetCurrentFreq(void){return 0;}
void PWM_Config_Freq_Steps(kal_uint8 owner, kal_uint32 pwm_num, kal_uint32 freq, kal_uint16 steps){}
void PWM_Set_Duty(kal_uint8 owner, kal_uint32 pwm_num, kal_uint16 duty){}
*/
void PWM_level(kal_uint8 level){}
void PWM2_level(kal_uint8 level){}
void PWM3_level(kal_uint8 level){}
void PWM4_level(kal_uint8 level){}
void PWM5_level(kal_uint8 level){}
void PWM6_level(kal_uint8 level){}
kal_bool custom_cfg_gpio_set_level_modis(kal_uint8 gpio_dev_type, kal_uint8 gpio_dev_level)
{
	switch(gpio_dev_type)
	{
		case GPIO_DEV_LED_MAINLCD:
		{
			mainlcd_backlight_level = gpio_dev_level +4; // from 4 ~ 9
			w32_light_black_draw_mmi();
			break;
		}
		default:
			break;
	}
	return KAL_TRUE;
}
/*
kal_uint8 PWM1_GetCurrentLevel(void){return 0;}
kal_uint8 PWM2_GetCurrentLevel(void){return 0;}
kal_uint8 PWM3_GetCurrentLevel(void){return 0;}
kal_uint8 PWM4_GetCurrentLevel(void){return 0;}
kal_uint8 PWM5_GetCurrentLevel(void){return 0;}
kal_uint8 PWM6_GetCurrentLevel(void){return 0;}
#if !defined(DRV_PWM_RWG)		// OLD PWM functions
void PWM2_Init(PWMClock_SEL clk_sel, PWMClock_DIV Clock_div){}
void PWM3_Init(PWMClock_SEL clk_sel,PWMClock_DIV Clock_div){return;}
#endif // #if !defined(DRV_PWM_RWG)

kal_uint8  PMW3_GetCurrentDuty(void){return 0;}
kal_uint32 PMW3_GetCurrentFreq(void){return 0;}

*/
// The following are implemented in \mcu\custom\common\custom_em_dummyDrv.c begin ==
//void PWM1_Configure(void){}
//void PWM2_Configure(void){}
//void PWM1_Start(void){}
//void PWM1_Stop(void){}
//void PWM2_Start(void){}
//void PWM2_Stop(void){}
// The following are implemented in \mcu\custom\common\custom_em_dummyDrv.c end ====
// ==================== PWM APIs (rwg.h, pwm_sw.h) ============================
// ==================== Alerter APIs (alerter_sw.h) ===========================
//ALterNoteStruct ALterNote;
// The following are implemented in w32_uart.c begin ==========================
//kal_uint16 UART_PutBytes(UART_PORT port, kal_uint8 *Buffaddr, kal_uint16 Length, module_type ownerid){return 0;}
//void UART_Close(UART_PORT port, module_type ownerid){}
//void UART_CtrlBreak(UART_PORT port, IO_level SBREAK, module_type ownerid){}
//void UART_ConfigEscape (UART_PORT port, kal_uint8 EscChar, kal_uint16 ESCGuardtime, module_type ownerid){}
//kal_uint16 UART_GetBytesAvail(UART_PORT port){return 0;}
//void PutUARTByte(UART_PORT port, kal_uint8 data){}
//void UART_SetOwner (UART_PORT port, module_type ownerid){}
//kal_bool UART_CheckTxAllSentOut(UART_PORT port){return KAL_FALSE;}
//void UART_CtrlDTR (UART_PORT port, IO_level SDTR, module_type ownerid){}
//void UART_SwitchPort(UART_PORT *APP_port, UART_PORT new_uart_port){}
//void UART_CtrlDCD(UART_PORT port, IO_level SDCD, module_type ownerid){}
//void UART_SetFlowCtrl(UART_PORT port, kal_bool XON, module_type ownerid){}
//void UART_SetBaudRate(UART_PORT port, UART_baudrate baud_rate, module_type ownerid){}
//void UART_SetDCBConfig(UART_PORT port, UARTDCBStruct *UART_Config, module_type ownerid){}
//kal_uint16 UART_GetBytes(UART_PORT port, kal_uint8 *Buffaddr, kal_uint16 Length, kal_uint8 *status, module_type ownerid){return 0;}
//kal_uint16 UART_SendData(UART_PORT port, kal_uint8 *Buffaddr, kal_uint16 Length,kal_uint8 mode,kal_uint8 escape_char, module_type ownerid ){return 0;}
//void UART_Purge(UART_PORT port, UART_buffer dir, module_type ownerid){}
//kal_uint8 GetUARTByte(UART_PORT port){return 0;}
//void UART_TurnOnPower(UART_PORT port, kal_bool enable){}
//kal_bool UART_Open(UART_PORT port, module_type ownerid){return KAL_FALSE;}
//void UART_ReadDCBConfig (UART_PORT port, UARTDCBStruct *DCB){}
//kal_bool UART_CheckTxBufferEmpty(UART_PORT port){return KAL_FALSE;}
/*
// The following are implemented in w32_uart.c end ============================
void ALERTER_Output(kal_uint8 outtype){}
void PlayAlterNotes(kal_bool (*GetNotecallbac)(BuzNoteStruct *Buz), void (*endofAlter)(void)){}
void StopAlterNotes(void){}
void SetBuzVolume(kal_uint8 volumn){}
void ALERTER_Config(ALMode mode, ALClock Clock){}
*/
void Alter_level(kal_uint8 level){}

kal_uint8 Alter_GetCurrentLevel(void){return 0;}
// The following are implemented in \mcu\custom\common\custom_em_dummyDrv.c begin ==
//void Alter_Start(void){}
//void Alter_Configure(kal_uint32 freq, kal_uint8 duty){}
//void Alter_Stop(void){}
// The following are implemented in \mcu\custom\common\custom_em_dummyDrv.c end ====
// ==================== Alerter APIs (alerter_sw.h) ===========================

// ==================== DCL PMU interface ===========================
DCL_STATUS DclPMU_Initialize(void){return STATUS_OK;}
DCL_HANDLE DclPMU_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclPMU_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_OK;}
DCL_STATUS DclPMU_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_OK;}
DCL_STATUS DclPMU_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_OK;}
DCL_STATUS DclPMU_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_OK;}
DCL_STATUS DclPMU_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data)
{
	switch(cmd)
	{	
		case BL_GET_SUPPORT_LEVEL:
	    {
            PMU_CTRL_BL_GET_SUPPORT_LEVEL *pBlCtrl = &(data->rPMUBlGetSupportLevel);            
#if defined(__MULTI_LEVEL_BACKLIGHT_SUPPORT__)
            pBlCtrl->blSupportLevel = PWM_MAX_BACKLIGHT_LEVEL;
#else
            pBlCtrl->blSupportLevel = PWM_MAX_LEVEL;
#endif // End of #if defined(__MULTI_LEVEL_BACKLIGHT_SUPPORT__)
        }
        break;
		default:				
		return STATUS_UNSUPPORTED;
		//break;
	}        
	return STATUS_OK;
}
DCL_STATUS DclPMU_Close(DCL_HANDLE handle){return STATUS_OK;}

DCL_STATUS DclPW_Initialize(void){return STATUS_OK;}
DCL_HANDLE DclPW_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS DclPW_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_OK;}
DCL_STATUS DclPW_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_OK;}
DCL_STATUS DclPW_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_OK;}
DCL_STATUS DclPW_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_OK;}
DCL_STATUS DclPW_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_OK;}
DCL_STATUS DclPW_Close(DCL_HANDLE handle){return STATUS_OK;}

DCL_STATUS Dcl_Chr_Det_Initialize(void){return STATUS_OK;}
DCL_HANDLE Dcl_Chr_Det_Open(DCL_DEV dev, DCL_FLAGS flags){return 0;}
DCL_STATUS Dcl_Chr_Det_ReadData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_OK;}
DCL_STATUS Dcl_Chr_Det_WriteData(DCL_HANDLE handle, DCL_BUFF *buff, DCL_BUFF_LEN buf_len, DCL_OPTIONS options){return STATUS_OK;}
DCL_STATUS Dcl_Chr_Det_Configure(DCL_HANDLE handle, DCL_CONFIGURE_T *configure){return STATUS_OK;}
DCL_STATUS Dcl_Chr_Det_RegisterCallback(DCL_HANDLE handle, DCL_EVENT event, PFN_DCL_CALLBACK callback){return STATUS_OK;}
DCL_STATUS Dcl_Chr_Det_Control(DCL_HANDLE handle, DCL_CTRL_CMD cmd, DCL_CTRL_DATA_T *data){return STATUS_OK;}
DCL_STATUS Dcl_Chr_Det_Close(DCL_HANDLE handle){return STATUS_OK;}
// ==================== DCL PMU interface end========================

// ==================== PWIC APIs (pwic.h) ====================================
#if defined(__DRV_UPMU_LDO_V1__)
// LDO CON0
DCL_STATUS ldo_set_enable(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_BOOL enable){return STATUS_OK;}
DCL_STATUS ldo_set_voltage(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_UINT32 vol){return STATUS_OK;}
void ldo_set_oc_auto_off(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_BOOL auto_off){}
void ldo_set_stb_enable(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_BOOL enable){}
void ldo_set_on_sel(PMU_LDO_BUCK_LIST_ENUM ldo, PMU_ON_SEL_ENUM sel){}
void ldo_set_ocfb_enable(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_BOOL enable){}
void ldo_set_ndis_enable(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_BOOL enable){}

//LDO CON1
void ldo_set_current_limit(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_UINT32 val){}

// LDO CON2
void ldo_set_oc_td(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_UINT32 sel){}
void ldo_set_stb_td(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_UINT32 sel){}
void ldo_set_ctrl_sel(PMU_LDO_BUCK_LIST_ENUM ldo, PMU_CTRL_LDO_CTRL_MODE_ENUM sel){}
void ldo_set_sim_gpio_en(PMU_LDO_BUCK_LIST_ENUM ldo, DCL_BOOL enable){}
void ldo_set_simio_drv(PMU_LDO_BUCK_LIST_ENUM ldo, kal_uint8 val){}
void ldo_set_bias(PMU_LDO_BUCK_LIST_ENUM ldo, kal_uint8 val){}
void ldo_set_srn(PMU_LDO_BUCK_LIST_ENUM ldo, kal_uint8 val){}
void ldo_set_srp(PMU_LDO_BUCK_LIST_ENUM ldo, kal_uint8 val){}
#endif //#if defined(__DRV_UPMU_LDO_V1__)

#if defined(__DRV_UPMU_BUCK_V1__)
// BUCK CON0
DCL_STATUS buck_set_enable(PMU_LDO_BUCK_LIST_ENUM buck, DCL_BOOL enable){return STATUS_OK;}
DCL_STATUS buck_set_voltage(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 vol){return STATUS_OK;}
void buck_set_rs(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 sel){}

//BUCK CON3
void buck_set_ical(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}
void buck_set_oc_td(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}
void buck_set_stb_td(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}

//BUCK CON5
void buck_set_ocfb_enable(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}
DCL_STATUS buck_set_sleep_voltage(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 vol){return STATUS_OK;}
void buck_set_burst_threshold(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 threshold){}
void buck_set_current_limit(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}
void buck_set_ocfb_en(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}
void buck_set_oc_auto_off(PMU_LDO_BUCK_LIST_ENUM buck, DCL_UINT32 val){}
void buck_set_adjcksel(PMU_LDO_BUCK_LIST_ENUM buck, kal_uint8 val){}
void buck_set_rzsel(PMU_LDO_BUCK_LIST_ENUM buck, kal_uint8 val){}
void buck_set_csr(PMU_LDO_BUCK_LIST_ENUM buck, kal_uint8 val){}
void buck_set_cks_prg(PMU_LDO_BUCK_LIST_ENUM buck, kal_uint8 val){}
#endif //#if defined(__DRV_UPMU_BUCK_V1__)

#if defined(__DRV_UPMU_VPA_V1__)
//VPA CON2
void vpa_set_votune0(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
void vpa_set_votune1(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
//VPA CON3
void vpa_set_votune2(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
void vpa_set_votune3(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
//VPA CON4
void vpa_set_votune4(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
void vpa_set_votune5(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
//VPA CON5
void vpa_set_votune6(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
void vpa_set_votune7(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 voltage){}
DCL_STATUS vpa_set_votune(PMU_VPA_LIST_ENUM vpa, DCL_UINT32 idx,DCL_UINT32 val){return STATUS_OK;}
#endif //#if defined(__DRV_UPMU_VPA_V1__)

#if defined(__DRV_UPMU_KPLED_V1__)
// KPLED CON0
void kpled_set_enable(PMU_KPLED_LIST_ENUM kpled, DCL_BOOL enable){}
void kpled_set_mode(PMU_KPLED_LIST_ENUM kpled, PMU_CTRL_KPLED_MODE_ENUM val){}
void kpled_set_sel(PMU_KPLED_LIST_ENUM kpled, kal_uint8 val){}
DCL_BOOL kpled_get_status(PMU_KPLED_LIST_ENUM kpled){return DCL_TRUE;}
#endif //#if defined(__DRV_UPMU_KPLED_V1__)

#if defined(__DRV_UPMU_CHARGER_V1__)
// CHR_CON0
void chr_set_csdac_enable(PMU_CHR_LIST_ENUM chr, DCL_BOOL enable){}
DCL_BOOL chr_get_is_chr_det(PMU_CHR_LIST_ENUM chr){return DCL_TRUE;}
void chr_set_enable(PMU_CHR_LIST_ENUM chr, DCL_BOOL enable){}
// CHR_CON1
DCL_BOOL chr_get_is_vbat_cv_det(PMU_CHR_LIST_ENUM chr){return KAL_FALSE;}
DCL_STATUS chr_set_vbat_cv_vth(PMU_CHR_LIST_ENUM chr, DCL_UINT32 voltage){return STATUS_OK;}
void chr_set_vbat_cv_det_enable(PMU_CHR_LIST_ENUM chr, DCL_BOOL enable){}
// CHR_CON2
DCL_UINT32 chr_get_cs_vth(PMU_CHR_LIST_ENUM chr){return 0;}
DCL_STATUS chr_set_cs_vth(PMU_CHR_LIST_ENUM chr, DCL_UINT32 current){return STATUS_OK;}
// CHR_CON3
DCL_BOOL chr_get_is_bat_on(PMU_CHR_LIST_ENUM chr){return DCL_TRUE;}
// CHR_CON6
void chr_wdt_clear_internal(PMU_CHR_LIST_ENUM chr){}
void chr_set_wdt_td(PMU_CHR_LIST_ENUM chr,DCL_UINT32 sec){}
void chr_wdt_clear(PMU_CHR_LIST_ENUM chr){}
void chr_wdt_enable(PMU_CHR_LIST_ENUM chr, kal_uint8 enable){}
// CHR_CON7
void chr_set_wdt_int_enable(PMU_CHR_LIST_ENUM chr, kal_uint8 enable){}
// CHR_CON8
void chr_set_adc_measure_enable(PMU_CHR_LIST_ENUM chr, DCL_BOOL enable){}

#if defined(__DRV_UPMU_BC11_V1__)
void chr_bc11_comp_vth(PMU_CHR_LIST_ENUM chr,PMU_CTRL_BC11_COMP_VTH_ENUM sel){}
void chr_bc11_comp_en_ctrl(PMU_CHR_LIST_ENUM chr,PMU_CTRL_BC11_COMP_EN_ENUM sel){}
void chr_bc11_ipd_en_ctrl(PMU_CHR_LIST_ENUM chr,PMU_CTRL_BC11_IPD_EN_ENUM  sel){}
void chr_bc11_ipu_en_ctrl(PMU_CHR_LIST_ENUM chr,PMU_CTRL_BC11_IPU_EN_ENUM sel){}
void chr_bc11_bias_enable(PMU_CHR_LIST_ENUM chr, DCL_BOOL enable){}
void chr_bc11_bb_ctrl(PMU_CHR_LIST_ENUM chr){}
void chr_bc11_reset(PMU_CHR_LIST_ENUM chr){}
void chr_bc11_vsrc_en_ctrl(PMU_CHR_LIST_ENUM chr,PMU_CTRL_BC11_VSRC_EN_ENUM sel){}
DCL_BOOL chr_bc11_get_cmp_out(PMU_CHR_LIST_ENUM chr){return KAL_FALSE;}
#endif //#if defined(__DRV_UPMU_BC11_V1__)
#endif //#if defined(__DRV_UPMU_CHARGER_V1__)

#if defined(__DRV_UPMU_STRUP_V1__)
void strup_usbdl_mode_enable(PMU_STRUP_LIST_ENUM strup,DCL_BOOL enable){}
#endif //#if defined(__DRV_UPMU_STRUP_V1__)


#if defined(__DRV_UPMU_BOOST_V1__)
// BOOST CON0
void boost_set_enable(PMU_BOOST_LIST_ENUM boost, DCL_BOOL enable){}
void boost_set_type(PMU_BOOST_LIST_ENUM boost, upmu_boost_type_enum val){}
void boost_set_mode(PMU_BOOST_LIST_ENUM boost, upmu_boost_mode_enum val){}
void boost_set_vrsel(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_oc_auto_off(PMU_BOOST_LIST_ENUM boost, DCL_BOOL auto_off){}

DCL_BOOL boost_get_oc_status(PMU_BOOST_LIST_ENUM boost){return DCL_TRUE;}

// BOOST CON1
void boost_set_cl(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_cs(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_rc(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_ss(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}

// BOOST CON2
void boost_set_cksel(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_sr_pmos(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_sr_nmos(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
void boost_set_slp(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}


// BOOST CON3
void boost_set_cks_prg(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}

// BOOST CON4
void boost_set_oc_thd(PMU_BOOST_LIST_ENUM boost, upmu_boost_oc_thd_enum val){}
void boost_set_oc_wnd(PMU_BOOST_LIST_ENUM boost, upmu_boost_oc_wnd_enum val){}
void boost_set_clk_cal(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}

// BOOST CON6
void boost_set_hw_sel(PMU_BOOST_LIST_ENUM boost, upmu_boost_hw_sel_enum val){}
void boost_set_cc(PMU_BOOST_LIST_ENUM boost, kal_uint8 val){}
#endif //#if defined(__DRV_UPMU_BOOST_V1__)


#if defined(__DRV_UPMU_ISINK_V1__)
// ISINK CON0
void isink_set_enable(PMU_ISINK_LIST_ENUM isink, DCL_BOOL enable){}
void isinks_set_vref_cal(PMU_ISINK_LIST_ENUM isink, kal_uint8 val){}
void isink_set_mode(PMU_ISINK_LIST_ENUM isink, PMU_CTRL_ISINK_MODE_ENUM val){}
void isink_set_step(PMU_ISINK_LIST_ENUM isink, kal_uint8 val){}
#endif //#if defined(__DRV_UPMU_ISINK_V1__)

#if defined(__DRV_UPMU_SPK_V1__)
// SPK CON0
void spk_set_enable(PMU_SPK_LIST_ENUM spk, DCL_BOOL enable){}
void spk_set_reset(PMU_SPK_LIST_ENUM spk, DCL_BOOL reset){}
DCL_STATUS spk_set_vol(PMU_SPK_LIST_ENUM spk, PMU_SPK_VOL_ENUM vol){return STATUS_OK;}
void spk_set_oc_auto_off(PMU_SPK_LIST_ENUM spk, DCL_BOOL auto_off){}
void spk_set_ocfb_enable(PMU_SPK_LIST_ENUM spk, DCL_BOOL enable){}
DCL_BOOL spk_set_get_oc_status(PMU_SPK_LIST_ENUM spk){return DCL_TRUE;}

// SPK CON1
void spk_set_pfd_mode_enable(PMU_SPK_LIST_ENUM spk, DCL_BOOL enable){}
void spk_set_cmode(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_ccode(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}

// SPK CON2
void spk_set_oc_thd(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_oc_wnd(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}

// SPK CON3
void spk_set_osc_isel(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_oc_enable(PMU_SPK_LIST_ENUM spk, DCL_BOOL enable){}

// SPK CON4
void spk_set_ocn_bias(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_ocp_bias(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}

// SPK CON5
void spk_set_pg_slew_dly(PMU_SPK_LIST_ENUM spk,kal_uint8 val){}
void spk_set_pg_slew_l(PMU_SPK_LIST_ENUM spk,kal_uint8 val){}

// SPK CON7
void spk_set_mode(PMU_SPK_LIST_ENUM spk, PMU_CTRL_SPK_MODE_ENUM val){}
void spk_set_ab_obias(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_ab_oc_enable(PMU_SPK_LIST_ENUM spk, DCL_BOOL enable){}
#endif //#if defined(__DRV_UPMU_SPK_V1__)

#if defined(__DRV_UPMU_SPK_V2__)
// SPK CON0
void spk_set_enable(PMU_SPK_LIST_ENUM spk, kal_bool enable){}
DCL_STATUS spk_set_vol(PMU_SPK_LIST_ENUM spk, PMU_SPK_VOL_ENUM vol){}
void spk_set_oc_enable(PMU_SPK_LIST_ENUM spk, kal_bool enable){}
void spk_set_obias(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_oc_thd(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
void spk_set_oc_wnd(PMU_SPK_LIST_ENUM spk, kal_uint8 val){}
#endif //#if defined(__DRV_UPMU_SPK_V1__)

//=============pmu6235===================
#if defined(PMIC_6223_REG_API) || defined(PMIC_6238_REG_API)
kal_bool dcl_pmu6235_get_vrf_status(void){return 0;}
void dcl_pmu6235_set_vrf(kal_bool enable){}
void dcl_pmu6235_set_vrf_force(kal_bool enable){}
void dcl_pmu6235_set_vrf_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_icalrf(pmu_icalrf_code code){}
void dcl_pmu6235_set_vrf_cal(kal_uint8 value){}
void dcl_pmu6235_set_tpsel(kal_uint8 value){}
void dcl_pmu6235_set_vcore_force(kal_bool enable){}
void dcl_pmu6235_set_icalcore(pmu_icalcore_code code){}
void dcl_pmu6235_set_vcore_sel(kal_uint8 value){}
void dcl_pmu6235_set_vcore_cal(kal_uint8 value){}
void dcl_pmu6235_set_vtcxo_pwrsave(kal_bool enable){}
void dcl_pmu6235_set_vrf_pwrsave(kal_bool enable){}
kal_bool dcl_pmu6235_get_vrtc_staus(void){return KAL_FALSE;}
void dcl_pmu6235_set_vrtc_force(kal_bool enable){}
kal_bool dcl_pmu6235_get_vio_status(void){return KAL_FALSE;}
kal_bool dcl_pmu6235_get_vm_status(void){return KAL_FALSE;}
void dcl_pmu6235_set_vio_force(kal_bool enable){}
void dcl_pmu6235_set_icalio(pmu_icalio_code code){}
void dcl_pmu6235_set_antiudsh_io_dn(kal_bool enable){}
void dcl_pmu6235_set_vio_cal(kal_uint8 value){}
void dcl_pmu6235_set_vm_force(kal_bool enable){}
void dcl_pmu6235_set_icalm(pmu_icalm_code code){}
void dcl_pmu6235_set_antiudsh_m_dn(kal_bool enable){}
void dcl_pmu6235_set_vm_cal(kal_uint8 value){}
kal_bool dcl_pmu6235_get_vsim_status(void){return KAL_FALSE;}
void dcl_pmu6235_set_vsim_force(kal_bool enable){}
void dcl_pmu6235_set_icalsim(pmu_icalsim_code code){}
void dcl_pmu6235_set_antiudsh_sim_dn(kal_bool enable){}
void dcl_pmu6235_set_vsim_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_vsim_cal(kal_uint8 value){}
void dcl_pmu6235_set_vrtc_step1_cal(kal_uint8 value){}
void dcl_pmu6235_set_vrtc_step2_cal(kal_uint8 value){}
kal_bool dcl_pmu6235_get_vtcxo_status(void){return KAL_FALSE;}
void dcl_pmu6235_set_vtcxo_force(kal_bool enable){}
void dcl_pmu6235_set_vtcxo(kal_bool enable){}
void dcl_pmu6235_set_vtcxo_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_vtcxo_cal(kal_uint8 value){}
kal_bool dcl_pmu6235_get_va_status(void){return KAL_FALSE;}
void dcl_pmu6235_set_va_force(kal_bool enable){}
void dcl_pmu6235_set_va(kal_bool enable){}
void dcl_pmu6235_set_va_cal(kal_uint8 value){}
void dcl_pmu6235_set_vrtc_cal_latch(kal_bool enable){}
void dcl_pmu6235_set_vibr(kal_bool enable){}
void dcl_pmu6235_set_kpled(kal_bool enable){}
void dcl_pmu6235_set_rled(kal_bool enable){}
void dcl_pmu6235_set_gled(kal_bool enable){}
void dcl_pmu6235_set_bled(kal_bool enable){}
void dcl_pmu6235_set_vsim(kal_bool enable){}
void dcl_pmu6235_set_vsim_sel(pmu_vsim_volt  volt){}
kal_bool dcl_pmu6235_is_ovp_occurred(void){return KAL_FALSE;}
kal_bool dcl_pmu6235_is_chr_det(void){return KAL_FALSE;}
kal_bool dcl_pmu6235_is_bat_on(void){return KAL_FALSE;}
kal_bool dcl_pmu6235_is_cv_mode(void){return KAL_FALSE;}
void dcl_pmu6235_set_adc_meas_on(kal_bool enable){}
void dcl_pmu6235_set_chron(kal_bool enable){}
void dcl_pmu6235_set_chr_cur_offset(pmu_chr_cur_offset offset){}
void dcl_pmu6235_set_chr_cur_level(pmu_chr_cur_level level){}
void dcl_pmu6235_set_chron_force(kal_bool enable){}
void dcl_pmu6235_set_chr_thermal_thres(pmu_chr_thermal_thres thres){}
void dcl_pmu6235_set_chr_ref_volt(pmu_ref_volt_step step){}
void dcl_pmu6235_set_chr_cv_volt(pmu_vbg_volt volt){}
void dcl_pmu6235_set_uv_sel(pmu_uvlo_volt volt){}
void dcl_pmu6235_set_rbgsel(pmu_rbgsel sel){}
void dcl_pmu6235_set_ibgsel(pmu_ibgsel sel){}
void dcl_pmu6235_set_osc(kal_bool enable){}
void dcl_pmu6235_set_cksel(pmu_cksel sel){}
void dcl_pmu6235_set_vbssel(pmu_vbssel sel){}
void dcl_pmu6235_reset_drv(kal_bool reset){}
void dcl_pmu6235_set_ov_hys_enb(pmu_ov_hys_enb value){}
void dcl_pmu6235_set_ov_thfreeze(pmu_ov_thfreeze value){}
kal_bool dcl_pmu6235_is_pwrkey_deb_disable(void){return KAL_FALSE;}
void dcl_pmu6235_sel_vrf_en(kal_bool enable){}
void dcl_pmu6235_set_adc_in_edge(kal_bool positive){}
void dcl_pmu6235_set_fast_slow(kal_bool fast){}
void dcl_pmu6235_set_pwmb_resol(kal_bool four_bits){}
void dcl_pmu6235_set_acc_out_init(kal_uint8 value){}
void dcl_pmu6235_set_cv_rt(kal_uint8 value){}
void dcl_pmu6235_set_mtv_enable(kal_bool enable){}
void dcl_pmu6235_set_gpio_drv(pmu_gpio_drv_strength strength){}
void dcl_pmu6235_set_bias_gen_force(kal_bool enable){}
void dcl_pmu6235_set_sdm_order(pmu_sdm_order order){}
void dcl_pmu6235_set_pid_gain_p(pmu_pid_gain_p gain){}
void dcl_pmu6235_set_pid_gain(pmu_pid_gain gain){}
void dcl_pmu6235_set_pid_gain_d(pmu_pid_gain_d gain){}
void dcl_pmu6235_set_duty_init(kal_uint8 value){}
void dcl_pmu6235_set_vcore_volt(pmu_vcore_volt volt){}
void dcl_pmu6235_set_sdm_fb_en(kal_bool enable){}
void dcl_pmu6235_set_vfbadj(kal_uint8 value){}
void dcl_pmu6235_set_direct_ctrl_en(kal_bool enable){}
void dcl_pmu6235_set_dcv_ck(pmu_dcv_ck clk){}
void dcl_pmu6235_set_isel(pmu_isel sel){}
void dcl_pmu6235_set_adjcksel(kal_uint8 value){}
void dcl_pmu6235_set_manual_mode(pmu_mode_set mode){}
void dcl_pmu6235_set_auto_mode_en(kal_uint8 value){}
void dcl_pmu6235_set_mode_cmp(pmu_mode_cmp cmp){}
void dcl_pmu6235_set_ave_current_mode(pmu_mode_ave_current mode){}
void dcl_pmu6235_set_dcv_test_en(kal_bool enable){}
void dcl_pmu6235_set_pfm_max_current(kal_uint8 value){}
void dcl_pmu6235_set_pfm_resistor(kal_uint8 value){}
void dcl_pmu6235_set_ndc_offset(pmu_ndc_offset offset){}
void dcl_pmu6235_set_dcv_trim(kal_uint8 value){}
void dcl_pmu6235_set_iasel(pmu_iasel volt){}
void dcl_pmu6235_set_rsel(pmu_rsel sel){}
kal_bool dcl_pmu6235_get_vusb_status(void){return 0;}
void dcl_pmu6235_set_vusb_en_force(kal_bool enable){}
void dcl_pmu6235_set_vusb_en(kal_bool enable){}
void dcl_pmu6235_set_icalusb(pmu_icalusb_code code){}
void dcl_pmu6235_set_antiudsh_usb_dn(kal_bool enable){}
void dcl_pmu6235_set_vusb_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_vusb_cal(kal_uint8 value){}
void dcl_pmu6235_set_vfbadj_slp(kal_uint8 value){}
kal_bool dcl_pmu6235_get_vsim2_status(void){return 0;}
void dcl_pmu6235_set_vsim2_en_force(kal_bool enable){}
void dcl_pmu6235_set_icalsim2(pmu_icalsim2_code code){}
void dcl_pmu6235_set_antiudsh_sim2_dn(kal_bool enable){}
void dcl_pmu6235_set_vsim2_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_vsim2_cal(kal_uint8 value){}
void dcl_pmu6235_set_clk_source_sel(pmu_clk_src_sel source){}
void dcl_pmu6235_set_vtcxo_on_sel(pmu_vtcxo_on_sel sel){}
void dcl_pmu6235_set_vsim_pwr_saving_en(kal_bool enable){}
void dcl_pmu6235_set_vsim2_en(kal_bool enable){}
void dcl_pmu6235_set_vsim2_sel(pmu_vsim_volt volt){}
//kal_bool dcl_pmu6235_get_vmc_status(void)
kal_bool dcl_pmu6235_get_vbt_status(void){return 0;}
//void dcl_pmu6235_set_vmc_en_force(kal_bool enable){}
void dcl_pmu6235_set_vbt_en_force(kal_bool enable){}
//void dcl_pmu6235_set_icalmc(pmu_icalmc_code code){}
void dcl_pmu6235_set_icalbt(pmu_icalbt_code code){}
//void dcl_pmu6235_set_antiudsh_mc_dn(kal_bool enable){}
void dcl_pmu6235_set_antiudsh_bt_dn(kal_bool enable){}
//void dcl_pmu6235_set_vmc_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_vbt_plnmos_dis(kal_bool enable){}
//void dcl_pmu6235_set_vmc_cal(kal_uint8 value){}
void dcl_pmu6235_set_vbt_cal(kal_uint8 value){}
//void dcl_pmu6235_set_vmc_en(kal_bool enable){}
void dcl_pmu6235_set_vbt_en(kal_bool enable){}
//void dcl_pmu6235_set_vmc_sel(pmu_vmc_volt volt){}
void dcl_pmu6235_set_vbt_sel(pmu_vbt_volt volt){}
//kal_bool dcl_pmu6235_get_vcamera_status(void)
kal_bool dcl_pmu6235_get_vcam_d_status(void){return KAL_FALSE;}
//void dcl_pmu6235_set_vcamera_en_force(kal_bool enable){}
void dcl_pmu6235_set_vcam_d_en_force(kal_bool enable){}
//void dcl_pmu6235_set_icalcamera(pmu_icalcamera_code code){}
void dcl_pmu6235_set_icalcam_d(pmu_icalcam_d_code code){}
//void dcl_pmu6235_set_antiudsh_camera_dn(kal_bool enable){}
void dcl_pmu6235_set_antiudsh_cam_d_dn(kal_bool enable){}
//void dcl_pmu6235_set_vcamera_plnmos_dis(kal_bool enable){}
void dcl_pmu6235_set_vcam_d_plnmos_dis(kal_bool enable){}
//void dcl_pmu6235_set_vcamera_cal(kal_uint8 value){}
void dcl_pmu6235_set_vcam_d_cal(kal_uint8 value){}
void dcl_pmu6235_set_dcv_slew_ctrl(kal_uint8 value){}
//void dcl_pmu6235_set_vcamera_en(kal_bool enable){}
void dcl_pmu6235_set_vcam_d_en(kal_bool enable){}
//void dcl_pmu6235_set_vcamera_sel(pmu_vcamera_volt volt){}
void dcl_pmu6235_set_vcam_d_sel(pmu_vcam_d_volt volt){}
//kal_bool dcl_pmu6235_get_vsw_a_status(void)
kal_bool dcl_pmu6235_get_vcam_a_status(void){return KAL_FALSE;}
//void dcl_pmu6235_set_vsw_a_en_force(kal_bool enable){}
void dcl_pmu6235_set_vcam_a_en_force(kal_bool enable){}
//void dcl_pmu6235_set_icalsw(pmu_icalsw_code code){}
void dcl_pmu6235_set_icalcam_a(pmu_icalcam_a_code code){}
//void dcl_pmu6235_set_vsw_a_sel(pmu_vsw_a_volt volt){}
void dcl_pmu6235_set_vcam_a_sel(pmu_vcam_a_volt volt){}
//void dcl_pmu6235_set_vsw_a_cal(kal_uint8 value){}
void dcl_pmu6235_set_vcam_a_cal(kal_uint8 value){}
void dcl_pmu6235_set_icala(pmu_icala_code code){}
void dcl_pmu6235_set_icaltcxo(pmu_icaltcxo_code code){}
//void dcl_pmu6235_set_vsw_a_en(kal_bool enable){}
void dcl_pmu6235_set_vcam_a_en(kal_bool enable){}
void dcl_pmu6235_set_oc_fold_en(kal_bool enable){}
void dcl_pmu6235_set_vref_bg(pmu_vref_bg value){}
void dcl_pmu6235_set_thr_sel(pmu_thr_sel value){}
void dcl_pmu6235_set_ldo_soft_st_dis(kal_bool disable){}
void dcl_pmu6235_set_tpsel_led(kal_uint8 value){}
void dcl_pmu6235_set_isense_out_en(kal_bool enable){}
void dcl_pmu6235_set_vbat_out_en(kal_bool enable){}
#endif //#if defined(PMIC_6223_REG_API) || defined(PMIC_6238_REG_API)

#if defined(PMIC_6236_REG_API)
/******************************************************************
         PMU6236 APIs
******************************************************************/
// =====================================================================================
// (0x800) VRF_CON0
 void dcl_pmu6236_vrf_enable(kal_bool enable){return;}
 void dcl_pmu6236_vrf_on_sel(pmu6236_vrf_on_sel_enum sel){return;}
 void dcl_pmu6236_vrf_sense(pmu6236_sense_enum sel){return;}
void dcl_pmu6236_vrf_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vrf_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vrf_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vrf_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_vrf_status(void){return KAL_FALSE;}

//  (0x804) VRF_CON1
 void dcl_pmu6236_vrf_cal(kal_uint8 val){return;}

// (0x810) VTCXO_CON0
 void dcl_pmu6236_vtcxo_enable(kal_bool enable){return;}
 void dcl_pmu6236_vtcxo_on_sel(pmu6236_vtcxo_on_sel_enum sel){return;}
void dcl_pmu6236_vtcxo_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vtcxo_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vtcxo_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vtcxo_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vtcxo_status(void){return KAL_FALSE;}

// (0x814) VTCXO_CON1
 void dcl_pmu6236_vtcxo_cal(kal_uint8 val){return;}

// (0x820) VA_CON0
 void dcl_pmu6236_va_sense(pmu6236_sense_enum sel){return;}
void dcl_pmu6236_va_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_va_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_va_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_va_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_va_status(void){return KAL_FALSE;}

// (0x824) VA_CON1
void dcl_pmu6236_va_cal(kal_uint8 val){return;}

// (0x830) VCAMA_CON0
 void dcl_pmu6236_vcama_enable(kal_bool enable){return;}
 void dcl_pmu6236_vcama_vosel(pmu6236_vcama_vosel_enum sel){return;}
void dcl_pmu6236_vcama_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vcama_stb_enable(kal_bool enable){return;}
 void dcl_pmu6236_vcama_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vcama_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vcama_status(void){return KAL_FALSE;}

// (0x834) VCAMA_CON1
 void dcl_pmu6236_vcama_cal(kal_uint8 val){return;}

// (0x838) VCAMA CON2
 void dcl_pmu6236_vcama_oc_td(pmu6236_oc_td_enum sel){return;}
 void dcl_pmu6236_vcama_stb_td(pmu6236_stb_td_enum sel){return;}

// (0x840) VCAMD_CON0
 void dcl_pmu6236_vcamd_enable(kal_bool enable){return;}
 void dcl_pmu6236_vcamd_vosel(pmu6236_vcamd_vosel_enum sel){return;}
void dcl_pmu6236_vcamd_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vcamd_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vcamd_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vcamd_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vcamd_status(void){return KAL_FALSE;}

// (0x844) VCAMD_CON1
 void dcl_pmu6236_vcamd_cal(kal_uint8 val){return;}

// (0x850) VIO_CON0
 void dcl_pmu6236_vio_sense(pmu6236_sense_enum sel){return;}
void dcl_pmu6236_vio_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vio_stb_enable(kal_bool enable){return;}
 void dcl_pmu6236_vio_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vio_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vio_status(void){return KAL_FALSE;}

// (0x854) VIO_CON1
 void dcl_pmu6236_vio_cal(kal_uint8 val){return;}

// (0x858) VIO_CON2
 void dcl_pmu6236_vio_oc_td(pmu6236_oc_td_enum sel){return;}

// (0x860) VUSB_CON0
 void dcl_pmu6236_vusb_enable(kal_bool enable){return;}
void dcl_pmu6236_vusb_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vusb_stb_enable(kal_bool enable){return;}
 void dcl_pmu6236_vusb_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vusb_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vusb_status(void){return KAL_FALSE;}

// (0x864) VUSB_CON1
 void dcl_pmu6236_vusb_cal(kal_uint8 val){return;}

// (0x868) VUSB_CON2
 void dcl_pmu6236_vusb_oc_td(pmu6236_oc_td_enum sel){return;}

// (0x870) VBT_CON0
 void dcl_pmu6236_vbt_enable(kal_bool enable){return;}
 void dcl_pmu6236_vbt_vosel(pmu6236_vbt_sel_enum sel){return;}
void dcl_pmu6236_vbt_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vbt_stb_enable(kal_bool enable){return;}
 void dcl_pmu6236_vbt_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vbt_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vbt_status(void){return KAL_FALSE;}

// (0x874) VBT_CON1
 void dcl_pmu6236_vbt_cal(kal_uint8 val){return;}

// (0x878) VBT_CON2
 void dcl_pmu6236_vbt_oc_td(pmu6236_oc_td_enum sel){return;}

// (0x880) VSIM_CON0
 void dcl_pmu6236_vsim_enable(kal_bool enable){return;}
 void dcl_pmu6236_vsim_vosel(pmu6236_vsim_vosel_enum sel){return;}
void dcl_pmu6236_vsim_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vsim_stb_enable(kal_bool enable){return;}
 void dcl_pmu6236_vsim_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vsim_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vsim_status(void){return KAL_FALSE;}

// (0x884) VSIM_CON1
 void dcl_pmu6236_vsim_cal(kal_uint8 val){return;}

// (0x888) VSIM_CON2
void dcl_pmu6236_vsim_oc_td(pmu6236_oc_td_enum sel){return;}

// (0x890) VSIM2_CON0
void dcl_pmu6236_vsim2_enable(kal_bool enable){return;}
void dcl_pmu6236_vsim2_vosel(pmu6236_vsim2_vosel_enum sel){return;}
void dcl_pmu6236_vsim2_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vsim2_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vsim2_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6236_vsim2_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_vsim2_status(void){return KAL_FALSE;}

// (0x894) VSIM2_CON1
void dcl_pmu6236_vsim2_cal(kal_uint8 val){return;}

// (0x898) VSIM2_CON2
 void dcl_pmu6236_vsim2_gpldo_en(kal_bool enable){return;}

// (0x8A0) VBACKUP_CON0
 void dcl_pmu6236_vbackup_enable(kal_bool enable){return;}
void dcl_pmu6236_vbackup_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vbackup_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vbackup_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6236_vbackup_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_vbackup_status(void){return KAL_FALSE;}

// (0x8B0) VIBR_CON0
 void dcl_pmu6236_vibr_enable(kal_bool enable){return;}
 void dcl_pmu6236_vibr_vosel(pmu6236_vibr_vosel_enum sel){return;}
void dcl_pmu6236_vibr_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vibr_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vibr_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vibr_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_vibr_status(void){return KAL_FALSE;}

// (0x8B4) VIBR_CON1
void dcl_pmu6236_vibr_cal(kal_uint8 val);

// (0x8C0) VMC_CON0
 void dcl_pmu6236_vmc_enable(kal_bool enable){return;}
void dcl_pmu6236_vmc_vosel(pmu6236_vmc_vosel_enum sel){return;}
void dcl_pmu6236_vmc_ndis_enable(kal_bool enable){return;}
void dcl_pmu6236_vmc_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vmc_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6236_vmc_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_vmc_status(void){return KAL_FALSE;}

// (0x8C4) VMC_CON1
void dcl_pmu6236_vmc_cal(kal_uint8 val){return;}

// (0x900) VCORE_CON0
 void dcl_pmu6236_vcore_enable(kal_bool enable){return;}
 void dcl_pmu6236_vcore_sense(pmu6236_sense_enum sel){return;}
 void dcl_pmu6236_vcore_vfbadj(pmu6236_vcore_vfbadj_enum sel){return;}
  kal_uint16 dcl_pmu6236_get_vcore_vfbadj(void){return 0;}
void dcl_pmu6236_vcore_stb_enable(kal_bool enable){return;}
void dcl_pmu6236_vcore_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6236_vcore_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_vcore_status(void){return KAL_FALSE;}

// (0x904) VCORE_CON1
 void dcl_pmu6236_vcore_modeset(pmu6236_vcore_modeset_enum mode){return;}
 void dcl_pmu6236_vcore_vfbadj_slp(pmu6236_vcore_vfbadj_enum sel){return;}
 kal_uint16 dcl_pmu6236_get_vcore_vfbadj_slp(void){return 0;}

// (0x908) VCORE_CON2
 void dcl_pmu6236_vcore_vosel(pmu6236_vcore_vosel_enum sel){return;}
void dcl_pmu6236_vcore_cal(kal_uint8 val){return;}

// (0x90C) VCORE_CON3
void dcl_pmu6236_vcore_ical_en(kal_uint8 sel){return;}

// (0x914) VCORE_CON5
void dcl_pmu6236_vcore_csl(pmu6236_vcore_csl_enum sel){return;}
void dcl_pmu6236_vcore_burst(pmu6236_vcore_burst_enum sel){return;}

// (0x920) VM_CON0
void dcl_pmu6236_vm_sense(pmu6236_sense_enum sel){return;}
void dcl_pmu6236_vm_stb_enable(kal_bool enable){return;}
 void dcl_pmu6236_vm_oc_auto_off(kal_bool enable){return;}
 void dcl_pmu6236_vm_ocfb_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_vm_status(void){return KAL_FALSE;}
 
// (0x928) VM_COM2
 void dcl_pmu6236_vm_cal(kal_uint8 val){return;}

// (0x92C) VM_CON3
void dcl_pmu6236_vm_ical_en(kal_uint8 sel){return;}

// (0x934) VM_CON5
void dcl_pmu6236_vm_csl(pmu6236_vm_csl_enum val){return;}
void dcl_pmu6236_vm_burst(pmu6236_vm_burst_enum val){return;}

// (0xA00) CHR_CON0
void dcl_pmu6236_chr_vcdt_lv_vth(kal_uint8 val){}
void dcl_pmu6236_chr_vcdt_hv_vth(kal_uint8 val){}
void dcl_pmu6236_chr_vcdt_hv_enable(kal_bool enable){}
 void dcl_pmu6236_chr_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_chr_chrdet(void){return KAL_FALSE;}
kal_bool dcl_pmu6236_chr_ovp(void){return KAL_FALSE;}

// (0xA04) CHR_CON1
void dcl_pmu6236_chr_vbat_cv_vth(pmu6236_chr_vbat_cv_enum cv){return;}
void dcl_pmu6236_chr_vbat_cc_vth(pmu6236_chr_vbat_cc_enum cc){return;}
void dcl_pmu6236_chr_vbat_cv_enable(kal_bool enable){return;}
void dcl_pmu6236_chr_vbat_cc_enable(kal_bool enable){return;}
kal_bool dcl_pmu6236_chr_cv_det(void){return KAL_FALSE;}
kal_bool dcl_pmu6236_chr_cc_det(void){return KAL_FALSE;}

// (0xA08) CHR_CON2
void dcl_pmu6236_chr_cs_enable(kal_bool enable){return;}
void dcl_pmu6236_chr_current(pmu6236_chr_current_enum sel){return;}

// (0xA14) CHR_CON5
kal_uint16 dcl_pmu6236_chr_control_state(kal_uint16 sel){return;}
pmu6236_pchr_state_enum dcl_pmu6236_get_pchr_state(void){return;}

// (0xA18) CHR_CON6
 void dcl_pmu6236_chr_wdt_td(pmu6236_chr_wdt_td_enum sel){return;}
 void dcl_pmu6236_chr_wdt_enable(kal_bool enable){return;}

// (0xA1C) CHR_CON7
 void dcl_pmu6236_chr_wdt_intr_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_chr_wdt_status(void){return KAL_FALSE;}
 void dcl_pmu6236_chr_wdt_clear(void){return;}

// (0xA20) CHR_CON8
void pmic6236_chr_adc_meas_on(kal_bool enable){return;}

// (0xB00) BOOST_CON0
 void dcl_pmu6236_vboost_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_get_vboost_enable(void){return KAL_FALSE;}
 void dcl_pmu6236_vboost_type(pmu6236_vboost_type_enum sel){return;}
pmu6236_vboost_type_enum dcl_pmu6236_get_vboost_type(void){return VBOOST_TYPE_VOLTAGE_CONTROLLER;}
 void dcl_pmu6236_vboost_mode(pmu6236_vboost_mode_enum sel){return;}
pmu6236_vboost_mode_enum dcl_pmu6236_get_vboost_mode(void){return VBOOST_NORMAL_MODE;}
 void dcl_pmu6236_vboost_vrsel(kal_uint16 val){return;}
 kal_uint16 dcl_pmu6236_get_vboost_vrsel(void){return 0;}

// (0xB0C) BOOST_CON3
void dcl_pmu6236_vboost_cks_prg(kal_uint8 val){return;}

// (0xC00) ISINK0_CON0
 void dcl_pmu6236_isink0_enable(kal_bool enable){return;}
void dcl_pmu6236_isink0_mode(pmu6236_isink_mode_enum sel){return;}
void dcl_pmu6236_isink0_step(pmu6236_isink_step_enum sel){return;}
kal_bool dcl_pmu6236_isink0_status(void){return 0;}

// (0xC10) ISINK1_CON0
 void dcl_pmu6236_isink1_enable(kal_bool enable){return;}
void dcl_pmu6236_isink1_mode(pmu6236_isink_mode_enum sel){return;}
void dcl_pmu6236_isink1_step(pmu6236_isink_step_enum sel){return;}
 kal_bool dcl_pmu6236_isink1_status(void){return KAL_FALSE;}

// (0xC20) ISINK2_CON0
void dcl_pmu6236_isink2_enable(kal_bool enable){return;}
void dcl_pmu6236_isink2_mode(pmu6236_isink_mode_enum sel){return;}
void dcl_pmu6236_isink2_step(pmu6236_isink_step_enum sel){return;}
 kal_bool dcl_pmu6236_isink2_status(void){return KAL_FALSE;}

// (0xC30) ISINK3_CON0
void dcl_pmu6236_isink3_enable(kal_bool enable){return;}
void dcl_pmu6236_isink3_mode(pmu6236_isink_mode_enum sel){return;}
void dcl_pmu6236_isink3_step(pmu6236_isink_step_enum sel){return;}
 kal_bool dcl_pmu6236_isink3_status(void){return KAL_FALSE;}

// (0xC40) ISINK4_CON0
void dcl_pmu6236_isink4_enable(kal_bool enable){return;}
void dcl_pmu6236_isink4_mode(pmu6236_isink_mode_enum sel){return;}
void dcl_pmu6236_isink4_step(pmu6236_isink_step_enum sel){return;}
 kal_bool dcl_pmu6236_isink4_status(void){return KAL_FALSE;}

// (0x0C80) KPLED_CON0
 void dcl_pmu6236_kpled_enable(kal_bool enable){return;}
void dcl_pmu6236_kpled_mode(pmu6236_kpled_mode_enum sel){return;}
void dcl_pmu6236_kpled_sel(kal_uint8 val){return;}
 kal_bool dcl_pmu6236_kpled_status(void){return KAL_FALSE;}

// (0x0C90) FLASH_CON0
 void dcl_pmu6236_flash_enable(kal_bool enable){return;}
void dcl_pmu6236_flash_mode(pmu6236_flash_mode_enum sel){return;}
void dcl_pmu6236_flash_sel(kal_uint8 sel){return ;}
 kal_bool dcl_pmu6236_flash_status(void){return KAL_FALSE;}

// (0xD00) SPK_CON0
 void dcl_pmu6236_spk_enable(kal_bool enable){return;}
 kal_bool dcl_pmu6236_get_spk_enable(void){return KAL_FALSE;}
void dcl_pmu6236_spk_vol(pmu6236_spk_vol_enum val){return;}
pmu6236_spk_vol_enum dcl_pmu6236_get_spk_vol(void){return SPK_VOL_12DB;}
void dcl_pmu6236_spk_ocfb_enable(kal_bool enable){return;}

// (0xE00) PMIC_OC_CON0
 void dcl_pmu6236_vrf_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vtcxo_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_va_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vcama_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vcamd_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vio_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vusb_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vbt_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vsim_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6236_vsim2_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6236_vbackup_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vibr_oc_int_enable(kal_bool enable){return;}
 void dcl_pmu6236_vmc_oc_int_enable(kal_bool enable){return;}

// (0xE04) PMIC_OC_CON1
void dcl_pmu6236_vcore_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6236_vm_oc_int_enable(kal_bool enable){return;}

// Other exported APIs
void dcl_pmu6236_init(void){return;}
pmu6236_chr_current_enum dcl_pmu6236_ret_chr_current(void){return CHR_CURR_800_0MA;}
pmu6236_chr_current_enum dcl_pmu6236_ret_usb_current(void){return CHR_CURR_500_0MA;}
void dcl_pmu6236_init_bl(pmu6236_vboost_type_enum bl_mode){return;}
void dcl_pmu6236_enable_bl(kal_bool enable){return;}
void dcl_pmu6236_bl_control_WA(kal_bool enable){return;}
void dcl_pmu6236_EM_reg_write(kal_uint32 reg, kal_uint16 val){return;}
kal_uint16 dcl_pmu6236_EM_reg_read(kal_uint32 reg){return 0;}

#endif //#if defined(PMIC_6236_REG_API)


#if defined(PMIC_6253_REG_API)
void dcl_pmu6253_vrf_enable(kal_bool enable){return;}
void dcl_pmu6253_vrf_cal(kal_uint8 val){return;}
void dcl_pmu6253_vrf_on_sel(pmu6253_vrf_on_sel_enum sel){return;}
void dcl_pmu6253_vrf_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vrf_status(void){return KAL_FALSE;}
// (0x804) VIO CON
void dcl_pmu6253_vio_cal(kal_uint8 val){return;}
void dcl_pmu6253_vio_vd_sense(pmu6253_vd_sense_enum sel){return;}
void dcl_pmu6253_vio_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vio_status(void){return;}
// (0x808) VM CON
void dcl_pmu6253_vm_cal(kal_uint8 val){return;}
void dcl_pmu6253_vm_vd_sense(pmu6253_vd_sense_enum sel){return;}
void dcl_pmu6253_vm_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vm_status(void){return KAL_FALSE;}
// (0x80C) VRTC CON
void dcl_pmu6253_vrtc_cal(kal_uint8 val){return;}
kal_bool dcl_pmu6253_vrtc_status(void){return KAL_FALSE;}
// (0x810) VTCXO CON
void dcl_pmu6253_vtcxo_enable(kal_bool enable){return;}
void dcl_pmu6253_vtcxo_cal(kal_uint8 val){return;}
void dcl_pmu6253_vtcxo_on_sel(pmu6253_vtcxo_on_sel_enum sel){return;}
void dcl_pmu6253_vtcxo_srclken(kal_bool enable){return;}
void dcl_pmu6253_vtcxo_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vtcxo_status(void){return KAL_FALSE;}
// (0x814) VA CON
void dcl_pmu6253_va_cal(kal_uint8 val){return;}
void dcl_pmu6253_va_vd_sense(pmu6253_vd_sense_enum sel){return;}
void dcl_pmu6253_va_on_sel(pmu6253_va_on_sel_enum sel){return;}
void dcl_pmu6253_va_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_va_status(void){return KAL_FALSE;}
// (0x818) VSIM CON
void dcl_pmu6253_vsim_enable(kal_bool enable){return;}
void dcl_pmu6253_vsim_cal(kal_uint8 val){return;}
void dcl_pmu6253_vsim_datal(kal_bool pull_low){return;}
void dcl_pmu6253_vsim_sel(pmu6253_vsim_sel_enum sel){return;}
void dcl_pmu6253_vsim_pwr_saving(kal_bool enable){return;}
void dcl_pmu6253_vsim_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vsim_status(void){return KAL_FALSE;}
// (0x81C) VSIM2 CON
void dcl_pmu6253_vsim2_enable(kal_bool enable){return;}
void dcl_pmu6253_vsim2_cal(kal_uint8 val){return;}
void dcl_pmu6253_vsim2_datal(kal_bool pull_low){return;}
void dcl_pmu6253_vsim2_sel(pmu6253_vsim_sel_enum sel){return;}
kal_bool dcl_pmu6253_vsim2_status(void){return KAL_FALSE;}
// (0x820) VUSB CON
void dcl_pmu6253_vusb_enable(kal_bool enable){return;}
void dcl_pmu6253_vusb_cal(kal_uint8 val){return;}
void dcl_pmu6253_vusb_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vusb_status(void){return KAL_FALSE;}
// (0x824) VBT CON
void dcl_pmu6253_vbt_enable(kal_bool enable){return;}
void dcl_pmu6253_vbt_cal(kal_uint8 val){return;}
void dcl_pmu6253_vbt_sel(pmu6253_vbt_sel_enum sel){return;}
void dcl_pmu6253_vbt_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vbt_status(void){return KAL_FALSE;}
// (0x828) VCAMD CON
void dcl_pmu6253_vcamd_enable(kal_bool enable){return;}
void dcl_pmu6253_vcamd_cal(kal_uint8 val){return;}
void dcl_pmu6253_vcamd_sel(pmu6253_vcamd_sel_enum sel){return;}
void dcl_pmu6253_vcamd_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vcamd_status(void){return KAL_FALSE;}
// (0x82C) VCAMA CON
void dcl_pmu6253_vcama_enable(kal_bool enable){return;}
void dcl_pmu6253_vcama_cal(kal_uint8 val){return;}
void dcl_pmu6253_vcama_sel(pmu6253_vcama_sel_enum sel){return;}
void dcl_pmu6253_vcama_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vcama_status(void){return KAL_FALSE;}
// (0x834) GPIO CON
void dcl_pmu6253_gpio_drv(pmu6253_gpio_drv_sel_enum sel){return;}
void dcl_pmu6253_mtv_enable(kal_bool enable){return;}
// (0x840) VCORE CON
void dcl_pmu6253_vcore_en_force(kal_bool enable){return;}
void dcl_pmu6253_vcore_cal(kal_uint8 val){return;}
void dcl_pmu6253_vcore_vd_sense(pmu6253_vd_sense_enum sel){return;}
kal_bool dcl_pmu6253_vcore_status(void){return KAL_FALSE;}
// (0x844) VCORE CON1
void dcl_pmu6253_vcore_modeset(pmu6253_vcore_modeset_enum mode){return;}
void dcl_pmu6253_vcore_adc_in_edge(pmu6253_vcore_adc_in_enum edge){return;}
void dcl_pmu6253_vcore_fast_slow(pmu6253_vcore_fast_slow_enum sel){return;}
void dcl_pmu6253_vcore_pwmb(pmu_6253_vcore_pwmb_enum sel){return;}
void dcl_pmu6253_vcore_acc_out_init(kal_uint8 val){return KAL_FALSE;}
// (0x848) VCORE CON2
void dcl_pmu6253_vcore_volsel(pmu6253_vcore_volsel_enum sel){return;}
void dcl_pmu6253_vcore_fben(kal_bool enable){return;}
// (0x84C) VCORE CON3
void dcl_pmu6253_vcore_vfbadj(pmu6253_vcore_vfbadj_enum sel){return;}
void dcl_pmu6253_vcore_direct_ctrl_en(pmu6253_vcore_direct_ctrl_enum sel){return;}
void dcl_pmu6253_vcore_dcvclksel(pmu6253_vcore_dcvclksel_enum sel){return;}
void dcl_pmu6253_vcore_modeen(pmu6253_vcore_modeen_enum sel){return;}
void dcl_pmu6253_vcore_modecmp(pmu6253_vcore_modecmp_enum sel){return;}
void dcl_pmu6253_vcore_modesel1A(pmu6253_vcore_modesel1a_enum sel){return;}
// (0x854) VCORE CON5
void dcl_pmu6253_vcore_vfbadj_slp(pmu6253_vcore_vfbadj_enum sel){return;}
void dcl_pmu6253_vcore_clk_source_sel(pmu6253_vcore_clk_source_enum sel){return;}
// (0x860) STARTUP CON0
void dcl_pmu6253_uv_sel(pmu6253_uv_sel_enum sel){return;}
void dcl_pmu6253_pwrkey_vcore(pmu6253_pwrkey_signal_enum sel){return;}
void dcl_pmu6253_pwrkey_deb(pmu6253_pwrkey_signal_enum sel){return;}
// (0x864) STARTUP CON1
void dcl_pmu6253_thr_sel(pmu6253_thr_sel_num sel){return;}
// (0x870) CHR CON0
void dcl_pmu6253_chr_enable(kal_bool enable){return;}
void dcl_pmu6253_chofst(pmu6253_chofst_enum sel){return;}
void dcl_pmu6253_chr_current(pmu6253_chr_current_enum sel){return;}
void dcl_pmu6253_chr_force_enable(kal_bool enable){return;}
void dcl_pmu6253_cv_rt(kal_uint8 val){return;}
void dcl_pmu6253_cv_tune(pmu6253_cv_tune_enum sel){return;}
// (0x874) CHR CON1
void dcl_pmu6253_cal_precc(pmu6253_cal_precc_enum sel){return;}
void dcl_pmu6253_ps_sel(pmu6253_ps_sel_enum sel){return;}
void dcl_pmu6253_ps_set(pmu6253_ps_set_enum sel){return;}
void dcl_pmu6253_chr_ov_sel(pmu6253_chr_ov_enum sel){return;}
// (0x878) CHR CON2
kal_bool dcl_pmu6253_chrdet(void){return;}
kal_bool dcl_pmu6253_ovp(void){return;}
kal_bool dcl_pmu6253_bat_on(void){return;}
kal_bool dcl_pmu6253_bad_bat(void){return;}
kal_bool dcl_pmu6253_cv_mode(void){return;}
// (0x87C) CHR CON3
void dcl_pmu6253_chr_wdt_td(pmu6253_chr_wdt_td_enum sel){}
void dcl_pmu6253_chr_wdt_enable(kal_bool enable){}
// (0x8F0) CHR CON4
void dcl_pmu6253_chr_wdt_intr_enable(kal_bool enable){}
kal_bool dcl_pmu6253_chr_wdt_status(void){return KAL_FALSE;}
void dcl_pmu6253_chr_wdt_clear(void){}

// (0x8F4) CHR CON5
//extern void dcl_pmu6253_chr_wdt_cnt(kal_uint32 val32){}

// (0x880) DRIVER CON0
void dcl_pmu6253_isinks_enable(kal_bool enable){return;}
void dcl_pmu6253_isinks_force_off(kal_bool off){return;}
void dcl_pmu6253_kpled_type(pmu6253_kpled_type_enum sel){return;}
void dcl_pmu6253_kpled_enable(kal_bool enable){return;}
void dcl_pmu6253_kpled_force_off(kal_bool off){return;}
void dcl_pmu6253_kpled_sel(pmu6253_kpled_sel_enum sel){return;}
kal_bool dcl_pmu6253_isink1_status(void){return KAL_FALSE;}
kal_bool dcl_pmu6253_isink2_status(void){return KAL_FALSE;}
kal_bool dcl_pmu6253_isink3_status(void){return KAL_FALSE;}
kal_bool dcl_pmu6253_isink4_status(void){return KAL_FALSE;}
kal_bool dcl_pmu6253_kpled_status(void){return KAL_FALSE;}
// (0x884) DRIVER CON1
void dcl_pmu6253_isinks_dimm(kal_uint8 sel){return;}
void dcl_pmu6253_isinks_chsel(pmu6253_isinks_chsel_enum sel){return;}
// (0x888) DRIVER CON2
void dcl_pmu6253_sinks_irset_cal(kal_uint8 val){return;}
void dcl_pmu6253_isinks_vled_step(pmu6253_isinks_vled_enum sel){return;}
// (0x88C) DRIVER CON3
void dcl_pmu6253_bl_enable(kal_bool enable){return;}
void dcl_pmu6253_vboost_enable(kal_bool enable){return;}
void dcl_pmu6253_bl_vgen_forceon(kal_bool on){return;}
void dcl_pmu6253_bl_mode(kal_uint8 val){return;}
void dcl_pmu6253_dimm_duty(kal_uint8 val){return;}
// (0x890) DRIVER CON4
void dcl_pmu6253_vibr_enable(kal_bool enable){return;}
void dcl_pmu6253_vibr_sel(pmu6253_vibr_sel_enum sel){return;}
void dcl_pmu6253_vibr_cal(kal_uint8 val){return;}
void dcl_pmu6253_vibr_ocfb_enable(kal_bool enable){return;}
kal_bool dcl_pmu6253_vibr_status(void){return KAL_FALSE;}
// (0x8A0) BOOST CON0
void dcl_pmu6253_vboost_sync_enable(kal_bool enable){return;}
void dcl_pmu6253_vboost_ss_speed(pmu6253_vboost_ss_speed_enum sel){return;}
void dcl_pmu6253_vboost_tune(kal_uint8 val){return;}
void dcl_pmu6253_vboost_cal(kal_uint8 val){return;}
kal_bool dcl_pmu6253_vboost_trk_status(void){return KAL_FALSE;}
kal_bool dcl_pmu6253_vboost_status(void){return KAL_FALSE;}
// (0x8A4) BOOST CON1
void dcl_pmu6253_isns_cal(kal_uint8 val){return;}
// (0x8A8) BOOST CON2
void dcl_pmu6253_vboost_forceon_clk(kal_bool forceon){return;}
void dcl_pmu6253_vboost_disclk(kal_bool forceoff){return;}
// (0x8B0) CLASSD CON0
void dcl_pmu6253_spk_enable(kal_bool enable){return;}
void dcl_pmu6253_spk_reset(kal_bool reset){return;}
void dcl_pmu6253_spk_emode(pmu6253_spk_emode_enum sel){return;}
void dcl_pmu6253_spk_mode(pmu6253_spk_mode_enum sel){return;}
void dcl_pmu6253_spkab_float(kal_bool enable){return;}
void dcl_pmu6253_spkab_sended(kal_bool enable){return;}
void dcl_pmu6253_spkab_oc_enable(kal_bool enable){return;}
void dcl_pmu6253_spkab_depop_enable(kal_bool enable){return;}
void dcl_pmu6253_spkab_obias(pmu6253_spkab_obias_enum sel){return;}
// (0x8B4) CLASSD CON1
void dcl_pmu6253_spk_dtin(kal_uint8 val){return;}
void dcl_pmu6253_spk_dtip(kal_uint8 val){return;}
void dcl_pmu6253_spk_dtcn(kal_uint8 val){return;}
void dcl_pmu6253_spk_dtcp(kal_uint8 val){return;}
// (0x8B8) CLASSD CON2
void dcl_pmu6253_spk_dmode(pmu6253_spk_dmode_enum sel){return;}
void dcl_pmu6253_spk_pchg(pmu6253_spk_pchg_enum sel){return;}
void dcl_pmu6253_spk_dtcal(kal_bool enable){return;}
void dcl_pmu6253_spk_pmode_enable(kal_bool enable){return;}
void dcl_pmu6253_spk_cmode(pmu6253_spk_freq_ctrl_enum sel){return;}
void dcl_pmu6253_spk_ccode(kal_uint8 val){return;}
// (0x8BC) CLASSD CON3
void dcl_pmu6253_spk_enable_view_clk(kal_bool enable){return;}
void dcl_pmu6253_spk_enable_view_vref(kal_bool enable){return;}
void dcl_pmu6253_spk_slew(pmu6253_spk_slew_enum sel){return;}
void dcl_pmu6253_spk_oc_enable(kal_bool enable){return;}
void dcl_pmu6253_spk_oscisel_half(kal_bool half){return;}
void dcl_pmu6253_spk_vol(kal_uint8 val){return;}
kal_uint8 dcl_pmu6253_spk_get_vol(void){return 0;}
// (0x8C8) TEST CON2
void dcl_pmu6253_adc_vol_divided_by_2(kal_bool enable){return;}
void dcl_pmu6253_adc_meas_on(kal_bool enable){return;}
// (0x8D0) OC CON0
void dcl_pmu6253_vrf_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vrf_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vrf_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vio_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vio_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vio_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vm_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vm_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vm_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_va_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_va_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_va_oc_int_enable(kal_bool enable){return;}
// (0x8D4) OC CON1
void dcl_pmu6253_vtcxo_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vtcxo_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vtcxo_oc_int_enable(kal_bool enable){return;}
// (0x8D8) OC CON2
void dcl_pmu6253_vbt_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vbt_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vbt_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vusb_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vusb_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vusb_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vcamd_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vcamd_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vcamd_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vcama_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vcama_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vcama_oc_int_enable(kal_bool enable){return;}
// (0x8DC) OC CON3
void dcl_pmu6253_spk_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_spk_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_spk_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vibr_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vibr_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vibr_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vboost_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vboost_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vboost_oc_int_enable(kal_bool enable){return;}
void dcl_pmu6253_vsim_oc_gear(pmu6253_gear_enum sel){return;}
void dcl_pmu6253_vsim_oc_auto_off(kal_bool enable){return;}
void dcl_pmu6253_vsim_oc_int_enable(kal_bool enable){return;}
// (0x8E0) OC CON4
void dcl_pmu6253_vibr_stbtd(pmu6253_soft_start_delay sel){return;}
void dcl_pmu6253_vsim_stbtd(pmu6253_soft_start_delay sel){return;}
void dcl_pmu6253_vbt_stbtd(pmu6253_soft_start_delay sel){return;}
void dcl_pmu6253_vusb_stbtd(pmu6253_soft_start_delay sel){return;}
void dcl_pmu6253_vcamd_stbtd(pmu6253_soft_start_delay sel){return;}
void dcl_pmu6253_vcama_stbtd(pmu6253_soft_start_delay sel){return;}
// (0x8E4) OC CON5
kal_bool dcl_pmu6253_oc_flag(pmu6253_oc_bit_enum sel){return KAL_FALSE;}
void dcl_pmu6253_clear_oc_flag(pmu6253_oc_bit_enum sel){return;}
void dcl_pmu6253_clear_all_oc_flag(void){return;}

#endif

// PMIC6326 dummy APIs
#if defined(PMIC_6326_REG_API)
// (0x09) STATUS 6 (RO)
kal_bool dcl_pmic6326_boost2_oc_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_spkr_oc_det_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_spkl_oc_det_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_pwrkey_deb_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_ovp_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_chrdet_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_bat_on_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_cv_status(void){return KAL_FALSE;}

// (0x0B) INT STATUS 1 (RO)
kal_uint8 dcl_pmic6326_int_status_1(void){return 0;}

// (0x0C) INT STATUS 2 (RO)
kal_uint8 dcl_pmic6326_int_status_2(void){return 0;}

// (0x0D) INT STATUS 3 (RO)
kal_uint8 dcl_pmic6326_int_status_3(void){return 0;}
kal_bool dcl_pmic6326_vsdio_oc_int_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_vgp_oc_int_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_vusb_oc_int_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_ovp_int_status(void){return KAL_FALSE;}
kal_bool dcl_pmic6326_chrdet_int_status(void){return KAL_FALSE;}

// (0x0E) INT STATUS 4 (RO)
kal_uint8 dcl_pmic6326_int_status_4(void){return 0;}
kal_bool dcl_pmic6326_watchdog_int_status(void){return KAL_FALSE;}
void dcl_pmic6326_watchdog_clear(void){}

// (0x1B) LDO CTRL 2 VRF
void dcl_pmic6326_vrf_ical_en(vrf_ical_en_enum sel){}
void dcl_pmic6326_vrf_oc_auto_off(kal_bool auto_off){}
void dcl_pmic6326_vrf_enable(kal_bool enable){}
void dcl_pmic6326_vrf_cal(kal_uint8 val){}

// (0x1C) LDO CTRL 3 VRF
void dcl_pmic6326_vrf_calst(vrf_calst_enum sel){}
void dcl_pmic6326_vrf_caloc(vrf_caloc_enum sel){}
void dcl_pmic6326_vrf_on_sel(vrf_on_sel_enum sel){}
void dcl_pmic6326_vrf_en_force(kal_bool enable){}
void dcl_pmic6326_vrf_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vrf_cm(vrf_cm_enum sel){}

// (0x1E) LDO CTRL 5 VTCXO
void dcl_pmic6326_vtcxo_ical_en(vtcxo_ical_en_enum sel){}
void dcl_pmic6326_vtcxo_oc_auto_off(kal_bool auto_off){}
void dcl_pmic6326_vtcxo_enable(kal_bool enable){}
void dcl_pmic6326_vtcxo_cal(kal_uint8 val){}

// (0x1F) LDO CTRL 6 VTCXO
void dcl_pmic6326_vtcxo_calst(vtcxo_calst_enum sel){}
void dcl_pmic6326_vtcxo_caloc(vtcxo_caloc_enum sel){}
void dcl_pmic6326_vtcxo_on_sel(vtcxo_on_sel_enum sel){}
void dcl_pmic6326_vtcxo_en_force(kal_bool enable){}
void dcl_pmic6326_vtcxo_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vtcxo_cm(vtcxo_cm_enum sel){}

// (0x21) LDO CTRL 8 V3GTX
void dcl_pmic6326_v3gtx_sel(v3gtx_vol vol){}
void dcl_pmic6326_v3gtx_ical_en(v3gtx_ical_en_enum sel){}
void dcl_pmic6326_v3gtx_cal(kal_uint8 val){}

// (0x22) LDO CTRL 9 V3GTX
void dcl_pmic6326_v3gtx_calst(v3gtx_calst_enum sel){}
void dcl_pmic6326_v3gtx_caloc(v3gtx_caloc_enum sel){}
void dcl_pmic6326_v3gtx_oc_auto_off(kal_bool auto_off){}
void dcl_pmic6326_v3gtx_enable(kal_bool enable){}
void dcl_pmic6326_v3gtx_on_sel(v3gtx_on_sel_enum sel){}
void dcl_pmic6326_v3gtx_en_force(kal_bool enable){}

// (0x24) LDO CTRL 11 V3GRX
void dcl_pmic6326_v3grx_sel(v3grx_vol vol){}
void dcl_pmic6326_3grx_ical_en(v3grx_ical_en_enum sel){}
void dcl_pmic6326_v3grx_cal(kal_uint8 val){}

// (0x25) LDO CTRL 12 V3GRX
void dcl_pmic6326_v3grx_calst(v3grx_calst_enum sel){}
void dcl_pmic6326_v3grx_caloc(v3grx_caloc_enum sel){}
void dcl_pmic6326_v3grx_oc_auto_off(kal_bool auto_off){}
void dcl_pmic6326_v3grx_enable(kal_bool enable){}
void dcl_pmic6326_v3grx_on_sel(v3grx_on_sel_enum sel){}
void dcl_pmic6326_v3grx_en_force(kal_bool enable){}

// (0x2E) LDO CTRL 21 VCAMA
void dcl_pmic6326_vcama_sel(vcama_sel_enum sel){}
void dcl_pmic6326_vcama_ical_en(vcama_ical_en_enum sel){}
void dcl_pmic6326_vcama_cal(kal_uint8 val){}

// (0x2F) LDO CTRL 22 VCAMA
void dcl_pmic6326_vcama_calst(vcama_calst_enum sel){}
void dcl_pmic6326_vcama_caloc(vcama_caloc_enum sel){}
void dcl_pmic6326_vcama_enable(kal_bool enable){}
void dcl_pmic6326_vcama_en_force(kal_bool enable){}
void dcl_pmic6326_vcama_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vcama_cm(vcama_cm_enum sel){}

// (0x31) LDO CTRL 24 VWIFI3V3
void dcl_pmic6326_vwifi3v3_sel(vwifi3v3_sel_enum sel){}
void dcl_pmic6326_vwifi3v3_ical_en(vwifi3v3_ical_en_enum sel){}
void dcl_pmic6326_vwifi3v3_cal(kal_uint8 val){}

// (0x32) LDO CTRL 25 VWIFI3V3
void dcl_pmic6326_vwifi3v3_calst(vwifi3v3_calst_enum sel){}
void dcl_pmic6326_vwifi3v3_caloc(vwifi3v3_caloc_enum sel){}
void dcl_pmic6326_vwifi3v3_enable(kal_bool enable){}
void dcl_pmic6326_vwifi3v3_en_force(kal_bool enable){}
void dcl_pmic6326_vwifi3v3_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vwifi3v3_cm(vwifi3v3_cm_enum sel){}

// (0x34) LDO CTRL 27 VWIFI2V8
void dcl_pmic6326_vwifi2v8_sel(vwifi2v8_sel_enum sel){}
void dcl_pmic6326_vwifi2v8_ical_en(vwifi2v8_ical_en_enum sel){}
void dcl_pmic6326_vwifi2v8_cal(kal_uint8 val){}

// (0x35) LDO CTRL 28 VWIFI2V8
void dcl_pmic6326_vwifi2v8_calst(vwifi2v8_calst_enum sel){}
void dcl_pmic6326_vwifi2v8_caloc(vwifi2v8_caloc_enum sel){}
void dcl_pmic6326_vwifi2v8_enable(kal_bool enable){}
void dcl_pmic6326_vwifi2v8_en_force(kal_bool enable){}
void dcl_pmic6326_vwifi2v8_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vwifi2v8_cm(vwifi2v8_cm_enum sel){}

// (0x37) LDO CTRL 30 VSIM
//void dcl_pmic6326_vsim_sel(vsim_sel_enum sel);
void dcl_pmic6326_vsim_sel(vsim_sel_enum sel){}
void dcl_pmic6326_vsim_enable(kal_bool enable){}
void dcl_pmic6326_vsim_ical_en(vsim_ical_en_enum sel){}
void dcl_pmic6326_vsim_en_force(kal_bool enable){}
void dcl_pmic6326_vsim_plnmos_dis(kal_bool disable){}

// (0x38) LDO CTRL 31 VSIM
void dcl_pmic6326_vsim_cal(kal_uint8 val){}

// (0x3A) LDO CTRL 33 VUSB
void dcl_pmic6326_vusb_sel(vusb_sel_enum sel){}
void dcl_pmic6326_vusb_enable(kal_bool enable){}
void dcl_pmic6326_vusb_ical_en(vusb_ical_en_enum sel){}
void dcl_pmic6326_vusb_en_force(kal_bool enable){}
void dcl_pmic6326_vusb_plnmos_dis(kal_bool disable){}

// (0x3B) LDO CTRL 34 VUSB
void dcl_pmic6326_vusb_cal(kal_uint8 val){}
void dcl_pmic6326_vusb_calst(vusb_calst_enum sel){}
void dcl_pmic6326_vusb_caloc(vusb_caloc_enum sel){}

// (0x3D) LDO CTRL 36 VBT
void dcl_pmic6326_vbt_sel(vbt_sel_enum sel){}
void dcl_pmic6326_vbt_enable(kal_bool enable){}
void dcl_pmic6326_vbt_ical_en(vbt_ical_en_enum sel){}
void dcl_pmic6326_vbt_en_force(kal_bool enable){}
void dcl_pmic6326_vbt_plnmos_dis(kal_bool disable){}

// (0x3E) LDO CTRL 37 VBT
void dcl_pmic6326_vbt_cal(kal_uint8 val){}
void dcl_pmic6326_vbt_calst(vbt_calst_enum sel){}
void dcl_pmic6326_vbt_caloc(vbt_caloc_enum sel){}

// (0x40) LDO CTRL 39 VCAMD
void dcl_pmic6326_vcamd_sel(vcamd_sel_enum sel){}
void dcl_pmic6326_vcamd_enable(kal_bool enable){}
void dcl_pmic6326_vcamd_ical_en(vcamd_ical_en_enum sel){}
void dcl_pmic6326_vcamd_en_force(kal_bool enable){}
void dcl_pmic6326_vcamd_plnmos_dis(kal_bool disable){}

// (0x41) LDO CTRL 40 VCAMD
void dcl_pmic6326_vcamd_cal(kal_uint8 val){}
void dcl_pmic6326_vcamd_calst(vcamd_calst_enum sel){}
void dcl_pmic6326_vcamd_caloc(vcamd_caloc_enum sel){}

// (0x43) LDO CTRL 42 VGP
void dcl_pmic6326_vgp_sel(vgp_sel_enum sel){}
void dcl_pmic6326_vgp_enable(kal_bool enable){}

// (0x44) LDO CTRL 43 VGP
void dcl_pmic6326_vgp_cal(kal_uint8 val){}

// (0x46) LDO CTRL 45 VSDIO
void dcl_pmic6326_vsdio_ical_en(vsdio_ical_en_enum sel){}
void dcl_pmic6326_vsdio_enable(kal_bool enable){}
void dcl_pmic6326_vsdio_en_force(kal_bool enable){}
void dcl_pmic6326_vsdio_cal(kal_uint8 val){}

// (0x47) LDO CTRL 46 VSDIO
void dcl_pmic6326_vsdio_calst(vsdio_calst_enum sel){}
void dcl_pmic6326_vsdio_caloc(vsdio_caloc_enum sel){}
void dcl_pmic6326_vsdio_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vsdio_sel(vsdio_sel_enum sel){}
void dcl_pmic6326_vsdio_cm(vsdio_cm_enum sel){}

// (0x48) LDO CTRL 47 VSDIO
void dcl_pmic6326_vcore1_dvfs_step_inc(kal_uint8 val){}

// (0x4E) BUCK CTRL 6 VCORE1
void dcl_pmic6326_vcore1_dvfs_0_eco3(kal_uint8 val){}

// (0x4F) BUCK CTRL 7 VCORE1
void dcl_pmic6326_vcore1_sleep_0_eco3(kal_uint8 val){}
void dcl_pmic6326_vcore1_dvfs_ramp_enable(kal_bool enable){}
void dcl_pmic6326_vcore1_dvfs_target_update(kal_bool update){}

// (0x51) BUCK CTRL 9 VCORE2
void dcl_pmic6326_vcore2_dvfs_0_eco3(kal_uint8 val){}

// (0x52) BUCK CTRL 10 VCORE2
void dcl_pmic6326_vcore2_enable(kal_bool enable){}
void dcl_pmic6326_vcore2_sleep_0_eco3(kal_uint8 val){}

// (0x53) BUCK CTRL 11 VCORE2
void dcl_pmic6326_vcore2_on_sel(vcore2_on_sel_enum sel){}

// (0x57) BUCK CTRL 15 VMEM
void dcl_pmic6326_vcore1_sleep_1_eco3(kal_uint8 val){}
void dcl_pmic6326_vcore1_dvfs_1_eco3(kal_uint8 val){}

// (0x58) BUCK CTRL 16 VPA
void dcl_pmic6326_vpa_tuneh(kal_uint8 value){}
void dcl_pmic6326_vpa_en_force(kal_bool enable){}
void dcl_pmic6326_vpa_plnmos_dis(kal_bool disable){}
void dcl_pmic6326_vpa_enable(kal_bool enable){}

// (0x59) BUCK CTRL 17 VPA
void dcl_pmic6326_vpa_tunel(kal_uint8 value){}

// (0x5A) BUCK CTRL 18 VPA
void dcl_pmic6326_vpa_oc_tune(kal_uint8 val){}

// (0x5C) BOOST CTRL 1 BOOST1
void dcl_pmic6326_vboost1_tune(vboost1_tune_enum sel){}
void dcl_pmic6326_vboost1_tatt(kal_uint8 val){}

// (0x5D) BOOST CTRL 2 BOOST1
void dcl_pmic6326_boost1_oc_th(kal_uint8 val){}
void dcl_pmic6326_boost1_enable(kal_bool enable){}
void dcl_pmic6326_boost1_pre_sr_con(kal_uint8 val){}
void dcl_pmic6326_boost1_soft_st_speed(boost1_soft_st_speed_enum sel){}

// (0x5E) BOOST CTRL 3 BOOST1
void dcl_pmic6326_boost1_dio_sr_con(kal_uint8 val){}
void dcl_pmic6326_boost1_sync_enable(kal_bool enable){}

// (0x5F) BOOST CTRL 4 BOOST2
void dcl_pmic6326_boost2_tune(vboost2_tune_enum sel){}
void dcl_pmic6326_boots2_oc_th(boost2_oc_th_enum sel){}
void dcl_pmic6326_boost2_dim_source(boost2_dim_source_enum sel){}

// (0x60) BOOST CTRL 5 BOOST2
void dcl_pmic6326_boost2_pre_sr_con(kal_uint8 val){}
void dcl_pmic6326_boost2_enable(kal_bool enable){}

// (0x61) BOOST CTRL 6 BOOST2 and BOOST
void dcl_pmic6326_boost_mode(boost_mode_sel_enum sel){}

// (0x64) DRIVER CTRL 3 GEN
void dcl_pmic6326_igen_drv_isel(kal_uint8 sel){}
void dcl_pmic6326_igen_drv_force(kal_bool force){}
void dcl_pmic6326_vgen_drv_bgsel(kal_uint8 sel){}

// (0x65) DRIVER CTRL 4 FLASH
//void dcl_pmic6326_flash_i_tune(flash_i_tune_enum sel){}
void dcl_pmic6326_flash_i_tune(kal_uint8 val){}
void dcl_pmic6326_flash_dim_div(kal_uint8 val){}

// (0x66) DRIVER CTRL 5 FLASH
void dcl_pmic6326_flash_dim_duty(kal_uint8 duty){}
void dcl_pmic6326_flash_enable(kal_bool enable){}
void dcl_pmic6326_flash_bypass(kal_bool bypass){}

// (0x67) DRIVER CTRL 6 BL
void dcl_pmic6326_bl_dim_duty(kal_uint8 duty){}
void dcl_pmic6326_bl_enable(kal_bool enable){}
void dcl_pmic6326_bl_i_cal_enable(kal_bool enable){}
void dcl_pmic6326_bl_bypass(kal_bool bypass){}

// (0x68) DRIVER CTRL 7 BL
void dcl_pmic6326_bl_i_corse_tune(bl_i_corse_tune_enum sel){}
void dcl_pmic6326_bl_i_fine_tune(bl_i_fine_tune_enum sel){}

// (0x6D) DRIVER CTRL 12 BL
void dcl_pmic6326_bl_dim_div(kal_uint8 val){}
void dcl_pmic6326_bl_number(bl_number_enum num){}

// (0x6E) DRIVER CTRL 13 KP
void dcl_pmic6326_kp_dim_div(kal_uint8 val){}
void dcl_pmic6326_kp_enable(kal_bool enable){}

// (0x6F) DRIVER CTRL 14 KP
void dcl_pmic6326_kp_dim_duty(kal_uint8 duty){}

// (0x70) DRIVER CTRL 15 VIBR
void dcl_pmic6326_vibr_dim_div(kal_uint8 val){}
void dcl_pmic6326_vibr_enable(kal_bool enable){}

// (0x71) DRIVER CTRL 16 VIBR
void dcl_pmic6326_vibr_dim_duty(kal_uint8 duty){}

// (0x73) CLASS_D CTRL 3 SPKL
void dcl_pmic6326_spkl_dtin(kal_uint8 val){}
void dcl_pmic6326_spkl_dtip(kal_uint8 val){}

// (0x74) CLASS_D CTRL 4 SPKL
void dcl_pmic6326_spkl_dmode(spkl_dmode_enum sel){}
void dcl_pmic6326_spkl_enable(kal_bool enable){}
void dcl_pmic6326_spkl_dtcal(spkl_dtcal_enum sel){}

// (0x78) CLASS_D CTRL 8 SPKR
void dcl_pmic6326_spkr_dtin(kal_uint8 val){}
void dcl_pmic6326_spkr_dtip(kal_uint8 val){}

// (0x79) CLASS_D CTRL 9 SPKR
void dcl_pmic6326_spkr_dmode(spkr_dmode_enum sel){}
void dcl_pmic6326_spkr_enable(kal_bool enable){}
void dcl_pmic6326_spkr_dtcal(spkr_dtcal_enum sel){}


// (0x81) CHARGER CTRL 1
//void dcl_pmic6326_chr_offset(void){}
void dcl_pmic6326_chr_offset(cht_chr_offset_enum sel){}
void dcl_pmic6326_chr_ov_th_high(void){}
void dcl_pmic6326_chr_current(chr_chr_current_enum current){}

// (0x82) CHARGER CTRL 2
void dcl_pmic6326_chr_cv_rt(void){}
void dcl_pmic6326_chr_force(kal_bool force){}
void dcl_pmic6326_chr_chr_enable(kal_bool enable){}
void dcl_pmic6326_chr_cv_tune(void){}
// (0x83) TESTMODE CTRL 3 Analog Switch
void dcl_pmic6326_asw_asel(asw_asel_enum sel){}
void dcl_pmic6326_asw_bsel(asw_bsel_enum sel){}
void dcl_pmic6326_asw_a1sel(kal_uint8 sel){}
void dcl_pmic6326_asw_a2sel(kal_uint8 sel){}
// (0x86) TESTMODE CTRL 6 BB AUXADC Related
void dcl_pmic6326_adc_isense_enable(kal_bool enable){}
void dcl_pmic6326_adc_vbat_enable(kal_bool enable){}
void dcl_pmic6326_adc_meas_on(kal_bool on){}		// exported for controling vbat, isense adc measure at same time

// (0x89) INT CTRL 1
void dcl_pmic6326_int_ctrl_1_enable(int_ctrl_1_enum sel, kal_bool enable){}
// (0x8A) INT CTRL 2
void dcl_pmic6326_int_ctrl_2_enable(int_ctrl_2_enum sel, kal_bool enable){}
// (0x8B) INT CTRL 2
void dcl_pmic6326_int_ctrl_3_enable(int_ctrl_3_enum sel, kal_bool enable){}
// (0x96) WATCHDOG CTRL and INT CTRL 4
void dcl_pmic6326_wdt_timeout(wdt_timout_enum sel){}
void dcl_pmic6326_intr_polarity(kal_bool assert){}
void dcl_pmic6326_wdt_enable(kal_bool enable){}

// Combinational functions
void dcl_pmic6326_vgp2_enable(kal_bool enable){}
void dcl_pmic6326_vgp2_sel(vgp2_sel_enum sel){}
void dcl_pmic6326_vgp2_on_sel(vgp2_on_sel_enum sel){}
void dcl_pmic6326_vgp2_sell(kal_uint8 value){}
void dcl_pmic6326_vgp2_selh(kal_uint8 value){}
void dcl_pmic6326_vsim2_enable(kal_bool enable){}
void dcl_pmic6326_vsim2_sel(vsim_sel_enum sel){}
void dcl_pmic6326_spk_enable(kal_bool enable){}
void dcl_pmic6326_vgp2_ocfb_enable(kal_bool enable){}
void dcl_pmic6326_EM_reg_write(kal_uint8 reg, kal_uint8 val){}
kal_uint8 dcl_pmic6326_EM_reg_read(kal_uint8 reg){ return 0; }


void dcl_pmic6326_assert_chaging_kick(void){}
// Do NOT need to implement custom function here
//void dcl_pmic6326_customization_init(void){}
//void dcl_pmic6326_cust_vspk_enable(kal_bool enable){}
//void dcl_pmic6326_csut_vsim_enable(kal_bool enable){}
//void dcl_pmic6326_csut_vsim_sel(pmic_adpt_vsim_volt volt){}
//void dcl_pmic6326_csut_vsim2_enable(kal_bool enable){}
//void dcl_pmic6326_csut_vsim2_sel(pmic_adpt_vsim_volt sel){}
//void dcl_pmic6326_csut_vusb_enable(kal_bool enable){}
//void dcl_pmic6326_csut_vcama_enable(kal_bool enable){}
//void dcl_pmic6326_csut_vcama_sel(pmic_adpt_vcama_volt vol){}
//void dcl_pmic6326_csut_vcamd_enable(kal_bool enable){}
//void dcl_pmic6326_csut_vcamd_sel(pmic_adpt_vcamd_volt volt){}
// Do NOT need to implement custom function here

#endif // #if defined(PMIC_6326_REG_API)


#if defined(PMIC_6326_CCCI_REG_API)
void dcl_pmic6326_ccci_vsim_sel_and_enable(kal_uint16 sel){}
void dcl_pmic6326_ccci_vsim_enable(kal_bool enable){}
void dcl_pmic6326_ccci_lock(kal_bool lock){}
void dcl_pmic6326_ccci_init(void){}
#endif // #if defined(PMIC_6326_CCCI_REG_API)


// ==================== PWIC APIs (pwic.h) ====================================
/*
// ==================== WDT APIs (wdt.h) ======================================
void WDT_SetValue(kal_uint16 value){}
kal_uint8 WDT_CheckStat(void){return 0;}
void WDT_Enable(kal_bool en){}
void WDT_SetExtpol(IO_level extpol){}
void WDT_SetExten(kal_bool en){}
void WDT_Config(IO_level extpol, kal_bool exten){}
void DRV_RESET(void){}
void WDT_Restart2(void){}
*/
// ==================== WDT APIs (wdt.h) ======================================
// APIs exported by pmic_MT6236PMU_drv.h
#if defined(PMIC_6236_REG_API)
// VCORE
void pmicMT6236PMU_VCORE_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VCORE_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VCORE_Cal(kal_uint32 step){return;}
// VIO
void pmicMT6236PMU_VIO_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VIO_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VIO_Cal(kal_uint32 step){return;}
// VRF
void pmicMT6236PMU_VRF_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VRF_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VRF_Cal(kal_uint32 step){return;}
// VA
void pmicMT6236PMU_VA_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VA_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VA_Cal(kal_uint32 step){return;}
// VTCXO
void pmicMT6236PMU_VTCXO_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VTCXO_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VTCXO_Cal(kal_uint32 step){return;}
// VRTC
void pmicMT6236PMU_VRTC_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VRTC_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VRTC_Cal(kal_uint32 step){return;}
// VM
void pmicMT6236PMU_VM_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VM_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VM_Cal(kal_uint32 step){return;}
// VSIM
void pmicMT6236PMU_VSIM_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VSIM_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VSIM_Cal(kal_uint32 step){return;}
// VSIM2
void pmicMT6236PMU_VSIM2_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VSIM2_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VSIM2_Cal(kal_uint32 step){return;}
// VMC
void pmicMT6236PMU_VMC_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VMC_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VMC_Cal(kal_uint32 step){return;}
// VBT
void pmicMT6236PMU_VBT_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VBT_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VBT_Cal(kal_uint32 step){return;}
// VUSB
void pmicMT6236PMU_VUSB_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VUSB_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VUSB_Cal(kal_uint32 step){return;}
// VCAMD
void pmicMT6236PMU_VCAMD_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VCAMD_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VCAMD_Cal(kal_uint32 step){return;}
// VCAMA
void pmicMT6236PMU_VCAMA_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VCAMA_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VCAMA_Cal(kal_uint32 step){return;}
// VIBR
void pmicMT6236PMU_VIBR_Enable(kal_bool enable){return;}
void pmicMT6236PMU_VIBR_Set_Volt(kal_uint8 volt){return;}
void pmicMT6236PMU_VIBR_Cal(kal_uint32 step){return;}

#endif // #if defined(PMIC_6236_REG_API)

#if defined(PMIC_6276_REG_API)
// VRF
void pmicMT6276PMU_VRF_Enable(kal_bool enable){}
void pmicMT6276PMU_VRF_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VRF_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VRF_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VRF_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VRF_Cal(kal_uint32 step){}

// VTCXO
void pmicMT6276PMU_VTCXO_Enable(kal_bool enable){}
void pmicMT6276PMU_VTCXO_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VTCXO_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VTCXO_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VTCXO_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VTCXO_Cal(kal_uint32 step){}

// VCAMA
void pmicMT6276PMU_VCAMA_Enable(kal_bool enable){}
void pmicMT6276PMU_VCAMA_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VCAMA_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VCAMA_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VCAMA_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VCAMA_Cal(kal_uint32 step){}

// VCAMD
void pmicMT6276PMU_VCAMD_Enable(kal_bool enable){}
void pmicMT6276PMU_VCAMD_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VCAMD_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VCAMD_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VCAMD_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VCAMD_Cal(kal_uint32 step){}

// VBT
void pmicMT6276PMU_VBT_Enable(kal_bool enable){}
void pmicMT6276PMU_VBT_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VBT_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VBT_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VBT_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VBT_Cal(kal_uint32 step){}

// VSIM
void pmicMT6276PMU_VSIM_Enable(kal_bool enable){}
void pmicMT6276PMU_VSIM_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VSIM_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VSIM_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VSIM_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VSIM_Cal(kal_uint32 step){}

// VSIM2
void pmicMT6276PMU_VSIM2_Enable(kal_bool enable){}
void pmicMT6276PMU_VSIM2_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VSIM2_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VSIM2_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VSIM2_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VSIM2_Cal(kal_uint32 step){}

// VIBR
void pmicMT6276PMU_VIBR_Enable(kal_bool enable){}
void pmicMT6276PMU_VIBR_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VIBR_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VIBR_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VIBR_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VIBR_Cal(kal_uint32 step){}

// VMC
void pmicMT6276PMU_VMC_Enable(kal_bool enable){}
void pmicMT6276PMU_VMC_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VMC_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VMC_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VMC_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VMC_Cal(kal_uint32 step){}

// VCAMA2
void pmicMT6276PMU_VCAMA2_Enable(kal_bool enable){}
void pmicMT6276PMU_VCAMA2_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VCAMA2_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VCAMA2_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VCAMA2_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VCAMA2_Cal(kal_uint32 step){}

// VCAMD2
void pmicMT6276PMU_VCAMD2_Enable(kal_bool enable){}
void pmicMT6276PMU_VCAMD2_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VCAMD2_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VCAMD2_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VCAMD2_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VCAMD2_Cal(kal_uint32 step){}

// VFM
void pmicMT6276PMU_VFM_Enable(kal_bool enable){}
void pmicMT6276PMU_VFM_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VFM_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VFM_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VFM_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VFM_Cal(kal_uint32 step){}

// VM12
void pmicMT6276PMU_VM12_Enable(kal_bool enable){}
void pmicMT6276PMU_VM12_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMU_VM12_Cal(kal_uint32 step){}
void pmicMT6276PMUNONMP_VM12_Enable(kal_bool enable){}
void pmicMT6276PMUNONMP_VM12_Set_Volt(kal_uint32 volt){}
void pmicMT6276PMUNONMP_VM12_Cal(kal_uint32 step){}

#endif  // PMIC_6276_REG_API

#if defined(PMIC_6251_REG_API)

// VRF
void pmicMT6251PMU_VRF_Enable(kal_bool enable){}
void pmicMT6251PMU_VRF_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VRF_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VRF_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VRF_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VRF_Cal(kal_uint32 step){}

// VTCXO
void pmicMT6251PMU_VTCXO_Enable(kal_bool enable){}
void pmicMT6251PMU_VTCXO_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VTCXO_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VTCXO_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VTCXO_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VTCXO_Cal(kal_uint32 step){}

// VSF
void pmicMT6251PMU_VSF_Enable(kal_bool enable){}
void pmicMT6251PMU_VSF_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VSF_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VSF_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VSF_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VSF_Cal(kal_uint32 step){}

// VSIM
void pmicMT6251PMU_VSIM_Enable(kal_bool enable){}
void pmicMT6251PMU_VSIM_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VSIM_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VSIM_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VSIM_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VSIM_Cal(kal_uint32 step){}

// VSIM2
void pmicMT6251PMU_VSIM2_Enable(kal_bool enable){}
void pmicMT6251PMU_VSIM2_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VSIM2_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VSIM2_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VSIM2_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VSIM2_Cal(kal_uint32 step){}

// VIBR
void pmicMT6251PMU_VIBR_Enable(kal_bool enable){}
void pmicMT6251PMU_VIBR_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VIBR_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VIBR_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VIBR_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VIBR_Cal(kal_uint32 step){}

// VFM
void pmicMT6251PMU_VFM_Enable(kal_bool enable){}
void pmicMT6251PMU_VFM_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMU_VFM_Cal(kal_uint32 step){}
void pmicMT6251PMUNONMP_VFM_Enable(kal_bool enable){}
void pmicMT6251PMUNONMP_VFM_Set_Volt(kal_uint32 volt){}
void pmicMT6251PMUNONMP_VFM_Cal(kal_uint32 step){}

void pmu_6251_bl_enable(kal_bool enable){}

#endif  // PMIC_6251_REG_API



// ==================== PMIC APIs (pmu.h, pmic6318_sw.h========================
// ==================== Drv common APIs (drv_commm.h)==========================
kal_uint32 drv_get_current_time(void){return 0;}
kal_uint32 drv_get_duration_tick(kal_uint32 previous_time, kal_uint32 current_time){return 0;}
kal_uint32 drv_get_duration_ms(kal_uint32 previous_time){return 0;}
void drv_dbg_trace(kal_uint16 index, kal_uint32 time, kal_uint32 data1, kal_uint32 data2){}
void Fast_Memcpy(void *srcaddr, void *dstaddr, kal_uint32 leng){}
void Fast_SherifWrite(void *srcaddr,void *dstaddr,kal_uint32 len){}
void Fast_SherifRead(void *srcaddr,void *dstaddr,kal_uint32 len){}
// The following are implemented in w32_uart.c begin ==========================
//extern kal_uint32 SaveAndSetIRQMask(void);
//extern void RestoreIRQMask(kal_uint32);
// The following are implemented in w32_uart.c end ============================
// The following are implemented in w32_audio.c begin =========================
//void get_NFI_bus(void);
//void free_NFI_bus(void);
// The following are implemented in w32_audio.c end ===========================
// ==================== Drv common APIs (drv_commm.h)==========================

// ==================== GPIO APIs (gpio_sw.h)==================================
void GPIO_InitIO(char direction, char port){}
char GPIO_ReadIO(char port){return 0;}
kal_uint16 GPIO_ReadAll(void){return 0;}
void GPIO_WriteIO(char data, char port){}
void GPIO_WriteAll(kal_uint16 write_data){}
char GPIO_ReturnMode(char port){return 0;}
char GPO_ReturnMode(char port){return 0;}
char GPIO_ReturnDir(char port){return 0;}
char GPIO_ReturnDout(char port){return 0;}
char GPO_ReturnDout(char port){return 0;}
void GPO_WriteIO(char data,char port){}
void GPO_WriteAll(kal_uint16 write_data){}
void GPIO_ModeSetup(kal_uint16 pin, kal_uint16 conf_dada){}
void GPO_ModeSetup(kal_uint16 pin, kal_uint16 conf_dada){}
void initGPIO(void){}
void GPIO_init(void){}
void GPIO_ALLIO(void){}
void GPIO_PullenSetup(kal_uint16 pin, kal_bool enable){}
void GPIO_DinvSetup(kal_uint16 pin, kal_bool enable){}
void GPIO_SetDebugMode(kal_bool enable){}
void GPIO_SetClkOut(char clk_num, gpio_clk_mode mode){}
void GPIO_PullSelSetup(kal_uint16 pin, kal_bool pull_up){}
void GPIO_TMDir(kal_bool pad_oe){}
void GPIO_ModeSetup_FAST(kal_uint16 pin, kal_uint16 conf_dada){}
void GPIO_InitIO_FAST(char direction, char port){}
char GPIO_ReadIO_FAST(char port){return 0;}
void GPIO_WriteIO_FAST(char data, char port){}
void GPIO_Check_MultiPins(GPIOCheckStruct *check_ptr, kal_uint32 pin_cnt){}
void GPIO_WriteIO_Force(char data, char port){}
void GPIO_WriteIO_FAST2(char data, kal_uint16 no, kal_uint16 remainder_shift){}
// ==================== GPIO APIs (gpio_sw.h)==================================

// ==================== USB APIs (usbacm_adap.h)==================================
kal_bool USB_Get_RNDIS_Mode(void){return KAL_FALSE;}
kal_bool USB_Set_RNDIS_Mode(kal_bool set){return KAL_FALSE;}
// ==================== USB APIs (usbacm_adap.h)==================================


void UART_SleepOnTx_Enable(UART_PORT port, UART_SLEEP_ON_TX enable_flag){}

void DRVPDN_Disable(kal_uint32 addr,kal_uint16 code,kal_uint8 handle){}
void DRVPDN_Enable(kal_uint32 addr,kal_uint16 code,kal_uint8 handle){}



void ppp_frame_decode_hw(){}
void ppp_frame_encode_hw(){}

/* LCD extern variable */
volatile LCD_OPERATION_STATE_ENUM main_lcd_operation_state;
volatile lcd_frame_update_struct main_lcd_fb_update_para;

volatile LCD_OPERATION_STATE_ENUM sub_lcd_operation_state;
volatile lcd_frame_update_struct sub_lcd_fb_update_para;
volatile kal_uint8 wait_lcd_config_flag=KAL_FALSE;
#ifdef __SYNC_LCM_SUPPORT__
   volatile kal_uint8 wait_lcd_restore_config_flag;
   volatile kal_uint8 sync_lcm_channel_number;
   volatile kal_bool sync_lcm_enable_mode;
   volatile kal_timerid sync_lcm_timer_handle = 0;
   volatile kal_uint8 sync_lcm_delay_flag;
#endif
volatile kal_uint8 jpeg_video_play_lcd_id;
/* LCD dummy functions */
void assert_lcd_fb_update(){}
void reset_lcd_if(){}
extern int g_nSleepMode/*=false*/;
kal_bool lcd_sleep_in(void)
{
	g_nSleepMode = TRUE;
   return KAL_TRUE;
}
void lcd_sleep_out()
{
	g_nSleepMode = FALSE;
}
void lcd_power_on(){}
void lcd_bright_level(){}
void lcd_enable_rotation_speed_up(kal_uint32 layer){}
void lcd_disable_rotation_speed_up(kal_uint32 layer){}
kal_uint8 lcd_get_parameter(kal_uint8 lcd_id,lcd_func_type type){}
void lcd_set_bias(){}
void lcd_set_contrast(){}
void lcd_set_linerate(){}
void lcd_set_temp_compensate(){}
void lcd_screen_on(kal_uint8 lcd_id, kal_bool on){}
void LCD_preview(kal_uint32 layer, kal_uint32 buffer1, kal_uint32 buffer2 ){}
void LCD_recode_preview(kal_uint32 layer, kal_uint32 buffer){}
void LCD_config_fw_layer_address(kal_uint32 addr){}
void lcd_reset_preview(void){}
void LCD_config_fullvideo_layer_address(kal_uint32 layer, kal_uint32 addr){}

kal_bool lcd_is_busy(void)
{
    return KAL_FALSE;
}
void lcd_power_ctrl(kal_bool enable){}

kal_uint8 get_lcd_hw_layer_rotate_value(kal_uint32 hw_layer)
{ return 0;
}
kal_bool lcd_ESD_check(void) { return KAL_TRUE; }
void lcd_stop_jpeg_video_play(kal_uint8 lcd_id){}
void lcd_jpeg_video_play(kal_bool display_jpeg, lcd_frame_update_struct *lcd_para){}
void lcd_start_jpeg_video_play(lcd_frame_update_struct *lcd_para){}
void set_lcd_driving_current(kal_uint8 current){}
void LCD_enable_TE(kal_bool enable){}
kal_uint8 lcd_get_lcm_rotate_value(LCD_TYPE_ENUM lcd_id){}//MAIN_LCD, SUB_LCD
void lcd_display_enable(kal_bool enable){}
kal_bool lcd_is_in_standby_mode(void){}
void LCD_video_decode_display(kal_uint32 buffer){}

///multimedia power gating control
void mm_disable_clock(kal_uint32 module){}
void mm_enable_clock(kal_uint32 module){}
void mm_disable_power(kal_uint32 module){}
void mm_enable_power(kal_uint32 module){}

kal_bool INT_USBBoot(void){return 0;}

void mcd_dump_max_buffer_size(void );

/*
void mcd_dump_max_buffer_size(void )
{
	static kal_uint32 XXX[10240];
	int i,size;
	kal_uint8 *name;
	mcd_init();
	for(i=0;i<MCD_TABLE_SIZE;i++)
	if((name = mcd_get_structure_name(i))!=NULL)
	{
		size = mcd_pseudo_alloc(i,XXX,sizeof(XXX));
		printf("%10d %s\n",size/8,name);
	}
	exit(0);
}*/

void MSDC_GetCardStatus(void){}

//int L1sim_Get_CardSpeedType(void){return 0;}
boot_mode_type system_boot_mode=NORMAL_BOOT;


//void L1sim_Enable_Enhanced_Speed(kal_bool enable){}


typedef struct {int x;}NOR_MTD_Driver;
NOR_MTD_Driver NORFlashMtd;





void UPLL_Enable(void){}
void UPLL_Disable(void){}



/* system service */
void EINT_Registration(kal_uint8 eintno, kal_bool Dbounce_En, kal_bool ACT_Polarity, void (reg_hisr)(void), kal_bool auto_umask){}
void INT_QueryMemoryInfo(kal_uint32 *ext_start, kal_uint32 *ext_len, kal_uint32 *int_start, kal_uint32 *int_len){}
void INT_GetSysMemoryInfo(kal_uint32 **info, kal_uint16* count ) {}
void INT_QueryPowerDownStatus(CONFIG_PDN_TYPE* PDN_ptr){}
void INT_SetPowerDownStatus(CONFIG_PDN_TYPE* PDN_ptr){}

void SLA_RetreiveLoggingBuffer(void){}
void SLA_RetreiveHeader(void){}

void IRQUnmask         (void){}
void IRQSensitivity    (void){}
void IRQ_Register_LISR (void){}
void IRQMask           (void){}
void IRQClearInt       (void){}
#ifdef NEPTUNE_MMI
/* Prabhjot MoDIS Integration - Uncommented */
void IRQDirectMaskAll(void){}
#endif
void EINT_Set_Polarity(kal_uint8 eintno, kal_bool ACT_Polarity){}
void EINT_Mask(kal_uint8 eintno){}
void EINT_UnMask(kal_uint8 eintno){}

kal_bool SST_AdvRAMTest(void){return 0;}
kal_bool custom_ifLPSDRAM(void){return 0;}

volatile kal_uint16 lcd_cmd_period_count;
kal_uint8 INT_Exception_Enter = 0;
kal_uint32  INT_MemoryDumpFlag=0x00;

void INT_VersionNumbers(version_struct * ptr_version)
{
   ptr_version->bb_chip = (kal_char*)"MoDIS";
   ptr_version->dsp_fw = (kal_char*)L"";
   ptr_version->dsp_ptch = (kal_char*)L"";
   ptr_version->mcu_sw = (kal_char*)release_verno();
   ptr_version->mcu_sw_branch = (kal_char*)release_branch();
   ptr_version->bb_board = (kal_char*)release_hw_ver();
}


kal_uint32 Lock2WaysForMPEG4(void)	{return 0;}
void Unlock2WaysForMPEG4(kal_uint32 val) {}


/* Max tmp patch */
void DMA_Config_Internal(kal_uint8 dma_no, void *dma_menu, kal_bool fullsize, kal_bool b2w, kal_uint8 limit, kal_bool start){}
void DMA_Stop(kal_uint8 channel){}
kal_uint8 DMA_GetChannel(kal_uint32 DMA_CODE){return 0;}


/* Dummy function for Driver using DCM relative API */
kal_uint8 DCM_GetHandle( void )
{
	return 0;
}
void DCM_Enable( kal_uint8 handle )
{

}
void DCM_Disable( kal_uint8 handle )
{

}
/* Dummy function for Driver using DCM relative API */


/******************************************************************
         TVOUT
******************************************************************/
#ifdef TV_OUT_SUPPORT
volatile kal_uint8 tv_operation_state;
volatile tv_output_para_struct tv_output_config_data;
volatile kal_uint8 tv_out_current_fb;
volatile kal_uint8 tv_output_owner;

/*engineer mode*/
volatile kal_uint8 tv_u_scale_ntsc,tv_v_scale_ntsc, tv_gamma_table_sel;
volatile kal_uint8 tv_u_scale_pal,tv_v_scale_pal;
volatile kal_uint8 tv_engmode_u_scale, tv_engmode_v_scale;
volatile kal_bool tv_eng_mode;

/*external use*/
void init_tv(void){}
void deinit_tv(void){}
kal_bool tv_set_detection(void){}
void set_tv_output_data_format(TV_OUT_SRC_FMT_ENUM data_format){}
void set_tv_output_mode(tv_output_para_struct *tv_para){}
kal_uint32 get_current_tv_output_buffer(void){}
void enable_tv_output(kal_uint8 tv_on){}
void enable_tv_vertical_interpolation(kal_uint8 on){}
void enable_tv_encoder(kal_bool tv_on){}
void set_tv_src_size(TV_OUT_OWNER_ENUM tv_update_id,kal_uint16 src_width,kal_uint16 src_height){}
void tv_fb_update(TV_OUT_OWNER_ENUM tv_update_id,kal_uint32 tv_output_buffer_address){}
void tv_fb_update_yuv420(TV_OUT_OWNER_ENUM tv_update_id, kal_uint32 tv_y_buffer,kal_uint32 tv_u_buffer,kal_uint32 tv_v_buffer){}
void set_tv_parameter(TV_OUT_COMP_ENUM type,kal_uint8 para){}

/*for engineer mode*/
void enter_tv_engmode(kal_uint32 tv_buffer){}
void exit_tv_engmode(void){}
kal_uint8 get_tv_engmode_item_count(void){}
void get_tv_engmode_item_info(TV_ENGMODE_ITEM index, kal_uint8 *item_name, tv_engmode_info *info_ptr){}
void fill_tv_test_pattern(kal_uint32 buffer_address, kal_uint8 test_pattern){}
kal_bool set_tv_engmode_item_value(TV_ENGMODE_ITEM index, kal_uint16 item_value){}
#endif



void SIM1_LDO_enable(kal_bool enable){}

void SIM2_LDO_enable(kal_bool enable){}

/* Dummy function for using buffer push and pop */
void Buff_Push(BUFFER_INFO *Buf,kal_uint8 *pushData){}
void Buff_Pop(BUFFER_INFO *Buf,kal_uint8 *popData){}

#if defined(MT6236) || defined(MT6236B) || defined(MT6256) || defined(MT6276) || defined(MT6255) || defined(MT6250) || defined (__BTMODULE_GSM_BT_SOC__)
/******************************************************************
         BTIF
******************************************************************/
void BTIF_TurnOnPower(kal_uint8 dummy1, kal_bool enable){}
kal_bool BTIF_Open(kal_uint8 dummy1, kal_uint8 dummy2){ return FALSE; }
void BTIF_SetDCBConfig(kal_uint8 dummy1, kal_uint8* dummy2, kal_uint8 dummy3){}
void BTIF_Close(kal_uint8 dummy1, kal_uint8 dummy2){}
kal_uint16 BTIF_GetBytes(kal_uint8 dummy1, kal_uint8 *Buffaddr, kal_uint16 Length, kal_uint8 *status, kal_uint8 dummy2){return Length;}
kal_uint16 BTIF_PutBytes(kal_uint8 dummy1, kal_uint8 *Buffaddr, kal_uint16 Length, kal_uint8 dummy2){return Length;}
void BTIF_SLEEP_WAKEUP_OUT_LISR(void){}
void BTIF_SLEEP_WAKEUP_OUT_HISR(void){}
#endif

/******** mm_intmem START *****************************************************/
#if defined(DRV_FEATURE__MM_INTMEM_IF)
#if !defined(__MTK_TARGET__)
kal_bool mm_intmem_get(mm_scen_id_t scen_id, mm_intmem_segment_id_t segment_id, kal_uint32 *address, kal_uint32 *size)
{
  return KAL_FALSE;
}

kal_bool mm_intmem_free(mm_scen_id_t scen_id, mm_intmem_segment_id_t segment_id)
{
  return KAL_FALSE;
}
#endif  // #if !defined(__MTK_TARGET__)
#endif  // #if defined(DRV_FEATURE__MM_INTMEM_IF)
/******** mm_intmem END   *****************************************************/


/******** RF_DESENSE START ****************************************************/
#if defined( __RF_DESENSE_TEST__)
void rf_desense_set_curr_mode(void) {}
void rf_desense_get_curr_mode(void) {}
void custom_DynamicClockSwitch(void) {}

kal_uint16 rf_desense_get_total(void) {}
kal_uint16* rf_desense_get_item(kal_uint32 index) {}
#endif
/******** RF_DESENSE END   ****************************************************/

/******** Card Download EM Function Start *************************************/
#ifdef __CARD_DOWNLOAD__
void CDL_FullDownloadTest(void) {}
#endif
/******** Card Download EM function End ***************************************/

