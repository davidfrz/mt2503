/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * wgui_categories_ems.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is for EMS category screens.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/* start - added by magesh */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* end - added by magesh */

//#include "kal_release.h"
//#include "mmi_frm_gprot.h"

#include "conversions.h"

//#include "WguiCategoryGprot.h"
#include "wgui_ems.h"
//#include "MessagesResourceData.h"
#include "PhoneSetupGprots.h"
#if (defined(__MMI_FILE_MANAGER__))
//#include "FileMgr.h"
//#include "FileManagerDef.h"
//#include "FileManagerGProt.h"
#endif /* (defined(__MMI_FILE_MANAGER__)) */ 
#include "EmsMiscell.h"

/*PMT IRE START*/
#ifdef __MMI_INDIC_ALG__
#include "IndicEngineGprot.h"
/*PMT IRE END*/
#endif 
//#include "wgui_virtual_keyboard.h"
#if defined(__MMI_TOUCH_SCREEN__) // || defined(__MMI_HANDWRITING_PAD__)
//#include "EditorPen.h"
#endif 

//RHR
    #include "MMI_features.h"
    #include "MMIDataType.h"
    #include "ems.h"
    #include "wgui_categories_ems.h"
    #include "gui.h"
    #include "gui_scrollbars.h"
    #include "gui_data_types.h"
    #include "gui_ems.h"
    #include "gui_config.h"
    #include "gdi_include.h"
    #include "wgui_inputs.h"
    #include "gui_typedef.h"
    #include "gui_themes.h"
    #include "CustThemesRes.h"
    #include "wgui.h"
    #include "wgui_categories_util.h"
    #include "gdi_datatype.h"
    #include "kal_general_types.h"
    #include "kal_public_api.h"
    #include "wgui_include.h"
    #include "mmi_frm_input_gprot.h"
    #include "wgui_draw_manager.h"
    #include "wgui_title.h"
    #include "wgui_categories_enum.h"
    #include "mmi_rp_app_uiframework_def.h"
    #include "GlobalConstants.h"
    #include "wgui_fixed_menus.h"
    #include "gui_title_pre_oem.h"
    #include "gui_menu_shortcut.h"
    #include "wgui_touch_screen.h"
    #include "mmi_frm_events_gprot.h"
    #include "mmi_frm_history_gprot.h"
    #include "gui_theme_struct.h"
    #include "DebugInitDef_Int.h"
    #include "gui_switch.h"
    #include "mmi_frm_mem_gprot.h"
    #include "gui_title.h"
    #include "FileMgrSrvGProt.h"
    #include "Wgui_categories_util.h"
#ifndef __COSMOS_MMI_PACKAGE__
    #include "mmi_rp_app_sms_def.h"
#endif
    #include "fs_type.h"
    #include "Unicodexdcl.h"
    #include "string.h"
    #include "fs_func.h"
    #include "gdi_const.h"
    #include "gui_inputs.h"

#ifdef __MMI_MESSAGES_EMS__

extern void initialize_EMS_objects(void);
extern void close_EMS_objects(void);

extern U8 *EMS_predefined_pictures[];
extern U8 *EMS_predefined_melodies[];

EMSObjData temp_EMS_obj_data;
#ifdef __MMI_SMALL_IMAGE_SELECTOR_SCREEN__
small_image_selector_struct small_image_selector;
#endif 


/*****************************************************************************
 * FUNCTION
 *  CreateCategory143ObjectList
 * DESCRIPTION
 *  create 143 object list
 * PARAMETERS
 *  data            [IN]         data of objects
 *  object_list     [OUT]        list of objects
 * RETURNS
 *  void
 *****************************************************************************/
void CreateCategory143ObjectList(EMSData *data, EMSObject **object_list)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObject *p;
    EMSObject *q;
#if 0    
#if(ENABLE_EMS_TEST_SAVE_OBJECTS)
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_OBJECTS) */ 
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (data == NULL)
    {
        return;
    }
    p = data->listHead;
        
    *object_list = q = NULL;
#if 0    
#if(ENABLE_EMS_TEST_SAVE_OBJECTS)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __EMS_REL5__
/* under construction !*/
    #endif 
/* under construction !*/
    #if defined(__MMI_IMELODY_SUPPORT__)
/* under construction !*/
    #endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (ENABLE_EMS_TEST_SAVE_OBJECTS) */ 
#if(ENABLE_EMS_TEST_SAVE_PIC_OBJECTS)   /* picture */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_PIC_OBJECTS) */ 
#if(ENABLE_EMS_TEST_SAVE_ANIA_OBJECTS)  /* animation */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_ANIA_OBJECTS) */ 
#if(ENABLE_EMS_TEST_SAVE_MELO_OBJECTS)  /* melodies */
/* under construction !*/
#if defined(__MMI_IMELODY_SUPPORT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_MELO_OBJECTS) */ 
#endif /* (ENABLE_EMS_TEST_SAVE_OBJECTS) */ 
#else

#if 0
#if(ENABLE_EMS_TEST_SAVE_PIC_OBJECTS)   /* picture */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_PIC_OBJECTS) */ 
#endif

#if 0
#if(ENABLE_EMS_TEST_SAVE_ANIA_OBJECTS)  /* animation */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_ANIA_OBJECTS) */ 
#endif
#if 0
#if(ENABLE_EMS_TEST_SAVE_MELO_OBJECTS)  /* melodies */
/* under construction !*/
#if defined(__MMI_IMELODY_SUPPORT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
/* under construction !*/
#endif /* (ENABLE_EMS_TEST_SAVE_MELO_OBJECTS) */ 
/* under construction !*/
#endif

#endif
}


/*****************************************************************************
 * FUNCTION
 *  FreeCategory143ObjectList
 * DESCRIPTION
 *  free object list of category 143
 * PARAMETERS
 *  object_list     [IN]        object list
 * RETURNS
 *  void
 *****************************************************************************/
void FreeCategory143ObjectList(EMSObject **object_list)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObject *q, *temp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (object_list == NULL)
    {
        return;
    }
    q = *object_list;
    while (q != NULL)
    {
        temp = q;
        q = q->next;
        gui_free(temp);
    }
    *object_list = NULL;
}


/*****************************************************************************
 * FUNCTION
 *  category_143_redraw_highlighted_item
 * DESCRIPTION
 *  Redraws the object list screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 *category_143_object_list_index = NULL;
S32 category_143_object_list_n_items = 0;
vertical_scrollbar category143_vbar;
EMSObject *category_143_object_list;
EMSObject *category_143_current_object;
extern U8 EMS_view_mode;
U8 buffer[32];

void category_143_redraw_highlighted_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    color c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_cancel_object_focus();
    gui_reset_clip();
    c = gui_color(255, 255, 255);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__//071007 ems bg
    gdi_draw_solid_rect(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1,
        GDI_COLOR_TRANSPARENT);
#else
    gui_fill_rectangle(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1,
        c);
#endif
    gui_set_clip(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - current_MMI_theme->scrollbar_size,
        MMI_content_height + 2);
    if (category_143_current_object != NULL)
    {
        gui_EMS_input_box_measure_object(category_143_current_object, &w, &h);
        x = (UI_device_width >> 1) - (w >> 1);
        y = (UI_device_height >> 1) - (h >> 1);
        gui_EMS_input_box_display_object(x, y, category_143_current_object, 1);
    }
    /* Uncomment below line for auto-disable scrollbar    */
    if (category_143_object_list_n_items > 1 && !(wgui_is_touch_title_bar_buttons()))
    {
        gui_set_vertical_scrollbar_range(&category143_vbar, category_143_object_list_n_items);
        gui_set_vertical_scrollbar_scale(&category143_vbar, 1);
        gui_set_vertical_scrollbar_value(&category143_vbar, *category_143_object_list_index);
        
        if (mmi_fe_get_r2l_state())
        {
            /* move vertical scrollbar to the left side */
            gui_move_vertical_scrollbar(
                    &category143_vbar, 
                    0, 
                    category143_vbar.y);
        }

        gui_show_vertical_scrollbar(&category143_vbar);
    }
    
#ifdef __MMI_CAT143_FTE__   
    if (wgui_is_touch_title_bar_buttons())
    {
        /* Draw Index of current item. */
    	gdi_handle layer_handle;
    	gdi_handle lcd_handle;
    	gui_util_painter_struct bg_painter;
        
        kal_wsprintf((kal_wchar*)buffer, "(%d/%d)", (*category_143_object_list_index)+1, category_143_object_list_n_items);
        
        gdi_layer_get_active(&layer_handle);
        gdi_lcd_get_active(&lcd_handle);
        gui_util_painter_create_empty(&bg_painter);
        wgui_text_label_create(
            0,
            0,
            MMI_content_y + MMI_content_height - MMI_SINGLELINE_INPUTBOX_HEIGHT,
            MMI_content_width,
            MMI_SINGLELINE_INPUTBOX_HEIGHT,
            buffer,
            &MMI_medium_font,
            *current_MMI_theme->title_text_color,
            MMI_FALSE,
            *current_MMI_theme->title_text_border_color,
            bg_painter,
            GUI_TEXT_LABEL_H_ALIGN_CENTER,
            GUI_TEXT_LABEL_V_ALIGN_CENTER,
            layer_handle,
            lcd_handle);

        wgui_text_label_show(0);
        
    }
#endif    
    gui_BLT_double_buffer(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  category_143_highlight_handler
 * DESCRIPTION
 *  highlight handler
 * PARAMETERS
 *  index       [IN]        index of highlighted item
 * RETURNS
 *  void
 *****************************************************************************/
void category_143_highlight_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_CAT143_FTE__ 
    wgui_title_set_menu_shortcut_number(index + 1);
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    if (!wgui_title_get_menu_shortcut_handler_display())
    {
        draw_title();
    }
#endif /*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
#endif
    MMI_user_highlight_handler_Ext((U8)eListhighlight, index);
}


/*****************************************************************************
 * FUNCTION
 *  category_143_goto_item
 * DESCRIPTION
 *  goto item by index
 * PARAMETERS
 *  index       [IN]        index of item
 * RETURNS
 *  void
 *****************************************************************************/
void category_143_goto_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_143_object_list != NULL)
    {
        if (index < 0)
        {
            return; /* index=0; */
        }
        if (index > (category_143_object_list_n_items - 1))
        {
            return; /* index=category_143_image_list_n_items-1;  */
        }
        *category_143_object_list_index = index;
        category_143_current_object = category_143_object_list;
        if (category_143_current_object != NULL)
        {
            S32 i;

            for (i = 0; i < index; i++)
            {
                category_143_current_object = category_143_current_object->next;
            }
        }
    }
    category_143_redraw_highlighted_item();
    category_143_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_143_goto_previous_item
 * DESCRIPTION
 *  goto previous item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void category_143_goto_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_143_object_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index--;
    if (index < 0)
    {
        index = category_143_object_list_n_items - 1;
    }
    *category_143_object_list_index = index;
    if (category_143_current_object != NULL)
    {
        if (category_143_current_object->prev == NULL)
        {
            category_143_current_object = category_143_object_list;
            while (category_143_current_object->next != NULL)
            {
                category_143_current_object = category_143_current_object->next;
            }
        }
        else
        {
            category_143_current_object = category_143_current_object->prev;
        }
    }
    category_143_redraw_highlighted_item();
    category_143_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_143_goto_next_item
 * DESCRIPTION
 *  goto next item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void category_143_goto_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_143_object_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index++;
    if (index > (category_143_object_list_n_items - 1))
    {
        index = 0;
    }
    *category_143_object_list_index = index;
    if (category_143_current_object != NULL)
    {
        if (category_143_current_object->next == NULL)
        {
            category_143_current_object = category_143_object_list;
        }
        else
        {
            category_143_current_object = category_143_current_object->next;
        }
    }
    category_143_redraw_highlighted_item();
    category_143_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_143_key_handler
 * DESCRIPTION
 *  category 143 keypad handler
 * PARAMETERS
 *  vkey_code       [IN]       virtual key code 
 *  key_state       [IN]       key state
 * RETURNS
 *  void
 *****************************************************************************/
void category_143_key_handler(S32 vkey_code, S32 key_state)
{
#if 0
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
/* under construction !*/
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
#else

    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);
    
#endif

}

#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  category_143_pen_down_hdlr
 * DESCRIPTION
 *  pen down handler
 * PARAMETERS
 *  pos     [IN]        pen down position
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL category_143_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_143_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category143_vbar.x, category143_vbar.y, category143_vbar.width, category143_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category143_vbar,
                MMI_PEN_EVENT_DOWN,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_143_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_143_pen_up_hdlr
 * DESCRIPTION
 *  pen up handler
 * PARAMETERS
 *  pos     [IN]        pen up position
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL category_143_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_143_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category143_vbar.x, category143_vbar.y, category143_vbar.width, category143_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category143_vbar,
                MMI_PEN_EVENT_UP,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_143_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_143_pen_move_hdlr
 * DESCRIPTION
 *  Pen move handler
 * PARAMETERS
 *  pos     [IN]        pen move handler
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL category_143_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_143_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category143_vbar.x, category143_vbar.y, category143_vbar.width, category143_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category143_vbar,
                MMI_PEN_EVENT_MOVE,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_143_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_143_pen_repeat_hdlr
 * DESCRIPTION
 *  pen repeat handler
 * PARAMETERS
 *  pos     [IN]      pen repeat position  
 * RETURNS
 *  Is handled
 *****************************************************************************/
MMI_BOOL category_143_pen_repeat_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_143_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category143_vbar.x, category143_vbar.y, category143_vbar.width, category143_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category143_vbar,
                MMI_PEN_EVENT_REPEAT,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_143_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  DrawCate143CategoryControlArea
 * DESCRIPTION
 *  Draws the category143 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate143CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    category_143_redraw_highlighted_item();
}


extern void cat129_clear_icon_bg(void *button);
/*****************************************************************************
 * FUNCTION
 *  ShowCategory143Screen
 * DESCRIPTION
 *  Displays the object list screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  object_list             [IN]        Array of items
 *  n_items                 [IN]        Number of items in the menu
 *  index                   [IN]        Default item to be highlighted (if there is no history)
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory143Screen(
        U16 title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        EMSObject *object_list,
        S32 *n_items,
        S32 *index,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 shortcut_width, n = 0;
    U8 h_flag;
#if defined(__MMI_CAT143_FTE__)
    U16 btn_prev_item_id = 0, btn_next_item_id = 0;
#endif /* defined(__MMI_TOUCH_SCREEN__) */
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    EMS_view_mode = 1;
    initialize_EMS_objects();
    wgui_title_set_menu_shortcut_number(-1);
#ifdef __MMI_CAT143_FTE__    
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    wgui_set_touch_title_bar_buttons();
#else
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);
#endif

    clear_left_softkey();
    clear_right_softkey();
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__

    MMI_title_icon = get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    MMI_title_string = get_string(title);
    category_143_object_list = object_list;
    category_143_object_list_index = index;

    h_flag = set_object_list_category_history(MMI_CATEGORY143_ID, history_buffer, category_143_object_list_index);
    if (h_flag)
    {
        *index = *category_143_object_list_index;
    }
    if (category_143_object_list == NULL)
    {
        n = 0;
        category_143_current_object = NULL;
    }
    else
    {
        S32 i;
        EMSObject *p = object_list->next;

        ++n;
        while (p != NULL)
        {
            p = p->next;
            ++n;
        }
        if (*index < 0)
        {
            *index = 0;
        }
        if (*index >= n)
        {
            *index = n - 1;
        }
        category_143_current_object = category_143_object_list;
        for (i = 0; i < *index; i++)
        {
            category_143_current_object = category_143_current_object->next;
        }
    }
    *n_items = n;
    wgui_title_set_menu_shortcut_number(*index + 1);
    category_143_object_list_n_items = n;
    category_143_object_list_index = index;
    if (*category_143_object_list_index < 0)
    {
        *category_143_object_list_index = 0;
    }
    if (*category_143_object_list_index >= category_143_object_list_n_items)
    {
        *category_143_object_list_index = category_143_object_list_n_items - 1;
    }
    gui_create_vertical_scrollbar(
        &category143_vbar,
        UI_device_width - current_MMI_theme->scrollbar_size,
        (MMI_title_y + MMI_title_height),
        current_MMI_theme->scrollbar_size,
        MMI_content_height);

#ifdef __MMI_CAT143_FTE__ 
    /* check if the title bar buttons are enabled for the particular screen. */
    if (wgui_is_touch_title_bar_buttons())
    {
        btn_prev_item_id = dm_add_button(
                            NULL,
                            get_image(LEFT_RED_ARROW),
                            get_image(LEFT_RED_ARROW),
                            cat129_clear_icon_bg);

        btn_next_item_id = dm_add_button(
                            NULL,
                            get_image(RIGHT_RED_ARROW),
                            get_image(RIGHT_RED_ARROW),
                            cat129_clear_icon_bg);
    }
    if (wgui_is_touch_title_bar_buttons())
    {
        /* register the handler for pen event down istead of pen event up */
        dm_register_button_functions(btn_prev_item_id, KEY_EVENT_DOWN, category_143_goto_previous_item);
        dm_register_button_functions(btn_next_item_id, KEY_EVENT_DOWN, category_143_goto_next_item);
        dm_register_button_functions(btn_prev_item_id, KEY_REPEAT, category_143_goto_previous_item);
        dm_register_button_functions(btn_next_item_id, KEY_REPEAT, category_143_goto_next_item);
    }

    SetKeyHandler(category_143_goto_previous_item, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(category_143_goto_next_item, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
#else /* __MMI_CAT143_FTE__ */
    /* ShortCut */
    register_fixed_list_shortcut_handler();
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    shortcut_width = set_menu_item_count(*n_items) + 7;
#else
    shortcut_width = 7;  
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    resize_menu_shortcut_handler(shortcut_width, (MMI_title_height));
    move_menu_shortcut_handler(UI_device_width - MMI_menu_shortcut_box.width, MMI_title_y);
    register_hide_menu_shortcut(draw_title);

    register_menu_shortcut_keys();
    register_menu_shortcut_handler(category_143_goto_item);

    SetKeyHandler(category_143_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_DOWN);
    SetKeyHandler(category_143_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
#endif

    SetKeyHandler(category_143_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
    SetKeyHandler(category_143_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory143Screen;
    dm_setup_category_functions(dm_redraw_category_screen, GetCategory143History, GetCategory143HistorySize);
    dm_register_category_controlled_callback(DrawCate143CategoryControlArea);
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(category_143_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(category_143_pen_up_hdlr, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(category_143_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
    wgui_register_category_screen_control_area_pen_handlers(category_143_pen_repeat_hdlr, MMI_PEN_EVENT_REPEAT);
#endif /* __MMI_TOUCH_SCREEN__ */ 
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY143_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_LITE_DISP_WALLPAPER;//071007 ems bg
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory143Screen
 * DESCRIPTION
 *  Exits the object list screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory143Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_view_mode = 0;
    EMS_cancel_object_focus();
    close_EMS_objects();
    reset_menu_shortcut_handler();
    category_143_object_list = NULL;
    category_143_object_list_index = NULL;
    category_143_object_list_n_items = 0;
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
#ifdef __MMI_CAT143_FTE__    
    wgui_text_label_show(0);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory143HistorySize
 * DESCRIPTION
 *  Gets the history buffer size for the object list screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory143HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(object_list_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory143History
 * DESCRIPTION
 *  Gets the history buffer for the object list screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored
 * RETURNS
 *  pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory143History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_object_list_category_history(MMI_CATEGORY143_ID, history_buffer, category_143_object_list_index);
    return (history_buffer);
}

/* Supports only user defined objects  */


/*****************************************************************************
 * FUNCTION
 *  GetCategory143DataType
 * DESCRIPTION
 *  get category 143 data type
 * PARAMETERS
 *  void
 * RETURNS
 *  data type of category 143
 *****************************************************************************/
U8 GetCategory143DataType(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (category_143_current_object->Type)
    {
        case EMS_TYPE_PIC:
            return (EMS_USERDEFINED_PICTURE);
        case EMS_TYPE_USERDEF_ANM:
            return (EMS_USERDEFINED_ANIMATION);
            /* MTK Joy added for customization, 1014 */
    #if defined(__MMI_IMELODY_SUPPORT__)
        case EMS_TYPE_USERDEF_SND:
            return (EMS_USERDEFINED_MELODY);
    #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
            /* MTK end */
    }
    return (0);
}

/* Supports only user defined objects  */


/*****************************************************************************
 * FUNCTION
 *  GetCategory143DataSize
 * DESCRIPTION
 *  get category 143 data size
 * PARAMETERS
 *  void
 * RETURNS
 *  size of 143 data
 *****************************************************************************/
S32 GetCategory143DataSize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (category_143_current_object->Type)
    {
        case EMS_TYPE_PIC:
            size = 9 + category_143_current_object->data->picture.pdu_length;
            break;
        case EMS_TYPE_USERDEF_ANM:
            size = 12 + category_143_current_object->data->animation.pdu_length;
            break;
            /* MTK Joy added for customization, 1014 */
    #if defined(__MMI_IMELODY_SUPPORT__)
        case EMS_TYPE_USERDEF_SND:
            size = 4 + category_143_current_object->data->sound.pdu_length;
            break;
    #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
            /* MTK end */
    }
    return (size);
}

/* Supports only user defined objects  */


/*****************************************************************************
 * FUNCTION
 *  GetCategory143Data
 * DESCRIPTION
 *  Get cateogyr 143 data
 * PARAMETERS
 *  data        [OUT]     buffer to get data
 * RETURNS
 *  
 *****************************************************************************/
U8 *GetCategory143Data(U8 *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (data != NULL)
    {
        switch (category_143_current_object->Type)
        {
            case EMS_TYPE_PIC:
                data[0] = (U8) EMS_USERDEFINED_PICTURE;
                data[1] = (U8) category_143_current_object->data->picture.bitsPerPixel;
                data[2] = (U8) category_143_current_object->data->picture.attribute;
                data[3] = (U8) category_143_current_object->data->picture.hDim;
                data[4] = (U8) (category_143_current_object->data->picture.hDim >> 8);
                data[5] = (U8) category_143_current_object->data->picture.vDim;
                data[6] = (U8) (category_143_current_object->data->picture.vDim >> 8);
                data[7] = (U8) category_143_current_object->data->picture.pdu_length;
                data[8] = (U8) (category_143_current_object->data->picture.pdu_length >> 8);
                gui_memcpy(
                    data + 9,
                    category_143_current_object->data->picture.pdu,
                    category_143_current_object->data->picture.pdu_length);
                break;

            case EMS_TYPE_USERDEF_ANM:
                data[0] = (U8) EMS_USERDEFINED_ANIMATION;
                data[1] = (U8) category_143_current_object->data->animation.bitsPerPixel;
                data[2] = (U8) category_143_current_object->data->animation.attribute;
                data[3] = (U8) category_143_current_object->data->animation.cFrame;
                data[4] = (U8) category_143_current_object->data->animation.cRepeat;
                data[5] = (U8) category_143_current_object->data->animation.Duration;
                data[6] = (U8) category_143_current_object->data->animation.hDim;
                data[7] = (U8) (category_143_current_object->data->animation.hDim >> 8);
                data[8] = (U8) category_143_current_object->data->animation.vDim;
                data[9] = (U8) (category_143_current_object->data->animation.vDim >> 8);
                data[10] = (U8) category_143_current_object->data->animation.pdu_length;
                data[11] = (U8) (category_143_current_object->data->animation.pdu_length >> 8);
                gui_memcpy(
                    data + 12,
                    category_143_current_object->data->animation.pdu,
                    category_143_current_object->data->animation.pdu_length);
                break;
                /* MTK Joy added for customization, 1014 */
        #if defined(__MMI_IMELODY_SUPPORT__)
            case EMS_TYPE_USERDEF_SND:
                data[0] = (U8) EMS_USERDEFINED_MELODY;
                data[1] = (U8) category_143_current_object->data->sound.attribute;
                data[2] = (U8) category_143_current_object->data->sound.pdu_length;
                data[3] = (U8) (category_143_current_object->data->sound.pdu_length >> 8);
                gui_memcpy(
                    data + 4,
                    category_143_current_object->data->sound.pdu,
                    category_143_current_object->data->sound.pdu_length);
                break;
        #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
                /* MTK end */
        }
    }
    return (data);
}

#define EMS_PREDEFINED_PICTURE_HEADER_SIZE         3
#define EMS_USERDEFINED_PICTURE_HEADER_SIZE        3
#define EMS_PREDEFINED_ANIMATION_HEADER_SIZE    1
#define EMS_USERDEFINED_ANIMATION_HEADER_SIZE      3
#define EMS_PREDEFINED_SOUND_HEADER_SIZE        1
#define EMS_PREDEFINED_MELODY_HEADER_SIZE       1
#define EMS_USERDEFINED_MELODY_HEADER_SIZE         1


/*****************************************************************************
 * FUNCTION
 *  InsertEMSObjectUIHeader
 * DESCRIPTION
 *  Insert object UI header
 * PARAMETERS
 *  object_type     [IN]        object type
 *  object_size     [IN]        object size
 *  source          [IN]        object source data
 *  destination     [OUT]       object destination buffer
 * RETURNS
 *  void
 *****************************************************************************/
void InsertEMSObjectUIHeader(U32 object_type, S32 object_size, U8 *source, U8 *destination)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (object_type & 0xff)
    {
        case EMS_USERDEFINED_MELODY:
            gui_memcpy((destination + 3), source, object_size);
            destination[0] = (U8) EMS_USERDEFINED_MELODY;
            destination[1] = (U8) object_size;
            destination[2] = (U8) object_size >> 8;
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  RemoveEMSObjectUIHeader
 * DESCRIPTION
 *  remove object UI header
 * PARAMETERS
 *  object_type     [IN]        object type
 *  source          [IN]        object source data
 *  destination     [OUT]       object destination buffer
 * RETURNS
 *  void
 *****************************************************************************/
void RemoveEMSObjectUIHeader(U32 object_type, U8 *source, U8 *destination)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 object_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (object_type & 0xff)
    {
        case EMS_USERDEFINED_MELODY:
            object_size = destination[1];
            object_size |= destination[2] << 8;
            gui_memcpy(destination, (source + 3), object_size);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetEMSObjectPDUSize
 * DESCRIPTION
 *  get object PDU size
 * PARAMETERS
 *  data        [IN]     data of obj
 *  size        [OUT]    size of obj 
 * RETURNS
 *  void
 *****************************************************************************/
void GetEMSObjectPDUSize(U8 *data, S32 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (data != NULL)
    {
        U8 ID = data[0];

        switch (ID)
        {
            case EMS_PREDEFINED_PICTURE:
                *size = *size - 8;
                *size = *size + EMS_PREDEFINED_PICTURE_HEADER_SIZE;
                break;
            case EMS_USERDEFINED_PICTURE:
                *size = *size - 8;
                *size = *size + EMS_USERDEFINED_PICTURE_HEADER_SIZE;
                break;
            case EMS_PREDEFINED_ANIMATION:
                *size = *size + EMS_PREDEFINED_ANIMATION_HEADER_SIZE;
                break;
            case EMS_USERDEFINED_ANIMATION:
                *size = *size - 8;
                *size = *size + EMS_USERDEFINED_ANIMATION_HEADER_SIZE;
                break;
            case EMS_PREDEFINED_SOUND:
                *size = *size + EMS_PREDEFINED_SOUND_HEADER_SIZE;
                break;
            case EMS_USERDEFINED_MELODY:
                *size = *size - 3;
                *size = *size + EMS_USERDEFINED_MELODY_HEADER_SIZE;
                break;
            case EMS_PREDEFINED_MELODY:
                *size = *size - 3;
                *size = *size + EMS_PREDEFINED_MELODY_HEADER_SIZE;
                break;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetEMSPredefinedObjectPDUSize
 * DESCRIPTION
 *  get predefined object PDU size
 * PARAMETERS
 *  object_type     [IN]        object type
 * RETURNS
 *  
 *****************************************************************************/
S32 GetEMSPredefinedObjectPDUSize(U32 object_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (object_type & 0xff)
    {
        case EMS_PREDEFINED_ANIMATION:
            size = (1 + EMS_PREDEFINED_ANIMATION_HEADER_SIZE);
        case EMS_PREDEFINED_SOUND:
            size = (1 + EMS_PREDEFINED_SOUND_HEADER_SIZE);
    }
    return (size);
}

const U8 EMS_invalid_object_symbol[] = {EMS_PREDEFINED_PICTURE, 0x01, 0x18, 0x00, 0x18, 0x00, 0x48, 0x00,
    0x00, 0xFF, 0x00, 0x03, 0x00, 0xC0, 0x04, 0x00, 0x20, 0x18, 0x7E, 0x18, 0x11, 0xFF, 0x88, 0x23,
    0xFF, 0xC4, 0x47, 0xC3, 0xE2, 0x4F, 0x81, 0xF2, 0x8F, 0x3C, 0xF1, 0x9F, 0x3C, 0xF9, 0x9F, 0xFC,
    0xF9, 0x9F, 0xF9, 0xF9, 0x9F, 0xF3, 0xF9, 0x9F, 0xE7, 0xF9, 0x9F, 0xE7, 0xF9, 0x8F, 0xFF, 0xF1,
    0x4F, 0xFF, 0xF2, 0x47, 0xE7, 0xE2, 0x23, 0xE7, 0xC4, 0x11, 0xFF, 0x88, 0x18, 0x7E, 0x18, 0x04,
    0x00, 0x20, 0x03, 0x00, 0xC0, 0x00, 0xFF, 0x00,
};


S32 *category_144_object_list_index = NULL;
S32 category_144_object_list_n_items = 0;
S32 category_144_object_list_default_index = 0;
vertical_scrollbar category144_vbar;
EMSObject category_144_current_object;
EMSObjData category_144_current_object_data;
U8 **category_144_userdefined_objects = NULL;
U16 *category_144_predefined_objects = NULL;
U8 **category_144_list_of_titles = NULL;
U32 category_144_object_list_flags = 0;

/* image pre-loading for objects stored on a file system */
U8 category_144_object_file_flag = 0;
U8 *(*load_EMS_object_file) (S32 index) = NULL;
U8 category_144_autodetect_object_type;
U8 *category_144_data_ptr[1];
static U8 *category_144_file_data = NULL;
/*****************************************************************************
 * FUNCTION
 *  category_144_load_invalid_object_symbol
 * DESCRIPTION
 *  Redraws the object list screen
 * PARAMETERS
 *  obj     [OUT]     object pointer
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_load_invalid_object_symbol(EMSObject *obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSObjData *object = obj->data;
    U8 *data = (U8*) EMS_invalid_object_symbol;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    obj->Type = EMS_TYPE_PIC;
    object->picture.bitsPerPixel = data[1];
    object->picture.hDim = data[2] | (data[3] << 8);
    object->picture.vDim = data[4] | (data[5] << 8);
    object->picture.pdu_length = data[6] | (data[7] << 8);
    data += 8;
    object->picture.pdu = data;
}


/*****************************************************************************
 * FUNCTION
 *  category_144_load_object
 * DESCRIPTION
 *  load object by index
 * PARAMETERS
 *  index       [IN]        index to load
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_load_object(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 object_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((index < 0) || (index >= category_144_object_list_n_items))
    {
        return;
    }
    object_type = (U8) (category_144_object_list_flags & 0x0f);
    /* image pre-loading for objects stored on a file system */
    if ((category_144_object_file_flag) || (category_144_autodetect_object_type))
    {
        U8 *object_data;

        if (load_EMS_object_file != NULL)
        {
            object_data = (U8*) load_EMS_object_file(index);
            if (object_data != NULL)
            {
                if (category_144_autodetect_object_type)
                {
                    object_type = (U8) object_data[0];
                }
                switch (object_type)
                {
                    case EMS_PREDEFINED_PICTURE:
                        category_144_current_object.Type = EMS_TYPE_PIC;
                        EMS_predefined_pictures[index] = object_data;
                        break;

                    case EMS_USERDEFINED_PICTURE:
                        category_144_current_object.Type = EMS_TYPE_PIC;
                        category_144_userdefined_objects[index] = object_data;
                        break;

                    case EMS_USERDEFINED_ANIMATION:
                        category_144_current_object.Type = EMS_TYPE_USERDEF_ANM;
                        category_144_userdefined_objects[index] = object_data;
                        break;

                        /* MTK Joy added for customization, 1014 */
                #if defined(__MMI_IMELODY_SUPPORT__)

                    case EMS_PREDEFINED_MELODY:
                        category_144_current_object.Type = EMS_TYPE_USERDEF_SND;
                        EMS_predefined_melodies[index] = object_data;
                        break;

                    case EMS_USERDEFINED_MELODY:
                        category_144_current_object.Type = EMS_TYPE_USERDEF_SND;
                        category_144_userdefined_objects[index] = object_data;
                        break;
                #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
                        /* MTK end */
                }
            }
        }
    }
    switch (object_type)
    {
        case EMS_PREDEFINED_PICTURE:
    #ifdef __EMS_REL5__
            if (EMS_load_object
                (object_type, NULL, category_144_predefined_objects[index],
                 category_144_current_object.data) == EMS_INVALID_OBJECT &&
                category_144_current_object.data->picture.attribute != 1)
    #else /* __EMS_REL5__ */ 
            if (EMS_load_object
                (object_type, NULL, category_144_predefined_objects[index],
                 category_144_current_object.data) == EMS_INVALID_OBJECT)
    #endif /* __EMS_REL5__ */ 
                category_144_load_invalid_object_symbol(&category_144_current_object);
            break;

        case EMS_USERDEFINED_PICTURE:
    #ifdef __EMS_REL5__
            if (EMS_load_object
                (object_type, category_144_userdefined_objects[index], 0,
                 category_144_current_object.data) == EMS_INVALID_OBJECT &&
                category_144_current_object.data->picture.attribute != 1)
    #else /* __EMS_REL5__ */ 
            if (EMS_load_object
                (object_type, category_144_userdefined_objects[index], 0,
                 category_144_current_object.data) == EMS_INVALID_OBJECT)
    #endif /* __EMS_REL5__ */ 
                category_144_load_invalid_object_symbol(&category_144_current_object);
            break;

        case EMS_USERDEFINED_ANIMATION:
    #ifdef __EMS_REL5__
            if (EMS_load_object
                (object_type, category_144_userdefined_objects[index], 0,
                 category_144_current_object.data) == EMS_INVALID_OBJECT &&
                category_144_current_object.data->animation.attribute != 1)
    #else /* __EMS_REL5__ */ 
            if (EMS_load_object
                (object_type, category_144_userdefined_objects[index], 0,
                 category_144_current_object.data) == EMS_INVALID_OBJECT)
    #endif /* __EMS_REL5__ */ 
                category_144_load_invalid_object_symbol(&category_144_current_object);
            break;

        case EMS_PREDEFINED_ANIMATION:
            category_144_current_object.Type = EMS_TYPE_PREDEF_ANM;
            category_144_current_object.PredefNo = (U8) category_144_predefined_objects[index];
            break;

        case EMS_PREDEFINED_SOUND:
            category_144_current_object.Type = EMS_TYPE_PREDEF_SND;
            category_144_current_object.PredefNo = (U8) category_144_predefined_objects[index];
            break;

            /* MTK Joy added for customization, 1014 */
    #if defined(__MMI_IMELODY_SUPPORT__)

        case EMS_PREDEFINED_MELODY:
    #ifdef __EMS_REL5__
            if (EMS_load_object
                (EMS_PREDEFINED_MELODY, NULL, category_144_predefined_objects[index],
                 category_144_current_object.data) == EMS_INVALID_OBJECT &&
                category_144_current_object.data->sound.attribute != 1)
    #else /* __EMS_REL5__ */ 
            if (EMS_load_object
                (EMS_PREDEFINED_MELODY, NULL, category_144_predefined_objects[index],
                 category_144_current_object.data) == EMS_INVALID_OBJECT)
    #endif /* __EMS_REL5__ */ 
                category_144_load_invalid_object_symbol(&category_144_current_object);
            break;

        case EMS_USERDEFINED_MELODY:
    #ifdef __EMS_REL5__
            if (EMS_load_object
                (EMS_USERDEFINED_MELODY, category_144_userdefined_objects[index], 0,
                 category_144_current_object.data) == EMS_INVALID_OBJECT &&
                category_144_current_object.data->sound.attribute != 1)
    #else /* __EMS_REL5__ */ 
            if (EMS_load_object
                (EMS_USERDEFINED_MELODY, category_144_userdefined_objects[index], 0,
                 category_144_current_object.data) == EMS_INVALID_OBJECT)
    #endif /* __EMS_REL5__ */ 
                category_144_load_invalid_object_symbol(&category_144_current_object);
            break;
    #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
            /* MTK end */
    }
}


/*****************************************************************************
 * FUNCTION
 *  category_144_redraw_highlighted_item
 * DESCRIPTION
 *  redraw highlight item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_redraw_highlighted_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x, y, w, h;
    color c;
    S32 index = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_144_object_list_index != NULL)
    {
        index = *category_144_object_list_index;
    }
    EMS_cancel_object_focus();
    gui_reset_clip();
    c = gui_color(255, 255, 255);
#ifdef __MMI_WALLPAPER_ON_BOTTOM__//071007 ems bg
    gdi_draw_solid_rect(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1,
        GDI_COLOR_TRANSPARENT);
#else
    gui_fill_rectangle(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1,
        c);
#endif
    gui_set_clip(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - current_MMI_theme->scrollbar_size,
        MMI_content_height + 2);
    gui_EMS_input_box_measure_object(&category_144_current_object, &w, &h);
    x = (UI_device_width >> 1) - (w >> 1);
    y = (UI_device_height >> 1) - (h >> 1);
    gui_EMS_input_box_display_object(x, y, &category_144_current_object, 1);
    if (category_144_list_of_titles != NULL)
    {
        MMI_title_string = (UI_string_type) category_144_list_of_titles[index];
        draw_title();
    }
    /* Uncomment below line for auto-disable scrollbar    */
    if (category_144_object_list_n_items > 1)
    {
        gui_set_vertical_scrollbar_range(&category144_vbar, category_144_object_list_n_items);
        gui_set_vertical_scrollbar_scale(&category144_vbar, 1);
        gui_set_vertical_scrollbar_value(&category144_vbar, index);

        if (mmi_fe_get_r2l_state())
        {
            /* move vertical scrollbar to the left side */
            gui_move_vertical_scrollbar(
                    &category144_vbar, 
                    0, 
                    category144_vbar.y);
        }

        gui_show_vertical_scrollbar(&category144_vbar);
    }
    gui_BLT_double_buffer(
        0,
        (MMI_title_y + MMI_title_height),
        UI_device_width - 1,
        UI_device_height - MMI_button_bar_height - 1);
}


/*****************************************************************************
 * FUNCTION
 *  category_144_highlight_handler
 * DESCRIPTION
 *  category 144 highlight handler
 * PARAMETERS
 *  index       [IN]        index of highlight item
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_highlight_handler(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    wgui_title_set_menu_shortcut_number(index + 1);
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    if (!wgui_title_get_menu_shortcut_handler_display())
    {
        draw_title();
    }
#endif /*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
	MMI_user_highlight_handler_Ext((U8)eListhighlight, index);
}


/*****************************************************************************
 * FUNCTION
 *  category_144_goto_item
 * DESCRIPTION
 *  goto item by index
 * PARAMETERS
 *  index       [IN]        index of item
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_goto_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index < 0)
    {
        return;
    }
    if (index > (category_144_object_list_n_items - 1))
    {
        return;
    }
    if (!whether_no_small_screen())
    {
        *category_144_object_list_index = index;
    }
    category_144_load_object(index);
    if (!whether_no_small_screen())
    {
        category_144_redraw_highlighted_item();
    }
    category_144_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  category_144_goto_previous_item
 * DESCRIPTION
 *  goto previous item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_goto_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_144_object_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index--;
    if (index < 0)
    {
        index = category_144_object_list_n_items - 1;
    }
    *category_144_object_list_index = index;
#ifdef __MMI_SMALL_IMAGE_SELECTOR_SCREEN__
    /* do not load object if the small screen is on because redraw_small_image_selector_images will take care of it */
    if (whether_no_small_screen())
    {
        small_image_selector_configure_current_display(&small_image_selector, *category_144_object_list_index);
        redraw_small_image_selector_images();
    }
    else
#endif /* __MMI_SMALL_IMAGE_SELECTOR_SCREEN__ */ 
    {
        category_144_load_object(index);
        category_144_redraw_highlighted_item();
        category_144_highlight_handler(index);
    }
}


/*****************************************************************************
 * FUNCTION
 *  category_144_goto_next_item
 * DESCRIPTION
 *  category 144 goto next item
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_goto_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_144_object_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index++;
    if (index > (category_144_object_list_n_items - 1))
    {
        index = 0;
    }
    *category_144_object_list_index = index;
#ifdef __MMI_SMALL_IMAGE_SELECTOR_SCREEN__
    /* do not load object if the small screen is on because redraw_small_image_selector_images will take care of it */
    if (whether_no_small_screen())
    {
        small_image_selector_configure_current_display(&small_image_selector, *category_144_object_list_index);
        redraw_small_image_selector_images();
    }
    else
#endif /* __MMI_SMALL_IMAGE_SELECTOR_SCREEN__ */ 
    {
        category_144_load_object(index);
        category_144_redraw_highlighted_item();
        category_144_highlight_handler(index);
    }
}


/*****************************************************************************
 * FUNCTION
 *  category_144_key_handler
 * DESCRIPTION
 *  category 144 keypad handler
 * PARAMETERS
 *  vkey_code       [IN]        virtual key code
 *  key_state       [IN]        key state
 * RETURNS
 *  void
 *****************************************************************************/
void category_144_key_handler(S32 vkey_code, S32 key_state)
{
#if 0    
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
/* under construction !*/
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
#else

    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);

#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
}


/*****************************************************************************
 * FUNCTION
 *  RegisterCategory144ObjectLoader
 * DESCRIPTION
 *  register category 144 object load callback
 * PARAMETERS
 *  f       [IN]        callback function
 * RETURNS
 *  void
 *****************************************************************************/
void RegisterCategory144ObjectLoader(U8 *(*f) (S32 index))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    load_EMS_object_file = f;
}

#ifdef __MMI_TOUCH_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  category_144_pen_down_hdlr
 * DESCRIPTION
 *  category 144 pen down handler
 * PARAMETERS
 *  pos     [IN]        pen down position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category_144_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_144_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category144_vbar.x, category144_vbar.y, category144_vbar.width, category144_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category144_vbar,
                MMI_PEN_EVENT_DOWN,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_144_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_144_pen_up_hdlr
 * DESCRIPTION
 *  category 144 pen up handler
 * PARAMETERS
 *  pos     [IN]        pen up position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category_144_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_144_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category144_vbar.x, category144_vbar.y, category144_vbar.width, category144_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category144_vbar,
                MMI_PEN_EVENT_UP,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_144_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_144_pen_move_hdlr
 * DESCRIPTION
 *  category 144 pen move handler
 * PARAMETERS
 *  pos     [IN]        pen move position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category_144_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_144_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category144_vbar.x, category144_vbar.y, category144_vbar.width, category144_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category144_vbar,
                MMI_PEN_EVENT_MOVE,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_144_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  category_144_pen_repeat_hdlr
 * DESCRIPTION
 *  category 144 pen repeat handler
 * PARAMETERS
 *  pos     [IN]        pen repeat position
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL category_144_pen_repeat_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gui_scrollbar_pen_enum scrollbar_event;
    gui_pen_event_param_struct scrollbar_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (category_144_object_list_n_items > 1)
    {
        if (PEN_CHECK_BOUND
            (pos.x, pos.y, category144_vbar.x, category144_vbar.y, category144_vbar.width, category144_vbar.height))
        {
            gui_vertical_scrollbar_translate_pen_event(
                &category144_vbar,
                MMI_PEN_EVENT_REPEAT,
                pos.x,
                pos.y,
                &scrollbar_event,
                &scrollbar_param);
            if (scrollbar_event == GUI_SCROLLBAR_PEN_JUMP_TO_I)
            {
                category_144_goto_item((S32) scrollbar_param._u.i);
            }
            return MMI_TRUE;
        }
    }
    return MMI_FALSE;
}

#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  DrawCate144CategoryControlArea
 * DESCRIPTION
 *  Draws the category144 category control area
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate144CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    category_144_redraw_highlighted_item();
}

#ifdef __MMI_SMALL_IMAGE_SELECTOR_SCREEN__

//extern U16 title_bg_id;
U16 g_small_image_selector = 0;
UI_filled_area *old_title_filler;
static S16 small_image_selector_index[MAX_IMAGE_SELECTOR_ROW][MAX_IMAGE_SELECTOR_COL];


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_configure_current_display
 * DESCRIPTION
 *  function used to configure the current items to be displayed on the small screen
 *  calculates the first item to be displayed
 * PARAMETERS
 *  s                           [IN]        Small image sleector structure
 *  new_highlighted_image       [IN]        New highlighted image
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_configure_current_display(small_image_selector_struct *s, S32 new_highlighted_image)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 new_highlighted_row, new_highlighted_column;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_highlighted_row = new_highlighted_image / s->n_columns;
    new_highlighted_column = new_highlighted_image % s->n_columns;

    if (s->flags & UI_SMALL_IMAGE_SELECTOR_SHOW_VERTICAL_SCROLLBAR)
    {
        if (new_highlighted_row == 0)
        {
            s->first_displayed_row = 0;
        }
        else if (new_highlighted_row > s->highlighted_row)
        {
            if (new_highlighted_row == s->n_rows - 1 && s->highlighted_row == 0)
            {
                s->first_displayed_row = new_highlighted_row - s->displayed_rows + 1;
            }
            else if ((new_highlighted_row - s->first_displayed_row) >= s->displayed_rows &&
                     (s->n_rows - new_highlighted_row) > s->displayed_rows)
            {
                s->first_displayed_row = new_highlighted_row;
            }
            else if ((new_highlighted_row - s->first_displayed_row) >= s->displayed_rows &&
                     (s->n_rows - new_highlighted_row) > 0)
            {
                s->first_displayed_row = new_highlighted_row - 1;
            }
        }
        else if (new_highlighted_row <= (s->first_displayed_row - 1))
        {
            if (new_highlighted_row == s->n_rows - 1)
            {
                s->first_displayed_row = new_highlighted_row - s->displayed_rows + 1;
            }
            else if (new_highlighted_row >= s->displayed_rows - 1)
            {
                s->first_displayed_row = new_highlighted_row - s->displayed_rows + 1;
            }
            else
            {
                s->first_displayed_row = new_highlighted_row - 1;
            }
        }
    }
    if (s->flags & UI_SMALL_IMAGE_SELECTOR_SHOW_HORIZONTAL_SCROLLBAR)
    {
        if (new_highlighted_column == 0)
        {
            s->first_displayed_column = 0;
        }
        else if (new_highlighted_column > s->highlighted_column)
        {
            if (new_highlighted_column == s->n_columns - 1 && s->highlighted_column == 0)
            {
                s->first_displayed_column = new_highlighted_column - s->displayed_columns + 1;
            }
            else if ((new_highlighted_column - s->first_displayed_column) >= s->displayed_columns &&
                     (s->n_columns - new_highlighted_column) > s->displayed_columns)
            {
                s->first_displayed_column = new_highlighted_column;
            }
            else if ((new_highlighted_column - s->first_displayed_column) >= s->displayed_columns &&
                     (s->n_columns - new_highlighted_column) > 0)
            {
                s->first_displayed_column = new_highlighted_column - 1;
            }

        }
        else if (new_highlighted_column <= (s->first_displayed_column - 1))
        {
            if (new_highlighted_column == s->n_columns - 1)
            {
                s->first_displayed_column = new_highlighted_column - s->displayed_columns + 1;
            }
            else if (new_highlighted_column >= s->displayed_columns - 1)
            {
                s->first_displayed_column = new_highlighted_column - s->displayed_columns + 1;
            }
            else
            {
                s->first_displayed_column = new_highlighted_column - 1;
            }

        }
    }
    s->first_displayed_image = s->first_displayed_row * s->n_columns + s->first_displayed_column;
    s->highlighted_column = new_highlighted_column;
    s->highlighted_row = new_highlighted_row;
}


/*****************************************************************************
 * FUNCTION
 *  associate_small_image_selector
 * DESCRIPTION
 *  function used to initialize the small image selector structure
 * PARAMETERS
 *  s       [IN]        Small image sleector structure
 * RETURNS
 *  void
 *****************************************************************************/
void associate_small_image_selector(small_image_selector_struct *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    s->displayed_columns = 0;
    s->displayed_rows = 0;
    s->first_displayed_column = 0;
    s->first_displayed_row = 0;
    s->first_displayed_image = 0;
    s->highlighted_column = 0;
    s->highlighted_row = 0;
    s->highlighted_image = 0;
    s->n_columns = 0;
    s->n_rows = 0;
    s->flags = 0;
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_auto_calculate
 * DESCRIPTION
 *  Function used to auto calculate the no. of rows and columns depending upon the display area.
 * PARAMETERS
 *  s       [IN]        Small image sleector structure
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_auto_calculate(small_image_selector_struct *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    s->n_columns = s->displayed_columns;

    if (s->displayed_rows == 1)
    {
        s->n_columns = s->n_images;
        s->n_rows = 1;
    }
    else if (s->displayed_columns == 1)
    {
        s->n_columns = 1;
        s->n_rows = s->n_images;
    }
    else
    {
        s->n_rows = pixtel_highdivide(s->n_images, s->n_columns);
    }
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_auto_configure
 * DESCRIPTION
 *  Function used to auto configure the no. of rows and columns to be displayed depending upon the display area.
 * PARAMETERS
 *  s       [IN]        Small image sleector structure
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_auto_configure(small_image_selector_struct *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 show_vbar = 0, show_hbar = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((s->n_columns <= 0) && (s->image_width <= 0))
    {
        return;
    }
    if ((s->n_rows <= 0) && (s->image_height <= 0))
    {
        return;
    }
    if (s->n_images == 0)
    {
        return;
    }

    /* Calculate the number of displayed rows and columns    */
    s->displayed_rows = s->height / s->image_height;
    s->displayed_columns = s->width / s->image_width;

    if (s->displayed_rows > MAX_IMAGE_SELECTOR_ROW)
        s->displayed_rows = MAX_IMAGE_SELECTOR_ROW;
    if (s->displayed_columns > MAX_IMAGE_SELECTOR_COL)
        s->displayed_columns = MAX_IMAGE_SELECTOR_COL;

    small_image_selector_auto_calculate(s);

    if (s->displayed_rows < s->n_rows)
    {
        small_image_selector_auto_calculate(s);
    }

    if ((s->n_rows > s->displayed_rows))
    {
        show_vbar = 1;
        s->flags |= UI_SMALL_IMAGE_SELECTOR_SHOW_VERTICAL_SCROLLBAR;
    }
    if ((s->n_columns > s->displayed_columns))
    {
        show_hbar = 1;
        s->flags |= UI_SMALL_IMAGE_SELECTOR_SHOW_HORIZONTAL_SCROLLBAR;
    }

    if (show_vbar)
    {
        s->width = s->width - s->vbar.width + 1;
    }
    if (show_hbar)
    {
        s->height = s->height - s->hbar.height + 1;
    }

    /* Recalculate the number of rows that can be displayed  */
    s->displayed_rows = s->height / s->image_height;
    s->displayed_columns = s->width / s->image_width;

    /* Fix the number of displayed rows and columns       */
    if (s->displayed_columns > s->n_columns)
    {
        s->displayed_columns = s->n_columns;
    }
    if (s->displayed_rows > s->n_rows)
    {
        s->displayed_rows = s->n_rows;
    }

    s->h_gap = (s->width - s->displayed_columns * s->image_width) / (s->displayed_columns + 1);
    s->v_gap = (s->height - s->displayed_rows * s->image_height) / (s->displayed_rows + 1);

    if (show_vbar && (!show_hbar))
    {
        gui_resize_vertical_scrollbar(&s->vbar, s->vbar.width, s->height);
    }
    if (show_hbar && (!show_vbar))
    {
        gui_resize_horizontal_scrollbar(&s->hbar, s->width, s->hbar.height);
    }
    if (show_vbar && show_hbar)
    {
        gui_resize_vertical_scrollbar(&s->vbar, s->vbar.width, s->height - s->hbar.height);
        gui_resize_horizontal_scrollbar(&s->hbar, s->width - s->vbar.width, s->hbar.height);
    }
    gui_move_vertical_scrollbar(&s->vbar, s->x + s->width, s->y);
    gui_move_horizontal_scrollbar(&s->hbar, s->x, s->y + s->height);
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_set_up
 * DESCRIPTION
 *  set up function for small image selector
 * PARAMETERS
 *  s               [IN]        Small image sleector structure
 *  n_images        [IN]        Total no. of images
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_set_up(small_image_selector_struct *s, S32 n_images)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, x2, y1, y2;
    S32 w, h;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    x1 = MMI_SMALL_SCREEN_X_OFFSET;
    x2 = UI_device_width - MMI_SMALL_SCREEN_X_OFFSET;
    y1 = MMI_title_y + MMI_title_height;
    y2 = UI_device_height - (MMI_button_bar_height + MMI_SMALL_SCREEN_Y_OFFSET);
    category_144_load_object(0);
    gui_EMS_input_box_measure_object(&category_144_current_object, &w, &h);
    s->x = x1;
    s->y = y1;
    s->height = y2 - y1;
    s->width = x2 - x1;
    s->image_height = h;
    s->image_width = w;
    s->n_images = n_images;

    gui_create_vertical_scrollbar(
        &s->vbar,
        s->x + s->width - current_MMI_theme->scrollbar_size - 1,
        s->y + 2,
        current_MMI_theme->scrollbar_size,
        s->height - current_MMI_theme->scrollbar_size - 3);
    gui_create_horizontal_scrollbar(
        &s->hbar,
        s->x + 2,
        s->y + s->height - current_MMI_theme->scrollbar_size - 1,
        s->width - current_MMI_theme->scrollbar_size - 3,
        current_MMI_theme->scrollbar_size);
    small_image_selector_auto_configure(s);
}

/*****************************************************************************
 * FUNCTION
 *  redraw_small_image_selector_images
 * DESCRIPTION
 *  redraw function for the small image selector screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void redraw_small_image_selector_images(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, x, y, w, h, start_x, end_x, end_y, row, col, displayed_column;
    S32 current_row = 0;
    small_image_selector_struct *s = &small_image_selector;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_lock_double_buffer();
    EMS_cancel_object_focus();
    gui_draw_filled_area(
        MMI_title_x - 1,
        MMI_title_y - 1,    /* 101706 image select */
        UI_device_width - MMI_SMALL_SCREEN_X_OFFSET,
        UI_device_height - MMI_button_bar_height - MMI_SMALL_SCREEN_Y_OFFSET + 2,
        current_UI_theme->EMS_inputbox_theme->disabled_filler);

    x = s->x + s->h_gap;
    y = s->y + s->v_gap;
    end_x = s->x + s->width - 1;
    end_y = s->y + s->height - 1;
    start_x = x;

    for (row = 0; row < s->n_rows; row++)
    {
        for (col = 0; col < s->n_columns; col++)
        {
            small_image_selector_index[row][col] = col + row * s->n_columns;
        }
    }

    i = s->first_displayed_image;
    row = s->first_displayed_row;
    col = s->first_displayed_column;
    displayed_column = s->displayed_columns;
    for (; i < category_144_object_list_n_items; i = col + row * displayed_column)
    {
        category_144_goto_item(i);
        gui_EMS_input_box_measure_object(&category_144_current_object, &w, &h);
        start_x += w;
        if (start_x > end_x)
        {
            y += h + s->v_gap;
            current_row++;
            if (y >= end_y || current_row >= s->displayed_rows)
            {
                break;
            }
            x = MMI_SMALL_SCREEN_X_OFFSET + s->h_gap;
            start_x = x + w + s->h_gap;
            row++;
            col = s->first_displayed_column;
            col++;
        }
        else
        {
            start_x += s->h_gap;
            col++;
        }
        if (i == *category_144_object_list_index)
        {
            /* highlight currently selected item */
            gui_draw_rectangle(x - 1, y - 1, x + w, y + h, UI_COLOR_BLACK);
            /* show animation only when the highlight is on it */
            gui_EMS_input_box_display_object(x, y, &category_144_current_object, 1);
        }
        else
        {
            /* show single frame for animation when the highlight is not on it */
            gui_EMS_input_box_display_object(x, y, &category_144_current_object, 0);
        }
        x += w + s->h_gap;
    }

    category_144_goto_item(*category_144_object_list_index);
    if (s->flags & UI_SMALL_IMAGE_SELECTOR_SHOW_VERTICAL_SCROLLBAR)
    {
        gui_set_vertical_scrollbar_range(&s->vbar, s->n_rows);
        gui_set_vertical_scrollbar_scale(&s->vbar, s->displayed_rows);
        gui_set_vertical_scrollbar_value(&s->vbar, s->first_displayed_row);
        gui_show_vertical_scrollbar(&s->vbar);
    }
    if (s->flags & UI_SMALL_IMAGE_SELECTOR_SHOW_HORIZONTAL_SCROLLBAR)
    {
        gui_set_horizontal_scrollbar_range(&s->hbar, s->n_columns);
        gui_set_horizontal_scrollbar_scale(&s->hbar, s->displayed_columns);
        gui_set_horizontal_scrollbar_value(&s->hbar, s->first_displayed_column);
        gui_show_horizontal_scrollbar(&s->hbar);
    }
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(
        MMI_SMALL_SCREEN_X_OFFSET,
        MMI_title_y,
        UI_device_width - MMI_SMALL_SCREEN_X_OFFSET,
        UI_device_height - MMI_button_bar_height - 5);
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_goto_previous_item
 * DESCRIPTION
 *  Selects the previous image in the image selector screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_goto_previous_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_144_object_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index--;
    if (index < 0)
    {
        index = category_144_object_list_n_items - 1;
    }
    *category_144_object_list_index = index;
    redraw_small_image_selector_images();
    category_144_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_goto_next_item
 * DESCRIPTION
 *  Selects the next image in the image selector screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_goto_next_item(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_144_object_list_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    index++;
    if (index > (category_144_object_list_n_items - 1))
    {
        index = 0;
    }
    *category_144_object_list_index = index;
    redraw_small_image_selector_images();
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_compute_row_col
 * DESCRIPTION
 *  Calculates the row and column number of the image in the list
 * PARAMETERS
 *  index       [IN]        index to calculates
 *  row         [OUT]       row of index
 *  col         [OUT]       col of index
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_compute_row_col(S32 index, S32 *row, S32 *col)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 r, c;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    *row = -1;
    *col = -1;

    MMI_ASSERT(index >= 0 && index < category_144_object_list_n_items);

    for (r = 0; r < small_image_selector.n_rows; r++)
    {
        for (c = 0; c < small_image_selector.n_columns; c++)
        {
            if (small_image_selector_index[r][c] == index)
            {
                *row = r;
                *col = c;
                return;
            }
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_compute_previous_row_image_index
 * DESCRIPTION
 *  Calculates the actual index of the image in the list
 * PARAMETERS
 *  index       [IN]        index of previous row
 * RETURNS
 *  S32
 *****************************************************************************/
S32 small_image_selector_compute_previous_row_image_index(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 row, col, new_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(index >= 0 && index < category_144_object_list_n_items);
    small_image_selector_compute_row_col(index, &row, &col);
    MMI_ASSERT(row != -1 || col != -1);
    if (row == 0)
    {
        if (col + (small_image_selector.n_rows - 1) * small_image_selector.n_columns >= small_image_selector.n_images)
        {
            new_index = small_image_selector.n_images - 1;
        }
        else
        {
            new_index = small_image_selector_index[small_image_selector.n_rows - 1][col];
        }
        if (new_index == -1)
        {
            new_index = small_image_selector_index[small_image_selector.n_rows - 2][col];
        }
    }
    else
    {
        new_index = small_image_selector_index[row - 1][col];
    }
    return new_index;
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_compute_next_row_image_index
 * DESCRIPTION
 *  Calculates the actual index of the image in the list
 * PARAMETERS
 *  index       [IN]        index of next row
 * RETURNS
 *  S32
 *****************************************************************************/
S32 small_image_selector_compute_next_row_image_index(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 row, col, new_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(index >= 0 && index < category_144_object_list_n_items);
    small_image_selector_compute_row_col(index, &row, &col);
    MMI_ASSERT(row != -1 || col != -1);
    if (row == small_image_selector.n_rows - 1)
    {
        new_index = small_image_selector_index[0][col];
        if (new_index == -1)
        {
            new_index = small_image_selector_index[1][col];
        }
    }
    else
    {
        if ((col + (row + 1) * small_image_selector.n_columns) >= small_image_selector.n_images)
        {
            new_index = small_image_selector.n_images - 1;
        }
        else
        {
            new_index = small_image_selector_index[row + 1][col];
        }
        if (new_index == -1)
        {
            new_index = small_image_selector_index[0][col];
        }
    }
    return new_index;
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_goto_previous_row
 * DESCRIPTION
 *  Calculates the previous row
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_goto_previous_row(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_144_object_list_index, new_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_index = small_image_selector_compute_previous_row_image_index(index);
    if (new_index < 0)
    {
        new_index = category_144_object_list_n_items - 1;
    }
    *category_144_object_list_index = new_index;
    small_image_selector_configure_current_display(&small_image_selector, *category_144_object_list_index);
    redraw_small_image_selector_images();
    category_144_highlight_handler(new_index);
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_goto_next_row
 * DESCRIPTION
 *  Calculates the next row
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_goto_next_row(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = *category_144_object_list_index, new_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_index = small_image_selector_compute_next_row_image_index(index);
    if (new_index > (category_144_object_list_n_items - 1))
    {
        new_index = 0;
    }
    *category_144_object_list_index = new_index;
    small_image_selector_configure_current_display(&small_image_selector, *category_144_object_list_index);
    redraw_small_image_selector_images();
    category_144_highlight_handler(new_index);
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_key_handler
 * DESCRIPTION
 *  Executes the function depending upon the key pressed
 * PARAMETERS
 *  vkey_code       [IN]        virtual key code
 *  key_state       [IN]        key state
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_key_handler(S32 vkey_code, S32 key_state)
{
#if 0
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
/* under construction !*/
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
#else

    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);

#endif
}


/*****************************************************************************
 * FUNCTION
 *  small_image_selector_goto_item
 * DESCRIPTION
 *  Calculates the item based on the index passed
 * PARAMETERS
 *  index       [IN]        index to select
 * RETURNS
 *  void
 *****************************************************************************/
void small_image_selector_goto_item(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (index < 0)
    {
        return;
    }
    if (index > (category_144_object_list_n_items - 1))
    {
        return;
    }
    category_144_load_object(index);
    category_144_highlight_handler(index);
}


/*****************************************************************************
 * FUNCTION
 *  ExitSmallImageSelectorScreen
 * DESCRIPTION
 *  Exit the small image selector screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitSmallImageSelectorScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_cancel_object_focus();
    close_EMS_objects();
    EMS_view_mode = 0;

    reset_small_screen();

    //title_bg_id = 0;

    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR); /* 052906 early status icon */

    MMI_title_x = MMI_TITLE_X;
    MMI_title_y = MMI_TITLE_Y;
    MMI_title_width = UI_device_width;

    category_144_object_list_index = NULL;
    category_144_object_list_n_items = 0;
    category_144_list_of_titles = NULL;
    category_144_object_list_flags = 0;
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    load_EMS_object_file = NULL;
    entry_full_screen();
    
    if (category_144_file_data!=NULL)
    {
        mmi_frm_scrmem_free(category_144_file_data);
        category_144_file_data = NULL;
    }

    current_window_title_theme->active_filler = old_title_filler;
    gui_title_set_theme(&g_wgui_title_bar, current_window_title_theme);
}

#ifdef __MMI_TOUCH_SCREEN__
/*****************************************************************************
* FUNCTION
*  small_image_selector_pen_down_hdlr
*
* DESCRIPTION
*   This is the pen event down handler.
*
* PARAMETERS
* pos     [IN]        co-ordinates to the point of contact of pen on LCD.
* 
*  
* RETURNS                 
* BOOL
*
* GLOBALS AFFECTED        
*   
*****************************************************************************/
MMI_BOOL small_image_selector_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(PEN_CHECK_BOUND(pos.x,pos.y, small_image_selector.x, small_image_selector.y,small_image_selector.width, small_image_selector.height))
    {
        S32 i,x,y,w,h,start_x,end_x,end_y,row,col,displayed_column;
        S32 current_row=0;
        small_image_selector_struct *s = &small_image_selector;

        x = s->x + s->h_gap;
        y = s->y    + s->v_gap;
        end_x = s->x + s->width -1;
        end_y = s->y + s->height -1;
        start_x = x;
        i = s->first_displayed_image;
        row = s->first_displayed_row;
        col = s->first_displayed_column;
        displayed_column = s->displayed_columns;
        for(;i<category_144_object_list_n_items;i = col+row*displayed_column)
        {
            w = s->image_width;
            h = s->image_height; 
            start_x+=w;
            if(start_x > end_x)
            {
                y+=h+s->v_gap;
                current_row++;
                if(y>=end_y || current_row>=s->displayed_rows)
                    break;
                x = MMI_SMALL_SCREEN_X_OFFSET  + s->h_gap;
                start_x = x + w + s->h_gap;
                row++;
                col = s->first_displayed_column;
                col++;
            }
            else
            {
                start_x+=s->h_gap;
                col++;
            }
            if(PEN_CHECK_BOUND(pos.x,pos.y,x,y,w,h))
            {
                *category_144_object_list_index = i;
                small_image_selector_configure_current_display(&small_image_selector,*category_144_object_list_index);
                redraw_small_image_selector_images();
                return MMI_TRUE;
            }
            x+=w+s->h_gap;
        }
    }

    return MMI_FALSE;
}

/*****************************************************************************
* FUNCTION
*  small_image_selector_pen_up_hdlr
*
* DESCRIPTION
*   This is the pen event up handler.
*
* PARAMETERS
*  pos     [IN]        co-ordinates to the point of contact of pen on LCD.
* 
*  
* RETURNS                 
* BOOL
*
* GLOBALS AFFECTED        
*   
*****************************************************************************/

MMI_BOOL small_image_selector_pen_up_hdlr(mmi_pen_point_struct pos)
{   
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(PEN_CHECK_BOUND(pos.x,pos.y, small_image_selector.x, small_image_selector.y,small_image_selector.width, small_image_selector.height))
    {
        S32 i,x,y,w,h,start_x,end_x,end_y,row,col,displayed_column;
        S32 current_row=0;
        small_image_selector_struct *s = &small_image_selector;

        x = s->x + s->h_gap;
        y = s->y    + s->v_gap;
        end_x = s->x + s->width -1;
        end_y = s->y + s->height -1;
        start_x = x;
        i = s->first_displayed_image;
        row = s->first_displayed_row;
        col = s->first_displayed_column;
        displayed_column = s->displayed_columns;
        for(;i<category_144_object_list_n_items;i = col+row*displayed_column)
        {
            w = s->image_width;
            h = s->image_height;
            start_x+=w;
            if(start_x > end_x)
            {
                y+=h+s->v_gap;
                current_row++;
                if(y>=end_y || current_row>=s->displayed_rows)
                    break;
                x = MMI_SMALL_SCREEN_X_OFFSET  + s->h_gap;
                start_x = x + w + s->h_gap;
                row++;
                col = s->first_displayed_column;
                col++;
            }
            else
            {
                start_x+=s->h_gap;
                col++;
            }
            if(PEN_CHECK_BOUND(pos.x,pos.y,x,y,w,h))
            {
                *category_144_object_list_index = i;
                small_image_selector_configure_current_display(&small_image_selector,*category_144_object_list_index);
                PreviewEmsObjectIsDone();
                return MMI_TRUE;
            }
            x+=w+s->h_gap;
        }
    }
    
    return MMI_FALSE;
}

/*****************************************************************************
* FUNCTION
*  small_image_selector_pen_move_hdlr
*
* DESCRIPTION
*   This is the pen event move handler.
*
* PARAMETERS
*  pos     [IN]        co-ordinates to the point of contact of pen on LCD.
* 
*  
* RETURNS                 
* BOOL
*
* GLOBALS AFFECTED        
*   
*****************************************************************************/

MMI_BOOL small_image_selector_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(PEN_CHECK_BOUND(pos.x,pos.y, small_image_selector.x, small_image_selector.y,small_image_selector.width, small_image_selector.height))
    {
        S32 i,x,y,w,h,start_x,end_x,end_y,row,col,displayed_column;
        S32 current_row=0;
        small_image_selector_struct *s = &small_image_selector;

        x = s->x + s->h_gap;
        y = s->y    + s->v_gap;
        end_x = s->x + s->width -1;
        end_y = s->y + s->height -1;
        start_x = x;
        i = s->first_displayed_image;
        row = s->first_displayed_row;
        col = s->first_displayed_column;
        displayed_column = s->displayed_columns;
        for(;i<category_144_object_list_n_items;i = col+row*displayed_column)
        {
            w = s->image_width;
            h = s->image_height;
            start_x+=w;
            if(start_x > end_x)
            {
                y+=h+s->v_gap;
                current_row++;
                if(y>=end_y || current_row>=s->displayed_rows)
                    break;
                x = MMI_SMALL_SCREEN_X_OFFSET  + s->h_gap;
                start_x = x + w + s->h_gap;
                row++;
                col = s->first_displayed_column;
                col++;
            }
            else
            {
                start_x+=s->h_gap;
                col++;
            }
            if(PEN_CHECK_BOUND(pos.x,pos.y,x,y,w,h))
            {
                *category_144_object_list_index = i;
                small_image_selector_configure_current_display(&small_image_selector,*category_144_object_list_index);
                redraw_small_image_selector_images();
                return MMI_TRUE;
            }
            x+=w+s->h_gap;
        }
    }

    return MMI_FALSE;
}
#endif /* __MMI_TOUCH_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  RedrawSmallImageSelectorScreen
 * DESCRIPTION
 *  Redraws the image selector screen for the small screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawSmallImageSelectorScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_greyscale_rectangle(
        0,
        0,
        UI_device_width - 1,
        UI_device_height - 1,
        MMI_BG_GREYSCALE_VALUE,
        MMI_BG_GREYSCALE_BLACK_VALUE);
    gui_set_clip(0, MMI_title_y, UI_device_width - 1, UI_device_height - 1);
    gui_lock_double_buffer();
    gui_hide_animations();

    draw_title();
    show_softkey_background();
    show_left_softkey();
    show_right_softkey();
    small_image_selector_set_up(&small_image_selector, category_144_object_list_n_items);
    redraw_small_image_selector_images();
    gui_unlock_double_buffer();
    gui_BLT_double_buffer(0, 0, UI_device_width - 1, UI_device_height - 1);
}

/*----------------------------------------------------------------------------
Function:         ShowImageSelectorScreen
Description:      Displays the object list screen
Input Parameters:[1] S8*      title,            Title for the screen
               [2]   U16   title_icon           Icon shown with the title
               [3]   U16   left_softkey,        Left softkey label
               [4]   U16   left_softkey_icon,   Icon for the left softkey
               [5]   U16   right_softkey,       Right softkey label
               [6]   U16   right_softkey_icon,  Icon for the right softkey
               [7]   U32   object type flags
               [8]   S32   number of objects in the list
               [9]   U8**  list of object titles
               [10]  U16*  ist of predefined objects (EMS specific IDs)
               [11]  U8**  list of user defined objects (list of EMS data)
               [12]  S32 * index                highlighted item index
               [13]  U8*   history_buffer       history buffer
Output Parameters:   none
Returns:       void
----------------------------------------------------------------------------*/


/*****************************************************************************
 * FUNCTION
 *  dm_category_144_controlled_area
 * DESCRIPTION
 *  This function is used to draw the category controlled area of idle screen
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void dm_category_144_controlled_area(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    small_image_selector_set_up(&small_image_selector, category_144_object_list_n_items);
    redraw_small_image_selector_images();
}


/*****************************************************************************
 * FUNCTION
 *  ShowImageSelectorScreen
 * DESCRIPTION
 *  Show image selector screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  object_type             [IN]        Object type
 *  n_items                 [IN]        itmes count
 *  object_titles           [IN]        String list of object title
 *  predefined_objects      [IN]        Predefined object file path
 *  userdefined_objects     [IN]        User defined object list
 *  index                   [IN]        Index list
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowImageSelectorScreen(
        S8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U32 object_type,
        S32 n_items,
        U8 **object_titles,
        U16 *predefined_objects,
        U8 **userdefined_objects,
        S32 *index,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    color c = UI_COLOR_BLACK;
    U8 h_flag;

    wgui_title_disable_menu_shortcut_display(MMI_TRUE);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_title_x = MMI_SMALL_SCREEN_X_OFFSET + 1;
    MMI_title_y = MMI_title_y + MMI_title_height + MMI_SMALL_SCREEN_Y_OFFSET;
    MMI_title_width = UI_device_width - 2 * MMI_SMALL_SCREEN_X_OFFSET - 1;

    old_title_filler = current_window_title_theme->active_filler;
    current_window_title_theme->active_filler = current_MMI_theme->small_screen_title_filler;
    gui_title_set_theme(&g_wgui_title_bar, current_window_title_theme);

#ifdef MMI_SHOW_STATUS_ICON_IN_TITLE
    wgui_status_icon_bar_enable_integrated(MMI_FALSE);
#endif
    set_small_screen();
    gui_add_cleanup_hook(disable_resized_small_screen);
    wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);
    
#if (defined(__MMI_FILE_MANAGER__))
    if (object_type & CATEGORY144_FMGR_PREVIEW)
    {
        S32 str_len;
        S32 i;
        S8 buf_filename_no_ext[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) * ENCODING_LENGTH];

        wgui_title_disable_menu_shortcut_display(MMI_TRUE);
        index = &category_144_object_list_default_index;

        if (predefined_objects == NULL)
        {
        #ifndef __COSMOS_MMI_PACKAGE__
           #ifdef __MMI_FRM_HISTORY__
            GoBackToHistory(SCR_ID_MSG_EMS_INSERT_OBJECT);
           #endif /*__MMI_FRM_HISTORY__*/
        #endif
            return;
        }
        else
        {
            S32 errorCode = 0;
            FS_HANDLE emsObjectFilePtr = NULL;
            U32 filesize = 0;
            S8 *filename = (S8*) predefined_objects;

            str_len = mmi_ucs2strlen((S8*) filename);

            /* find file name - by finding "\\" */
            for (i = str_len * 2 - 2; i >= 2; i -= 2)
            {
                if (mmi_ucs2ncmp((PS8) & filename[i], (PS8) L"\\", 1) == 0)
                {
                    i += 2;
                    break;
                }
            }

            mmi_ucs2cpy((PS8) buf_filename_no_ext, (PS8) (&(filename[i])));
            ChangeTitle(title_icon, (PU8) (buf_filename_no_ext));

            userdefined_objects = category_144_data_ptr;
            category_144_file_data = mmi_frm_scrmem_alloc(CAT_144_DATA_FILE_SIZE);
            MMI_ASSERT(category_144_file_data != NULL);
            memset(category_144_file_data, 0, CAT_144_DATA_FILE_SIZE);
            emsObjectFilePtr = FS_Open((WCHAR*) predefined_objects, FS_READ_ONLY);
            if (emsObjectFilePtr > 0)
            {
                FS_GetFileSize(emsObjectFilePtr, &filesize);
                if (filesize > 1600 /* bytes */ )
                {
                    FS_Close(emsObjectFilePtr);
                    userdefined_objects[0] = NULL;
                }
                FS_Read(emsObjectFilePtr, category_144_file_data, filesize, (U32*)&errorCode);
                FS_Close(emsObjectFilePtr);

                userdefined_objects[0] = category_144_file_data;
            }
            else
            {
                userdefined_objects[0] = NULL;
            }
        }
    }
#endif /* (defined(__MMI_FILE_MANAGER__)) */ 

    if (!history_buffer)
    {
        associate_small_image_selector(&small_image_selector);
    }
    gdi_layer_lock_frame_buffer();
    initialize_EMS_objects();
    EMS_view_mode = 1;
    category_144_object_file_flag = 0;
    category_144_object_list_flags = object_type;
    category_144_current_object.data = &category_144_current_object_data;
    category_144_autodetect_object_type = 0;

    switch (object_type & 0x0f)
    {
            /* small screen is only applicable to picture and animation */
        case EMS_PREDEFINED_PICTURE:
            category_144_current_object.Type = EMS_TYPE_PIC;
            category_144_object_file_flag = 1;
            break;
        case EMS_USERDEFINED_PICTURE:
            category_144_current_object.Type = EMS_TYPE_PIC;
            category_144_object_file_flag = 1;
            break;
        case EMS_PREDEFINED_ANIMATION:
            category_144_current_object.Type = EMS_TYPE_PREDEF_ANM;
            break;
        case EMS_USERDEFINED_ANIMATION:
            category_144_current_object.Type = EMS_TYPE_USERDEF_ANM;
            category_144_object_file_flag = 1;
            break;
        default:
            MMI_ASSERT(0);
            break;
    }

    clear_left_softkey();
    clear_right_softkey();
    SetupCategoryKeyHandlers();
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__

    MMI_title_icon = get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    if (!((object_type & CATEGORY144_FMGR_PREVIEW) && (!(object_type & CATEGORY144_EMAIL_PREVIEW))))
    {
        MMI_title_string = (UI_string_type) title;
    }
    category_144_object_list_index = index;
    category_144_userdefined_objects = userdefined_objects;
    category_144_predefined_objects = predefined_objects;
    h_flag = set_object_list_category_history(MMI_CATEGORY146_ID, history_buffer, category_144_object_list_index);
    if (h_flag)
    {
        *index = *category_144_object_list_index;
    }

    category_144_object_list_n_items = n_items;
    if (*index < 0)
    {
        *index = 0;
    }
    if (*index >= n_items)
    {
        *index = n_items - 1;
    }
    if ((!(object_type & CATEGORY144_DISABLE_PREVIEW)) && (!(object_type & CATEGORY144_FMGR_PREVIEW)))
    {
        register_keyboard_key_handler(small_image_selector_key_handler);
        SetKeyHandler(small_image_selector_goto_previous_row, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(small_image_selector_goto_previous_row, KEY_UP_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(small_image_selector_goto_next_row, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(small_image_selector_goto_next_row, KEY_DOWN_ARROW, KEY_EVENT_REPEAT);

        SetKeyHandler(category_144_goto_previous_item, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_previous_item, KEY_LEFT_ARROW, KEY_EVENT_REPEAT);
        SetKeyHandler(category_144_goto_next_item, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_next_item, KEY_RIGHT_ARROW, KEY_EVENT_REPEAT);

        SetKeyHandler(category_144_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_previous_item, KEY_VOL_UP, KEY_EVENT_REPEAT);
        SetKeyHandler(category_144_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_REPEAT);
    }

    //title_bg_id = IMG_FLEXIBLE_TITLEBAR_BG;

    gdi_layer_unlock_frame_buffer();

    if (!(object_type & CATEGORY144_DISABLE_PREVIEW))
    {
        ExitCategoryFunction = ExitSmallImageSelectorScreen;
        dm_setup_category_functions(dm_redraw_category_screen, GetCategory146History, GetCategory144HistorySize);
        dm_register_category_controlled_callback(DrawCate144CategoryControlArea);
        dm_data.s32ScrId = (S32) GetActiveScreenId();
        dm_data.s32CatId = MMI_CATEGORY146_ID;
        dm_data.s32flags = DM_NO_FLAGS;
        dm_add_rectangle(c, DM_RECTANGLE_FILL_GRAYSCALE);
        dm_setup_data(&dm_data);
        dm_register_category_controlled_callback(dm_category_144_controlled_area);
        dm_redraw_category_screen();
    }
#ifdef __MMI_TOUCH_SCREEN__
    wgui_register_category_screen_control_area_pen_handlers(small_image_selector_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
    wgui_register_category_screen_control_area_pen_handlers(small_image_selector_pen_up_hdlr, MMI_PEN_EVENT_UP);
    wgui_register_category_screen_control_area_pen_handlers(small_image_selector_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /* __MMI_TOUCH_SCREEN__ */ 

}
#endif /* __MMI_SMALL_IMAGE_SELECTOR_SCREEN__ */ 


/*****************************************************************************
 * FUNCTION
 *  ShowCategory144Screen
 * DESCRIPTION
 *  Displays the object list screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon shown with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Icon for the left softkey
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Icon for the right softkey
 *  object_type             [IN]        Object type
 *  n_items                 [IN]        itmes count
 *  object_titles           [IN]        String list of object title
 *  predefined_objects      [IN]        Predefined object file path
 *  is_short_name           [IN]        Is short file name
 *  userdefined_objects     [IN]        User defined object list
 *  index                   [IN]        Index list
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory144Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U32 object_type,
        S32 n_items,
        U8 **object_titles,
        U16 *predefined_objects,
        MMI_BOOL is_short_name,
        U8 **userdefined_objects,
        S32 *index,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 shortcut_width;
    U8 h_flag;

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_FALSE);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (defined(__MMI_FILE_MANAGER__))
    if (object_type & CATEGORY144_FMGR_PREVIEW)
    {
        S32 str_len;
        S32 i;
        S8 buf_filename_no_ext[(SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) * ENCODING_LENGTH];

        wgui_title_disable_menu_shortcut_display(MMI_TRUE);
        index = &category_144_object_list_default_index;

        if (predefined_objects == NULL)
        {
        #ifndef __COSMOS_MMI_PACKAGE__
            #ifdef __MMI_FRM_HISTORY__
            GoBackToHistory(SCR_ID_MSG_EMS_INSERT_OBJECT);
            #endif /*__MMI_FRM_HISTORY__*/
        #endif
            return;
        }
        else
        {
            S32 errorCode = 0;
            FS_HANDLE emsObjectFilePtr = NULL;
            U32 filesize = 0;
            S8 *filename = (S8*) predefined_objects;

            str_len = mmi_ucs2strlen((S8*) filename);

            /* find file name - by finding "\\" */
            for (i = str_len * 2 - 2; i >= 2; i -= 2)
            {
                if (mmi_ucs2ncmp((PS8) & filename[i], (PS8) L"\\", 1) == 0)
                {
                    i += 2;
                    break;
                }
            }

            if (is_short_name)
            {
                mmi_chset_mixed_text_to_ucs2_str(
                    (U8*) buf_filename_no_ext,
                    (MAX_SUBMENU_CHARACTERS - 1) * ENCODING_LENGTH,
                    (U8*) & filename[i],
                    PhnsetGetDefEncodingType());
            }
            else
            {
                mmi_ucs2cpy((PS8) buf_filename_no_ext, (PS8) (&(filename[i])));
            }

            if (title != NULL)
            {
                ChangeTitle(title_icon, (PU8) title);
            }
            else
            {
                ChangeTitle(title_icon, (PU8) (buf_filename_no_ext));
            }

            userdefined_objects = category_144_data_ptr;
            category_144_file_data = mmi_frm_scrmem_alloc(CAT_144_DATA_FILE_SIZE);
            MMI_ASSERT(category_144_file_data != NULL);
            memset(category_144_file_data, 0, CAT_144_DATA_FILE_SIZE);
            emsObjectFilePtr = FS_Open((WCHAR*) predefined_objects, FS_READ_ONLY);
            if (emsObjectFilePtr > 0)
            {
                FS_GetFileSize(emsObjectFilePtr, &filesize);
                if (filesize > 1600 /* bytes */ )
                {
                    FS_Close(emsObjectFilePtr);
                    userdefined_objects[0] = NULL;
                }
                FS_Read(emsObjectFilePtr, category_144_file_data, filesize, (U32*)&errorCode);
                FS_Close(emsObjectFilePtr);
                userdefined_objects[0] = category_144_file_data;
            }
            else
            {
                userdefined_objects[0] = NULL;
            }
        }
    }
#endif /* (defined(__MMI_FILE_MANAGER__)) */ 

    gdi_layer_lock_frame_buffer();
    initialize_EMS_objects();
    EMS_view_mode = 1;
    category_144_object_file_flag = 0;
    category_144_object_list_flags = object_type;
    category_144_current_object.data = &category_144_current_object_data;
    category_144_autodetect_object_type = 0;

    switch (object_type & 0x0f)
    {
        case EMS_PREDEFINED_PICTURE:
            category_144_current_object.Type = EMS_TYPE_PIC;
            category_144_object_file_flag = 1;
            break;
        case EMS_USERDEFINED_PICTURE:
            category_144_current_object.Type = EMS_TYPE_PIC;
            category_144_object_file_flag = 1;
            break;
        case EMS_PREDEFINED_ANIMATION:
            category_144_current_object.Type = EMS_TYPE_PREDEF_ANM;
            break;
        case EMS_USERDEFINED_ANIMATION:
            category_144_current_object.Type = EMS_TYPE_USERDEF_ANM;
            category_144_object_file_flag = 1;
            break;
        case EMS_PREDEFINED_SOUND:
            category_144_current_object.Type = EMS_TYPE_PREDEF_SND;
            break;

            /* MTK Joy added for customization, 1014 */
    #if defined(__MMI_IMELODY_SUPPORT__)

        case EMS_PREDEFINED_MELODY:
            category_144_current_object.Type = EMS_TYPE_USERDEF_SND;
            category_144_object_file_flag = 1;
            break;
        case EMS_USERDEFINED_MELODY:
            category_144_current_object.Type = EMS_TYPE_USERDEF_SND;
            category_144_object_file_flag = 1;
            break;
    #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
            /* MTK end */

        default:
            category_144_autodetect_object_type = 1;
            break;
    }

    clear_left_softkey();
    clear_right_softkey();
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();
	//huking	
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    MMI_title_icon = get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    if (!((object_type & CATEGORY144_FMGR_PREVIEW) && (!(object_type & CATEGORY144_EMAIL_PREVIEW))))
    {
        MMI_title_string = (UI_string_type) title;
    }
    category_144_object_list_index = index;
    category_144_userdefined_objects = userdefined_objects;
    category_144_predefined_objects = predefined_objects;

    h_flag = set_object_list_category_history(MMI_CATEGORY144_ID, history_buffer, category_144_object_list_index);
    if (h_flag)
    {
        *index = *category_144_object_list_index;
    }

    category_144_object_list_n_items = n_items;
    if (*index < 0)
    {
        *index = 0;
    }
    if (*index >= n_items)
    {
        *index = n_items - 1;
    }
    category_144_load_object(*index);
    wgui_title_set_menu_shortcut_number(*index + 1);
    category_144_object_list_index = index;
    if ((!(object_type & CATEGORY144_DISABLE_PREVIEW)) && (!(object_type & CATEGORY144_FMGR_PREVIEW)))
    {
        gui_create_vertical_scrollbar(
            &category144_vbar,
            UI_device_width - current_MMI_theme->scrollbar_size,
            (MMI_title_y + MMI_title_height),
            current_MMI_theme->scrollbar_size,
            MMI_content_height);
        register_fixed_list_shortcut_handler();
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__		
        shortcut_width = set_menu_item_count(n_items) + 7;
#else
        shortcut_width = 7;    
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
        resize_menu_shortcut_handler(shortcut_width, (MMI_title_height));
        move_menu_shortcut_handler(UI_device_width - MMI_menu_shortcut_box.width, MMI_title_y);
        register_hide_menu_shortcut(draw_title);
        register_keyboard_key_handler(category_144_key_handler);
        register_menu_shortcut_keys();
        register_menu_shortcut_handler(category_144_goto_item);
        SetKeyHandler(category_144_goto_previous_item, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_next_item, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_previous_item, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(category_144_goto_next_item, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    gdi_layer_unlock_frame_buffer();

    if (!(object_type & CATEGORY144_DISABLE_PREVIEW))
    {
        ExitCategoryFunction = ExitCategory144Screen;
        dm_setup_category_functions(dm_redraw_category_screen, GetCategory144History, GetCategory144HistorySize);
        dm_register_category_controlled_callback(DrawCate144CategoryControlArea);
    #ifdef __MMI_TOUCH_SCREEN__
        wgui_register_category_screen_control_area_pen_handlers(category_144_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
        wgui_register_category_screen_control_area_pen_handlers(category_144_pen_up_hdlr, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category_144_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
        wgui_register_category_screen_control_area_pen_handlers(category_144_pen_repeat_hdlr, MMI_PEN_EVENT_REPEAT);
    #endif /* __MMI_TOUCH_SCREEN__ */ 
        dm_data.s32ScrId = (S32) GetActiveScreenId();
        dm_data.s32CatId = MMI_CATEGORY144_ID;
        dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND | DM_LITE_DISP_WALLPAPER;//071007 ems bg
        dm_setup_data(&dm_data);
        dm_redraw_category_screen();
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory144Screen
 * DESCRIPTION
 *  Exits the object list screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory144Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_cancel_object_focus();
    close_EMS_objects();
    reset_menu_shortcut_handler();
    EMS_view_mode = 0;
    category_144_object_list_index = NULL;
    category_144_object_list_n_items = 0;
    category_144_list_of_titles = NULL;
    category_144_object_list_flags = 0;
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
    load_EMS_object_file = NULL;
    
    if (category_144_file_data!=NULL)
    {
        mmi_frm_scrmem_free(category_144_file_data);
        category_144_file_data = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory144HistorySize
 * DESCRIPTION
 *  Gets the history buffer size for the object list screen
 * PARAMETERS
 *  void
 * RETURNS
 *  size in U8s of the history buffer
 *****************************************************************************/
S32 GetCategory144HistorySize(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (sizeof(object_list_category_history));
}


/*****************************************************************************
 * FUNCTION
 *  GetCategory144History
 * DESCRIPTION
 *  Gets the history buffer for the object list screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored
 * RETURNS
 *  pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory144History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_object_list_category_history(MMI_CATEGORY144_ID, history_buffer, category_144_object_list_index);
    return (history_buffer);
}

#if defined __MMI_SMALL_IMAGE_SELECTOR_SCREEN__


/*****************************************************************************
 * FUNCTION
 *  GetCategory146History
 * DESCRIPTION
 *  Gets the history buffer for the object list screen
 * PARAMETERS
 *  history_buffer      [IN]        Is the buffer into which the history data is stored
 * RETURNS
 *  pointer to the history buffer
 *****************************************************************************/
U8 *GetCategory146History(U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    get_object_list_category_history(MMI_CATEGORY146_ID, history_buffer, category_144_object_list_index);
    return (history_buffer);
}
#endif /* defined __MMI_SMALL_IMAGE_SELECTOR_SCREEN__ */ 

EMSObjData EMS_playback_object_data;
EMSObject EMS_playback_object;


/*****************************************************************************
 * FUNCTION
 *  EMSObjectPlayback
 * DESCRIPTION
 *  start object play
 * PARAMETERS
 *  object_type     [IN]        Object type
 *  data            [IN]        Object data
 *  index           [IN]        Object index
 * RETURNS
 *  EMSTATUS EMS function status
 *****************************************************************************/
EMSTATUS EMSObjectPlayback(U32 object_type, U8 *data, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSTATUS r = EMS_load_object(object_type, data, index, &EMS_playback_object_data);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_cancel_object_focus();
    if (r != EMS_OK)
    {
        return (r);
    }
    EMS_playback_object.data = &EMS_playback_object_data;
    EMS_playback_object.prev = NULL;
    EMS_playback_object.next = NULL;
    EMS_playback_object.OffsetToText = 0;
    EMS_playback_object.PredefNo = (U8) index;
    switch (object_type & 0xff)
    {
        case EMS_PREDEFINED_SOUND:
            EMS_playback_object.Type = EMS_TYPE_PREDEF_SND;
            gui_EMS_playback_object(&EMS_playback_object);
            break;
            /* MTK Joy added for customization, 1014 */
    #if defined(__MMI_IMELODY_SUPPORT__)
        case EMS_PREDEFINED_MELODY:
            EMS_playback_object.Type = EMS_TYPE_USERDEF_SND;
            gui_EMS_playback_object(&EMS_playback_object);
            break;
        case EMS_USERDEFINED_MELODY:
            EMS_playback_object.Type = EMS_TYPE_USERDEF_SND;
            gui_EMS_playback_object(&EMS_playback_object);
            break;
    #endif /* defined(__MMI_IMELODY_SUPPORT__) */ 
            /* MTK end */
    }
    return (EMS_OK);
}


/*****************************************************************************
 * FUNCTION
 *  EMSObjectStopPlayBack
 * DESCRIPTION
 *  stop object play
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EMSObjectStopPlayBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    EMS_cancel_object_focus();
}
#endif /* __MMI_MESSAGES_EMS__ */ 

#define CAT145_SCROLL_DY   20

color cat145_message_title_color;
vertical_scrollbar cat145_vbar;
S32 cat145_h1, cat145_h2, cat145_h3, cat145_total_height, cat145_available_height;
S32 cat145_y = 0, cat145_image_x, cat145_message_title_x;
S32 cat145_clip_x1, cat145_clip_y1, cat145_clip_x2, cat145_clip_y2;
U32 cat145_flags;
U8 cat145_scrollbar_flag = 0;

// BT dialer defined
MMI_BOOL g_145_is_need_show_number = MMI_FALSE;
U8* g_145_show_number_buffer = NULL;
MMI_BOOL g_145_show_image_is_path = MMI_FALSE;
U8* g_145_show_image_path = NULL;

MMI_BOOL g_145_show_image_is_data = MMI_FALSE;
U8* g_145_show_image_data = NULL;
U8  g_145_show_image_data_type = NULL;
S32  g_145_show_image_data_size = NULL;
    #ifdef __MMI_MAINLCD_128X128__ 
        const U8 G_145_IMAGE_SIZE = 25;
        const U8 G_145_SPACE = 5;
        const U8 G_145_SMALL_SPACE = 2;
        const U8 G_145_IS_NEED_NUMBER_HIGHT = 54;
        const U8 G_145_NOT_NEED_NUMBER_HIGHT = 78;
        const U8 G_145_BT_NUMBER_HIGHT = 8;
        const U8 G_145_BT_TITLE_WIDTH = 80;
        const U8 G_145_LINE_WIDTH_BEGIN = 33;//G_145_IMAGE_SIZE + G_145_SPACE + G_145_IMAGE_SIZE / 2;
        const U8 G_145_LINE_WIDTH_END = 110;//G_145_IMAGE_SIZE * 4 - G_145_SPACE;
        const U8 G_145_NUMBER_BEGIN = 65;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
        const U8 G_145_CONTEXT_EFFORT = 2; //G_145_SMALL_SPACE - G_145_CONTEXT_EFFORT
        const U8 G_145_TITLE_EFFORT = 6;//G_145_SPACE - G_145_SMALL_SPACE;
	#elif defined (__MMI_MAINLCD_128X160__)		
		const U8 G_145_IMAGE_SIZE = 25;
		const U8 G_145_SPACE = 5;
		const U8 G_145_SMALL_SPACE = 2;
		const U8 G_145_IS_NEED_NUMBER_HIGHT = 54+30;
		const U8 G_145_NOT_NEED_NUMBER_HIGHT = 78+28;
		const U8 G_145_BT_NUMBER_HIGHT = 8;
		const U8 G_145_BT_TITLE_WIDTH = 80;
		const U8 G_145_LINE_WIDTH_BEGIN = 33;//G_145_IMAGE_SIZE + G_145_SPACE + G_145_IMAGE_SIZE / 2;
		const U8 G_145_LINE_WIDTH_END = 110;//G_145_IMAGE_SIZE * 4 - G_145_SPACE;
		const U8 G_145_NUMBER_BEGIN = 65;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
		const U8 G_145_CONTEXT_EFFORT = 2; //G_145_SMALL_SPACE - G_145_CONTEXT_EFFORT
		const U8 G_145_TITLE_EFFORT = 6;//G_145_SPACE - G_145_SMALL_SPACE;       
    #elif defined (__MMI_MAINLCD_240X320__)
	    #if  defined (__MMI_WEARABLE_DEVICE__)
		const U8 G_145_IMAGE_SIZE = 40;
		const U8 G_145_SPACE = 10;
		const U8 G_145_SMALL_SPACE = 5;
		const U16 G_145_IS_NEED_NUMBER_HIGHT =  320;
		const U8 G_145_NOT_NEED_NUMBER_HIGHT = 126;
		const U8 G_145_BT_NUMBER_HIGHT = 16;
		const U8 G_145_BT_TITLE_WIDTH = 175;
		const U8 G_145_LINE_WIDTH_BEGIN = 50;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
		const U8 G_145_LINE_WIDTH_END = 230;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
		const U8 G_145_NUMBER_BEGIN = 130;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
		const U8 G_145_CONTEXT_EFFORT = 2;
		const U8 G_145_TITLE_EFFORT = 10;//5;//G_145_SPACE - G_145_SMALL_SPACE;
		#else
        const U8 G_145_IMAGE_SIZE = 40;
        const U8 G_145_SPACE = 10;
        const U8 G_145_SMALL_SPACE = 5;
        const U8 G_145_IS_NEED_NUMBER_HIGHT = 165;
        const U8 G_145_NOT_NEED_NUMBER_HIGHT = 200;
        const U8 G_145_BT_NUMBER_HIGHT = 16;
        const U8 G_145_BT_TITLE_WIDTH = 175;
        const U8 G_145_LINE_WIDTH_BEGIN = 50;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
        const U8 G_145_LINE_WIDTH_END = 230;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
        const U8 G_145_NUMBER_BEGIN = 130;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
        const U8 G_145_CONTEXT_EFFORT = 5;
        const U8 G_145_TITLE_EFFORT = 10;//G_145_SPACE - G_145_SMALL_SPACE;
        #endif
	#elif defined (__MMI_MAINLCD_240X240__)
		const U8 G_145_IMAGE_SIZE = 40;
		const U8 G_145_SPACE = 10;
		const U8 G_145_SMALL_SPACE = 5;
		const U8 G_145_IS_NEED_NUMBER_HIGHT =  240;
		const U8 G_145_NOT_NEED_NUMBER_HIGHT = 126;
		const U8 G_145_BT_NUMBER_HIGHT = 16;
		const U8 G_145_BT_TITLE_WIDTH = 175;
		const U8 G_145_LINE_WIDTH_BEGIN = 50;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
		const U8 G_145_LINE_WIDTH_END = 230;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
		const U8 G_145_NUMBER_BEGIN = 130;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
		const U8 G_145_CONTEXT_EFFORT = 2;
		const U8 G_145_TITLE_EFFORT = 10;//5;//G_145_SPACE - G_145_SMALL_SPACE;
	#elif defined (__MMI_MAINLCD_320X320__)
		const U16 G_145_IMAGE_SIZE = 40;
		const U16 G_145_SPACE = 10;
		const U16 G_145_SMALL_SPACE = 5;
		const U16 G_145_IS_NEED_NUMBER_HIGHT =  320;
		const U16 G_145_NOT_NEED_NUMBER_HIGHT = 126;
		const U16 G_145_BT_NUMBER_HIGHT = 16;
		const U16 G_145_BT_TITLE_WIDTH = 175;
		const U16 G_145_LINE_WIDTH_BEGIN = 50;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
		const U16 G_145_LINE_WIDTH_END = 230;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
		const U16 G_145_NUMBER_BEGIN = 130;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
		const U16 G_145_CONTEXT_EFFORT = 2;
		const U16 G_145_TITLE_EFFORT = 10;//5;//G_145_SPACE - G_145_SMALL_SPACE;
	#elif defined (__MMI_MAINLCD_176X220__)
        const U8 G_145_IMAGE_SIZE = 32;
        const U8 G_145_SPACE = 8;
        const U8 G_145_SMALL_SPACE = 2;
        const U8 G_145_IS_NEED_NUMBER_HIGHT = 115;
        const U8 G_145_NOT_NEED_NUMBER_HIGHT = 136;
        const U8 G_145_BT_NUMBER_HIGHT = 10;
        const U8 G_145_BT_TITLE_WIDTH = 120;
        const U8 G_145_LINE_WIDTH_BEGIN = 45;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
        const U8 G_145_LINE_WIDTH_END = 160;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
        const U8 G_145_NUMBER_BEGIN = 96;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
        const U8 G_145_CONTEXT_EFFORT = 0;
        const U8 G_145_TITLE_EFFORT = 6;//G_145_SPACE - G_145_SMALL_SPACE;
	#elif defined (__MMI_MAINLCD_320X480__)    
	    const U8 G_145_IMAGE_SIZE = 45;
	    const U8 G_145_SPACE = 10;
	    const U8 G_145_SMALL_SPACE = 5;
	    const U32 G_145_IS_NEED_NUMBER_HIGHT = 290;
	    const U32 G_145_NOT_NEED_NUMBER_HIGHT = 327;
	    const U8 G_145_BT_NUMBER_HIGHT = 16;
	    const U8 G_145_BT_TITLE_WIDTH = 175;
	    const U8 G_145_LINE_WIDTH_BEGIN = 55;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
	    const U32 G_145_LINE_WIDTH_END = 312;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
	    const U8 G_145_NUMBER_BEGIN = 165;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
	    const U8 G_145_CONTEXT_EFFORT = 5;
	    const U8 G_145_TITLE_EFFORT = 10;//G_145_SPACE - G_145_SMALL_SPACE;
	#elif defined (__MMI_MAINLCD_320X240__) 
		const U8 G_145_IMAGE_SIZE = 32;
		const U8 G_145_SPACE = 8;
		const U8 G_145_SMALL_SPACE = 2;
		const U8 G_145_IS_NEED_NUMBER_HIGHT = 120;
		const U8 G_145_NOT_NEED_NUMBER_HIGHT = 132;
		const U8 G_145_BT_NUMBER_HIGHT = 10;
		const U8 G_145_BT_TITLE_WIDTH = 120;
		const U8 G_145_LINE_WIDTH_BEGIN = 45;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
		const U8 G_145_LINE_WIDTH_END = 160;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
		const U8 G_145_NUMBER_BEGIN = 96;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
		const U8 G_145_CONTEXT_EFFORT = 0;
		const U8 G_145_TITLE_EFFORT = 6;//G_145_SPACE - G_145_SMALL_SPACE;
#else /*__MMI_MAINLCD_320X240__*/
        const U8 G_145_IMAGE_SIZE = 32;
        const U8 G_145_SPACE = 8;
        const U8 G_145_SMALL_SPACE = 2;
        const U8 G_145_IS_NEED_NUMBER_HIGHT = 120;
        const U8 G_145_NOT_NEED_NUMBER_HIGHT = 136;
        const U8 G_145_BT_NUMBER_HIGHT = 10;
        const U8 G_145_BT_TITLE_WIDTH = 120;
        const U8 G_145_LINE_WIDTH_BEGIN = 45;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE / 2 - G_145_SPACE;
        const U8 G_145_LINE_WIDTH_END = 160;//G_145_IMAGE_SIZE * 6 - G_145_SPACE;
        const U8 G_145_NUMBER_BEGIN = 96;//G_145_IMAGE_SIZE + G_145_IMAGE_SIZE +  G_145_IMAGE_SIZE / 2
        const U8 G_145_CONTEXT_EFFORT = 0;
        const U8 G_145_TITLE_EFFORT = 6;//G_145_SPACE - G_145_SMALL_SPACE;
    #endif

#ifdef __MMI_BT_DIALER_SUPPORT__


void set_cat145_show_number(U8* buffer)
{
    g_145_is_need_show_number = MMI_TRUE;
    g_145_show_number_buffer = buffer;
}

void set_cat145_show_image_file_path(U8* image_path)
{
    g_145_show_image_is_path = MMI_TRUE;
    g_145_show_image_path = image_path;   
}

void set_cat145_show_image_finish(void)
{
    g_145_show_image_is_path = MMI_FALSE;
    g_145_show_image_path = NULL;
}


void set_cat145_show_image_file_data(U8* image_data,U8 image_type,S32 image_size)
{
    g_145_show_image_is_data = MMI_TRUE;
    g_145_show_image_data = image_data;   
    g_145_show_image_data_type = image_type;
    g_145_show_image_data_size = image_size;    
}

void set_cat145_show_image_data_finish(void)
{
    g_145_show_image_is_data = MMI_FALSE;
    g_145_show_image_data = NULL;
    g_145_show_image_data_type = NULL;
    g_145_show_image_data_size = NULL;     
}

void set_cat145_show_number_finish(void)
{
    g_145_is_need_show_number = MMI_FALSE;
}

void cat145_display_bt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = MMI_title_y + MMI_title_height + G_145_SMALL_SPACE;
    color text_color;
    U8 number_len = 0;
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(cat145_clip_x1, cat145_clip_y1, cat145_clip_x2, cat145_clip_y2);
    if (g_145_is_need_show_number)
    {
        if (g_145_show_image_is_path)
        {    
            gdi_image_draw_resized_file(G_145_SPACE, y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*)g_145_show_image_path);
        }
		else if(g_145_show_image_is_data)
		{
			gdi_image_draw_resized_mem(G_145_SPACE, y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*) g_145_show_image_data,g_145_show_image_data_type
                ,g_145_show_image_data_size);
		}
        else
        {
            gdi_image_draw_resized(G_145_SPACE, y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*) MMI_message_icon);
        }

        //// draw number and line
        number_len = mmi_ucs2strlen((const char*)g_145_show_number_buffer);
        gui_set_font(&MMI_small_font);
        gui_set_text_color(gui_color(0, 0, 0)); 
        
        if (3 == number_len)
        {
            gui_move_text_cursor(G_145_NUMBER_BEGIN, y);
        }
        else if (4 == number_len)
        {
            gui_move_text_cursor(G_145_NUMBER_BEGIN - G_145_SMALL_SPACE, y);
        }
        else if (5 == number_len)
        {
            gui_move_text_cursor(G_145_NUMBER_BEGIN - G_145_SMALL_SPACE * 3, y);
        }
        
        gui_print_text((UI_string_type)g_145_show_number_buffer);
        
        gdi_draw_line(G_145_LINE_WIDTH_BEGIN, y + G_145_BT_NUMBER_HIGHT, G_145_LINE_WIDTH_END, y + G_145_BT_NUMBER_HIGHT, GDI_COLOR_BLACK); 

        y += G_145_TITLE_EFFORT; 

        ///draw title
        gui_move_text_cursor(G_145_IMAGE_SIZE  + G_145_SPACE * 2, y + G_145_SPACE);
        gui_set_font(&MMI_large_font);
        gui_set_text_color(gui_color(0, 0, 196));
        gui_print_truncated_text(G_145_IMAGE_SIZE  + G_145_SPACE * 2, y + G_145_SPACE, G_145_BT_TITLE_WIDTH, MMI_message_string);
        y += G_145_IMAGE_SIZE + G_145_CONTEXT_EFFORT;   
    }
    else
    {
        gui_set_font(&MMI_small_font);
        gui_set_text_color(gui_color(101, 101, 101));   
        gui_move_text_cursor(G_145_SPACE, y);
        gui_print_text(MMI_message_string);
        y += G_145_SPACE + G_145_SPACE;       
    }        
   
    switch (cat145_flags & 0xff)
    {
        case CAT145_BLACK_TITLE:
            text_color = gui_color(0, 0, 0);
            break;

        case CAT145_BLUE_TITLE:
            text_color = gui_color(0, 0, 196);
            break;

        case CAT145_RED_TITLE:
            text_color = gui_color(196, 0, 0);
            break;

        case CAT145_GREEN_TITLE:
            text_color = gui_color(0, 196, 0);
            break;
        default:
            text_color = gui_color(0, 0, 0);
    }
    
    if (mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(cat145_message_title_x + gui_get_string_width((UI_string_type) MMI_message_string), y);
    }
    else
    {
        gui_move_text_cursor(G_145_SMALL_SPACE, y);
    }
    /* MTk end */
    
    gui_set_font(&MMI_default_font);
    gui_move_multi_line_input_box(&MMI_multiline_inputbox, G_145_SMALL_SPACE, y); 
    if (g_145_is_need_show_number)
    {
        resize_multiline_inputbox(MMI_multiline_inputbox.width, G_145_IS_NEED_NUMBER_HIGHT); 
    }
    else
    {
        resize_multiline_inputbox(MMI_multiline_inputbox.width, G_145_NOT_NEED_NUMBER_HIGHT); 
    }

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */

    gui_show_multi_line_input_box(&MMI_multiline_inputbox);
    gdi_layer_pop_clip();
}



#endif
void cat145_btnoti_previous_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gui_set_clip(MMI_multiline_inputbox.x, MMI_multiline_inputbox.y, MMI_multiline_inputbox.x+MMI_multiline_inputbox.width, MMI_multiline_inputbox.height+MMI_multiline_inputbox.y);
    gui_draw_filled_area(MMI_multiline_inputbox.x, MMI_multiline_inputbox.y, MMI_multiline_inputbox.x+MMI_multiline_inputbox.width, MMI_multiline_inputbox.height+MMI_multiline_inputbox.y, current_MMI_theme->general_background_filler);
    wgui_inputs_ml_previous_line();
    wgui_inputs_ml_redraw();
    gdi_layer_pop_clip();
    return;
}

void cat145_btnoti_next_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gui_set_clip(MMI_multiline_inputbox.x, MMI_multiline_inputbox.y, MMI_multiline_inputbox.x+MMI_multiline_inputbox.width, MMI_multiline_inputbox.height+MMI_multiline_inputbox.y);
    gui_draw_filled_area(MMI_multiline_inputbox.x, MMI_multiline_inputbox.y, MMI_multiline_inputbox.x+MMI_multiline_inputbox.width, MMI_multiline_inputbox.height+MMI_multiline_inputbox.y, current_MMI_theme->general_background_filler);    
    wgui_inputs_ml_next_line();
    wgui_inputs_ml_redraw();
    gdi_layer_pop_clip();
    return;
}


/*****************************************************************************
 * FUNCTION
 *  cat145_display
 * DESCRIPTION
 *  category 145 redraw
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat145_display(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = cat145_y + (MMI_title_y + MMI_title_height) + 2;
    color text_color;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(cat145_clip_x1, cat145_clip_y1, cat145_clip_x2, cat145_clip_y2);
    gdi_image_draw(cat145_image_x, y, (U8*) MMI_message_icon);
    y += cat145_h1 + 2;
    switch (cat145_flags & 0xff)
    {
        case CAT145_BLACK_TITLE:
            text_color = gui_color(0, 0, 0);
            break;

        case CAT145_BLUE_TITLE:
            text_color = gui_color(0, 0, 196);
            break;

        case CAT145_RED_TITLE:
            text_color = gui_color(196, 0, 0);
            break;

        case CAT145_GREEN_TITLE:
            text_color = gui_color(0, 196, 0);
            break;
        default:
            text_color = gui_color(0, 0, 0);
    }
    gui_set_font(&MMI_default_font);
    gui_set_text_color(text_color);
    /* MTK Elvis for R2L characters */
    if (mmi_fe_get_r2l_state())
    {
        gui_move_text_cursor(cat145_message_title_x + gui_get_string_width((UI_string_type) MMI_message_string), y);
    }
    else
    {
        gui_move_text_cursor(cat145_message_title_x, y);
    }
    /* MTk end */
    gui_print_text(MMI_message_string);
    y += cat145_h2;
    gui_move_multi_line_input_box(&MMI_multiline_inputbox, MMI_multiline_inputbox.x, y);
    gui_show_multi_line_input_box(&MMI_multiline_inputbox);
    gdi_layer_pop_clip();
}


/*****************************************************************************
 * FUNCTION
 *  cat145_previous_line
 * DESCRIPTION
 *  change to previous line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat145_previous_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_clip(0, cat145_clip_y1, UI_device_width - 1, cat145_clip_y2);
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
    cat145_y += CAT145_SCROLL_DY;
    if (cat145_y > 0)
    {
        cat145_y = 0;
    }
    gui_set_vertical_scrollbar_value(&cat145_vbar, -cat145_y);
    
    if (mmi_fe_get_r2l_state())
    {
        /* move vertical scrollbar to the left side */
        gui_move_vertical_scrollbar(
                &cat145_vbar, 
                0, 
                cat145_vbar.y);
    }

    gui_show_vertical_scrollbar(&cat145_vbar);

    cat145_display();

    gdi_layer_blt_previous(0, cat145_clip_y1, UI_device_width - 1, cat145_clip_y2);

}


/*****************************************************************************
 * FUNCTION
 *  cat145_next_line
 * DESCRIPTION
 *  change to next line
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cat145_next_line(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gui_set_clip(0, cat145_clip_y1, UI_device_width - 1, cat145_clip_y2);
    gui_draw_filled_area(0, 0, UI_device_width - 1, UI_device_height - 1, current_MMI_theme->general_background_filler);
    cat145_y -= CAT145_SCROLL_DY;
    if (cat145_y < -(cat145_total_height - cat145_available_height))
    {
        cat145_y = -(cat145_total_height - cat145_available_height);
    }
    gui_set_vertical_scrollbar_value(&cat145_vbar, -cat145_y);

    if (mmi_fe_get_r2l_state())
    {
        /* move vertical scrollbar to the left side */
        gui_move_vertical_scrollbar(
                &cat145_vbar, 
                0, 
                cat145_vbar.y);
    }

    gui_show_vertical_scrollbar(&cat145_vbar);

    cat145_display();

    gdi_layer_blt_previous(0, cat145_clip_y1, UI_device_width - 1, cat145_clip_y2);

}


/*****************************************************************************
 * FUNCTION
 *  cat145_keyboard_key_handler
 * DESCRIPTION
 *  category 145 keypad handler
 * PARAMETERS
 *  vkey_code       [IN]        virtual key code
 *  key_state       [IN]        key state
 * RETURNS
 *  void
 *****************************************************************************/
void cat145_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
#if 0     
#if(MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
/* under construction !*/
#endif /* (MMI_BUILD_TYPE == BUILD_TYPE_X86WIN32) */ 
/* under construction !*/
#else

    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state);

#endif
}


/*****************************************************************************
 * FUNCTION
 *  DrawCate145CategoryControlArea
 * DESCRIPTION
 *  Draws the category145 category control area
 * PARAMETERS
 *  coordinate      [IN]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
void DrawCate145CategoryControlArea(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RedrawCategory145Screen();
}


/*****************************************************************************
 * FUNCTION
 *  RedrawCategory145Screen
 * DESCRIPTION
 *  Redraws the Delivery report screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void RedrawCategory145Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cat145_scrollbar_flag)
    {
        if (mmi_fe_get_r2l_state())
        {
            /* move vertical scrollbar to the left side */
            gui_move_vertical_scrollbar(
                    &cat145_vbar, 
                    0, 
                    cat145_vbar.y);
        }

        gui_show_vertical_scrollbar(&cat145_vbar);
    }
    cat145_display();
}



#ifdef __MMI_EDITOR_SSP_SUPPORT__
MMI_BOOL category_145BT_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_DOWN);
       return MMI_TRUE;
   }
   return  MMI_FALSE;
    
}


MMI_BOOL category_145BT_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   
    if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
    {
        return gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_UP);
    }
    return  MMI_FALSE;    
}

MMI_BOOL category_145BT_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       return gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_MOVE);
   }
   return  MMI_FALSE;
}

MMI_BOOL category_145BT_pen_repeat_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                       MMI_multiline_inputbox.y, 
                                       MMI_multiline_inputbox.width, 
                                       MMI_multiline_inputbox.height))
    {
        return gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_REPEAT);
    }
    return  MMI_FALSE;   
}

#endif /*__MMI_EDITOR_SSP_SUPPORT__*/
/*****************************************************************************
 * FUNCTION
 *  ChangeCategory145MessageString
 * DESCRIPTION
 *  Change category 145 string.
 * PARAMETERS
 *  new_string      [IN]     string to change
 * RETURNS
 *  void
 *****************************************************************************/
void ChangeCategory145MessageString(U8 *new_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_multiline_inputbox.text = (UI_buffer_type) new_string;
    MMI_multiline_inputbox.cursor_p = new_string;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
    gui_show_multi_line_input_box(&MMI_multiline_inputbox);
    MMI_multiline_inputbox.flags &= ~UI_MULTI_LINE_INPUT_BOX_DISABLE_DRAW;
}


void cat145_bt_keyboard_key_handler(S32 vkey_code, S32 key_state)
{
    UI_UNUSED_PARAMETER(vkey_code);
    UI_UNUSED_PARAMETER(key_state); 
}


#ifdef __MMI_BT_DIALER_SUPPORT__ 




void RedrawBTCategory145BTScreen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cat145_display_bt();
}

void DrawBTCate145CategoryControlArea(dm_coordinates *coordinate)
{
    RedrawBTCategory145BTScreen();
}

void ShowBTNotiCategory145Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message_icon,
        U8 *message_title,
        U8 *message,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l, width, height, content_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    cat145_scrollbar_flag = 0;
    content_width = UI_device_width;
    l = gui_strlen((UI_string_type) message);
    create_multiline_inputbox_set_buffer((UI_string_type) message, l, l, 0);
    resize_multiline_inputbox(content_width, MMI_content_height);
    show_multiline_inputbox_no_draw();
    cat145_h3 = MMI_multiline_inputbox.height;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
      #ifndef __MMI_EDITOR_SSP_SUPPORT__
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
      #endif/*__MMI_EDITOR_SSP_SUPPORT__*/
        | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING;
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */

    MMI_message_string = (UI_string_type) message_title;
    gui_set_font(&MMI_default_font);
    gui_measure_string(MMI_message_string, &width, &height);
    cat145_h2 = height;
    cat145_message_title_x = (content_width >> 1) - (width >> 1);
    MMI_title_string = (UI_string_type) title;
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    MMI_title_icon = (PU8) get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

    MMI_message_icon = (PU8) get_image(message_icon);
    gui_measure_image(MMI_message_icon, &width, &height);
    cat145_h1 = height + 4;
    cat145_image_x = (content_width >> 1) - (width >> 1);

    cat145_flags = flags;
    cat145_y = 0;
    cat145_clip_x1 = 0;
    cat145_clip_x2 = content_width;
    cat145_clip_y1 = (MMI_title_y + MMI_title_height);
    cat145_clip_y2 = UI_device_height - MMI_button_bar_height - 1;
    cat145_total_height = (cat145_h1 + cat145_h2 + cat145_h3);
    cat145_available_height = cat145_clip_y2 - cat145_clip_y1 + 1;
    if (cat145_total_height > cat145_available_height)
    {
        resize_multiline_inputbox(MMI_multiline_inputbox.width - current_MMI_theme->scrollbar_size, MMI_multiline_inputbox.height);
        cat145_message_title_x -= (current_MMI_theme->scrollbar_size>>1);
        cat145_image_x -= (current_MMI_theme->scrollbar_size>>1);

        cat145_scrollbar_flag = 1;
        cat145_clip_x2 = cat145_clip_x2 - current_MMI_theme->scrollbar_size;
        register_keyboard_key_handler(cat145_bt_keyboard_key_handler);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    else
    {
        cat145_y = (cat145_available_height >> 1) - (cat145_total_height >> 1);
    }

    gdi_layer_unlock_frame_buffer();

#ifdef __MMI_EDITOR_SSP_SUPPORT__
        wgui_register_category_screen_control_area_pen_handlers(category_145BT_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
        wgui_register_category_screen_control_area_pen_handlers(category_145BT_pen_up_hdlr, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category_145BT_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
        wgui_register_category_screen_control_area_pen_handlers(category_145BT_pen_repeat_hdlr, MMI_PEN_EVENT_REPEAT);
#endif /*__MMI_EDITOR_SSP_SUPPORT__*/



    ExitCategoryFunction = ExitCategory145Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawBTCate145CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY145_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}
#endif
#if (defined( __MMI_WEARABLE_DEVICE__)&&(defined(__MMI_TOUCH_SCREEN__))) //MMI_WEARABLE_TOUCH_EDITOR_SCREEN 

wgui_BT145_footer_button_struct  bt145_footer_area_button [FOOTER_BUTTTON_MAX];
wgui_BT145_footer_button_handler  wgui_bt145_footer_area_button_handler[FOOTER_BUTTTON_MAX]; 
S16 bt145_footer_area_start_y = 0;
U8 BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
UI_string_type MMI_timer_string = NULL;
U8 UI_STYLE_ICON ;


#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__

U8 bt145_footer_area_buttons = FOOTER_BUTTTON_ERROR_COUNT;
UI_string_type  bt145_footer_area_button_lable [FOOTER_BUTTTON_MAX];

wgui_BT145_page_mode_struct  bt145_page_mode_data;

U16 null_data[4];

#endif
static MMI_BOOL disable_button_flag = MMI_FALSE;
static MMI_BOOL no_show_button_flag = MMI_FALSE;

#define CHECK_GAP (8)
static S32  pen_down_x = 0;
static S32  pen_down_y = 0;

/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_draw_header
 * DESCRIPTION
 *  draw BTcat145 header area
 * PARAMETERS
 *  is_draw  [MMI_BOOL]  MMI_TRUE :draw ,MMI_FALSE: no draw
 *  yoffset  [IN]  start Y 
 *  height   [IN]  header area height
 *  clip_xl  [IN]  editr start x
 *  clip_yl  [IN]  editr start y
 *  clip_x2  [IN]  editr end   x
 *  clip_y2  [IN]  editr end   y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_draw_header(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = yoffset ;
    color text_color = {245, 245, 245, 100};
	color message_title_color = {245, 245, 245, 100};
    S32 show_string_x = LCD_WIDTH - BT145_HEAD_RIGHT_MARGIN;
    S32 app_name_x = 0;
    S32 app_name_w = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    
    if (UI_STYLE_ICON)//need draw APP icon and only one footer button
    {
        // draw icon
        if (g_145_show_image_is_path)
        {    
            gdi_image_draw_resized_file(BT145_HEAD_ICON_X, y + BT145_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*)g_145_show_image_path);
        }
		else if (g_145_show_image_is_data)
		{
			gdi_image_draw_resized_mem(BT145_HEAD_ICON_X, y + BT145_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*) g_145_show_image_data,g_145_show_image_data_type
                ,g_145_show_image_data_size);
		}
        else
        {
            gdi_image_draw_resized(BT145_HEAD_ICON_X, y + BT145_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*) MMI_message_icon);
        }
        // draw APP Name
        //gui_set_text_color(text_color); 
         message_title_color = *current_MMI_theme->title_text_color;
        gui_set_text_color(message_title_color); 
        gui_set_font(&MMI_medium_font);

        app_name_x = BT145_HEAD_APP_NAME_X;
        app_name_w = BT145_HEAD_APP_NAME_MAX_LENGTH;
        
    #ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
        if((!MMI_title_string)&&(!MMI_timer_string))
        {// no draw icon
            app_name_x = BT145_HEAD_APP_NAME_X - BT145_HEAD_ICON_SIZE - BT145_HEAD_LEFT_GAP_APP_NAME_AND_ICON;
            app_name_w = BT145_HEAD_APP_NAME_MAX_LENGTH + BT145_HEAD_ICON_SIZE + BT145_HEAD_LEFT_GAP_APP_NAME_AND_ICON;

        }
    #endif
        {
            if(mmi_fe_get_r2l_state())
            {
                gui_print_truncated_text(show_string_x ,y + BT145_HEAD_APP_NAME_Y,
                                               app_name_w,
                                                     (UI_string_type)MMI_message_string);       
            } 
            else
            {
                gui_print_truncated_text(app_name_x ,y + BT145_HEAD_APP_NAME_Y,
                                               app_name_w,
                                                     (UI_string_type)MMI_message_string);   
            }

        }        
        // draw time
        gui_set_font(&MMI_small_font);
        gui_print_truncated_text(BT145_HEAD_TIME_X ,y + BT145_HEAD_TIME_Y,BT145_HEAD_TIME_MAX_LENGTH,(UI_string_type)MMI_timer_string);       

        // draw title
        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_HEAD_TITLE_Y,BT145_HEAD_TITLE_MAX_LENGTH,(UI_string_type)MMI_title_string);  
        }
        else
        {
            gui_print_truncated_text(BT145_HEAD_TITLE_X ,y + BT145_HEAD_TITLE_Y,BT145_HEAD_TITLE_MAX_LENGTH,(UI_string_type)MMI_title_string);       
        }     
    }
    else
    {
        // draw message APP Name
        message_title_color = *current_MMI_theme->title_text_color;
        gui_set_text_color(message_title_color); 
        
        gui_set_font(&MMI_medium_font);
        
        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_HEAD_MESSAGE_APP_NAME_Y,
                                           BT145_HEAD_MESSAGE_APP_NAME_MAX_LENTH,
                                                 (UI_string_type)MMI_message_string);       
        } 
        else
        {
            gui_print_truncated_text(BT145_HEAD_MESSAGE_APP_NAME_X ,y + BT145_HEAD_MESSAGE_APP_NAME_Y,
                                           BT145_HEAD_MESSAGE_APP_NAME_MAX_LENTH,
                                                 (UI_string_type)MMI_message_string);   
        }
        // draw message APP icon
        if (g_145_show_image_is_path)
        {    
            gdi_image_draw_resized_file(BT145_HEAD_MESSAGE_APP_ICON_X, y + BT145_HEAD_MESSAGE_APP_ICON_Y, 
                BT145_HEAD_MESSAGE_APP_ICON_SIZE, BT145_HEAD_MESSAGE_APP_ICON_SIZE, (U8*)g_145_show_image_path);
        }
		else if(g_145_show_image_is_data)
		{
			gdi_image_draw_resized_mem(BT145_HEAD_MESSAGE_APP_ICON_X, y + BT145_HEAD_MESSAGE_APP_ICON_Y, 
                 BT145_HEAD_MESSAGE_APP_ICON_SIZE, BT145_HEAD_MESSAGE_APP_ICON_SIZE, (U8*) g_145_show_image_data,g_145_show_image_data_type,g_145_show_image_data_size);	
		}
        else
        {
            gdi_image_draw_resized(BT145_HEAD_MESSAGE_APP_ICON_X, y + BT145_HEAD_MESSAGE_APP_ICON_Y, 
                BT145_HEAD_MESSAGE_APP_ICON_SIZE, BT145_HEAD_MESSAGE_APP_ICON_SIZE, (U8*) MMI_message_icon);
        }
        // draw time
        gui_set_font(&MMI_small_font);
        gui_print_truncated_text(BT145_HEAD_MESSAGE_APP_TIME_X ,y + BT145_HEAD_MESSAGE_APP_TIME_Y,BT145_HEAD_MESSAGE_APP_TIME_MAX_LENGTH,(UI_string_type)MMI_timer_string); 

    }
   
    
    gui_set_font(&MMI_default_font);

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
        gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */    
   
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}




/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_draw_button
 * DESCRIPTION
 *  draw BTcat145 footer area button
 * PARAMETERS
 *  index  [IN]  button incex
 *  down   [IN]  button status ,1: down ,0: up 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_footer_area_draw_button(U8 index, U8 down)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // U8 *img_src = NULL;
    color text_color_down = {255, 255, 255, 100};
    color bg_color_down = {31, 181, 172, 100};
    color text_color_up = {52, 149, 165, 100};
    color bg_color_up = {32, 32, 40, 100};//{0, 0, 0, 100};   
	color line_color  ;
    color bg_color ; 
    color text_color ; 

    color line_enable_color = {61, 107, 120, 100};
    
    color bg_disable_color =  {62, 64, 76, 100}; 
    color text_disable_color = {90, 94, 105, 100}; 
    color line_disable_color = {91, 95, 105, 100};
    
    UI_string_type string = 0;
    S32 sw, sh;

    S32 button_x = 0;
    S32 button_y = 0;
    S32 button_w = 0;
    S32 button_h = 0;
    S32 x_move = 0;
    S32 draw_button_end_y = LCD_HEIGHT-1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 1            
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
        if((bt145_page_mode_data.is_page_mode)&&(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON))
       	{
			bg_color_down = current_MMI_theme->menuitem_single_line_highlight_filler->c;
			//bg_color_up = current_MMI_theme->sub_menu_bkg_filler->c;								  
			text_color_up = *current_MMI_theme->list_normal_text_color;			
			text_color_down = *current_MMI_theme->list_selected_text_color;       	
		}
	    else
#endif	   	
       	{
			bg_color_up = current_MMI_theme->softkey_bar_bkg_filler->c;
			bg_color_down = current_MMI_theme->softkey_lsk_down_filler->c;								  
			text_color_up = *current_MMI_theme->LSK_up_text_color;
			text_color_down = *current_MMI_theme->LSK_down_text_color;
       	}
		
		gui_set_font(&MMI_large_font);
#endif

    if((index >= 0)&&(index < FOOTER_BUTTTON_MAX)&&(bt145_footer_area_button[index].h))
    {
        button_x = bt145_footer_area_button[index].x;
        button_y = bt145_footer_area_button[index].y;
        button_w = bt145_footer_area_button[index].w;
        button_h = bt145_footer_area_button[index].h;    
        string   = (UI_string_type)bt145_footer_area_button[index].label;
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__  
        if(bt145_footer_area_buttons <= FOOTER_BUTTTON_MAX)
        {
            if(bt145_footer_area_buttons >= 1)
            {
                draw_button_end_y = bt145_footer_area_button[index].h + button_y-1;
            }
        }
#endif

        if(disable_button_flag == MMI_TRUE)
        {
            line_color = line_disable_color;
            bg_color = bg_disable_color;
            text_color = text_disable_color;
        }
        else
        {
            line_color = line_enable_color;
            if(down)
            {
                //img_src = get_image(bt145_footer_area_button[index].normal_down_icon);
                bg_color = bg_color_down;
                text_color = text_color_down;            
            }
            else
            {
                //img_src = get_image(bt145_footer_area_button[index].normal_up_icon);
                bg_color = bg_color_up;
                text_color = text_color_up;              //GDI_COLOR_GREEN         
            }
            //draw button bg

        }
        
        if(!down)
        {
            gdi_draw_solid_rect(button_x, 
                            button_y, 
                            button_x + button_w - 1,
                            draw_button_end_y,                                                        
                            gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));   
        }
        else
        {
            gdi_draw_solid_rect(button_x, 
                            button_y, 
                            button_x + button_w - 1,
                            draw_button_end_y,                                                        
                            gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b)); 

        }
        if(!down)
        {
#if 0        
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif

            if(bt145_footer_area_buttons == (index+1))
            {
#if 0 
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif

            }
        }
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
        // draw label
        gui_measure_string(string, &sw, &sh);
        
        if(button_h > sh)
        {
            button_y = button_y + ((button_h - sh)/2);
        } 
        if(button_w > sw)
        {
            x_move = (button_w - sw)/2;
        }
        if (mmi_fe_get_r2l_state())
        {
            button_x = button_x + button_w-1-x_move;
        }    
        else
        {
            button_x = button_x + x_move ;
        }
        gui_set_text_color(text_color);
        
        if(sw >= button_w)
        {
            gui_print_truncated_text(button_x,button_y, button_w,string);    
        }
        else
        {   
            gui_move_text_cursor(button_x, button_y);
            gui_print_text(string);            
        }              
    }
    gui_set_font(&MMI_default_font);

}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_show_button
 * DESCRIPTION
 *  show all footer area button for category145
 * PARAMETERS
 *  down_index      [IN]   pen down button index 
 *  flag_update_all [IN]   flag for redraw all button,1: redraw ,0: not redraw
 *  need_blt        [IN]   flag for redraw with layer blt,1: blt ,0: not blt
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_footer_area_show_button(U8 down_index, U8 flag_update_all,U8 need_blt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    {   
        if(need_blt) 
        {
            gdi_layer_lock_frame_buffer();
            gdi_layer_push_clip();
            gui_set_clip_preset(0, 
                                bt145_footer_area_button[0].y,
                                UI_device_width - 1,
                                MMI_multiline_inputbox.y+ MMI_multiline_inputbox.height - 1);
        }    
        for(i = 0; i < FOOTER_BUTTTON_MAX ; i++)
        {
            if((down_index < FOOTER_BUTTTON_MAX)&&(down_index == i))
            {
                wgui_BTcat145_footer_area_draw_button(i,1);
            }
            else if(flag_update_all)
            {                    
                wgui_BTcat145_footer_area_draw_button(i,0);
            }            
        } 
        
        if(need_blt)
        {   gdi_layer_pop_clip();
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);  
        }
    }
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_ini
 * DESCRIPTION
 *  ini footer area button
 * PARAMETERS
 *  type    [IN]   2: two button ,1:one button
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_footer_area_ini(U8 type, UI_string_type left_label, UI_string_type right_label)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(bt145_footer_area_button,0,sizeof(bt145_footer_area_button));
    if(type == 2)
    {
        UI_STYLE_ICON = 0; 
        bt145_footer_area_button[0].x = BT145_FOOTER_B0_X;
        bt145_footer_area_button[0].y = BT145_FOOTER_B0_Y;
        bt145_footer_area_button[0].w = BT145_FOOTER_B0_W;
        bt145_footer_area_button[0].h = BT145_FOOTER_B0_H;
        bt145_footer_area_button[0].w_pen_gap= BT145_W_GAP;
        bt145_footer_area_button[0].h_pen_gap = BT145_W_GAP;  
        bt145_footer_area_button[0].label =  left_label;
   //     bt145_footer_area_button[0].normal_down_icon = IMG_ID_FMRDO_SKIN_1_POWER_BUTTON_OFF_UP;
   //     bt145_footer_area_button[0].normal_up_icon = IMG_ID_BT_MAIN_SKIN1_STOP;

        bt145_footer_area_button[1].x = BT145_FOOTER_B1_X;
        bt145_footer_area_button[1].y = BT145_FOOTER_B1_Y;
        bt145_footer_area_button[1].w = BT145_FOOTER_B1_W;
        bt145_footer_area_button[1].h = BT145_FOOTER_B1_H;    
        bt145_footer_area_button[1].w_pen_gap = BT145_W_GAP;
        bt145_footer_area_button[1].h_pen_gap = BT145_W_GAP;
        bt145_footer_area_button[1].label =  right_label;
        
  //      bt145_footer_area_button[1].normal_down_icon = IMG_ID_FMRDO_SKIN_1_POWER_BUTTON_OFF_UP;
 //       bt145_footer_area_button[1].normal_up_icon = IMG_ID_BT_MAIN_SKIN1_STOP;

        BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
    }
    else
    {
          UI_STYLE_ICON = 1; 
            bt145_footer_area_button[0].x = BT145_FOOTER_B2_X;
            bt145_footer_area_button[0].y = BT145_FOOTER_B2_Y;
            bt145_footer_area_button[0].w = BT145_FOOTER_B2_W;
            bt145_footer_area_button[0].h = BT145_FOOTER_B2_H;
            bt145_footer_area_button[0].w_pen_gap= BT145_W_GAP;
            bt145_footer_area_button[0].h_pen_gap = BT145_W_GAP;   
            bt145_footer_area_button[0].label =  left_label;
       //     bt145_footer_area_button[0].normal_down_icon = IMG_ID_FMRDO_SKIN_1_POWER_BUTTON_OFF_UP;
       //     bt145_footer_area_button[0].normal_up_icon = IMG_ID_BT_MAIN_SKIN1_STOP;
              
            BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
    }
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
    if((bt145_footer_area_buttons <= FOOTER_BUTTTON_MAX)&&(no_show_button_flag == MMI_FALSE))   
    {
        U8 i = 0;
        U16 image_h = 0;
        UI_STYLE_ICON = 1;    

        for(i = 0 ; i < bt145_footer_area_buttons ; i++)
        {
            bt145_footer_area_button[i].x = BT145_FOOTER_BX_X;
            bt145_footer_area_button[i].y = BT145_FOOTER_BX_Y + (i*BT145_FOOTER_BX_H) + image_h ;
            bt145_footer_area_button[i].w = BT145_FOOTER_BX_W;
            bt145_footer_area_button[i].h = BT145_FOOTER_BX_H;
            bt145_footer_area_button[i].w_pen_gap= BT145_W_GAP;
            bt145_footer_area_button[i].h_pen_gap = BT145_H_GAP;   
            bt145_footer_area_button[i].label =  bt145_footer_area_button_lable[i];
        }
    }

#endif

     //wgui_bt145_footer_area_button_handler[0] = mmi_frm_scrn_close_active_id;
    
    //wgui_uce_control_button_handler[0] = EntrySymbolPickerScreen;
} 
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_check_pen_point
 * DESCRIPTION
 *  check pen point in whith footer area button
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  the button index 
 *****************************************************************************/
static U8 wgui_BTcat145_footer_area_check_pen_point(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    U8 i = 0;
    S16 x1,x2,y1,y2;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
    if(bt145_footer_area_buttons <= FOOTER_BUTTTON_MAX)   
    {
        for(i = 0; i < bt145_footer_area_buttons ; i++)
        {   
            if(!bt145_footer_area_button[i].h)
            {
                break;
            }

            y1 = bt145_footer_area_button[i].y - bt145_footer_area_button[i].h_pen_gap;
            y2 = bt145_footer_area_button[i].y + bt145_footer_area_button[i].h + bt145_footer_area_button[i].h_pen_gap;

            if(y2 > MMI_multiline_inputbox.y + MMI_multiline_inputbox.height)
            {
                y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height -1;
            }

            if((y1 <= point.y)&&(y2 >= point.y))
            {
                x1 = bt145_footer_area_button[i].x - bt145_footer_area_button[i].w_pen_gap;
                x2 = bt145_footer_area_button[i].x + bt145_footer_area_button[i].w + bt145_footer_area_button[i].w_pen_gap;
                if((x1 <= point.x )&&(x2 >= point.x))
                {
                    return  i;
                }
            }
        }  
    }        
    else    
#endif
    {
    y1 = bt145_footer_area_button[0].y - bt145_footer_area_button[i].h_pen_gap;
    y2 = bt145_footer_area_button[0].y + bt145_footer_area_button[0].h + bt145_footer_area_button[i].h_pen_gap;

    if(y2 > MMI_multiline_inputbox.y + MMI_multiline_inputbox.height)
    {
        y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height -1;
    }
    if((y1 <= point.y)&&(y2 >= point.y))
    {
        for(i = 0; i < FOOTER_BUTTTON_MAX ; i++)
        {   
            if(!bt145_footer_area_button[i].h)
            {
                break;
            }
            x1 = bt145_footer_area_button[i].x - bt145_footer_area_button[i].w_pen_gap;
            x2 = bt145_footer_area_button[i].x + bt145_footer_area_button[i].w + bt145_footer_area_button[i].w_pen_gap;
            if((x1 <= point.x )&&(x2 >= point.x))
            {
                return  i;
            }
        }  
    }
    }
    return FOOTER_BUTTTON_MAX;

    
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_PenDownHdlr
 * DESCRIPTION
 *  check pen down event in footer area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen down button ,MMI_FALSE:not pen down button [MMI_BOOL]
 *****************************************************************************/
MMI_BOOL wgui_BTcat145_footer_area_PenDownHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = FOOTER_BUTTTON_MAX;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_footer_area_check_pen_point(point);
    if(button_index != FOOTER_BUTTTON_MAX)
    {
        pen_down_x = point.x;
        pen_down_y = point.y;
        BT145_footer_area_highlight_button = button_index;               
        wgui_BTcat145_footer_area_show_button(button_index,0,1);//just show down status button        
        return MMI_TRUE;

    }
    return MMI_FALSE;
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_PenUpHdlr
 * DESCRIPTION
 *  check pen up event in footer area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen up button ,MMI_FALSE:not pen up button [MMI_BOOL]
 *****************************************************************************/
MMI_BOOL wgui_BTcat145_footer_area_PenUpHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = FOOTER_BUTTTON_MAX;
    void (*handler) (void);
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_footer_area_check_pen_point(point);
    if(button_index != FOOTER_BUTTTON_MAX)
    {
        wgui_BTcat145_footer_area_show_button(FOOTER_BUTTTON_MAX,1,1);//just show up with all buttons  
        if(disable_button_flag == MMI_FALSE)
        {
            if(BT145_footer_area_highlight_button == button_index)
            {
               handler = wgui_bt145_footer_area_button_handler[button_index] ;
               if(handler)
               {
                 handler(); 
               }
            }
        }
        BT145_footer_area_highlight_button =  FOOTER_BUTTTON_MAX;    
        return MMI_TRUE;

    }
    BT145_footer_area_highlight_button =  FOOTER_BUTTTON_MAX; 
    return MMI_FALSE;
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_PenMoveHdlr
 * DESCRIPTION
 *  check pen move event in footer area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen move button ,MMI_FALSE:not pen move button [MMI_BOOL]
 *****************************************************************************/
MMI_BOOL wgui_BTcat145_footer_area_PenMoveHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = FOOTER_BUTTTON_MAX;
    U8 i = 0;
    U8 need_redraw_button_all = 0;
    U8 need_draw_button = FOOTER_BUTTTON_MAX;
    MMI_BOOL result = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_footer_area_check_pen_point(point);

    if((pen_down_x >( point.x + CHECK_GAP))||(point.x >( pen_down_x + CHECK_GAP))
		||(pen_down_y >( point.y + CHECK_GAP))||(point.y >( pen_down_y + CHECK_GAP))
		)
    {
		button_index = FOOTER_BUTTTON_MAX;
	}

    if(button_index != FOOTER_BUTTTON_MAX)
    {
        if(BT145_footer_area_highlight_button != button_index)
        {// down and move in not one same button
            BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
            //need_redraw_button_all = 1;            
        }
        else
        {
           need_draw_button = button_index; 
        }
        need_redraw_button_all = 1;
        result = MMI_TRUE;
    }
    else 
    {   // down on button and move out on button
        //if(ctrl_area_highlight_button != BUTTTON_MAX) 
        {
            need_redraw_button_all = 1;
        }
        BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
        result = MMI_FALSE;

    }
    if(need_redraw_button_all)
    {  
        wgui_BTcat145_footer_area_show_button(need_draw_button,1,1);// show up and down
    }
    
    return result;
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_register_controlled_callback
 * DESCRIPTION
 *  register APP callback to footer area button
 * PARAMETERS
 *  handler       [IN]  app callback
 *  button_index  [IN]  button index which been  register callback 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_footer_area_register_controlled_callback(void (*handler) (void),U8 button_index)
{

    if(button_index >=0 && button_index < FOOTER_BUTTTON_MAX)
    {
        wgui_bt145_footer_area_button_handler[button_index] = handler;
    }

}

/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_set_disable_button
 * DESCRIPTION
 *  set button disable or enable
 * PARAMETERS
 *   
 *  button_flag  [IN]  button disable flag 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_footer_area_set_disable_button(MMI_BOOL button_flag)
{
    disable_button_flag = button_flag;
}


/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_set_no_show_button
 * DESCRIPTION
 *  set button no show 
 * PARAMETERS
 *   
 *  button_flag  [IN] no show button disable flag 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_footer_area_set_no_show_button(MMI_BOOL button_flag)
{
    no_show_button_flag = button_flag;
}

#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
void wgui_BTcat145_set_page_mode_sse_no_change_footer(MMI_BOOL set_flag)
{
#ifdef   GUI_SSP_SUPPORT_FOOTER_AREA_NO_CHANGE
    gui_effect_some_area_slide_no_change_frame(set_flag,BT145_PAGE_INDICATOR_H,LCD_HEIGHT-BT145_PAGE_INDICATOR_H ); 
     //gui_effect_footer_area_slide_no_change_frame(set_flag,BT145_PAGE_INDICATOR_H); 
#endif
}
/*****************************************************************************
 * FUNCTION
 *  set_cat145_page_mode_data
 * DESCRIPTION
 *  set  page count and cuttent page id  
 * PARAMETERS
 *  page_count    [IN]  page count
 *  current_page_index  [IN]  current page index , value start from 0 
 *  mode_type     [IN]  current page mode  
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_set_page_mode_data(U8 page_count ,U8 current_page_index,BT145_page_mode_type mode_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if((page_count < BT145_ERROR_PAGE)&&(current_page_index < page_count))
    {
        bt145_page_mode_data.is_page_mode = MMI_TRUE;
        bt145_page_mode_data.current_page_index = current_page_index;
        bt145_page_mode_data.page_count = page_count;
        bt145_page_mode_data.mode_type = mode_type;
    }  
    else
    {
        bt145_page_mode_data.is_page_mode = MMI_FALSE;
        bt145_page_mode_data.current_page_index = BT145_ERROR_PAGE;
        bt145_page_mode_data.page_count = BT145_ERROR_PAGE;
        bt145_page_mode_data.mode_type = MMI_BT145_PAGE_MODE_ERROR;  
    }
}

/*****************************************************************************
 * FUNCTION
 *  set_cat145_footer_area_show_button_count
 * DESCRIPTION
 *  set button count 
 * PARAMETERS
 *   
 *  button_count  [IN] button count
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_set_footer_area_show_button_count(U8 button_count)
{
    if(button_count >= FOOTER_BUTTTON_MAX)
    {
        bt145_footer_area_buttons = FOOTER_BUTTTON_MAX;
    }
    else
    {
        bt145_footer_area_buttons = button_count;
    }
    memset(bt145_footer_area_button_lable,0,sizeof(bt145_footer_area_button_lable));
}


/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_footer_area_show_button_lable
 * DESCRIPTION
 *  set button lable by button index 
 * PARAMETERS
 *  label         [IN] button label  
 *  button_index  [IN] button index  
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_set_footer_area_show_button_lable(UI_string_type label,U8 button_index)
{
    if(button_index >=0 && button_index < FOOTER_BUTTTON_MAX)
    {
        bt145_footer_area_button_lable[button_index] = label;
    }
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_show_page_indicator
 * DESCRIPTION
 *  show page indicator
 * PARAMETERS
 *  page_count         [IN] page count  
 *  current_page_index [IN] page index  
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_show_page_indicator(U8 page_count ,U8 current_page_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color bg_color = {32, 32, 40, 100};
    
    U8 i = 0;
    S32 icon_x = 0;
    S32 icon_y = 0;
    S32 icon_w = 0;
    S32 icon_h = 0;
    S32 icon_x_gap = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/


    if(bt145_page_mode_data.is_page_mode = MMI_TRUE)
    {
        switch (page_count)
        {
            case 2:// 2 pages
            {
                icon_x = BT145_PAGE_INDICATOR_ICON_FOR_2_PAGE_START_X;
                icon_y = BT145_PAGE_INDICATOR_ICON_FOR_2_PAGE_START_Y;
                icon_w = BT145_PAGE_INDICATOR_ICON_W;
                icon_h = BT145_PAGE_INDICATOR_ICON_H;
                icon_x_gap = BT145_PAGE_INDICATOR_ICON_FOR_2_PAGE_X_GAP;                ;
                break;
            }
            case 3:// 3 pages
            {
                icon_x = BT145_PAGE_INDICATOR_ICON_FOR_3_PAGE_START_X;
                icon_y = BT145_PAGE_INDICATOR_ICON_FOR_3_PAGE_START_Y;
                icon_w = BT145_PAGE_INDICATOR_ICON_W;
                icon_h = BT145_PAGE_INDICATOR_ICON_H;
                icon_x_gap = BT145_PAGE_INDICATOR_ICON_FOR_3_PAGE_X_GAP;                  
                break;
            }

            case 4:// 4 pages
            {
                icon_x = BT145_PAGE_INDICATOR_ICON_FOR_4_PAGE_START_X;
                icon_y = BT145_PAGE_INDICATOR_ICON_FOR_4_PAGE_START_Y;
                icon_w = BT145_PAGE_INDICATOR_ICON_W;
                icon_h = BT145_PAGE_INDICATOR_ICON_H;
                icon_x_gap = BT145_PAGE_INDICATOR_ICON_FOR_4_PAGE_X_GAP;   
                break;
            }

            default:
            {
                break;
            }            
        }
        gdi_draw_solid_rect(BT145_PAGE_INDICATOR_X, 
                        BT145_PAGE_INDICATOR_Y, 
                        BT145_PAGE_INDICATOR_X + BT145_PAGE_INDICATOR_W - 1,
                        BT145_PAGE_INDICATOR_Y + BT145_PAGE_INDICATOR_H - 1,                                                       
                        gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b)); 

        for(i = 0; i< page_count;i++)
        {
            if(i == current_page_index)
            {
                gdi_image_draw_resized(icon_x+(i*icon_x_gap), icon_y, icon_w, icon_h, (U8*)get_image(IMG_BTNOTIFICATON_PAGE_DOT_SELECT));//43424
            }
            else
            {
                gdi_image_draw_resized(icon_x+(i*icon_x_gap), icon_y, icon_w, icon_h, (U8*)get_image(IMG_BTNOTIFICATON_PAGE_DOT_NORMAL));//45808
            }
 
        }
    }
}


#endif

#ifdef __MMI_EDITOR_SSP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_pen_down_hdlr
 * DESCRIPTION
 *  check pen down event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen down button ,MMI_FALSE:not pen down button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 other_case = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   /*if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenDownHdlr(pos);
      return MMI_TRUE; 
   }    
   else */ 
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_DOWN);
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
        if((!bt145_footer_area_start_y)&&(bt145_page_mode_data.is_page_mode)
            &&(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON))
        {
            other_case = 1;  
        }
#endif
        if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y||(other_case)))// in footer area
       {
          wgui_BTcat145_footer_area_PenDownHdlr(pos);
       }           
       return MMI_TRUE;
   }
   return  MMI_FALSE;
    
}
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_pen_up_hdlr
 * DESCRIPTION
 *  check pen up event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen up button ,MMI_FALSE:not pen up button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret ;
    U8 other_case = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   
   /*if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenUpHdlr(pos);
      return MMI_TRUE; 
    }    
    else */
    if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
    {
        ret =  gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_UP);

#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
        if((!bt145_footer_area_start_y)&&(bt145_page_mode_data.is_page_mode)
            &&(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON))
        {
            other_case = 1;  
        }
#endif

        
        if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y||other_case)&&(!ret))// in footer area
        {
            wgui_BTcat145_footer_area_PenUpHdlr(pos);
            return MMI_TRUE; 
        }  
        return ret;  
    }
    return  MMI_FALSE;    
}
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_pen_move_hdlr
 * DESCRIPTION
 *  check pen move event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen move button ,MMI_FALSE:not pen move button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret ;
    U8 other_case = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   /* if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenMoveHdlr(pos);
      return MMI_TRUE; 
   }    
   else
   */
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       ret = gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_MOVE);

#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
       if((!bt145_footer_area_start_y)&&(bt145_page_mode_data.is_page_mode)
           &&(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON))
       {
           other_case = 1;  
       }
#endif

       
       if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y||other_case)&&(!ret))// in footer area
       {
          wgui_BTcat145_footer_area_PenMoveHdlr(pos);
          return MMI_TRUE;
       }
       else if((bt145_footer_area_start_y||other_case)&&(BT145_footer_area_highlight_button != FOOTER_BUTTTON_MAX))
       {// footer area can be see,move in editor ,should redraw button
            wgui_BTcat145_footer_area_show_button(FOOTER_BUTTTON_MAX,1,1);
            BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
       }
       return ret;
   }
   if((bt145_footer_area_start_y||other_case)&&(BT145_footer_area_highlight_button != FOOTER_BUTTTON_MAX))
   {// footer area can be see ,mvoe out editor,should redraw button
        wgui_BTcat145_footer_area_show_button(FOOTER_BUTTTON_MAX,1,1);
        BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;
   }
   
   return  MMI_FALSE;
}


#endif /*__MMI_EDITOR_SSP_SUPPORT__*/



/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_draw_footer
 * DESCRIPTION
 *  draw BTcat145 footer area
 * PARAMETERS
 *  is_draw  [MMI_BOOL]  MMI_TRUE :draw ,MMI_FALSE: no draw
 *  yoffset  [IN]  start Y 
 *  height   [IN]  header area height
 *  clip_xl  [IN]  editr start x
 *  clip_yl  [IN]  editr start y
 *  clip_x2  [IN]  editr end   x
 *  clip_y2  [IN]  editr end   y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_draw_footer(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
  

 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bt145_footer_area_start_y = 0 ; 
    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, clip_y1, LCD_WIDTH-1, clip_y2);    
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
    if((bt145_footer_area_buttons <= FOOTER_BUTTTON_MAX)&&(no_show_button_flag == MMI_FALSE))   
    {
        U8 i = 0;
        U16 image_h = 0;
        //draw button
        {
            bt145_footer_area_start_y = yoffset ;

            for(i = 0 ; i < bt145_footer_area_buttons ; i++)
            {
               
			    if((bt145_page_mode_data.is_page_mode)&&(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON))
				{
					bt145_footer_area_button[i].y =  (i*BT145_FOOTER_BX_H) + image_h + yoffset;
			   	}
				else
				{
                	bt145_footer_area_button[i].y = BT145_FOOTER_BX_Y + (i*BT145_FOOTER_BX_H) + image_h + yoffset;
				}	
            }
            
            wgui_BTcat145_footer_area_show_button(FOOTER_BUTTTON_MAX, 1,0);// can't show highlight button
        }

    }
    else    
#endif
    {
    bt145_footer_area_start_y = yoffset ;
    bt145_footer_area_button[0].y = yoffset + BT145_FOOTER_B0_Y;
    bt145_footer_area_button[1].y = bt145_footer_area_button[0].y ;
    //gdi_draw_line(MMI_multiline_inputbox.x, yoffset+2, MMI_multiline_inputbox.x+MMI_multiline_inputbox.width-1, yoffset+2, GDI_COLOR_BLACK);     
    wgui_BTcat145_footer_area_show_button(FOOTER_BUTTTON_MAX, 1,0);// can't show highlight button
    }
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_get_header_and_footer_height
 * DESCRIPTION
 *  get header area  and footer area height 
 * PARAMETERS
 *  header_height    [OUT]   header height
 *  footer_height    [OUT]   footer height
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_get_header_and_footer_height(U16 *header_height, U16 *footer_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 header = 0, footer = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    // header = MMI_title_y + MMI_title_height + G_145_SMALL_SPACE + G_145_TITLE_EFFORT + G_145_SPACE + G_145_SPACE; 
     if(UI_STYLE_ICON)
     {
        header = G_145_BT_HEAD_HIGHT; 
     }
     else
     {
        header = G_145_BT_HEAD_MESSAGE_APP_HIGHT; 
     }
     if(no_show_button_flag == MMI_FALSE)
     {
        footer = G_145_BT_FOOT_HIGHT;
#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
         if(bt145_footer_area_buttons <= FOOTER_BUTTTON_MAX)   
         {
             if((bt145_page_mode_data.is_page_mode)&&(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON))
             {
				 footer =  bt145_footer_area_buttons*BT145_FOOTER_BX_H;
			 }
			 else
			 {
             	footer = BT145_FOOT_TOP_MARGIN + bt145_footer_area_buttons*BT145_FOOTER_BX_H;
			 }	
         }
         if((!MMI_title_string)&&(MMI_timer_string))
         {
            header = G_145_BT_HEAD_HIGHT - BT145_HEAD_FONT_SIZE;
         }

         if((!MMI_title_string)&&(!MMI_timer_string))
         {
            header = G_145_BT_HEAD_MESSAGE_APP_HIGHT - BT145_HEAD_FONT_SIZE;
         }
#endif
     }
     else
     {
        footer = 0;
     }
     *header_height = header;
     *footer_height = footer;
}
/*****************************************************************************
 * FUNCTION
 *  DrawBTCate145CategoryControlArea_WEARABLE_DEVICE
 * DESCRIPTION
 *  control area callback for category145
 * PARAMETERS
 *  coordinate    [IN]   control area coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void DrawBTCate145CategoryControlArea_WEARABLE_DEVICE(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = MMI_title_y + MMI_title_height + G_145_SMALL_SPACE;
    color text_color = {245, 245, 245, 100};
    color bg_color = {32, 32, 40, 100};//{0, 0, 0, 100};
    U8 number_len = 0;
  //  UI_filled_area f;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, 0, LCD_WIDTH-1, LCD_HEIGHT-1);

    gdi_draw_solid_rect(0, 0, LCD_WIDTH-1, LCD_HEIGHT-1, gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));
    
    gui_set_font(&MMI_default_font);
    //gui_move_multi_line_input_box(&MMI_multiline_inputbox, G_145_SMALL_SPACE, y); 
    gui_move_multi_line_input_box(&MMI_multiline_inputbox, 0, 0);
    {
        resize_multiline_inputbox(LCD_WIDTH, G_145_IS_NEED_NUMBER_HIGHT ); 
    }
    MMI_multiline_inputbox.min_text_height = MMI_multiline_inputbox.height-2;
    MMI_multiline_inputbox.vbar.height = MMI_multiline_inputbox.vbar.height - MMI_multiline_inputbox.footer_height;

    MMI_multiline_inputbox.text_x = BT145_HEAD_LEFT_MARGIN;
    MMI_multiline_inputbox.margin.top_margin = 0;
    MMI_multiline_inputbox.text_y = 0;
   // f = *b->normal_filler;
  //  f.flags &= ~(UI_FILLED_AREA_BORDER); // no border
    MMI_multiline_inputbox.ext_flags |= (GUI_MULTI_LINE_INPUT_BOX_SET_BG_COLOR|GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER); // bg black
    
    MMI_multiline_inputbox.default_bg_color = bg_color;
    MMI_multiline_inputbox.normal_text_color = text_color;

   #ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__
   if(bt145_page_mode_data.is_page_mode)
   {
        switch (bt145_page_mode_data.mode_type)
        {
            case MMI_BT145_PAGE_MODE_APP_NAME_AND_CONTENT_TEXT_AND_NO_BUTTON:
            {
                MMI_multiline_inputbox.footer_callback = NULL;
                MMI_multiline_inputbox.footer_height = 0;                   ;
                break;
            }
            case MMI_BT145_PAGE_MODE_ONLY_CONTENT_TEXT:
            {
                MMI_multiline_inputbox.header_callback = NULL;
                MMI_multiline_inputbox.header_height = 0; 
                MMI_multiline_inputbox.footer_callback = NULL;
                MMI_multiline_inputbox.footer_height = 0;                 
                break;
            }

            case MMI_BT145_PAGE_MODE_ONLY_BUTTON:
            {
                MMI_multiline_inputbox.header_callback = NULL;
                MMI_multiline_inputbox.header_height = 0; 
                MMI_multiline_inputbox.text = (UI_buffer_type)null_data;
                memset(null_data,0,sizeof(null_data));
                break;
            }

            default:
            {
                break;
            }            
        }
        MMI_multiline_inputbox.height = MMI_multiline_inputbox.height - BT145_PAGE_INDICATOR_H;
        MMI_multiline_inputbox.min_text_height = MMI_multiline_inputbox.height-2;

        if(bt145_page_mode_data.mode_type == MMI_BT145_PAGE_MODE_ONLY_BUTTON)
        {
            if(MMI_multiline_inputbox.min_text_height > MMI_multiline_inputbox.footer_height)
            {
                MMI_multiline_inputbox.min_text_height = MMI_multiline_inputbox.footer_height;
            }
        }
        MMI_multiline_inputbox.vbar.height = MMI_multiline_inputbox.height - 2;
        
        wgui_BTcat145_show_page_indicator(bt145_page_mode_data.page_count,bt145_page_mode_data.current_page_index);
   }
   #endif
    
#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
        gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */
    
    gui_show_multi_line_input_box(&MMI_multiline_inputbox);
    gdi_layer_pop_clip();
}

/*****************************************************************************
 * FUNCTION
 *  ShowBTNotiCategory145Screen_WEARABLE_DEVICE
 * DESCRIPTION
 *  Displays the WEARABLE_DEVICE message and notifier Detail screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message_icon            [IN]        Icon displayed with the message
 *  message_title           [IN]        Colored text that appears above the message
 *  message                 [IN]        Message
 *  flags                   [IN]        Flags
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowBTNotiCategory145Screen_WEARABLE_DEVICE(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message_icon,
        U8 *message_title,
        U8 *message,
        U32 flags,
        U8 *history_buffer,
        U8 *time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l, width, height, content_width;
    U16 header_height;
    U16 footer_height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    cat145_scrollbar_flag = 0;
    content_width = UI_device_width;
    l = gui_strlen((UI_string_type) message);
    create_multiline_inputbox_set_buffer((UI_string_type) message, l, l, 0);
    resize_multiline_inputbox(content_width, MMI_content_height);
    show_multiline_inputbox_no_draw();
    cat145_h3 = MMI_multiline_inputbox.height;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
  #ifndef __MMI_EDITOR_SSP_SUPPORT__
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
  #endif/*__MMI_EDITOR_SSP_SUPPORT__*/
        | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING;
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */

    MMI_message_string = (UI_string_type) message_title;
    gui_set_font(&MMI_default_font);
    gui_measure_string(MMI_message_string, &width, &height);
    cat145_h2 = height;
    cat145_message_title_x = (content_width >> 1) - (width >> 1);
    MMI_title_string = (UI_string_type) title;
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    MMI_title_icon = (PU8) get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/

    MMI_timer_string = (UI_string_type)time;
    MMI_message_icon = (PU8) get_image(message_icon);
    gui_measure_image(MMI_message_icon, &width, &height);
    cat145_h1 = height + 4;
    cat145_image_x = (content_width >> 1) - (width >> 1);

    cat145_flags = flags;
    cat145_y = 0;
    cat145_clip_x1 = 0;
    cat145_clip_x2 = content_width;
    cat145_clip_y1 = (MMI_title_y + MMI_title_height);
    cat145_clip_y2 = UI_device_height - MMI_button_bar_height - 1;
    cat145_total_height = (cat145_h1 + cat145_h2 + cat145_h3);
    cat145_available_height = cat145_clip_y2 - cat145_clip_y1 + 1;
    if (cat145_total_height > cat145_available_height)
    {
        resize_multiline_inputbox(MMI_multiline_inputbox.width - current_MMI_theme->scrollbar_size, MMI_multiline_inputbox.height);
        cat145_message_title_x -= (current_MMI_theme->scrollbar_size>>1);
        cat145_image_x -= (current_MMI_theme->scrollbar_size>>1);

        cat145_scrollbar_flag = 1;
        cat145_clip_x2 = cat145_clip_x2 - current_MMI_theme->scrollbar_size;
        register_keyboard_key_handler(cat145_bt_keyboard_key_handler);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    else
    {
        cat145_y = (cat145_available_height >> 1) - (cat145_total_height >> 1);
    }

    gdi_layer_unlock_frame_buffer();
    
    if(right_softkey)
    {
        wgui_BTcat145_footer_area_ini(2,get_string(left_softkey),get_string(right_softkey));// show 2 button
    }
    else
    {
        wgui_BTcat145_footer_area_ini(1,get_string(left_softkey),get_string(right_softkey));// show  1 button
    }
    
    MMI_multiline_inputbox.header_callback = wgui_BTcat145_draw_header;

    if(no_show_button_flag == MMI_FALSE)
    {
        MMI_multiline_inputbox.footer_callback = wgui_BTcat145_draw_footer;
    }

    wgui_BTcat145_get_header_and_footer_height(&header_height, &footer_height);
    MMI_multiline_inputbox.header_height = header_height;
    MMI_multiline_inputbox.footer_height= footer_height;
    
#ifdef __MMI_EDITOR_SSP_SUPPORT__
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_pen_up_hdlr, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /*__MMI_EDITOR_SSP_SUPPORT__*/


    bt145_footer_area_start_y = 0;
    BT145_footer_area_highlight_button = FOOTER_BUTTTON_MAX;

    ExitCategoryFunction = ExitCategory145Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawBTCate145CategoryControlArea_WEARABLE_DEVICE);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY145_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_data.s32flags |= DM_NO_STATUS_BAR | DM_NO_TITLE|DM_NO_SOFTKEY; // no title ,no status bar   
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}

#endif /*__MMI_WEARABLE_DEVICE__*/


#ifdef __MMI_WEARABLE_DEVICE_LIST_INPUT__

//////////////

wgui_BT145_list_input_head_button_struct  bt145_list_input_head_area_button [LIST_INPUT_HEAD_BUTTTON_MAX];
wgui_BT145_list_input_head_button_handler  wgui_bt145_list_input_head_area_button_handler[1]; 
S16 bt145_list_input_head_area_start_y = 0;
U16 BT145_list_input_head_area_highlight_button = LIST_INPUT_HEAD_BUTTTON_MAX;
U16 sample_text_buff[6];
U16 bt145_list_input_all_row = 0;
U16 bt145_list_input_button_count = 0;
U8 **bt145_list_input_app_list = NULL;

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_draw_button
 * DESCRIPTION
 *  draw BTcat145 list input category head area button
 * PARAMETERS
 *  index  [IN]  button incex
 *  down   [IN]  button status ,1: down ,0: up 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_list_input_head_area_draw_button(U8 index, U8 down)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // U8 *img_src = NULL;
    color text_color_down = {255, 255, 255, 100};
    color bg_color_down =  {255, 155, 0, 100};//{52, 149, 165, 100};//{31, 81, 172, 100};
    color text_color_up = {245, 245, 245, 100};//{52, 149, 165, 100};
    color line_color = {45, 45, 56, 100};   
    color bg_color_up = {0, 0, 0, 100};  
    color bg_color ; 
    color text_color ; 
    
    UI_string_type string = 0;
    S32 sw, sh;

    S32 button_x = 0;
    S32 button_y = 0;
    S32 button_w = 0;
    S32 button_h = 0;
    S32 x_move = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	bg_color_down = current_MMI_theme->menuitem_single_line_highlight_filler->c;

    if((index >= 0)&&(index < bt145_list_input_button_count)&&(bt145_list_input_head_area_button[index].h))
    {
        button_x = bt145_list_input_head_area_button[index].x;
        button_y = bt145_list_input_head_area_button[index].y;
        button_w = bt145_list_input_head_area_button[index].w;
        button_h = bt145_list_input_head_area_button[index].h;    
        string   = (UI_string_type)bt145_list_input_head_area_button[index].label;
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif        

        {//draw button top line
               
             gdi_draw_line(button_x, button_y-1, button_x+button_w, button_y-1, 
                     gdi_act_color_from_rgb(line_color.alpha, line_color.r, line_color.g, line_color.b)); 
        }

        {//draw button down line
                       
             gdi_draw_line(button_x, button_y + button_h, button_x+button_w, button_y + button_h, 
                gdi_act_color_from_rgb(line_color.alpha, line_color.r, line_color.g, line_color.b));
        }

        if(button_x + button_w < LCD_WIDTH)  
        {//draw button right v line
                                 
             gdi_draw_line(button_x + button_w, button_y-1, button_x + button_w, button_y+button_h, 
                     gdi_act_color_from_rgb(line_color.alpha, line_color.r, line_color.g, line_color.b)); 
        }


        if(down)
        {
            bg_color = bg_color_down;
            text_color = text_color_down;            
        }
        else
        {
            bg_color = bg_color_up;
            text_color = text_color_up;              //GDI_COLOR_GREEN         
        }
        //draw button bg
        gdi_draw_solid_rect(button_x, 
                            button_y, 
                            button_x + button_w - 1,
                            button_y + button_h - 1,                                                        
                            gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));         
        
        // draw label
        if(string)
        {
            gui_measure_string(string, &sw, &sh);
            
            if(button_h > sh)
            {
                button_y = button_y + ((button_h - sh)/2);
            } 
            if(button_w > sw)
            {
                x_move = (button_w - sw)/2;
            }
            if (mmi_fe_get_r2l_state())
            {
                button_x = button_x + button_w-1-x_move;
            }    
            else
            {
                button_x = button_x + x_move ;
            }
            gui_set_text_color(text_color);
            
            if(sw >= button_w)
            {
                gui_print_truncated_text(button_x,button_y, button_w,string);    
            }
            else
            {   
                gui_move_text_cursor(button_x, button_y);
                gui_print_text(string);            
            }      
        }
    }

}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_show_button
 * DESCRIPTION
 *  show all head area button for category145
 * PARAMETERS
 *  down_index      [IN]   pen down button index 
 *  flag_update_all [IN]   flag for redraw all button,1: redraw ,0: not redraw
 *  need_blt        [IN]   flag for redraw with layer blt,1: blt ,0: not blt
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_list_input_head_area_show_button(U8 down_index, U8 flag_update_all,U8 need_blt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    {   
        if(need_blt) 
        {
            gdi_layer_lock_frame_buffer();
            gdi_layer_push_clip();
            gui_set_clip_preset(0, 
                                MMI_title_height + MMI_title_y,
                                UI_device_width - 1,
                                MMI_multiline_inputbox.y+ MMI_multiline_inputbox.height - 1);
        }    
        for(i = 0; i < bt145_list_input_button_count ; i++)
        {
            if((down_index < bt145_list_input_button_count)&&(down_index == i))
            {
                wgui_BTcat145_list_input_head_area_draw_button(i,1);
            }
            else if(flag_update_all)
            {                    
                wgui_BTcat145_list_input_head_area_draw_button(i,0);
            }            
        } 
        
        if(need_blt)
        {   gdi_layer_pop_clip();
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);  
        }
    }
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_ini
 * DESCRIPTION
 *  ini head area button
 * PARAMETERS
 *  type    [IN]    
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_list_input_head_area_ini(U8 type, UI_string_type left_label, UI_string_type right_label)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    S32 button_y = 0;
    S32 button_x = 0;
    S32 button_w = 0;
    S32 yoffset = MMI_title_y + MMI_title_height;
    U8  button_index = 0;
    U8 i = 0;
    U8 j = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(bt145_list_input_head_area_button,0,sizeof(bt145_list_input_head_area_button));

    //update button count
    if(bt145_list_input_button_count > LIST_INPUT_HEAD_BUTTTON_MAX)
    {
        bt145_list_input_button_count = 0;
    }

    //get row count
    bt145_list_input_all_row =  bt145_list_input_button_count/BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON;
    
    if((bt145_list_input_button_count%BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON)&&bt145_list_input_button_count) 
    {
        bt145_list_input_all_row =  bt145_list_input_all_row +1; 
    }

    for(i = 0; i < bt145_list_input_all_row; i++)
    {// update all button start y
    
        button_y = yoffset + BT145_LIST_INPUT_HEAD_H_LINE_PIX + (i*(BT145_LIST_INPUT_HEAD_B0_H + BT145_LIST_INPUT_HEAD_H_LINE_PIX));
        button_x = 0;

        if(button_index > (bt145_list_input_button_count - 1))
        {
            break;
        }
        
        for(j = 0; j < BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON; j++)
        {
            button_index = j+(i*BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON);

            if(button_index > (bt145_list_input_button_count - 1))
            {
                break;
            }
            
            bt145_list_input_head_area_button[button_index].y = button_y ;

            if((j%BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON)== 1)
            {
                button_w = BT145_LIST_INPUT_HEAD_B1_W ;
            }
            else
            {
                button_w = BT145_LIST_INPUT_HEAD_B0_W ;
            }
            if(j > 0)
            {
                button_x = button_x + bt145_list_input_head_area_button[button_index-1].w + BT145_LIST_INPUT_HEAD_V_LINE_PIX;
            }
            else
            {
                button_x = 0;
            }
                
            bt145_list_input_head_area_button[button_index].x = button_x;
            bt145_list_input_head_area_button[button_index].w = button_w;
            bt145_list_input_head_area_button[button_index].h = BT145_LIST_INPUT_HEAD_B0_H;
            bt145_list_input_head_area_button[button_index].w_pen_gap = 0;
            bt145_list_input_head_area_button[button_index].h_pen_gap = 0;  
            bt145_list_input_head_area_button[button_index].label = (UI_string_type) bt145_list_input_app_list[button_index];            
        }          

    
    }
    
    BT145_list_input_head_area_highlight_button = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
    wgui_bt145_list_input_head_area_button_handler[0] = NULL;
    
    //wgui_uce_control_button_handler[0] = EntrySymbolPickerScreen;
} 
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_check_pen_point
 * DESCRIPTION
 *  check pen point in whith head area button
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  the button index 
 *****************************************************************************/
static U8 wgui_BTcat145_list_input_head_area_check_pen_point(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    U8 i = 0;
    S16 button_x1,button_x2,editor_y1,editor_y2;
    S16 button_y1 = 0,button_y2 = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    editor_y1 = MMI_multiline_inputbox.y - bt145_list_input_head_area_button[i].h_pen_gap;
    editor_y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height + bt145_list_input_head_area_button[i].h_pen_gap;

    if(editor_y2 > MMI_multiline_inputbox.y + MMI_multiline_inputbox.height)
    {
        editor_y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height -1;
    }
    if((editor_y1 <= point.y)&&(editor_y2 >= point.y))
    {
        for(i = 0; i < bt145_list_input_button_count ; i++)
        {   
            if(!bt145_list_input_head_area_button[i].h)
            {
                break;
            }
            button_x1 = bt145_list_input_head_area_button[i].x - bt145_list_input_head_area_button[i].w_pen_gap;
            button_x2 = bt145_list_input_head_area_button[i].x + bt145_list_input_head_area_button[i].w + bt145_list_input_head_area_button[i].w_pen_gap;
            
            button_y1 = bt145_list_input_head_area_button[i].y - bt145_list_input_head_area_button[i].h_pen_gap;
            button_y2 = bt145_list_input_head_area_button[i].y + bt145_list_input_head_area_button[i].h + bt145_list_input_head_area_button[i].h_pen_gap;
                        

            if((button_x1 <= point.x )&&(button_x2 >= point.x))
            {
                if((button_y1 <= point.y )&&(button_y2 >= point.y))
                {
                    if(bt145_list_input_head_area_button[i].label)
                    {
                        return  i;
                    }
                    else
                    {
                      break;  
                    }
                }    
            }
        }  
    }
    return LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;

    
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_PenDownHdlr
 * DESCRIPTION
 *  check pen down event in head area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen down button ,MMI_FALSE:not pen down button [MMI_BOOL]
 *****************************************************************************/
MMI_BOOL wgui_BTcat145_list_input_head_area_PenDownHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_list_input_head_area_check_pen_point(point);
    if(button_index != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX)
    {
        BT145_list_input_head_area_highlight_button = button_index;               
        wgui_BTcat145_list_input_head_area_show_button(button_index,0,1);//just show down status button        
        return MMI_TRUE;

    }
    return MMI_FALSE;
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_PenUpHdlr
 * DESCRIPTION
 *  check pen up event in head area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen up button ,MMI_FALSE:not pen up button [MMI_BOOL]
 *****************************************************************************/
MMI_BOOL wgui_BTcat145_list_input_head_area_PenUpHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
    wgui_BT145_list_input_head_button_handler handler;
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_list_input_head_area_check_pen_point(point);
    if(button_index != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX)
    {
        wgui_BTcat145_list_input_head_area_show_button(LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX,1,1);//just show up with all buttons              
        if(BT145_list_input_head_area_highlight_button == button_index)
        {
           // now all button handler is same ,so call wgui_bt145_list_input_head_area_button_handler[0]
           handler = wgui_bt145_list_input_head_area_button_handler[0] ;  
           if(handler)
           {
             handler((S32)button_index); 
           }
        }
        BT145_list_input_head_area_highlight_button =  LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;    
        return MMI_TRUE;

    }
    BT145_list_input_head_area_highlight_button =  LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX; 
    return MMI_FALSE;
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_PenMoveHdlr
 * DESCRIPTION
 *  check pen move event in head area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen move button ,MMI_FALSE:not pen move button [MMI_BOOL]
 *****************************************************************************/
MMI_BOOL wgui_BTcat145_list_input_head_area_PenMoveHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
    U8 i = 0;
    U8 need_redraw_button_all = 0;
    U8 need_draw_button = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
    MMI_BOOL result = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_list_input_head_area_check_pen_point(point);
    if(button_index != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX)
    {
        if(BT145_list_input_head_area_highlight_button != button_index)
        {// down and move in not one same button
            BT145_list_input_head_area_highlight_button = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
            //need_redraw_button_all = 1;            
        }
        else
        {
           need_draw_button = button_index; 
        }
        need_redraw_button_all = 1;
        result = MMI_TRUE;
    }
    else 
    {   // down on button and move out on button
        //if(ctrl_area_highlight_button != BUTTTON_MAX) 
        {
            need_redraw_button_all = 1;
        }
        BT145_list_input_head_area_highlight_button = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
        result = MMI_FALSE;

    }
    if(need_redraw_button_all)
    {  
        wgui_BTcat145_list_input_head_area_show_button(need_draw_button,1,1);// show up and down
    }
    
    return result;
}
/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_head_area_register_controlled_callback
 * DESCRIPTION
 *  register APP callback to head area button
 * PARAMETERS
 *  handler       [IN]  app callback
 *  button_index  [IN]  button index which been  register callback 
 * RETURNS
 *  void
 *****************************************************************************/
void wgui_BTcat145_list_input_head_area_register_controlled_callback(void (*handler)(S32 index))//(void (*handler) (void),U8 button_index)
{

    //  if(button_index >=0 && button_index < LIST_INPUT_HEAD_BUTTTON_MAX)
    {
        wgui_bt145_list_input_head_area_button_handler[0] = handler;
    }

}

/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_draw_head
 * DESCRIPTION
 *  draw BTcat145 head area
 * PARAMETERS
 *  is_draw  [MMI_BOOL]  MMI_TRUE :draw ,MMI_FALSE: no draw
 *  yoffset  [IN]  start Y 
 *  height   [IN]  header area height
 *  clip_xl  [IN]  editr start x
 *  clip_yl  [IN]  editr start y
 *  clip_x2  [IN]  editr end   x
 *  clip_y2  [IN]  editr end   y
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_list_input_draw_head(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color line_color = {30, 30, 30, 100}; 
    U8 i = 0;
    U8 j = 0;
    U16 line_x = 0;
    U16 line_y1 = MMI_title_y + MMI_title_height;
    U16 line_y2 = LCD_HEIGHT-1;
    S32 button_y = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bt145_list_input_head_area_start_y = 0 ; 
    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, clip_y1, LCD_WIDTH-1, clip_y2);    
    // draw line
#if 0 // now need every button draw by itself
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    
    bt145_list_input_head_area_start_y = yoffset ;
    yoffset = yoffset + BT145_LIST_INPUT_HEAD_GAP;
    for(i = 0; i < bt145_list_input_all_row; i++)
    {// update all button start y
    
        button_y = yoffset + BT145_LIST_INPUT_HEAD_H_LINE_PIX + (i*(BT145_LIST_INPUT_HEAD_B0_H+BT145_LIST_INPUT_HEAD_H_LINE_PIX));
        
        for(j = 0; j < BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON; j++)
        {
            bt145_list_input_head_area_button[j+(i*BT145_LIST_INPUT_HEAD_ONE_LINE_MIX_BUTTON)].y = button_y ;
        }
    }
    
    wgui_BTcat145_list_input_head_area_show_button(LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX, 1,0);// can't show highlight button

    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}


#ifdef __MMI_EDITOR_SSP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_list_input_pen_down_hdlr
 * DESCRIPTION
 *  check pen down event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen down button ,MMI_FALSE:not pen down button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_list_input_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   /*if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenDownHdlr(pos);
      return MMI_TRUE; 
   }    
   else */ 
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_DOWN);

       //if((pos.y > bt145_list_input_head_area_start_y)&&(bt145_list_input_head_area_start_y))
       {
          wgui_BTcat145_list_input_head_area_PenDownHdlr(pos);
       }           
       return MMI_TRUE;
   }
   return  MMI_FALSE;
    
}
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_list_input_pen_up_hdlr
 * DESCRIPTION
 *  check pen up event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen up button ,MMI_FALSE:not pen up button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_list_input_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret ;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   
   /*if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenUpHdlr(pos);
      return MMI_TRUE; 
    }    
    else */
    if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
    {
        ret =  gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_UP);
        //if((pos.y > bt145_list_input_head_area_start_y)&&(bt145_list_input_head_area_start_y)&&(!ret))
        if(!ret)
        {
            wgui_BTcat145_list_input_head_area_PenUpHdlr(pos);
            return MMI_TRUE; 
        }  
        return ret;  
    }
    return  MMI_FALSE;    
}
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_list_input_pen_move_hdlr
 * DESCRIPTION
 *  check pen move event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen move button ,MMI_FALSE:not pen move button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_list_input_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret ;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       ret = gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_MOVE);
       //if((pos.y > bt145_list_input_head_area_start_y)&&(bt145_list_input_head_area_start_y)&&(!ret))// in head area
       if(!ret)
       {
          wgui_BTcat145_list_input_head_area_PenMoveHdlr(pos);
          return MMI_TRUE;
       }
       //else if((bt145_list_input_head_area_start_y)&&(BT145_list_input_head_area_highlight_button != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX))
       else if(BT145_list_input_head_area_highlight_button != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX)
       {// head area can be see,move to other button ,should redraw button
            wgui_BTcat145_list_input_head_area_show_button(LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX,1,1);
            BT145_list_input_head_area_highlight_button = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
       }
       return ret;
   }
   if(BT145_list_input_head_area_highlight_button != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX)
   {// mvoe out editor,should redraw button
        wgui_BTcat145_list_input_head_area_show_button(LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX,1,1);
        BT145_list_input_head_area_highlight_button = LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX;
   }
   
   return  MMI_FALSE;
}


#endif /*__MMI_EDITOR_SSP_SUPPORT__*/


/*****************************************************************************
 * FUNCTION
 *  wgui_BTcat145_list_input_get_header_and_footer_height
 * DESCRIPTION
 *  get header area  and footer area height 
 * PARAMETERS
 *  header_height    [OUT]   header height
 *  footer_height    [OUT]   footer height
 * RETURNS
 *  void
 *****************************************************************************/
static void wgui_BTcat145_list_input_get_header_and_footer_height(U16 *header_height, U16 *footer_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 header = 0, footer = 0;
    U8  line_h  = BT145_LIST_INPUT_HEAD_H_LINE_PIX;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/     

     header = bt145_list_input_all_row*(BT145_LIST_INPUT_HEAD_B0_H + line_h) + line_h + BT145_LIST_INPUT_HEAD_GAP;
    
    footer = 0;
    *header_height = header;
    *footer_height = footer;
}
/*****************************************************************************
 * FUNCTION
 *  DrawBTCate145CategoryControlArea_WEARABLE_DEVICE_list_input
 * DESCRIPTION
 *  control area callback for category145
 * PARAMETERS
 *  coordinate    [IN]   control area coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void DrawBTCate145CategoryControlArea_WEARABLE_DEVICE_list_input(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = MMI_title_y + MMI_title_height ;
    color text_color = {245, 245, 245, 100};
    color bg_color = {0, 0, 0, 100};
    U8 number_len = 0;
  //  UI_filled_area f;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, MMI_title_height + MMI_title_y, LCD_WIDTH-1, LCD_HEIGHT-1);

   // gdi_draw_solid_rect(0, MMI_title_height + MMI_title_y, LCD_WIDTH-1, LCD_HEIGHT-1 , gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));
    
    gui_set_font(&MMI_default_font);
    //gui_move_multi_line_input_box(&MMI_multiline_inputbox, G_145_SMALL_SPACE, y); 
    gui_move_multi_line_input_box(&MMI_multiline_inputbox, 0, y);
    
    {
        resize_multiline_inputbox(LCD_WIDTH, LCD_HEIGHT- MMI_title_height); 
    }

    //MMI_multiline_inputbox.text_x = BT145_HEAD_LEFT_MARGIN;
    MMI_multiline_inputbox.margin.top_margin = 0;
    MMI_multiline_inputbox.text_y = 0;
   // f = *b->normal_filler;
  //  f.flags &= ~(UI_FILLED_AREA_BORDER); // no border
    MMI_multiline_inputbox.ext_flags |= (GUI_MULTI_LINE_INPUT_BOX_SET_BG_COLOR|GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER); // bg black
    
    MMI_multiline_inputbox.default_bg_color = bg_color;
    MMI_multiline_inputbox.normal_text_color = text_color;
        
    gui_show_multi_line_input_box(&MMI_multiline_inputbox);
    gdi_layer_pop_clip();
}

/*****************************************************************************
 * FUNCTION
 *  ShowBTNotiCategory145Screen_list_input_WEARABLE_DEVICE
 * DESCRIPTION
 *  by pen selec input characert
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowBTNotiCategory145Screen_list_input_WEARABLE_DEVICE(
            U8 *title,
            U16 title_icon,
            U16 left_softkey,
            U16 left_softkey_icon,
            U16 right_softkey,
            U16 right_softkey_icon,
            U8 **list_item,
            U16 item_count,
            U8 *history_buffer
            )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32  width, height, content_width;
    U16 header_height;
    U16 footer_height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) title;


    content_width = UI_device_width;
    create_multiline_inputbox_set_buffer((UI_string_type) &sample_text_buff, 2, 2, 0);
    resize_multiline_inputbox(content_width, MMI_content_height);
    show_multiline_inputbox_no_draw();
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
       // | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);


    gui_set_font(&MMI_default_font);
    
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    MMI_title_icon = (PU8) get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/


    /* 
    {
        register_keyboard_key_handler(cat145_bt_keyboard_key_handler);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    */
    bt145_list_input_button_count = item_count;
    bt145_list_input_app_list = list_item;

    {
        wgui_BTcat145_list_input_head_area_ini(1,get_string(left_softkey),get_string(right_softkey));// show  1 button
    }    
    
    wgui_BTcat145_list_input_get_header_and_footer_height(&header_height, &footer_height);
    MMI_multiline_inputbox.header_height = header_height;
    MMI_multiline_inputbox.footer_height= 0;


    
    MMI_multiline_inputbox.header_callback = wgui_BTcat145_list_input_draw_head;
    MMI_multiline_inputbox.footer_callback = NULL;
    MMI_multiline_inputbox.header_height = header_height;
    MMI_multiline_inputbox.footer_height= 0;
    
#ifdef __MMI_EDITOR_SSP_SUPPORT__
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_list_input_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_list_input_pen_up_hdlr, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_list_input_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /*__MMI_EDITOR_SSP_SUPPORT__*/



    ExitCategoryFunction = ExitCategory145Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawBTCate145CategoryControlArea_WEARABLE_DEVICE_list_input);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY145_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_data.s32flags |= DM_NO_STATUS_BAR |DM_NO_SOFTKEY; // no title ,no status bar   
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}



///////////////
#endif /*__MMI_WEARABLE_DEVICE_LIST_INPUT__*/


#ifdef __BT145_SUPPORT_LIST_BUTTONS_WITH_MULTILINE_EDITOR__


//////////////

extern gui_line_struct g_visible_multiline_line_info;
extern gui_line_struct g_multiline_line_info;


wgui_BT145_list_item_head_button_struct  bt145_list_item_head_area_button [LIST_ITEM_BUTTTON_MAX];
//wgui_BT145_list_item_head_button_handler  wgui_bt145_list_item_head_area_button_handler[1]; 
S16 bt145_list_item_head_area_start_y = 0;
U16 BT145_list_item_head_area_highlight_button = LIST_ITEM_BUTTTON_MAX;
U16 sample_item_text_buff[6];
U16 bt145_list_item_all_row = 0;
U16 bt145_list_item_button_count = 0;
//U8 **bt145_list_item_app_list = NULL;

show_btnoti_category145screen_item * bt145_list_current_item = NULL;

multi_line_input_box BT145_list_item_inputbox;

show_btnoti_category145screen_item BT145_list_item_data_item[LIST_ITEM_BUTTTON_MAX];



show_btnoti_category145screen_item  *wgui_BTcat145_list_item_get_data_item( U8 index)
{
  if(index < LIST_ITEM_BUTTTON_MAX)
  {

    return &BT145_list_item_data_item[index];
  }

  return NULL;
}


MMI_BOOL wgui_BTcat145_list_item_header_area_check_need_change_mode(U8 index)
{
    if(!index)
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;
}

MMI_BOOL wgui_BTcat145_list_item_footer_area_check_need_change_mode(U8 index)
{
    if(!index)
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;

}

static void wgui_BTcat145_list_item_get_header_and_footer_height(U16 *header_height, U16 *footer_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 header = 0, footer = 0;
    U8  line_h  = BT145_LIST_ITEM_HEAD_H_LINE_PIX;
    U8  i = 0;
    U16 hight = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/     
    for(i = 0 ; i < LIST_ITEM_BUTTTON_MAX ; i++)
    {
       hight = hight + bt145_list_item_head_area_button[i].h  ;
    }
     header = hight + line_h + BT145_LIST_ITEM_HEAD_GAP;
    
    footer = 0;
    *header_height = header;
    *footer_height = footer;
}


void wgui_BTcat145_list_item_data_footer_area_set_button_handler(show_btnoti_category145screen_item * item_p,void (*handler) (void),U8 button_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!item_p)
    {
        return;
    }

    if(button_index >=0 && button_index < LIST_ITEM_FOOTER_BUTTTON_MAX)
    {
        item_p->footer_area_button_handler[button_index] = handler;
    }
}

void wgui_BTcat145_list_item_data_header_area_set_button_handler_in_short_mode(show_btnoti_category145screen_item * item_p,void (*handler) (void),U8 button_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!item_p)
    {
        return;
    }

    if(button_index >=0 && button_index < LIST_ITEM_HEADER_BUTTTON_MAX)
    {
        item_p->header_area_button_handler[button_index] = handler;
    }
}


void wgui_BTcat145_list_item_data_footer_area_set_button_lable(show_btnoti_category145screen_item * item_p,UI_string_type label,U8 button_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!item_p)
    {
        return;
    }

    if(button_index >=0 && button_index < LIST_ITEM_FOOTER_BUTTTON_MAX)
    {
        item_p->footer_button_lable[button_index] = label;
    }
}
void wgui_BTcat145_list_item_data_header_area_set_button_lable_in_short_mode(show_btnoti_category145screen_item * item_p,UI_string_type label,U8 button_index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!item_p)
    {
        return;
    }

    if(button_index >=0 && button_index < LIST_ITEM_HEADER_BUTTTON_MAX)
    {
        item_p->header_button_lable[button_index] = label;
    }
}

void wgui_BTcat145_list_item_data_ini(show_btnoti_category145screen_item * item_p,
    U8* header_image_path,
    PU8 header_image_data,   
    U8 *title,
    U8 *message_title,
    U8 *message,
    U8 *time,
    U8 footer_area_buttons,
    U8 header_area_buttons,
    U32 flags)
{
    if(item_p)
    {
        
        item_p->title = title;
        item_p->message_title = message_title;
        item_p->message = message;
        item_p->time = time;
        item_p->footer_buttons = footer_area_buttons;
        item_p->header_buttons = header_area_buttons;
        item_p->flags = flags;
        
        item_p->header_area_show_image_path = header_image_path;
        item_p->header_area_show_image_data = header_image_data;
    }
}
static void wgui_BTcat145_list_item_data_footer_area_ini(show_btnoti_category145screen_item * item_p,S32 *e_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!item_p)
    {
        return;
    }
    
    memset(item_p->footer_area_button,0,sizeof(item_p->footer_area_button));

    if(item_p->footer_buttons <= LIST_ITEM_FOOTER_BUTTTON_MAX)   
    {  
        for(i = 0 ; i < item_p->footer_buttons ; i++)
        {
            item_p->footer_area_button[i].x = BT145_LIST_ITEM_FOOTER_BX_X;
            item_p->footer_area_button[i].y = BT145_LIST_ITEM_FOOTER_BX_Y + (i*BT145_LIST_ITEM_FOOTER_BX_H) ;
            item_p->footer_area_button[i].w = BT145_LIST_ITEM_FOOTER_BX_W;
            item_p->footer_area_button[i].h = BT145_LIST_ITEM_FOOTER_BX_H;
            item_p->footer_area_button[i].w_pen_gap= BT145_LIST_ITEM_W_GAP;
            item_p->footer_area_button[i].h_pen_gap = BT145_LIST_ITEM_H_GAP;   
            item_p->footer_area_button[i].label =  item_p->footer_button_lable[i];
        }
    }
    *e_height = BT145_LIST_ITEM_FOOTER_BX_Y + (item_p->footer_buttons * BT145_LIST_ITEM_FOOTER_BX_H);
}

static void wgui_BTcat145_list_item_data_header_area_ini(show_btnoti_category145screen_item * item_p,S32 *e_height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/ 
    U8 i = 0;
    U16 image_h = 0; 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!item_p)
    {
        return;
    }
    
    memset(item_p->header_area_button,0,sizeof(item_p->header_area_button));

    if(item_p->header_buttons <= LIST_ITEM_HEADER_BUTTTON_MAX)   
    {  
        for(i = 0 ; i < item_p->header_buttons ; i++)
        {
            item_p->header_area_button[i].x = BT145_LIST_ITEM_FOOTER_BX_X;
            item_p->header_area_button[i].y = BT145_LIST_ITEM_FOOTER_BX_Y ;
            item_p->header_area_button[i].w = BT145_LIST_ITEM_FOOTER_BX_W;
            item_p->header_area_button[i].h = BT145_LIST_ITEM_FOOTER_BX_H;
            item_p->header_area_button[i].w_pen_gap= BT145_LIST_ITEM_W_GAP;
            item_p->header_area_button[i].h_pen_gap = BT145_LIST_ITEM_H_GAP;   
            item_p->header_area_button[i].label =  item_p->header_button_lable[i];
        }
    }
    *e_height =  (item_p->header_buttons * BT145_LIST_ITEM_FOOTER_BX_H);
}



void wgui_BTcat145_list_item_data_all_area_draw_button(U8 index, U8 down,S32 x,S32 y,S32 w, S32 h,UI_string_type str,U8 buttons,U8 max_buttons,U8 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // U8 *img_src = NULL;
    color text_color_down = {255, 255, 255, 100};
    color bg_color_down = {31, 181, 172, 100};
    color text_color_up = {52, 149, 165, 100};
    color bg_color_up = {32, 32, 40, 100};//{0, 0, 0, 100};   
    color line_color  ;
    color bg_color ; 
    color text_color ; 

    color line_enable_color = {61, 107, 120, 100};
    
    color bg_disable_color =  {62, 64, 76, 100}; 
    color text_disable_color = {90, 94, 105, 100}; 
    color line_disable_color = {91, 95, 105, 100};
    
    UI_string_type string = str;
    S32 sw, sh;

    S32 button_x = x;
    S32 button_y = y;
    S32 button_w = w;
    S32 button_h = h;
    S32 x_move = 0;
    S32 draw_button_h = LCD_HEIGHT-1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    if((index >= 0)&&(index < max_buttons)&&(h))
    {


        if(buttons<= max_buttons)
        {
            draw_button_h =  h + button_y-2;
        }

        {
            line_color = line_enable_color;
            if(down)
            {
                //img_src = get_image(bt145_footer_area_button[index].normal_down_icon);
                bg_color = bg_color_down;
                text_color = text_color_down;            
            }
            else
            {
                //img_src = get_image(bt145_footer_area_button[index].normal_up_icon);
                bg_color = bg_color_up;
                text_color = text_color_up;              //GDI_COLOR_GREEN         
            }
            //draw button bg

        }
        
        if(flags != MMI_BT145_LIST_ITEM_STSTUS_SHORT_MODE)
        {
            gdi_draw_line(0, button_y-1, LCD_WIDTH-1, button_y-1, 
                gdi_act_color_from_rgb(line_color.alpha, line_color.r, line_color.g, line_color.b)); 
        }
        gdi_draw_solid_rect(button_x, 
                            button_y, 
                            button_x + button_w - 1,
                            draw_button_h,                                                        
                            gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));         
        
        // draw label
        gui_measure_string(string, &sw, &sh);
        
        if(button_h > sh)
        {
            button_y = button_y + ((button_h - sh)/2);
        } 
        if(button_w > sw)
        {
            x_move = (button_w - sw)/2;
        }
        if (mmi_fe_get_r2l_state())
        {
            button_x = button_x + button_w-1-x_move;
        }    
        else
        {
            button_x = button_x + x_move ;
        }
        gui_set_text_color(text_color);
        
        if(sw >= button_w)
        {
            gui_print_truncated_text(button_x,button_y, button_w,string);    
        }
        else
        {   
            gui_move_text_cursor(button_x, button_y);
            gui_print_text(string);            
        }              
    }

}



void wgui_BTcat145_list_item_data_footer_area_draw_button(U8 index, U8 down,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_p = (show_btnoti_category145screen_item*)item;
    if(!item_p)
    {
        return;
    }
    wgui_BTcat145_list_item_data_all_area_draw_button(index,down,
         item_p->footer_area_button[index].x,
         item_p->footer_area_button[index].y,
         item_p->footer_area_button[index].w, 
         item_p->footer_area_button[index].h,
         (UI_string_type)item_p->footer_area_button[index].label,
         item_p->footer_buttons,LIST_ITEM_FOOTER_BUTTTON_MAX,
         item_p->flags);
}

void wgui_BTcat145_list_item_data_footer_area_show_button(U8 down_index, U8 flag_update_all,U8 need_blt,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_p = (show_btnoti_category145screen_item*)item;
    if(!item_p)
    {
        return;
    }
    {   
        if(need_blt) 
        {
            gdi_layer_lock_frame_buffer();
            gdi_layer_push_clip();
            gui_set_clip_preset(0, 
                                MMI_multiline_inputbox.y,
                                UI_device_width - 1,
                                MMI_multiline_inputbox.y+ MMI_multiline_inputbox.height - 1);
        }    
        for(i = 0; i < LIST_ITEM_FOOTER_BUTTTON_MAX ; i++)
        {
            if((down_index < LIST_ITEM_FOOTER_BUTTTON_MAX)&&(down_index == i))
            {
                wgui_BTcat145_list_item_data_footer_area_draw_button(i,1,item_p);
            }
            else if(flag_update_all)
            {                    
                wgui_BTcat145_list_item_data_footer_area_draw_button(i,0,item_p);
            }            
        } 
        
        if(need_blt)
        {   gdi_layer_pop_clip();
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);  
        }
    }
}
void wgui_BTcat145_list_item_data_header_area_draw_button_in_short_mode(U8 index, U8 down,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    show_btnoti_category145screen_item *item_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_p = (show_btnoti_category145screen_item*)item;
    if(!item_p)
    {
        return;
    }
    wgui_BTcat145_list_item_data_all_area_draw_button(index,down,
         item_p->header_area_button[index].x,
         item_p->header_area_button[index].y,
         item_p->header_area_button[index].w, 
         item_p->header_area_button[index].h,
         (UI_string_type)item_p->header_area_button[index].label,
         item_p->header_buttons,LIST_ITEM_HEADER_BUTTTON_MAX,
         item_p->flags);
}

void wgui_BTcat145_list_item_data_header_area_show_button_in_short_mode(U8 down_index, U8 flag_update_all,U8 need_blt,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_p = (show_btnoti_category145screen_item*)item;
    if(!item_p)
    {
        return;
    }
    {   
        if(need_blt) 
        {
            gdi_layer_lock_frame_buffer();
            gdi_layer_push_clip();
            gui_set_clip_preset(0, 
                                MMI_multiline_inputbox.y,
                                UI_device_width - 1,
                                MMI_multiline_inputbox.y+ MMI_multiline_inputbox.height - 1);
        }    
        for(i = 0; i < LIST_ITEM_HEADER_BUTTTON_MAX ; i++)
        {
            if((down_index < LIST_ITEM_HEADER_BUTTTON_MAX)&&(down_index == i))
            {
                wgui_BTcat145_list_item_data_header_area_draw_button_in_short_mode(i,1,item_p);
            }
            else if(flag_update_all)
            {                    
                wgui_BTcat145_list_item_data_header_area_draw_button_in_short_mode(i,0,item_p);
            }            
        } 
        
        if(need_blt)
        {   gdi_layer_pop_clip();
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);  
        }
    }
}

static void wgui_BTcat145_list_item_data_draw_header_in_short_mode(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = yoffset ;
    color text_color = {245, 245, 245, 100};
    color text_color2 = {60, 60, 245, 100};
    color text_color3 = {90, 90, 122, 100};
    S32 show_string_x = LCD_WIDTH - BT145_LIST_ITEM_HEAD_RIGHT_MARGIN;
    S32 button_y = 0;
    U8 i;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!bt145_list_current_item)
    {
        return;
    }
    
    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();

    if(clip_y1 < MMI_multiline_inputbox.y)
    {
        clip_y1 = MMI_multiline_inputbox.y;
    }
    
    if(clip_y2 > (MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1))
    {
        clip_y2 = MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1;
    }
        
    gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    
    {
        // draw icon
        if (bt145_list_current_item->header_area_show_image_path)
        {    
            gdi_image_draw_resized_file(BT145_LIST_ITEM_HEAD_ICON_X, y + BT145_LIST_ITEM_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*)bt145_list_current_item->header_area_show_image_path);
        }
        else if (bt145_list_current_item->header_area_show_image_data)
        {
            gdi_image_draw_resized(BT145_LIST_ITEM_HEAD_ICON_X, y + BT145_LIST_ITEM_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*) bt145_list_current_item->header_area_show_image_data);
        }
        // draw APP Name
        gui_set_text_color(text_color); 
        if(!bt145_list_current_item->flags)
        {
            gui_set_text_color(text_color2); 
        }
        else if(bt145_list_current_item->flags == 1)
        {
            gui_set_text_color(text_color3); 
        }
        gui_set_font(&MMI_medium_font);

        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_LIST_ITEM_HEAD_APP_NAME_Y,
                                           BT145_LIST_ITEM_HEAD_APP_NAME_MAX_LENGTH,
                                                 (UI_string_type)bt145_list_current_item->title);       
        } 
        else
        {
            gui_print_truncated_text(BT145_LIST_ITEM_HEAD_APP_NAME_X ,y + BT145_LIST_ITEM_HEAD_APP_NAME_Y,
                                           BT145_LIST_ITEM_HEAD_APP_NAME_MAX_LENGTH,
                                                 (UI_string_type)bt145_list_current_item->title);   
        }
        // draw time
        gui_set_font(&MMI_small_font);
        gui_print_truncated_text(BT145_LIST_ITEM_HEAD_TIME_X ,y + BT145_LIST_ITEM_HEAD_TIME_Y,BT145_LIST_ITEM_HEAD_TIME_MAX_LENGTH,(UI_string_type)bt145_list_current_item->time);       

        // draw message title
        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_LIST_ITEM_HEAD_TITLE_Y,BT145_LIST_ITEM_HEAD_TITLE_MAX_LENGTH,(UI_string_type)bt145_list_current_item->message_title);  
        }
        else
        {
            gui_print_truncated_text(BT145_LIST_ITEM_HEAD_TITLE_X ,y + BT145_LIST_ITEM_HEAD_TITLE_Y,BT145_LIST_ITEM_HEAD_TITLE_MAX_LENGTH,(UI_string_type)bt145_list_current_item->message_title);       
        }   
        // draw content
        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_LIST_ITEM_HEAD_TITLE_Y + BT145_LIST_ITEM_HEAD_FONT_SIZE,BT145_LIST_ITEM_HEAD_TITLE_MAX_LENGTH,(UI_string_type)bt145_list_current_item->message);  
        }
        else
        {
            gui_print_truncated_text(BT145_LIST_ITEM_HEAD_TITLE_X ,y + BT145_LIST_ITEM_HEAD_TITLE_Y + BT145_LIST_ITEM_HEAD_FONT_SIZE,BT145_LIST_ITEM_HEAD_TITLE_MAX_LENGTH,(UI_string_type)bt145_list_current_item->message);       
        }         
    }
    gui_set_font(&MMI_default_font);

    button_y =  y + BT145_LIST_ITEM_HEAD_TITLE_Y + BT145_LIST_ITEM_HEAD_FONT_SIZE + BT145_LIST_ITEM_HEAD_FONT_SIZE;

    //draw button
    if(bt145_list_current_item->header_buttons <= LIST_ITEM_HEADER_BUTTTON_MAX)  
    {
        bt145_list_current_item->header_area_start_y = yoffset ;

        for(i = 0 ; i < bt145_list_current_item->header_buttons ; i++)
        {
            bt145_list_current_item->header_area_button[i].y =   (i*BT145_LIST_ITEM_FOOTER_BX_H)  + button_y ;
        }
        
        wgui_BTcat145_list_item_data_header_area_show_button_in_short_mode(LIST_ITEM_HEADER_BUTTTON_MAX, 1,0,bt145_list_current_item);// can't show highlight button
    }

   
   
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}

static void wgui_BTcat145_list_item_data_draw_header(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = yoffset ;
    color text_color = {245, 245, 245, 100};
    color text_color2 = {60, 60, 245, 100};
    color text_color3 = {90, 90, 122, 100};
    S32 show_string_x = LCD_WIDTH - BT145_LIST_ITEM_HEAD_RIGHT_MARGIN;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!bt145_list_current_item)
    {
        return;
    }
    
    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();

    if(clip_y1 < MMI_multiline_inputbox.y)
    {
        clip_y1 = MMI_multiline_inputbox.y;
    }
    
    if(clip_y2 > (MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1))
    {
        clip_y2 = MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1;
    }
        
    gdi_layer_set_clip(clip_x1, clip_y1, clip_x2, clip_y2);
    
    {
        // draw icon
        if (bt145_list_current_item->header_area_show_image_path)
        {    
            gdi_image_draw_resized_file(BT145_LIST_ITEM_HEAD_ICON_X, y + BT145_LIST_ITEM_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*)bt145_list_current_item->header_area_show_image_path);
        }
        else if (bt145_list_current_item->header_area_show_image_data)
        {
            gdi_image_draw_resized(BT145_LIST_ITEM_HEAD_ICON_X, y + BT145_LIST_ITEM_HEAD_ICON_Y, G_145_IMAGE_SIZE, G_145_IMAGE_SIZE, (U8*) bt145_list_current_item->header_area_show_image_data);
        }
        // draw APP Name
        gui_set_text_color(text_color); 
        if(!bt145_list_current_item->flags)
        {
            gui_set_text_color(text_color2); 
        }
        else if(bt145_list_current_item->flags == 1)
        {
            gui_set_text_color(text_color3); 
        }
        gui_set_font(&MMI_medium_font);

        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_LIST_ITEM_HEAD_APP_NAME_Y,
                                           BT145_LIST_ITEM_HEAD_APP_NAME_MAX_LENGTH,
                                                 (UI_string_type)bt145_list_current_item->title);       
        } 
        else
        {
            gui_print_truncated_text(BT145_LIST_ITEM_HEAD_APP_NAME_X ,y + BT145_LIST_ITEM_HEAD_APP_NAME_Y,
                                           BT145_LIST_ITEM_HEAD_APP_NAME_MAX_LENGTH,
                                                 (UI_string_type)bt145_list_current_item->title);   
        }
        // draw  time
        gui_set_font(&MMI_small_font);
        gui_print_truncated_text(BT145_LIST_ITEM_HEAD_TIME_X ,y + BT145_LIST_ITEM_HEAD_TIME_Y,BT145_LIST_ITEM_HEAD_TIME_MAX_LENGTH,(UI_string_type)bt145_list_current_item->time);       

        // draw message title
        if(mmi_fe_get_r2l_state())
        {
            gui_print_truncated_text(show_string_x ,y + BT145_LIST_ITEM_HEAD_TITLE_Y,BT145_LIST_ITEM_TITLE_MAX_LENGTH,(UI_string_type)bt145_list_current_item->message_title);  
        }
        else
        {
            gui_print_truncated_text(BT145_LIST_ITEM_HEAD_TITLE_X ,y + BT145_LIST_ITEM_HEAD_TITLE_Y,BT145_LIST_ITEM_HEAD_TITLE_MAX_LENGTH,(UI_string_type)bt145_list_current_item->message_title);       
        }     
    }
    gui_set_font(&MMI_default_font);

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
        gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */    
   
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}


static void wgui_BTcat145_list_item_data_draw_footer(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bt145_list_current_item->footer_area_start_y = 0 ; 

    if(!bt145_list_current_item)
    {
        return;
    }

    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();

    if(clip_y1 < MMI_multiline_inputbox.y)
    {
        clip_y1 = MMI_multiline_inputbox.y;
    }
    
    if(clip_y2 > (MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1))
    {
        clip_y2 = MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1;
    }

    
    gdi_layer_set_clip(0, clip_y1, LCD_WIDTH-1, clip_y2);        
    
    
    //draw button
    if(bt145_list_current_item->footer_buttons <= LIST_ITEM_FOOTER_BUTTTON_MAX)  
    {
        bt145_list_current_item->footer_area_start_y = yoffset ;

        for(i = 0 ; i < bt145_list_current_item->footer_buttons ; i++)
        {
            bt145_list_current_item->footer_area_button[i].y = BT145_LIST_ITEM_FOOTER_BX_Y + (i*BT145_LIST_ITEM_FOOTER_BX_H) + yoffset;
        }
        
        wgui_BTcat145_list_item_data_footer_area_show_button(LIST_ITEM_FOOTER_BUTTTON_MAX, 1,0,bt145_list_current_item);// can't show highlight button
    }


    
    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}


void  wgui_BTcat145_list_tem_data_show(
    void *item, 
    void *common_item_data, 
    S32 x, 
    S32 y)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2, menu_y1, menu_y2;
    S32 ix1, iy1, ix2, iy2;
    color text_color;
    UI_filled_area *f = NULL;
    show_btnoti_category145screen_item *item_p = NULL;
    U32 flags, flags_ext;
    UI_string_type _text;
    PU8 _icon;
    U8 focussed_flag = 0;
    U8 disabled_flag = 0;
    U8 selected_flag = 0;
    S32 i;
    MMI_BOOL show_highlight = MMI_FALSE;
    S32 sw, sh;
    U32 ret_flag_ext = 0;

    gdi_handle old_alpha_layer = GDI_NULL_HANDLE;
    S32 icon_width, icon_height;


    S32 clip_x1, clip_x2, clip_y1, clip_y2;


    multi_line_input_box temp_editor;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   item_p = (show_btnoti_category145screen_item*)item ;
    if(item_p)
    {   bt145_list_current_item = item_p;
        memcpy(&temp_editor, &BT145_list_item_inputbox, sizeof(multi_line_input_box));

        BT145_list_item_inputbox.text = item_p->message;
        BT145_list_item_inputbox.x = x;
        BT145_list_item_inputbox.y = y;
        BT145_list_item_inputbox.width = MMI_multiline_inputbox.width;
        BT145_list_item_inputbox.height = item_p->editor_height;
        BT145_list_item_inputbox.footer_height = item_p->footer_height;
        BT145_list_item_inputbox.header_height = item_p->header_height;
        
        BT145_list_item_inputbox.header_callback = wgui_BTcat145_list_item_data_draw_header;
        BT145_list_item_inputbox.footer_callback = wgui_BTcat145_list_item_data_draw_footer;


        if(item_p->flags == MMI_BT145_LIST_ITEM_STSTUS_SHORT_MODE)            
        {  
            BT145_list_item_inputbox.height = item_p->header_short_mode_height;
            BT145_list_item_inputbox.text = (UI_buffer_type)&sample_item_text_buff; 
            BT145_list_item_inputbox.header_callback = wgui_BTcat145_list_item_data_draw_header_in_short_mode;
            BT145_list_item_inputbox.header_height = item_p->header_short_mode_height;
            BT145_list_item_inputbox.footer_height = 0;
            BT145_list_item_inputbox.footer_callback = 0;             
        }

        gdi_layer_lock_frame_buffer();
        gdi_layer_push_clip();                  
        gdi_layer_set_clip(MMI_multiline_inputbox.x, 
                           MMI_multiline_inputbox.y, 
                           MMI_multiline_inputbox.x+MMI_multiline_inputbox.width-1, 
                           MMI_multiline_inputbox.y+MMI_multiline_inputbox.height-1);

        gui_show_multi_line_input_box(&BT145_list_item_inputbox);

        
        memcpy(&BT145_list_item_inputbox, &temp_editor, sizeof(multi_line_input_box));

        gdi_layer_pop_clip();
        gdi_layer_unlock_frame_buffer();
    }

    bt145_list_current_item = NULL;



}



void wgui_BTcat145_list_item_data_measure(void *item, void *common_item_data, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    show_btnoti_category145screen_item *item_p = NULL;
    multi_line_input_box temp_editor;
    S32 e_width;
    S32 e_height;
    S32 header_height = 80 ;
    S32 header_short_mode_height = 100 + 10 ;
    S32 footer_height = 0;
    S32 h_height = 0 ;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(item)
    {   memcpy(&temp_editor, &BT145_list_item_inputbox, sizeof(multi_line_input_box));
    
        item_p = (show_btnoti_category145screen_item*)item;
        
        if(item_p)
        {
            MMI_multiline_inputbox.text = item_p->message;
            wgui_inputs_ml_resize_fit(LCD_WIDTH,LCD_HEIGHT,&e_width,&e_height);
            wgui_BTcat145_list_item_data_footer_area_ini(item_p,&footer_height);
            wgui_BTcat145_list_item_data_header_area_ini(item_p,&h_height);
            
            *height = e_height + header_height + footer_height;
            item_p->header_height = header_height;
            item_p->header_short_mode_height = header_short_mode_height + h_height;
            item_p->footer_height = footer_height;   
            item_p->editor_height = *height;

            if(item_p->flags ==MMI_BT145_LIST_ITEM_STSTUS_SHORT_MODE)
            {
                *height =  header_short_mode_height + h_height;
            }
            else
            {
                *height = e_height + header_height + footer_height;
            }

        }
        memcpy(&BT145_list_item_inputbox, &temp_editor, sizeof(multi_line_input_box));
    }
}


void wgui_BTcat145_list_item_head_area_draw_button(U8 index, U8 down)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color text_color_down = {255, 255, 255, 100};
    color bg_color_down = {52, 149, 165, 100};//{31, 81, 172, 100};
    color text_color_up = {245, 245, 245, 100};//{52, 149, 165, 100};
    color line_color = {45, 45, 56, 100};   
 
    

    S32 button_x = 0;
    S32 button_y = 0;
    S32 button_w = 0;
    S32 button_h = 0;
    S32 x_move = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if((index >= 0)&&(index < bt145_list_item_button_count)&&(bt145_list_item_head_area_button[index].h))
    {
        button_x = bt145_list_item_head_area_button[index].x;
        button_y = bt145_list_item_head_area_button[index].y;
        button_w = bt145_list_item_head_area_button[index].w;
        button_h = bt145_list_item_head_area_button[index].h;    

        if((button_y > (MMI_multiline_inputbox.y + MMI_multiline_inputbox.height-1))
           ||((button_y + button_h -1) < MMI_multiline_inputbox.y )
           ) 
        {
            return ; //no need draw item
        }
        
        {//draw button top line
               
             gdi_draw_line(button_x, button_y-1, button_x+button_w, button_y-1, 
                     gdi_act_color_from_rgb(line_color.alpha, line_color.r, line_color.g, line_color.b)); 
        }

        {//draw button down line
                       
             gdi_draw_line(button_x, button_y + button_h, button_x+button_w, button_y + button_h, 
                gdi_act_color_from_rgb(line_color.alpha, line_color.r, line_color.g, line_color.b));
        }

        wgui_BTcat145_list_tem_data_show(&BT145_list_item_data_item[index], 
                                           NULL, 
                                           button_x, 
                                           button_y);

    }

}

void wgui_BTcat145_list_item_head_area_show_button(U8 down_index, U8 flag_update_all,U8 need_blt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    {   
        if(need_blt) 
        {
            gdi_layer_lock_frame_buffer();
            gdi_layer_push_clip();
            gui_set_clip_preset(0, 
                                MMI_title_height + MMI_title_y,
                                UI_device_width - 1,
                                BT145_list_item_inputbox.y+ BT145_list_item_inputbox.height - 1);
        }    
        for(i = 0; i < bt145_list_item_button_count ; i++)
        {
            if((down_index < bt145_list_item_button_count)&&(down_index == i))
            {
                wgui_BTcat145_list_item_head_area_draw_button(i,1);
            }
            else if(flag_update_all)
            {                    
                wgui_BTcat145_list_item_head_area_draw_button(i,0);
            }            
        } 
        
        if(need_blt)
        {   gdi_layer_pop_clip();
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1);  
        }
    }
}
static U8 wgui_BTcat145_list_item_data_footer_area_check_pen_point(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    U8 i = 0;
    S16 x1,x2,y1,y2;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_p = (show_btnoti_category145screen_item*)item;
    
    if(!item_p)
    {
        return LIST_ITEM_FOOTER_BUTTTON_MAX;
    }

    
    if(item_p->footer_buttons <= LIST_ITEM_FOOTER_BUTTTON_MAX)   
    {
        for(i = 0; i < item_p->footer_buttons ; i++)
        {   
            if(!item_p->footer_area_button[i].h)
            {
                break;
            }

            y1 = item_p->footer_area_button[i].y - item_p->footer_area_button[i].h_pen_gap;
            y2 = item_p->footer_area_button[i].y + item_p->footer_area_button[i].h + item_p->footer_area_button[i].h_pen_gap;

            if(y2 > MMI_multiline_inputbox.y + MMI_multiline_inputbox.height)
            {
                y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height -1;
            }

            if((y1 <= point.y)&&(y2 >= point.y))
            {
                x1 = item_p->footer_area_button[i].x - item_p->footer_area_button[i].w_pen_gap;
                x2 = item_p->footer_area_button[i].x + item_p->footer_area_button[i].w + item_p->footer_area_button[i].w_pen_gap;
                if((x1 <= point.x )&&(x2 >= point.x))
                {
                    return  i;
                }

            }
        }  
    }         
    return LIST_ITEM_FOOTER_BUTTTON_MAX;    
}

MMI_BOOL wgui_BTcat145_list_item_data_footer_area_PenDownHdlr(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_FOOTER_BUTTTON_MAX;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    item_p = (show_btnoti_category145screen_item*)item;

    if(!item_p)
    {
        return;
    }
    button_index = wgui_BTcat145_list_item_data_footer_area_check_pen_point(point,item_p);

    if(button_index != LIST_ITEM_FOOTER_BUTTTON_MAX)
    {
        item_p->footer_area_highlight_button = button_index;               
        wgui_BTcat145_list_item_data_footer_area_show_button(button_index,0,1,item_p);//just show down status button        
        return MMI_TRUE;

    }
    return MMI_FALSE;
}


MMI_BOOL wgui_BTcat145_list_item_data_footer_area_PenUpHdlr(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_FOOTER_BUTTTON_MAX;
    void (*handler) (void);
    U8 i = 0;
    U16 header_height;
    U16 footer_height;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    item_p = (show_btnoti_category145screen_item*)item;
    if(!item_p)
    {
        return;
    }
    button_index = wgui_BTcat145_list_item_data_footer_area_check_pen_point(point,item_p);    
    if(button_index != LIST_ITEM_FOOTER_BUTTTON_MAX)
    {
        wgui_BTcat145_list_item_data_footer_area_show_button(LIST_ITEM_FOOTER_BUTTTON_MAX,1,1,item_p);//just show up with all buttons  
        if(disable_button_flag == MMI_FALSE)
        {
            if((item_p->footer_area_highlight_button == button_index)
                &&(BT145_list_item_head_area_highlight_button != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX))
            {
               handler = item_p->footer_area_button_handler[button_index] ;
               if(handler)
               {
                 handler(); 
               }
               if(wgui_BTcat145_list_item_header_area_check_need_change_mode(button_index))
               {
                    item_p->flags = MMI_BT145_LIST_ITEM_STSTUS_SHORT_MODE;
                    bt145_list_item_head_area_button[item_p->index].h = item_p->header_short_mode_height;
                    
                    wgui_BTcat145_list_item_get_header_and_footer_height(&header_height, &footer_height);
                    MMI_multiline_inputbox.header_height = header_height;

                    {
                       MMI_multiline_inputbox.text_offset_y =  MMI_multiline_inputbox.text_offset_y +
                              (0-bt145_list_item_head_area_button[item_p->index].y + MMI_multiline_inputbox.y);

                       if(MMI_multiline_inputbox.text_offset_y > 0 )
                       {
                            MMI_multiline_inputbox.text_offset_y = 0;
                       }
                    }
                                
                    gui_show_multi_line_input_box_no_draw(&MMI_multiline_inputbox);
                    
               }     
            }  
        }
        item_p->footer_area_highlight_button =  LIST_ITEM_FOOTER_BUTTTON_MAX;   
        if((wgui_BTcat145_list_item_header_area_check_need_change_mode(button_index))
            &&(BT145_list_item_head_area_highlight_button != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX))
        {   gdi_layer_lock_frame_buffer();
            
            gui_show_multi_line_input_box(&MMI_multiline_inputbox);
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1); 
        }    
        return MMI_TRUE;

    }
    item_p->footer_area_highlight_button =  LIST_ITEM_FOOTER_BUTTTON_MAX; 
    return MMI_FALSE;
}

MMI_BOOL wgui_BTcat145_list_item_data_footer_area_PenMoveHdlr(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_FOOTER_BUTTTON_MAX;
    U8 i = 0;
    U8 need_redraw_button_all = 0;
    U8 need_draw_button = LIST_ITEM_FOOTER_BUTTTON_MAX;
    MMI_BOOL result = MMI_FALSE;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    item_p = (show_btnoti_category145screen_item*)item;

    if(!item_p)
    {
        return;
    }
    button_index = wgui_BTcat145_list_item_data_footer_area_check_pen_point(point,item_p);

    
    if(button_index != LIST_ITEM_FOOTER_BUTTTON_MAX)
    {
        if(item_p->footer_area_highlight_button != button_index)
        {// down and move in not one same button
            item_p->footer_area_highlight_button = LIST_ITEM_FOOTER_BUTTTON_MAX;
            //need_redraw_button_all = 1;            
        }
        else
        {
           need_draw_button = button_index; 
        }
        need_redraw_button_all = 1;
        result = MMI_TRUE;
    }
    else 
    {   // down on button and move out on button
        //if(ctrl_area_highlight_button != BUTTTON_MAX) 
        {
            need_redraw_button_all = 1;
        }
        item_p->footer_area_highlight_button = LIST_ITEM_FOOTER_BUTTTON_MAX;
        result = MMI_FALSE;

    }
    if(need_redraw_button_all)
    {  
        wgui_BTcat145_list_item_data_footer_area_show_button(need_draw_button,1,1,item_p);// show up and down
    }
    
    return result;
}

static U8 wgui_BTcat145_list_item_data_header_area_check_pen_point(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    U8 i = 0;
    S16 x1,x2,y1,y2;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    item_p = (show_btnoti_category145screen_item*)item;

    if(!item_p)
    {
        return LIST_ITEM_HEADER_BUTTTON_MAX;
    }

    
    if(item_p->header_buttons <= LIST_ITEM_HEADER_BUTTTON_MAX)   
    {
        for(i = 0; i < item_p->header_buttons ; i++)
        {   
            if(!item_p->header_area_button[i].h)
            {
                break;
            }

            y1 = item_p->header_area_button[i].y - item_p->header_area_button[i].h_pen_gap;
            y2 = item_p->header_area_button[i].y + item_p->header_area_button[i].h + item_p->header_area_button[i].h_pen_gap;

            if(y2 > MMI_multiline_inputbox.y + MMI_multiline_inputbox.height)
            {
                y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height -1;
            }

            if((y1 <= point.y)&&(y2 >= point.y))
            {
                x1 = item_p->header_area_button[i].x - item_p->header_area_button[i].w_pen_gap;
                x2 = item_p->header_area_button[i].x + item_p->header_area_button[i].w + item_p->header_area_button[i].w_pen_gap;
                if((x1 <= point.x )&&(x2 >= point.x))
                {
                    return  i;
                }

            }
        }  
    }         
    return LIST_ITEM_HEADER_BUTTTON_MAX;    
}

MMI_BOOL wgui_BTcat145_list_item_data_header_area_PenDownHdlr(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_HEADER_BUTTTON_MAX;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    item_p = (show_btnoti_category145screen_item*)item;

    if(!item_p)
    {
        return;
    }              
    button_index = wgui_BTcat145_list_item_data_header_area_check_pen_point(point,item_p);
    
    if(button_index != LIST_ITEM_HEADER_BUTTTON_MAX)
    {
        item_p->header_area_highlight_button = button_index;               
        wgui_BTcat145_list_item_data_header_area_show_button_in_short_mode(button_index,0,1,item_p);
        return MMI_TRUE;

    }
    return MMI_FALSE;
}


MMI_BOOL wgui_BTcat145_list_item_data_header_area_PenUpHdlr(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_HEADER_BUTTTON_MAX;
    void (*handler) (void);
    U8 i = 0;
    U16 header_height;
    U16 footer_height;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    item_p = (show_btnoti_category145screen_item*)item;

    if(!item_p)
    {
        return;
    }               
    button_index = wgui_BTcat145_list_item_data_header_area_check_pen_point(point,item_p);
    
    if(button_index != LIST_ITEM_HEADER_BUTTTON_MAX)
    {
        wgui_BTcat145_list_item_data_header_area_show_button_in_short_mode(LIST_ITEM_HEADER_BUTTTON_MAX,1,1,item_p);//just show up with all buttons  
        if(disable_button_flag == MMI_FALSE)
        {
            if((item_p->header_area_highlight_button == button_index)
                &&(BT145_list_item_head_area_highlight_button != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX))
            {
               handler = item_p->header_area_button_handler[button_index] ;
               if(handler)
               {
                 handler(); 
               }
               if(wgui_BTcat145_list_item_header_area_check_need_change_mode(button_index))
               {
                    item_p->flags = MMI_BT145_LIST_ITEM_STSTUS_DETAIL_MODE;
                    bt145_list_item_head_area_button[item_p->index].h = item_p->editor_height;  
                    wgui_BTcat145_list_item_get_header_and_footer_height(&header_height, &footer_height);
                    MMI_multiline_inputbox.header_height = header_height;
                    
               }     
            }  
        }
        item_p->header_area_highlight_button =  LIST_ITEM_HEADER_BUTTTON_MAX;  
        
        if((wgui_BTcat145_list_item_header_area_check_need_change_mode(button_index))&&(BT145_list_item_head_area_highlight_button != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX))
        {   gdi_layer_lock_frame_buffer();
            gui_show_multi_line_input_box(&MMI_multiline_inputbox);
            gdi_layer_unlock_frame_buffer();
            gdi_layer_blt_previous(0, 0, UI_device_width - 1, UI_device_height - 1); 
        }    
        return MMI_TRUE;

    }
    item_p->header_area_highlight_button =  LIST_ITEM_HEADER_BUTTTON_MAX; 
    return MMI_FALSE;
}

MMI_BOOL wgui_BTcat145_list_item_data_header_area_PenMoveHdlr(mmi_pen_point_struct point,void *item)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_HEADER_BUTTTON_MAX;
    U8 i = 0;
    U8 need_redraw_button_all = 0;
    U8 need_draw_button = LIST_ITEM_HEADER_BUTTTON_MAX;
    MMI_BOOL result = MMI_FALSE;
    show_btnoti_category145screen_item *item_p = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    item_p = (show_btnoti_category145screen_item*)item;

    if(!item_p)
    {
        return;
    }              
    button_index = wgui_BTcat145_list_item_data_header_area_check_pen_point(point,item_p);
    
    if(button_index != LIST_ITEM_HEADER_BUTTTON_MAX)
    {
        if(item_p->header_area_highlight_button != button_index)
        {// down and move in not one same button
            item_p->header_area_highlight_button = LIST_ITEM_HEADER_BUTTTON_MAX;
            //need_redraw_button_all = 1;            
        }
        else
        {
           need_draw_button = button_index; 
        }
        need_redraw_button_all = 1;
        result = MMI_TRUE;
    }
    else 
    {   // down on button and move out on button
        //if(ctrl_area_highlight_button != BUTTTON_MAX) 
        {
            need_redraw_button_all = 1;
        }
        item_p->header_area_highlight_button = LIST_ITEM_HEADER_BUTTTON_MAX;
        result = MMI_FALSE;

    }
    if(need_redraw_button_all)
    {        
       wgui_BTcat145_list_item_data_header_area_show_button_in_short_mode(need_draw_button,1,1,item_p);
    }
    
    return result;
}


BOOL wgui_BTcat145_list_item_data_translate_pen_event(
        void *item,
        mmi_pen_event_type_enum pen_event,
        mmi_pen_point_struct point
        )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 flags = 0;
    show_btnoti_category145screen_item *item_p = NULL;
    BOOL result = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   item_p = (show_btnoti_category145screen_item*)item;
    if(!item_p)
    {
        return;
    }

    if(MMI_PEN_EVENT_DOWN == pen_event)
    {
        if(item_p)
        {   if(item_p->flags == MMI_BT145_LIST_ITEM_STSTUS_DETAIL_MODE)
            {
                result = wgui_BTcat145_list_item_data_footer_area_PenDownHdlr(point,item_p);
            }
            else
            {
                result = wgui_BTcat145_list_item_data_header_area_PenDownHdlr(point,item_p);
            }
         }   
    }
        
        

    if(MMI_PEN_EVENT_MOVE== pen_event)
    {
        if(item_p)
        {    
            if(item_p->flags == MMI_BT145_LIST_ITEM_STSTUS_DETAIL_MODE)
            {
                result = wgui_BTcat145_list_item_data_footer_area_PenMoveHdlr(point,item_p);
            }    
            else
            {
                result = wgui_BTcat145_list_item_data_header_area_PenMoveHdlr(point,item_p);
            }
        }     
    }

    if(MMI_PEN_EVENT_UP == pen_event)
    {
        if(item_p)
        {    
            if(item_p->flags == MMI_BT145_LIST_ITEM_STSTUS_DETAIL_MODE)
            {
                result = wgui_BTcat145_list_item_data_footer_area_PenUpHdlr(point,item_p);
            }
            else
            {
                result = wgui_BTcat145_list_item_data_header_area_PenUpHdlr(point,item_p);
            }
        }     
    }
    return result;




}


static void wgui_BTcat145_list_item_head_area_ini(U8 type, UI_string_type left_label, UI_string_type right_label)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    S32 button_y = 0;
    S32 button_x = 0;
    S32 button_w = 0;
    S32 button_h = 0;
    S32 yoffset = MMI_title_y + MMI_title_height;
    U8  button_index = 0;
    S32  button_ww = 0;
    U8 i = 0;
    U8 j = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(bt145_list_item_head_area_button,0,sizeof(bt145_list_item_head_area_button));

    //update button count
    if(bt145_list_item_button_count > LIST_ITEM_BUTTTON_MAX)
    {
        bt145_list_item_button_count = 0;
    }

    //get row count
    bt145_list_item_all_row =  bt145_list_item_button_count/BT145_LIST_ITEM_HEAD_ONE_LINE_MIX_BUTTON;
    
    if((bt145_list_item_button_count%BT145_LIST_ITEM_HEAD_ONE_LINE_MIX_BUTTON)&&bt145_list_item_button_count) 
    {
        bt145_list_item_all_row =  bt145_list_item_all_row +1; 
    }

    for(i = 0; i < bt145_list_item_all_row; i++)
    {// update all button start y
    
        button_y = yoffset + BT145_LIST_ITEM_HEAD_H_LINE_PIX + (i*(BT145_LIST_ITEM_FOOTER_BX_H + BT145_LIST_ITEM_HEAD_H_LINE_PIX));
        button_x = 0;

        if(button_index > (bt145_list_item_button_count - 1))
        {
            break;
        }
        
        for(j = 0; j < BT145_LIST_ITEM_HEAD_ONE_LINE_MIX_BUTTON; j++)
        {
            button_index = j+(i*BT145_LIST_ITEM_HEAD_ONE_LINE_MIX_BUTTON);

            if(button_index > (bt145_list_item_button_count - 1))
            {
                break;
            }
            
            bt145_list_item_head_area_button[button_index].y = button_y ;

            if((j%BT145_LIST_ITEM_HEAD_ONE_LINE_MIX_BUTTON)== 1)
            {
                button_w = BT145_LIST_ITEM_FOOTER_BX_W ;
            }
            else
            {
                button_w = BT145_LIST_ITEM_FOOTER_BX_W ;
            }
            button_w = LCD_WIDTH;

            {
                button_x = 0;
            }
            BT145_list_item_data_item[button_index].flags = MMI_BT145_LIST_ITEM_STSTUS_SHORT_MODE;
            wgui_BTcat145_list_item_data_measure(&BT145_list_item_data_item[button_index],NULL,&button_ww,&button_h);        
            bt145_list_item_head_area_button[button_index].x = button_x;
            bt145_list_item_head_area_button[button_index].w = button_w;
            bt145_list_item_head_area_button[button_index].h = button_h;
            bt145_list_item_head_area_button[button_index].w_pen_gap = 0;
            bt145_list_item_head_area_button[button_index].h_pen_gap = 0;  
                
            BT145_list_item_data_item[button_index].index = button_index;
        }          

    
    }
    
    BT145_list_item_head_area_highlight_button = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
    
} 

static U8 wgui_BTcat145_list_item_head_area_check_pen_point(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/        
    U8 i = 0;
    S16 button_x1,button_x2,editor_y1,editor_y2;
    S16 button_y1 = 0,button_y2 = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    editor_y1 = MMI_multiline_inputbox.y - bt145_list_item_head_area_button[i].h_pen_gap;
    editor_y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height + bt145_list_item_head_area_button[i].h_pen_gap;

    if(editor_y2 > MMI_multiline_inputbox.y + MMI_multiline_inputbox.height)
    {
        editor_y2 = MMI_multiline_inputbox.y + MMI_multiline_inputbox.height -1;
    }
    if((editor_y1 <= point.y)&&(editor_y2 >= point.y))
    {
        for(i = 0; i < bt145_list_item_button_count ; i++)
        {   
            if(!bt145_list_item_head_area_button[i].h)
            {   
                break;
            }
            button_x1 = bt145_list_item_head_area_button[i].x - bt145_list_item_head_area_button[i].w_pen_gap;
            button_x2 = bt145_list_item_head_area_button[i].x + bt145_list_item_head_area_button[i].w + bt145_list_item_head_area_button[i].w_pen_gap;
            
            button_y1 = bt145_list_item_head_area_button[i].y - bt145_list_item_head_area_button[i].h_pen_gap;
            button_y2 = bt145_list_item_head_area_button[i].y + bt145_list_item_head_area_button[i].h + bt145_list_item_head_area_button[i].h_pen_gap;
                        

            if((button_x1 <= point.x )&&(button_x2 >= point.x))
            {
                if((button_y1 <= point.y )&&(button_y2 >= point.y))
                {                    
                    return  i;
                }    
            }
        }  
    }
    return LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
             
    
}


MMI_BOOL wgui_BTcat145_list_item_head_area_PenDownHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
    BOOL result = MMI_FALSE ;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_list_item_head_area_check_pen_point(point);
    if(button_index != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX)
    {
        BT145_list_item_head_area_highlight_button = button_index;    


        result = wgui_BTcat145_list_item_data_translate_pen_event(&BT145_list_item_data_item[button_index],                                                                  
                                                                  MMI_PEN_EVENT_DOWN,
                                                                  point);
        //wgui_BTcat145_list_item_head_area_show_button(button_index,0,1);//just show down status button        
        return result;

    }
    return MMI_FALSE;
}

MMI_BOOL wgui_BTcat145_list_item_head_area_PenUpHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
    wgui_BT145_list_item_head_button_handler handler;
    U8 i = 0;
    BOOL result = MMI_FALSE ;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_list_item_head_area_check_pen_point(point);
    if(button_index != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX)
    {
                    
        result = wgui_BTcat145_list_item_data_translate_pen_event(&BT145_list_item_data_item[button_index],                                                                  
                                                                  MMI_PEN_EVENT_UP,
                                                                  point);

        BT145_list_item_head_area_highlight_button =  LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;    
        return MMI_TRUE;

    }
    BT145_list_item_head_area_highlight_button =  LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX; 
    return MMI_FALSE;
}

MMI_BOOL wgui_BTcat145_list_item_head_area_PenMoveHdlr(mmi_pen_point_struct point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 button_index = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
    U8 i = 0;
    U8 need_redraw_button_all = 0;
    U8 need_draw_button = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
    MMI_BOOL result = MMI_FALSE;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    button_index = wgui_BTcat145_list_item_head_area_check_pen_point(point);
    if(button_index != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX)
    {
        if(BT145_list_item_head_area_highlight_button != button_index)
        {// down and move in not one same button
            BT145_list_item_head_area_highlight_button = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
            //need_redraw_button_all = 1;       

            result = wgui_BTcat145_list_item_data_translate_pen_event(
                              &BT145_list_item_data_item[BT145_list_item_head_area_highlight_button],                                  
                                  MMI_PEN_EVENT_MOVE,
                                  point);
            result = wgui_BTcat145_list_item_data_translate_pen_event(&BT145_list_item_data_item[button_index],
                                                                      MMI_PEN_EVENT_MOVE,
                                                                      point);            
        }
        else
        {
           need_draw_button = button_index; 
           result = wgui_BTcat145_list_item_data_translate_pen_event(&BT145_list_item_data_item[button_index],
                                                                      MMI_PEN_EVENT_MOVE,
                                                                      point); 
        }
        need_redraw_button_all = 1;
        result = MMI_TRUE;
    }
    else 
    {   // down on button and move out on button
        //if(ctrl_area_highlight_button != BUTTTON_MAX) 
        {
            need_redraw_button_all = 1;
        }
        BT145_list_item_head_area_highlight_button = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
        result = MMI_FALSE;

    }
    if(need_redraw_button_all)
    {  
       // wgui_BTcat145_list_item_head_area_show_button(need_draw_button,1,1);// show up and down
    }
    
    return result;
}



static void wgui_BTcat145_list_item_draw_head(MMI_BOOL is_draw, S32 yoffset, S32 height, S32 clip_x1, S32 clip_y1, S32 clip_x2, S32 clip_y2)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    color line_color = {30, 30, 30, 100}; 
    U8 i = 0;
    U8 j = 0;
    U16 line_x = 0;
    U16 line_y1 = MMI_title_y + MMI_title_height;
    U16 line_y2 = LCD_HEIGHT-1;
    S32 button_y = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bt145_list_item_head_area_start_y = 0 ; 
    if (is_draw == MMI_FALSE)
    {
        return;
    }
    gdi_layer_lock_frame_buffer();
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, clip_y1, LCD_WIDTH-1, clip_y2);    

    
    bt145_list_item_head_area_start_y = yoffset ;
    yoffset = yoffset + BT145_LIST_ITEM_HEAD_GAP;
    bt145_list_item_head_area_button[0].y = yoffset + BT145_LIST_ITEM_HEAD_H_LINE_PIX  ;
    
    for(i = 1; i < bt145_list_item_all_row; i++)
    {// update all button start y    

        button_y =  BT145_LIST_ITEM_HEAD_H_LINE_PIX 
                   + bt145_list_item_head_area_button[i-1].h + bt145_list_item_head_area_button[i-1].y;

        bt145_list_item_head_area_button[i].y = button_y ;

    }
    
    wgui_BTcat145_list_item_head_area_show_button(LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX, 1,0);// can't show highlight button

    gdi_layer_pop_clip();
    gdi_layer_unlock_frame_buffer();

}


#ifdef __MMI_EDITOR_SSP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_list_item_pen_down_hdlr
 * DESCRIPTION
 *  check pen down event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen down button ,MMI_FALSE:not pen down button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_list_item_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   /*if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenDownHdlr(pos);
      return MMI_TRUE; 
   }    
   else */ 
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_DOWN);

       //if((pos.y > bt145_list_item_head_area_start_y)&&(bt145_list_item_head_area_start_y))
       {
          wgui_BTcat145_list_item_head_area_PenDownHdlr(pos);
       }           
       return MMI_TRUE;
   }
   return  MMI_FALSE;
    
}
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_list_item_pen_up_hdlr
 * DESCRIPTION
 *  check pen up event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen up button ,MMI_FALSE:not pen up button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_list_item_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret ;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

   
   /*if((pos.y > bt145_footer_area_start_y)&&(bt145_footer_area_start_y))// in footer area
   {
      wgui_BTcat145_footer_area_PenUpHdlr(pos);
      return MMI_TRUE; 
    }    
    else */
    if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
    {
        ret =  gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_UP);
        //if((pos.y > bt145_list_input_head_area_start_y)&&(bt145_list_input_head_area_start_y)&&(!ret))
        if(!ret)
        {
            wgui_BTcat145_list_item_head_area_PenUpHdlr(pos);
            return MMI_TRUE; 
        }  
        return ret;  
    }
    return  MMI_FALSE;    
}
/*****************************************************************************
 * FUNCTION
 *  category_BTcat145_list_item_pen_move_hdlr
 * DESCRIPTION
 *  check pen move event in cat145 ctrol area 
 * PARAMETERS
 *  point    [IN]   pen event point
 * RETURNS
 *  MMI_TRUE: pen move button ,MMI_FALSE:not pen move button 
 *****************************************************************************/
MMI_BOOL category_BTcat145_list_item_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret ;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   if(PEN_CHECK_BOUND(pos.x,pos.y, MMI_multiline_inputbox.x, 
                                   MMI_multiline_inputbox.y, 
                                   MMI_multiline_inputbox.width, 
                                   MMI_multiline_inputbox.height))
   {
       ret = gui_input_box_ssp_pen_translate(pos,MMI_PEN_EVENT_MOVE);
       //if((pos.y > bt145_list_input_head_area_start_y)&&(bt145_list_input_head_area_start_y)&&(!ret))// in head area
       if(!ret)
       {
          wgui_BTcat145_list_item_head_area_PenMoveHdlr(pos);
          return MMI_TRUE;
       }
       //else if((bt145_list_input_head_area_start_y)&&(BT145_list_input_head_area_highlight_button != LIST_INPUT_HEAD_BUTTTON_ERROR_INDEX))
       else if(BT145_list_item_head_area_highlight_button != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX)
       {// head area can be see,move to other button ,should redraw button
            wgui_BTcat145_list_item_head_area_show_button(LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX,1,1);
            BT145_list_item_head_area_highlight_button = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
       }
       return ret;
   }
   if(BT145_list_item_head_area_highlight_button != LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX)
   {// mvoe out editor,should redraw button
        wgui_BTcat145_list_item_head_area_show_button(LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX,1,1);
        BT145_list_item_head_area_highlight_button = LIST_ITEM_HEAD_BUTTTON_ERROR_INDEX;
   }
   
   return  MMI_FALSE;
}


#endif /*__MMI_EDITOR_SSP_SUPPORT__*/



/*****************************************************************************
 * FUNCTION
 *  DrawBTCate145CategoryControlArea_WEARABLE_DEVICE_list_input
 * DESCRIPTION
 *  control area callback for category145
 * PARAMETERS
 *  coordinate    [IN]   control area coordinate
 * RETURNS
 *  void
 *****************************************************************************/
void DrawBTCate145CategoryControlArea_WEARABLE_DEVICE_list_item(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 y = 0;//MMI_title_y + MMI_title_height ;
    color text_color = {245, 245, 245, 100};
    color bg_color = {0, 0, 0, 100};
    U8 number_len = 0;
  //  UI_filled_area f;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_push_clip();
    gdi_layer_set_clip(0, 0 , LCD_WIDTH-1, LCD_HEIGHT-1);

   // gdi_draw_solid_rect(0, MMI_title_height + MMI_title_y, LCD_WIDTH-1, LCD_HEIGHT-1 , gdi_act_color_from_rgb(bg_color.alpha, bg_color.r, bg_color.g, bg_color.b));
    
    gui_set_font(&MMI_default_font);
    //gui_move_multi_line_input_box(&MMI_multiline_inputbox, G_145_SMALL_SPACE, y); 
    gui_move_multi_line_input_box(&MMI_multiline_inputbox, 0, y);
    
    {
        resize_multiline_inputbox(LCD_WIDTH, LCD_HEIGHT); 
    }

    //MMI_multiline_inputbox.text_x = BT145_HEAD_LEFT_MARGIN;
    MMI_multiline_inputbox.margin.top_margin = 0;
    MMI_multiline_inputbox.text_y = 0;
   // f = *b->normal_filler;
  //  f.flags &= ~(UI_FILLED_AREA_BORDER); // no border
    MMI_multiline_inputbox.ext_flags |= (GUI_MULTI_LINE_INPUT_BOX_SET_BG_COLOR|GUI_MULTI_LINE_INPUT_BOX_NONE_BORDER); // bg black
    
    MMI_multiline_inputbox.default_bg_color = bg_color;
    MMI_multiline_inputbox.normal_text_color = text_color;
        
    gui_show_multi_line_input_box(&MMI_multiline_inputbox);
    gdi_layer_pop_clip();
}

/*****************************************************************************
 * FUNCTION
 *  ShowBTNotiCategory145Screen_list_input_WEARABLE_DEVICE
 * DESCRIPTION
 *  by pen selec input characert
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  history_buffer          [IN]        History buffer
 *  time                    [IN]        time string
 *  item cout               [IN]        content item count
 * RETURNS
 *  void
 *****************************************************************************/
void ShowBTNotiCategory145Screen_list_item_WEARABLE_DEVICE(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message_icon,
        U8 *message_title,
        U8 *message,
        U32 flags,
        U8 *history_buffer,
        U8 *time,
        U16 item_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32  width, height, content_width;
    U16 header_height;
    U16 footer_height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    MMI_title_string = (UI_string_type) title;


    content_width = UI_device_width;
    create_multiline_inputbox_set_buffer((UI_string_type) &sample_item_text_buff, 2, 2, 0);
    resize_multiline_inputbox(content_width, MMI_content_height);
    show_multiline_inputbox_no_draw();
    BT145_list_item_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
       // | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
    BT145_list_item_inputbox.normal_text_color = gui_color(0, 0, 0);

    BT145_list_item_inputbox.text_font = &MMI_default_font ;
    BT145_list_item_inputbox.text =  (UI_buffer_type)&sample_item_text_buff;

   // for null point error
    BT145_list_item_inputbox.visible_line_info = &g_visible_multiline_line_info;
    BT145_list_item_inputbox.line_info = &g_multiline_line_info;
    gui_set_multi_line_input_box_current_theme(&BT145_list_item_inputbox);

#if 1

    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
       // | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR;
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);

    MMI_multiline_inputbox.text_font = &MMI_default_font ;
    MMI_multiline_inputbox.text =  (UI_buffer_type)&sample_item_text_buff;


#endif
    
    gui_set_font(&MMI_default_font);

#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__
    MMI_title_icon = (PU8) get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/


    /* 
    {
        register_keyboard_key_handler(cat145_bt_keyboard_key_handler);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_previous_line, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_btnoti_next_line, KEY_VOL_DOWN, KEY_EVENT_DOWN);
    }
    */
    bt145_list_item_button_count = item_count;
 //   bt145_list_item_app_list = list_item;

    {
        wgui_BTcat145_list_item_head_area_ini(1,get_string(left_softkey),get_string(right_softkey));
    }    
    
    wgui_BTcat145_list_item_get_header_and_footer_height(&header_height, &footer_height);


    MMI_multiline_inputbox.text =  (UI_buffer_type)&sample_item_text_buff;
    MMI_multiline_inputbox.header_callback = wgui_BTcat145_list_item_draw_head;
    MMI_multiline_inputbox.footer_callback = NULL;
    MMI_multiline_inputbox.header_height = header_height;
    MMI_multiline_inputbox.footer_height= 0;
    
#ifdef __MMI_EDITOR_SSP_SUPPORT__
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_list_item_pen_down_hdlr, MMI_PEN_EVENT_DOWN);
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_list_item_pen_up_hdlr, MMI_PEN_EVENT_UP);
        wgui_register_category_screen_control_area_pen_handlers(category_BTcat145_list_item_pen_move_hdlr, MMI_PEN_EVENT_MOVE);
#endif /*__MMI_EDITOR_SSP_SUPPORT__*/



    ExitCategoryFunction = ExitCategory145Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawBTCate145CategoryControlArea_WEARABLE_DEVICE_list_item);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY145_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_data.s32flags |= DM_NO_STATUS_BAR |DM_NO_SOFTKEY; // no title ,no status bar   
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}

#endif /*__BT145_SUPPORT_LIST_BUTTONS_WITH_MULTILINE_EDITOR__*/

/*****************************************************************************
 * FUNCTION
 *  ShowCategory145Screen
 * DESCRIPTION
 *  Displays the Delivery report screen
 * PARAMETERS
 *  title                   [IN]        Title for the screen
 *  title_icon              [IN]        Icon displayed with the title
 *  left_softkey            [IN]        Left softkey label
 *  left_softkey_icon       [IN]        Left softkey icon
 *  right_softkey           [IN]        Right softkey label
 *  right_softkey_icon      [IN]        Right softkey icon
 *  message_icon            [IN]        Icon displayed with the message
 *  message_title           [IN]        Colored text that appears above the message
 *  message                 [IN]        Message
 *  flags                   [IN]        Flags
 *  history_buffer          [IN]        History buffer
 * RETURNS
 *  void
 *****************************************************************************/
void ShowCategory145Screen(
        U8 *title,
        U16 title_icon,
        U16 left_softkey,
        U16 left_softkey_icon,
        U16 right_softkey,
        U16 right_softkey_icon,
        U16 message_icon,
        U8 *message_title,
        U8 *message,
        U32 flags,
        U8 *history_buffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    dm_data_struct dm_data;
    S32 l, width, height, content_width;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_lock_frame_buffer();

    wgui_title_set_menu_shortcut_number(-1);
    wgui_title_disable_menu_shortcut_display(MMI_TRUE);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    change_left_softkey(left_softkey, left_softkey_icon);
    change_right_softkey(right_softkey, right_softkey_icon);
    SetupCategoryKeyHandlers();

    cat145_scrollbar_flag = 0;
    gui_create_vertical_scrollbar(
        &cat145_vbar,
        UI_device_width - current_MMI_theme->scrollbar_size,
        (MMI_title_y + MMI_title_height),
        current_MMI_theme->scrollbar_size,
        (UI_device_height - (MMI_title_y + MMI_title_height) - MMI_button_bar_height));
    content_width = UI_device_width;
    l = gui_strlen((UI_string_type) message);
    create_multiline_inputbox_set_buffer((UI_string_type) message, l, l, 0);
    resize_multiline_inputbox(content_width, MMI_content_height);
    show_multiline_inputbox_no_draw();
    resize_multiline_inputbox(MMI_multiline_inputbox.width, MMI_multiline_inputbox.text_height + 6);
    cat145_h3 = MMI_multiline_inputbox.height;
    MMI_multiline_inputbox.flags |= UI_MULTI_LINE_INPUT_BOX_DISABLE_CURSOR_DRAW
        | UI_MULTI_LINE_INPUT_BOX_VIEW_MODE
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_BACKGROUND
        | UI_MULTI_LINE_INPUT_BOX_DISABLE_SCROLLBAR
        | UI_MULTI_LINE_INPUT_BOX_USE_PRESET_CLIPPING | UI_MULTI_LINE_INPUT_BOX_CENTER_JUSTIFY;
    MMI_multiline_inputbox.normal_text_color = gui_color(0, 0, 0);

#ifdef GUI_INPUT_BOX_CACHE_SUPPORT
    gui_mlc_all_line_update();
#endif /* GUI_INPUT_BOX_CACHE_SUPPORT */

    MMI_message_string = (UI_string_type) message_title;
    gui_set_font(&MMI_default_font);
    gui_measure_string(MMI_message_string, &width, &height);
    cat145_h2 = height;
    cat145_message_title_x = (content_width >> 1) - (width >> 1);
    MMI_title_string = (UI_string_type) title;
#ifndef __MMI_TITLE_BAR_NO_ICON_SHCT__	
    MMI_title_icon = (PU8) get_image(title_icon);
#endif/*__MMI_TITLE_BAR_NO_ICON_SHCT__*/
    MMI_message_icon = (PU8) get_image(message_icon);
    gui_measure_image(MMI_message_icon, &width, &height);
    cat145_h1 = height + 4;
    cat145_image_x = (content_width >> 1) - (width >> 1);

    cat145_flags = flags;
    cat145_y = 0;
    cat145_clip_x1 = 0;
    cat145_clip_x2 = content_width;
    cat145_clip_y1 = (MMI_title_y + MMI_title_height);
    cat145_clip_y2 = UI_device_height - MMI_button_bar_height - 1;
    cat145_total_height = (cat145_h1 + cat145_h2 + cat145_h3);
    cat145_available_height = cat145_clip_y2 - cat145_clip_y1 + 1;
    if (cat145_total_height > cat145_available_height)
    {
        resize_multiline_inputbox(MMI_multiline_inputbox.width - current_MMI_theme->scrollbar_size, MMI_multiline_inputbox.height);
        cat145_message_title_x -= (current_MMI_theme->scrollbar_size>>1);
        cat145_image_x -= (current_MMI_theme->scrollbar_size>>1);

        cat145_scrollbar_flag = 1;
        cat145_clip_x2 = cat145_clip_x2 - current_MMI_theme->scrollbar_size;
        register_keyboard_key_handler(cat145_keyboard_key_handler);
        SetKeyHandler(cat145_previous_line, KEY_UP_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_next_line, KEY_DOWN_ARROW, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_previous_line, KEY_VOL_UP, KEY_EVENT_DOWN);
        SetKeyHandler(cat145_next_line, KEY_VOL_DOWN, KEY_EVENT_DOWN);
        gui_set_vertical_scrollbar_range(&cat145_vbar, cat145_total_height);
        gui_set_vertical_scrollbar_scale(&cat145_vbar, cat145_available_height);
        gui_set_vertical_scrollbar_value(&cat145_vbar, -cat145_y);
    }
    else
    {
        cat145_y = (cat145_available_height >> 1) - (cat145_total_height >> 1);
    }

    gdi_layer_unlock_frame_buffer();

    ExitCategoryFunction = ExitCategory145Screen;
    dm_setup_category_functions(dm_redraw_category_screen, dummy_get_history, dummy_get_history_size);
    dm_register_category_controlled_callback(DrawCate145CategoryControlArea);
    dm_data.s32ScrId = (S32) GetActiveScreenId();
    dm_data.s32CatId = MMI_CATEGORY145_ID;
    dm_data.s32flags = DM_CLEAR_SCREEN_BACKGROUND_COLOR;
    dm_setup_data(&dm_data);
    dm_redraw_category_screen();
}


/*****************************************************************************
 * FUNCTION
 *  ExitCategory145Screen
 * DESCRIPTION
 *  Exits the Delivery report screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExitCategory145Screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_BT_DIALER_SUPPORT__
    g_145_is_need_show_number = MMI_FALSE;
    g_145_show_number_buffer = NULL;
    g_145_show_image_is_path = MMI_FALSE;
    g_145_show_image_path = NULL;

	g_145_show_image_is_data = MMI_FALSE;
	g_145_show_image_data = NULL;
    g_145_show_image_data_type = NULL;
    g_145_show_image_data_size = NULL;

#endif


#ifdef __BT145_FOOTER_SUPPORT_BUTTONS_AND_PAGE__


    bt145_footer_area_buttons = FOOTER_BUTTTON_ERROR_COUNT;

    bt145_page_mode_data.is_page_mode = MMI_FALSE;
    bt145_page_mode_data.current_page_index = BT145_ERROR_PAGE;
    bt145_page_mode_data.page_count = BT145_ERROR_PAGE;
     bt145_page_mode_data.mode_type = MMI_BT145_PAGE_MODE_ERROR;    

#endif
#if (defined( __MMI_WEARABLE_DEVICE__)&&(defined(__MMI_TOUCH_SCREEN__)))
    disable_button_flag = MMI_FALSE;
    no_show_button_flag = MMI_FALSE;

#endif

    cat145_scrollbar_flag = 0;
    reset_softkeys();
    reset_multiline_inputbox();
    ExitCategoryFunction = MMI_dummy_function;
    RedrawCategoryFunction = MMI_dummy_function;
    GetCategoryHistory = dummy_get_history;
    GetCategoryHistorySize = dummy_get_history_size;
}



