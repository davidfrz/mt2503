/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *    usb.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *    This file intends for usb1.1 definitions.
 *
 * Author:
 * -------
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef USB_H
#define USB_H


#include "usb_custom.h"
#include "usb_custom_def.h"
//#include "usb_drv.h"
#include "dcl.h"
#include "usb_comm.h"
#include "kal_general_types.h"


/* Remove dependence.
 * It should be releated to MMI behavior. Thus, add it on makefile if request is incoming. 
 */
//#ifdef  __TC01__
//#define  __USB_BOOT_NOT_CHECK_NVRAM_SETTING__
//#endif

/***********************************************
	standard command definition
************************************************/

/* Standard Request Codes */
#define USB_GET_STATUS			0x00
#define USB_CLEAR_FEATURE		0x01
#define USB_SET_FEATURE			0x03
#define USB_SET_ADDRESS			0x05
#define USB_GET_DESCRIPTOR		0x06
#define USB_SET_DESCRIPTOR		0x07
#define USB_GET_CONFIGURATION	0x08
#define USB_SET_CONFIGURATION	0x09
#define USB_GET_INTERFACE		0x0A
#define USB_SET_INTERFACE		0x0B
#define USB_SYNCH_FRAME			0x0C

/* Vendor Request Codes */
#define USB_GET_MS_DESCRIPTOR		0xCC

/* Command bit fields */
#define USB_CMD_DATADIR			0x80

/* Request Type Field */
#define USB_CMD_TYPEMASK		0x60
#define USB_CMD_STDREQ			0x00
#define USB_CMD_CLASSREQ		0x20
#define USB_CMD_VENDREQ			0x40
#define USB_CMD_STDDEVIN		0x80
#define USB_CMD_STDDEVOUT		0x00
#define USB_CMD_STDIFIN			0x81
#define USB_CMD_STDIFOUT		0x01
#define USB_CMD_STDEPIN			0x82
#define USB_CMD_STDEPOUT		0x02
#define USB_CMD_CLASSIFIN		0xA1
#define USB_CMD_CLASSIFOUT		0x21
#define USB_CMD_VENDDEVIN		0xC0
#define USB_CMD_VENDDEVOUT	0x40


/* Standard command descriptor type*/
#define USB_DEVICE				0x01
#define USB_CONFIG				0x02
#define USB_STRING				0x03
#define USB_INTERFACE			0x04
#define USB_ENDPOINT			0x05
#define USB_DEVICE_QUALIFIER 		0x06
#define USB_OTHER_SPEED			0x07
#define USB_INTERFACE_POWER		0x08
#define USB_OTG_DESC			0x09
#define USB_INTERFACE_ASSOCIATION		0x0B

#define USB_CMD_DESCMASK		0xFF00
#define USB_CMD_DEVICE			(USB_DEVICE<<8)
#define USB_CMD_CONFIG			(USB_CONFIG<<8)
#define USB_CMD_STRING			(USB_STRING<<8)
#define USB_CMD_INTERFACE		(USB_INTERFACE<<8)
#define USB_CMD_ENDPOINT		(USB_ENDPOINT<<8)
#define USB_CMD_DEVICE_QUALIFIER		(USB_DEVICE_QUALIFIER<<8)
#define USB_CMD_OTHER_SPEED			(USB_OTHER_SPEED<<8)
#define USB_CMD_INTERFACE_POWER		(USB_INTERFACE_POWER<<8)

/* Standard Device Feature Selectors */
#define USB_FTR_DEVREMWAKE			0x0001
#define USB_FTR_EPHALT				0x0000
#define USB_FTR_B_HNP_ENB			0x0003
#define USB_FTR_A_HNP_SUPPORT		0x0004
#define USB_FTR_A_ALT_HNP_SUPPORT	0x0005
#define USB_FTR_TEST_MODE				0x0002

/* Vendor OS feature descriptor, feature index */
#define USB_FTR_GENRE					0x0001
#define USB_FTR_EXT_COMPAT_ID			0x0004
#define USB_FTR_EXT_PROPERTIES		0x0005


/* USB test mode */
#define USB_TEST_J						0x01
#define USB_TEST_K						0x02
#define USB_TEST_SE0_NAK				0x03
#define USB_TEST_PACKET				0x04

/***********************************************
	standard descriptor definition
************************************************/
/* Scriptor length */
#define USB_DEVDSC_LENGTH			18
#define USB_CFGDSC_LENGTH			9
#define USB_IFDSC_LENGTH			9
#define USB_MAX_IFDSC_LENGTH		258	/* this will change depend on different class interface */
						/*descriptor requirment*/
						/* 258 is for video streaming class interface */	
#define USB_EPDSC_LENGTH			7
#define USB_OTGDSC_LENGTH			3
#define USB_MAX_CLASS_EPDESC_LENGTH	12	/* this will change depend on different class interface */
						/*descriptor requirment*/
						/* 12 is for video control interrupt ep */	
#define USB_IAD_LENGTH				8
#define USB_DEV_QUA_DSC_LENGTH		10
#define USB_OTHER_CFGDSC_LENGTH			9
#define USB_MAX_OS_STRING_LENGTH			18
#define USB_MAX_OS_FEATURE_DESC_LENGTH		40


/* Endpoint direction */
#define USB_EP_DIR				0x80
#define USB_EP_DIR_IN			0x80
#define USB_EP_DIR_OUT			0x00

/* Endpoint transfer types */
#define USB_EP_TFMASK			0x03
#define USB_EP_CONTROL			0x00
#define USB_EP_ISO				0x01
#define USB_EP_BULK				0x02
#define USB_EP_INTR				0x03

/* ISO Synchronization types */
#define USB_ISO_NO_SYNCHRONIZATION		0x00
#define USB_ISO_ASYNCHRONOUS				0x01
#define USB_ISO_ADAPTIVE					0x02
#define USB_ISO_SYNCHRONOUS				0x03

/* ISO Usage types */
#define USB_ISO_DATA						0x00
#define USB_ISO_FEEDBACK					0x01
#define USB_ISO_IMPLICIT_FEEDBACK			0x02

/*****Descriptor Element*****/
/* Define values for Standard Device Descriptor */
/* For Device descriptor */

/* bcdDevice value */
#define USB_DEVDSC_BCDDEVICE_PHONE			0x0100   /* Release number of USB device */
#define USB_DEVDSC_BCDDEVICE_MODEM_CARD			0x0200   /* Release number of USB modem card device for ECMT */
#define USB_DEVDSC_BCDDEVICE_MODEM_CARD_FOR_NDIS	0x0300   /* Release number of USB modem card device for NDIS*/

/* Device class code for composite device */
#define USB_COMPOSITE_DEVICE_CODE				0xEF
#define USB_COMPOSITE_SUBCLASS_CODE				0x02
#define USB_COMPOSITE_PROTOCOL_CODE				0x01

/* Device class code for without IAD composite device */
#define USB_COMPOSITE_NO_IAD_DEVICE_CODE				0x00
#define USB_COMPOSITE_NO_IAD_SUBCLASS_CODE				0x00
#define USB_COMPOSITE_NO_IAD_PROTOCOL_CODE				0x00


#define USB_DEVDSC_CONFIGS    			USB_MAX_CONFIG // USB_DEVDSC_CONFIGS   -->  USB_GetChargeCurrentTableSize() 


/*For Configuration descriptor*/
#define USB_CFGDSC_ATTR_NATURE			0x80
#define USB_CFGDSC_ATTR_SELFPOWER		0x40
#define USB_CFGDSC_ATTR_REMOTEWAKEUP	0x20
#define USB_CFGDSC_MAXPOWER				(500/2)

#define USB_OTG_HNP_SUPPORT				0x02
#define USB_OTG_SRP_SUPPORT				0x01


/***********************************************
	Hub class code definition
************************************************/
#define USB_HUB_DEVICE_CLASS_CODE				0x09
#define USB_HUB_DEVICE_SUBCLASS_CODE				0x00
//#define USB_HUB_DEVICE_PROTOCOL_CODE				0x00
#define USB_HUB_INTERFACE_CLASS_CODE 			0x09
#define USB_HUB_INTERFACE_SUBCLASS_CODE 			0x00
//#define USB_HUB_INTERFACE_PROTOCOL_CODE 			0x00


/***********************************************
	Implement definition
************************************************/

/* Define configuration, interface, ep number */
#define USB_MAX_CONFIG				6  /* configuration number */
#if defined(__USB_COMPOSITE_DEVICE_SUPPORT__)
#define USB_MAX_IAD					2
#else
#define USB_MAX_IAD					1
#endif

#if defined(__USB_MULTIPLE_COMPORT_SUPPORT__)
#define USB_MAX_INTERFACE			4  /* interface number */
#else
#define USB_MAX_INTERFACE			2  /* interface number */
#endif

#define USB_MAX_INTERFACE_ALTERNATE_NUM		1  /* interface alternate seting number */

#if defined(__USB_EP_TEST__)
#define USB_MAX_EP_BULK_TX		4  /* max bulk in ep number */
#define USB_MAX_EP_BULK_RX		3  /* max bulk in ep number */
#define USB_MAX_EP_ISO_TX			4  /* max interrupt ep number */
#define USB_MAX_EP_INTR_TX			4  /* max interrupt ep number */
#else
#if defined(__USB_MULTIPLE_COMPORT_SUPPORT__)
#if defined (__USB_MODEM_CARD_SUPPORT__)
#define USB_MAX_EP_BULK_TX		3  /* max bulk in ep number */
#define USB_MAX_EP_BULK_RX		3  /* max bulk in ep number */
#else
#define USB_MAX_EP_BULK_TX		2  /* max bulk in ep number */
#define USB_MAX_EP_BULK_RX		2  /* max bulk in ep number */
#endif
#define USB_MAX_EP_INTR_TX			2  /* max interrupt ep number */
#else
#define USB_MAX_EP_BULK_TX		1  /* max bulk in ep number */
#define USB_MAX_EP_BULK_RX		1  /* max bulk in ep number */
#define USB_MAX_EP_INTR_TX			1  /* max interrupt ep number */
#endif
#define USB_MAX_EP_ISO_TX			1  /* max interrupt ep number */
#endif

#define USB_MAX_STRING				12 /* string number */

#define USB_MAX_EP_PER_IF			3 /* 3 is for image class */

/* serial string array size  for that unique Serial number*/
#define USB_SERIAL_STRING_LEN		16

/* define endpoint data parameters */
#define USB_EP_NODATA				-1  /* no more data for endpoint to send */


/***********************************************
	standard command structure
************************************************/

/* usb standard command structure */
typedef struct 
{
	kal_uint8	bmRequestType;
	kal_uint8	bRequest;
	kal_uint16	wValue;
	kal_uint16	wIndex;
	kal_uint16	wLength;
}Usb_Command;



/***********************************************
	Standard descriptor structure
************************************************/

/* standard device descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint16   bcdUSB;
	kal_uint8    bDeviceClass;
	kal_uint8    bDeviceSubClass;
	kal_uint8    bDeviceProtocol;
	kal_uint8    bMaxPacketSize0;
	kal_uint16   idVendor;
	kal_uint16   idProduct;
	kal_uint16   bcdDevice;
	kal_uint8    iManufacturer;
	kal_uint8    iProduct;
	kal_uint8    iSerialNumber;
	kal_uint8    bNumConfigurations;
}Usb_Dev_Dscr;


/* standard configuration descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint16   wTotalLength;
	kal_uint8    bNumInterfaces;
	kal_uint8    bConfigurationValue;
	kal_uint8    iConfiguration;
	kal_uint8    bmAttributes;
	kal_uint8    bMaxPower;
}Usb_Cfg_Dscr;


/* standard IAD descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint8    bFirstInterface;
	kal_uint8    bInterfaceCount;
	kal_uint8    bFunctionClass;
	kal_uint8    bFunctionSubClass;
	kal_uint8    bFunctionProtocol;
	kal_uint8    iFunction;
}Usb_IAD_Dscr;


/* standard interface descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint8    bInterfaceNumber;
	kal_uint8    bAlternateSetting;
	kal_uint8    bNumEndpoints;
	kal_uint8    bInterfaceClass;
	kal_uint8    bInterfaceSubClass;
	kal_uint8    bInterfaceProtocol;
	kal_uint8    iInterface;
}Usb_If_Dscr;


/* standard endpoint descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint8    bEndpointAddress;
	kal_uint8    bmAttributes;
	kal_uint8    wMaxPacketSize[2];	
	kal_uint8    bInterval;
}Usb_Ep_Dscr;


/* standard string descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint16   wData[1];
}Usb_String_Dscr;


/* standard string descriptor */
typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint8    bAttribute;
}Usb_Otg_Dscr;


typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint16  bcdUSB;
	kal_uint8    bDeviceClass;
	kal_uint8    bDeviceSubClass;
	kal_uint8    bDeviceProtocol;
	kal_uint8    bMaxPacketSize0;
	kal_uint8    bNumConfigurations;
	kal_uint8    bReserved;
}Usb_Dev_Qual_Dscr;


typedef struct 
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint16  wTotalLength;
	kal_uint8    bNumInterfaces;
	kal_uint8    bConfigurationValue;
	kal_uint8    iConfiguration;
	kal_uint8    bmAttributes;
	kal_uint8    MaxPower;
}Usb_Other_Speed_Cfg_Dscr;


typedef struct
{
	kal_uint8    bLength;
	kal_uint8    bDescriptorType;
	kal_uint8    qwSignature[14];
	kal_uint8    bMS_VendorCode;
	kal_uint8    bPad;
}Usb_OS_String_Dscr;


typedef struct
{
	kal_uint32    dwLength;
	kal_uint16    bcdVersion;
	kal_uint16    wIndex;
	kal_uint8     bCount;
	kal_uint8     bPads_1[7];
	kal_uint8     bFirstInterfaceNumber;
	kal_uint8     bPads_2;
	kal_uint8     compatibleID[8];
	kal_uint8     subcompatibleID[8];
	kal_uint8     bPads_3[6];
}Usb_Ext_Compat_ID_OS_Feature_Dscr;


/***********************************************
	implement enum and structure 
************************************************/

/* device states */
typedef enum
{
	DEVSTATE_DEFAULT = 0,
	DEVSTATE_SET_ADDRESS,
	DEVSTATE_ADDRESS,
	DEVSTATE_CONFIG
}USB_DEVICE_STATE;


/* Endpoint 0 state */
typedef enum 
{
	USB_EP0_IDLE=0,
	USB_EP0_RX,
	USB_EP0_TX,
	USB_EP0_RX_STATUS
}USB_EP0_STATE;


/* EP0 status */
typedef struct 
{
	kal_int32	nBytesLeft;	/* number of bytes left to send in TX mode */
	void		*pData;		/* pointer to data to transmit/receive */
	kal_int32	nBytesRecv;	/* number of bytes received in RX mode */
	kal_uint8	byFAddr;	/* new function address */
	kal_bool	no_ZLP;	/* No need ZLP when wLength == transfer size */
}Usb_Ep0_Status;


/* Bulk IN endpoint status */
typedef struct 
{
	void		*pData;		/* pointer to data buffer */
	kal_int32	nBytesLeft;	/* number of bytes left to send */
	kal_uint8	byEP;		/* endpoint number */
}Usb_EpBIn_Status;


/* Bulk OUT endpoint status */
typedef struct 
{
	void		*pData;		/* pointer to data buffer */
	kal_int32	nBuffLen;	/* length of data buffer */
	kal_int32	nBytesRecv;	/* number of bytes received */
	kal_uint8	byEP;		/* endpoint number */
}Usb_EpBOut_Status;


typedef enum
{
	USB_NORMAL_BOOT = 0,
	USB_BOOT_ONE_PORT,
	USB_BOOT_TWO_PORT,
	USB_BOOT_THREE_PORT
//	USB_RNDIS_ONE_PORT
}USB_Comport_Boot_Status;

typedef enum
{
	USB_COMPORT_WIN = 0,
	USB_COMPORT_WIN_SINGLE_INTERFACE,
	USB_COMPORT_MAC,
	USB_COMPORT_LINUX,
}USB_Comport_OS_Driver_Status;

typedef enum
{
	USB_MASK_OWNER_MS = 0,
	USB_MASK_OWNER_COM_1,
	USB_MASK_OWNER_COM_2,
	USB_MASK_OWNER_COM_3,
	USB_MASK_OWNER_ALL,
	USB_MASK_OWNER_MAX
}USB_MASK_OWNER;


/* interface create function pointer */
typedef void (*usb_create_if_func_ptr)(void *);
/* interface speed reset function pointer */
typedef void (* usb_speed_if_func_ptr)(kal_bool bset);
/* EP0 rx interrupt handler */
typedef void (*usb_ep0_rx_ptr)(void *);
/* class specific command interrupt handler */
typedef void (*usb_class_specific_handler_ptr)(Usb_Ep0_Status *, Usb_Command*);
/* endpoint interrupt handler */
typedef void (*usb_ep_handler_ptr)(void);
/* EP0 command  interrupt handler */
typedef void (*usb_ep0_cmd_ptr)(Usb_Command *pcmd);

typedef void (*usb_void_func)(void);

/* endpoint information, including endpoint status */
typedef struct 
{
	union 
	{
		Usb_Ep_Dscr			stdep;			/* ep descriptor */
		kal_uint8			classep[USB_MAX_CLASS_EPDESC_LENGTH];
	}epdesc;

	union 
	{
		Usb_EpBIn_Status	epin_status;
		Usb_EpBOut_Status	epout_status;
	}ep_status;						/* ep status */

	usb_ep_handler_ptr		ep_reset;		/* ep reset handler */
	kal_uint16				epdscr_size;		/* descriptor length */
}Usb_Ep_Info;


typedef struct 
{
	Usb_Ep_Info			*ep_info[USB_MAX_EP_PER_IF];/* endpoint attach to the interface info */	
	kal_uint16			ifdscr_size;		/* descriptor length */
	Usb_If_Dscr			stdif;	
}Usb_Alternate_Interface_Info;


/* interface information, including endpoint information and interface information*/
typedef struct 
{
	kal_char			*interface_name_ptr;	/* interface name */
	usb_class_specific_handler_ptr	if_class_specific_hdlr;	/* interface specific handler, handle ep0 class specific request */
	kal_uint16			ifdscr_size;		/* descriptor length */
#ifdef  __USB_SUPPORT_ISO_PIPE__
	Usb_Alternate_Interface_Info	alternate_if_info[USB_MAX_INTERFACE_ALTERNATE_NUM];
	kal_uint8				alternate_setting;	/* alternate setting number */
#endif
	union 
	{
		Usb_If_Dscr		stdif;
		kal_uint8		classif[USB_MAX_IFDSC_LENGTH];
	}ifdscr;

	Usb_Ep_Info			*ep_info[USB_MAX_EP_PER_IF];/* endpoint attach to the interface info */	
}Usb_Interface_Info;


/* configuration information */
typedef struct 
{	
	Usb_Cfg_Dscr		stdcfg;			/* config descriptor */
}Usb_Config_Info;


typedef struct
{
	kal_bool			b_enable;
	kal_uint8			cmd;
	usb_ep0_cmd_ptr	ep0_cmd_hdlr;
}Usb_EP0_Cmd_Hdler;

/* device information, used for usb level */
typedef struct
{
	USB_DEVICE_TYPE 	device_type;
	USB_DEVICE_STATE	nDevState;			/*DEVSTATE_CONFIG,DEVSTATE_ADDRESS,DEVSTATE_DEFAULT*/		
	kal_bool			remoteWk;
#if defined(__DUAL_TALK_MODEM_SUPPORT__)	
	kal_bool			isRemoteWking;
#endif

	kal_uint32  			memory_addr;// allocate memory buffer address
	kal_uint32  			reserved_memory_size;//memory left size	

	kal_bool			self_powered;
	kal_bool			ep0_send_one_pkt;		/* the variable to record ep0 will send only one packet */

	kal_uint8			config_num;
	kal_uint8			interface_num[USB_MAX_INTERFACE];
	USB_EP0_STATE 		ep0_state;


	/* Add for multi-configurations*/
	PMU_CTRL_CHR_GET_CHR_CURRENT_LIST get_chr_current_list;	
	kal_uint8			multi_Max_Power[USB_MAX_CONFIG];
	kal_uint8 			current_table_index;

#if defined(__TC01__)||defined(__USB_DATA_CONNECTION__)||defined (__USB_MODEM_CARD_SUPPORT__)
	kal_bool			usb_send_config_result; /* to send configure may be fail */
#endif

	/* used for resource management*/
// optimize code size : cannot change order
   	kal_uint8			resource_ep_bulk_tx_number;
   	kal_uint8			resource_ep_bulk_rx_number;		
   	kal_uint8			resource_ep_intr_tx_number;
	kal_uint8			resource_interface_number;
   	kal_uint8			resource_string_number;   
#ifdef  __USB_SUPPORT_ISO_PIPE__
	kal_uint8			resource_ep_iso_tx_number;
   	kal_uint8			resource_interface_alternate_number[USB_MAX_INTERFACE];
#endif
	kal_uint8			resource_iad_number;   		
// resource_iad_number : must be the end of resource parameter



	/*  the configuration only one for saving memory  */
// optimize code size : cannot change order
	Usb_Dev_Dscr		devdscr;
	Usb_Cfg_Dscr 		cfgdscr;
	Usb_Ep_Info			ep_bulk_tx_info[USB_MAX_EP_BULK_TX];
	Usb_Ep_Info			ep_bulk_rx_info[USB_MAX_EP_BULK_RX];
	Usb_Ep_Info			ep_intr_tx_info[USB_MAX_EP_INTR_TX];
	Usb_Interface_Info	if_info[USB_MAX_INTERFACE];	
#ifdef  __USB_SUPPORT_ISO_PIPE__
	Usb_Ep_Info			ep_iso_tx_info[USB_MAX_EP_ISO_TX];
#endif
	Usb_String_Dscr		*resource_string[USB_MAX_STRING];
	Usb_IAD_Dscr			iad_desc[USB_MAX_IAD];
#ifdef __OTG_ENABLE__
	Usb_Otg_Dscr		otgdscr;
#endif
#ifdef __USB_IMAGE_CLASS__
	Usb_OS_String_Dscr   		os_string_desc;
	Usb_Ext_Compat_ID_OS_Feature_Dscr   	os_feature_desc;
#endif
	
#ifdef __USB_HS_ENABLE__
	Usb_Dev_Qual_Dscr			dev_qual_dscr;
	Usb_Other_Speed_Cfg_Dscr		other_speed_cfg_dscr;
	USB_TEST_MODE_TYPE			usb_test_type;
#endif
	kal_uint8 			*conf;				/*just for descriptor transfer*/
// conf :  : must be the end of descriptor parameter

	Usb_Command			cmd;				/*USB_COMMAND*/

	Usb_Ep0_Status    	ep0info;
	usb_ep0_rx_ptr  	ep0_rx_handler;
	Usb_EP0_Cmd_Hdler	ep0_class_cmd_handler; /* class specific ep0 cmd */

   	/* serial string unique for each phone*/
   	kal_uint16			serial_string[USB_SERIAL_STRING_LEN]; 

	/* customizable variables*/
	const USB_DEVICE_PARAM	*device_param;
} Usb_Device;


/***********************************************
	function and global variable
************************************************/
extern Usb_Device gUsbDevice;

void USB_EP0_Command_Hdlr(kal_bool bError);


#ifdef  __RTL_SIMULATION_FOR_60QBIT__
extern void usb_irq_disable_duration_test2(void);
#endif

extern void USB_Send_Msg_Ext_Queue(module_type dstid,msg_type msg_id,void *data);

extern kal_uint32 USB_Get_Memory (kal_uint32 len);
extern void USB_Free_Memory(void);

#endif /* USB_H */

