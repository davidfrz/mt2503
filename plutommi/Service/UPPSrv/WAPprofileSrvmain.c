/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
*
* Filename:
* ---------
* WAPProfileSrvMain.c
*
* Project:
* --------
*   MAUI
*
* Description:
* ------------
*   This is main source file for UPP profile module.
*
* Author: 
* -------
* -------
*
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/
#include "MMI_features.h"
#include "MMIDataType.h"
#include "GlobalResDef.h"


#include "DtcntSrvGprot.h"

#include "Custom_data_account.h"
#include "dtcntsrviprot.h"


#ifdef WAP_SUPPORT

#include "WAPProfSrvConfig.h"
#include "WAPProfileSrvType.h"
#ifdef PROV_SUPPORT
#include "WAPProvisioningSrvType.h"        /* prov action enum. */
#include "WAPProvisioningSrvProt.h"
#endif
#include "WAPProfileSrvProt.h"
#include "WAPProfileSrvGprot.h"
#ifdef PROV_SUPPORT
#include "WAPProvisioningSrvProt.h"        /* For prov init. */
#endif
#include "app_url.h"
//------------------------------ suggest Add ------------------------------
#include "Conversions.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "mmi_inet_app_trc.h"
#include "MMI_inet_app_trc.h"
#include "kal_public_api.h"
#include "cbm_api.h"
#include "kal_general_types.h"
#include "stack_msgs.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_cb_mgr_gprot.h"
#include "cbm_consts.h"
#include "string.h"
#include "stack_config.h"
#include "mmi_frm_scenario_gprot.h"
#include "common_nvram_editor_data_item.h"
#include "Unicodexdcl.h"
#include "stdio.h"
#include "mmi_frm_mem_gprot.h"
//#include "app_buff_alloc.h"
#include "mmi_frm_history_gprot.h"
//------------------------------ usage ------------------------------





srv_wap_prof_context_struct g_srv_wap_prof_cntx;

static mmi_ret srv_wap_prof_dtcnt_profile_changes_reg_event(void *user_data);
static S32 srv_wap_prof_dtcnt_changed_handler(mmi_event_struct* param);

#ifndef __SRV_UPP_SLIM__
static srv_wap_prof_job_list_data_struct *g_srv_wap_prof_job_list_p;
static U8 g_srv_wap_prof_job_count = 0;
static srv_wap_prof_job_list_data_struct *g_srv_wap_prof_job_list_last_p;
#endif

static U8 g_srv_wap_prof_wifi_prefer_flag = 0;


/*****************************************************************************
 * FUNCTION
 *  vapp_wap_prof_app_init
 * DESCRIPTION
 *  This is the WAP PROF Initialization API. Called at bootup.
 * PARAMETERS
 *  void
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
void srv_wap_prof_process_init_event()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
  
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
	U8 no_of_sim_supported;
     g_srv_wap_prof_wifi_prefer_flag = 0;	
	/* Read active data account id*/

	 for(no_of_sim_supported =0; no_of_sim_supported<MMI_MAX_SIM_NUM; no_of_sim_supported++)
	 {
		 srv_wap_prof_nvram_read_active_profile_index((srv_wap_prof_sim_id_enum)no_of_sim_supported, SRV_WAP_PROF_APPID_BRW); 
#ifdef MMS_SUPPORT
		 srv_wap_prof_nvram_read_active_profile_index((srv_wap_prof_sim_id_enum)no_of_sim_supported, SRV_WAP_PROF_APPID_MMS); 
#endif
	 }
	 no_of_sim_supported = SRV_WAP_PROF_SIMID_END;


    /* Init provisioning */
#ifdef PROV_SUPPORT
    srv_wap_prof_prov_init();
#endif

    srv_wap_prof_reset_status();

    srv_wap_prof_dtcnt_profile_changes_reg_event(NULL);

    MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_INIT_EXIT);
}

#ifndef __SRV_UPP_SLIM__

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_add_job
* DESCRIPTION
*  Adds job to job list.
* PARAMETERS
*  job_type        [IN]        
*  mod_id          [IN]        
*  sim_id          [IN]        
*  app_id          [IN]        
*  data            [?]         
*  msg(?)
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_add_job(
						  srv_wap_prof_job_type_enum job_type,
						  U16 mod_id,
						  srv_wap_prof_sim_id_enum sim_id,
						  srv_wap_prof_app_id_enum app_id,
						  void *data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_ADD_JOB, g_srv_wap_prof_job_count, job_type);

	if (!(g_srv_wap_prof_job_list_p))
	{
		/* List empty */
		g_srv_wap_prof_job_list_p =
			(srv_wap_prof_job_list_data_struct*) srv_wap_prof_mem_allocate(sizeof(srv_wap_prof_job_list_data_struct));
		g_srv_wap_prof_job_list_last_p = g_srv_wap_prof_job_list_p;
	}
	else
	{
		/* List contains data */
		ASSERT(g_srv_wap_prof_job_list_last_p);
		g_srv_wap_prof_job_list_last_p->next =
			(srv_wap_prof_job_list_data_struct*) srv_wap_prof_mem_allocate(sizeof(srv_wap_prof_job_list_data_struct));
		g_srv_wap_prof_job_list_last_p = g_srv_wap_prof_job_list_last_p->next;
	}

	g_srv_wap_prof_job_list_last_p->job_type = job_type;
	g_srv_wap_prof_job_list_last_p->src_mod_id = mod_id;
	g_srv_wap_prof_job_list_last_p->job_sim_id = sim_id;
	g_srv_wap_prof_job_list_last_p->job_app_id = app_id;
	g_srv_wap_prof_job_list_last_p->job_data = data;
	g_srv_wap_prof_job_list_last_p->next = NULL;
	g_srv_wap_prof_job_count++;
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_delete_job
* DESCRIPTION
*  Deletes the current job which has been processed.
* PARAMETERS
*  void
*  msg(?)
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_delete_job(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prof_job_list_data_struct *lp_job;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(
		SRV_WAP_PROF_TRC_GRP9,
		TRC_MMI_WAP_PROF_DELETE_JOB,
		g_srv_wap_prof_job_count);

	if (g_srv_wap_prof_job_list_p)
	{
		lp_job = g_srv_wap_prof_job_list_p->next;
		srv_wap_prof_mem_free(g_srv_wap_prof_job_list_p);
		g_srv_wap_prof_job_list_p = NULL;
		g_srv_wap_prof_job_count--;
		g_srv_wap_prof_job_list_p = lp_job;
	}
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_process_job
* DESCRIPTION
*  Processes current job.
* PARAMETERS
*  void
*  msg(?)
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_process_job(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prof_profile_content_struct *profile_content;
	srv_wap_prof_get_profile_rsp_funcptr_type temp_func_ptr;
	srv_wap_prof_job_get_profile_struct *job_data;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_srv_wap_prof_job_list_p)
	{
		MMI_TRACE(
			SRV_WAP_PROF_TRC_GRP9,
			TRC_MMI_WAP_PROF_PROCESS_JOB,
			g_srv_wap_prof_job_count,
			g_srv_wap_prof_job_list_p->job_type);
		switch (g_srv_wap_prof_job_list_p->job_type)
		{
		case SRV_WAP_PROF_JOB_GET_PROFILE_CONTENT:
			{
				job_data = (srv_wap_prof_job_get_profile_struct*) g_srv_wap_prof_job_list_p->job_data;
				profile_content = srv_wap_prof_get_profile_content(
					g_srv_wap_prof_job_list_p->job_sim_id,
					g_srv_wap_prof_job_list_p->job_app_id,
					job_data->profile_id,
					job_data->dtcnt_type,
					NULL);

				MMI_TRACE(
					SRV_WAP_PROF_TRC_GRP9,
					TRC_MMI_WAP_PROF_JOB_GET_PROFILE_CONTENT_CALLBACK_RSP,
					g_srv_wap_prof_job_list_p->src_mod_id);
				/* Function ptr exists (Q05a) reply through callback. mem will be freed in the callback by Q05a */
				temp_func_ptr = (srv_wap_prof_get_profile_rsp_funcptr_type) (job_data->callback);

				temp_func_ptr(g_srv_wap_prof_job_list_p->job_sim_id, profile_content);

				srv_wap_prof_mem_free(job_data);
				job_data = NULL;
			}
			break;

			/* Add all cases above this line */
		default:
			/* Should not reach here */
			ASSERT(0);
		}

		srv_wap_prof_delete_job();
		if (g_srv_wap_prof_job_list_p)
		{
			/* More jobs to process. */
			srv_wap_prof_send_process_job_queue_ind();
		}
	}
}
#endif

void srv_wap_prof_send_activate_account_ind(U32 account_id,
									            MMI_BOOL inform_other,
						  srv_wap_prof_sim_id_enum sim_id,
												srv_wap_prof_app_id_enum app_id)
{
		    srv_wap_prof_activate_profile_struct act_evt;
			MMI_FRM_INIT_EVENT(&act_evt, EVT_ID_SRV_UPP_ACTIVATE_PROFILE_IND);
			act_evt.index = account_id;
			act_evt.inform_others = inform_other;
			act_evt.sim_info = sim_id;
			act_evt.app_info = app_id;
			MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&act_evt);

}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_dtcnt_profile_changes_reg_event
* DESCRIPTION
*  Register event callback dynamically with user data pointer.
* PARAMETERS
*  evt_id :      [IN]  callback execution type.
*  user_data :   [IN]  user data pointer.
* RETURNS
*  Return MMI_RET_OK if success to register callback with designated user data;
*  return MMI_RET_ERR_HAS_BEEN_REGISTERED if the designated callback with 
*  designated user data has been registered.
*****************************************************************************/
static mmi_ret srv_wap_prof_dtcnt_profile_changes_reg_event(void *user_data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_frm_cb_reg_event(EVT_ID_SRV_DTCNT_ACCT_UPDATE_IND, srv_wap_prof_dtcnt_changed_handler, user_data);
	mmi_frm_cb_reg_event(EVT_ID_SRV_DTCNT_ACCT_DELETE_IND, srv_wap_prof_dtcnt_changed_handler, user_data);
#if defined(__MMI_BROWSER_2__) && defined(__MMI_WLAN_FEATURES__)
	mmi_frm_cb_reg_event(EVT_ID_SRV_DTCNT_WLAN_BEARER_STATUS, srv_wap_prof_dtcnt_changed_handler, user_data);
#endif
	return MMI_RET_OK;
}


/*****************************************************************************
* FUNCTION
*  mmi_dtcnt_prov_callback_handler
* DESCRIPTION
*  function to handle the service callback
* PARAMETERS
*    param :      [IN]  event parameter.
* RETURNS
*  Return MMI_RET_OK if success;
*****************************************************************************/
static S32 srv_wap_prof_dtcnt_changed_handler(mmi_event_struct* param)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/


	switch (param->evt_id)
	{
	case EVT_ID_SRV_DTCNT_ACCT_UPDATE_IND:
		srv_wap_prof_dtcnt_updated_ind_hdlr(param);
		break;
	case EVT_ID_SRV_DTCNT_ACCT_DELETE_IND:
		srv_wap_prof_dtcnt_deleted_ind_hdlr(param);
		break;
#if defined (__MMI_BROWSER_2__) && defined(__MMI_WLAN_FEATURES__) 
	case EVT_ID_SRV_DTCNT_WLAN_BEARER_STATUS:
		if (g_srv_wap_prof_wifi_prefer_flag==0)
			srv_wap_prof_wlan_account_updated_ind_hdlr(param);

		break;
#endif

	default:
		break;
	}

	return MMI_RET_OK;
}



#ifdef __MMI_BROWSER_2__

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_wlan_account_updated_ind_hdlr
* DESCRIPTION
*  
* PARAMETERS
*  param      [IN]            
* RETURNS
*  
*****************************************************************************/
void srv_wap_prof_wlan_account_updated_ind_hdlr(mmi_event_struct *param)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 

}

#endif /* __MMI_BROWSER_2__ */

MMI_BOOL srv_wap_prof_is_dtcnt_updated(srv_dtcnt_acct_update_ind_evt_struct *account_info,
									   srv_wap_prof_sim_id_enum sim_id,
									   srv_wap_prof_app_id_enum app_id)
{
	    U32 data_account_id, account_id;
	    U8 primary_dtcnt_id = (U8) -1;
	    U8 secondary_dtcnt_id = (U8) -1;
		cbm_account_info_struct data_account_info;

		/* FOR BROWSER */

		sim_id = (srv_wap_prof_sim_id_enum)(account_info->sim_id  - 1);

		account_id  = srv_wap_prof_get_active_dtcnt_index(sim_id, app_id);
            
		cbm_decode_data_account_id_ext(account_id, &data_account_info);

		primary_dtcnt_id = data_account_info.account[0].account_id;
		secondary_dtcnt_id = data_account_info.account[1].account_id;
            
		if(primary_dtcnt_id == CBM_DEFAULT_ACCT_ID || secondary_dtcnt_id == CBM_DEFAULT_ACCT_ID)
		{

			srv_dtcnt_get_auto_acc_id(account_id, &data_account_id); 

			cbm_decode_data_account_id_ext(data_account_id, &data_account_info);

			primary_dtcnt_id = data_account_info.account[0].account_id;
			secondary_dtcnt_id = data_account_info.account[1].account_id;     

			if(account_info->cause == 2 &&  srv_wap_prof_target_app_is_ready(app_id))
			{
				return(MMI_TRUE);
			}
		}

		if((primary_dtcnt_id == (U8)account_info->acc_id  || secondary_dtcnt_id == (U8)account_info->acc_id) && srv_wap_prof_target_app_is_ready(SRV_WAP_PROF_APPID_BRW))
		{
			return(MMI_TRUE);
    }
		return(MMI_FALSE);

}

void srv_wap_prof_send_dtcnt_update_indication(U32 data_account_id, 
										  srv_wap_prof_sim_id_enum sim_id,
									      srv_wap_prof_app_id_enum app_id)
{
	        g_srv_wap_prof_cntx.app_id =  app_id;
             srv_wap_prof_send_activate_account_ind(data_account_id,MMI_TRUE,sim_id,app_id);
}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_dtcnt_updated_ind_hdlr
* DESCRIPTION
*  
* PARAMETERS
*  param      [IN]            
* RETURNS
*  
*****************************************************************************/
void srv_wap_prof_dtcnt_updated_ind_hdlr(mmi_event_struct *param)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_dtcnt_acct_update_ind_evt_struct *account_info;
	srv_wap_prof_sim_id_enum sim_id = SRV_WAP_PROF_SIMID_SIM1;

#ifdef __MMI_BROWSER_2__ 
	U32 browser_account_id;
	MMI_BOOL browser_dtcnt_activated = MMI_FALSE;
#endif
#ifdef MMS_SUPPORT
	MMI_BOOL mms_dtcnt_activated = MMI_FALSE;
	U32 mms_account_id;
#endif

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	account_info = (srv_dtcnt_acct_update_ind_evt_struct *)param;
	sim_id = (srv_wap_prof_sim_id_enum)(account_info->sim_id  - 1);

	if(g_srv_wap_prof_cntx.module_status != SRV_WAP_PROF_WAITING && account_info->cause !=1) // Cause is not provisioning
	{
		g_srv_wap_prof_cntx.profile_content_src = SRV_WAP_PROF_PROFILE_SRC_DTCNT_CHANGED;
		g_srv_wap_prof_cntx.dtcnt_update_flag = MMI_FALSE;
		g_srv_wap_prof_cntx.sim_id = sim_id;

#ifdef __MMI_BROWSER_2__  //Only for Q05A app
		/* FOR BROWSER */
		browser_dtcnt_activated = srv_wap_prof_is_dtcnt_updated(account_info, sim_id,  SRV_WAP_PROF_APPID_BRW);
		browser_account_id  = srv_wap_prof_get_active_dtcnt_index(sim_id, SRV_WAP_PROF_APPID_BRW);
#endif   

#ifdef MMS_SUPPORT
		/* FOR MMS  */
		mms_account_id  = srv_wap_prof_get_active_dtcnt_index(sim_id, SRV_WAP_PROF_APPID_MMS);
		mms_dtcnt_activated = srv_wap_prof_is_dtcnt_updated(account_info,sim_id,SRV_WAP_PROF_APPID_MMS);
#endif

#ifdef MMS_SUPPORT
#ifdef __MMI_BROWSER_2__  
		if(browser_dtcnt_activated && mms_dtcnt_activated)
			{
				g_srv_wap_prof_cntx.dtcnt_update_flag = MMI_TRUE;
				g_srv_wap_prof_cntx.updated_mms_dtcnt = mms_account_id;
			}
#endif
#endif

#ifdef __MMI_BROWSER_2__  
		if( browser_dtcnt_activated == MMI_TRUE)
		{
			/* activate profile indication callback */	
			srv_wap_prof_send_dtcnt_update_indication(browser_account_id, sim_id, SRV_WAP_PROF_APPID_BRW);
			return;
		}
#endif

#ifdef MMS_SUPPORT
		if( mms_dtcnt_activated == MMI_TRUE)
		{
			/* activate profile indication callback */	
			srv_wap_prof_send_dtcnt_update_indication(mms_account_id, sim_id, SRV_WAP_PROF_APPID_MMS);	
		}
#endif
	}/* if(g_srv_wap_prof_cntx.module_status != MMI_WAP_PROF_WAITING) */
}



srv_wap_find_deleted_accounts(srv_wap_prof_app_id_enum app_id, srv_dtcnt_acct_delete_ind_evt_struct *account_info)
{

		MMI_BOOL flag = MMI_FALSE;
	srv_wap_prof_sim_id_enum sim_id = SRV_WAP_PROF_SIMID_SIM1;
	U32 account_id;
		U8 loop_index;
        U32 account_activated;

	U8 primary_dtcnt_id = (U8) -1;
	U8 secondary_dtcnt_id = (U8) -1;
	cbm_account_info_struct data_account_info;

		for(sim_id = SRV_WAP_PROF_SIMID_SIM1; sim_id < SRV_WAP_PROF_SIM_TOTAL; sim_id++)
		{
			account_id  = srv_wap_prof_get_active_dtcnt_index(sim_id, app_id);

			cbm_decode_data_account_id_ext(account_id, &data_account_info);

			primary_dtcnt_id = data_account_info.account[0].account_id;
			secondary_dtcnt_id = data_account_info.account[1].account_id;
if(primary_dtcnt_id == CBM_DEFAULT_ACCT_ID || secondary_dtcnt_id == CBM_DEFAULT_ACCT_ID)
        {
					account_id  = srv_wap_prof_get_smart_dtcnt_index(sim_id, app_id);
					cbm_decode_data_account_id_ext(account_id, &data_account_info);

            primary_dtcnt_id = data_account_info.account[0].account_id;
            secondary_dtcnt_id = data_account_info.account[1].account_id;
			}


			for(loop_index = 0; loop_index < account_info->del_num; loop_index++)
			{  
				if(primary_dtcnt_id == (U8)account_info->acc_id[loop_index] )
				{
					primary_dtcnt_id = CBM_INVALID_NWK_ACCT_ID;
					flag = MMI_TRUE;
				}

				if(secondary_dtcnt_id == (U8)account_info->acc_id[loop_index])  // if it matches with any 
				{
					secondary_dtcnt_id = CBM_INVALID_NWK_ACCT_ID;
					flag = MMI_TRUE;
				}

			}


			if(flag == MMI_TRUE)
			{

				if(primary_dtcnt_id == CBM_INVALID_NWK_ACCT_ID)
				{
					if(secondary_dtcnt_id == CBM_INVALID_NWK_ACCT_ID)
					{
						account_activated = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, (U8)-1, sim_id, app_id );
					}
					else
					{
						account_activated = srv_wap_prof_encode_dtcnt(secondary_dtcnt_id, (U8)-1, sim_id, app_id );
					}
				}
				else
				{

					account_activated = srv_wap_prof_encode_dtcnt(primary_dtcnt_id, (U8)-1, sim_id, app_id );

				}

				g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_count].app_id = app_id;
				g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_count].sim_id = sim_id;
				g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_count].activate_data_account_id = account_activated;
				g_srv_wap_prof_cntx.update_account_count++;
				flag = MMI_FALSE;
			}

			MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_DTCNT_DELETED_TOTAL_COUNT, g_srv_wap_prof_cntx.update_account_count);
		}

		}

MMI_BOOL srv_wap_prof_notify_deleted_dtcnt(srv_wap_prof_app_id_enum app_id)
		{
				g_srv_wap_prof_cntx.app_id =  app_id;

				if(srv_wap_prof_target_app_is_ready(app_id))
        {
					g_srv_wap_prof_cntx.update_account_index++;
            
					/*activate profile indication callback */
					srv_wap_prof_send_activate_account_ind(g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index-1].activate_data_account_id,
						                                                                  MMI_TRUE,
																						  g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index-1].sim_id,
																						  app_id);
					return KAL_TRUE;
		   }
				else
				{
					MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_DTCNT_DELETED_BRW_NOT_READY);

					while(g_srv_wap_prof_cntx.update_account_index   <  g_srv_wap_prof_cntx.update_account_count 
						&& g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index ].app_id == app_id )
				{
						g_srv_wap_prof_cntx.update_account_index++;

                        /*activate profile indication callback */
						srv_wap_prof_send_activate_account_ind(g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index-1].activate_data_account_id,
						                                                                  MMI_FALSE,
																						  g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index-1 ].sim_id,
																						  app_id);

				}
					return KAL_FALSE;
				}

				}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_dtcnt_updated_ind_hdlr
* DESCRIPTION
*  
* PARAMETERS
*  param      [IN]            
* RETURNS
*  
*****************************************************************************/
void srv_wap_prof_dtcnt_deleted_ind_hdlr(mmi_event_struct *param)
				{

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_BOOL ret;
	srv_dtcnt_acct_delete_ind_evt_struct *account_info;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	account_info = (srv_dtcnt_acct_delete_ind_evt_struct *)param;


	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_DTCNT_DELETED_HDLR,account_info->del_num);

	memset(g_srv_wap_prof_cntx.update_account_info, (U8)-1, sizeof(g_srv_wap_prof_cntx.update_account_info));

	if (g_srv_wap_prof_cntx.module_status != SRV_WAP_PROF_WAITING && account_info->del_num > 0) //|| (g_srv_wap_prof_cntx.module_status == SRV_WAP_PROF_READY_TO_DELETE))
	{
		g_srv_wap_prof_cntx.profile_content_src = SRV_WAP_PROF_PROFILE_SRC_DTCNT_DELETED;
		g_srv_wap_prof_cntx.update_account_count = 0;

		/* FOR BROWSER */
#ifdef __MMI_BROWSER_2__ 
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_DTCNT_DELETED_BRW_HDLR);
		srv_wap_find_deleted_accounts(SRV_WAP_PROF_APPID_BRW, account_info);
#endif

		/* FOR MMS  */
#ifdef MMS_SUPPORT
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_DTCNT_DELETED_MMS_HDLR);
		srv_wap_find_deleted_accounts(SRV_WAP_PROF_APPID_MMS, account_info);
#endif /* MMS_SUPPORT*/

		if(g_srv_wap_prof_cntx.update_account_count > 0 )
		{
			g_srv_wap_prof_cntx.update_account_index = 0;

#ifdef __MMI_BROWSER_2__
			if(g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index].app_id == SRV_WAP_PROF_APPID_BRW)
			{
				ret = srv_wap_prof_notify_deleted_dtcnt(SRV_WAP_PROF_APPID_BRW);
				
					if(ret)
					return;
			}
#endif

#ifdef MMS_SUPPORT
			if(g_srv_wap_prof_cntx.update_account_index < g_srv_wap_prof_cntx.update_account_count)
					{
				srv_wap_prof_notify_deleted_dtcnt(SRV_WAP_PROF_APPID_MMS);
			}
#endif
		}

	}/* if(g_srv_wap_prof_cntx.module_status != SRV_WAP_PROF_WAITING)*/
}



/*****************************************************************************
* FUNCTION
*  srv_wap_prof_reset_status
* DESCRIPTION
*  Resets status of profile module.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_reset_status(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_RESET_STATUS);

	g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY;

	g_srv_wap_prof_cntx.callback = NULL;

}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_deinit
* DESCRIPTION
*  This is the deinitialization routine & reset values used by WAP_PROF
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_deinit(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
    U8 i;
    srv_wap_prof_reset_status();

	for(i=0;i<MMI_MAX_SIM_NUM;i++)
		cbm_deregister_app_id(g_srv_wap_prof_cntx.cbm_app_id[i][SRV_WAP_PROF_APPID_BRW]);

#ifdef MMS_SUPPORT
	for(i=0;i<MMI_MAX_SIM_NUM;i++)
		cbm_deregister_app_id(g_srv_wap_prof_cntx.cbm_app_id[i][SRV_WAP_PROF_APPID_MMS]);
#endif

}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_display_profile_list
* DESCRIPTION
*  Interface API for other modules to display profile list.
* PARAMETERS
*  sim_id      [IN]        
*  app_id      [IN]        
*  titlebar_icon_id        [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_display_profile_list(
									   srv_wap_prof_sim_id_enum sim_id,
									   srv_wap_prof_app_id_enum app_id,
									   U16 titlebar_icon_id,
									   U16 app_menu_id,
									   mmi_id parent_id)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prof_entry_dtcnt_cui_struct evt;
#ifndef __COSMOS_MMI_PACKAGE__ 
	srv_wap_prof_display_popup_struct popup_evt;
#endif
	U8 cbm_app_id;
#if  ((MMI_MAX_SIM_NUM  >= 2))  && defined(__MMI_WLAN_FEATURES__)
	U32 data_account_id;
#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

#if (!(MMI_MAX_SIM_NUM >= 2))
	/* wrong SIM ID. */
	ASSERT(SRV_WAP_PROF_SIMID_DEFAULT == sim_id);
#endif /* __MMI_WAP_DUAL_SIM__ */ 


	MMI_TRACE(
		SRV_WAP_PROF_TRC_GRP9,
		TRC_MMI_WAP_PROF_UI_SHOW_PROFILE_LIST,
		sim_id,
		app_id);
#ifndef __COSMOS_MMI_PACKAGE__ 
	if (!(srv_wap_prof_is_re_entry_allowed(sim_id, app_id)))

	{
		MMI_FRM_INIT_EVENT(&popup_evt, EVT_ID_SRV_UPP_DISPLAY_POPUP_IND);
		popup_evt.action = (U16) SRV_WAP_PROF_GLOBAL_NOT_AVAILABLE;
		popup_evt.result = SRV_WAP_PROF_ERR;
		popup_evt.use_action_as_string_id = MMI_TRUE;
		popup_evt.popup_end_callback = NULL;
		popup_evt.popup_exit_callback = NULL;
		MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&popup_evt);
        return;
	}
#endif

	g_srv_wap_prof_cntx.sim_id = sim_id;
	g_srv_wap_prof_cntx.app_id = app_id;
	g_srv_wap_prof_cntx.titlebar_icon_id = titlebar_icon_id;
	g_srv_wap_prof_cntx.profile_content_src = SRV_WAP_PROF_PROFILE_SRC_USER;
	g_srv_wap_prof_cntx.parent_id = parent_id;


#if ((MMI_MAX_SIM_NUM >= 2)) && defined(__MMI_WLAN_FEATURES__)

	if (g_srv_wap_prof_cntx.sim_id == SRV_WAP_PROF_SIMID_WLAN)
	{


		//		#define CBM_WIFI_ACCT_ID    (0x38)
		data_account_id =  cbm_encode_data_account_id(CBM_WIFI_ACCT_ID, CBM_SIM_ID_SIM1, srv_wap_prof_get_cbm_app_id(app_id,sim_id), KAL_FALSE);
		if(data_account_id != srv_wap_prof_get_active_dtcnt_index(g_srv_wap_prof_cntx.sim_id, g_srv_wap_prof_cntx.app_id) )
			
		{
			/* activate profile callback indication */
			srv_wap_prof_send_activate_account_ind(data_account_id,MMI_TRUE,sim_id,app_id);
			return;

		}
	}
#endif /*(__MMI_WAP_DUAL_SIM__ ) && defined(__MMI_WLAN_FEATURES__)*/




	MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_ENTER_DTCNT_CUI_IND);

	cbm_app_id = srv_wap_prof_get_cbm_app_id(app_id,sim_id);

	evt.sim_id = sim_id;
	evt.app_id = app_id;
	evt.cbm_app_id = cbm_app_id;
	evt.parent_id = parent_id;
	evt.icon_id = g_srv_wap_prof_cntx.titlebar_icon_id;
	evt.app_menu_id = app_menu_id;
	MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_get_module_status
* DESCRIPTION
*  
* PARAMETERS  
*  module_status       [IN]        
* RETURNS
*  MMI_BOOL
*****************************************************************************/

MMI_BOOL srv_wap_prof_get_module_status(srv_wap_prof_module_status_enum *module_status)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	*module_status = g_srv_wap_prof_cntx.module_status;
	return MMI_TRUE;
}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_set_module_status
* DESCRIPTION
*  
* PARAMETERS  
*  void       [IN]        
* RETURNS
*  void
*****************************************************************************/

MMI_BOOL srv_wap_prof_set_module_status(void)
{

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_WAITING;
	return MMI_TRUE;
}
/*****************************************************************************
* FUNCTION
*  srv_wap_prof_is_dtcnt_valid
* DESCRIPTION
*  
* PARAMETERS  
*        [IN]        
* RETURNS
*  MMI_BOOL
*****************************************************************************/

MMI_BOOL srv_wap_prof_is_dtcnt_valid(srv_wap_prof_sim_id_enum sim_id, srv_wap_prof_app_id_enum app_id, U8 profile_id)
{

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
    srv_wap_prof_check_dtcnt_valid_struct evt;
   
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
     MMI_FRM_INIT_EVENT(&evt,EVT_ID_SRV_UPP_CHECK_DTCNT_VALID);
     evt.sim_id = sim_id;
	 evt.app_id = app_id;
	 evt.profile_id = profile_id;
	 evt.result = KAL_FALSE;
	 MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

     return(evt.result);

}
/*****************************************************************************
* FUNCTION
*  srv_wap_prof_get_profile_source
* DESCRIPTION
*  
* PARAMETERS  
*  void       [IN]        
* RETURNS
*  srv_wap_prof_profile_source_enum
*****************************************************************************/
srv_wap_prof_profile_source_enum srv_wap_prof_get_profile_source(void)
{

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	srv_wap_prof_profile_source_enum profile_source = g_srv_wap_prof_cntx.profile_content_src;
	return profile_source;
}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_active_profile_change_confirmation_callback
* DESCRIPTION
*  This will be called when active profile chg rsp is recieved, To continue the processing.
* PARAMETERS
*  result      [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_active_profile_change_confirmation_callback(srv_wap_prof_result_enum result)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prof_app_id_enum app_id = g_srv_wap_prof_cntx.app_id;
	srv_wap_prof_sim_id_enum sim_id = g_srv_wap_prof_cntx.sim_id;

#if defined (__MMI_BROWSER_2__)
	U8 primary_dtcnt_id = (U8) -1;
	U32 browser_account_id;

	cbm_account_info_struct data_account_info;

#endif

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_ACTIVE_PROFILE_CHANGED_CONFIRMATION_ENTER, result);

	if ((app_id >= SRV_WAP_PROF_APPID_END) || (sim_id >= SRV_WAP_PROF_SIMID_END))
	{
		ASSERT(app_id < SRV_WAP_PROF_APPID_END);
		ASSERT(sim_id < SRV_WAP_PROF_SIMID_END);
		return;
	}

	if (MMI_TRUE == g_srv_wap_prof_cntx.end_key_pressed)
	{
		/*
		* End key was pressed revert back.
		* * change result to err.
		*/
		result = SRV_WAP_PROF_ERR;
	}

	if (SRV_WAP_PROF_SUCCESS == result)
	{
		/* Commit active profile index to NVRAM. */
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_ACTIVE_PROFILE_CHANGED_COMMIT_CHANGES);

#if defined(__MMI_WLAN_FEATURES__)

		if (g_srv_wap_prof_cntx.sim_id != SRV_WAP_PROF_SIMID_WLAN)
		{

			srv_wap_prof_nvram_write_active_profile_index(sim_id, app_id);
			g_srv_wap_prof_wifi_prefer_flag = 0;

		}

#else /*(__MMI_WAP_DUAL_SIM__ ) && defined(__MMI_WLAN_FEATURES__)*/


		srv_wap_prof_nvram_write_active_profile_index(sim_id, app_id);

#endif
	}
	else  //10ADA if (MMI_WAP_PROF_AXN_ACTIVATE == g_srv_wap_prof_cntx.action)
	{
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_ACTIVE_PROFILE_CHANGED_REVERT_CHANGES);
		/*
		* Revert back as result failed, only if user activated, if user deleted active profile or user edited
		* * active profile then do not revert.
		*/


#if (MMI_MAX_SIM_NUM >=2) && defined(__MMI_WLAN_FEATURES__)

		if (g_srv_wap_prof_cntx.sim_id != SRV_WAP_PROF_SIMID_WLAN)
		{

			srv_wap_prof_nvram_read_active_profile_index(sim_id, app_id);
			g_srv_wap_prof_wifi_prefer_flag = 0;

		}

#else /*(__MMI_WAP_DUAL_SIM__ ) && defined(__MMI_WLAN_FEATURES__)*/


		srv_wap_prof_nvram_read_active_profile_index(sim_id, app_id);

#endif


	}


	/* Change status to ready. */
	g_srv_wap_prof_cntx.module_status = SRV_WAP_PROF_READY;

#ifdef PROV_SUPPORT
	if (SRV_WAP_PROF_PROFILE_SRC_OTA_PROV == g_srv_wap_prof_cntx.profile_content_src)
	{
		if (MMI_FALSE == g_srv_wap_prof_cntx.end_key_pressed)
		{
			srv_wap_prov_provisioning_ui_done(MMI_TRUE); //10ADA : Critical: Check it
		}
	}

	if ((SRV_WAP_PROF_PROFILE_SRC_USIM_PROV == g_srv_wap_prof_cntx.profile_content_src) ||
		(SRV_WAP_PROF_PROFILE_SRC_DM_PROV == g_srv_wap_prof_cntx.profile_content_src) )   //10ADA critical
	{

		srv_wap_prov_provisioning_ui_done(MMI_FALSE);

	}
#endif



#if defined (__MMI_BROWSER_2__)

	if(SRV_WAP_PROF_SRC_WLAN_DTCNT_CHANGED == g_srv_wap_prof_cntx.profile_content_src && g_srv_wap_prof_cntx.dtcnt_update_flag == MMI_TRUE )
	{

		browser_account_id  = srv_wap_prof_get_active_dtcnt_index(SRV_WAP_PROF_SIMID_SIM1, SRV_WAP_PROF_APPID_BRW);

		cbm_decode_data_account_id_ext(browser_account_id, &data_account_info);

		primary_dtcnt_id = data_account_info.account[0].account_id;

		g_srv_wap_prof_cntx.dtcnt_update_flag = MMI_FALSE; 

		if(primary_dtcnt_id ==  CBM_DEFAULT_ACCT_ID)
		{  
			g_srv_wap_prof_cntx.app_id =  SRV_WAP_PROF_APPID_BRW;
			
			/* activate profile indication callback */
			srv_wap_prof_send_activate_account_ind(browser_account_id,MMI_TRUE,SRV_WAP_PROF_SIMID_SIM1,SRV_WAP_PROF_APPID_BRW);
		}

	}
#endif


	if (SRV_WAP_PROF_PROFILE_SRC_DTCNT_DELETED == g_srv_wap_prof_cntx.profile_content_src)
	{


		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_DTCNT_DELETED_ACTIVATED_CONFIRMATION,
			g_srv_wap_prof_cntx.update_account_index,
			g_srv_wap_prof_cntx.update_account_count);


		if(g_srv_wap_prof_cntx.update_account_index  < g_srv_wap_prof_cntx.update_account_count )
		{
#ifdef __MMI_BROWSER_2__
			if(g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index].app_id == SRV_WAP_PROF_APPID_BRW)
			{
				g_srv_wap_prof_cntx.app_id =  SRV_WAP_PROF_APPID_BRW;
				g_srv_wap_prof_cntx.update_account_index++;
				
				/* activate profile indication callback */
				srv_wap_prof_send_activate_account_ind(g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index-1].activate_data_account_id,
					                                                                  MMI_TRUE,
																					  g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index-1].sim_id,
																					  SRV_WAP_PROF_APPID_BRW);
			}

#endif
#ifdef MMS_SUPPORT

			if(g_srv_wap_prof_cntx.update_account_info[g_srv_wap_prof_cntx.update_account_index].app_id == SRV_WAP_PROF_APPID_MMS)
					{
				srv_wap_prof_notify_deleted_dtcnt(SRV_WAP_PROF_APPID_MMS);
			}
#endif
		}
		else
		{	
			g_srv_wap_prof_cntx.update_account_index =0;
		g_srv_wap_prof_cntx.update_account_count =0;
		memset(g_srv_wap_prof_cntx.update_account_info, (U8)-1, sizeof(g_srv_wap_prof_cntx.update_account_info));
		}
	}
#ifdef MMS_SUPPORT
	// else if(SRV_WAP_PROF_PROFILE_SRC_DTCNT_CHANGED == g_srv_wap_prof_cntx.profile_content_src 
	else if( g_srv_wap_prof_cntx.dtcnt_update_flag == MMI_TRUE
		&& srv_wap_prof_target_app_is_ready(SRV_WAP_PROF_APPID_MMS))
	{

		g_srv_wap_prof_cntx.app_id = SRV_WAP_PROF_APPID_MMS;

		/* activate profile indication callback */
		srv_wap_prof_send_activate_account_ind(g_srv_wap_prof_cntx.updated_mms_dtcnt,
					                                                                  MMI_TRUE,
																					  g_srv_wap_prof_cntx.sim_id,
																					  g_srv_wap_prof_cntx.app_id);

		g_srv_wap_prof_cntx.dtcnt_update_flag = MMI_FALSE;  


	}
#endif
}




/*****************************************************************************
* FUNCTION
*  srv_wap_prof_validate_url
* DESCRIPTION
*  Utility function to validate the url.
* PARAMETERS
*  url_p                       [IN]        Url in unicode to be validated
*  b_blank_url_is_valid        [IN]        
* RETURNS
*  void
*****************************************************************************/
S16 srv_wap_prof_validate_url(U8 *url_p, MMI_BOOL b_blank_url_is_valid)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U8 temp[NVRAM_WAP_PROF_URL_LEN + 1];
	U8 url_ascii[NVRAM_WAP_PROF_URL_LEN + 1];
	U8 uri_schm_len;
	applib_url_struct url_info;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* check the zero length */
	if (MMI_FALSE == b_blank_url_is_valid)
	{
		if (!mmi_ucs2strlen((S8*) url_p))
		{
			return APPLIB_URL_ERR_INVALID_PARAM;
		}
	}

	/* convert the UCS2 URL string into UTF-8 */
	mmi_chset_ucs2_to_utf8_string((U8*) url_ascii, NVRAM_WAP_PROF_URL_LEN + 1, (U8*) url_p);

	MMI_PRINT(SRV_WAP_PROF_MOD_INET_APP, SRV_WAP_PROF_TRC_GRP9, "[WAP_PROF] Validate URL = %s", (S8*) url_ascii);
	/* parse the URL string by using Applib API */
	if (!(S32) applib_parse_url((S8*) url_ascii, &url_info))
	{
		/* if there is an empty URI scheme in the URL then append the default ("http://") */
		/* URI scheme */
		if (url_info.scheme_type == applib_scheme_empty)
		{
			uri_schm_len = strlen((S8*) SRV_WAP_PROF_DEFAULT_URL);
			if (strlen((S8*) url_ascii) > (NVRAM_WAP_PROF_URL_LEN - uri_schm_len))
			{
				strncpy((S8*) temp, (S8*) url_ascii, NVRAM_WAP_PROF_URL_LEN - uri_schm_len);
				temp[NVRAM_WAP_PROF_URL_LEN - uri_schm_len] = '\0';
			}
			else
			{
				strcpy((S8*) temp, (S8*) url_ascii);
			}
			strcpy((S8*) url_ascii, (S8*) SRV_WAP_PROF_DEFAULT_URL);
			strcat((S8*) url_ascii, (S8*) temp);
			mmi_chset_utf8_to_ucs2_string((U8*) url_p, (NVRAM_WAP_PROF_URL_LEN) * ENCODING_LENGTH, (U8*) url_ascii);

			/* check whether it contain HTTP or HTTPS URI scheme with empty host */
			if (MMI_FALSE == b_blank_url_is_valid)
			{
				if (!(S32) applib_parse_url((S8*) url_ascii, &url_info))
				{
					if ((url_info.scheme_type == applib_scheme_http) || (url_info.scheme_type == applib_scheme_https))
					{

						if (!url_info.len[APPLIB_URL_HOST_PART])
						{
							return APPLIB_URL_ERR_INVALID_HOST;
						}
					}
				}
			}
		}
		/* check whether it contain HTTP or HTTPS URI scheme with empty host */
		else if ((url_info.scheme_type == applib_scheme_http) || (url_info.scheme_type == applib_scheme_https))
		{
			if (MMI_FALSE == b_blank_url_is_valid)
			{
				if (!url_info.len[APPLIB_URL_HOST_PART])
				{
					return APPLIB_URL_ERR_INVALID_HOST;
				}
			}
		}
	}

	/* validate the UTF-8 URL string by using Applib API */
	return (S32) applib_url_is_valid((S8*) url_ascii);
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_set_cbm_app
* DESCRIPTION
*  Returns CBM registered app id for BRW / MMS
* PARAMETERS
*  app_id                          [IN]        
*  srv_wap_prof_app_id_enum(?)     [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_set_cbm_app(srv_wap_prof_sim_id_enum sim_id , srv_wap_prof_app_id_enum app_id,  U8 cbm_app_id)
	{
		 g_srv_wap_prof_cntx.cbm_app_id[sim_id][app_id] = cbm_app_id;
}
/*****************************************************************************
* FUNCTION
*  srv_wap_prof_get_cbm_app_id
* DESCRIPTION
*  Returns CBM registered app id for BRW / MMS
* PARAMETERS
*  app_id                          [IN]        
*  srv_wap_prof_app_id_enum(?)     [IN]        
* RETURNS
*  U8
*****************************************************************************/
U8 srv_wap_prof_get_cbm_app_id(srv_wap_prof_app_id_enum app_id, srv_wap_prof_sim_id_enum  sim_info)
{
	return(g_srv_wap_prof_cntx.cbm_app_id[sim_info][app_id]);
}

/*****************************************************************************
* FUNCTION
*  srv_wap_prof_handle_service_n_port_param
* DESCRIPTION
*  it fills the service / port parameter for the proxy.
* PARAMETERS
*  proxy_content       [IN]        
*  service_parm        [IN]        
*  portnbr_parm        [IN]        
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_handle_service_n_port_param(
	U16 px_port,
	U16  px_service,
	srv_wap_prof_conn_type_enum *conn_type)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/*
	* CL-WAP            9200  WAP
	* CO-WSP            9201  WAP
	* CL-SEC-WSP        9202  WAP + Security ON
	* CO-SEC-WSP        9203  WAP + Security ON
	* CO-SEC-WTA        not supported
	* CL-SEC-WTA        not supported
	* OTA-HTTP-TO       80    HTTP
	* OTA-HTTP-TLS-TO   443   HTTP + Security ON
	* OTA-HTTP-PO       80    HTTP
	* OTA-HTTP-TLS-PO   443   HTTP + Security ON
	* 
	* all others --> HTTP
	* 
	*/
#ifdef __MMI_WAP_PROF_PORT_PRIORITY__

	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_PROV_RCVD_PORT_N_SERVICE_VALUE, px_port, px_service);

	/* First priority is of port number */
	switch (px_port)
	{
	case 9200:
	case 9201:
		*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED;

		break;

	case 9202:
	case 9203:
		*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED_SECURE;

		break;
#ifdef WAP2
	case 80:
	case 8080:
	case 443:
		*conn_type = SRV_WAP_PROF_CONN_TYPE_HTTP;

		break;
#endif /* WAP2 */ 
	default:
		/* If standard port numbers did not match, change port number according to service. */
		{
			switch (px_service)
			{

			case SRV_DTCNT_PROF_PX_SRV_CL_WSP:
			case SRV_DTCNT_PROF_PX_SRV_CO_WSP:
				*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED;

				break;

			case SRV_DTCNT_PROF_PX_SRV_CL_SEC_WSP:
			case SRV_DTCNT_PROF_PX_SRV_CO_SEC_WSP:
				*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED_SECURE;

				break;
#ifdef WAP2
			case SRV_DTCNT_PROF_PX_SRV_HTTP:
			case SRV_DTCNT_PROF_PX_SRV_HTTP_TLS:
				*conn_type = SRV_WAP_PROF_CONN_TYPE_HTTP;
				break;

#endif /* WAP2 */ 
			default:
				*conn_type = SRV_WAP_PROF_CONN_TYPE_HTTP;

			}
		}
		break;
	}

#else /* __MMI_WAP_PROF_PORT_PRIORITY__ */ 


	/* Service has higher priority. */
	switch (px_service)
	{
	case SRV_DTCNT_PROF_PX_SRV_CL_WSP:
	case SRV_DTCNT_PROF_PX_SRV_CO_WSP:
		*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED;

		break;

	case SRV_DTCNT_PROF_PX_SRV_CL_SEC_WSP:
	case SRV_DTCNT_PROF_PX_SRV_CO_SEC_WSP:
		*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED_SECURE;

		break;
#ifdef WAP2
	case SRV_DTCNT_PROF_PX_SRV_HTTP:
	case SRV_DTCNT_PROF_PX_SRV_HTTP_TLS:
		*conn_type = SRV_WAP_PROF_CONN_TYPE_HTTP;

		break;
#endif /* WAP2 */ 
	default:

		if (px_port == 9200 || px_port == 9201)
		{
			*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED;
		}
		else if (px_port == 9202 || px_port == 9203)
		{
			*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED_SECURE;
		}
		else
		{
#ifdef WAP2
			*conn_type = SRV_WAP_PROF_CONN_TYPE_HTTP;
#else 
			*conn_type = SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED;
#endif 
		}

	}
#endif /* __MMI_WAP_PROF_PORT_PRIORITY__ */ 


}


/*****************************************************************************
 * FUNCTION
 *  mmi_wap_prof_set_active_profile_index
 * DESCRIPTION
 *  Sets index value to active profile index global. commits to NVRAM if commit_flag = MMI_TRUE
 * PARAMETERS
 *  sim_id          [IN]        
 *  app_id          [IN]        
 *  index_value     [IN]        
 *  commit_flag     [IN]        
 * RETURNS
 *  U8    activated profile index(?)
 *****************************************************************************/
void srv_wap_prof_set_smart_profile_index( srv_wap_prof_sim_id_enum sim_id, srv_wap_prof_app_id_enum app_id, U32 index_value)
{
  g_srv_wap_prof_cntx.smart_dtcnt_index[sim_id][app_id] = index_value;
}

/*****************************************************************************
* FUNCTION
 *  sr_wap_prof_get_homepage
 * DESCRIPTION
 *  Return homepage for browser
 * PARAMETERS
 *  sim_id          [IN]        
 *  app_id          [IN]        
 * RETURNS
 *  CHAR *
 *****************************************************************************/


CHAR* srv_wap_prof_get_homepage(
	srv_wap_prof_sim_id_enum sim_id,
	srv_wap_prof_app_id_enum app_id, U8 profile_index)

{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

    srv_dtcnt_prof_str_info_qry_struct homepage_struct;
	U32 data_account_id = 0;
	U8 primary_dtcnt_id = (U8) -1;
	U32 temp_dtcnt_id = (U8) - 1;
	U8 secondary_dtcnt_id = (U8) -1;
	
	cbm_account_info_struct data_account_info;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	homepage_struct.dest = (CHAR*)srv_wap_prof_mem_allocate(NVRAM_WAP_PROF_URL_LEN);
	memset((CHAR*)homepage_struct.dest, 0, NVRAM_WAP_PROF_URL_LEN);
	homepage_struct.dest_len = NVRAM_WAP_PROF_URL_LEN;
	homepage_struct.req_len = 0; 

    #ifdef __OP01__
	   	    temp_dtcnt_id = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, secondary_dtcnt_id, sim_id,  app_id );
			srv_dtcnt_get_auto_acc_id(temp_dtcnt_id, &data_account_id);
	#else
   
	#if defined(__MMI_WLAN_FEATURES__)
	if(SRV_WAP_PROF_SIMID_WLAN == sim_id && SRV_WAP_PROF_APPID_BRW == app_id) // WLAN Profile
	{

		//		#define CBM_WIFI_ACCT_ID    (0x38)
		data_account_id =  cbm_encode_data_account_id(CBM_WIFI_ACCT_ID, CBM_SIM_ID_SIM1, srv_wap_prof_get_cbm_app_id(SRV_WAP_PROF_APPID_BRW, SRV_WAP_PROF_SIMID_SIM1), KAL_FALSE);
	}
        else
    #endif
	{
		data_account_id = srv_wap_prof_get_active_dtcnt_index(sim_id, app_id);

			cbm_decode_data_account_id_ext(data_account_id, &data_account_info);

			primary_dtcnt_id = data_account_info.account[0].account_id;

			if (!(srv_wap_prof_is_dtcnt_valid(sim_id, app_id, profile_index)) || primary_dtcnt_id == CBM_DEFAULT_ACCT_ID)
			{
	        		temp_dtcnt_id = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, secondary_dtcnt_id, sim_id,  app_id );

					srv_dtcnt_get_auto_acc_id(temp_dtcnt_id, &data_account_id);
			}
	}
	#endif


	if (MMI_FALSE ==  srv_dtcnt_get_homepage(
		data_account_id,
		&homepage_struct,
		SRV_DTCNT_ACCOUNT_PRIMARY))  
	{
	        if(profile_index == 0)
			strcpy((CHAR*)homepage_struct.dest, (CHAR*)"http://google.com");
		else
			strcpy((CHAR*)homepage_struct.dest, (CHAR*) SRV_WAP_PROF_DEFAULT_URL);
	}
	else
	{	 
		if(strcmp((CHAR*)homepage_struct.dest, "") == 0) 
			if(profile_index == 0)
				strcpy((CHAR*)homepage_struct.dest, (CHAR*)"http://google.com");
			else
				strcpy((CHAR*)homepage_struct.dest,(CHAR*)SRV_WAP_PROF_DEFAULT_URL);
	}

   	MMI_PRINT(SRV_WAP_PROF_MOD_INET_APP, SRV_WAP_PROF_TRC_GRP9, "[WAP_PROF] Homepage URL = %s", (CHAR*) homepage_struct.dest);

	return((CHAR*)homepage_struct.dest);
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_get_profile_content
* DESCRIPTION
*  Returns profile content based on profile index, if -1 is index then active profile is returned.
*  if callback is provided then reply is through callback, if callback is NULL and status is waiting
*  reply NULL is returned.
*  If module is ready, then content is returned even if callback is provided.
* PARAMETERS
*  sim_id                          [IN]        
*  app_id                          [IN]        
*  profile_index                   [IN]        
*  get_profile_rsp_callback        [IN]        
*  prof_conn_type_enum(?)          [IN]        
* RETURNS
*  wap_prof_conn_type_enum
*****************************************************************************/
srv_wap_prof_profile_content_struct *srv_wap_prof_get_profile_content(
	srv_wap_prof_sim_id_enum sim_id,
	srv_wap_prof_app_id_enum app_id,
	U8 profile_index,
	srv_wap_prof_dtcnt_count_enum  dtcnt_type,
	srv_wap_prof_get_profile_rsp_funcptr_type get_profile_rsp_callback)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	srv_wap_prof_profile_content_struct *profile_content = NULL;
#ifndef __SRV_UPP_SLIM__
	srv_wap_prof_job_get_profile_struct *job_data = NULL;
#endif
	//10ADA
	U32 data_account_id = 0;
	U32 smart_encoded_acc_id = 0;
	srv_dtcnt_prof_proxy_info_struct  dtcnt_proxy_struct;
	srv_dtcnt_prof_str_info_qry_struct homepage_struct;
	srv_wap_prof_conn_type_enum conn_type;
	srv_dtcnt_account_enum dtcnt_account_type;
	U8 primary_dtcnt_id = (U8) -1;
	U8 secondary_dtcnt_id = (U8) -1;
	S8 trace_string[NVRAM_WAP_PROF_URL_LEN * 4] = {0, };
	CHAR ip_address[64] = { '\0' };
	cbm_account_info_struct data_account_info;
	g_srv_wap_prof_cntx.sim_id = sim_id;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(
		SRV_WAP_PROF_TRC_GRP9,
		TRC_MMI_WAP_PROF_GET_PROFILE,
		sim_id,
		app_id,
		profile_index,
		(U16) g_srv_wap_prof_cntx.module_status);

#ifndef __SRV_UPP_SLIM__
	if ((get_profile_rsp_callback) && (g_srv_wap_prof_cntx.module_status != SRV_WAP_PROF_READY))
	{
		/* Response required as a callback, and Module not ready. */
		job_data =
			(srv_wap_prof_job_get_profile_struct*)
			srv_wap_prof_mem_allocate(sizeof(srv_wap_prof_job_get_profile_struct));
		job_data->profile_id = profile_index;
		job_data->dtcnt_type = dtcnt_type;
		job_data->callback = (void*)get_profile_rsp_callback;
		srv_wap_prof_add_job(SRV_WAP_PROF_JOB_GET_PROFILE_CONTENT, MOD_MMI, sim_id, app_id, (void*)job_data);
		srv_wap_prof_send_process_job_queue_ind();
		return NULL;
	}
	else
#endif
	{
		if (SRV_WAP_PROF_BOOTUP_NOT_READY == g_srv_wap_prof_cntx.module_status)
		{
			MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_GET_PROFILE_MODULE_NOT_READY_ERROR);
			/*
			* Module not ready and No callback. 
			* * Do not change the above condition to != READY, as during activate, status is waiting.
			*/
			ASSERT(get_profile_rsp_callback);
			return NULL;
		}
	}

	if(dtcnt_type == SRV_WAP_PROF_DTCNT_PRIMARY )
	{
		dtcnt_account_type = SRV_DTCNT_ACCOUNT_PRIMARY;
	}
	else
	{
		dtcnt_account_type = SRV_DTCNT_ACCOUNT_SECONDARY;
	}



	profile_content =
		(srv_wap_prof_profile_content_struct*)
		srv_wap_prof_mem_allocate(sizeof(srv_wap_prof_profile_content_struct));

	memset(profile_content, 0 , (sizeof(srv_wap_prof_profile_content_struct)));

 

	/* for WLAN Profiles : Primary as WLan and secondary as invalid*/
	//Falback won't hapeen

#if defined(__MMI_WLAN_FEATURES__)
	if(SRV_WAP_PROF_SIMID_WLAN == sim_id && SRV_WAP_PROF_APPID_BRW == app_id) // WLAN Profile
	{

		//		#define CBM_WIFI_ACCT_ID    (0x38)
		data_account_id =  cbm_encode_data_account_id(CBM_WIFI_ACCT_ID, CBM_SIM_ID_SIM1, srv_wap_prof_get_cbm_app_id(SRV_WAP_PROF_APPID_BRW, SRV_WAP_PROF_SIMID_SIM1), KAL_FALSE);

		dtcnt_account_type = SRV_DTCNT_ACCOUNT_PRIMARY;

	}
	else

#endif 
	{ /* Start: normal sim profile case */

		if(profile_index == 0)
		{

			secondary_dtcnt_id = (U8) - 1;

			smart_encoded_acc_id = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, secondary_dtcnt_id, sim_id,  app_id );

			srv_dtcnt_get_auto_acc_id(smart_encoded_acc_id, &data_account_id); //10A Da return value: Critical

		}
		else
		{ 

			data_account_id = srv_wap_prof_get_active_dtcnt_index(sim_id, app_id);

			cbm_decode_data_account_id_ext(data_account_id, &data_account_info);

			primary_dtcnt_id = data_account_info.account[0].account_id;
			secondary_dtcnt_id = (U8) - 1;

			if (data_account_info.acct_num > 1)
			{
				secondary_dtcnt_id = data_account_info.account[1].account_id;
			}


			/*  DO NOT DELETE

			srv_dtcnt_get_auto_acc_id() : API behavior

			for Primary no issues: Primary is returned as the auto id and secondary as the same value
			2003737 -> 2003700
			2003E37 -> 2003E00
			2000237 -> 2000200



			for Secondary check  issues: 
			2003737 -> 2003700 : if primary also auto, no use
			200373E -> 2003E3E : If primary invalid, secondary also invalid
			2003702 -> 2000002 : OK
			*/   


			if(dtcnt_account_type == SRV_DTCNT_ACCOUNT_PRIMARY)
			{
				if (!(srv_wap_prof_is_dtcnt_valid(sim_id, app_id, profile_index)))
				{
					smart_encoded_acc_id = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, secondary_dtcnt_id, sim_id,  app_id );

					srv_dtcnt_get_auto_acc_id(smart_encoded_acc_id, &data_account_id); //10A Da return value: Critical
				}
				else if(primary_dtcnt_id == CBM_DEFAULT_ACCT_ID)
				{

					smart_encoded_acc_id = data_account_id;
					smart_encoded_acc_id = srv_wap_prof_encode_dtcnt(CBM_DEFAULT_ACCT_ID, secondary_dtcnt_id, sim_id,  app_id );

					srv_dtcnt_get_auto_acc_id(smart_encoded_acc_id, &data_account_id); //10A Da return value: Critical

				}

              srv_wap_prof_set_smart_profile_index(sim_id, app_id, data_account_id);
			}
			else  //Secondary data account : SRV_DTCNT_ACCOUNT_SECONDARY
			{
				  if (!(srv_wap_prof_is_dtcnt_valid(sim_id, app_id, profile_index)))

				{  smart_encoded_acc_id = srv_wap_prof_encode_dtcnt(primary_dtcnt_id, CBM_DEFAULT_ACCT_ID, sim_id,  app_id );

				   srv_dtcnt_get_auto_acc_id(smart_encoded_acc_id, &data_account_id); //10A Da return value: Critical
				}
				else if (secondary_dtcnt_id == CBM_DEFAULT_ACCT_ID)
				{
					smart_encoded_acc_id = data_account_id;
					smart_encoded_acc_id = srv_wap_prof_encode_dtcnt(primary_dtcnt_id, CBM_DEFAULT_ACCT_ID, sim_id,  app_id );
					srv_dtcnt_get_auto_acc_id(smart_encoded_acc_id, &data_account_id); //10A Da return value: Critical
				}
               srv_wap_prof_set_smart_profile_index(sim_id, app_id, data_account_id);
			}

		}
	} /* End : normal sim profile case */



	homepage_struct.dest = srv_wap_prof_get_homepage(sim_id,app_id,profile_index);
			strncpy((S8*) profile_content->url, (S8*) homepage_struct.dest, NVRAM_WAP_PROF_URL_LEN-1);
	srv_wap_prof_mem_free(homepage_struct.dest);


	memset(&dtcnt_proxy_struct, 0 , (sizeof( srv_dtcnt_prof_proxy_info_struct)));

	if(MMI_FALSE == srv_dtcnt_get_proxy_info(
		data_account_id,
		&dtcnt_proxy_struct,
		dtcnt_account_type) )   // 10ADA check the return type of this API
	{
		//Error handling
		// erro check : remove this line later + 10A Critical SPECIAL WLAN CASES as discussed with Will 

		profile_content->proxy_port = SRV_WAP_PROF_DEFAULT_PORT;
		strcpy((CHAR*)profile_content->proxy_ip, (CHAR*) SRV_WAP_PROF_DEFAULT_PROXY_URL);

		profile_content->conn_type = SRV_WAP_PROF_CONN_TYPE_HTTP;

		strcpy((S8*) profile_content->username, (S8*)SRV_WAP_PROF_DEFAULT_USERNAME);
		strcpy((S8*) profile_content->password, (S8*)SRV_WAP_PROF_DEFAULT_PASSWORD);

	}
	else
	{

		profile_content->proxy_port = dtcnt_proxy_struct.px_port;

		strncpy((CHAR*) profile_content->proxy_ip, (CHAR*) dtcnt_proxy_struct.px_addr, SRV_WAP_PROF_MAX_PROXY_ADDR_LEN-1);

		srv_wap_prof_handle_service_n_port_param(
			dtcnt_proxy_struct.px_port,
			dtcnt_proxy_struct.px_service,
			&conn_type); //10ADA check the data type of conn_type

		profile_content->conn_type = conn_type;


		strncpy((S8*) profile_content->username, (S8*) dtcnt_proxy_struct.px_authid, NVRAM_WAP_PROF_PROFILE_USERNAME_LEN-1);
		strncpy((S8*) profile_content->password, (S8*) dtcnt_proxy_struct.px_authpw, NVRAM_WAP_PROF_PROFILE_PASSWORD_LEN-1); 


	}


	profile_content->data_account_primary_id = data_account_id;
	profile_content->data_account_secondary_id = (U32) - 1;


	//  MMI_PRINT(MMI_WAP_PROF_MOD_INET_APP, MMI_WAP_PROF_TRC_GRP9, "[WAP_PROF] Homepage URL = %s", (S8*) homepage_struct.dest);

	sprintf(
		ip_address,
		"%s",
		profile_content->proxy_ip);

	sprintf(
		(S8*) trace_string,
		(S8*) "[WAP_PROF]Content:IP= %s, port= %d, dtcnt 1= %d, uid= %s, PW= %s, conn= %d, url = %s, ap_id= %d, sim_id= %d",
		(S8*) ip_address,
		profile_content->proxy_port,
		profile_content->data_account_primary_id,
		(S8*) profile_content->username,
		(S8*) profile_content->password,
		profile_content->conn_type,
		(S8*) profile_content->url,
		app_id,
		sim_id);

	MMI_PRINT(SRV_WAP_PROF_MOD_INET_APP, SRV_WAP_PROF_TRC_GRP9, (S8*) trace_string);

	return profile_content;
}



/*****************************************************************************
* FUNCTION
*  srv_wap_prof_get_active_profile_connection_type
* DESCRIPTION
*  
* PARAMETERS
*  app_id      [IN]        
* RETURNS
*  prof_conn_type_enum
*****************************************************************************/
srv_wap_prof_conn_type_enum srv_wap_prof_get_active_profile_connection_type(srv_wap_prof_app_id_enum app_id)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	U32 data_account_id = 0;
	srv_dtcnt_prof_proxy_info_struct  dtcnt_proxy_struct;
	srv_wap_prof_conn_type_enum conn_type ;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/


	data_account_id =  srv_wap_prof_get_active_dtcnt_index(SRV_WAP_PROF_SIMID_DEFAULT, app_id);

	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_ENTRY_ACTIVE_CONN_TYPE, data_account_id);

	srv_dtcnt_get_proxy_info(
		data_account_id,
		&dtcnt_proxy_struct,
		SRV_DTCNT_ACCOUNT_PRIMARY);

	//10ADA : get api from MMS for data account type : although after discussion with Vikas no need

	srv_wap_prof_handle_service_n_port_param(
		dtcnt_proxy_struct.px_port,
		dtcnt_proxy_struct.px_service,
		&(conn_type));  //10ADA check the data type of conn_type


	if (SRV_WAP_PROF_CONN_TYPE_HTTP == conn_type)
		return SRV_WAP_PROF_CONN_TYPE_HTTP;
	else
		return SRV_WAP_PROF_CONN_TYPE_CONNECTION_OREINTED;

}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_mem_allocate
* DESCRIPTION
*  Allocates requested memory from control buffer.
* PARAMETERS
*  size        [IN]        
* RETURNS
*  void
*****************************************************************************/
void *srv_wap_prof_mem_allocate(U32 size)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	void *result = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	result = (void*)OslMalloc(size);

	if (NULL == result)
	{
		ASSERT(result);
		return result;
	}
	/*
	MMI_PRINT(
	MMI_WAP_PROF_MOD_INET_APP,
	MMI_WAP_PROF_TRC_GRP9,
	"[WAP_PROF][MEM] Allocated = %d, at ADD = %x",
	size,
	(U32) result);
	*/
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_MEM_ALLOCATED, size, (U32) result);

	return result;
}


/*****************************************************************************
* FUNCTION
*  srv_wap_prof_mem_free
* DESCRIPTION
*  Releases memory pointed by ptr.
* PARAMETERS
*  ptr     [?]     
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_mem_free(void *ptr)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (NULL == ptr)
	{
		ASSERT(ptr);
		return;
	}

	/*    MMI_PRINT(MMI_WAP_PROF_MOD_INET_APP, MMI_WAP_PROF_TRC_GRP9, "[WAP_PROF][MEM] Released ADD = %x", (U32) ptr); */
	MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_MEM_RELEASED, (U32) ptr);
	OslMfree(ptr);
}

#ifndef __SRV_UPP_SLIM__
/* MAUI_01508716 starts */
/*****************************************************************************
* FUNCTION
*  srv_wap_prof_kill_profile
* DESCRIPTION
*  Kills all the profile operations abruptly.
* PARAMETERS
*  app_id
* RETURNS
*  void
*****************************************************************************/
void srv_wap_prof_kill_profile(srv_wap_prof_app_id_enum app_id)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	srv_wap_prof_close_dtcnt_cui_struct evt;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if(g_srv_wap_prof_cntx.app_id == app_id)
	{
		MMI_TRACE(SRV_WAP_PROF_TRC_GRP9, TRC_MMI_WAP_PROF_ERR_KILL_PROFILE, g_srv_wap_prof_cntx.action);
		MMI_FRM_INIT_EVENT(&evt, EVT_ID_SRV_UPP_CLOSE_CUI_IND);
		MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);  

		srv_wap_prof_reset_status();

	}
}
#endif
/*****************************************************************************
* FUNCTION
* srv_wap_prof_get_app_id
* DESCRIPTION
*  This will be called when App need app_id.
* PARAMETERS
*  void   [IN]
* RETURNS
*  srv_wap_prof_app_id_enum
*****************************************************************************/
srv_wap_prof_app_id_enum srv_wap_prof_get_app_id(void)
{
	srv_wap_prof_app_id_enum app_id;
    app_id = g_srv_wap_prof_cntx.app_id;

	return app_id;
}

/*****************************************************************************
* FUNCTION
* srv_wap_prof_get_app_id
* DESCRIPTION
*  This will be called when App need app_id.
* PARAMETERS
*  void   [IN]
* RETURNS
*  srv_wap_prof_app_id_enum
*****************************************************************************/
MMI_BOOL srv_wap_prof_is_re_entry_allowed(srv_wap_prof_sim_id_enum sim_id, srv_wap_prof_app_id_enum app_id)
{
  /*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
   srv_wap_prof_re_entry_allowed_struct evt;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	 MMI_FRM_INIT_EVENT(&evt,EVT_ID_SRV_UPP_RE_ENTRY_ALLOWED);
     evt.sim_id = sim_id;
	 evt.app_id = app_id;
	 evt.result = KAL_FALSE;
	 MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

	 return (evt.result);


}
/*****************************************************************************
* FUNCTION
* srv_wap_prof_get_action
* DESCRIPTION
*  This will be called when App need action.
* PARAMETERS
*  void   [IN]
* RETURNS
*  srv_wap_prof_action_enum
*****************************************************************************/
srv_wap_prof_action_enum srv_wap_prof_get_action(void)
{
	srv_wap_prof_action_enum action  = g_srv_wap_prof_cntx.action;
	return action;
}



#endif /* WAP_SUPPORT */ 
