/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
  ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
#ifndef DOWNLOAD_AGENT_PROT_H
#define DOWNLOAD_AGENT_PROT_H

//#ifdef __COSMOS_MMI_PACKAGE__

#ifndef _FILE_MGR_H_
//#include "FileMgr.h"
#endif

#ifndef DOWNLOAD_AGENT_DEF_H
#include "DLAgentSrvDef.h"
#endif
#include "BrowserSrvGprot.h"
#ifndef DOWNLOAD_AGENT_GPROT_H
#include "DLAgentSrvGProt.h"
#endif

#include "DLAgentSrvWPS.h"
#include "DLAgentSrvConfig.h"

#ifdef __DRM_SUPPORT__
#ifndef DRM_DEF_H
#include "drm_def.h"
#endif
#endif

#ifndef __APP_MINE_H__
#include "App_mine.h"
#endif
#if defined (__MMI_NCENTER_SUPPORT__)
#include "Vsrv_ncenter.h"
#endif
//#include "app_str.h"

//#include "wapadp.h"

//#include "Menucuigprot.h"







    #include "FileMgrGProt.h"
    #include "DLAgentSrvDef.h"
    #include "DLAgentSrvWPS.h"
    #include "app_mine.h"
    #include "MMI_features.h"
    #include "MMI_features_switch.h"
    #include "MMI_features_type.h"
    #include "MMI_conn_app_trc.h"
    #include "mmi_frm_mem_gprot.h"
    #include "MMIDataType.h"
    #include "DebugInitDef_Int.h"
    #include "kal_general_types.h"
    #include "FileMgrSrvGProt.h"
    #include "wgui.h"
    #include "stack_msgs.h"
    #include "vmswitch.h"

#ifdef __MRE_LIB_NETWORK__
#define MMI_DLA_MRE_SUPPORT
#endif /* __MRE_LIB_NETWORK__ */

/****************************************************************************
 * Configurations
 ****************************************************************************/

/*
 * If MMI_DA_CFG_SELECT_STORAGE_BEFORE_DOWNLOAD is defined, it will let
 * user to select storage before download a file. Otherwise, the storage
 * will be decided automatically.
 */
#define MMI_DA_CFG_SELECT_STORAGE_BEFORE_DOWNLOAD

/*
 * If MMI_DA_CFG_INPUT_FILENAME_BEFORE_DOWNLOAD is defined, it will let
 * user to decide the filename to save before download a file. Otherwise, the filename
 * will be decided automatically.
 */
#define MMI_DA_CFG_INPUT_FILENAME_BEFORE_DOWNLOAD

/*
 * If MMI_DA_CFG_OMA_EXPOSE_DD_TO_USER is defined, after user confirmed an OMA download
 * and before the download is really started, an option to view DD will be provided to user.
 */
#define MMI_DA_CFG_OMA_EXPOSE_DD_TO_USER


#ifdef __MMI_DA_DOWNLOAD_FLOW__

#if __MMI_DA_DOWNLOAD_FLOW__ == __DA_FLOW_1__

/* Turn on all, do nothing here. */

#elif __MMI_DA_DOWNLOAD_FLOW__ == __DA_FLOW_2__

#undef MMI_DA_CFG_INPUT_FILENAME_BEFORE_DOWNLOAD
#undef MMI_DA_CFG_OMA_EXPOSE_DD_TO_USER

#elif __MMI_DA_DOWNLOAD_FLOW__ == __DA_FLOW_3__

#undef MMI_DA_CFG_INPUT_FILENAME_BEFORE_DOWNLOAD

#endif

#endif /* defined(__MMI_DA_DOWNLOAD_FLOW__) */


#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) && defined(BROWSER_SUPPORT)
#define __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__
#endif /* __MMI_DA_RESUME__ */

/****************************************************************************
 * Constants
 ****************************************************************************/

#define MMI_DA_TRACE_GROUP                      MMI_CONN_TRC_G1_DLAGENT

#if (defined(__MMI_DLA_SLIM__) || defined(SLIM_WAP_MMS))
#define MMI_DA_MAX_DL                           2
#else
#define MMI_DA_MAX_DL                           4
#endif

#define MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN      0xFFFFFFFF
#define MMI_DA_UTIL_ESTIMATED_TIME_FORMAT_LEN   50

#define MMI_DA_MAX_HTTP_ETAG_LEN                64
#define MMI_DA_MAX_FILENAME_INPUT_LEN           40

#define SRV_DA_MAX_TEXT_BUFFER_LENGTH           1000
#ifdef __COSMOS_MMI_PACKAGE__
#if (defined(__MMI_DLA_SLIM__) || defined(SLIM_WAP_MMS))
#define SRV_DA_MAX_NUM_OF_COMPLETED_DOWNLOAD    2
#else
#define SRV_DA_MAX_NUM_OF_COMPLETED_DOWNLOAD    5
#endif
#else
#define SRV_DA_MAX_NUM_OF_COMPLETED_DOWNLOAD    0
#endif

#define MMI_DA_MAX_JOB                          MMI_DA_MAX_DL + SRV_DA_MAX_NUM_OF_COMPLETED_DOWNLOAD

#define DA_SHOW_INFO(dst, format, tag_src, value_src) \
    kal_wsprintf((unsigned short*)(dst + mmi_ucs2strlen((S8*)dst)),(format),(tag_src), (value_src))
/****************************************************************************
 * Trace enum
 ****************************************************************************/

#define MMI_DA_TRACE_ITEM(func) DA_TRACE_##func

enum mmi_da_trace_func_enum_e
{
    MMI_DA_TRACE_ITEM(srv_da_push_recv_dispatch_file_req) = 0,
    MMI_DA_TRACE_ITEM(mmi_da_recv_wap_notify_ind),
    MMI_DA_TRACE_ITEM(srv_da_can_receive_file),

    /* job api */
    MMI_DA_TRACE_ITEM(srv_da_job_create) = 0x00010000,
    MMI_DA_TRACE_ITEM(srv_da_job_cancel),
    MMI_DA_TRACE_ITEM(srv_da_job_start),
    MMI_DA_TRACE_ITEM(srv_da_job_destroy),
    MMI_DA_TRACE_ITEM(mmi_da_display_job_list),
    MMI_DA_TRACE_ITEM(mmi_da_display_job_detail),
    MMI_DA_TRACE_ITEM(mmi_da_update_job_status),
    MMI_DA_TRACE_ITEM(mmi_da_job_list_option_lsk_hdlr),
    MMI_DA_TRACE_ITEM(mmi_da_click_job),
    MMI_DA_TRACE_ITEM(mmi_da_app_free_job_and_remove_screens),
    MMI_DA_TRACE_ITEM(srv_da_suspend_all_job),

    MMI_DA_TRACE_ITEM(srv_da_curr_job_do_abort),
	MMI_DA_TRACE_ITEM(srv_da_bearer_change_to_cellular),
    MMI_DA_TRACE_ITEM(srv_da_bearer_change_to_wifi),
    MMI_DA_TRACE_ITEM(srv_da_switch_download_to_other_wlan),



    MMI_DA_TRACE_ITEM(mmi_da_entry_job_list) = 0x00010100,
    MMI_DA_TRACE_ITEM(mmi_da_entry_job_list_option),
    MMI_DA_TRACE_ITEM(mmi_da_entry_job_detail),
    MMI_DA_TRACE_ITEM(mmi_da_curr_job_entry_dispatch_confirm),
    MMI_DA_TRACE_ITEM(srv_da_job_fallback_suspended_callback),
    MMI_DA_TRACE_ITEM(srv_da_resume_all_paused_list),
	MMI_DA_TRACE_ITEM(srv_da_recv_nw_switch_ind),
    MMI_DA_TRACE_ITEM(srv_da_suspend_and_resume_all_download),
	MMI_DA_TRACE_ITEM(srv_da_open_bearer),
	MMI_DA_TRACE_ITEM(srv_da_start_http_download),

    MMI_DA_TRACE_ITEM(srv_da_job_make_filestamp) = 0x00010200,
    //MMI_DA_TRACE_ITEM(srv_da_job_check_filestamp),  to do
	MMI_DA_TRACE_ITEM(srv_da_http_dl_operation),

    /* push api */
    MMI_DA_TRACE_ITEM(srv_da_push_free_item) = 0x00020000,
    MMI_DA_TRACE_ITEM(mmi_da_push_filename_done),
    MMI_DA_TRACE_ITEM(mmi_da_entry_new_push),

    /* DLAgent exported api */
    MMI_DA_TRACE_ITEM(srv_da_stop_dl) = 0x00030000,
    MMI_DA_TRACE_ITEM(mmi_da_enter_idle_screen_notify),
    MMI_DA_TRACE_ITEM(srv_da_usb_mode_on),
    MMI_DA_TRACE_ITEM(mmi_da_entry_new_push_ind),
    MMI_DA_TRACE_ITEM(srv_da_resume_dl),
    MMI_DA_TRACE_ITEM(srv_da_remove_dl),
    MMI_DA_TRACE_ITEM(srv_da_stop_pdl),
       
    /* DRM : New design since 08B W09.01 */
    MMI_DA_TRACE_ITEM(srv_da_drm_install_result_callback) = 0x00040000,
    MMI_DA_TRACE_ITEM(srv_da_drm_process),
    MMI_DA_TRACE_ITEM(srv_da_drm_process_cancel),
    MMI_DA_TRACE_ITEM(srv_da_drm_wait_for_rights_callback),
    MMI_DA_TRACE_ITEM(srv_da_drm_wait_for_rights),
    MMI_DA_TRACE_ITEM(srv_da_drm_wait_for_rights_cancel),
    MMI_DA_TRACE_ITEM(srv_da_drm_has_rights),

    /* Screen */
    MMI_DA_TRACE_ITEM(mmi_da_scr_select_storage) = 0x00050000,
    MMI_DA_TRACE_ITEM(mmi_da_scr_get_drive_callback),
    MMI_DA_TRACE_ITEM(mmi_da_scr_delete_callback),
    MMI_DA_TRACE_ITEM(mmi_da_scr_storage_callback),

    /* DLS api */
    MMI_DA_TRACE_ITEM(srv_da_recv_wap_file_dl_ind) = 0x00060000,
    MMI_DA_TRACE_ITEM(srv_da_http_free_job),
    MMI_DA_TRACE_ITEM(srv_da_http_wps_http_response_callback),
    MMI_DA_TRACE_ITEM(mmi_da_http_http_response_error),
    
    /* OMA api */
    MMI_DA_TRACE_ITEM(srv_da_oma_parse_dd) = 0x00070000,
    MMI_DA_TRACE_ITEM(srv_da_oma_http_response_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_popup_and_send_report),
    MMI_DA_TRACE_ITEM(srv_da_oma_send_report_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_abort_job),
    MMI_DA_TRACE_ITEM(srv_da_oma_session_aborted_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_do_next_procedure),
    MMI_DA_TRACE_ITEM(srv_da_oma_parse_dd_and_show_confirm),
    /* iconURI */
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_start_download) = 0x00072000,
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_terminate_download),
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_trigger_next_procedure),
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_session_created_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_session_http_auth_ind_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_session_http_response_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_session_dl_progress_callback),
    MMI_DA_TRACE_ITEM(srv_da_oma_icon_register_for_file),
    /* FOTA */
    MMI_DA_TRACE_ITEM(srv_da_start_oma_download) = 0x00073000,

    /* OMA2.0 api */
    MMI_DA_TRACE_ITEM(srv_da_oma_parse_dd2) = 0x00080000,
    MMI_DA_TRACE_ITEM(mmi_da_oma2_http_response),
    MMI_DA_TRACE_ITEM(mmi_da_oma2_popup_and_send_report),

    /* OMA util */
    MMI_DA_TRACE_ITEM(_dd_read_data_element) = 0x00090000,
    MMI_DA_TRACE_ITEM(_dd2_read_data_element),

    /* WPS */
    DA_TRACE_WPS = 0x000A0000,
    /* See DLAgentWPS.c */

    /* Util */
    MMI_DA_TRACE_ITEM(srv_da_util_file_delete) = 0x000B0000,
    MMI_DA_TRACE_ITEM(srv_da_util_file_move),

    /* ----------------------------------------------- */
    MMI_DA_TRACE_END_OF_ENUM = 0x7FFFFFFF
}; /* this enum is for TRACE usage */

#undef MMI_DA_TRACE_ITEM


#define SRV_DA_PUSH_TRACE_ITEM(func) PUSH_TRACE_##func

enum srv_da_push_trace_enum_e
{
    SRV_DA_PUSH_TRACE_ITEM(srv_da_push_recv_dispatch_file_req) = 0x20000,
    SRV_DA_PUSH_TRACE_ITEM(srv_da_push_free_item),
    SRV_DA_PUSH_TRACE_ITEM(mmi_da_entry_new_push),

    /* ----------------------------------------------- */
    SRV_DA_PUSH_TRACE_END_OF_ENUM
};

#undef SRV_DA_PUSH_TRACE_ITEM


/****************************************************************************
 * Macro
 ****************************************************************************/

#define DA_FREE_BUFFER(buffer)    \
    do { \
    if( buffer ) \
    {           \
        OslMfree( buffer ); \
        buffer = NULL;      \
    } \
    } while(0) 

#define ANSI_STR_MALLOC_COPY(out, in, buffer_size)    \
    do { \
        DA_FREE_BUFFER(out);	\
        if (in != NULL && in[0] != '\0') {  \
            out = (S8*)OslMalloc(strlen((kal_char*)in) + 1); \
            app_strlcpy((kal_char*)(out), (kal_char*)(in), (buffer_size));\
        } \
    } while(0) 

#define UCS2_STR_MALLOC_COPY(out, in)    \
    do { \
    DA_FREE_BUFFER(out);	\
    out = NULL; \
    if( in && mmi_ucs2strlen((const S8*)in) > 0 ){  \
        out = (PU16) OslMalloc((mmi_ucs2strlen((S8*)in)+1)*ENCODING_LENGTH); \
        mmi_ucs2cpy((S8*)(out), (S8*)in);\
    } \
    } while(0) 

#define DA_MAKE_UNIQUE_ID(thejob, localid) \
    ((localid) | ((S32)(thejob->type) << 16))

#define DA_MAKE_UNIQUE_ID_EX(type, localid) \
    ((localid) | ((S32)type << 16))

#define DA_ALLOC_OBJ(trg, struct_type) \
    trg = (struct_type*)OslMalloc(sizeof(struct_type)); \
    memset(trg, 0, sizeof(struct_type))

#define DA_GET_LOCAL_ID(type, global_id) \
    ((global_id) & 0xffff)

#define DA_TRACE_FUNC(func)                 srv_da_trace_func(DA_TRACE_##func)
#define DA_TRACE_FUNC1(func, p1)            srv_da_trace_func_ex(DA_TRACE_##func, p1, 0, 0)
#define DA_TRACE_FUNC2(func, p1, p2)        srv_da_trace_func_ex(DA_TRACE_##func, p1, p2, 0)
#define DA_TRACE_FUNC3(func, p1, p2, p3)    srv_da_trace_func_ex(DA_TRACE_##func, p1, p2, p3)

#define DA_TRACE_ENDFUNC(func)              srv_da_trace_endfunc(DA_TRACE_##func)

#define DA_TRACE1(trace_enum, p1)           MMI_TRACE(MMI_DA_TRACE_GROUP, trace_enum, p1)


#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
#define DA_DL_FLAG_SPECIAL      0x01
#define DA_DL_FLAG_SKIP_CONFIRM 0x02
#endif


/****************************************************************************
 * Typedef
 ****************************************************************************/

typedef enum
{
    SRV_DA_JOB_TYPE_NORMAL,
#ifdef __MMI_OMA_DD_DOWNLOAD__
    SRV_DA_JOB_TYPE_OMADL,  /* DLOTA 1.0 */
#ifdef __MMI_OMA_DD2_DOWNLOAD__
    SRV_DA_JOB_TYPE_OMADL2, /* DLOTA 2.0 */
#endif
#endif   
    
    SRV_DA_JOB_TYPE_HTTP_DOWNLOAD,
	SRV_DA_JOB_TYPE_YT_DOWNLOAD,
    SRV_DA_JOB_TYPE_MREDL,
    SRV_DA_JOB_TYPE_TOTAL,

    SRV_DA_JOB_TYPE_PUSH
    
} srv_da_job_type_enum;


typedef enum
{
    SRV_DA_JOB_STATE_CREATED,
    SRV_DA_JOB_STATE_INIT,
    SRV_DA_JOB_STATE_DOWNLOADING,
    SRV_DA_JOB_STATE_ABORTING,
    SRV_DA_JOB_STATE_ABORTED,
    SRV_DA_JOB_STATE_PAUSED,
    SRV_DA_JOB_STATE_PROCESSING,
    SRV_DA_JOB_STATE_COMPLETED,
	SRV_DA_JOB_STATE_RESUMING,
    SRV_DA_JOB_STATE_FAILED,
    SRV_DA_JOB_STATE_WAITING,
    SRV_DA_JOB_STATE_PAUSED_WAITING,
   
    SRV_DA_JOB_STATE_END_OF_ENUM
} srv_da_job_state_enum;


typedef enum
{
    SRV_DA_IERROR_OK = 0,
    SRV_DA_IERROR_EXCEED_MAX_JOB,
    SRV_DA_IERROR_EXCEED_MAX_DL,
    SRV_DA_IERROR_ANOTHER_JOB,   // already has a job on screen setuping.
    SRV_DA_IERROR_NO_MEMORY,

    SRV_DA_IERROR_NUM
} srv_da_internal_error_enum;


typedef enum
{
    SRV_DA_DRM_STATUS_NONE,
    SRV_DA_DRM_STATUS_PROCESSING,
    SRV_DA_DRM_STATUS_WAITING_FOR_RIGHTS,
    SRV_DA_DRM_STATUS_RIGHTS_ARRIVED,
    SRV_DA_DRM_STATUS_NO_RIGHTS,

    SRV_DA_DRM_STATUS_END_OF_ENUM
} srv_da_drm_status_enum;

typedef struct
{
    S32                     mime_type;
    S32                     mime_subtype;
    srv_da_dispatch_hdlr    dispatch_hdlr;
    srv_da_presetting_hdlr  get_presetting;
    srv_da_setting_hdlr     setting_hdlr;
} srv_da_type_handler_struct;

/* Hook handler */
typedef struct
{
    S32 mime_type;
    S32 mime_subtype;
    srv_da_hook_dispatch_hdlr hook_hdlr;
} srv_da_hook_handler_struct;


typedef struct
{
    MMI_BOOL    do_dispatch;
    MMI_BOOL    confirm_dispatch;
    MMI_BOOL    confirm_push;
    MMI_BOOL    can_minimize;

    srv_da_filepath_hdlr    filepath_hdlr;
    srv_da_report_hdlr      report_hdlr;
} srv_da_job_setting_struct;

typedef struct
{
    U32     curr_size;

} srv_da_job_filestamp_struct;


typedef enum
{
    SRV_DA_ACCEPTANCE_ACCEPT,
    SRV_DA_ACCEPTANCE_REJECT,
    SRV_DA_ACCEPTANCE_ASYNC,

    SRV_DA_ACCEPTANCE_END_OF_ENUM
} srv_da_acceptance_enum;


typedef enum
{
    SRV_DA_NOTIFIED_NONE,
    SRV_DA_NOTIFIED_COMPLETED,
    SRV_DA_NOTIFIED_FAILED,

    SRV_DA_NOTIFIED_END_OF_ENUM
} srv_da_notified_enum;


typedef enum
{
    SRV_DA_POPUP_TYPE_NONE = 0,
    SRV_DA_POPUP_TYPE_MESSAGE,
    SRV_DA_POPUP_TYPE_ERROR,
	SRV_DA_POPUP_TYPE_WAP_ERROR,
	SRV_DA_POPUP_TYPE_FS_ERROR,
    SRV_DA_POPUP_TYPE_DONE,
    SRV_DA_POPUP_TYPE_INFO,
    SRV_DA_POPUP_TYPE_SAVED,
    SRV_DA_POPUP_TYPE_LONG_MESSAGE,
    SRV_DA_POPUP_TYPE_DRM_PROCESSING_INFO,
    SRV_DA_POPUP_TYPE_NMGR_POPUP,

    SRV_DA_POPUP_TYPE_END_OF_ENUM
} srv_da_popup_type_enum;


typedef struct
{
    srv_da_popup_type_enum type;
    U16 title_string_id;
    U16 title_icon_id;
    U16 *string;
    MMI_BOOL free_string_after_popup;
    void *info;
} srv_da_popup_message_struct;


typedef struct _da_job_struct
{
    struct _da_job_struct   *next_job;  /* ponter to next job,     NULL if last job */
    struct _da_job_struct   *prev_job;  /* ponter to previous job, NULL if first job */
    
    srv_da_job_type_enum    type;
    srv_da_job_state_enum   state;
    MMI_BOOL                notified_complete;
    MMI_BOOL                reporting;  /* Init in srv_da_job_start() */
    MMI_BOOL                was_stopped_by_upper_layer;
#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
    MMI_BOOL                saved_to_my_fav;
#endif
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    U8                      dl_flag;
#endif

    srv_da_popup_message_struct pending_popup;
    
    srv_da_error_enum       error_cause;
    srv_da_notified_enum    notified;

    void                    *data_ptr;  /* pointer to job struct, depend on type */

    srv_da_job_setting_struct           setting_info;

    const srv_da_type_handler_struct    *type_handler;
    const applib_mime_type_struct       *mime_type;

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    srv_da_job_filestamp_struct         filestamp;
#endif

    const struct srv_da_module_funcptr_table_s *op; /* Operations */
#if defined (__MMI_NCENTER_SUPPORT__)
	vsrv_notification_handle notify_handle;
#endif
} srv_da_job_struct;


/****************************************************************************
* Define - Macro
*****************************************************************************/

#define DA_JOB_GET_PROGRESS(job, info) \
    job->op->get_progress(job, &info)

#define DA_JOB_GET_ID(job) (S32)(job->op->get_id(job))

#define DA_JOB_UNIQUE_ID(job) DA_MAKE_UNIQUE_ID(job, DA_JOB_GET_ID(job))

#define DA_JOB_GET_FILEPATH(job) (U16*)(job->op->get_filepath(job))

typedef enum {
    SRV_DA_FILESTAMP_CHECK_OK,
    SRV_DA_FILESTAMP_CHECK_FAIL,
    SRV_DA_FILESTAMP_CHECK_FAIL_TEMP,

    SRV_DA_FILESTAMP_CHECK_MAX
} srv_da_job_filestamp_enum;

typedef enum
{
    SRV_DA_ACTION_SCR_PLEASE_WAIT = 1,
    SRV_DA_ACTION_SCR_PREFETCHING_CANCELLING,
    SRV_DA_ACTION_SCR_OMA_DOWNLOAD_OPTION,
    SRV_DA_ACTION_SCR_DRM_PROCESSING,
    SRV_DA_ACTION_SCR_PUSH_MOVING,
    SRV_DA_ACTION_SCR_END   
} srv_da_action_scr_enum;

/****************************************************************************
* Typedef - Struct
*****************************************************************************/

typedef enum
{
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_USER_BACK,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_DELETE_SCREEN,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_NO_AVAILABLE_STORAGE,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_INSUFFICIENT_MEMORY,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_FS_ERROR,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_ORIGINAL_FILE_LOST,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_INSUFFICIENT_RESOURCE,
    SRV_DA_SCR_SELECT_STORAGE_CAUSE_UNEXPECTED_ERROR,
	SRV_DA_SCR_SELECT_STORAGE_CAUSE_DONE,

    SRV_DA_SCR_SELECT_STORAGE_CAUSE_END_OF_ENUM
} srv_da_scr_select_storage_cause_enum;


typedef struct
{
    U16     drv;
    srv_da_storage_enum     storage;
    
    U16     filename[MMI_DA_MAX_FILENAME_INPUT_LEN + 1];
    U16     folder[SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 2]; /* Includes tail '\' */
    U16     fileext[SRV_FMGR_PATH_MAX_FILE_EXT_LEN + 1];
    
    U32     filesize;                   /* for checking capacity, 0 if not checking */
    const U16 *original_filepath;         /* if provide original filepath, overwrite will not prompt if match */
    
    MMI_BOOL (*filecheck_func)(const U16* filepath, MMI_BOOL bpopup);

    MMI_BOOL    select_storage;             /* user select storage */
    MMI_BOOL    select_filename;            /* user input filename, if MMI_TRUE will check overwrite */

    MMI_BOOL    skip_exist_check;

} srv_da_storage_parameter_struct;


typedef struct
{
    U32 secs_remain;
    U32 fileSize;
    U32 currSize;
    U16 processing_string_id;
} srv_da_item_progress_struct;

typedef struct
{
    srv_da_job_struct *job;
    U16 *dest_path;
    void *select_storage_instance;
    MMI_BOOL can_reject;
} srv_da_job_async_move_arg_struct;


/* ----------------------------- Common UI ----------------------------------*/

typedef void (*srv_da_abort_callback_type)(srv_da_job_struct* job, U16 string_id);
typedef MMI_BOOL (*srv_da_job_match_funcptr_type)(const srv_da_job_struct* job, U32 criteria);

typedef void (*srv_da_init_module_funcptr_type)     (void);

typedef U32  (*srv_da_job_get_progress_funcptr_type)(const srv_da_job_struct* job,
                                                     srv_da_item_progress_struct *info);  // return percentage
typedef U16  (*srv_da_job_get_id_funcptr_type)      (const srv_da_job_struct* job);
typedef void (*srv_da_job_get_setting_funcptr_type) (const srv_da_job_struct* job, srv_da_setting_struct *setting_data);

typedef MMI_BOOL (*srv_da_job_free_data_funcptr_type)   (srv_da_job_struct* job);
typedef void (*srv_da_job_stop_funcptr_type)        (srv_da_job_struct* job, S32 prev_state, MMI_BOOL pauseOnly,
                                                     srv_da_abort_callback_type end_callback);
typedef void (*srv_da_job_dispatch_funcptr_type)    (const srv_da_job_struct* job);

typedef void (*srv_da_job_resume_funcptr_type)      (srv_da_job_struct* job);
typedef S32  (*srv_da_job_move_funcptr_type)        (srv_da_job_struct* job, U16* new_filepath);

typedef void (*srv_da_auth_callback_type)(U32 criteria, U16* username, U16* password);

typedef struct srv_da_module_funcptr_table_s
{
    /* Init module */
    srv_da_init_module_funcptr_type         init;

    void (*get_name)(const srv_da_job_struct *job, U16 *buffer, U32 buffer_len);

    const U16* (*get_filepath)(const srv_da_job_struct *job);
    
    srv_da_job_get_progress_funcptr_type    get_progress;   /* get job progress */
    srv_da_job_get_id_funcptr_type          get_id;         /* get job unique id */
    srv_da_job_get_setting_funcptr_type     get_setting;

    /* If returns MMI_TRUE, the description can be provided by get_object_desc() */
    MMI_BOOL (*is_object_desc_available)(const srv_da_job_struct *job);
    
    void (*get_object_desc)(const srv_da_job_struct *job,
        U16* string_buffer,
        const U32 buffer_len);
    
    void (*get_status_desc)(
        const srv_da_job_struct *job,
        U16 *string_buffer[],       /* string_buffer[num_of_buffers] */
        const U32 buffer_len,       /* Max length per buffer(line) */
        const U32 num_of_buffers,   /* Number of buffers(lines) */
        U32 *num_of_filled);        /* Number of buffers(lines) filled */
    
    const S8* (*get_infoURL)(const srv_da_job_struct* job);

    /* Operation API */
    srv_da_job_free_data_funcptr_type       free;
    srv_da_job_stop_funcptr_type            stop;
    srv_da_job_dispatch_funcptr_type        dispatch;

    void (*assign_filepath)(srv_da_job_struct* job, const U16* new_filepath);

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    srv_da_job_resume_funcptr_type          resume;
#endif
} srv_da_module_funcptr_table;


extern void srv_da_adp_show_choice_screen (
    MMI_BOOL show_cancel_ask,
    void *arg,
    U16  arg_size,
    void (*lsk_hdlr)(void *arg, U16 *filepath),
    void (*rsk_hdlr)(void *arg),
    void (*delete_hdlr)(void *arg),
    MMI_BOOL set_instance);

extern srv_da_job_struct* srv_da_get_first_job_of_type_in_state (U16 state, U16 job_type);
extern srv_da_job_struct* srv_da_job_get_job_by_type_and_id(U32 id, U32 type);
extern void srv_da_msg_init (void);
extern void srv_da_adp_close_app (void);
extern srv_da_job_struct * srv_da_get_list_job(void);
extern void srv_da_set_curr_job_in_setuping_state (void *arg);
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
extern mmi_ret srv_da_http_display_job_list_callback(mmi_event_struct *evt);
#endif

/* ----------------------------- Screen ----------------------------------*/
typedef void (*srv_da_confirm_funcptr_type)(U32 criteria);
typedef void (*srv_da_confirm_format_msg_funcptr_type)(U32 criteria, U16* buffer);

typedef srv_da_acceptance_enum (*srv_da_scr_storage_callback_type)(
    U32 arg,
    U16* filepath,
    MMI_BOOL canback,
    MMI_BOOL canpopup,
    void *instance);
    
typedef srv_da_job_struct* (*srv_da_scr_storage_filecheck_funcptr_type)(U16* filepath, MMI_BOOL bpopup);
    
typedef void (*srv_da_scr_auth_callback_type)(U32 criteria, U16*, U16*, MMI_BOOL in_delete);

typedef void (*srv_da_scr_abort_funcptr_type)(U32 criteria, MMI_BOOL in_delete);



/****************************************************************************
 *                       Global Function
 *****************************************************************************/
extern MMI_BOOL srv_da_job_is_pgdl(U32 arg);
extern U32 srv_da_get_current_utc_time (void);
extern U32 srv_da_get_current_time(void);
extern U32 srv_da_get_current_job_data_size(U32 arg);
#if defined(BROWSER_SUPPORT)
extern void srv_da_recv_wap_file_dl_ind(void *MsgStruct, int mod_src, void *ilm_p);
extern void srv_da_recv_wap_file_dl_progress_ind(void *MsgStruct, int mod_src, void *ilm_p);
extern void srv_da_recv_wap_file_stop_rsp(void *MsgStruct, int mod_src, void *ilm_p);
extern void srv_da_send_wap_file_dl_res(S32 session_id, S32 error, U16* filepath);
extern void srv_da_send_wap_file_dl_progress_res(S32 session_id, U32 seq_num);

extern void srv_da_recv_nw_switch_ind(void *MsgStruct, int mod_src, void *ilm_p);
extern void srv_da_recv_wap_notify_ind(void *MsgStruct, int mod_src, void *ilm_p);
#endif
#ifdef __MMI_DA_PREFETCHING_SCREEN__
extern void srv_da_http_cancel_prefetch_rsp_hdlr(void *msg);
extern void srv_da_http_prefetch_aborted_ind_hdlr(void *msg);
#endif
#ifdef __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__
extern void srv_da_suspend_and_resume_all_downloads_with_browser (void);
#endif
extern U32 srv_da_get_current_job_acc_id (U32 s);
extern MMI_BOOL srv_da_http_dl_job_match_url_func(const srv_da_job_struct* job, U32 criteria);
/* ----------------------------- Common UI ---------------------------------*/
extern void srv_da_init_job_list(void);
extern srv_da_setting_struct* srv_da_get_setting_buffer(void);
extern MMI_BOOL srv_da_job_match_state_func(const srv_da_job_struct* job, U32 criteria);
extern srv_da_job_struct *srv_da_search_job(U32 criteria);
extern srv_da_job_struct* srv_da_job_create(srv_da_job_type_enum type, void *obj);
extern srv_da_job_struct* srv_da_job_create_ex(srv_da_job_type_enum type, void *obj);
extern MMI_BOOL srv_da_job_cancel(srv_da_job_struct* job);  // Cancel before started (state = INIT)
extern MMI_BOOL srv_da_job_start(srv_da_job_struct* job);   // Start a job (state = DOWNLOADING)
extern MMI_BOOL srv_da_job_destroy(srv_da_job_struct *job);
#ifndef MMI_DA_PLUTO_SLIM
extern U32 srv_da_count_special_job(srv_da_job_match_funcptr_type func, U32 criteria);
#endif
extern void srv_da_job_resume(srv_da_job_struct* job);
extern void srv_da_curr_job_do_abort(srv_da_job_struct *job);
extern MMI_BOOL srv_da_job_match_job_type_func(const srv_da_job_struct* job, U32 criteria);
extern srv_da_job_struct* srv_da_job_get_job_by_id(U32 id);
extern U16 srv_da_job_get_new_unique_id (void);
extern srv_da_scr_select_storage_cause_enum  srv_da_decide_filepath_auto (
	U32 arg, 
	srv_da_storage_parameter_struct *para, 
	srv_da_action_enum job_type,
	srv_da_scr_storage_callback_type callback);
extern void srv_da_decide_yt_filepath (
	U32 arg, 
	srv_da_storage_parameter_struct *para, 
	srv_da_action_enum job_type,
	srv_da_scr_storage_callback_type callback);
extern U32 srv_da_get_last_error(void);
#ifdef __SIM_HOT_SWAP_SUPPORT__
extern void srv_da_adp_on_sim_plug_out(mmi_sim_enum sim_id);
extern MMI_BOOL srv_da_wps_can_switch_to_wlan (void);
#endif
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
extern void srv_da_job_set_notify_callback(srv_da_job_struct* job, srv_da_dl_report_callback cb);
#endif

/* find the first job that MMI_TRUE == func(criteria) */
extern srv_da_job_struct* srv_da_find_job(srv_da_job_match_funcptr_type func, U32 criteria);
//extern srv_da_job_struct* srv_da_find_job_by_filepath(const U16* filepath, MMI_BOOL bpopup);   // check if there is already a job
extern MMI_BOOL srv_da_does_job_with_filepath_exist(const U16 *filepath, MMI_BOOL can_popup_msg);
extern U32 srv_da_count_job(srv_da_job_match_funcptr_type func, U32 criteria);

extern MMI_BOOL srv_da_job_match_id_func(const srv_da_job_struct* job, U32 criteria);

extern MMI_BOOL srv_da_is_job_valid(const srv_da_job_struct* job);

extern void srv_da_copy_setting(srv_da_job_struct* job, const srv_da_setting_struct* setting);

extern U16 srv_da_job_get_title_icon(const srv_da_job_struct *job);
extern MMI_BOOL srv_da_is_popup_allowed(void);
extern MMI_BOOL srv_da_is_new_screen_allowed(void);
extern MMI_BOOL srv_da_can_receive_file(void);
extern void srv_da_update_job_status(srv_da_job_struct* job);
extern void srv_da_suspend_all_job(srv_da_error_enum cause);



extern void srv_da_set_allow_to_trigger_connection(MMI_BOOL allow);
extern MMI_BOOL srv_da_is_allowed_to_trigger_connection(void);
extern void srv_da_adp_set_active_download_confirm_screen(srv_da_job_struct *job, U16 instance_id);
extern void srv_da_suspend_and_resume_all_download (void);
extern void srv_da_resume_all_paused_list(void);
#ifdef MMI_DA_WLAN_PREFER_SUPPORT

extern void srv_da_wap_reset_bearer_type (void);
extern MMI_BOOL srv_da_is_bearer_switching (void);
extern void srv_da_reset_bearer_switching(void);

extern U8 srv_da_wps_reset_app_id(void);
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
extern kal_int8 srv_da_open_bearer(U32 s);
#if defined(BROWSER_SUPPORT)
extern srv_brw_profile_content_struct* srv_da_wps_get_bearer_profile(U32 s);
#endif

extern void srv_da_job_get_setting (const srv_da_job_struct *job, srv_da_setting_struct *setting);
extern U16 srv_da_get_job_id (const srv_da_job_struct *job);


#ifdef __DRM_SUPPORT__

/* ----------------------------- DRM API ---------------------------------*/

typedef struct
{
    MMI_BOOL is_archive;
    MMI_BOOL waiting;
} srv_da_drm_result_info_struct;

typedef struct
{
    S32 result;
    const applib_mime_type_struct *mime_type;
    srv_da_drm_result_info_struct result_info;
    srv_da_action_enum action;
} srv_da_drm_popup_info;

#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
void srv_da_job_drm_save_as(srv_da_job_struct *job, drm_method_enum drm_method);
#endif

S32 srv_da_move_as_new_type(
    const U16 *src_filepath,
    const U16 *new_folder,
    const U16 *filename_and_ori_ext, /* contains extension name */
    const applib_mime_type_struct *mime_type,
    U16 *new_filepath_after_moved);

extern MMI_BOOL srv_da_job_update_content_by_drm_processing_result(
    srv_da_job_struct *job,
    srv_da_action_enum action,
    S32 result,
    const U16 *new_filepath,
    const applib_mime_type_struct *new_mime_type,
    const srv_da_drm_result_info_struct *info);

extern void* srv_da_drm_process(
    const U16 *filepath,
    const applib_mime_type_struct *mime_type,
    MMI_BOOL *need_to_wait,
    void *arg,
    void (*result_callback)(
        void *arg,
        S32 result,
        const U16 *new_filepath,
        const applib_mime_type_struct *new_mime_type,
        drm_method_enum method,
        const srv_da_drm_result_info_struct *info));
        
extern MMI_BOOL srv_da_drm_process_cancel(void *session);

extern void srv_da_drm_show_process_info(
    S32 result,
    const applib_mime_type_struct *mime_type,
    const srv_da_drm_result_info_struct *info,
    srv_da_action_enum action);
        
extern void* srv_da_drm_wait_for_rights(
    const U16 *filepath,
    U32 time_to_wait,
    void *arg,
    void (*rights_arrived_callback)(void *arg),
    void (*fail_to_wait_callback)(void *arg, drm_sd_expiry_type_enum cause, MMI_BOOL can_continue_waiting, MMI_BOOL *continue_waiting));
    
extern void srv_da_drm_wait_for_rights_cancel(void *session);

extern MMI_BOOL srv_da_drm_has_rights(const U16 *filepath, const applib_mime_type_struct* mime_type);

extern void srv_da_drm_presetting(
    const srv_da_presetting_param_struct *param,
    srv_da_presetting_struct *presetting);

extern void srv_da_drm_content_setting(
    S32	session_id,
    S32	mime_type,
    S32	mime_subtype,
    S32 action,
    U32	filesize,
    PS8	url,
    PS8	mime_type_string,
    U32	content_len,
    PS8	content,
    srv_da_setting_struct *setting);

extern void srv_da_drm_extract_info_from_http_header(
    const S8 *header,
    S32 *time_to_wait_for_rights);

extern MMI_BOOL srv_da_is_drm_require_processing( const applib_mime_type_struct *type );
extern MMI_BOOL srv_da_is_drm_file( const applib_mime_type_struct *type );
extern MMI_BOOL srv_da_is_drm_right( const applib_mime_type_struct *type );
extern MMI_BOOL srv_da_is_drm_content( const applib_mime_type_struct *type );
extern MMI_BOOL srv_da_is_drm_roap( const applib_mime_type_struct *type );

#endif

/* ----------------------------- Trace ---------------------------------*/
extern void srv_da_trace_func(S32 func_enum);
extern void srv_da_trace_func_ex(S32 func_enum, S32 p1, S32 p2, S32 p3);
extern void srv_da_trace_endfunc(S32 func_enum);
extern MMI_BOOL srv_da_free_job_and_remove_screens_ex(srv_da_job_struct *job);


/* ----------------------------- Config ---------------------------------*/
extern const srv_da_type_handler_struct* srv_da_search_mime_type_handler(const applib_mime_type_struct * type);
extern UI_string_ID_type srv_da_search_mime_type_string(const applib_mime_type_struct * type);

extern const srv_da_type_handler_struct* srv_da_get_default_mime_type_handler(void);

extern MMI_BOOL srv_da_setting_check(const srv_da_setting_struct *setting);

/* Hook_patch */
extern S32 srv_da_search_hook_handler(const applib_mime_type_struct *type, 
                                      S32 s_index, 
                                      srv_da_hook_dispatch_hdlr* p_hdlr);

extern MMI_BOOL srv_da_dispatch_to_app(
    S32 session_id, 
    const applib_mime_type_struct *mime_type,
    srv_da_action_enum action, 
    U16 *filepath, 
    S8 *url,
    const S8 *mime_type_string,
    const srv_da_type_handler_struct *type_hdlr);

/* ----------------------------- Utility ---------------------------------*/
extern void srv_da_util_init(void);
extern module_type wap_get_service_module(kal_uint32 msg_id);
extern void srv_da_send_ilm(void *local_para_ptr, void *peer_buff_ptr, msg_type msg_id, S32 dst_id);

#define srv_da_send_ilm_to_wap(local_para_ptr, peer_buff_ptr, msg_id) \
    srv_da_send_ilm((local_para_ptr), (peer_buff_ptr), (msg_id), wap_get_service_module(msg_id))

extern MMI_BOOL srv_da_is_in_voice_call(void);

extern srv_da_error_enum  srv_da_wap_error_to_internal_error(S32 error);
extern S32  srv_da_util_state_transfer(srv_da_job_state_enum state);

extern U16  srv_da_util_get_wap_error_string_id(S32 dls_error);

/* access file system */
extern MMI_BOOL srv_da_util_check_free_space(U16 drv, U64 need_space);
extern MMI_BOOL srv_da_util_is_drive_available(U16 drv);
extern U32 srv_da_get_max_number_of_drives(void);
extern U32 srv_da_get_number_of_available_drives(void);
extern S32  srv_da_util_create_file_dir(PU16 filepath, MMI_BOOL is_filepath);
extern S32 srv_da_util_create_yt_file_dir(U16 *filepath, MMI_BOOL is_filepath);
extern MMI_BOOL srv_da_util_does_file_exist(const U16* path);
extern U32  srv_da_util_get_file_size(const U16* filepath);
extern S32 srv_da_util_file_delete(const U16* filepath);
extern S32 srv_da_util_file_move(const U16 *src_path, const U16 *dest_path, U32 flags);

/* filename related */
extern U16 *srv_da_util_get_extension(U16* filepath);
extern S8 *srv_da_util_get_extension_ascii(S8* filepath);
extern U16 *srv_da_util_get_filename(U16 * filepath);
extern S8  *srv_da_util_get_filename_ascii(S8 *filepath);
extern MMI_BOOL srv_da_util_get_temp_filename(U16* pathname, U16* filename, U32 filename_len);
extern U16* srv_da_util_get_clear_filepath(
    U16 *filepath,
    MMI_BOOL (*is_in_use)(const U16* filepath, MMI_BOOL do_popup));
extern U16* srv_da_util_process_filepath_to_be_displayed(U16 *filepath);

extern U16* srv_da_util_pathname_replace_ex(U16* old_filepath, U16* folder, U16* filename, const applib_mime_type_struct* mime_type);

extern MMI_BOOL srv_da_util_is_valid_filename(U16 *filepath);
S8* srv_da_util_gen_http_header_to_resume(S8 *header_buffer, const S8 *etag, U32 from_bytes);

extern applib_mime_type_struct* srv_da_util_lookup_mime_type(U8* mime_string, U16* ext,
                                                             applib_mime_type_enum mime_type,
                                                             applib_mime_subtype_enum mime_subtype);
extern applib_mime_type_struct* srv_da_util_lookup_mime_type_ascii(U8* mime_string, S8* ext,
                                                             applib_mime_type_enum mime_type,
                                                             applib_mime_subtype_enum mime_subtype);
extern MMI_BOOL srv_da_util_is_supported_by_fmgr(const WCHAR *filepath);
extern void srv_da_extract_filepath(U16* filepath, U16* filename, U16* fileext);
extern void srv_da_extract_filepath_ascii(S8* filepath, U16* filename, U16* fileext);
extern void srv_da_extract_filename_from_url(const S8 *url, U16 *filename, U16 *fileext);
extern void srv_da_extract_filename_from_url_ext(const S8 *url, U16 *filename);
extern U16 *srv_da_util_extract_folder(const U16 *path, U16 *folder);
extern S8* srv_da_util_extract_from_header(const S8 *header, const S8 *tag, S8 *value_buffer, U32 buffer_len);
extern MMI_BOOL srv_da_util_atoi(const S8 *str, S32 *value);
extern U16* srv_da_util_strcpy_and_truncate(U16 *dest, const U16 *src, U32 dest_buffer_len);
extern MMI_BOOL srv_da_util_decide_drive_to_save_file(
    const U16 *original_filepath,
    U32 filesize,
    U16 *drive,
    srv_da_storage_enum *storage);

extern void srv_da_util_async_move(
        U16 *src_path,
        U16 *dest_path,
        void *arg, /* Pass to result_callback */
        void (*result_callback)(void *arg, S32 error_code));
        
extern void srv_da_util_cancel_async_move(void);
extern void srv_da_util_trigger_proc(void (*func)(void *arg), void *arg);
extern void srv_da_util_trigger_proc_ext(void (*func)(void *arg_p, S32 arg_v), void *arg_p, S32 arg_v);
extern U32  srv_da_util_get_estimated_time(U32 file_size);
extern S8  *srv_da_util_format_size_total(U32 curr, U32 total);
extern S8  *srv_da_util_format_size(U64 size);
extern U16  srv_da_util_get_icon_from_appid(U16 app_id);
extern U16  srv_da_util_get_appid_from_icon(U16 icon_id);
extern U32 srv_da_util_ticks_to_milli_seconds(U32 ticks);
extern U16 srv_da_timer_triggered_proc_set(U32 ms, void (*func)(void *arg, S32 arg_v), void *arg_p, S32 arg_v);
extern void srv_da_timer_triggered_proc_cancel(U16 timer_id);


/* ------------------------------ Push ------------------------------ */


typedef struct _srv_da_push_item_struct
{
    U16                 unique_id;
    
    const applib_mime_type_struct *mime_type;
    const srv_da_type_handler_struct *type_handler;
    
    U16                 *filepath;
    U16                 *filename;
    S8                  *url;
    S8                  *mime_type_string;
    U32                 file_length;
    U32                 header_len;
    S8                  *header;
    srv_da_action_enum  action;

    MMI_BOOL            is_normal_save;
    MMI_BOOL            user_selected_storage;

    /* DRM */
#ifdef __DRM_SUPPORT__
    drm_method_enum     drm_method;
    void                *drm_process_session;
#endif

    srv_da_extra_info_struct *extra_info;
    srv_da_ui_setting_struct ui;
#if defined (__MMI_NCENTER_SUPPORT__)
	vsrv_notification_handle notify_handle;
#endif
} srv_da_push_item_struct;

typedef struct
{
    U16 unique_id;
    srv_da_push_item_struct *item;
    U16 *dest_path;
    void *select_storage_instance;
    MMI_BOOL can_reject;
} srv_da_push_async_move_arg_struct;


typedef struct srv_da_push_item_element_struct_s
{
    srv_da_push_item_struct *item;
    struct srv_da_push_item_element_struct_s *next;
} srv_da_push_item_element_struct;


typedef struct srv_da_push_item_list_struct_s
{
    srv_da_push_item_element_struct *head;
    U32 number;
} srv_da_push_item_list_struct;

/****************************************************************************
 * Constants
 ****************************************************************************/

#define SRV_DA_PUSH_MAX_PUSH_ITEM_ELEMENT_NUM   \
    (SRV_DA_MAX_PUSHES_IN_QUEUE_NUM + SRV_DA_MAX_PUSHES_IN_PROCESSING_NUM * 2)


/****************************************************************************
 * Macro
 ****************************************************************************/

#define SRV_DA_PUSH_ID(item_p) DA_MAKE_UNIQUE_ID_EX(SRV_DA_JOB_TYPE_PUSH, (item_p)->unique_id)

/*****************************************************************************
 * FUNCTION
 *  srv_da_push_get_number_of_elements
 * DESCRIPTION
 *  Get number of elements of the list.
 * PARAMETERS
 *  list_p      [IN] srv_da_push_item_list_struct*
 * RETURNS
 *  Number of elements
 *****************************************************************************/
#define srv_da_push_get_number_of_elements(list_p) ( (const U32)((list_p)->number) )


extern void srv_da_push_recv_dispatch_file_req(void *MsgStruct, int mod_src, void *ilm_p);
extern void srv_da_push_init(void);
extern const S8* srv_da_push_get_header(S32 session_id, U32* header_len);
extern void srv_da_push_enter_idle_screen_callback(void);
extern U32 srv_da_push_get_number_of_processing_items(void);


/* ------------------------------ HTTP ------------------------------ */
const S8* srv_da_http_get_header(srv_da_job_struct *job, U32* header_len);

typedef struct
{
    U16     unique_id;

    /* attribute provide by lower layer */
    S8      *url_ptr;
    S8      *mime_type_ptr;
    U32     size;

    S8      *content;
    U32     content_len;
    S8      *header;
    U32     header_len;

    /* Values included in the HTTP header */
    S8      *etag; /* Etag for resumption */
    

    /* run-time variable */
    U16	    *filepath;  /* full pathname */
    S32	    session_id;
    U32     curr_size;
    U32     dl_start_tick;
    U32     dl_latest_tick;

    srv_da_abort_callback_type          abort_callback;

#ifdef __HTTP_INTERFACE__
    srv_da_wps_session_handle      session;
	srv_da_wps_session_struct     *session_handle;
#endif
	U8 status;
	U8 seq_num;

#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT

/* Need to wrap the code */
	U32 acc_id;
	srv_da_http_progress_funcptr_type dl_progress_cb;
	MMI_BOOL show_confirm;
	MMI_BOOL need_sent;
	MMI_BOOL http_flag;
	void *user_data;
	srv_da_setting_hdlr setting_hdlr;
	srv_da_dispatch_hdlr dispatch_callback;
#endif
/*For Authentication */
	U16         *auth_username;
    U16         *auth_password;
    MMI_BOOL    auth_is_info_valid; 

    /* DRM */
#ifdef __DRM_SUPPORT__
    drm_method_enum drm_method;
#endif
    S32     time_to_wait_for_rights; /* -1 represents the header does not contain this value */
    srv_da_drm_status_enum drm_status;
    void    *drm_process_session;
    void    *drm_wait_for_rights_session;
   
} srv_da_normal_dl_job_struct;


#ifdef __MMI_OMA_DD_DOWNLOAD__
/* ------------------------- OMA Download 1.0 ------------------------ */
extern void srv_da_oma_process_dd_file(S32 session_id, S32 mime_type, S32 mime_subtype, S32 action_type, PU16 filename,
                                       PS8 download_url,PS8 mime_type_string);
extern MMI_BOOL srv_da_oma_is_oma_processing_required (const applib_mime_type_struct *type);
extern void srv_da_oma_dd_presetting(
    const srv_da_presetting_param_struct *param,
    srv_da_presetting_struct *presetting);
extern void srv_da_oma_dd_setting(S32 session_id, S32 mime_type, S32 mime_subtype, S32 action, 
                               U32 filesize, PS8 url, PS8 mime_type_string, U32 content_len,
                               PS8 content, srv_da_setting_struct * setting);
extern srv_da_job_struct* srv_da_oma_find_job_by_dd(S8* dd_url);

extern void srv_da_oma_send_report_stop_retrying(void);

extern void srv_da_oma_fill_message_string(void *arg, U16 *buffer, U32 buffer_len);
extern void srv_da_oma_confirm_download_callback(void *arg, U16 *filepath);
extern void srv_da_oma_download_cancel_callback(void *arg);
extern void srv_da_oma_delete_screen_callback(void *arg);
extern void srv_da_oma_get_setting(const srv_da_job_struct *job, srv_da_setting_struct *setting_data);
extern void srv_da_oma_decide_default_filename(
    const srv_da_job_struct *job,
    const srv_da_setting_struct *setting_data,
    U16 *filename,
    U16 *fileext);

/* ------------------------- OMA Download 2.0 ------------------------ */
extern void srv_da_oma_process_dd2_file(S32 session_id, S32 mime_type, S32 mime_subtype, S32 action_type, PU16 filename,
                                        PS8 download_url,PS8 mime_type_string);
extern void srv_da_oma2_setting(S32 session_id, S32 mime_type, S32 mime_subtype, S32 action, 
                                U32 filesize, PS8 url, PS8 mime_type_string, U32 content_len,
                                PS8 content, srv_da_setting_struct * setting);
#endif /* __MMI_OMA_DD_DOWNLOAD__ */
extern void srv_da_adp_close_app (void);
/* PDP Switch Begin  */
//#ifdef __COSMOS_MMI_PACKAGE__
extern mmi_ret srv_da_bearer_available(mmi_event_struct *evt);
extern mmi_ret srv_da_bearer_unavailable(mmi_event_struct *evt);
extern void srv_da_pdp_switch_cause(MMI_BOOL flag);
extern MMI_BOOL srv_da_is_pdp_switching(void);
//#endif
/* PDP Switch End */

#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
extern void srv_da_http_dl_get_setting(const srv_da_job_struct* job, srv_da_setting_struct *setting_data);
#endif
extern srv_da_job_struct* srv_da_get_curr_job_in_setuping_state (void);
extern U32 srv_da_get_current_job_state (U32 arg);
extern void srv_da_http_dl_get_setting_ext(const srv_da_job_struct* job, srv_da_setting_struct *setting_data);
extern void srv_da_http_dl_inform_app(srv_da_job_struct *arg);
extern void srv_da_set_job_content(srv_da_job_struct * job, S8 *buffer);
extern void srv_da_set_job_data_length(srv_da_job_struct * job, U32 len);
extern void srv_da_job_set_reporting(srv_da_job_struct * job, MMI_BOOL flag);
extern MMI_BOOL srv_da_get_http_flag(U32 arg);
extern void srv_da_set_http_flag(U32 arg, MMI_BOOL flag);
extern srv_da_job_struct* srv_da_get_current_job (U32 arg);
extern U32 srv_da_get_current_job_type (U32 arg);
#ifndef MMI_DA_PLUTO_SLIM
extern MMI_BOOL srv_da_does_job_exist(const srv_da_job_struct* comp_job);
#endif
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
#ifdef __MMI_DA_RESUME__
extern void srv_da_save_session_info(U32 arg,srv_da_wps_session_struct *session_handle, U8 seq_num, U8 status);
extern srv_da_wps_session_handle srv_da_get_job_data_session(U32 arg);
#endif
extern void srv_da_set_current_job_need_sent(U32 arg, MMI_BOOL flag);

extern MMI_BOOL  srv_da_get_current_job_need_sent (U32 arg);
#endif

extern MMI_BOOL srv_da_util_decide_drive_yt_save_file(
    const U16 *original_filepath,
    U32 filesize,
    U16 *drive,
    srv_da_storage_enum *storage);
extern void srv_da_push_get_dir (void* arg, U16 *dir);
#ifdef __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__
extern MMI_BOOL srv_da_http_is_browser_job (srv_da_job_struct *job);
#endif

/*..........DLAgentSrvInterface.c interface...........*/

extern void srv_da_adp_display_job_list(srv_da_job_struct* job, MMI_BOOL check_complete);
extern void srv_da_adp_show_user_auth_screen (U32 arg, srv_da_auth_callback_type auth_callback);
extern void srv_da_adp_display_select_storage (U32 arg, srv_da_storage_parameter_struct *para, srv_da_action_enum job_type);
extern void srv_da_adp_show_ncenter (void *arg, U16 type);
extern void srv_da_adp_set_active_select_storage_instance (void *instance);
extern void srv_da_adp_display_job_detail(srv_da_job_struct* job);
extern MMI_BOOL srv_da_find_java_job(applib_mime_subtype_enum criteria);
extern void srv_da_adp_click_job(srv_da_job_struct *job);
extern void srv_da_adp_popup_for_error_code_with_callback (U16 error_code, mmi_proc_func callback);
extern void srv_da_adp_popup_wps_aborted (srv_da_job_struct *job, S32 error_code);
extern void srv_da_adp_scr_progressing_close(U16 screen_id);
extern void srv_da_adp_handle_push_move(void *arg, S32 error_code);
void srv_da_adp_show_progressing(
    srv_da_action_scr_enum screen_id,
    U16 title_string_id,
    U16 title_icon_id,
    U16 message_id,
    MMI_BOOL cancel_rsk, /* Show RSK "Cancel" */
    void *arg,
    void (*cancel_callback)(void *arg, MMI_BOOL is_deleted));
extern void srv_da_adp_handle_wps_http_response_callback (U32 job, U16 status, MMI_BOOL is_error);
extern srv_da_scr_select_storage_cause_enum srv_da_select_storage_final(srv_da_storage_parameter_struct *para, U16 *filepath);
extern srv_da_scr_select_storage_cause_enum srv_da_select_storage_final_ext(srv_da_storage_parameter_struct *para, U16 *filepath);
/*....................................................*/
#ifdef __HTTP_INTERFACE__
extern U32 srv_da_wps_get_account_id(void);
extern U8 srv_da_wps_get_app_id(void);
extern void srv_da_wps_set_account_id(U32 net_id);
#endif
//#endif /* __COSMOS_MMI_PACKAGE__ */
#endif /* DOWNLOAD_AGENT_PROT_H */

