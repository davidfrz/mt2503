/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2008
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  vrt_system.h
 *
 * Project:
 * --------
 *  Venus Rendering Task
 *
 * Description:
 * ------------
 *  Provide system information for porting.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#ifndef __VRT_SYSTEM_H__
#define __VRT_SYSTEM_H__

#ifdef __cplusplus
extern "C"
{
#endif

/***************************************************************************** 
 * Include
 *****************************************************************************/
#include "vrt_datatype.h"
#include "vrt_base_allocator.h"

#include "kal_trace.h"
#include "MMIDataType.h"


/***************************************************************************** 
 * Define
 *****************************************************************************/
#define VRT_SYS_RENDER_MEMORY_FLAG_DEFAULT              (0)
#define VRT_SYS_RENDER_MEMORY_FLAG_DYNAMIC_CACHEABLE    (1 << 0)

#define VRT_SYS_RENDER_MEMORY_SET_CONFIG(m, t, p, s, f) \
do                          \
{                           \
    (m)->type = t;         \
    (m)->mem_ptr = p;   \
    (m)->size = s;         \
    (m)->flag = f;         \
} while (0);

/* For general trace class and level */
#define VRT_FUNC     TRACE_FUNC
#define VRT_STATE    TRACE_STATE
#define VRT_INFO     TRACE_INFO
#define VRT_WARNING  TRACE_WARNING
#define VRT_ERROR    TRACE_ERROR

/* For detail trace class and level */
#define VRT_PERFORMANCE    TRACE_GROUP_1
#define VRT_PERFORMANCE2   TRACE_GROUP_2
#define VRT_INFO2          TRACE_GROUP_3
#define VRT_WARNING2       TRACE_GROUP_4
#define VRT_ERROR2         TRACE_GROUP_5

/* For verbose trace class and level */
#define VRT_FUNC3    TRACE_GROUP_6
#define VRT_STATE3   TRACE_GROUP_7
#define VRT_INFO3    TRACE_GROUP_8
#define VRT_WARNING3 TRACE_GROUP_9
#define VRT_ERROR3   TRACE_GROUP_10

/*
 * VRT related uses this macro to log.
 * For example:
 *  VRT_LOG(VRT_INFO, XXX);
 */
// #define VRT_LOG    kal_trace
// TODO: enable VRT LOG when option.mak is MODIFIED.
#define VRT_LOG(trc_class, ...) vrt_log(trc_class, __VA_ARGS__)

/***************************************************************************** 
 * Typedef
 *****************************************************************************/
typedef enum
{
    VRT_SYS_RENDER_MEMORY_TYPE_TEMP,
    VRT_SYS_RENDER_MEMORY_TYPE_CACHE,
    VRT_SYS_RENDER_MEMORY_TYPE_END_OF_ENUM
} vrt_sys_render_memory_type_enum;

typedef struct 
{
    vrt_u32 type;
    void    *mem_ptr;
    vrt_u32 size;    
    vrt_u32 flag;
} vrt_sys_render_memory_config_struct;

/* screen rotation enum */
typedef enum
{
    VRT_SYS_SCREEN_ROTATE_0,
    VRT_SYS_SCREEN_ROTATE_90,
    VRT_SYS_SCREEN_ROTATE_180,
    VRT_SYS_SCREEN_ROTATE_270,
    VRT_SYS_SCREEN_ROTATE_MIRROR_0,
    VRT_SYS_SCREEN_ROTATE_MIRROR_90,
    VRT_SYS_SCREEN_ROTATE_MIRROR_180,
    VRT_SYS_SCREEN_ROTATE_MIRROR_270,
    VRT_SYS_SCREEN_ROTATE_END_OF_ENUM
} vrt_sys_screen_rotate_enum;

/* memory provider */
typedef struct
{
    void (*memory_init)(vrt_sys_render_memory_config_struct *, vrt_u32 , vrt_u32 *);
    void (*memory_deinit)();

    vrt_u8 *global_cache_buf;
    vrt_u32 global_cache_size;
} vrt_mem_provider_struct;

typedef vrt_mem_provider_struct *vrt_mem_provider_handle;


/* user pool */
#define VRT_CACHE_USER_POOL_FLAG_CACHEABLE                   (1 << 1)
#define VRT_CACHE_USER_POOL_FLAG_NON_CACHEABLE               (1 << 2)
#define VRT_CACHE_USER_POOL_FLAG_DEFAULT                     (VRT_CACHE_USER_POOL_FLAG_CACHEABLE | VRT_CACHE_USER_POOL_FLAG_NON_CACHEABLE)

/*
 * The structure of vrt_canvas_entry() parameters
 */
typedef struct
{
    /* Flags to entry */
    vrt_flag_type flags;
    /* app id */
    vrt_u16 app_id;
    /* allocator for VRT context pool*/
    vrt_allocator_handle allocator;
    /* asm config cache size */
    vrt_u32 asm_cache_size;
    /* cache limit size */
    vrt_u32 cache_limit_size;
} vrt_canvas_entry_param_struct;


/*
 * The structure of vrt_canvas_leave() parameters
 */
typedef struct
{
    /* Flags to leave */
    vrt_flag_type flags;
} vrt_canvas_leave_param_struct;


/*
 * The enum of image info status
 */
typedef enum
{
    VRT_SYS_IMAGE_INFO_STATE_UNLOAD = 0,    /*file not be read yet*/
    VRT_SYS_IMAGE_INFO_STATE_LOADED,        /*file has been opened and read successful*/
    VRT_SYS_IMAGE_INFO_STATE_ERROR,         /*file has been opened but read failed*/
    VRT_SYS_IMAGE_INFO_STATE_END_OF_ENUM
} vrt_sys_image_info_state_enum;


/*
 * The structure of image file info parameters
 */
typedef struct
{
    /* state */
    vrt_sys_image_info_state_enum state;
    /* image type */
    vrt_u8 type;
    /* size of image */
    vrt_size_struct size;
} vrt_sys_image_info_struct;


/***************************************************************************** 
 * Global Function
 *****************************************************************************/
/*
 *VRT trace function
 */
extern void vrt_log(trace_class_enum trc_class, ...);

extern kal_uint32 vrt_get_log_start_index(void);

/*
 * System state functions
 */
extern vrt_bool vrt_sys_check_mmi_has_gdi_lock(void);

/*
 * System clock functions
 */
extern vrt_msec_type vrt_sys_get_time(void);

/*
 * Screen functions
 */
extern void vrt_sys_get_main_screen_info(vrt_size_struct *dimension, vrt_color_type_enum *color_format);
extern vrt_text_dir_type_enum vrt_sys_get_text_dir(void);

/*
 * Resource functions
 */
extern vrt_u8 *vrt_sys_res_image_lock(vrt_s32 res_id);
extern void vrt_sys_res_image_unlock(vrt_s32 res_id, vrt_u8 *ptr);

extern vrt_size_struct vrt_sys_image_get_size_from_mem(const void *image_ptr);
extern vrt_size_struct vrt_sys_image_get_size_from_res_id(U16 res_id);
extern vrt_size_struct vrt_sys_image_get_size_from_file(const vrt_wchar *filename);
extern vrt_bool vrt_sys_image_get_info_from_file(const vrt_wchar *filename, vrt_sys_image_info_struct *info);
extern vrt_u8 vrt_sys_image_get_type_from_raw_data_image(const void *image_ptr , vrt_raw_data_image_format_enum image_format);
extern vrt_size_struct vrt_sys_image_get_size_from_file_raw_data(const void *image_ptr , vrt_s32 image_size, vrt_raw_data_image_format_enum image_format);
extern vrt_size_struct vrt_sys_layer_get_size(void *gdi_handle);

extern vrt_u8 *vrt_sys_res_shader_lock(vrt_res_id res_id);
extern void vrt_sys_res_shader_unlock(vrt_res_id res_id, vrt_u8 *ptr);


/*
 * Font functions
 */
extern vrt_size_struct vrt_sys_font_measure_str(const vrt_font_struct *font, const vrt_wchar *string);

/* 
 * System functions
 */
extern void vrt_sys_init(void);
extern void vrt_sys_entry(void);
extern void vrt_sys_leave(void);

/*
 * VRT memory config
 */
extern void vrt_cache_mem_attach(void *mem_p, vrt_u32 size);
extern void vrt_cache_mem_detach(void *mem_p);

extern void vrt_cache_mem_attach_ext(void *mem_p, vrt_u32 size, vrt_u32 flag);

/*
 * VRT dcache switching
 */
extern void vrt_dynamic_switch_cacheable_region(void *vaddr, vrt_u32 len, vrt_bool cacheable);

// TODO: Move these prototype to other place
/*
 * VRT message related
 */
extern vrt_msec_type vrt_get_current_frame_time(void);
extern vrt_msec_type vrt_get_finish_frame_time(void);
extern void vrt_adjust_current_frame_time(vrt_msec_type);
extern vrt_msec_type vrt_adjust_with_frame_time(vrt_msec_type time_to_adjust);

extern void vrt_timer_start(vrt_msec_type time, vrt_timer_callback_funcptr_type timer_callback, void *arg, void *arg2);
extern void vrt_timer_stop(void *arg);

extern void vrt_invoke_mmi_rpc(vrt_rpc_funcptr_type rpc_callback, void *arg);

/* 
 * screen rotation 
 */
extern void vrt_sys_set_screen_rotation(vrt_sys_screen_rotate_enum rotation);
extern vrt_sys_screen_rotate_enum vrt_sys_get_screen_rotation(void);
extern vrt_sys_screen_rotate_enum vrt_sys_get_pre_screen_rotation(void);


typedef enum
{
    VRT_SYS_VIDEO_LAYER_INDEX_0,
    VRT_SYS_VIDEO_LAYER_INDEX_1,    
    VRT_SYS_VIDEO_LAYER_INDEX_2, // this one is left for toppest
    VRT_SYS_VIDEO_LAYER_INDEX_NUM,
} vrt_sys_video_layer_index_enum;

typedef enum
{
    VRT_SYS_ENV_INFO_ID_IS_GDI_PROFILING_ENABLED,
    VRT_SYS_ENV_INFO_ID_END_OF_ENUM
} vrt_sys_env_info_id_enum;

typedef enum
{
    VRT_SYS_DISPLAY_MAIN_LCD,
    VRT_SYS_DISPLAY_END_OF_ENUM
} vrt_sys_display_enum;

#ifndef V3D_TEST
extern void *vrt_sys_get_env_info(vrt_sys_env_info_id_enum info_id);
#endif

extern void vrt_canvas_enable_1st_frame_dithering(vrt_bool is_enable);
extern vrt_bool vrt_canvas_is_enable_1st_frame_dithering(void);

extern void vrt_enter_throttle_mode(vrt_u32 id);
extern void vrt_leave_throttle_mode(vrt_u32 id);
extern vrt_bool vrt_enable_throttle_mode(vrt_u32 id, vrt_bool enable);

extern vrt_bool vrt_sys_is_support_scanline_rotation(void);
extern void vrt_sys_disable_scanline_rotation(void);
extern void vrt_sys_enable_scanline_rotation(void);
extern vrt_u8 vrt_sys_get_scanline_rotation_angle(void);
extern vrt_u8 *vrt_sys_get_scanline_rotation_buffer(vrt_u32 *buffer_size);

extern void *vrt_sys_med_alloc_temp_mem(vrt_u32 size, void (*callback)(void*));

extern void vrt_sys_med_free_temp_mem(void **mem_p);

extern vrt_bool vrt_sys_is_using_int_stack(void);

extern vrt_u32 vrt_sys_get_max_busy_sleep_tick_num(void);
extern vrt_u32 vrt_sys_get_min_busy_sleep_tick_num(void);

extern void vrt_oom_free_discardable_resource(void);

extern vrt_size_struct vrt_sys_get_lcd_act_size(vrt_sys_display_enum lcd);
extern vrt_u32 vrt_sys_get_fps(vrt_sys_display_enum lcd);

extern vrt_color_type_enum vrt_sys_get_normal_color_format(void);
extern vrt_color_type_enum vrt_sys_get_opaque_color_format(void);

/* Framework Internal used API */
extern void vrt_canvas_enable_auto_cache(vrt_bool is_enable);
extern vrt_bool vrt_canvas_is_enable_auto_cache(void);
extern void vrt_canvas_enable_cache(vrt_bool is_enable);
extern vrt_bool vrt_canvas_is_enable_cache(void);
extern void vrt_canvas_enable_hw_ovl(vrt_bool is_enable);
extern vrt_bool vrt_canvas_is_enable_hw_ovl(void);
extern void vrt_canvas_enable_show_cross(vrt_bool is_enable);
extern vrt_bool vrt_canvas_is_enable_show_cross(void);


#ifdef __cplusplus
} /* extern "C"*/
#endif 

#endif /* __VRT_SYSTEM_H__ */

