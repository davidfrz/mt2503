/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
* Filename:
* ---------
*  
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  
*
* Author:
* -------
*
*
*==============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
*==============================================================================
*******************************************************************************/
#include "vmswitch.h"
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "MMI_mre_trc.h"
#include "mmi_trc.h"
#include "vmnwsetting.h"

#if 1
void _vm_trace(char* fmt, ...)
{
    char text[260] = {0};
    
    va_list ap;
    
    va_start(ap, fmt);
    
    
#ifdef __MTK_TARGET__
    vsnprintf(text + strlen(text), 150, fmt, ap);
#else 
    _vsnprintf(text + strlen(text), 150, fmt, ap);
#endif

    MMI_PRINT(MOD_MRE, TRACE_GROUP_7, text);


    va_end(ap);

}


#ifdef WIN32
#define vm_trace _vm_trace
#else
#define vm_trace(...) _vm_trace(__VA_ARGS__)
#endif
#else
#ifdef WIN32
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
#endif

#ifdef __MRE_SAL_SOCKET__
#include "mmi_features.h"
#include "MMIDataType.h"
#include "custom_data_account.h"
#include "stack_config.h"
#include "stack_msgs.h"
#include "app2soc_struct.h"
#include "cbm_consts.h"
#include "soc_consts.h"
#include "soc_api.h"
#include "cbm_api.h"
#include "DataAccountDef.h"
#include "ModeSwitchSrvGProt.h"
#include "mmi_frm_events_gprot.h"
#include "DtcntSrvGprot.h"
#include "string.h"
#include "wgui_categories_util.h"
#include "mmi_rp_app_mre_def.h"

#include "vmsock.h"
#include "vmsys.h"
#include "vmmod.h"
#include "vmsim.h"
#include "vmopt.h"

#include "vmmem.h"
#include "vmpromng.h"
#include "vmresmng.h"
#include "vmmacrostub.h"
#include "vmlog.h"
#include "vmpromnginner.h"

#ifdef __COSMOS_MMI_PACKAGE__
    #include "vapp_dtcnt_gprot.h"
#else
    #include "DataAccountGProt.h"
#endif
#include "NwInfoSrvGprot.h"


#define VM_SOCK_POOL_SIZE       MRE_SUPPORT_TCP_CONTEXT_MAX_NUM
//#define PF_INET                     SOC_PF_INET 
//#define SOCK_STREAM             SOC_SOCK_STREAM
#define MAX_CTX_CB 4

/*
 * 得到联网账号。
 */
extern VMUINT vm_get_account_id(VMUINT account_id, VMUINT8 app_id);

extern _vm_pcb_t* vm_sh_pcb_in_pt(VMINT search_type, VMINT value, VM_PROCESS_STATUS* status);


	//abm hold
kal_uint32 vm_get_tcp_acctid_by_resid(VMINT res_id);


/*
  * TCP链路读通道的状态。
  */
typedef enum 
{
    read_block = 0,                             // 读阻塞状态
    read_notify                                 // 读允许状态
} sock_read_pipe_t;

/*
  * TCP链路写通道的状态。
  */
typedef enum 
{
    write_block = 0,                                // 写阻塞状态
    write_notify                                    // 写允许状态
} sock_write_pipe_t;

/*
  * TCP链路的状态。
  */
typedef enum 
{
    conn_init = 0,                              // 未连接状态
    conn_host_by_name,                          // DSN 解析状态
    conn_connected,                             // 已连接状态
    conn_unkown                             // 未知的SOCKET 状态
} sock_connection_t;

/*
  * TCP链路的上下文的结构。
  */
typedef struct vm_sock_context_t 
{
    kal_int8 sock;                              /**< socket 句柄                                */
    kal_uint16 port;                                /**< socket 远程端口                            */
    sock_connection_t socket_state;             /**<socket 链路的状态                       */
    sock_read_pipe_t read_pipe_state;               /**< 写通道的状态                           */
    sock_write_pipe_t write_pipe_state;             /**< 读通道的状态                           */
    void (*callback_old)(VMINT handle, VMINT event);        /**< 事件回调函数句柄                   */
    void (*callback)(VMINT handle, VMINT event, void *user_data);        /**< 事件回调函数句柄                   */
    VMINT res_handle;                           /**< 该上下的空间是否已经被使用     */
    void *cb[MAX_CTX_CB];
    VMINT cb_num;
	//abm hold
    kal_uint32 account_id;
    void *user_data;
} vm_sock_context_t;

/*
  * 从socket 上下文资源池中获得socket上下文。
  */
static vm_sock_context_t* vm_malloc_socket_context(void);

/*
  * 把socket上下文归还到socket上下文资源池中。
  */
static void vm_free_socket_context(vm_sock_context_t*);

/*
  * 根据使用的socket句柄找到对应的socket链路上下
  * 文，如果找不到返回NULL。
  */
	//abm hold
static vm_sock_context_t* vm_get_socket_context(VMINT id, VMINT type);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/*
 * 注册到MTK的协议事件里的soc_notify函数。
 */
static MMI_BOOL vm_soc_notify(void*);

/*
 * 注册到MTK的协议事件里的get_host_by_name函数。
 */
static MMI_BOOL vm_get_host_by_name(void*);
static VMINT vm_get_host_by_name_1(VMINT handle, vm_soc_dns_result * rst);

static void * vm_soc_ctx_cb_push(vm_sock_context_t * ctx_p, void *cb);
static void * vm_soc_ctx_cb_pop(vm_sock_context_t * ctx_p);
/*
  * 初始化本模块的资源。
  */
static VMINT initialize_socket_resource(void);

/*
  * 释放本模块的资源
  */
static VMINT finialize_socket_resource(void);

/*
  * SOCKET模块生命周期事件的处理函数。
  */
static VMINT sock_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event);

/*
  * 加入close的保护，防止MTK不传回CLOSE事件。
  */
//static void vm_close_timer_proc(int timer_id);

/*
 * 查找str_1和str_2是否相等，本函数大小不敏感。
 * 例如:str1为L"jie.chen"而str2为L"JIE.chen"则毕竟返回TRUE。
 */
static VMINT vm_cmp_wstr_ignore_case(VMWSTR str_1, VMWSTR str_2, VMUINT count);

static void TCP_PMNG_WRAP_CALLBACK(VM_P_HANDLE p, void (*cb)(VMINT handle, VMINT event, void *user_data), void *user_data, VMINT rid, VMINT state)
{
    if (vm_pmng_set_ctx(p) == VM_PMNG_OP_OK)
    {
        cb(rid, state, user_data);
        vm_pmng_reset_ctx(); 
    }
}



static void vm_soc_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_sock_context_t* socket_context = NULL;
    
    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_TCP_HANDLE)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
            resHandle, (void**)&socket_context, &bufSize) == 0 && socket_context != NULL)
        {
            if (socket_context->socket_state == conn_host_by_name)
            {
                soc_abort_dns_query(KAL_TRUE, MOD_MMI, KAL_TRUE, 
                    socket_context->sock, KAL_FALSE, 0, KAL_FALSE, 0);
            }
            soc_close(socket_context->sock);
            /* 分配内存的时候是通过vm_malloc分配的。 */
            _vm_kernel_free(socket_context);
        }
        else
        {
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_378 );
        }
        vm_res_release_data(VM_RES_TYPE_TCP_HANDLE, resHandle);
        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE); 
    }
}

static void vm_soc_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        vm_soc_free_resource(process_handle);
        break;
    }
}

static VMINT g_vm_is_ready_dataaccount = FALSE;
static void init_dataaccount_callback(void)
{
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_390 );
    g_vm_is_ready_dataaccount = TRUE;
}

VMINT vm_is_ready_dataaccount(void)
{
    return g_vm_is_ready_dataaccount;
}
static void * vm_soc_ctx_cb_push(vm_sock_context_t * ctx_p, void *cb)
{
    //ASSERT(ctx_p && cb); // internal function, unnecessary to ASSERT

    if (MAX_CTX_CB == ctx_p->cb_num)
    {
        return 0;
    }
    ctx_p->cb[ctx_p->cb_num++] = cb;
    return (void*)cb;
}

static void * vm_soc_ctx_cb_pop(vm_sock_context_t * ctx_p)
{
    //ASSERT(ctx_p); // internal function, unnecessary to ASSERT

    if (0 == ctx_p->cb_num)
    {
        return 0;
    }
    return ctx_p->cb[--ctx_p->cb_num];
}

static VMINT vm_never_call_mmi_dtcnt_ready_check_on_background = TRUE;
static kal_uint8 cbm_app_id = 1;
static VMINT initialize_socket_resource(void)
{
    //VMINT ret = 0;

    if (vm_never_call_mmi_dtcnt_ready_check_on_background == TRUE)
    {
        vm_never_call_mmi_dtcnt_ready_check_on_background = FALSE;
        //mmi_dtcnt_ready_check_on_background(init_dataaccount_callback);
#ifdef __COSMOS_MMI_PACKAGE__
        if(MMI_TRUE == vapp_dtcnt_ready_check(init_dataaccount_callback, MMI_FALSE))
#else
    #if defined(__IOT__)
        if (MMI_FALSE)
    #else
        if(MMI_TRUE == mmi_dtcnt_ready_check(init_dataaccount_callback, MMI_FALSE))
    #endif
#endif  
        {
            g_vm_is_ready_dataaccount = TRUE;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_438 );
        }
    }
    
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_TCP_HANDLE, 
        vm_soc_notify_process_status) != 0)
    {
        return -1;
    }

    //cbm_app_id = cbm_register_app_id(STR_MRE_TITLE, 0);
    //if ((ret = cbm_hold_bearer(MOD_MMI, cbm_app_id)) != CBM_OK)
    //{
    //  cbm_deregister_app_id(cbm_app_id);
    //  MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_452 , ret);
    //}
    return 0;
}

static VMINT finialize_socket_resource(void)
{
    vm_soc_free_resource(-1);
    
    vm_res_type_set_notify_callback(VM_RES_TYPE_TCP_HANDLE, NULL);

    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, 
        (PsIntFuncPtr)vm_get_host_by_name);
    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
        (PsIntFuncPtr)vm_soc_notify);

    //cbm_release_bearer(MOD_MMI, cbm_app_id);
    //cbm_deregister_app_id(cbm_app_id);

    return 0;
}

static VMINT sock_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (initialize_socket_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        finialize_socket_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_514 , event);
        return -2;
    }

    return 0;
}

	//abm hold
static vm_sock_context_t* vm_get_socket_context(VMINT id, VMINT type)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_sock_context_t* socketContext = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
            resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
        {
            if (0 == type)
            {
                if (socketContext->sock == id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext;
                }
            }
            else if (1 == type)
            {
                if (socketContext->res_handle == id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext;
                }
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
                resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
            {
                if (0 == type)
                {
                if (socketContext->sock == id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext;
                }
                }
                else if (1 == type)
                {
                    if (socketContext->res_handle == id)
                    {
                        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                        return socketContext;
                    }
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
    }   
    return NULL;
}

	//abm hold
kal_uint32 vm_get_tcp_acctid_by_resid(VMINT res_id)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_sock_context_t* socketContext = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
            resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
        {
            if (socketContext->res_handle == res_id)
            {
                vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                return socketContext->account_id;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_TCP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_TCP_HANDLE, 
                resHandle, (void**)&socketContext, &bufSize) == 0 && socketContext != NULL)
            {
                if (socketContext->res_handle == res_id)
                {
                    vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
                    return socketContext->account_id;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_TCP_HANDLE);
    }   
    return 0;
}

static vm_sock_context_t* vm_malloc_socket_context(void)
{
    vm_sock_context_t* socket_context = NULL;

    if ((socket_context = _vm_kernel_calloc(sizeof(vm_sock_context_t))) != NULL)
    {
        if ((socket_context->res_handle = vm_res_save_data(VM_RES_TYPE_TCP_HANDLE, 
            (void*)socket_context, sizeof(socket_context), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_564, socket_context->res_handle);
			socket_context->callback_old = 0;
			socket_context->callback = 0;
            return socket_context;
        }
        else
        {
            _vm_kernel_free(socket_context);
        }
    }

    return NULL;
}

static void vm_free_socket_context(vm_sock_context_t* context_ptr)
{
    //if (context_ptr) // internal function, unnecessary to check
    //{
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_581, context_ptr->res_handle);
		
        vm_res_release_data(VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);
        _vm_kernel_free(context_ptr);
    //}
}
static void vm_close_and_free_socket(VMINT8 soc_id)
{
    vm_sock_context_t* context_ptr;
    context_ptr = vm_get_socket_context(soc_id, 0);
    if (context_ptr)
    {
        soc_close(context_ptr->sock);
        vm_free_socket_context(context_ptr);
    }
}

static VMINT vm_cmp_wstr_ignore_case(VMWSTR str_1, VMWSTR str_2, VMUINT count)
{
    if (mmi_wcsnicmp((const WCHAR *)str_1, (const WCHAR *)str_2, count) == 0)
        return TRUE;

    return FALSE;
}

/*
#ifdef __MMI_WLAN_FEATURES__
static U16 wifi_status = DTCNT_BEARER_STATE_INACTIVE;
static void vm_wifi_status_callback_handler(U16 status)
{
    wifi_status = status;
}
#endif


void vm_mre_wifi_init(void)
{
#ifdef __MMI_WLAN_FEATURES__
    mmi_wlan_add_event_notify_hdlr(vm_wifi_status_callback_handler);
#endif  
}

VMINT vm_tcp_wifi_connected (void)
{
#ifdef __MMI_WLAN_FEATURES__
    if (wifi_status == DTCNT_BEARER_STATE_CONNECTED)
    {
        return TRUE;
    }
#endif
    return FALSE;
}
*/

VMINT vm_is_support_wifi(void)
{
    return stub_tcp_is_support_wifi();
}

VMINT vm_wifi_is_connected(void)
{
    return vm_wlan_get_status();
}


VMINT _vm_reg_tcp_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("TCP", 
        (MOD_EVT_PROCESS)sock_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
        MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_672 , res_code);
    }

    return res_code;
}

static VMINT vm_get_apn_info_internal(vm_apn_info_ext *apn_info, kal_uint32 accid);
VMINT vm_tcp_apn_exists(VMINT apn)
{
#ifdef __MRE_SAL_SIM__  
#if 1
    VMUINT dtacct_id;
    vm_apn_info_ext apn_info;

    
    if (VM_E_SOC_SUCCESS == vm_get_encoded_dtacct_id(apn, &dtacct_id) && 
        0 == vm_get_apn_info_internal(&apn_info, dtacct_id))
    {
        return 1;
    }
    else
        return 0;

    

#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#endif  
}

static VMINT vm_soc_get_host_by_name_int(VMINT handle, 
                                         const VMCHAR * host, 
                                         VMBYTE * addr, 
                                         VMBYTE * addr_len, 
                                         VMUINT dtacct_id, 
                                         VMINT (*callback)(VMINT handle, vm_soc_dns_result * rst));
static VMINT vm_soc_get_host_by_name_cb(VMINT handle, vm_soc_dns_result * rst, void *user_data);
static VMINT vm_soc_get_host_by_name_ex_cb(VMINT handle, vm_soc_dns_result * rst);
static VMINT vm_soc_get_host_by_name_int_cb(void* msg);
VMINT g_mre_account_id = 0;
static VMINT g_mre_soc_error_cause; /* soc_error_enum in soc_consts.h */

void tcp_callback_cb_ex(VMINT handle, VMINT event, void *user_data)
{
    vm_sock_context_t *context_ptr = vm_get_socket_context(handle, 1);
    if (context_ptr)
    {
        context_ptr->callback_old(handle, event);
    }
}

VMINT vm_tcp_get_soc_id(VMINT hdl)
{
    vm_sock_context_t *ctx_p;   
    ctx_p = vm_get_socket_context(hdl, 1);
    if (NULL == ctx_p)
    {
        return -2;
    }

    return (VMINT)ctx_p->sock;
}
VMINT vm_tcp_connect(const char* host, const VMINT port, const VMINT apn,
    void (*callback)(VMINT handle, VMINT event))
{
    vm_sock_context_t *ctx_p;   
    VMINT hdl;
    hdl = vm_tcp_connect_ex(host, port, apn, NULL, tcp_callback_cb_ex);
    if (hdl >= 0)
    {
        ctx_p = vm_get_socket_context(hdl, 1);
        if (ctx_p)
        {
            ctx_p->callback_old = callback;
        }
    }

    return hdl;
}

VMINT vm_tcp_connect_ex(const char* host, const VMINT port, const VMINT apn, void *user_data, 
	void (*callback)(VMINT handle, VMINT event, void *user_data))
{
    VMUINT account_id = 0;
    VMINT i = 0, apn_check;
    //srv_dtcnt_sim_type_enum sim_type;
#ifdef  __MRE_SAL_SIM__
    //operator_t ioperator;// = CMCC;
#endif
    vm_sock_context_t* context_ptr = NULL;
        //srv_dtcnt_sim_type_enum sim_type;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT, host, port, apn, callback, __LINE__);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    // check params 
    if (!host  || port <= 0 || !callback)
    {
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_776 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_02, VM_TCP_ERR_CREATE_FAILED, __LINE__);
        return VM_TCP_ERR_CREATE_FAILED;
    }

    apn_check = (apn != VM_TCP_APN_CMNET && apn != VM_TCP_APN_CMWAP &&
                 apn != VM_TCP_APN_CMWAP_ONLY && apn != VM_TCP_APN_CMNET_ONLY && 
                 apn != VM_APN_USER_DEFINE);
    // check apn
    if (stub_tcp_is_support_wifi())
    {
        if (apn_check && apn != VM_TCP_APN_WIFI)
        {
            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_788 , apn); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_03, apn, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            return VM_TCP_ERR_CREATE_FAILED;
        }       
    }
    else
    {
        if (apn_check)
        {
            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_798 , apn); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_04, apn, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            return VM_TCP_ERR_CREATE_FAILED;
        }
    }

    // 没有更多的资源 
    if ((context_ptr = vm_malloc_socket_context()) == NULL) 
    {
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_807 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_05, apn, VM_TCP_ERR_CREATE_FAILED, __LINE__);
        return VM_TCP_ERR_NO_ENOUGH_RES;
    }
    
    context_ptr->port = port;
    context_ptr->callback = callback;
    context_ptr->user_data = user_data;

    if (0 > vm_get_encoded_dtacct_id(apn, &account_id))
    {
        vm_free_socket_context(context_ptr);
    	return VM_TCP_ERR_CREATE_FAILED;
    }

        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_DTCNT_ID, i, account_id);

       
        // 没有找到适合的APN帐号，则返回失败。
        if ((cbm_result_error_enum)account_id == CBM_INVALID_ACCT_ID)
        {
            //vm_free_socket_context(context_ptr);
            /* MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_828 ); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_11, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            vm_free_socket_context(context_ptr);
            return VM_TCP_ERR_CREATE_FAILED;
        }
    //srv_dtcnt_get_sim_preference(&sim_type);
    if ((stub_tcp_is_support_wifi() && VM_TCP_APN_WIFI == apn)
#ifdef __COSMOS_MMI_PACKAGE__      
       // || (srv_mre_da_get_account_id(SRV_MRE_DA_WIFI_ONLY) == 1)
       // || (sim_type == SRV_DTCNT_SIM_TYPE_NONE)
#endif
        )
    {
        if (SRV_DTCNT_WLAN_STATUS_INACTIVE == srv_dtcnt_wlan_status())
        {
            //MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 2, __LINE__);
            vm_free_socket_context(context_ptr);
            return VM_TCP_ERR_CREATE_FAILED;
        }
    }

    if ((context_ptr->sock = soc_create(PF_INET, SOCK_STREAM, 0, MOD_MMI, account_id)) >= 0)
    {
        kal_uint8 val = 1;

        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_CREATED_SOC, context_ptr->sock, account_id);
        
        if (soc_setsockopt(context_ptr->sock, SOC_NBIO, &val, sizeof(val)) < 0)
        {
            vm_close_and_free_socket(context_ptr->sock);

            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_845 ); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_07, VM_TCP_ERR_CREATE_FAILED, __LINE__);
        }
        else
        {   
            val = SOC_READ | SOC_WRITE | SOC_CLOSE | SOC_CONNECT;
            if (soc_setsockopt(context_ptr->sock, SOC_ASYNC, &val, sizeof(val)) < 0)
            {
                vm_close_and_free_socket(context_ptr->sock);

                /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_856 ); */
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_08, VM_TCP_ERR_CREATE_FAILED, __LINE__);
            }
            else                                            // 开始连接过程
            {
                sockaddr_struct addr;               // connect 地址
                kal_uint8 buf[4] = {0}, addr_len = 0;
                kal_int8 ret = -1;
                kal_bool is_ip_valid;
                kal_char* host_name  = vm_malloc(strlen(host) + 1);
                memset(host_name, 0x00, strlen(host) + 1);
                strcpy(host_name, host);

                //memset(&addr, 0x00, sizeof(addr));
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                    apn, 0, 0, 0, 0, 0);
                if (apn == VM_TCP_APN_CMWAP)    // cmwap 连接
                {
                    //kal_char* host_name  = vm_malloc(strlen(host) + 1);
                    //kal_bool is_ip_valid;
                    //kal_uint8 buf[4];
                    kal_uint8 len = 0;
                    
                    if (!host_name)
                    {
                        vm_free_socket_context(context_ptr);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    //memset(buf, 0x00, sizeof(buf));
                
                    if (soc_ip_check(host_name, addr.addr, &is_ip_valid) == KAL_FALSE)
                    {
                        #define WAP_DNS 
                        #ifdef WAP_DNS 
	//abm hold
                        ret = vm_soc_get_host_by_name_int((VMINT)context_ptr->res_handle, host, buf, &addr_len, account_id, vm_get_host_by_name_1); 
                        if (ret == SOC_SUCCESS)             // success
                        {
                            //addr.addr[0] = buf[0];    
                            //addr.addr[1] = buf[1];
                            //addr.addr[2] = buf[2];
                            //addr.addr[3] = buf[3];
                            memcpy(addr.addr, buf, 4);
                            addr.addr_len = addr_len;
                            addr.port = port;              
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 0, __LINE__, 
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 4] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 3] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 2] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 1] : -1,
                                                                                        addr.addr_len);
                            
                        }
                        else if (ret == SOC_WOULDBLOCK)         // block
                        {
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 11, __LINE__);
	//abm hold
                            return context_ptr->res_handle;
                        }
                        else                                    // error
                        {
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_09, context_ptr->sock);
                            vm_close_and_free_socket(context_ptr->sock);
                            
                            return VM_TCP_ERR_CREATE_FAILED;
                        }
                        
                        vm_free(host_name);

                        #else

                        vm_free(host_name);
                        vm_close_and_free_socket(context_ptr->sock);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 11, __LINE__);
                        return VM_TCP_ERR_CREATE_FAILED;
                        #endif
                    }
                    else if (is_ip_valid == KAL_FALSE)
                    {
                        vm_free(host_name);
                        vm_close_and_free_socket(context_ptr->sock);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E2, 11, __LINE__);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    else
                    {
                        vm_free(host_name);
                        addr.addr_len = 4;
                        addr.port = port;
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                            addr.port, addr.addr_len, 0, 0, 0, 0);
                    }                   
                }
                else                                // cmnet 连接
                {

                    if (!host_name)
                    {
                        vm_free_socket_context(context_ptr);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E3, 11, __LINE__);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    //memset(buf, 0x00, sizeof(buf));
                    //memset(host_name, 0x00, strlen(host) + 1);
                    //strcpy(host_name, host);
                    
                    if (soc_ip_check(host_name, addr.addr, &is_ip_valid) == KAL_FALSE)
                    {
                        // 是主机名而非ip地址 
                        vm_free(host_name);
                        #ifndef OLD_SOCK
	//abm hold
                        ret = vm_soc_get_host_by_name_int((VMINT)context_ptr->res_handle, host, buf, &addr_len, account_id, vm_get_host_by_name_1); 
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                            apn, context_ptr->res_handle, account_id, addr_len, 0, 0);
                        #else
                        ret = soc_gethostbyname(KAL_FALSE, MOD_MMI, context_ptr->sock, 
                            host, buf, &addr_len, 0, account_id); //这里的request id 就是socket id。
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                            apn, context_ptr->sock, account_id, addr_len, 0, 0);
                        #endif
                        if (ret == SOC_SUCCESS)             // success
                        {
                            //addr.addr[0] = buf[0];    
                            //addr.addr[1] = buf[1];
                            //addr.addr[2] = buf[2];
                            //addr.addr[3] = buf[3];
                            memcpy(addr.addr, buf, 4);
                            addr.addr_len = addr_len;
                            addr.port = port;                       
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 0, __LINE__, 
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 4] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 3] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 2] : -1,
                                                                                        addr.addr_len > 0 ? addr.addr[addr.addr_len - 1] : -1,
                                                                                        addr.addr_len, 0);
                        }
                        else if (ret == SOC_WOULDBLOCK)         // block
                        {
                            #ifdef OLD_SOCK
                            context_ptr->socket_state = conn_host_by_name;
                            mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, (PsIntFuncPtr)vm_get_host_by_name, MMI_TRUE);
                            //mmi_frm_set_multi_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, (PsIntFuncPtr)vm_get_host_by_name);
	//abm hold
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_GET_HOST, context_ptr->res_handle);
                            #endif
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E4, 11, __LINE__);
	//abm hold
                            context_ptr->account_id = account_id;
                            return context_ptr->res_handle;
                        }
                        else                                    // error
                        {
                            vm_close_and_free_socket(context_ptr->sock);

                            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1005 ); */
                            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_09, context_ptr->sock);
                            return VM_TCP_ERR_CREATE_FAILED;
                        }
                    }
                    else if (is_ip_valid == KAL_FALSE)  
                    {
                        // 非法的ip 地址 
                        vm_free(host_name);
                        vm_close_and_free_socket(context_ptr->sock);
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, 0);
                        return VM_TCP_ERR_CREATE_FAILED;
                    }
                    else
                    {
                        vm_free(host_name);
                        addr.addr_len = 4;
                        addr.port = port;
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_IP_HOST, context_ptr->sock);
                    }
                }   

                // 对于cmnet ，只有在get_host_by_name成功后才可能走连接过程。 
                switch (soc_connect(context_ptr->sock, &addr))
                {
                    case SOC_SUCCESS:
                    case SOC_WOULDBLOCK:
                        mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify, MMI_TRUE);
                        //mmi_frm_set_multi_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify);
	//abm hold
                        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_WAIT, context_ptr->res_handle);
                        context_ptr->account_id = account_id;
                        return context_ptr->res_handle;
                    default:
                        vm_close_and_free_socket(context_ptr->sock);
                        break;
                }
            }
        }
    }
    else
    {
        vm_close_and_free_socket(context_ptr->sock);
        
        /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1049 ); */
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_10, VM_TCP_ERR_CREATE_FAILED, __LINE__);
    }

    return VM_TCP_ERR_CREATE_FAILED;
}

void vm_tcp_close(VMINT handle)
{
    vm_sock_context_t* socketContext = NULL;
    sock_connection_t state;
    //VM_P_HANDLE pHandle = vm_pmng_get_current_handle();


    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CLOSE, handle);
    
	//abm hold
    if ((socketContext = vm_get_socket_context(handle, 1)) != NULL)
        //&& vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, socketContext->res_handle) == pHandle)
    {
        state = socketContext->socket_state;
        if (state <= conn_connected 
            || state == conn_unkown)
        {
            if (state == conn_host_by_name)
            {
	//abm hold
                soc_abort_dns_query(KAL_TRUE, MOD_MMI, KAL_TRUE, socketContext->sock, 
                    KAL_FALSE, 0, KAL_FALSE, 0);
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1074 , socketContext->sock);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1076 , socketContext->sock);
	//abm hold
            soc_close((kal_int8)socketContext->sock);
            vm_free_socket_context(socketContext);
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CLOSE_END, socketContext->sock);
            return;
        }
    }
}

VMINT vm_tcp_read(VMINT handle, void* buf, VMINT len)
{
    kal_int32 ret = 0;
    vm_sock_context_t* context_ptr = NULL;

    if (!buf || len <= 0)
    {
        return 0;
    }

	//abm hold
    if ((context_ptr = vm_get_socket_context(handle, 1)) == NULL) 
    {
        return (VM_TCP_READ_EOF  -2);
    }
    
    if (context_ptr->socket_state != conn_connected || context_ptr->read_pipe_state <= read_block)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1102 , handle);
        return 0; 
    }

    if ((ret = soc_recv(context_ptr->sock, (kal_uint8*)buf, len, 0)) <= 0)
    {
        if (ret == SOC_WOULDBLOCK)
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1110 , context_ptr->sock);
            context_ptr->read_pipe_state = read_block;
            return 0;
        }
        else if (ret == 0)
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1116 , context_ptr->sock);
            return VM_TCP_READ_EOF;
        }
        else
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1121 , context_ptr->sock);
            return (VM_TCP_READ_EOF - 1);
        }
    }
    else
    {
	//abm hold
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1127, context_ptr->sock, ret);
		
    }
    return ret;
}

VMINT vm_tcp_write(VMINT handle, void* buf, VMINT len)
{
    vm_sock_context_t* context_ptr = NULL;
    kal_int32 ret = 0;

    if (!buf || len <= 0)
    {
        return 0;
    }

	//abm hold
    if ((context_ptr = vm_get_socket_context(handle, 1)) == NULL)
    {
        return -1;
    }
    
    if (context_ptr->socket_state != conn_connected || context_ptr->write_pipe_state <= write_block)
    {
	//abm hold
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1150 , context_ptr->sock);
        return 0;
    }

    if ((ret = soc_send(context_ptr->sock, (kal_uint8*)buf, len, 0)) < 0)
    {
        if (ret == SOC_WOULDBLOCK)
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1158 , context_ptr->sock);
            context_ptr->write_pipe_state = write_block;
            return 0;
        }
        else
        {
	//abm hold
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1164 , context_ptr->sock);
            return -1;
        }
    }
    else
    {
	//abm hold
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1170 , context_ptr->sock, ret);
    }
    
    return ret;
}


VMINT vm_soc_get_last_error(void)
{
    return g_mre_soc_error_cause;
}

VMINT vm_soc_get_host_by_name_ex(VMINT apn, 
                                 const VMCHAR * host, 
                                 vm_soc_dns_result * result, 
                                 VMINT (*callback)(VMINT, vm_soc_dns_result *, void *), void *user_data)
{
        vm_sock_context_t * soc_ctx = NULL;
        VMUINT dtacct_id = 0;
        kal_uint8 val = 1;
        VMINT ret = 0;
        VMBYTE addr[32] = {0};
        VMBYTE addr_len = 0;
        
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 1, __LINE__);
    
        if (NULL == host || 
            NULL == callback ||
            NULL == result || 
            (VM_TCP_APN_CMNET != apn && VM_TCP_APN_WIFI != apn) &&
            apn != VM_TCP_APN_CMNET_ONLY && 
            apn != VM_APN_USER_DEFINE)
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -8);
            return VM_E_SOC_INVAL;
        }
        
        if (NULL == (soc_ctx = vm_malloc_socket_context())) 
        {
            /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1202 ); */
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, VM_TCP_ERR_NO_ENOUGH_RES);
            return VM_E_SOC_LIMIT_RESOURCE;
        }
        
        //soc_ctx->port = port;
        //soc_ctx->callback = callback;
    
        // wifi & cmnet use the same apid witch registered from cbm.
        if (0 > vm_get_encoded_dtacct_id(apn, &dtacct_id))
        {
            vm_free_socket_context(soc_ctx);
            // 没有找到适合的APN帐号，则返回失败。
            if (CBM_INVALID_ACCT_ID == (cbm_result_error_enum)dtacct_id)
            {
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -6);
                return VM_E_SOC_INVALID_ACCOUNT; 
            }
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -7);
            return VM_E_SOC_INVALID_ACCOUNT;
        }
        
        if (0 > (soc_ctx->sock = soc_create(PF_INET, SOCK_STREAM, 0, MOD_MMI, dtacct_id)))
        {
            vm_free_socket_context(soc_ctx);
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -5);
            return VM_E_SOC_ERROR;
        }
    
        if (0 > soc_setsockopt(soc_ctx->sock, SOC_NBIO, &val, sizeof(val)))
        {
            vm_close_and_free_socket(soc_ctx->sock);
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -5);
            return VM_E_SOC_ERROR;
        }
    /*
        val = SOC_READ | SOC_WRITE | SOC_CLOSE | SOC_CONNECT;
        if (0 > soc_setsockopt(soc_ctx->sock, SOC_ASYNC, &val, sizeof(val)))
        {
            soc_close(soc_ctx->sock);
            vm_free_socket_context(soc_ctx);
            return -5; // TODO: check value
        }
        */
        //soc_ctx->cb = (void(*)(void))callback;
        soc_ctx->user_data = user_data;
        
        if (NULL == vm_soc_ctx_cb_push(soc_ctx, (void *)callback))
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 1, __LINE__, -5);
            return VM_E_SOC_ERROR;
        }
        
    
        //abm hold
        if (SOC_SUCCESS == (ret = vm_soc_get_host_by_name_int(soc_ctx->res_handle, 
                                            host,
                                            addr,
                                            &addr_len, 
                                            dtacct_id,
                                            vm_soc_get_host_by_name_ex_cb)))
        {
            //memcpy(&(result.address[0]), addr, 4);
    /*        result.address = (VMUINT*)addr;
            result.num = 1;
            result.error_cause = 0;
            callback(&result);*/
            memcpy(result->address, addr, 4);
            result->error_cause = 0;
            result->num = 1;
            {
            VMINT i = 0;
            kal_uint8 * p = NULL;
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 1, __LINE__, 
                result->num, 0, 0, 0, 0, 0);
            for (i = 0; i < result->num; i ++)
            {
                p = (kal_uint8*)(result->address + i);
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 1, __LINE__, 
                                                        p[0],
                                                        p[1],
                                                        p[2],
                                                        p[3], 0, 0);
            }
            }
            vm_close_and_free_socket(soc_ctx->sock);
            return VM_E_SOC_SUCCESS;
        }

        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 1, ret);
        if (VM_E_SOC_WOULDBLOCK == ret)
            return soc_ctx->res_handle;
        else
            return ret;
        
}

VMINT vm_soc_get_host_by_name(VMINT apn, 
                              const VMCHAR * host, 
                              vm_soc_dns_result * result, 
                              VMINT (*callback)(vm_soc_dns_result *))
{
    VMINT handle;
    VMINT (**cb)(vm_soc_dns_result *) = vm_calloc(sizeof(VMINT (*)(vm_soc_dns_result *)));
    *cb = callback;
    if (0 >= (handle = vm_soc_get_host_by_name_ex(apn, host, result, vm_soc_get_host_by_name_cb, cb)))
    {
        vm_free(cb);
    }
    return handle;    
}

static void vm_fill_app_info(cbm_app_info_struct *app_info, kal_uint16 str_id, kal_uint64 type)
{
    #ifdef __IOT__
    app_info->app_icon_id = 0;
    #else
    app_info->app_icon_id = GetRootTitleIcon(IMAGE_MRE_SMALL_ICON);
    #endif
    app_info->app_str_id = str_id;
    app_info->app_type = type;
}

static VMUINT8 app_id_net;
static VMUINT8 app_id_wap;
static VMUINT8 app_id_net_only;
static VMUINT8 app_id_wap_only;
static VMUINT8 app_id_wifi;
// DIS WLAN
#include "vmenv.h"
static VMUINT8 app_id_net_dis_wlan;
static VMUINT8 app_id_wap_dis_wlan;
static VMUINT8 app_id_net_only_dis_wlan;
static VMUINT8 app_id_wap_only_dis_wlan;
VMINT vm_get_app_id(VMINT apn, VMUINT8 *app_id)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    cbm_app_info_struct app_info;
    kal_int8 ret = 0;
    // DIS WLAN
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    _vm_pcb_t* pcb = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // DIS WLAN
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_S, 2, __LINE__);
    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_LOG, 
        apn,
        pcb,
        0,
        0,
        0,
        pcb ? (VMUINT)pcb->flag : (VMUINT)pcb,
        2, __LINE__);

    /* register app id */
    if (VM_TCP_APN_WIFI == apn || VM_APN_WIFI_HS == apn || VM_APN_AP_MODE == apn)
    {
        if (app_id_wifi == 0)
        {
            vm_fill_app_info(&app_info, STR_MRE_NETWORK_WIFI, 
                DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX);
            ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wifi);
        }
        *app_id = app_id_wifi;
        vm_log_debug("[test] ret[%d] app_id [%d]", ret, app_id_wifi);
    }else if (VM_TCP_APN_CMNET == apn/* || 
        VM_TCP_APN_WIFI == apn*/
        || VM_APN_USER_DEFINE == apn
#ifndef DTCNT_APPTYPE_SKIP_WIFI
        || VM_TCP_APN_CMNET_ONLY == apn 
#endif
        ) 
    {
    // DIS WLAN
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_net_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 20, __LINE__);
            *app_id = app_id_net_dis_wlan;
        }
        else
        {
            if (app_id_net == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net);
            }
            *app_id = app_id_net;
        }
    }
    else if (VM_TCP_APN_CMWAP == apn
#ifndef DTCNT_APPTYPE_SKIP_WIFI
                || VM_TCP_APN_CMWAP_ONLY == apn 
#endif
        )
    {
    
    // DIS WLAN
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_wap_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 21, __LINE__);
            *app_id = app_id_wap_dis_wlan;
        }
        else
        {
            if (app_id_wap == 0)
            {
            vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP, 
                DTCNT_APPTYPE_MRE_WAP | DTCNT_APPTYPE_NEED_PX);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap);
            }
            *app_id = app_id_wap;
        }
    }
    #ifdef DTCNT_APPTYPE_SKIP_WIFI
    else if (VM_TCP_APN_CMNET_ONLY == apn)
    {
    
    // DIS WLAN
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_net_only_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET_ONLY_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net_only_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 22, __LINE__);
            *app_id = app_id_net_only_dis_wlan;
        }
        else
        {
            if (app_id_net_only == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMNET_ONLY, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_SKIP_WIFI);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_net_only);
            }
            *app_id = app_id_net_only;
        }
    }
    else if (VM_TCP_APN_CMWAP_ONLY == apn)
    {
    
        if (pcb && (VM_FLAG_DIS_WLAN_PERFER == (VM_FLAG_DIS_WLAN_PERFER & pcb->flag)))
        {
            if (app_id_wap_only_dis_wlan == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP_ONLY_DIS_WLAN, 
                	DTCNT_APPTYPE_MRE_NET | DTCNT_APPTYPE_NO_PX | DTCNT_APPTYPE_NO_SCR);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap_only_dis_wlan);
            }
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E3, 23, __LINE__);
            *app_id = app_id_wap_only_dis_wlan;
        }
        else
        {
            if (app_id_wap_only == 0)
            {
            	vm_fill_app_info(&app_info, STR_MRE_NETWORK_CMWAP_ONLY, 
                	DTCNT_APPTYPE_MRE_WAP | DTCNT_APPTYPE_SKIP_WIFI | DTCNT_APPTYPE_NEED_PX);
                ret = cbm_register_app_id_with_app_info(&app_info, &app_id_wap_only);
            }
            *app_id = app_id_wap_only;
        }
    }
    #endif
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E1, 2, __LINE__);
        return VM_E_SOC_INVAL;
    }

    if (0 != ret)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E2, 2, __LINE__);
        return VM_E_SOC_INVALID_ACCOUNT;
    }
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E, 2, __LINE__);
    return VM_E_SOC_SUCCESS;
}

// custmized apn
static VMBOOL vm_is_cust_apn_set(void);
VMINT vm_get_encoded_dtacct_id(VMINT apn, VMUINT * dtacct_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //srv_dtcnt_sim_type_enum sim_type;
    VMUINT dtacct = 0;
    VMUINT8 app_id = 0;
    kal_int8 ret = 0;
    VMBYTE prefer_b = 1;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 3, __LINE__);

    if (NULL == dtacct_id)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 3, __LINE__);
        return VM_E_SOC_INVAL;
    }

    /* Get APP ID */
    ret = vm_get_app_id(apn, &app_id);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 3, __LINE__, 
                                            apn,
                                            app_id, 
                                            0, 
                                            0, 0, ret);
                                            
    if (ret != VM_E_SOC_SUCCESS)
        return ret;
        
    //srv_dtcnt_get_sim_preference(&sim_type);

    if (stub_tcp_is_support_wifi() && 
        (VM_TCP_APN_WIFI == apn || VM_APN_WIFI_HS == apn || VM_APN_AP_MODE == apn))
    {
        switch (apn)
        {
        case VM_TCP_APN_WIFI:
            {
                if(CBM_OK != cbm_get_valid_account_id(CBM_WIFI, (kal_uint32 *)&dtacct))
                {
                    //vm_free_socket_context(context_ptr);
                    /* MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_1432 ); */
                    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_ERR_06, VM_TCP_ERR_CREATE_FAILED, __LINE__);
                    return VM_E_SOC_INVALID_ACCOUNT;
                }
            }break;
        case VM_APN_WIFI_HS:
            {
                dtacct = CBM_WIFI_HS_ACCT_ID;
            }break;
        case VM_APN_AP_MODE:
            {
                dtacct = CBM_AP_MODE_ACCT_ID;
            }break;
        }

        *dtacct_id = (kal_uint32)cbm_encode_data_account_id((kal_uint32)dtacct, CBM_SIM_ID_SIM1, (kal_uint8)app_id, (kal_bool)0);
        
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_WIFI_ACNT_ID, *dtacct_id);
    }
    else
    {

        dtacct = CBM_DEFAULT_ACCT_ID;
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#endif
#if __MMI_MRE_DTCNT_SETTING__
        switch(sim_type)
        {
            case SRV_DTCNT_SIM_TYPE_1:
                if (VM_TCP_APN_CMNET == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM1);
                }
                else if(VM_TCP_APN_CMWAP == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM1_PX);
                }
                break;
                
            case SRV_DTCNT_SIM_TYPE_2:
                if (VM_TCP_APN_CMNET == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM2);
                }
                else if(VM_TCP_APN_CMWAP == apn)
                {
                    dtacct = srv_mre_da_get_account_id(SRV_MRE_DA_SIM2_PX);
                }              
                break;

            default:
                /* Other card use default */
                //dtacct = CBM_DEFAULT_ACCT_ID;
                prefer_b = 0;
                break;
        }

        if (!prefer_b)
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 3, __LINE__, 
                                                    apn,
                                                    sim_type, 
                                                    0, 
                                                    0, 0, 1);
#ifdef __MRE_SAL_SIM__  
            if (VM_APN_USER_DEFINE == apn) // BAD PARAM CHECKING
            {
                VMUINT32 acct_id = 0;
                VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
                _vm_pcb_t* pcb = NULL;
                pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
                if (pcb)
                {
                    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 301, __LINE__, 
                                                        status,
                                                        pcb->sim_id, 
                                                        pcb->accountId, 
                                                        0, 0, 1);
                    // custmized apn
                    if (CBM_MRE_ACCT_ID == (pcb->accountId & CBM_MRE_ACCT_ID))
                    {
                        // it will failure if cust apn was not set
                        if (!vm_is_cust_apn_set())
                        {
                            *dtacct_id = 0;
                            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E5, 4, __LINE__);
                            return VM_E_SOC_ERROR;
                        }
                    }

                    *dtacct_id = cbm_encode_data_account_id(pcb->accountId, (cbm_sim_id_enum)(pcb->sim_id), app_id, (kal_bool)0);

                }
            }
            else
            {
                *dtacct_id = vm_get_account_id(dtacct, app_id);
            }
#endif
        }
        else
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 3, __LINE__, 
                                                    apn,
                                                    sim_type, 
                                                    0, 
                                                    0, 0, 2);
            if (VM_APN_USER_DEFINE == apn)
            {
                VMUINT32 acct_id = 0;
                VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
                _vm_pcb_t* pcb = NULL;
                pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
                if (pcb)
                {
                    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 301, __LINE__, 
                                                        status,
                                                        pcb->sim_id, 
                                                        pcb->accountId, 
                                                        0, 0, 2);

                    // custmized apn
                    if (CBM_MRE_ACCT_ID == (pcb->accountId & CBM_MRE_ACCT_ID))
                    {
                        // it will failure if cust apn was not set
                        if (!vm_is_cust_apn_set())
                        {
                            *dtacct_id = 0;
                            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E5, 4, __LINE__);
                            return VM_E_SOC_ERROR;
                        }
                    }

                    *dtacct_id = cbm_encode_data_account_id(pcb->accountId, (cbm_sim_id_enum)(pcb->sim_id), app_id, (kal_bool)0);

                }
            }
            else
            {
                *dtacct_id = cbm_encode_data_account_id((kal_uint32)dtacct, (cbm_sim_id_enum)(sim_type-1), app_id, (kal_bool)0);
            }
        }

#else /* __MMI_MRE_DTCNT_SETTING__ __COSMOS_MMI_PACKAGE__ */

#ifdef __MRE_SAL_SIM__  
        if (VM_APN_USER_DEFINE == apn)
        {
            VMUINT32 acct_id = 0;
            VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
            _vm_pcb_t* pcb = NULL;
            pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);
            if (pcb)
            {
                VMUINT result = 0;

                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 301, __LINE__, 
                    status,
                    pcb->sim_id, 
                    pcb->accountId, 
                    0, 0, 3);
                // custmized apn
                if (CBM_MRE_ACCT_ID == (pcb->accountId & CBM_MRE_ACCT_ID))
                {
                    // it will failure if cust apn was not set
                    if (!vm_is_cust_apn_set())
                    {
                        *dtacct_id = 0;
                        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E5, 4, __LINE__);
                        return VM_E_SOC_ERROR;
                    }
                }

                *dtacct_id = cbm_encode_data_account_id(pcb->accountId, (cbm_sim_id_enum)(pcb->sim_id), app_id, (kal_bool)0);

            }
            }
        else
        {
            /* encode account id, using default automatic account ID */
            *dtacct_id = vm_get_account_id(dtacct, app_id);
        }
#endif

#endif /* __COSMOS_MMI_PACKAGE__ */
    }
    
    g_mre_account_id = *dtacct_id;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 3, __LINE__);

    return VM_E_SOC_SUCCESS;
}

static MMI_BOOL  vm_soc_notify(void* inMsg)
{
    vm_sock_context_t* context_ptr = NULL;
    void (*notify_callback)(VMINT handle, VMINT event, void *user_data) = NULL;
    VM_P_HANDLE processHandle = 0;
    
    app_soc_notify_ind_struct* ind = (app_soc_notify_ind_struct*)inMsg;

    /* 防止对指向null 的指针的操作 */
    if (!ind)                   
    {
        MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1552 );
        return MMI_FALSE;
    }

	//abm hold
    if ((context_ptr = vm_get_socket_context(ind->socket_id, 0)) != NULL)
    {
        /* 得到进程句柄。 */
        processHandle = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            context_ptr->res_handle);
        
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1563 , 
            processHandle, context_ptr->sock, ind->event_type, context_ptr->res_handle);
    
        switch (ind->event_type)
        {
        case SOC_WRITE:
            context_ptr->write_pipe_state = write_notify;
            
            
            if (context_ptr->callback && context_ptr->socket_state == conn_connected)
            {
	//abm hold
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1574 , context_ptr->res_handle);


	//abm hold
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    context_ptr->callback, context_ptr->user_data, context_ptr->res_handle, VM_TCP_EVT_CAN_WRITE);
            }
            break;
        case SOC_READ:
            context_ptr->read_pipe_state= read_notify;
            if (context_ptr->callback && context_ptr->socket_state == conn_connected)
            {
	//abm hold
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1591 , 
                    context_ptr->res_handle);


	//abm hold
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    context_ptr->callback, context_ptr->user_data, context_ptr->res_handle, VM_TCP_EVT_CAN_READ);
            }
            break;
        case SOC_CONNECT:
            if (ind->result != FALSE)
            {
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1608 , ind->socket_id);
                context_ptr->socket_state = conn_connected;
                context_ptr->read_pipe_state = read_notify;
                context_ptr->write_pipe_state = write_notify;
                g_mre_soc_error_cause = 0;
                if (context_ptr->callback)
                {
	//abm hold
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1615 , 
                        context_ptr->res_handle);

	//abm hold
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        context_ptr->callback, context_ptr->user_data, context_ptr->res_handle, VM_TCP_EVT_CONNECTED);

                }
            }
            else
            {
                notify_callback = context_ptr->callback;


                g_mre_soc_error_cause = ind->error_cause;
	//abm hold
                if (notify_callback)
                {
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1636 , ind->socket_id);
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        notify_callback, context_ptr->user_data, context_ptr->res_handle, VM_TCP_EVT_PIPE_BROKEN);
                }

                vm_close_and_free_socket(ind->socket_id);
            }
            break;
        case SOC_CLOSE:
            notify_callback = context_ptr->callback;

                
	//abm hold
            if (notify_callback)
            {
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_1656 , ind->socket_id);
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    notify_callback, context_ptr->user_data, context_ptr->res_handle, VM_TCP_EVT_PIPE_CLOSED);

                vm_close_and_free_socket(ind->socket_id);
            }           
            break;
        default:
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_1669 , ind->event_type);
        }

        return MMI_TRUE;
    }
    
    return MMI_FALSE;
}

static VMINT vm_get_host_by_name_1(VMINT handle, vm_soc_dns_result * rst)
{
    vm_sock_context_t* context_ptr = NULL;
    void (*notify_callback)(VMINT handle, VMINT event, void *user_data) = NULL;
    VM_P_HANDLE processHandle = -1;
    sockaddr_struct address;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 2, __LINE__);

    if (!rst)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 2, __LINE__, 0);
        return MMI_FALSE;
    }

    if (!rst->address)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 2, __LINE__, 0);
        return MMI_FALSE;
    }
    
    if (!rst->num)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 2, __LINE__);
        return MMI_FALSE;
    }
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 2, __LINE__, 
                        rst->address[0], 
                        rst->address[1],
                        rst->address[2],
                        rst->address[3],
                        rst->num, 
                        rst->error_cause);
    //                    rst->error_cause);
	//abm hold
    context_ptr = vm_get_socket_context(handle, 1);
    if (NULL == context_ptr)
        return MMI_FALSE;

    processHandle = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);

    //memset(&address, 0x00, sizeof(address));
    memcpy(address.addr, rst->address, 4);
    address.addr_len = 4;
    address.port = context_ptr->port;

    
    
    switch (soc_connect(context_ptr->sock, &address))
    {
    case SOC_SUCCESS:
    case SOC_WOULDBLOCK:
        mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify, MMI_TRUE);
        //mmi_frm_set_multi_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify);
        break;
    default:
        notify_callback = context_ptr->callback;
        vm_free_socket_context(context_ptr);
        soc_close((kal_int8)handle);
        
        if (notify_callback)
        {
            if (processHandle >= 0)
            {
                TCP_PMNG_WRAP_CALLBACK(processHandle, 
                    notify_callback, context_ptr->user_data, handle, VM_TCP_EVT_PIPE_BROKEN);
            }
            else
            {
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 2, __LINE__, processHandle);
            }
        }               
        break;
    }

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 2, __LINE__);

    return MMI_FALSE;
    
}

static VMINT vm_soc_get_host_by_name_cb(VMINT handle, vm_soc_dns_result * rst, void *user_data)
{
    
    VM_P_HANDLE handle_p = -1;
    VMINT ret;
    VMINT (**tmp_cb)(vm_soc_dns_result *);
    handle_p = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            handle);
    if (0 > handle_p)
    {
        return MMI_FALSE;
    }

    tmp_cb = (VMINT (**)(vm_soc_dns_result *))user_data;
    if (0 == handle_p)
    {
        ret = (*tmp_cb)(rst);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 111, __LINE__, 
                                    ret, rst->address, rst->num, rst->error_cause, 0, 0);
    }
    else
    {
        if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
        {
            ret = (*tmp_cb)(rst);
            vm_pmng_reset_ctx();
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 112, __LINE__, 
                                        ret, rst->address, rst->num, rst->error_cause, 0, 0);
        }
    }
    
    vm_free(user_data);
    return ret;
}
static VMINT vm_soc_get_host_by_name_ex_cb(VMINT handle, vm_soc_dns_result * rst)
{
    vm_sock_context_t* soc_ctx = NULL;
    VM_P_HANDLE handle_p = -1;
    VMINT (*tmp_cb)(VMINT, vm_soc_dns_result *, void *);
    VMINT ret = 0;
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 11, __LINE__);
    
    if (!rst)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, rst);
        return MMI_FALSE;
    }

    if (!rst->address)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, rst->address);
        return MMI_FALSE;
    }

    
	//abm hold
    soc_ctx = vm_get_socket_context(handle, 1);
    if (NULL == soc_ctx)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, soc_ctx);
        return MMI_FALSE;
    }
    
    tmp_cb = (VMINT (*)(VMINT, vm_soc_dns_result *, void *))vm_soc_ctx_cb_pop(soc_ctx);
    if (NULL == tmp_cb)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, soc_ctx->cb_num);
        vm_close_and_free_socket(soc_ctx->sock);
        return MMI_FALSE;
    }
    
    handle_p = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            soc_ctx->res_handle);
    if (0 > handle_p)
    {
        vm_close_and_free_socket(soc_ctx->sock);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 11, __LINE__, soc_ctx->res_handle);
        return MMI_FALSE;
    }

    

    if (0 == handle_p)
    {
        ret = (*tmp_cb)(soc_ctx->res_handle, rst, soc_ctx->user_data);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                                    ret, rst->address, rst->num, rst->error_cause, 0, 0);
    }
    else
    {
        if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
        {
            ret = (*tmp_cb)(soc_ctx->res_handle, rst, soc_ctx->user_data);
            vm_pmng_reset_ctx();
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 11, __LINE__, 
                                        ret, rst->address, rst->num, rst->error_cause, 0, 0);
        }
    }
    
    vm_close_and_free_socket(soc_ctx->sock);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 11, __LINE__);

    return ret;
}

static VMINT vm_soc_get_host_by_name_int(VMINT handle, 
                                                                                const VMCHAR * host, 
                                                                                VMBYTE * addr, 
                                                                                VMBYTE * addr_len, 
                                                                                VMUINT dtacct_id, 
                                                                                VMINT (*callback)(VMINT handle, vm_soc_dns_result * rst))
{

    vm_sock_context_t* soc_ctx = NULL;
    kal_int8 ret = 0;

    ASSERT(callback);

	//abm hold
    soc_ctx = vm_get_socket_context(handle, 1);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 12, __LINE__);
    
    if (NULL == soc_ctx)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 12, __LINE__);
        return VM_E_SOC_ERROR;
    }
    
    ret = soc_gethostbyname(KAL_FALSE, 
                            MOD_MMI, 
                            soc_ctx->sock, 
                            host, 
                            (kal_uint8*)addr, 
                            (kal_uint8*)addr_len, 
                            0, 
                            dtacct_id);
                            
    if (SOC_WOULDBLOCK == ret)
    {
        if (NULL == vm_soc_ctx_cb_push(soc_ctx, (void *)callback))
        {
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 12, __LINE__, soc_ctx->cb_num);
            return VM_E_SOC_ERROR;
        }
        soc_ctx->socket_state = conn_host_by_name;
        mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, (PsIntFuncPtr)vm_soc_get_host_by_name_int_cb, MMI_TRUE);
        //mmi_frm_set_multi_protocol_event_handler(MSG_ID_APP_SOC_GET_HOST_BY_NAME_IND, (PsIntFuncPtr)vm_soc_get_host_by_name_int_cb);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_CONNECT_GET_HOST, soc_ctx->sock);
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 12, __LINE__, 
                                    ret, 0, 0, 0, 0, 0);
    }
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 12, __LINE__);
    return ret;
}

static VMINT vm_soc_get_host_by_name_int_cb(void* msg)
{
    vm_sock_context_t* soc_ctx = NULL;
    VM_P_HANDLE handle_p = 0;
    app_soc_get_host_by_name_ind_struct * dns_msg = NULL;
    VMINT (*tmp_cb)(VMINT handle, vm_soc_dns_result * rst);
    VMINT ret = 0;
    vm_soc_dns_result result_tmp = {0};

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_S, 13, __LINE__);

    if (NULL == msg)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E1, 13, __LINE__);
        return MMI_FALSE;
    }

    dns_msg = (app_soc_get_host_by_name_ind_struct *)msg;
	//abm hold
    soc_ctx = vm_get_socket_context(dns_msg->request_id, 0);
    if (NULL == soc_ctx)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E2, 13, __LINE__);
        return MMI_FALSE;
    }
    
    tmp_cb = (VMINT (*)(VMINT handle, vm_soc_dns_result * rst))vm_soc_ctx_cb_pop(soc_ctx);
    handle_p = vm_res_get_process_handle(VM_RES_TYPE_TCP_HANDLE, 
            soc_ctx->res_handle);
            
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                        dns_msg->request_id, 
                        soc_ctx ? soc_ctx->res_handle : 0, 
                        handle_p, 
                        soc_ctx->cb, 
                        soc_ctx->callback, 
                        dns_msg->result);

    if (tmp_cb && (0 <= handle_p))
    {
        if (!dns_msg->result)
        {
            result_tmp.error_cause = dns_msg->error_cause;
            g_mre_soc_error_cause = dns_msg->error_cause;

//abm hold
            if (soc_ctx->callback)
                TCP_PMNG_WRAP_CALLBACK(handle_p, 
                    soc_ctx->callback, soc_ctx->user_data, soc_ctx->res_handle, VM_TCP_EVT_HOST_NOT_FOUND);
            if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
            {
//abm hold
                ret = tmp_cb(soc_ctx->res_handle, &result_tmp);
                vm_pmng_reset_ctx();
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                                            ret, result_tmp.address, result_tmp.num, result_tmp.error_cause, 0, 0);
            }
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_FAILURE, 13, __LINE__, result_tmp.error_cause);

            return MMI_FALSE;
        }
        else
        {        
            result_tmp.num = (VMINT)dns_msg->num_entry;
            memcpy(result_tmp.address, dns_msg->entry, VM_SOC_DNS_MAX_ADDR*4);
            g_mre_soc_error_cause = 0;
            {
            VMINT i = 0;
            kal_uint8 * p = NULL;
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                result_tmp.num, 0, 0, 0, 0, 0);
            for (i = 0; i < result_tmp.num; i ++)
            {
                p = (kal_uint8*)(result_tmp.address + i);
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                                                        p[0],
                                                        p[1],
                                                        p[2],
                                                        p[3], 0, 0);
            }
            }
            if (VM_PMNG_OP_OK == vm_pmng_set_ctx(handle_p))
            {
//abm hold
                ret = tmp_cb(soc_ctx->res_handle, &result_tmp);
                vm_pmng_reset_ctx();
                MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
                                            ret, result_tmp.address, result_tmp.num, result_tmp.error_cause, 0, 0);
            }
                
            return MMI_FALSE;
        }
    }
    else
    {
        
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_LOG, 13, __LINE__, 
            dns_msg->request_id, handle_p, soc_ctx->cb, dns_msg->result, 0, 0);
    }
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_SOC_HOST_E, 13, __LINE__);

    return ret;
}

static MMI_BOOL vm_get_host_by_name(void* inMsg)
{
    vm_sock_context_t* context_ptr = NULL;
    void (*notify_callback)(VMINT handle, VMINT event, void *user_data) = NULL;
    app_soc_get_host_by_name_ind_struct* dns_ind = (app_soc_get_host_by_name_ind_struct*)inMsg;

    if ((context_ptr = vm_get_socket_context(dns_ind->request_id, 0)) != NULL)
    {
        return MMI_FALSE;
    }

    if (dns_ind && dns_ind->result != FALSE)
    {
        sockaddr_struct addr;
	//abm hold
        VM_P_HANDLE processHandle = vm_res_get_process_handle(
            VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);
    
        g_mre_soc_error_cause = 0;
        if(context_ptr->socket_state != conn_host_by_name)
        {
            /* 当前的状态不为get host by name 状态。    */
            MMI_TRACE(MMI_MRE_TRC_WARNING, TRC_MRE_VMSOCK_2034 , 
                dns_ind->request_id, context_ptr->socket_state);
            return MMI_TRUE;
        }

        memset(&addr, 0x00, sizeof(addr));
        memcpy(addr.addr, dns_ind->addr, dns_ind->addr_len);
        addr.addr_len = dns_ind->addr_len;
        addr.port = context_ptr->port;

        switch (soc_connect(context_ptr->sock, &addr))
        {
        case SOC_SUCCESS:
        case SOC_WOULDBLOCK:
                    mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify, MMI_TRUE);
                    //mmi_frm_set_multi_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_notify);
            break;
        default:
            notify_callback = context_ptr->callback;    
            if (notify_callback)
            {
                if (processHandle >= 0)
                {
//abm hold
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        notify_callback, context_ptr->user_data, context_ptr->res_handle, VM_TCP_EVT_PIPE_BROKEN);
                }
                else
                {
                    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_2068 , processHandle);
                }
            }               
            
            vm_close_and_free_socket(dns_ind->request_id);
            break;
        }

        return MMI_TRUE;
    }
    else                                // dns analyse error.
    {
        if (dns_ind)
        {
            //abm hold
            VM_P_HANDLE processHandle = vm_res_get_process_handle(
                VM_RES_TYPE_TCP_HANDLE, context_ptr->res_handle);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2081 , dns_ind->request_id);
            
            g_mre_soc_error_cause = dns_ind->error_cause;
            notify_callback = context_ptr->callback;
            if (notify_callback)
            {
                if (processHandle >= 0)
                {
//abm hold
                    TCP_PMNG_WRAP_CALLBACK(processHandle, 
                        notify_callback, context_ptr->user_data, context_ptr->res_handle, 
                        VM_TCP_EVT_HOST_NOT_FOUND);
                }
                else
                {
                    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_2106 , 
                        processHandle);
                }
            }
            
            vm_close_and_free_socket(dns_ind->request_id);

            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}

static VMINT vm_get_apn_info_internal(vm_apn_info_ext *apn_info, kal_uint32 accid)
{
    MMI_BOOL bret = MMI_FALSE;
    srv_dtcnt_prof_proxy_info_struct proxy_info = {0};

    bret = srv_dtcnt_get_proxy_info(accid, &proxy_info, SRV_DTCNT_ACCOUNT_PRIMARY);
    if (bret)
    {
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
            proxy_info.use_proxy,
            proxy_info.px_addrtype,
            proxy_info.px_service,
            0,
            0,
            0,
            54, __LINE__);
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
            0,
            0,
            0,
            0,
            0,
            proxy_info.acc_id,
            56, __LINE__);
        
        apn_info->apn_info_id = proxy_info.use_proxy;
        apn_info->proxy_port = proxy_info.px_port;
        apn_info->operator_id[0] = '\0';
        apn_info->operator_name[0] = '\0';
        
        strncpy((char *)apn_info->proxy_ip, (const char *)proxy_info.px_addr, 16);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2164 , apn_info->proxy_ip);
        
        apn_info->apn_proxy[0] = '\0';
        apn_info->apn_no_proxy[0] = '\0';
        memcpy(apn_info->user_name, proxy_info.px_authid, 16);
        apn_info->user_name[15] = '\0';
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2170 , apn_info->user_name);
        memcpy(apn_info->pass_word, proxy_info.px_authpw, 16);
        apn_info->pass_word[15] = '\0';
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2173 , apn_info->pass_word);
        
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
            proxy_info.px_addr[0], 
            proxy_info.px_addr[1],
            proxy_info.px_addr[2],
            proxy_info.px_addr[3],
            proxy_info.px_port,
            0,
            55, __LINE__);
        
        vm_trace("[APN DFT] proxy_ip[%s]", apn_info->proxy_ip);
        vm_trace("[APN DFT] px_authid[%s]", proxy_info.px_authid);
        vm_trace("[APN DFT] px_authpw[%s]", proxy_info.px_authpw);
        vm_trace("[APN DFT] px_startpage[%s]", proxy_info.px_startpage);
        
    }
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_E2, 57, __LINE__);
        return -3;
    }
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_E, 58, __LINE__);
    return 0;
}

VMINT vm_get_default_apn_info(vm_apn_info_ext * apn_info)
{
    VMUINT8 app_id = 0;
    kal_uint32 accid = 0;
    MMI_BOOL bret = MMI_FALSE;
    VMINT i = 0, j = 0;
        
    //vm_trace("[default] S");
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_S, 51, __LINE__);

    if (NULL == apn_info)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_E1, 52, __LINE__);
        return -2;
    }

    accid = vm_get_account_id(CBM_DEFAULT_ACCT_ID, 0);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_APN_DFT_LOG, 
        0,
        0,
        0,
        0,
        0,
        accid,
        53, __LINE__);
    
    return vm_get_apn_info_internal(apn_info, accid);
}

VMINT vm_get_apn_info(vm_apn_info_ext *current_apn_info)
{
    MMI_TRACE(MMI_MRE_TRC_ERROR, TRC_MRE_VMSOCK_2125 , g_mre_account_id);
    return vm_get_apn_info_internal(current_apn_info, g_mre_account_id);
}


typedef struct
{
    VMUINT jid;
    VMINT res_id;
    void (*cb)(vm_wlan_loc_data_t * data, void * user_data);
}vm_wlan_loc_context_t;

static void vm_wlan_loc_free_ctx(VMINT jid);
static vm_wlan_loc_context_t * vm_wlan_loc_malloc_ctx(void);
static vm_wlan_loc_context_t * vm_wlan_loc_get_ctx(VMUINT jid);


static void vm_wlan_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;

    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_WLAN_LOC)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_WLAN_LOC, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p)
                vm_wlan_loc_free_ctx(ctx_p->jid);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2211 );
        }
        else
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2215 );
        }
        vm_res_release_data(VM_RES_TYPE_WLAN_LOC, resHandle);
        vm_res_findclose(VM_RES_TYPE_WLAN_LOC); 
    }
}

static void vm_wlan_loc_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        vm_wlan_free_resource(process_handle);
        break;
    }
}


static VMINT vm_wlan_loc_initialize_resource(void)
{
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_WLAN_LOC, 
        vm_wlan_loc_notify_process_status) != 0)
    {
        return -1;
    }

    ///TODO: other init.
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2234 );


    return 0;
}

static VMINT vm_wlan_loc_finialize_resource(void)
{
    vm_wlan_free_resource(-1);
    
    vm_res_type_set_notify_callback(VM_RES_TYPE_WLAN_LOC, NULL);

    ///TODO: Deregister WPS relate functions

    return 0;
}

static VMINT vm_wifi_loc_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (vm_wlan_loc_initialize_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        vm_wlan_loc_finialize_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2287 , event);
        return -2;
    }

    return 0;
}

VMINT _vm_reg_wifi_loc_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("WIF", (MOD_EVT_PROCESS)vm_wifi_loc_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2300 , res_code);
    }

    return res_code;
}

static vm_wlan_loc_context_t * vm_wlan_loc_get_ctx(VMUINT jid)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;

    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_WLAN_LOC)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_WLAN_LOC, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p->jid == jid)
            {
                vm_res_findclose(VM_RES_TYPE_WLAN_LOC);
                return ctx_p;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_WLAN_LOC)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_WLAN_LOC, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
            {
                if (ctx_p->jid == jid)
                {
                    vm_res_findclose(VM_RES_TYPE_WLAN_LOC);
                    return ctx_p;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_WLAN_LOC);
    }	
    return NULL;
}


static vm_wlan_loc_context_t * vm_wlan_loc_malloc_ctx(void)
{
    vm_wlan_loc_context_t * ctx_p = NULL;

    if ((ctx_p = _vm_kernel_calloc(sizeof(vm_wlan_loc_context_t))) != NULL)
    {
        if ((ctx_p->res_id = vm_res_save_data(VM_RES_TYPE_WLAN_LOC, 
            (void*)ctx_p, sizeof(ctx_p), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            return ctx_p;
        }
        else
        {
            _vm_kernel_free(ctx_p);
        }
    }

    return NULL;
}

static void vm_wlan_loc_free_ctx(VMINT jid)
{
    vm_wlan_loc_context_t * ctx_p = NULL;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2792 );
    ctx_p = vm_wlan_loc_get_ctx(jid);
    if (ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2796 );
        if (VM_RES_OK == vm_res_release_data(VM_RES_TYPE_WLAN_LOC, ctx_p->res_id))
        {
            _vm_kernel_free(ctx_p);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2700 );
        }
    }
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2704 );
}



static void vm_srv_dtcnt_wlan_scan_res_cb(U32 job_id,
                                                                                        void *user_data,
                                                                                        srv_dtcnt_wlan_scan_result_struct *scan_res)
{
    VM_P_HANDLE p_handle = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;
    vm_wlan_loc_data_t data = {0};
    vm_wlan_loc_supc_abm_bss_info_struct * info = NULL;
    VMINT i = 0;
    VMINT jid = -1;

    ctx_p = vm_wlan_loc_get_ctx((VMUINT)(job_id));
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2385 );
        return;
    }
    
    p_handle = vm_res_get_process_handle(VM_RES_TYPE_WLAN_LOC, ctx_p->res_id);
    if (0 > p_handle)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2392 );
        return;
    }

    if (NULL == scan_res)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2398 );
        return;
    }

    jid = ctx_p->jid;
    
    data.ap_list_num = scan_res->ap_list_num;

    if (data.ap_list_num > 0)
    {
        info = _vm_kernel_malloc(data.ap_list_num * sizeof(vm_wlan_loc_supc_abm_bss_info_struct));
        for (i = 0; i < data.ap_list_num; i++)
        {
            data.ap_list[i] = (const vm_wlan_loc_supc_abm_bss_info_struct *)&info[i];
            memcpy(((vm_wlan_loc_supc_abm_bss_info_struct*)(data.ap_list[i]))->bssid, 
                scan_res->ap_list[i]->bssid, 
                VM_WLAN_LOC_MAC_ADDR_LEN > WNDRV_MAC_ADDRESS_LEN ? WNDRV_MAC_ADDRESS_LEN : VM_WLAN_LOC_MAC_ADDR_LEN);
            ((vm_wlan_loc_supc_abm_bss_info_struct*)(data.ap_list[i]))->rssi = scan_res->ap_list[i]->rssi;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2414 , 
                data.ap_list[i]->bssid[0],
                data.ap_list[i]->bssid[1],
                data.ap_list[i]->bssid[2],
                data.ap_list[i]->bssid[3],
                data.ap_list[i]->bssid[4],
                data.ap_list[i]->bssid[5],
                data.ap_list[i]->rssi);
        } 
        
    }
    data.handle = ctx_p->res_id;
    data.result = (vm_wlan_loc_scan_result_enum)scan_res->result;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2428 , data.ap_list_num, data.handle, data.result);

    PMNG_WRAP_CALLBACK(p_handle, ctx_p->cb(&data, user_data));

    if (info)
    {
        _vm_kernel_free(info);
    }

    vm_wlan_loc_free_ctx(jid);

}


VMINT vm_wlan_loc_search(void (*callback)(vm_wlan_loc_data_t * data, void * user_data), void * user_data)
{
    U32 jid = 0;
    vm_wlan_loc_context_t * ctx_p = NULL;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2447 );
    
#if defined (__MMI_WLAN_FEATURES__) && defined(__MTK_TARGET__) && defined(__TCPIP__)

    
    if (SRV_DTCNT_WLAN_STATUS_INACTIVE == srv_dtcnt_wlan_status())
    {
        return VM_WLAN_LOC_ERR_LOGICAL;
    }
    
    ctx_p = vm_wlan_loc_malloc_ctx();
    if (NULL == ctx_p)
    {
        return VM_WLAN_LOC_ERR_NO_RESOURCE;
    }
    
    jid = srv_dtcnt_wlan_scan(vm_srv_dtcnt_wlan_scan_res_cb, user_data);
    if (0 >= jid)
    {
        vm_wlan_loc_free_ctx(jid);
        return VM_WLAN_LOC_ERR_BUSY;
    }

    ctx_p->jid = jid;
    ctx_p->cb = callback;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2468 , ctx_p->jid, ctx_p->cb);

    
    return ctx_p->res_id;

#else

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2475 );
    return VM_WLAN_LOC_ERR_NOT_SUPPORT;

#endif
}

VMINT vm_wlan_loc_search_abort(VMINT handle)
{

    vm_wlan_loc_context_t * ctx_p = NULL;
    VMINT size = 0;
    VMINT jid = 0;

MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2487 );
#if defined (__MMI_WLAN_FEATURES__) && defined(__MTK_TARGET__) && defined(__TCPIP__)

    if (VM_RES_OK != vm_res_get_data(VM_RES_TYPE_WLAN_LOC, handle, (void**)&ctx_p, &size))
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2733 );
        return VM_WLAN_LOC_ERR_BAD_PARAM;
    }
    else
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2740 );
            return VM_WLAN_LOC_ERR_INTERNAL;
        }
    }

    if (0 >= ctx_p->jid)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2747 );
        return VM_WLAN_LOC_ERR_INTERNAL;
    }

    jid = ctx_p->jid;
    srv_dtcnt_wlan_scan_abort((U32)jid);
    vm_wlan_loc_free_ctx(jid);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2510 , ctx_p->jid);
    return 0;

#else
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2514 );
    return VM_WLAN_LOC_ERR_NOT_SUPPORT;
#endif

}

VMINT vm_wlan_loc_get_connected_info(vm_wlan_loc_supc_abm_bss_info_struct * info)
{
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2522 );
    
#if defined (__MMI_WLAN_FEATURES__) && defined(__MTK_TARGET__) && defined(__TCPIP__)
    if (NULL == info)
    {
        return VM_WLAN_LOC_ERR_BAD_PARAM;
    }
    
    if (MMI_FALSE == srv_dtcnt_wlan_get_connected_ap_rssi((S32*)&(info->rssi)))
    {
        return VM_WLAN_LOC_ERR_LOGICAL;
    }


    if (MMI_FALSE == srv_dtcnt_wlan_get_connected_ap_bssid(info->bssid))
    {
        return VM_WLAN_LOC_ERR_LOGICAL;
    }


    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2542 , 
        info->bssid[0],
        info->bssid[1],
        info->bssid[2],
        info->bssid[3],
        info->bssid[4],
        info->bssid[5],
        info->rssi);
    
    return 0;
#else

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_2554 );
    return VM_WLAN_LOC_ERR_NOT_SUPPORT;

#endif

}

//#define _MRE_UDP_DEBUG_
typedef struct _vm_udp_ctx_t
{
    VM_P_HANDLE p_hdl;
    void (*cb)(VMINT hdl, VMINT event);
    VMINT soc_id;
    VMINT res_id;
    VMINT apn;
	//abm hold
    kal_uint32 account_id;
}vm_udp_ctx_t;

static void _vm_udp_free_ctx(vm_udp_ctx_t * ctx_p);
static vm_udp_ctx_t * _vm_udp_malloc_ctx(void);
static vm_udp_ctx_t* _vm_udp_get_ctx_by_socid(VMINT sock_id);

static MMI_BOOL _vm_udp_cb(void * data);

static void vm_udp_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    
    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_UDP_HANDLE)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            _vm_udp_free_ctx(ctx_p);
        }
        else
        {
        }
        vm_res_release_data(VM_RES_TYPE_UDP_HANDLE, resHandle);
        vm_res_findclose(VM_RES_TYPE_UDP_HANDLE); 
    }
}

static void vm_udp_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        break;
    }
}

static VMINT vm_udp_initialize_resource(void)
{
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_UDP_HANDLE, 
        vm_udp_notify_process_status) != 0)
    {
        return -1;
    }

    ///TODO: other init.


    return 0;
}

static VMINT vm_udp_finialize_resource(void)
{
    vm_udp_free_resource(-1);
    
    vm_res_type_set_notify_callback(VM_RES_TYPE_UDP_HANDLE, NULL);
    
    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
        (PsIntFuncPtr)_vm_udp_cb);

    return 0;
}

static VMINT vm_udp_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (vm_udp_initialize_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        vm_udp_finialize_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        return -2;
    }

    return 0;
}

VMINT _vm_reg_udp_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("UDP", (MOD_EVT_PROCESS)vm_udp_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
        
    }

    return res_code;
}

static void _vm_udp_free_ctx(vm_udp_ctx_t * ctx_p)
{    
    if (NULL == ctx_p)
    {
        return;
    }

    if (ctx_p->soc_id >= 0)
    {
        soc_close(ctx_p->soc_id);
        ctx_p->soc_id = -1;
    }

	//abm hold
    ctx_p->account_id = 0;
    
    vm_res_release_data(VM_RES_TYPE_UDP_HANDLE, ctx_p->res_id);
    _vm_kernel_free(ctx_p);
    return;
}

static vm_udp_ctx_t * _vm_udp_malloc_ctx(void)
{
    vm_udp_ctx_t * ctx_p = NULL;

    if ((ctx_p = _vm_kernel_calloc(sizeof(vm_udp_ctx_t))) != NULL)
    {
        if ((ctx_p->res_id = vm_res_save_data(VM_RES_TYPE_UDP_HANDLE, 
            (void*)ctx_p, sizeof(ctx_p), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            ctx_p->p_hdl = vm_pmng_get_current_handle();
            return ctx_p;
        }
        else
        {
            _vm_kernel_free(ctx_p);
        }
    }

    return NULL;
}

static vm_udp_ctx_t* _vm_udp_get_ctx_by_socid(VMINT soc_id)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_udp_ctx_t* ctx_p = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p->soc_id == soc_id)
            {
                vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                return ctx_p;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
                resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
            {
                if (ctx_p->soc_id == soc_id)
                {
                    vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                    return ctx_p;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
    }	
    return NULL;
}



VMINT vm_udp_create(VMINT port, VMINT apn, void (*callback)(VMINT hdl, VMINT event), VMINT loopback)
{
    VMUINT acct_id = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    VMUINT8 option = 0;
    VMINT8 ret = 0;
    sockaddr_struct addr;
    VMUINT8 app_id = 0;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 1, __LINE__);
    if (0 >= port || NULL == callback)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 1, __LINE__);
        return -2;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        apn,
        app_id, 
        acct_id, 
        0, 
        0,
        0,
        1, __LINE__);
    if (loopback)
    {
        vm_get_app_id(apn, &app_id);
        acct_id = vm_get_account_id(CBM_LOOPBACK_ACCT_ID, app_id);
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
    }
    else
    {
        if (VM_E_SOC_SUCCESS != vm_get_encoded_dtacct_id(apn, &acct_id))
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 1, __LINE__);
            return -2;
        }
    }

    ctx_p = _vm_udp_malloc_ctx();
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 1, __LINE__);
        return -3;
    }

    ctx_p->apn = apn;
    ctx_p->cb = callback;

    ctx_p->soc_id = soc_create(SOC_PF_INET, SOC_SOCK_DGRAM, 0, MOD_MMI, acct_id);
    if (0 > ctx_p->soc_id)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 1, __LINE__);
        return -4;
    }

    
    option = KAL_TRUE;
    ret = soc_setsockopt(ctx_p->soc_id, SOC_NBIO, &option, sizeof(option));
    if (SOC_SUCCESS != ret)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E5, 1, __LINE__);
        return -5;
    }
    
    option = SOC_READ | SOC_WRITE | SOC_CLOSE;
    ret = soc_setsockopt(ctx_p->soc_id, SOC_ASYNC, &option, sizeof(option));
    if (SOC_SUCCESS != ret)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E6, 1, __LINE__);
        return -6;
    }

    addr.sock_type = SOC_SOCK_DGRAM;
    addr.addr_len = 0x04;
    addr.port = port;
#ifdef _MRE_UDP_DEBUG_
    addr.addr[0] = 0;
    addr.addr[1] = 0;
    addr.addr[2] = 0;
    addr.addr[3] = 0;
#else
    //addr.addr[0] = 0;
    //addr.addr[1] = 0;
    //addr.addr[2] = 0;
    //addr.addr[3] = 0;
    memset(addr.addr, 0, sizeof(addr.addr));
#endif
    ret = soc_bind(ctx_p->soc_id, &addr);
    if (SOC_SUCCESS != ret)
    {
        _vm_udp_free_ctx(ctx_p);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E7, 1, __LINE__);
        return -7;
    }


    mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)_vm_udp_cb, MMI_TRUE);
    //mmi_frm_set_multi_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)_vm_udp_cb);

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        addr.addr[0], 
        addr.addr[1], 
        addr.addr[2], 
        addr.addr[3],
        addr.port,
        ctx_p->res_id,
        1, __LINE__);

	//abm hold
    ctx_p->account_id = acct_id;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 1, __LINE__);
    
    return ctx_p->res_id;
}

VMINT vm_udp_sendto(VMINT hdl, const void * buf, VMINT32 len, const vm_sockaddr_struct * addr)
{
    VMINT32 ret = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    VMINT size = 0;
    //srv_dtcnt_sim_type_enum sim_type;
    sockaddr_struct toaddr;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 2, __LINE__);
    if (NULL == buf ||
        0 == len ||
        NULL == addr)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 2, __LINE__);
        return -2;
    }
    
    if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
        hdl, (void**)&ctx_p, &size) < 0 || NULL != ctx_p)
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 2, __LINE__);
            return -3;
        }
    }

    memcpy(toaddr.addr, addr->addr, addr->addr_len);
    toaddr.addr_len = addr->addr_len;
    toaddr.port = addr->port;
    toaddr.sock_type = SOC_SOCK_DGRAM;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ctx_p->soc_id, 
        buf, 
        len, 
        hdl,
        0,
        0,
        2, __LINE__);
        
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        toaddr.addr[0], 
        toaddr.addr[1], 
        toaddr.addr[2], 
        toaddr.addr[3],
        toaddr.port,
        0,
        2, __LINE__);
        
    //srv_dtcnt_get_sim_preference(&sim_type);
    if ((stub_tcp_is_support_wifi() && VM_TCP_APN_WIFI == ctx_p->apn)
#ifdef __COSMOS_MMI_PACKAGE__      
      //  || (srv_mre_da_get_account_id(SRV_MRE_DA_WIFI_ONLY) == 1)
      //  || (sim_type == SRV_DTCNT_SIM_TYPE_NONE)
#endif
        )
    {
        if (SRV_DTCNT_WLAN_STATUS_INACTIVE == srv_dtcnt_wlan_status())
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 2, __LINE__);
            return -4;
        }
    }
    ret = soc_sendto(ctx_p->soc_id, (kal_uint8*)buf, (kal_int32)len, 0, &toaddr);
    if (0 > ret)
    {
        //_vm_udp_free_ctx(ctx_p);
        if (SOC_WOULDBLOCK == ret)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 2, __LINE__);
            return 0;
        }
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 2, __LINE__);
        //return -4;
    }

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ret, 
        0, 
        0, 
        0,
        0,
        0,
        2, __LINE__);
        
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 2, __LINE__);
    return ret;
}

VMINT vm_udp_recvfrom(VMINT hdl, void * buf, VMINT32 len, vm_sockaddr_struct * addr)
{
    VMINT32 ret = 0;
    vm_udp_ctx_t * ctx_p = NULL;
    VMINT size = 0;
    sockaddr_struct fromaddr;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 3, __LINE__);
    if (NULL == buf ||
        0 == len ||
        NULL == addr)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 3, __LINE__);
        return -2;
    }   

    if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
        hdl, (void**)&ctx_p, &size) < 0 || NULL != ctx_p)
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 3, __LINE__);
            return -3;
        }
    }
/*
    strncpy(fromaddr.addr, addr->addr, addr->addr_len);
    fromaddr.addr_len = addr->addr_len;
    fromaddr.port = addr->port;
    fromaddr.sock_type = SOC_SOCK_DGRAM;
*/

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ctx_p->soc_id, 
        buf, 
        len, 
        hdl,
        0,
        0,
        3, __LINE__);



    ret = soc_recvfrom(ctx_p->soc_id, (kal_uint8*)buf, (kal_int32)len, 0, &fromaddr);
    if (0 > ret)
    {
        //_vm_udp_free_ctx(ctx_p);
        if (SOC_WOULDBLOCK == ret)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 3, __LINE__);
            return 0;
        }
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 3, __LINE__);
        //return -4;
    }

    memcpy(addr->addr, fromaddr.addr, fromaddr.addr_len);
    addr->addr_len = fromaddr.addr_len;
    addr->port = fromaddr.port;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        addr->addr[0], 
        addr->addr[1], 
        addr->addr[2], 
        addr->addr[3],
        addr->port,
        ret,
        3, __LINE__);

    

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 3, __LINE__);
    return ret;
}

VMINT vm_udp_close(VMINT hdl)
{
    vm_udp_ctx_t * ctx_p = NULL;   
    VMINT size = 0;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 4, __LINE__);
    if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
        hdl, (void**)&ctx_p, &size) < 0 || NULL != ctx_p)
    {
        if (NULL == ctx_p)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 4, __LINE__);
            return -2;
        }
    }

    _vm_udp_free_ctx(ctx_p);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 4, __LINE__);
    return 0;
}

static MMI_BOOL _vm_udp_cb(void * data)
{
    app_soc_notify_ind_struct * ind = (app_soc_notify_ind_struct *)data;
    vm_udp_ctx_t * ctx_p = NULL;
    VMINT state = 0, event;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_S, 5, __LINE__);
    if (NULL == ind)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E1, 5, __LINE__);
        return MMI_FALSE;
    }
    
    ctx_p = _vm_udp_get_ctx_by_socid(ind->socket_id);
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E2, 5, __LINE__);
        return MMI_FALSE;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_LOG,
        ctx_p->p_hdl, 
        ctx_p->res_id, 
        ind->event_type, 
        0,
        0,
        0,
        5, __LINE__);
        
    switch (ind->event_type)
    {
    case SOC_WRITE:
        {
            event = VM_UDP_EVT_WRITE;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 5, __LINE__);
        }break;
    case SOC_READ:
        {
            event = VM_UDP_EVT_READ;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E4, 5, __LINE__);
        }break;
    case SOC_CLOSE:
        {
            event = VM_UDP_EVT_PIPE_CLOSED;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E5, 5, __LINE__);
            
        }break;
    default:
        {
            event = ind->event_type;
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E3, 6, __LINE__);
        }break;
    }
    PMNG_WRAP_CALLBACK(ctx_p->p_hdl, 
        ctx_p->cb(ctx_p->res_id, event));
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_UDP_E, 5, __LINE__);
    return MMI_TRUE;
}

	//abm hold
kal_uint32 vm_get_udp_acctid_by_resid(VMINT res_id)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_udp_ctx_t* ctx_p = NULL;
    
    if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            if (ctx_p->res_id == res_id)
            {
                vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                return ctx_p->account_id;
            }
        }

        while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_UDP_HANDLE)) != VM_RES_NOT_FIND)
        {
            if (vm_res_get_data(VM_RES_TYPE_UDP_HANDLE, 
                resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
            {
                if (ctx_p->res_id == res_id)
                {
                    vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
                    return ctx_p->account_id;
                }
            }
        }
        vm_res_findclose(VM_RES_TYPE_UDP_HANDLE);
    }   
    return 0;
}

VMINT vm_srv_nw_info_get_protocol(VMINT sim_card)
{
    if (sim_card != MMI_SIM1 &&
        sim_card != MMI_SIM2 &&
        sim_card != MMI_SIM3 &&
        sim_card != MMI_SIM4)
    {
        return -2;
    }
    #ifdef __MMI_TELEPHONY_SUPPORT__
    return (VMINT)srv_nw_info_get_protocol((mmi_sim_enum)sim_card);
	#else
	return 0;
    #endif
}



VMINT vm_srv_nw_info_channel_supports(VMINT sim_card, vm_network_capability_enum type)
{
    if (sim_card != MMI_SIM1 &&
    sim_card != MMI_SIM2 &&
    sim_card != MMI_SIM3 &&
    sim_card != MMI_SIM4)
    {
        return -2;
    }
    #ifdef __MMI_TELEPHONY_SUPPORT__
    return srv_nw_info_channel_supports((mmi_sim_enum)sim_card, (mmi_network_capability_enum)type);
	#else
	return MMI_FALSE;
    #endif
}

VMINT vm_srv_nw_info_get_service_availability(VMINT sim_card)
{
    if (sim_card != MMI_SIM1 &&
        sim_card != MMI_SIM2 &&
        sim_card != MMI_SIM3 &&
        sim_card != MMI_SIM4)
    {
        return -2;
    }
    #ifdef __MMI_TELEPHONY_SUPPORT__
    return (VMINT)srv_nw_info_get_service_availability((mmi_sim_enum)sim_card);
	#else
	return 0;
    #endif
}

VMINT vm_srv_nw_info_get_sim_dn_status(VMINT sim_card)
{
    if (sim_card != MMI_SIM1 &&
        sim_card != MMI_SIM2 &&
        sim_card != MMI_SIM3 &&
        sim_card != MMI_SIM4)
    {
        return -2;
    }
    #ifdef __MMI_TELEPHONY_SUPPORT__
    return (VMINT)srv_nw_info_get_sim_dn_status((mmi_sim_enum)sim_card);
	#else
	return 0;
    #endif
}


#include "GlobalResDef.h"
#if !defined(__IOT__)
#include "DataAccountCuiGprot.h"
#endif
#include "vmsock.h"
#include "DataAccountGprot.h"
#include "cbm_api.h"


//#define DTCNT_DEBUG


#ifdef DTCNT_DEBUG
#include "WAPProfResDef.h"
#endif

static mmi_ret vm_dtacct_select_gproc(mmi_event_struct* evt);
extern VMINT vm_get_app_id(VMINT apn, VMUINT8 *app_id);
extern _vm_pcb_t* vm_sh_pcb_in_pt(VMINT search_type, VMINT value, VM_PROCESS_STATUS* status);
typedef struct
{
    mmi_id dtcnt_cid;
    mmi_id parent_gid;
    VM_P_HANDLE p_hdl;
    VMINT (*cb)(VMUINT32 dtacct);
    VMINT sim_id;
}vm_dtacct_selection_ctx_t;

static vm_dtacct_selection_ctx_t dtacct_ctx;

VMINT vm_dtacct_set(VMINT sim_id, VMUINT32 dtacct)
{
    _vm_pcb_t * pcb = NULL;
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    VMINT i = 0;

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_S, 1, __LINE__);

    if (MMI_SIM_TOTAL <= sim_id || 0 > sim_id || 0 == dtacct)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E1, 1, __LINE__);
        return -2;
    }
    
    //dtacct_ctx.cb = callback;
    dtacct_ctx.dtcnt_cid = GRP_ID_INVALID;    
    dtacct_ctx.p_hdl = vm_pmng_get_current_handle();
    
    if (0 == dtacct_ctx.p_hdl)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E2, 1, __LINE__);
        return -3;
    }

    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, dtacct_ctx.p_hdl, &status);
    if (NULL == pcb)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E3, 1, __LINE__);
        return -4;
    }

    pcb->accountId = dtacct;
    pcb->sim_id = sim_id;
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                    pcb->sim_id,
                    0,
                    0,
                    0,
                    0,
                    pcb->accountId,
                    1, __LINE__);

    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E, 1, __LINE__);

    return 0;
}

VMINT vm_dtacct_select(VMINT sim_id, VMINT (*callback)(VMUINT32 dtacct))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__PLUTO_MMI_PACKAGE__) && !defined(__IOT__)
    cui_dtcnt_select_run_struct select_run_info;
#endif
    VMINT i = 0;
    //kal_uint32 acct_id;
    U32 sim_account_id[MMI_SIM_TOTAL] = {0};
    VMUINT8 cbm_app_id = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    dtacct_ctx.dtcnt_cid = GRP_ID_INVALID;    
    dtacct_ctx.p_hdl = vm_pmng_get_current_handle();
    dtacct_ctx.cb = callback;
    dtacct_ctx.sim_id = sim_id;

#if defined(__IOT__)
    return -2;
#else

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_S, 2, __LINE__);
    if (0 == dtacct_ctx.p_hdl)
    {
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E1, 2, __LINE__);
        return -2;
    }
    
#ifdef __PLUTO_MMI_PACKAGE__
    //dtacct_ctx.parent_gid = mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_AUTO_GEN, vm_dtacct_select_gproc, (void*)NULL);
    //mmi_frm_group_enter(dtacct_ctx.parent_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    //dtacct_ctx.parent_gid = mmi_frm_group_create_ex(GRP_ID_ROOT, (MMI_ID)GRP_ID_AUTO_GEN, vm_dtacct_select_gproc, NULL, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    //dtacct_ctx.dtcnt_cid = cui_dtcnt_select_create((MMI_ID)dtacct_ctx.parent_gid);
    //#ifdef DTCNT_DEBUG
    dtacct_ctx.parent_gid = mmi_frm_group_create_ex(GRP_ID_ROOT, 
                                    (MMI_ID)GRP_ID_AUTO_GEN, 
                                    vm_dtacct_select_gproc, 
                                    NULL, 
                                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
    dtacct_ctx.dtcnt_cid = cui_dtcnt_select_create((MMI_ID)dtacct_ctx.parent_gid);
    //#endif
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                    dtacct_ctx.parent_gid,
                    dtacct_ctx.dtcnt_cid,
                    MMI_SIM_TOTAL,
                    0,
                    0,
                    0,
                    21, __LINE__);
                    

    memset(&select_run_info, 0, sizeof(cui_dtcnt_select_run_struct));
    
#ifdef __PLUTO_MMI_PACKAGE__
    select_run_info.AppMenuID = 0;
#endif

    vm_get_app_id(VM_TCP_APN_CMNET, &cbm_app_id);
    select_run_info.app_id = cbm_app_id;
    select_run_info.bearers = DATA_ACCOUNT_BEARER_GPRS;
    select_run_info.option = CUI_DTCNT_SELECT_NOT_SUBSCRIBE_ACCOUNT;
    select_run_info.type = CUI_DTCNT_SELECT_TYPE_NORMAL;
    select_run_info.sim_selection = (cui_dtcnt_select_sim_enum)sim_id;//CUI_DTCNT_SELECT_SIM_ALL;
    select_run_info.icon_id = IMAGE_MRE_ICON;
    for (i = 0; i < MMI_SIM_TOTAL; i++)
    {
        select_run_info.sim_account_id[i] = CBM_DEFAULT_ACCT_ID;
    }
    
    cui_dtcnt_select_set_param(dtacct_ctx.dtcnt_cid, &select_run_info);
    cui_dtcnt_select_run(dtacct_ctx.dtcnt_cid);
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                    dtacct_ctx.dtcnt_cid,
                    cbm_app_id,
                    0,
                    0,
                    0,
                    0, 
                    22, __LINE__);



#else
    {
        extern MMI_ID vm_vapp_dtcnt_select_run(VM_P_HANDLE p_hdl, VMINT (*cb)(VMUINT32 dtacct), VMINT sim_id);
        vm_vapp_dtcnt_select_run(dtacct_ctx.p_hdl, dtacct_ctx.cb, dtacct_ctx.sim_id);
    }
    
#endif

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E, 2, __LINE__);
    return 0;
#endif /* !defined(__IOT__) */
}

static mmi_ret vm_dtacct_select_gproc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if !defined(__IOT__)

//    cbm_account_info_struct data_account_info;
    U32 get_account_id = 0;
    U8 primary_dtcnt_id = (U8) -1;
    U8 secondary_dtcnt_id = (U8) -1;
    //cui_dtcnt_sim_enum sim;
    _vm_pcb_t* pcb = NULL;
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    cui_dtcnt_select_event_any_sim_selected_struct *event =  (cui_dtcnt_select_event_any_sim_selected_struct *)evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_S, 3, __LINE__);
    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, dtacct_ctx.p_hdl, &status);
        
    switch(evt->evt_id)
    {
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    case CUI_DTCNT_SELECT_EVENT_ANY_SIM_ACCOUNT_SELECTED:
        {
            /* If user selected an account and press OK, send this event to APPs proc, APP need to save the account ID and close the CUI */            
            PMNG_WRAP_CALLBACK(dtacct_ctx.p_hdl, 
                dtacct_ctx.cb(/*(VMINT)event->selectSim, */(VMUINT32)event->accountId));
            
            //cui_dtcnt_select_close(event->sender_id);
            
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_LOG, 
                            event->selectSim,
                            0,
                            0,
                            0,
                            0,
                            event->accountId,
                            3, __LINE__);
                            
            MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E1, 3, __LINE__);
        }
        break;
    case CUI_DTCNT_SELECT_EVENT_RESULT_OK:
    case CUI_DTCNT_SELECT_EVENT_RESULT_CANCEL:
        /* If CUIs part screen closed abnormally not by user, send this event to APPs proc, APP can just  close the CUI*/
    case CUI_DTCNT_SELECT_EVENT_CLOSE:
        cui_dtcnt_select_close(event->sender_id);
        mmi_frm_group_close((MMI_ID)dtacct_ctx.parent_gid);
        memset(&dtacct_ctx, 0, sizeof(dtacct_ctx));
        MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E2, 3, __LINE__);
    default:
            break;  
    }
#endif /* !defined(__IOT__) */
    
    MMI_TRACE(MMI_MRE_TRC_G4_SOC, TRC_MRE_VMIO_DTCNT_SEL_E, 3, __LINE__);
    return MMI_RET_OK;
}
	//abm hold
static kal_uint32 vm_cbm_get_account_id(vm_res_type_t type, VMINT res_id)
{
    kal_uint32 account_id = 0;
    kal_int8 ret = 0;

    switch (type)
    {
    case VM_RES_TYPE_TCP:
        {
            account_id = vm_get_tcp_acctid_by_resid(res_id);
        }break;
    case VM_RES_TYPE_UDP:
        {
            account_id = vm_get_udp_acctid_by_resid(res_id);
        }break;
#ifdef __MRE_LIB_HTTP__
    case VM_RES_TYPE_HTTP:
        {
            VMUINT32 vm_get_http_acctid_by_resid(VMINT res_id);
            VMUINT32 http_acct_id = 0;
            //res_id = VM_RES_TYPE_HTTP_HANDLE;
            http_acct_id = vm_get_http_acctid_by_resid(res_id);
            account_id = http_acct_id;
        }break;
#endif
#ifdef __MRE_SAL_WPS__
    case VM_RES_TYPE_HTTPS:
        {
            //res_id = VM_RES_TYPE_WPS_HANDLE;
            extern kal_uint32 vm_get_https_acctid_by_chnlid(VMINT channel_id);
            kal_uint32 https_acct_id = 0;
            https_acct_id = vm_get_https_acctid_by_chnlid(res_id);
            account_id = https_acct_id;
        }break;
#endif
    default:
        {
            return 0;
        }
    }

    return account_id;

}

static kal_uint8 g_ap_id = 0;

	//abm hold
VMINT vm_cbm_hold_bearer(vm_res_type_t type, VMINT hdl)
{
    kal_uint32 account_id = 0;
    kal_uint8 ap_id = 0;
    kal_int8 ret = 0;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_S, 1, __LINE__ );
    account_id = vm_cbm_get_account_id(type, hdl);

    if (0 == account_id)
    {
        return -2;
    }
    
    ap_id = cbm_get_app_id((kal_uint32)account_id);

    if (CBM_OK != (ret = cbm_hold_bearer(ap_id)))
    {
        //hold the bearer successfully
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E1, 1, ret );
        return ret;
    }

    g_ap_id = ap_id;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E, 1, g_ap_id );
    return 0;
}

VMINT vm_cbm_release_bearer(void)
{
    kal_uint32 account_id = 0;
    kal_uint8 ap_id = 0;
    kal_int8 ret = 0;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_S, 2, g_ap_id );
    if (0 == g_ap_id)
    {
        return -2;
    }

    ret = cbm_release_bearer(g_ap_id);

    if (CBM_OK != ret && CBM_WOULDBLOCK != ret)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E1, 2, ret );
        return ret;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_ABM_HOLD_BEARER_E, 2, g_ap_id );
    return 0;

}

// custmized apn
#include "MRESrvGprot.h"

static VMINT g_cust_is_set = 0;
static VMBOOL vm_is_cust_apn_set(void)
{
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_S, 3, __LINE__);
    if (g_cust_is_set)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E1, 3, __LINE__);
        return (~0);
    }
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E2, 3, __LINE__);
        return (0);
    }
//    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E, 3, __LINE__);
}

VMINT vm_set_cust_apn_info(const vm_dtcnt_info_t * info, VMUINT32 * dtacct)
{
    vm_srv_dtcnt_info_t *  info_int = (vm_srv_dtcnt_info_t *)srv_mre_get_cust_dtcnt_info();
    VMUINT8 app_id = 0;
    VMINT8 ret = 0;
    VMUINT32 account_id = 0;
    VMINT32 status = 0;

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_S, 1, __LINE__);

    if (NULL == info_int || NULL == info)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E1, 1, __LINE__);
        return -2;
    }

    
    ret = vm_get_app_id(VM_APN_USER_DEFINE, &app_id);
    if (ret != VM_E_SOC_SUCCESS)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E2, 1, __LINE__);
        return -3;
    }
    
    *dtacct = vm_get_account_id(CBM_MRE_ACCT_ID, app_id);

    status = cbm_get_bearer_status(*dtacct);
    if (status >= 0)
    {
        if (CBM_ACTIVATED == status || CBM_ACTIVATING == status)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E3, 1, __LINE__);
            return -4;
        }
    }
    else
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E4, 1, __LINE__);
        return -5;
    }

    g_cust_is_set = 1;

    memcpy(info_int->APN, info->APN, SRV_DTCNT_PROF_MAX_APN_LEN+1);
    memcpy(info_int->PrimaryAddr, info->PrimaryAddr, VM_SRV_DTCNT_PROF_MAX_IP_ADDR_LEN);
    info_int->use_proxy = (U8)info->use_proxy;
    memcpy(info_int->UserName, info->UserName, SRV_DTCNT_PROF_MAX_USER_LEN+1);
    memcpy(info_int->Passwd, info->Passwd, SRV_DTCNT_PROF_MAX_PW_LEN+1);
    memcpy(info_int->px_addr, info->px_addr, VM_SRV_DTCNT_PROF_MAX_IP_ADDR_LEN);
    info_int->px_port = (U16)info->px_port;
    
    MMI_PRINT(MOD_MRE, MMI_MRE_TRC_MOD_VMSOCK,"cust apn[%s, %d]addr[%s:%d]", info_int->APN, info_int->use_proxy, info_int->px_addr, info_int->px_port);

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E, 1, __LINE__);

    return 0;
}

VMINT vm_get_cust_apn_info(vm_dtcnt_info_t * info)
{
    vm_srv_dtcnt_info_t *  info_int = (vm_srv_dtcnt_info_t *)srv_mre_get_cust_dtcnt_info();

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_S, 2, __LINE__);
    if (NULL == info)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E1, 2, __LINE__);
        return -2;
    }
    
    if (!vm_is_cust_apn_set())
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E2, 2, __LINE__);
        return -3;
    }
    
    memcpy(info->APN, info_int->APN, VM_SRV_DTCNT_PROF_MAX);
    memcpy(info->PrimaryAddr, info_int->PrimaryAddr, VM_SRV_DTCNT_IP_MAX);
    info->use_proxy = (VMUINT8)info_int->use_proxy;
    memcpy(info->UserName, info_int->UserName, VM_SRV_DTCNT_PROF_MAX);
    memcpy(info->Passwd, info_int->Passwd, VM_SRV_DTCNT_PROF_MAX);
    memcpy(info->px_addr, info_int->px_addr, VM_SRV_DTCNT_IP_MAX);
    info->px_port = (VMUINT16)info_int->px_port;

    
    MMI_PRINT(MOD_MRE, MMI_MRE_TRC_MOD_VMSOCK,"cust apn[%s, %d]addr[%s:%d]", info->APN, info->use_proxy, info->px_addr, info->px_port);

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_CUST_APN_E, 2, __LINE__);
    return 0;
}
// DIS WLAN
VMINT vm_wlan_perfer(VMINT disable)
{
    VM_PROCESS_STATUS status = VM_PMNG_UNLOAD;
    _vm_pcb_t* pcb = NULL;

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_S, 1, __LINE__);
    pcb = vm_sh_pcb_in_pt(SH_TYPE_PROCESS_HANDLE, vm_pmng_get_current_handle(), &status);

    if (NULL == pcb)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E1, 1, __LINE__);
        return -2;
    }

    if (disable)
    {
        pcb->flag |= VM_FLAG_DIS_WLAN_PERFER;
    }
    else
    {
        pcb->flag &= ~VM_FLAG_DIS_WLAN_PERFER;
    }

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_LOG, 
        disable,
        0,
        0,
        0,
        0,
        pcb->flag,
        1, __LINE__);
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_VMSOCK_DIS_WLAN_E, 1, __LINE__);
    return 0;
}

#if defined(__IOT__)
#include "app_frm_thread_gprot.h"
#include "soc_defs.h"
#include "soc_struct.h"
//static MMI_BOOL vm_tcp_connect_sync_int(void* inMsg)
//{
//    soc_abm_activate_cnf_struct *ptr = (soc_abm_activate_cnf_struct *)inMsg;
//    ptr->ip_addr;
//    ptr->
//}

VMINT vm_tcp_connect_sync(const char* ip, const VMINT port, VMINT apn)
{
    VMINT apn_check, ret;
    VMUINT dtacct_id;
    VMUINT8 app_id = 0;
    kal_int8 soc_id;
	sockaddr_struct addr;
	//kal_uint8 addr_buf[4];
	//kal_uint8 addr_len;
	kal_bool is_ip_valid;
	U16 mod_id = app_frm_get_current_mod_id();
	
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_S, 1, __LINE__);
    if (NULL == ip || 0 >= port)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E1, 1, __LINE__);
        return -21;
    }

    apn_check = (apn != VM_TCP_APN_CMNET && apn != VM_TCP_APN_CMWAP &&
             apn != VM_TCP_APN_CMWAP_ONLY && apn != VM_TCP_APN_CMNET_ONLY && 
             apn != VM_APN_USER_DEFINE);
    if (stub_tcp_is_support_wifi())
    {
        if (apn_check && apn != VM_TCP_APN_WIFI)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E2, apn, __LINE__);
            return -22;
        }       
    }
    else
    {
        if (apn_check)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E3, apn, __LINE__);
            return -23;
        }
    }

    if (0 > vm_get_encoded_dtacct_id(apn, &dtacct_id))
    {
    	return 25;
    }
    
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
    
    if ((soc_id = soc_create(PF_INET, SOCK_STREAM, 0, mod_id, dtacct_id)) < 0)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E6, soc_id, __LINE__);
        return soc_id;
    }

    // url
	if (MMI_FALSE == soc_ip_check((kal_char *)ip, addr.addr, &is_ip_valid))
	{
	    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef WIN32
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
/* under construction !*/
        #else
        return VM_TCP_ERR_CREATE_FAILED;
        #endif
	}
	else if (!is_ip_valid) // ip is invalid
	{
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E8, 1, __LINE__);
	    return -24;
	}


    addr.sock_type = SOC_SOCK_STREAM;
    addr.port = port;
    addr.addr_len = 4;

    //mmi_frm_set_protocol_event_handler(MSG_ID_SOC_ABM_ACTIVATE_CNF, (PsIntFuncPtr)vm_get_host_by_name, MMI_TRUE);
    //soc_activate_account(ctx_p->sock);
    
    ret = soc_connect(soc_id, &addr);
    #ifdef WIN32
    if (SOC_WOULDBLOCK == ret)
    {
        //sleep(4);
        ret = soc_connect(soc_id, &addr);
        if (ret != SOC_ALREADY)
        {
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E9, 11, ret);
            return ret;
        }   
    }
    #else
    if (SOC_SUCCESS != ret)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E9, 1, ret);
        return ret;
    }   
    
    ASSERT(SOC_WOULDBLOCK != ret);
    #endif
    //SOC_WAIT_EVENT(s, SOC_EVT_CONNECT);

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_SYNC_TCP_E, 1, ret);
    return soc_id;
}

VMINT vm_tcp_read_sync(VMINT handle, void* buf, VMINT len)
{
    
    VMINT ret = 0;

    if (0 > handle || NULL == buf || 0 == len)
        return -21;
    ret = soc_recv(handle, buf, (kal_int32)len, 0);
    return ret;
}

VMINT vm_tcp_write_sync(VMINT handle, void* buf, VMINT len)
{
    VMINT ret = 0;
    if (0 > handle || NULL == buf || 0 == len)
        return -21;
    ret = soc_send(handle, buf, (kal_int32)len, 0);
    return ret;
}

VMINT vm_tcp_close_sync(VMINT handle)
{
    if (0 > handle)
        return -21;

    soc_close(handle);
    return 0;
}

#include "CbmSrvGprot.h"
#include "vmnwsetting.h"

typedef struct _vm_client_ctx_t vm_client_ctx_t;
struct _vm_client_ctx_t
{
    VMINT soc_id;
    VMINT s_hdl;
    vm_client_ctx_t * next;  
};

typedef struct _vm_soc_svr_ctx_t vm_soc_svr_ctx_t;
struct _vm_soc_svr_ctx_t
{
    kal_int8 soc_id;
    VMINT res_id;
    VM_P_HANDLE p_hdl;
    //sockaddr_struct addr;
    VMINT bearer;
    void (*app_cb)(VMINT handle, VMINT event, VMINT param, void *user_data);
    void *user_data;
    vm_client_ctx_t *head;
};


//static vm_client_ctx_t g_http_client;
//static vm_soc_svr_ctx_t g_http_server;

static void vm_soc_svr_free_resource(VM_P_HANDLE process_handle)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_soc_svr_ctx_t* ctx_p = NULL;

    while ((resHandle = vm_res_findfirst(process_handle, VM_RES_TYPE_SOC_SERVER)) 
        != VM_RES_NOT_FIND)
    {
        if (vm_res_get_data(VM_RES_TYPE_SOC_SERVER, 
            resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
        {
            // TODO:EXIT
            vm_soc_svr_deinit(ctx_p->res_id);
        }
        else
        {
        }
        vm_res_release_data(VM_RES_TYPE_SOC_SERVER, resHandle);
        vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
    }
    

}
static VMINT vm_soc_svr_finialize_resource(void)
{
    vm_soc_svr_free_resource(-1);

    vm_res_type_set_notify_callback(VM_RES_TYPE_SOC_SERVER, NULL);


    return 0;
}

static void vm_soc_svr_notify_process_status(VM_P_HANDLE process_handle, 
    VMINT sys_state)
{
    VMINT resHandle = 0, bufSize = 0;
    vm_soc_svr_ctx_t * ctx_p = NULL;

    switch (sys_state)
    {
    case VM_PMNG_UNLOAD:
        vm_soc_svr_free_resource(process_handle);
        break;
    }
}

static VMINT vm_soc_svr_initialize_resource(void)
{
    if (vm_res_type_set_notify_callback(VM_RES_TYPE_SOC_SERVER, 
        vm_soc_svr_notify_process_status) != 0)
    {
        return -1;
    }



    return 0;
}

static VMINT vm_soc_svr_mod_evt_proc(MRE_MOD_LIFECIRCLE_EVT event)
{
    switch(event)
    {
    case EVT_MOD_INIT:
        if (vm_soc_svr_initialize_resource() != 0)
            return -1;
        break;
    case EVT_MOD_RELEASE:
        vm_soc_svr_finialize_resource();
        break;
    case EVT_MOD_ACTIVE:
        break;
    case EVT_MOD_INACTIVE:
        break;
    default:
        return -2;
    }

    return 0;
}

VMINT _vm_reg_soc_svr_module(void)
{
    int res_code = REG_MRE_MODULE_SUCCESS;
    
    if ((res_code = _vm_reg_module("HPS MODULE", (MOD_EVT_PROCESS)vm_soc_svr_mod_evt_proc)) != REG_MRE_MODULE_SUCCESS)
    {
    }

    return res_code;
}

static vm_soc_svr_ctx_t* vm_soc_svr_int_alloc(void)
{
    vm_soc_svr_ctx_t * ctx_p = NULL;

    if ((ctx_p = vm_calloc(sizeof(vm_soc_svr_ctx_t))) != NULL)
    {
        if ((ctx_p->res_id = vm_res_save_data(VM_RES_TYPE_SOC_SERVER, 
            (void*)ctx_p, sizeof(ctx_p), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            
            ctx_p->p_hdl = vm_pmng_get_current_handle();
            return ctx_p;
        }
        else
        {
            vm_free(ctx_p);
        }
    }

    return NULL;
}
#define WITH_K_MEM
static void vm_soc_svr_int_release_all_clients(vm_soc_svr_ctx_t *ctx_p);
static vm_client_ctx_t *vm_soc_svr_int_alloc_client(vm_soc_svr_ctx_t *ctx_p)
{
    vm_client_ctx_t *client;
    vm_client_ctx_t *tmp;
    if (NULL == ctx_p)
        return NULL;
#ifdef WITH_K_MEM
    client = (vm_client_ctx_t*)_vm_kernel_calloc(sizeof(vm_client_ctx_t));
    memset(client, 0, sizeof(vm_client_ctx_t));
#else
    client = (vm_client_ctx_t*)vm_calloc(sizeof(vm_client_ctx_t) + 16);
#endif
    client->s_hdl = ctx_p->res_id;
    tmp = ctx_p->head;
    if (NULL == tmp)
    {
        ctx_p->head = client;
        return client;
    }
    
    while (tmp->next)
    {
        tmp = tmp->next;
        
    }

    tmp->next = client;
    
     
    return client;
}

static void vm_soc_svr_int_free_client(vm_soc_svr_ctx_t *ctx_p, kal_int8 client_soc_id)
{
    vm_client_ctx_t *p, *q;
    if (NULL == ctx_p)
        return;

    p = ctx_p->head;
    if (NULL == p)
    {
        return;    
    }
    else
    {
        if (p->soc_id == client_soc_id)
        {
            ctx_p->head = p->next;
#ifdef WITH_K_MEM
            _vm_kernel_free(p);
#else
            vm_free(p);
#endif
            return;
        }
    }

    q = p->next;
    while (q)
    {
        if (client_soc_id == q->soc_id)
        {
            p->next = q->next;
#ifdef WITH_K_MEM
            _vm_kernel_free(q);
#else
            vm_free(q);
#endif
            return;   
        }
        p = q;
        q = q->next;
    }

    
    

    
}

static void vm_soc_svr_int_release_all_clients(vm_soc_svr_ctx_t *ctx_p)
{
    vm_client_ctx_t *tmp;
    if (NULL == ctx_p)
    {
        return;
    }

    tmp = ctx_p->head;
    if (NULL == tmp)
        return;
    
    while (tmp)
    {
        ctx_p->head = tmp->next;
#ifdef WITH_K_MEM
        _vm_kernel_free(tmp);
#else
        vm_free(tmp);
#endif
        tmp = ctx_p->head;
    }


    
}

static vm_client_ctx_t * vm_soc_svr_int_get_client(vm_soc_svr_ctx_t *ctx_p, kal_int8 client_soc_id)
{
    vm_client_ctx_t *tmp;
    if (NULL == ctx_p)
        return NULL;

    tmp = ctx_p->head;
    while (tmp)
    {
        if (tmp->soc_id == client_soc_id)
            return tmp;
        tmp = tmp->next;
    }
    return NULL;
}

static void vm_soc_svr_int_free(vm_soc_svr_ctx_t * ctx_p)
{
    if (ctx_p)
    {
        if (VM_RES_OK == vm_res_release_data(VM_RES_TYPE_SOC_SERVER, ctx_p->res_id))
        {
           vm_soc_svr_int_release_all_clients(ctx_p);
           soc_close(ctx_p->soc_id);
            if (ctx_p->bearer)
                cbm_release_bearer(ctx_p->bearer);
           vm_free(ctx_p);
        }
    }
}

static vm_soc_svr_ctx_t *vm_soc_svr_int_get(VMINT id, VMINT type)
{
    vm_soc_svr_ctx_t *ctx_p;
    switch (type)
    {
    case 0: // server handle (res_id)
        {
            VMINT buf_size;
            if (VM_RES_OK != vm_res_get_data(VM_RES_TYPE_SOC_SERVER, id,(void**)&ctx_p, &buf_size))
            {
                return 0;
            }
            
            return ctx_p;
        }
        break;
    case 1: // server soc_id
        {
            
            VMINT resHandle = 0, bufSize = 0;
            if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_SOC_SERVER)) != VM_RES_NOT_FIND)
            {
                if (vm_res_get_data(VM_RES_TYPE_SOC_SERVER, 
                    resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
                {
                    if (ctx_p->soc_id == id)
                    {
                        vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
                        return ctx_p;
                    }
                }
            
                while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_SOC_SERVER)) != VM_RES_NOT_FIND)
                {
                    if (vm_res_get_data(VM_RES_TYPE_SOC_SERVER, 
                    resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
                    {
                        if (ctx_p->soc_id == id)
                        {
                            vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
                            return ctx_p;
                        }
                    }
                }
                vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
            }   
            return NULL;
        }
        break;
    case 2: // client soc_id
        {
            vm_client_ctx_t *client;
            VMINT resHandle = 0, bufSize = 0;
            if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_SOC_SERVER)) != VM_RES_NOT_FIND)
            {
                if (vm_res_get_data(VM_RES_TYPE_SOC_SERVER, 
                    resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
                {
                    client = vm_soc_svr_int_get_client(ctx_p, id);
                    if (client)
                    {
                        vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
                        return vm_soc_svr_int_get(client->s_hdl, 0);
                    }
                }
            
                while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_SOC_SERVER)) != VM_RES_NOT_FIND)
                {
                    if (vm_res_get_data(VM_RES_TYPE_SOC_SERVER, 
                    resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
                    {
                        client = vm_soc_svr_int_get_client(ctx_p, id);
                        if (client)
                        {
                            vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
                            return vm_soc_svr_int_get(client->s_hdl, 0);
                        }
                    }
                }
                vm_res_findclose(VM_RES_TYPE_SOC_SERVER);
            }   
            return NULL;
            

        }break;
    default:
        break;
    }

    return 0;
}

static kal_int8 vm_soc_svr_int_accept(kal_uint8 soc_id)
{
    sockaddr_struct addr = {0};

    vm_client_ctx_t *client;

    vm_soc_svr_ctx_t *server = vm_soc_svr_int_get(soc_id, 1);
    if (NULL == server)
    {
        return -1;
    }
    
    client = vm_soc_svr_int_alloc_client(server);
    if (NULL == client)
    {
        soc_shutdown(soc_id, SHUT_WR);
        return -2;
    }    
    client->soc_id = soc_accept(soc_id, &addr);

    if (client->soc_id < 0)
    {
        vm_soc_svr_int_free_client(server, client->soc_id);
        return client->soc_id;
    }

    //vm_soc_svr_int_append_client(client);

    return client->soc_id;
}

mmi_ret vm_soc_svr_int_bearer_status_proc(mmi_event_struct* event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_cbm_bearer_info_struct *bearer_info_p = (srv_cbm_bearer_info_struct*)event;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //if (g_srv_brw_cntx.srv_brw_dynamic_cntx_p &&  g_srv_brw_cntx.srv_brw_dynamic_cntx_p->is_activating_wifi)
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 7, __LINE__);
    

    if (bearer_info_p->user_data)
    {
        vm_soc_svr_ctx_t *server = bearer_info_p->user_data;
        kal_int8 ret;
        VMINT evt;
        void *user_data;
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_LOG, 
            server->res_id,
            server->soc_id,
            server->p_hdl,
            server->head,
            server->app_cb,
            server->user_data,
            7, __LINE__);
        user_data = server->user_data;
        switch (bearer_info_p->state)
        {
            case SRV_CBM_ACTIVATED:
            {
                
                server->bearer = 1;
                ret = soc_listen(server->soc_id, 3);
                if (SOC_SUCCESS != ret)
                {
                    vm_soc_svr_int_free(server);
                    evt = VM_SOC_SVR_EVT_FAILED;
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E1, ret, __LINE__);
                }
                else
                {
                    evt = VM_SOC_SVR_EVT_ACTIVED;
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E2, ret, __LINE__);
                }
                if (vm_pmng_set_ctx(server->p_hdl) == VM_PMNG_OP_OK)
                {
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E3, ret, __LINE__);
                    server->app_cb(server->res_id, evt, ret, user_data);
                    vm_pmng_reset_ctx();
                }
            }
            break;

            case SRV_CBM_DEACTIVATED:
            {
                evt = VM_SOC_SVR_EVT_DEACTIVATED;
                ret = 0;
                if (vm_pmng_set_ctx(server->p_hdl) == VM_PMNG_OP_OK)
                {
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E4, ret, __LINE__);
                    server->app_cb(server->res_id, evt, ret, user_data);
                    vm_pmng_reset_ctx();
                }
            }
            break;
            
        }
    }
    
    return MMI_RET_OK;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, 7, __LINE__);
}
static MMI_BOOL  vm_soc_svr_int_ind(void* inMsg)
{
    app_soc_notify_ind_struct* ind = (app_soc_notify_ind_struct*)inMsg;
    vm_soc_svr_ctx_t *server;
    VM_P_HANDLE p_handle;

    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 1, __LINE__);
    if (!ind)                   
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E1, 1, __LINE__);
        return MMI_FALSE;
    }
    
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_LOG, 
        ind->event_type,
        0,
        0,
        0,
        0,
        0,
        10, __LINE__);

    switch (ind->event_type)
    {
        case SOC_CLOSE:
        case SOC_WRITE:
        case SOC_READ:
            {
                vm_client_ctx_t *client;
                VMINT evt;
                if (SOC_WRITE == ind->event_type)
                {evt = VM_SOC_SVR_EVT_WRITE;}
                else if (SOC_READ == ind->event_type)
                {evt = VM_SOC_SVR_EVT_READ;}
                else
                {evt = VM_SOC_SVR_EVT_CLOSED;}
                    
                server = vm_soc_svr_int_get(ind->socket_id, 2);
                if (NULL == server)
                {
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E2, 1, __LINE__);
                    break;
                }
                client = vm_soc_svr_int_get_client(server, ind->socket_id);
                if (NULL == client)
                {
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E3, 1, __LINE__);
                    break;
                }
                
                p_handle = vm_res_get_process_handle(VM_RES_TYPE_SOC_SERVER, server->res_id);
                
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_LOG, 
                    server->res_id,
                    p_handle,
                    evt,
                    ind->socket_id,
                    0,
                    0,
                    11, __LINE__);


                if (vm_pmng_set_ctx(p_handle) == VM_PMNG_OP_OK)
                {
                    server->app_cb(server->res_id, evt, ind->socket_id, server->user_data);
                    vm_pmng_reset_ctx();
                }

                //read = vm_soc_svr_int_client_recv(client);
                
                //vm_soc_svr_int_client_parser(client->data);
                
                //vm_trace("[HTTP SVR][%s] handle[%d]", client->data);
                //while ((ret = soc_send(ind->socket_id, (kal_uint8*)client->data + send_len, client->len - send_len, 0)) > 0)
                //{
                //    send_len += ret;
                //    if (send_len == client->len)
                //    {
                //        client->len = 0;
                //        break;
                //    }
                //}
                //client->len = 0;
                //vm_trace("[HTTP SVR]sent handle[%d]", ind->socket_id);
            }
            break;
        case SOC_ACCEPT:
            {
                kal_uint8 option;
                kal_int8 client_soc_id;
                kal_uint8 val = 1;
                server = vm_soc_svr_int_get(ind->socket_id, 1);
                client_soc_id = vm_soc_svr_int_accept(ind->socket_id);
                
                MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E4, 1, __LINE__);
                if (client_soc_id >= 0)
                {
                    //vm_trace("[HTTP SVR]accepted [%d.%d.%d.%d:%d] handle [%d]", addr.addr[0], addr.addr[1], addr.addr[2], addr.addr[3], addr.port, client_soc_id);
                    option = SOC_READ | SOC_WRITE | SOC_ACCEPT  | SOC_CLOSE;
                    soc_setsockopt(client_soc_id, SOC_ASYNC, &option, sizeof(kal_uint8));
                    soc_setsockopt(client_soc_id, SOC_NBIO, &val, sizeof(val));
                    
                    p_handle = vm_res_get_process_handle(VM_RES_TYPE_SOC_SERVER, server->res_id);
                    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_LOG, 
                        server->res_id,
                        p_handle,
                        client_soc_id,
                        ind->socket_id,
                        0,
                        0,
                        12, __LINE__);
                    if (vm_pmng_set_ctx(p_handle) == VM_PMNG_OP_OK)
                    {
                        server->app_cb(server->res_id, VM_SOC_SVR_EVT_ACCEPT, client_soc_id, server->user_data);
                        vm_pmng_reset_ctx();
                    }
                }
            }
            break;
        default:
            break;
    }

    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, 1, __LINE__);

    return MMI_FALSE;
}

VMINT vm_soc_svr_init(VMINT apn, 
                            VMINT port, 
                            void *user_data,
                            void (*callback)(VMINT handle, VMINT event, VMINT param, void *user_data))
{
    kal_int8 result;
    VMUINT acct_id;
    kal_uint8 option;
    sockaddr_struct addr;
    kal_uint8 bearer;
  
    //kal_uint32 type, state;
    kal_uint8 val;    
    VMUINT8 appid = 0;

    vm_soc_svr_ctx_t *ctx_p;
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 2, __LINE__);
    
    
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_LOG, 
        apn,
        port,
        0,
        0,
        callback,
        user_data,
        21, __LINE__);
        
    ctx_p = vm_soc_svr_int_alloc();
    if (NULL == ctx_p)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E1, 2, __LINE__);
        return -2;
    }    
    ctx_p->app_cb = callback;
    ctx_p->user_data = user_data;
    mmi_frm_set_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, (PsIntFuncPtr)vm_soc_svr_int_ind, MMI_TRUE);
    vm_get_encoded_dtacct_id(apn, &acct_id);

    
    ctx_p->soc_id = soc_create(SOC_PF_INET, SOC_SOCK_STREAM, 0, MOD_MMI, acct_id);
    if (ctx_p->soc_id < 0)
    {
        vm_soc_svr_int_free(ctx_p);
        mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
            (PsIntFuncPtr)vm_soc_svr_int_ind);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E2, 2, __LINE__);
        return -3;
    }
    
    option = SOC_READ | SOC_WRITE | SOC_ACCEPT | SOC_CLOSE;
    result = soc_setsockopt(ctx_p->soc_id, SOC_ASYNC, &option, sizeof(kal_uint8));
    if (result != SOC_SUCCESS)
    {
        vm_soc_svr_int_free(ctx_p);
        //soc_close(ctx_p->soc_id);
        mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
            (PsIntFuncPtr)vm_soc_svr_int_ind);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E3, 2, __LINE__);
        return -4;
    }
    
    option = 1;
    result = soc_setsockopt(ctx_p->soc_id, SOC_NBIO, &option, sizeof(kal_uint8));
    if (result != SOC_SUCCESS)
    {
        vm_soc_svr_int_free(ctx_p);
        //soc_close(ctx_p->soc_id);
        mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
            (PsIntFuncPtr)vm_soc_svr_int_ind);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E4, 2, __LINE__);
        return -5;
    }
    
    /* INADDR_ANY */
    addr.addr[0] = 0x00;
    addr.addr[1] = 0x00;
    addr.addr[2] = 0x00;
    addr.addr[3] = 0x00;
    addr.addr_len = sizeof(long);
    addr.port = (unsigned short)port;
    result = soc_bind((kal_int8)ctx_p->soc_id, &addr);
    if (result != SOC_SUCCESS)
    {
        vm_soc_svr_int_free(ctx_p);
        //soc_close(ctx_p->soc_id);
        mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
            (PsIntFuncPtr)vm_soc_svr_int_ind);
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E5, result, __LINE__);
        return -6;
    }

    bearer = SRV_CBM_BEARER_PS | 
     #ifdef __TCPIP_OVER_CSD__
             SRV_CBM_BEARER_CSD | 
     #endif /* #ifdef __TCPIP_OVER_CSD__ */
             SRV_CBM_BEARER_WIFI;
    val = SRV_CBM_ACTIVATED|SRV_CBM_DEACTIVATED;

    vm_get_app_id(apn, &appid);
    cbm_register_bearer_info_by_app_id(appid, MOD_MMI, bearer, val);

    if (VM_APN_WIFI_HS == apn || VM_APN_AP_MODE == apn)
    {  
        // check ap mode    
        #ifdef __MRE_SAL_NWSETTING__
        VMINT sta = vm_wlan_mode_get();
        if (sta == VM_WLAN_MODE_STATUS_AP || sta == VM_WLAN_MODE_STATUS_AP_STA)
        #else
        if (0)
        #endif
        //if (SRV_WLAN_MODE_STATUS_AP == srv_wlan_status() || SRV_WLAN_MODE_STATUS_AP_STA == srv_wlan_status())
        {            
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, 0, __LINE__);    
            result = SOC_SUCCESS;
        }
        else
        {
            vm_soc_svr_int_free(ctx_p);
            //soc_close(ctx_p->soc_id);
            mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
                (PsIntFuncPtr)vm_soc_svr_int_ind);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E6, -9, __LINE__);
            return -9;
        }
        
    }
    else
    {
        srv_cbm_register_bearer_info(appid, val, bearer, vm_soc_svr_int_bearer_status_proc, ctx_p);
        result = cbm_open_bearer(acct_id);
    }
    

    if (SOC_SUCCESS == result)
    {
        // listen API is blocking API, set BLOCKING
        option = 0;
        result = soc_setsockopt(ctx_p->soc_id, SOC_NBIO, &option, sizeof(kal_uint8));
        if (result != SOC_SUCCESS)
        {
            vm_soc_svr_int_free(ctx_p);
            //soc_close(ctx_p->soc_id);
            mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
                (PsIntFuncPtr)vm_soc_svr_int_ind);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E4, result, -10);
            return -10;
        }
        
        result = soc_listen(ctx_p->soc_id, 3);
        if (SOC_SUCCESS != result && SOC_WOULDBLOCK != result)
        {
            vm_soc_svr_int_free(ctx_p);
            //soc_close(ctx_p->soc_id);
            mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
                (PsIntFuncPtr)vm_soc_svr_int_ind);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E6, result, -7);
            return -7;
        }

        //  set option
        option = SOC_READ | SOC_WRITE | SOC_ACCEPT | SOC_CLOSE;
        result = soc_setsockopt(ctx_p->soc_id, SOC_ASYNC, &option, sizeof(kal_uint8));
        if (result != SOC_SUCCESS)
        {
            vm_soc_svr_int_free(ctx_p);
            //soc_close(ctx_p->soc_id);
            mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
                (PsIntFuncPtr)vm_soc_svr_int_ind);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E3, result, -12);
            return -12;
        }
        
        option = 1;
        result = soc_setsockopt(ctx_p->soc_id, SOC_NBIO, &option, sizeof(kal_uint8));
        if (result != SOC_SUCCESS)
        {
            vm_soc_svr_int_free(ctx_p);
            //soc_close(ctx_p->soc_id);
            mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
                (PsIntFuncPtr)vm_soc_svr_int_ind);
            MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E4, result, -11);
            return -11;
        }
    }
    else
    if (SOC_WOULDBLOCK == result)
    {
        ctx_p->bearer = appid;
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E7, result, __LINE__);
        return -8;
    }


    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, ctx_p->res_id, __LINE__);
    return ctx_p->res_id;
    
    
}

VMINT vm_soc_svr_send(VMINT s_hdl, VMINT c_hdl, const void *data, VMUINT len)
{
    vm_soc_svr_ctx_t * server;
    vm_client_ctx_t * client;
    kal_int32 ret;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 3, __LINE__);
    server = vm_soc_svr_int_get(s_hdl, 0);
    if (NULL == server)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E1, 3, __LINE__);
        return -12;
    }
    
    client = vm_soc_svr_int_get_client(server, c_hdl);
    if (NULL == client)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E2, 3, __LINE__);
        return -13;
    }
    ret = soc_send(client->soc_id, data, len, 0);
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, ret, __LINE__);
    return ret;
}

VMINT vm_soc_svr_read(VMINT s_hdl, VMINT c_hdl, void *data, VMUINT len)
{
    vm_soc_svr_ctx_t * server;
    vm_client_ctx_t * client;
    kal_int32 ret;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 4, __LINE__);
    server = vm_soc_svr_int_get(s_hdl, 0);
    if (NULL == server)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E1, 4, __LINE__);
        return -12;
    }
    
    client = vm_soc_svr_int_get_client(server, c_hdl);
    if (NULL == client)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E2, 4, __LINE__);
        return -13;
    }
    
    ret = soc_recv(client->soc_id, data, len, 0);
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, ret, __LINE__);
    return ret;
}

VMINT vm_soc_svr_close_client(VMINT c_hdl)
{
    vm_soc_svr_ctx_t * server;
    kal_int8 ret;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 5, __LINE__);
    server = vm_soc_svr_int_get(c_hdl, 2);
    if (NULL == server)
    {
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E1, 5, __LINE__);
        return -12;
    }
    
    vm_soc_svr_int_free_client(server, c_hdl);
    ret = soc_close(c_hdl);
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, ret, __LINE__);
    return ret;
}

VMINT vm_soc_svr_deinit(VMINT handle)
{
    vm_soc_svr_ctx_t * server;
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 6, __LINE__);
    server = vm_soc_svr_int_get(handle, 0);
    mmi_frm_clear_protocol_event_handler(MSG_ID_APP_SOC_NOTIFY_IND, 
        (PsIntFuncPtr)vm_soc_svr_int_ind);

    vm_soc_svr_int_free(server);
    MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, 6, __LINE__);

    return 0;
}

VMINT vm_soc_svr_get_soc_id(VMINT handle)
{
    vm_soc_svr_ctx_t *server;
    server = vm_soc_svr_int_get(handle, 0);
    if (NULL == server)
    {
        return -2;
    }
    return (VMINT)server->soc_id;
}


VMINT vm_soc_svr_init_sync(VMINT apn, VMINT port)
{
	U16 mod_id = app_frm_get_current_mod_id();
    kal_int8 result, soc_id;
    VMUINT acct_id;
    //kal_uint8 option;
    sockaddr_struct addr;
    
    ASSERT(MOD_MMI != mod_id);
    
    vm_get_encoded_dtacct_id(apn, &acct_id);

    
    soc_id = soc_create(SOC_PF_INET, SOC_SOCK_STREAM, 0, mod_id, acct_id);
    if (soc_id < 0)
    {
        return -21;
    }
    
    /* INADDR_ANY */
    addr.addr[0] = 0x00;
    addr.addr[1] = 0x00;
    addr.addr[2] = 0x00;
    addr.addr[3] = 0x00;
    addr.addr_len = sizeof(long);
    addr.port = (unsigned short)port;
    result = soc_bind(soc_id, &addr);
    if (result != SOC_SUCCESS)
    {
        soc_close(soc_id);
        return -22;
    }

    result = soc_listen(soc_id, 3);
    if (result != SOC_SUCCESS)
    {
        soc_close(soc_id);
        return -23;
    }


    return soc_id;

}

VMINT vm_soc_svr_accept_sync(VMINT s_hdl, vm_sockaddr_struct *addr)
{
    int ret;
    sockaddr_struct addr1 = {0};

    if (0 >= s_hdl)
        return -21;
    if (0 >= addr)
        return -21;
    ret = soc_accept(s_hdl, &addr1);

    if (ret >= 0)
    {
        memcpy(addr->addr, addr1.addr, VM_MAX_SOCK_ADDR_LEN);
        addr->addr_len = addr1.addr_len;
        addr->port = addr1.port;
    }

    return ret;

}


VMINT vm_soc_svr_send_sync(VMINT c_hdl, const void *data, VMUINT len)
{
    if (0 >= c_hdl)
        return -21;

    if (NULL == data || 0 == len)
        return -22;
        
    return soc_send(c_hdl, data, len, 0);
}

VMINT vm_soc_svr_read_sync(VMINT c_hdl, void *data, VMUINT len)
{
    if (0 >= c_hdl)
        return -21;

    if (NULL == data || 0 == len)
        return -22;
    
    return soc_recv(c_hdl, data, len, 0);
}

VMINT vm_soc_svr_close_client_sync(VMINT c_hdl)
{
    if (0 >= c_hdl)
        return -21;
    
    return soc_close(c_hdl);
}

VMINT vm_soc_svr_deinit_sync(VMINT s_hdl)
{
    if (0 >= s_hdl)
        return -21;
    return soc_close(s_hdl);

}
typedef struct _vm_bsd_sub_ctx_t vm_bsd_sub_ctx_t;
struct _vm_bsd_sub_ctx_t
{
    U16 mod_id;
    VMINT res_id;
};


typedef struct _vm_bsd_ctx_t vm_bsd_ctx_t;
struct _vm_bsd_ctx_t
{
    //kal_int8 soc_id;
    VMINT res_id;
    VM_P_HANDLE p_hdl;
    //sockaddr_struct addr;
    VMUINT32 first_acct;
    VMINT bearer;
    void (*app_cb)(VMINT handle, VMINT event, VMUINT param, void *user_data);
    void *user_data;
    //vm_bsd_sub_ctx_t *head;
};

static VMUINT32 latest_acct = 0;

static vm_bsd_ctx_t* vm_bsd_int_alloc(void)
{
    vm_bsd_ctx_t * ctx_p = NULL;

    if ((ctx_p = vm_calloc(sizeof(vm_soc_svr_ctx_t))) != NULL)
    {
        if ((ctx_p->res_id = vm_res_save_data(VM_RES_TYPE_BEARER, 
            (void*)ctx_p, sizeof(ctx_p), NULL, vm_pmng_get_current_handle())) >= 0)
        {
            
            ctx_p->p_hdl = vm_pmng_get_current_handle();
            return ctx_p;
        }
        else
        {
            vm_free(ctx_p);
        }
    }

    return NULL;
}

static void vm_bsd_int_free(vm_bsd_ctx_t * ctx_p)
{
    if (ctx_p)
    {
        if (VM_RES_OK == vm_res_release_data(VM_RES_TYPE_BEARER, ctx_p->res_id))
        {
           //vm_soc_svr_int_release_all_clients(ctx_p);
           //soc_close(ctx_p->soc_id);
           //if (ctx_p->bearer)
                //cbm_release_bearer(ctx_p->bearer);
           vm_free(ctx_p);
        }
    }
}

static vm_bsd_ctx_t *vm_bsd_int_get(VMINT id, VMINT type)
{
    vm_bsd_ctx_t *ctx_p;
    switch (type)
    {
    case 1: 
        {
            
            VMINT resHandle = 0, bufSize = 0;
            if ((resHandle = vm_res_findfirst(-1, VM_RES_TYPE_BEARER)) != VM_RES_NOT_FIND)
            {
                if (vm_res_get_data(VM_RES_TYPE_BEARER, 
                    resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
                {
                    if (ctx_p->res_id == id)
                    {
                        vm_res_findclose(VM_RES_TYPE_BEARER);
                        return ctx_p;
                    }
                }
            
                while ((resHandle = vm_res_findnext(-1, VM_RES_TYPE_BEARER)) != VM_RES_NOT_FIND)
                {
                    if (vm_res_get_data(VM_RES_TYPE_BEARER, 
                    resHandle, (void**)&ctx_p, &bufSize) == 0 && ctx_p != NULL)
                    {
                        if (ctx_p->res_id == id)
                        {
                            vm_res_findclose(VM_RES_TYPE_BEARER);
                            return ctx_p;
                        }
                    }
                }
                vm_res_findclose(VM_RES_TYPE_BEARER);
            }   
            return NULL;
        }
        break;
    default:
        break;
    }

    return 0;
}
/*
static VMUINT vm_bsd_int_get_account(void)
{
    //app_frm_get_current_mod_id();
    vm_bsd_ctx_t *ctx_p = vm_bsd_int_get(app_frm_get_current_mod_id());
    if (ctx_p)
        ctx_p->acct;
    return 0;
}

static VMUINT vm_bsd_int_set_account(VMUINT acct)
{
    //app_frm_get_current_mod_id();
    vm_bsd_ctx_t *ctx_p = vm_bsd_int_get(app_frm_get_current_mod_id());
    
    return 0;
}
*/


/* IPV4 Native soc  => BSD struct  */
static void
vm_sockaddr_struct2addr_in(const sockaddr_struct * soc_addr,
                         SOCKADDR *addr_in)
{
    addr_in->sa_family = 0; //PF_INET for app;
#ifdef __MTK_TARGET__
    //addr_in->sa_len = sizeof(SOCKADDR);
#else /* !__MTK_TARGET__ */
    memset(&((SOCKADDR_IN*) addr_in)->sin_zero, 0, 8);
#endif /* __MTK_TARGET__ */
    ((SOCKADDR_IN*) addr_in)->sin_port = soc_htons(soc_addr->port);
    memcpy(&((SOCKADDR_IN *) addr_in)->sin_addr, soc_addr->addr, 4);

    return;
}

/* IPV4 BSD struct  =>  Native soc  */
static void
vm_addr_in2sockaddr_struct(const SOCKADDR * addr_in, 
                        sockaddr_struct * sock_addr, socket_type_enum type)
{
    sock_addr->sock_type = type; // TODO:
    sock_addr->addr_len = 4;
    sock_addr->port = soc_htons(((SOCKADDR_IN*) addr_in)->sin_port);
    
    memcpy(sock_addr->addr, &((SOCKADDR_IN *) addr_in)->sin_addr, 4);

    return;
}

static mmi_ret vm_bsd_bearer_status_proc(mmi_event_struct* event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_cbm_bearer_info_struct *bearer_info_p = (srv_cbm_bearer_info_struct*)event;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //if (g_srv_brw_cntx.srv_brw_dynamic_cntx_p &&  g_srv_brw_cntx.srv_brw_dynamic_cntx_p->is_activating_wifi)
    //MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_S, 7, __LINE__);
    

    if (bearer_info_p->user_data)
    {
        vm_bsd_ctx_t *ctx_p = bearer_info_p->user_data;
        //kal_int8 ret;
        VMINT evt;
        void *user_data;
        
        user_data = ctx_p->user_data;
        ctx_p->first_acct = bearer_info_p->account_id;
        latest_acct = bearer_info_p->account_id;
        MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_LOG, 
            0,
            ctx_p->app_cb,
            ctx_p->res_id,
            ctx_p->p_hdl,
            ctx_p->first_acct,
            user_data,
            7, __LINE__);

        evt = bearer_info_p->state;
        switch (bearer_info_p->state)
        {
            case SRV_CBM_DEACTIVATED:
            case SRV_CBM_ACTIVATING:
            case SRV_CBM_ACTIVATED:
            case SRV_CBM_DEACTIVATING:
            case SRV_CBM_CSD_AUTO_DISC_TIMEOUT:
            case SRV_CBM_GPRS_AUTO_DISC_TIMEOUT:
            case SRV_CBM_NWK_NEG_QOS_MODIFY:
                {
                    if (vm_pmng_set_ctx(ctx_p->p_hdl) == VM_PMNG_OP_OK)
                    {
                        //MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E3, ret, __LINE__);
                        ctx_p->app_cb(ctx_p->res_id, evt, bearer_info_p->account_id, user_data);
                        vm_pmng_reset_ctx();
                    }
                }
                break;
            default:
                break;
            
        }
    }
    
    return MMI_RET_OK;
    //MMI_TRACE(MMI_MRE_TRC_MOD_VMSOCK, TRC_MRE_ASYNC_SERVER_E, 7, __LINE__);
}


VMINT vm_bearer_open(VMINT apn, void *user_data, void (*callback)(VMINT handle, VMINT event, VMUINT param, void *user_data))
{

   kal_uint32 bearer_type = SRV_CBM_BEARER_PS | 
 #ifdef __TCPIP_OVER_CSD__
             SRV_CBM_BEARER_CSD | 
 #endif /* #ifdef __TCPIP_OVER_CSD__ */
             SRV_CBM_BEARER_WIFI;
             
    kal_uint32 val = SRV_CBM_ACTIVATED|SRV_CBM_DEACTIVATED;
    
    VMUINT8 appid;
    kal_int8 result;
    vm_bsd_ctx_t *ctx_p;
    VMUINT account_id = 0;
   
    
    vm_get_app_id(apn, &appid);
    if (CBM_OK != (result = cbm_register_bearer_info_by_app_id(appid, MOD_MMI, bearer_type, val)))
    {
        return result;
    }
    
    ctx_p = vm_bsd_int_alloc();
    if (NULL == ctx_p)
    {
        return -13;
    }

    ctx_p->bearer = appid;
    ctx_p->app_cb = callback;
    ctx_p->user_data = user_data;

    if (SRV_CBM_OK != (result = srv_cbm_register_bearer_info(appid, val, bearer_type, vm_bsd_bearer_status_proc, ctx_p)))
    {
        return result;
    }
    vm_get_encoded_dtacct_id(apn, &account_id);
    //srv_cbm_deregister_bearer_info
    result = cbm_open_bearer(account_id);
    if (CBM_WOULDBLOCK == result)
    {
        return CBM_WOULDBLOCK;
    }
    else if (CBM_OK == result)
    {
        vm_bsd_int_free(ctx_p);
        latest_acct = account_id;
        return ctx_p->res_id;
    }
    else
    {
        vm_bsd_int_free(ctx_p);
        return (VMINT)result;
    }
    
 

}

VMINT vm_bearer_close(VMINT hdl)
{
    vm_bsd_ctx_t *ctx_p;
    kal_int8 ret;

    ctx_p = vm_bsd_int_get(hdl, 1);
    if (NULL == ctx_p)
    {
        return -20;
    }

    ret = cbm_release_bearer(ctx_p->bearer);
    vm_bsd_int_free(ctx_p);
    return ret;
}

int vm_socket_ex(int family, int type, int protocol, VMUINT32 data_account)
{
    kal_int8 soc_id;

    
    if ((soc_id = soc_create(family, type, protocol, app_frm_get_current_mod_id(), data_account)) < 0)
    {
        //return soc_id;
        
    }

    

    return soc_id;
}


int vm_socket(int family, int type, int protocol)
{
    kal_int8 soc_id;

    //vm_bsd_ctx_t *ctx_p = vm_bsd_int_alloc(void);//vm_bsd_int_get(app_frm_get_current_mod_id());
    //ctx_p->acct = vm_bsd_int_get_account();
    //vm_get_encoded_dtacct_id(VM_TCP_APN_WIFI, &acct_id);
    if (!latest_acct)
    {
        return -20;
    }
    
    if ((soc_id = soc_create(family, type, protocol, app_frm_get_current_mod_id(), latest_acct)) < 0)
    {
        //return soc_id;
    }

    

    return soc_id;
}

int vm_closesocket (int sock)
{
    
    kal_int8 ret;
    
    if (sock < 0)
    {
        return -20;
    }
    ret = soc_close(sock);
    
    return ret;
}

int vm_bind(int sock, const SOCKADDR *addr, int addrlen, int type)
{
    kal_int8 ret;

    sockaddr_struct local = {0};

    if (sock < 0 || NULL == addr)
    {
        return -20;
    }
    vm_addr_in2sockaddr_struct(addr, &local, type); // TODO: BSD inet_type
    
    ret = soc_bind(sock, &local);

    
    
    return ret;
}

int vm_listen(int sock, int backlog)
{
    kal_int8 ret;

    //sockaddr_struct local = {0};
        
    //vm_addr_in2sockaddr_struct(addr, &local);
    if (sock < 0)
    {
        return -20;
    }
    ret = soc_listen(sock, backlog);
    
    
    return ret;
}

int vm_accept(int sock, SOCKADDR *addr, int *addrlen)
{
    kal_int8 ret;

    sockaddr_struct local = {0};

    if (sock < 0 || NULL == addr)
    {
        return -20;
    }
    
    ret = soc_accept(sock, &local);
    
    vm_sockaddr_struct2addr_in(&local, addr);
    
    return ret;
}

int vm_connect(int sock, SOCKADDR *addr, int addrlen)
{
    kal_int8 ret;

    sockaddr_struct local = {0};

    if (sock < 0 || NULL == addr)
    {
        return -20;
    }
        
    vm_addr_in2sockaddr_struct(addr, &local, SOC_SOCK_STREAM);

    ret = soc_connect(sock, &local);

    return ret;
}

int vm_send(int sock, const char *buf, int len, int flags)
{
    kal_int32 ret;

    //sockaddr_struct local = {0};

    if (sock < 0 || NULL == buf || 0 >= len)
    {
        return -20;
    }
        
    //vm_addr_in2sockaddr_struct(addr, &local);

    ret = soc_send(sock, (const void *)buf, (kal_int32)len, (kal_uint8)flags);
    
    return ret;
}

int vm_sendto(int sock, const char *buf, int len, int flags, const SOCKADDR *to, int tolen)
{
    
    kal_int32 ret;

    sockaddr_struct local = {0};

    if (sock < 0 || NULL == buf || 0 >= len || NULL == to)
    {
        return -20;
    }
        
    vm_addr_in2sockaddr_struct(to, &local, SOC_SOCK_DGRAM);

    ret = soc_sendto(sock, (const void *)buf, (kal_int32)len, (kal_uint8)flags, &local);

    return ret;
}

int vm_recv(int sock, char *buf, int len, int flags)
{
    kal_int32 ret;

    //sockaddr_struct local = {0};

    if (sock < 0 || NULL == buf || 0 >= len)
    {
        return -20;
    }
        
    //vm_addr_in2sockaddr_struct(addr, &local);

    ret = soc_recv((kal_int8)sock, (void*)buf, (kal_int32)len, (kal_uint8)flags);
    
    return ret;
}

int vm_recvfrom (int sock, char *buf, int len, int flags, SOCKADDR *from, int *fromlen)
{
    kal_int32 ret;

    sockaddr_struct local = {0};

    if (sock < 0 || NULL == buf || 0 >= len || NULL == from)
    {
        return -20;
    }
        
    //vm_addr_in2sockaddr_struct(from, &local);

    ret = soc_recvfrom(sock, (void *)buf, (kal_int32)len, (kal_uint8)flags, &local);
    
    vm_sockaddr_struct2addr_in(&local, from);

    return ret;
}

int vm_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const timeval *timeout)
{
    

    soc_timeval_struct tv = {0};

    kal_int8 ret;

    tv.tv_sec = timeout->tv_sec;
    tv.tv_usec = timeout->tv_usec;
    
    ret = soc_select((kal_uint8)nfds, 
            (soc_fd_set *)readfds, 
            (soc_fd_set *)writefds, 
            (soc_fd_set *)exceptfds, 
            &tv);

    

    
    return ret;
}

int vm_shutdown(int sock,  int how)
{
    kal_int8 ret = soc_shutdown(sock, (kal_uint8)how);
    return ret;
}
int vm_setsockopt(int sock,  VMUINT32 option, void *val, VMUINT8 val_size)
{
    kal_int8 ret;

    ret = soc_setsockopt((kal_int8)sock, (kal_uint32)option, val, (kal_uint8)val_size);
    
    return ret;
}

int vm_getsockopt(int sock,  VMUINT32 option, void *val, VMUINT8 val_size)
{
    kal_int8 ret;

    ret = soc_getsockopt((kal_int8)sock, (kal_uint32)option, val, (kal_uint8)val_size);
    
    return ret;
}

/*
int vm_gethostbyname(const char *domain_name, VMUINT8 *addr, VMUINT8 *addr_len)
{
    //soc_gethostbyname(kal_bool is_blocking,module_type mod_id,kal_int32 request_id,const kal_char * domain_name,kal_uint8 * addr,kal_uint8 * addr_len,kal_uint8 access_id,kal_uint32 nwk_account_id)
    return 0;
}
*/

int vm_getsockname(int s, SOCKADDR *addr, int *len)
{
    kal_int8 ret = -3;
    sockaddr_struct local;

    if (s < 0 || !addr || !len)
    {
        return -2;
    }

    switch (addr->sa_family)
    {
    case PF_INET:
        {
            ret = soc_getsockaddr((kal_int8)s, KAL_TRUE, &local);
            if (ret == SOC_SUCCESS)
            {
                *len = sizeof(SOCKADDR);
                vm_sockaddr_struct2addr_in(&local, addr);
            }
            
            return ret;
        }break;
    case 3: // PF_INET6:
        {
        
        }break;
    default:
        {
        
        }break;
    }

    

    //kal_trace(TRACE_FUNC, FUNC_GETSOCKNAME, s);


    return ret;
}

int vm_getpeername(int s, SOCKADDR *addr, int *len)
{
    kal_int8 ret = -3;
    sockaddr_struct peer;

    
    if (s < 0 || !addr || !len)
    {
        return -2;
    }
    
    switch (addr->sa_family)
    {
    case PF_INET:
        {
            ret = soc_getsockaddr((kal_int8)s, KAL_FALSE, &peer);
            if (ret == SOC_SUCCESS)
            {
                *len = sizeof(SOCKADDR);
                vm_sockaddr_struct2addr_in(&peer, addr);
            }
            return ret;
        }break;
    case 3: // PF_INET6:
        {
        
        }break;
    default:
        {
        
        }break;
    }

    return ret;
}

VMUINT32 vm_htonl(VMUINT32 a)
{
    return soc_htonl(a);
    /*
    VMUINT8 *b = (VMUINT8*)(&a);
    VMUINT8 tmp;
    
    tmp = b[0];
    b[0] = b[3];
    b[3] = tmp;

    tmp = b[1];
    b[1] = b[2];
    b[2] = tmp;
    
    return *(VMUINT32*)b;
    */
}

VMUINT16 vm_htons(VMUINT16 a)
{
    return soc_htons(a);
    /*
    VMUINT8 *b = (VMUINT8*)(&a);
    VMUINT8 tmp;
    
    tmp = b[0];
    b[0] = b[1];
    b[1] = tmp;
    
    return *(VMUINT16*)b;
    */
}

// IPV4
#define AF_INET 2
#define VM_NTOA_ADDR_LEN 64
static char vm_ntoa_addr[VM_NTOA_ADDR_LEN];        /* for storing returned string */

static int vm_int_inet_ntop4(const unsigned char *src, char *dst, size_t size)
{
    static const char *fmt = "%u.%u.%u.%u";
    char tmp[sizeof "255.255.255.255"];

    if ((size_t) sprintf(tmp, fmt, src[0], src[1], src[2], src[3]) >=
        size)
    {
        return 0;
    }
    strcpy(dst, tmp);

    return 1;
}


static int vm_int_inet_ntop(int af, const void *src, char *dst, size_t size)
{
    switch (af)
    {
    case AF_INET:
        return (vm_int_inet_ntop4(src, dst, size));
//#ifdef HAVE_IPV6
//        case AF_INET6:return (inet_ntop6(src, dst, size));
//#endif /* __cplusplus */
        default:return 0;
    }
    /* NOTREACHED */
}

static int vm_int_inet_pton4(const char *src, unsigned char *dst)
{
    static const char digits[] = "0123456789";
    int saw_digit, octets, ch;
    unsigned char tmp[4], *tp;

    saw_digit = 0;
    octets = 0;
    *(tp = tmp) = 0;
    while ((ch = *src++) != '\0')
    {
        const char *pch;

        if ((pch = strchr(digits, ch)) != NULL)
        {
            unsigned int new = *tp * 10 + (pch - digits);

            if (new > 255)
                return (0);
            *tp = new;
            if (!saw_digit)
            {
                if (++octets > 4)
                    return (0);
                saw_digit = 1;
            }
        }
        else if (ch == '.' && saw_digit)
        {
            if (octets == 4)
                return (0);
            *++tp = 0;
            saw_digit = 0;
        }
        else
            return (0);
    }
    if (octets < 4)
        return (0);
    memcpy(dst, tmp, 4);
    return (1);
}

static int vm_int_inet_pton(int af, const char *src, void *dst)
{
    switch (af)
    {
    case AF_INET:
        return (vm_int_inet_pton4(src, dst));
//#ifdef HAVE_IPV6
//        case AF_INET6:return (inet_pton6(src, dst));
//#endif /* HAVE_IPV6 */
        default:return 0;
    }
    /* NOTREACHED */
}

VMUINT vm_inet_addr(const char* addr)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	VMUINT dst_addr = 0;
	
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    int af = AF_INET;
    vm_int_inet_pton(AF_INET, addr, (void *)&dst_addr);
	return dst_addr;
}

char* vm_inet_ntoa(IN_ADDR in)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    int af = AF_INET;
    vm_int_inet_ntop(AF_INET, (const void *)&(in.S_un.s_addr), vm_ntoa_addr, VM_NTOA_ADDR_LEN);

    return vm_ntoa_addr;	
}

VMINT vm_soc_get_account_localip(VMINT8 sock, VMUINT8 *local_ip)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (VMINT)soc_get_account_localip((kal_int8)sock, (kal_uint8*)local_ip);
    
}


// ipv6
//extern int inet_ntop(int af, const void *src, char *dst, size_t size);

#endif /* defined(__IOT__) */

VMINT vm_get_network_sym(VMCHAR* func_name)
{
#if defined(__IOT__)
    if(strcmp(func_name,"vm_soc_get_host_by_name_ex") == 0)
        return (VMINT)vm_soc_get_host_by_name_ex;           
    if(strcmp(func_name,"vm_tcp_connect_ex") == 0)
        return (VMINT)vm_tcp_connect_ex;
    if(strcmp(func_name,"vm_tcp_connect_sync") == 0)
        return (VMINT)vm_tcp_connect_sync;
    if(strcmp(func_name,"vm_tcp_read_sync") == 0)
        return (VMINT)vm_tcp_read_sync;
    if(strcmp(func_name,"vm_tcp_write_sync") == 0)
        return (VMINT)vm_tcp_write_sync;
    if(strcmp(func_name,"vm_tcp_close_sync") == 0)
        return (VMINT)vm_tcp_close_sync;
    if(strcmp(func_name,"vm_soc_svr_init") == 0)
        return (VMINT)vm_soc_svr_init;
    if(strcmp(func_name,"vm_soc_svr_send") == 0)
        return (VMINT)vm_soc_svr_send;        
    if(strcmp(func_name,"vm_soc_svr_read") == 0)
        return (VMINT)vm_soc_svr_read;     
    if(strcmp(func_name,"vm_soc_svr_close_client") == 0)
        return (VMINT)vm_soc_svr_close_client;
    if(strcmp(func_name,"vm_soc_svr_deinit") == 0)
        return (VMINT)vm_soc_svr_deinit;
    if(strcmp(func_name,"vm_soc_svr_get_soc_id") == 0)
        return (VMINT)vm_soc_svr_get_soc_id;
    if(strcmp(func_name,"vm_soc_svr_init_sync") == 0)
        return (VMINT)vm_soc_svr_init_sync;
    if(strcmp(func_name,"vm_soc_svr_accept_sync") == 0)
        return (VMINT)vm_soc_svr_accept_sync;
    if(strcmp(func_name,"vm_soc_svr_send_sync") == 0)
        return (VMINT)vm_soc_svr_send_sync;        
    if(strcmp(func_name,"vm_soc_svr_read_sync") == 0)
        return (VMINT)vm_soc_svr_read_sync;     
    if(strcmp(func_name,"vm_soc_svr_close_client_sync") == 0)
        return (VMINT)vm_soc_svr_close_client_sync;
    if(strcmp(func_name,"vm_soc_svr_deinit_sync") == 0)
        return (VMINT)vm_soc_svr_deinit_sync;
    if(strcmp(func_name,"vm_tcp_get_soc_id") == 0)
        return (VMINT)vm_tcp_get_soc_id;
        
    if(strcmp(func_name,"vm_soc_get_last_error") == 0)
        return (VMINT)vm_soc_get_last_error;

    if(strcmp(func_name,"vm_bearer_open") == 0)
        return (VMINT)vm_bearer_open;
    if(strcmp(func_name,"vm_bearer_close") == 0)
        return (VMINT)vm_bearer_close;
    if(strcmp(func_name,"vm_socket") == 0)
        return (VMINT)vm_socket;
    if(strcmp(func_name,"vm_socket_ex") == 0)
        return (VMINT)vm_socket_ex;
    if(strcmp(func_name,"vm_closesocket") == 0)
        return (VMINT)vm_closesocket;
    if(strcmp(func_name,"vm_bind") == 0)
        return (VMINT)vm_bind;
    if(strcmp(func_name,"vm_listen") == 0)
        return (VMINT)vm_listen;
    if(strcmp(func_name,"vm_accept") == 0)
        return (VMINT)vm_accept;
    if(strcmp(func_name,"vm_connect") == 0)
        return (VMINT)vm_connect;
    if(strcmp(func_name,"vm_send") == 0)
        return (VMINT)vm_send;
    if(strcmp(func_name,"vm_sendto") == 0)
        return (VMINT)vm_sendto;
    if(strcmp(func_name,"vm_recv") == 0)
        return (VMINT)vm_recv;
    if(strcmp(func_name,"vm_recvfrom") == 0)
        return (VMINT)vm_recvfrom;
    if(strcmp(func_name,"vm_select") == 0)
        return (VMINT)vm_select;
    if(strcmp(func_name,"vm_shutdown") == 0)
        return (VMINT)vm_shutdown;
    if(strcmp(func_name,"vm_setsockopt") == 0)
        return (VMINT)vm_setsockopt;
    if(strcmp(func_name,"vm_getsockopt") == 0)
        return (VMINT)vm_getsockopt;
    if(strcmp(func_name,"vm_getsockname") == 0)
        return (VMINT)vm_getsockname;
    if(strcmp(func_name,"vm_getpeername") == 0)
        return (VMINT)vm_getpeername;
    if(strcmp(func_name,"vm_htonl") == 0)
        return (VMINT)vm_htonl;
    if(strcmp(func_name,"vm_htons") == 0)
        return (VMINT)vm_htons;
    if(strcmp(func_name,"vm_inet_addr") == 0)
        return (VMINT)vm_inet_addr;
    if(strcmp(func_name,"vm_inet_ntoa") == 0)
        return (VMINT)vm_inet_ntoa;
    if(strcmp(func_name,"vm_soc_get_account_localip") == 0)
        return (VMINT)vm_soc_get_account_localip;
#endif /* defined(__IOT__) */
    if(strcmp(func_name,"vm_srv_nw_info_get_service_availability") == 0)
        return (VMINT)vm_srv_nw_info_get_service_availability;
    if(strcmp(func_name,"vm_srv_nw_info_get_sim_dn_status") == 0)
        return (VMINT)vm_srv_nw_info_get_sim_dn_status;

    if(strcmp(func_name,"vm_set_cust_apn_info") == 0)
        return (VMINT)vm_set_cust_apn_info;
    if(strcmp(func_name,"vm_get_cust_apn_info") == 0)
        return (VMINT)vm_get_cust_apn_info;
	return 0;
}


#endif /* __MRE_SAL_SOCKET__ */

