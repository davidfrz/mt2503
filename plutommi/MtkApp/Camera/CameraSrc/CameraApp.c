/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
*
* Filename:
* ---------
*  CameraApp.c
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  Camera Applications v0.3
*
* Author:
* -------
 * -------
*                      
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
*
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/

/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
*
* Filename:
* ---------
*  CameraApp.c
*
* Project:
* --------
*  MAUI
*
* Description:
* ------------
*  Camera Applications v0.3
*
* Author:
* -------
 * -------
*                      
*============================================================================
*             HISTORY
* Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*------------------------------------------------------------------------------
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
 * removed!
 * removed!
 * removed!
*
*------------------------------------------------------------------------------
* Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
*============================================================================
****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
#include "MMI_features.h"

#if defined(__MMI_CAMERA__) && !defined(__MMI_CAMCORDER__)

/* suggest to add */
#include "lcd_sw_inc.h"
#include "MMI_features.h"
#include "gdi_features.h"
#include "MMIDataType.h"
#include "MMI_media_app_trc.h"
#include "GlobalResDef.h"
#include "med_api.h"
#include "mmi_frm_input_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_mem_gprot.h"
#include "gui_typedef.h"
#include "fs_func.h"
#include "fs_type.h"
#include "fs_errcode.h"
#include "stdio.h"
#include "Unicodexdcl.h"
#include "mmi_frm_nvram_gprot.h"
#include "nvram_common_defs.h"
#include "custom_mmi_default_value.h"
#include "custom_nvram_config.h"
#include "mmi_rp_file_type_def.h"
#include "string.h"
#include "GlobalConstants.h"
#include "CustDataRes.h"
#include "gui_data_types.h"
#include "AlertScreen.h"
#include "FileMgrResDef.h"
#include "mmi_rp_srv_filemanager_def.h"
#include "gdi_include.h"
#include "wgui_categories_util.h"
#include "gdi_const.h"
#include "gdi_lcd_config.h"
#include "app_mem.h"
#include "mmi_frm_scenario_gprot.h"
#include "gui.h"
#include "mmi_frm_history_gprot.h"
#include "UcmSrvGprot.h"
#include "GpioSrvGprot.h"
#include "gpiosrvgprot.h"
#include "DebugInitDef_Int.h"
#include "gui_effect_oem.h"
#include "PixcomFontEngine.h"
#include "wgui_touch_screen.h"
#include "gdi_datatype.h"
#include "g2d_enum.h"
#include "stack_config.h"
#include "kal_trace.h"
#include "wgui_include.h"
#include "gui_themes.h"
#include "gui_buttons.h"
#include "gui_effect_oem.h"
#include "wgui_inputs.h"
#include "device.h"
#include "mmi_media_app_trc.h"
#include "CustMenuRes.h"
#include "mms_api.h"
#include "wgui_categories_list.h"
#include "wgui_categories_popup.h"
#include "custom_events_notify.h"
#include "l4c_nw_cmd.h"
#include "CommonScreensResDef.h"
#include "gui_font_size.h"
#include "RestoreGprot.h"
#include "app_str.h"
#include "gui_touch_feedback.h"
#include "ModeSwitchSrvGprot.h"
#include "wgui_categories_sublcd.h"
#include "IdleAppGprot.h"
#include "wgui_categories.h"
#include "wgui_categories_multimedia.h"
/* Original but reduce X */
#define __MMI_CAMERA_ONLY__
#include "lcd_if.h"
#include "lcd_sw_rnd.h"
#include "mdi_datatype.h"
#include "mdi_camera.h"
#include "mdi_audio.h"
#include "MMI_features_camera.h"
#include "mmi_rp_app_mainmenu_def.h"
#include "CommonScreens.h"
#include "wgui_softkeys.h"
#include "FileMgrSrvGProt.h"
#include "FileMgrCuiGProt.h"
#include "InlineCuiGprot.h"
#include "menucuigprot.h"
#include "InlineCuiGprot.h"
#include "ProfilesSrvGprot.h"
#include "UCMGProt.h"
#include "PhotoEditorGProt.h"
#include "mmi_rp_app_camera_def.h"
#include "CbmSrvGprot.h"
#include "SoundEffect.h"
#include "mdi_include.h"
#include "resource_camera_skins.h"
#include "CameraGprot.h"
#include "CameraApp.h"
#include "CameraMenu.h"
#include "ImageViewerGprot.h"
#include "gdi_2d_engine.h"
#include "BTMMIScrGprots.h"
#include "BTMMIObexGprots.h"
#include "ScreenRotationGprot.h"
#include "EmailAppGProt.h"
#include "VdoRecGProt.h"
#ifdef __MMI_USB_SUPPORT__
#include "USBDeviceGprot.h"
#include "USBSrvGProt.h"
#include "mmi_rp_app_usbmmi_def.h"
#endif
#include "VdoRecCuiGprot.h"
#include "CameraCuiGprot.h"
#include "IdleAppResDef.h"
#include "AMGprot.h"
#include "Cal_feature_option.h"
#include "ScrlockerGprot.h"

#if ((LCD_WIDTH == 240) && (LCD_HEIGHT == 320))
#if (IMAGE_SENSOR_PREVIEW_HEIGHT == 288)
#undef __MMI_CAMERA_TOP_ALIGN__
#define __MMI_CAMERA_TOP_ALIGN__
#endif
#endif

#ifdef EXIF_SUPPORT
#include "exif.h"
#endif 
#ifdef __MMI_AUDIO_REVERB_EFFECT__
#include "SoundEffect.h"
#endif
#include "resource_audio.h"

#include "ConnectManageGprot.h"

#include "mdi_include.h"
#include "CameraResDef.h"              /* resource ID def */

#ifdef __MMI_SUBLCD_CAMERA__
#include "IdleAppProt.h"
#include "ScrLockerGprot.h"
#include "IdleGprot.h"
#endif

#include "BTMMIScrGprots.h"

#ifdef __MMI_OPP_SUPPORT__
#include "btsendcuigprot.h"
#endif

#if defined(__MMI_BT_AUDIO_VIA_SCO__) || defined(__MMI_BT_FM_VIA_SCO__)
#include "BthScoPathSrvGProt.h"
#endif

/* Bluetooth sending API revise */
#ifdef __MMI_BT_SUPPORT__
#include "BTMMIObexGprots.h"
#endif

#ifdef __MMI_BIP_SUPPORT__
#include "BTMMIBipGprot.h"
#endif

#if defined(__CAMERA_OSD_HORIZONTAL__)
#include "ScreenRotationGprot.h"
#endif 


/* TURN OFF EMAIL UNTIL IT GETS READY */
#ifdef __MMI_EMAIL__
#include "EmailAppGProt.h"
#endif

#ifdef __MMI_IRDA_SUPPORT__
#include "ConnectivityResDef.h"
#include "IrdaMMIGprots.h"
#endif

#if defined(__MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__)
#include "VdoRecGprot.h"
#endif

#if defined(__MMI_MMS__)
#include "wapadp.h"
#include "mmsadp.h"
#endif 

#include "VdoRecCuiGprot.h"
#include "CameraCuiGprot.h"
#include "mmi_frm_app_launcher_gprot.h"
#if defined(__MM_DEBUG_MEASURE__)
/* under construction !*/
#endif
#include "MMI_ap_dcm_config.h"

#if defined(__MTK_INTERNAL__)
/* under construction !*/
#endif

#define MMI_CAMERA_IS_SILENT_MODE() (TRUE==srv_prof_is_profile_activated(SRV_PROF_SILENT_MODE))

#if defined(__MM_DEBUG_MEASURE__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
#define MMI_CAMERA_START_MEASURE(_symbol_)
#define MMI_CAMERA_STOP_MEASURE(_symbol_)
#endif 
//#define __CAMERA_UI_DEBUG__
#if defined(__MMI_CAMERA_DEBUG_ON__) && defined(__MTK_TARGET__) && !defined(WIN32)
U32 g_mmi_cam_start_time;
U32 g_mmi_cam_end_time;
U32 g_mmi_cam_duration;
#define MMI_CAMERA_GET_START_TIME(_trace_) \
	do{\
	kal_get_time(&g_mmi_cam_start_time);\
	}while(0)
#define MMI_CAMERA_GET_STOP_TIME_AND_PRINT_TRACE(_trace_)\
	do{\
	kal_get_time(&g_mmi_cam_end_time);\
	g_mmi_cam_duration = kal_ticks_to_milli_secs(g_mmi_cam_end_time - g_mmi_cam_start_time);\
	kal_trace(MMI_MEDIA_TRC_G2_APP,_trace_, g_mmi_cam_duration,__LINE__);\
	}while(0)
#else
#define MMI_CAMERA_GET_START_TIME(_trace_)
#define MMI_CAMERA_GET_STOP_TIME_AND_PRINT_TRACE(_trace_) 
#endif

#ifndef __MMI_CAMERA_SLIM__
#if defined(__CAMERA_OSD_HORIZONTAL__)
#define MMI_CAMERA_DISPLAY_POPUP_STR(v,w,x)  \
	do {                                            \
	mmi_popup_property_struct arg;              \
	mmi_popup_property_init(&arg);              \
	arg.rotation = (mmi_frm_screen_rotate_enum)g_camera_cntx.osd_data.osd_rotate;    \
	if(g_camera_cntx.cur_gid != GRP_ID_INVALID) \
		{                                           \
		arg.parent_id = g_camera_cntx.cur_gid;  \
		arg.user_tag = (void *)((void*)x);      \
		}                                           \
		mmi_popup_display(v, (mmi_event_notify_enum)(w), &arg);    \
	}while(0);
#else /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
#define MMI_CAMERA_DISPLAY_POPUP_STR(v,w,x)  \
	if (g_camera_cntx.cur_gid == GRP_ID_INVALID)    \
	{                                               \
	mmi_popup_display(v, (mmi_event_notify_enum)(w), NULL);   \
	}                                               \
	else                                            \
	{                                               \
	mmi_popup_display_simple(v, (mmi_event_notify_enum)(w), g_camera_cntx.cur_gid, (void*)x);   \
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
#endif

#ifndef __MMI_CAMERA_SLIM__
#if defined(__CAMERA_OSD_HORIZONTAL__)
#define MMI_CAMERA_DISPLAY_POPUP(v,w,x)  \
	do {                                            \
	mmi_popup_property_struct arg;              \
	mmi_popup_property_init(&arg);              \
	arg.rotation = (mmi_frm_screen_rotate_enum)g_camera_cntx.osd_data.osd_rotate;    \
	if(g_camera_cntx.cur_gid != GRP_ID_INVALID) \
		{                                           \
		arg.parent_id = APP_CAMERA;  			\
		arg.user_tag = (void *)((void*)x);      \
		}                                           \
		else											\
		{												\
		if (mmi_frm_group_is_present(APP_CAMERA))   \
			{                                           \
			mmi_frm_group_close(APP_CAMERA);        \
			}                                           \
		}												\
		mmi_popup_display_ext(v, (mmi_event_notify_enum)(w), &arg);    \
	}while(0);
#else /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
#define MMI_CAMERA_DISPLAY_POPUP(v,w,x)  \
	if (g_camera_cntx.cur_gid == GRP_ID_INVALID)    \
	{                                               \
	if (mmi_frm_group_is_present(APP_CAMERA))   \
		{                                           \
		mmi_frm_group_close(APP_CAMERA);        \
		}                                           \
		mmi_popup_display_ext(v, (mmi_event_notify_enum)(w), NULL);   \
	}                                               \
	else                                            \
	{                                               \
	if(g_camera_cntx.external_request_mode != MMI_CAMERA_EXTERNAL_MODE_OFF)     \
		{											\
		mmi_popup_display_simple_ext(v, (mmi_event_notify_enum)(w), g_camera_cntx.cur_gid, (void*)x);   \
		}											\
		else										\
		{											\
		mmi_popup_display_simple_ext(v, (mmi_event_notify_enum)(w), APP_CAMERA, (void*)x);   \
		}											\
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
#else
void mmi_camera_display_popup(MMI_ID_TYPE string_id, mmi_event_notify_enum event_id, void* user_tag);


void mmi_camera_display_popup(MMI_ID_TYPE string_id, mmi_event_notify_enum event_id, void* user_tag)
{
#if defined(__CAMERA_OSD_HORIZONTAL__)
	mmi_popup_property_struct arg;				
	mmi_popup_property_init(&arg);				
	arg.rotation = (mmi_frm_screen_rotate_enum)g_camera_cntx.osd_data.osd_rotate;	 
	if(g_camera_cntx.cur_gid != GRP_ID_INVALID) 
	{																		
		arg.parent_id = g_camera_cntx.cur_gid;
		arg.user_tag = (void *)(user_tag);		
	}											
	else											
	{												
		if (mmi_frm_group_is_present(APP_CAMERA))	
		{											
			mmi_frm_group_close(APP_CAMERA);		
		}											
	}												
	mmi_popup_display_ext(string_id, (mmi_event_notify_enum)(event_id), &arg);    
#else /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	if (g_camera_cntx.cur_gid == GRP_ID_INVALID)	
	{												
		if (mmi_frm_group_is_present(APP_CAMERA))	
		{											
			mmi_frm_group_close(APP_CAMERA);		
		}											
		mmi_popup_display_ext(string_id, (mmi_event_notify_enum)(event_id), NULL);   
	}												
	else											
	{
		mmi_popup_display_simple_ext(string_id, (mmi_event_notify_enum)(event_id), g_camera_cntx.cur_gid, user_tag);								
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

}
#endif
/***************************************************************************** 
* Define
*****************************************************************************/

#define APP_API     extern
#define MOD_API     extern
#define SYS_CALLBACK    extern

#define DUMMY_COMMAND                  (0)
#define HINT_POPUP_FADE_TIME           (1200)
#define TOGGLE_POPUP_FADE_TIME         (800)
#define DONE_POPUP_FADE_TIME           (1000)
#define CAMERA_ERR_CORRUPT_FAT         (-2001)
#define CAMERA_ERR_PHONE_DISK_FULL     (-2002)
#define CAMERA_ERR_CARD_DISK_FULL      (-2003)
#define CAMERA_ERR_WRITE_PROTECT       (-2004)
#define CAMERA_ERR_ROOT_DIR_FULL       (-2005)
#define CAMERA_ERR_SAVE_FAIL           (-2006)
#define CAMERA_ERR_BT_IS_WORKING       (-2007)
#define CAMERA_ERR_BEARER_IS_ACTIVE    (-2008)
#define CAMERA_ERR_EXIST_PHOTOS_FILE   (-2009)
#define CAMERA_ERR_CREATE_DIR          (-2010)


#define POPLIST_LIST_SPACING           (1)

#define CAMERA_AF_LARGE_WIDTH             (32)
#define CAMERA_AF_NORMAL_WIDTH            (32)
#define CAMERA_AF_SMALL_WIDTH             (32)

#if defined(VC0558)
#define CAMEAR_BG_TRASN_COLOR       (0x0821)
#else 
#define CAMEAR_BG_TRASN_COLOR       (GDI_COLOR_TRANSPARENT)
#endif 

#define TRANSLATE_COORDINATE_TO_270(X,Y,TMP)\
	TMP=X;                          \
	X=Y;                            \
	Y=(LCD_WIDTH-1)-TMP;

#define BEFORE_PLAY_AUDIO()\
	g_camera_cntx.is_audio_finished=FALSE;
/***************************************************************************** 
* Typedef 
*****************************************************************************/
/* camera application state */
typedef enum
{
	CAMERA_STATE_EXIT = 0,                  /* 0 */

	/* main lcd */
	CAMERA_STATE_PREVIEW,                   /* 1 */
	CAMERA_STATE_COUNTDOWN,                 /* 2 */
	CAMERA_STATE_CONTSHOT,                  /* 3 */
	CAMERA_STATE_BURSTSHOT,                 /* 4 */
	CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM,    /* 5 */
	CAMERA_STATE_BURSTSHOT_SAVING,          /* 6 */
	CAMERA_STATE_DELETE_DONE,                 /* 7 */
	CAMERA_STATE_DELETE_CONFIRM,              /* 8 */

	/* toggle popup */
	CAMERA_STATE_TOGGLE_TO_SUB,             /* 10 */
	CAMERA_STATE_TOGGLE_TO_MAIN,            /* 11 */

	/* sub lcd */
	CAMERA_STATE_SUB_PREVIEW,               /* 12 */
	CAMERA_STATE_SUB_COUNTDOWN,             /* 13 */
	CAMERA_STATE_SUB_CONTSHOT,              /* 14 */
	CAMERA_STATE_SUB_BURSTSHOT,             /* 15 */
	CAMERA_STATE_SUB_BURSTSHOT_SAVING,      /* 16 */

	/* forward */
	CAMERA_STATE_FORWARD_TO                 /* 17 */

} camera_state_enum;

#ifdef __MMI_SUBLCD_CAMERA__
typedef enum
{
	SUB_CAMERA_STATE_EXIT = 0,                  /* 0 */

	/* main lcd */
	SUB_CAMERA_STATE_PREVIEW,                   /* 1 */
	SUB_CAMERA_STATE_COUNTDOWN,                 /* 2 */
	SUB_CAMERA_STATE_CONTSHOT,                  /* 3 */
	SUB_CAMERA_STATE_BURSTSHOT,                 /* 4 */
	SUB_CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM,    /* 5 */
	SUB_CAMERA_STATE_BURSTSHOT_SAVING,          /* 6 */
	SUB_CAMERA_STATE_SAVE_DONE,                 /* 7 */
	SUB_CAMERA_STATE_SAVE_CONFIRM,              /* 8 */

} sublcd_camera_state_enum;
#endif

typedef struct
{
	S32 error;            /* error code */
	mmi_str_id str_id;    /* error string id */
} camera_error_info_struct;

const static camera_error_info_struct g_camera_error_table[] = 
{
	{CAMERA_ERR_BEARER_IS_ACTIVE,               STR_ID_CAMERA_NOTIFY_BEARER_IS_ACTIVE},
	{CAMERA_ERR_BT_IS_WORKING,                  STR_ID_CAMERA_NOTIFY_BT_IS_WORKING},
	{MDI_RES_CAMERA_ERR_DISK_FULL,              FMGR_FS_DISK_FULL_TEXT},
	{MDI_RES_CAMERA_ERR_NO_DISK,                STR_ID_CAMERA_NOTIFY_NO_MEMORY_CARD},
	{MDI_RES_CAMERA_ERR_WRITE_PROTECTION,       STR_ID_CAMERA_NOTIFY_WRITE_PROTECTION},
	{MDI_RES_CAMERA_ERR_CAPTURE_FAILED,         STR_ID_CAMERA_NOTIFY_CAPTURE_FAILED},
	{CAMERA_ERR_CARD_DISK_FULL,                 FMGR_FS_DISK_FULL_TEXT},
	{CAMERA_ERR_ROOT_DIR_FULL,                  FMGR_FS_ROOT_DIR_FULL_TEXT},
	{CAMERA_ERR_WRITE_PROTECT,                  FMGR_FS_WRITE_PROTECTION_TEXT},
	{MDI_RES_CAMERA_ERR_HW_NOT_READY,           STR_ID_CAMERA_NOTIFY_HW_NOT_READY},   
	{MDI_RES_CAMERA_ERR_MEMORY_NOT_ENOUGH,      STR_GLOBAL_NOT_ENOUGH_MEMORY},
	{CAMERA_ERR_CORRUPT_FAT,                    FMGR_FS_FAT_ALLOC_ERROR_TEXT},
	{CAMERA_ERR_PHONE_DISK_FULL,                FMGR_FS_DISK_FULL_TEXT},
	{CAMERA_ERR_SAVE_FAIL,                      STR_ID_CAMERA_NOTIFY_SAVING_FAIL},
	{MDI_RES_CAMERA_ERR_XENONFLASH_TIMEOUT,     STR_ID_CAMERA_NOTIFY_XENON_TIMEOUT},
	{MDI_RES_CAMERA_ERR_XENONFLASH_LOW_BATTERY, STR_ID_CAMERA_NOTIFY_XENON_LOW_BATTERY},
	{CAMERA_ERR_CREATE_DIR,                     STR_ID_CAMERA_NOTIFY_CREATE_DIR_ERR},
	{0,0}
};


/****************************************************************************
* Setting command map                                                                
*****************************************************************************/
/* mapping mmi settings to mdi command. */
/*********** EV ***********/
const U8 camera_ev_command_map[CAMERA_SETTING_EV_COUNT + 1] = 
{
#ifdef __CAMERA_FEATURE_EV_4__
	MDI_CAMERA_EV_N4,   /* CAMERA_SETTING_EV_N4 */
#endif 

#ifdef __CAMERA_FEATURE_EV_3__
	MDI_CAMERA_EV_N3,   /* CAMERA_SETTING_EV_N3 */
#endif 

#ifdef __CAMERA_FEATURE_EV_2__
	MDI_CAMERA_EV_N2,   /* CAMERA_SETTING_EV_N2 */
#endif 

	MDI_CAMERA_EV_N1,   /* CAMERA_SETTING_EV_N1 */
	MDI_CAMERA_EV_0,    /* CAMERA_SETTING_EV_0 */
	MDI_CAMERA_EV_P1,   /* CAMERA_SETTING_EV_P1 */

#ifdef __CAMERA_FEATURE_EV_2__
	MDI_CAMERA_EV_P2,   /* CAMERA_SETTING_EV_P2 */
#endif 

#ifdef __CAMERA_FEATURE_EV_3__
	MDI_CAMERA_EV_P3,   /* CAMERA_SETTING_EV_P3 */
#endif 

#ifdef __CAMERA_FEATURE_EV_4__
	MDI_CAMERA_EV_P4,   /* CAMERA_SETTING_EV_P4 */
#endif 

	DUMMY_COMMAND
};

/*********** EFFECT ***********/
const U8 camera_effect_command_map[CAMERA_SETTING_EFFECT_COUNT + 1] = 
{
#ifdef __CAMERA_FEATURE_EFFECT_NORMAL__
	MDI_CAMERA_EFFECT_NOMRAL,   /* CAMERA_SETTING_EFFECT_NOMRAL */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_GRAYSCALE__
	MDI_CAMERA_EFFECT_GRAYSCALE,    /* CAMERA_SETTING_EFFECT_GRAYSCALE */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_SEPIA__
	MDI_CAMERA_EFFECT_SEPIA,    /* CAMERA_SETTING_EFFECT_SEPIA */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_SEPIA_GREEN__
	MDI_CAMERA_EFFECT_SEPIA_GREEN,  /* CAMERA_SETTING_EFFECT_SEPIA_GREEN */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_SEPIA_BLUE__
	MDI_CAMERA_EFFECT_SEPIA_BLUE,   /* CAMERA_SETTING_EFFECT_SEPIA_BLUE */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_COLOR_INVERT__
	MDI_CAMERA_EFFECT_COLOR_INVERT, /* CAMERA_SETTING_EFFECT_COLOR_INVERT */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_GRAY_INVERT__
	MDI_CAMERA_EFFECT_GRAY_INVERT,  /* CAMERA_SETTING_EFFECT_GRAY_INVERT */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_BLACKBOARD__
	MDI_CAMERA_EFFECT_BLACKBOARD,   /* CAMERA_SETTING_EFFECT_BLACKBOARD */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_WHITEBOARD__
	MDI_CAMERA_EFFECT_WHITEBOARD,   /* CAMERA_SETTING_EFFECT_WHITEBOARD */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_COPPER_CARVING__
	MDI_CAMERA_EFFECT_COPPER_CARVING,   /* CAMERA_SETTING_EFFECT_COPPER_CARVING */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_BLUE_CARVING__
	MDI_CAMERA_EFFECT_BLUE_CARVING, /* CAMERA_SETTING_EFFECT_BLUE_CARVING */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_EMBOSSMENT__
	MDI_CAMERA_EFFECT_EMBOSSMENT,   /* CAMERA_SETTING_EFFECT_EMBOSSMENT */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_CONTRAST__
	MDI_CAMERA_EFFECT_CONTRAST, /* CAMERA_SETTING_EFFECT_CONTRAST */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_JEAN__
	MDI_CAMERA_EFFECT_JEAN, /* CAMERA_SETTING_EFFECT_JEAN */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_SKETCH__
	MDI_CAMERA_EFFECT_SKETCH,   /* CAMERA_SETTING_EFFECT_SKETCH */
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_OIL__
	MDI_CAMERA_EFFECT_OIL,  /* CAMERA_SETTING_EFFECT_OIL */
#endif 

#ifdef __CAL_ADVANCED_IMAGE_EFFECT_SUPPORT__
#ifdef __CAMERA_FEATURE_EFFECT_EFFECT_LOMO__
	MDI_CAMERA_EFFECT_LOMO,
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_EFFECT_COLOR_RED__
	MDI_CAMERA_EFFECT_COLOR_RED,
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_EFFECT_COLOR_YELLOW__
	MDI_CAMERA_EFFECT_COLOR_YELLOW,
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_EFFECT_COLOR_GREEN__
	MDI_CAMERA_EFFECT_COLOR_GREEN,
#endif 

#ifdef __CAMERA_FEATURE_EFFECT_EFFECT_COLOR_BLUE__
	MDI_CAMERA_EFFECT_COLOR_BLUE,
#endif 
#endif      
	DUMMY_COMMAND
};

/*********** WB ***********/
const U8 camera_wb_command_map[CAMERA_SETTING_WB_COUNT + 1] = 
{
#ifdef __CAMERA_FEATURE_WB_AUTO__
	MDI_CAMERA_WB_AUTO, /* CAMREA_SETTING_WB_AUTO */
#endif 

#ifdef __CAMERA_FEATURE_WB_DAYLIGHT__
	MDI_CAMERA_WB_DAYLIGHT, /* CAMERA_SETTING_WB_DAYLIGHT */
#endif 

#ifdef __CAMERA_FEATURE_WB_TUNGSTEN__
	MDI_CAMERA_WB_TUNGSTEN, /* CAMERA_SETTING_WB_TUNGSTEN */
#endif 

#ifdef __CAMERA_FEATURE_WB_FLUORESCENT__
	MDI_CAMERA_WB_FLUORESCENT,  /* CAMERA_SETTING_WB_FLUORESCENT */
#endif 

#ifdef __CAMERA_FEATURE_WB_CLOUD__
	MDI_CAMERA_WB_CLOUD,    /* CAMERA_SETTING_WB_CLOUD */
#endif 

#ifdef __CAMERA_FEATURE_WB_INCANDESCENCE__
	MDI_CAMERA_WB_INCANDESCENCE,    /* CAMERA_SETTING_WB_INCANDESCENCE */
#endif 

#ifdef __CAMERA_FEATURE_WB_MANUAL__
	MDI_CAMERA_WB_MANUAL,   /* MDI_CAMERA_WB_MANUAL */
#endif
	DUMMY_COMMAND
};

/*********** Image Qty ***********/
const U8 camera_image_qty_command_map[CAMERA_SETTING_IMAGE_QTY_COUNT + 1] = 
{
#ifdef __CAMERA_FEATURE_IMAGE_QTY_LOW__
	MDI_CAMERA_JPG_QTY_LOW, /* CAMERA_SETTING_IMAGE_QTY_LOW */
#endif 

#ifdef __CAMERA_FEATURE_IMAGE_QTY_NORMAL__
	MDI_CAMERA_JPG_QTY_NORMAL,  /* CAMERA_SETTING_IMAGE_QTY_NORMAL */
#endif 

#ifdef __CAMERA_FEATURE_IMAGE_QTY_HIGH__
	MDI_CAMERA_JPG_QTY_HIGH,    /* CAMERA_SETTING_IMAGE_QTY_HIGH */
#endif 

#ifdef __CAMERA_FEATURE_IMAGE_QTY_FINE__
	MDI_CAMERA_JPG_QTY_FINE,    /* CAMREA_SETTING_IMAGE_QTY_FINE */
#endif 

	DUMMY_COMMAND
};

/*********** Banding ***********/
const U8 camera_banding_command_map[CAMERA_SETTING_BANDING_COUNT + 1] = 
{
	MDI_CAMERA_BANDING_50HZ,
	MDI_CAMERA_BANDING_60HZ,
	DUMMY_COMMAND
};

/*********** AE meter ***********/
const U8 camera_ae_meter_command_map[CAMERA_SETTING_AE_METER_COUNT + 1] = 
{
#ifdef __CAMERA_FEATURE_AE_METER_AUTO__
	MDI_CAMERA_AE_METER_AUTO,   /* CAMERA_SETTING_AE_METER_AUTO */
#endif 

#ifdef __CAMERA_FEATURE_AE_METER_SPOT__
	MDI_CAMERA_AE_METER_SPOT,   /* CAMERA_SETTING_AE_METER_SPOT */
#endif 

#ifdef __CAMERA_FEATURE_AE_METER_CENTER__
	MDI_CAMERA_AE_METER_CENTER, /* CAMERA_SETTING_AE_METER_CENTER */
#endif 

#ifdef __CAMERA_FEATURE_AE_METER_AVERAGE__
	MDI_CAMERA_AE_METER_AVERAGE,    /* CAMERA_SETTING_AE_METER_AVERAGE */
#endif 

	DUMMY_COMMAND
};

/*********** Flash ***********/
const U8 camera_flash_command_map[CAMERA_SETTING_FLASH_COUNT + 1] = 
{
	MDI_CAMERA_FLASH_OFF,   /* CAMERA_SETTING_FLASH_OFF */
	MDI_CAMERA_FLASH_ON,    /* CAMERA_SETTING_FLASH_ON */

#ifdef __CAMERA_FEATURE_FLASH_AUTO__
	MDI_CAMERA_FLASH_AUTO,  /* CAMERA_SETTING_FLASH_AUTO */
#endif 

#ifdef __CAMERA_FEATURE_FLASH_REDEYE__
	MDI_CAMERA_FLASH_REDEYE,    /* CAMERA_SETTING_FLASH_REDEYE */
#endif 

	DUMMY_COMMAND
};

/*********** ISO ***********/
const U8 camera_iso_command_map[CAMERA_SETTING_ISO_COUNT + 1] = 
{
#ifdef __CAEMRA_FEATURE_ISO_AUTO__
	MDI_CAMERA_ISO_AUTO,    /* CAMERA_SETTING_ISO_AUTO */
#endif 

#ifdef __CAEMRA_FEATURE_ISO_100__
	MDI_CAMERA_ISO_100, /* CAMERA_SETTING_ISO_100 */
#endif 

#ifdef __CAEMRA_FEATURE_ISO_200__
	MDI_CAMERA_ISO_200, /* CAMERA_SETTING_ISO_200 */
#endif 

#ifdef __CAEMRA_FEATURE_ISO_400__
	MDI_CAMERA_ISO_400, /* CAMERA_SETTING_ISO_400 */
#endif 

	DUMMY_COMMAND
};

const U8 camera_autofocus_command_map[CAMERA_SETTING_AUTOFOCUS_COUNT + 1] = 
{
#ifdef __CAMERA_AUTOFOCUS_1_ZONE__
	MDI_CAMERA_AF_OPERATION_MODE_SINGLE_ZONE,
#endif 
#ifdef __CAMERA_AUTOFOCUS_3_ZONE__
	MDI_CAMERA_AF_OPERATION_MODE_MULTI_ZONE,
#endif 
#ifdef __CAMERA_AUTOFOCUS_5_ZONE__
	MDI_CAMERA_AF_OPERATION_MODE_MULTI_ZONE,
#endif 
	DUMMY_COMMAND
};

const U8 camera_autofocus_mode_command_map[CAMERA_SETTING_AUTOFOCUS_MODE_COUNT + 1] = 
{
#ifdef __CAMERA_AUTOFOCUS_MODE_AUTO__
	MDI_CAMERA_AF_RANGE_AUTO,
#endif 
#ifdef __CAMERA_AUTOFOCUS_MODE_MACRO__
	MDI_CAMERA_AF_RANGE_MACRO,
#endif 
#ifdef __CAMERA_AUTOFOCUS_MODE_INFINITE__
	MDI_CAMERA_AF_RANGE_LANDSCAPE,
#endif 
	DUMMY_COMMAND
};

/*********** Shot Mode ***********/
const U8 camera_dsc_mode_command_map[CAMERA_SETTING_DSC_MODE_COUNT + 1] = 
{
#ifdef __CAMERA_DSC_MODE_AUTO__
	MDI_CAMERA_SCENE_MODE_AUTO,           /* CAMERA_SETTING_DSC_MODE_AUTO */
#endif 
#ifdef __CAMERA_DSC_MODE_PORTRAIT__
	MDI_CAMERA_SCENE_MODE_PORTRAIT,       /* CAMERA_SETTING_DSC_MODE_PORTRAIT */
#endif 
#ifdef __CAMERA_DSC_MODE_LANDSCAPE__
	MDI_CAMERA_SCENE_MODE_LANDSCAPE,      /* CAMERA_SETTING_DSC_MODE_LANDSCAPE */
#endif 
#ifdef __CAMERA_DSC_MODE_SPORT__
	MDI_CAMERA_SCENE_MODE_SPORT,          /* CAMERA_SETTING_DSC_MODE_SPORT */
#endif 
#ifdef __CAMERA_DSC_MODE_FLOWER__
	MDI_CAMERA_SCENE_MODE_FLOWER,         /* CAMERA_SETTING_DSC_MODE_FLOWER */
#endif 
#ifdef __CAMERA_DSC_MODE_NIGHT__
	MDI_CAMERA_SCENE_MODE_NIGHT,          /* CAMERA_SETTING_DSC_MODE_NIGHT */
#endif 

	DUMMY_COMMAND
};


static const struct img_size_map{
	U16 img_w, img_h;
}g_camera_img_size_map[] = 
{
#ifdef __CAMERA_FEATURE_IMAGE_SIZE_SS__

	{
		CAMERA_FEATURE_IMAGE_SIZE_SS_WIDTH, CAMERA_FEATURE_IMAGE_SIZE_SS_HEIGHT,
	},
#endif

#ifdef __CAMERA_FEATURE_IMAGE_SIZE_S__

	{
		CAMERA_FEATURE_IMAGE_SIZE_S_WIDTH, CAMERA_FEATURE_IMAGE_SIZE_S_HEIGHT,

		},
#endif

#ifdef __CAMERA_FEATURE_IMAGE_SIZE_M__

		{
			CAMERA_FEATURE_IMAGE_SIZE_M_WIDTH, CAMERA_FEATURE_IMAGE_SIZE_M_HEIGHT,
		},
#endif

#ifdef __CAMERA_FEATURE_IMAGE_SIZE_L__

		{
			CAMERA_FEATURE_IMAGE_SIZE_L_WIDTH, CAMERA_FEATURE_IMAGE_SIZE_L_HEIGHT,
			},
#endif

#ifdef __CAMERA_FEATURE_IMAGE_SIZE_LL__

			{
				CAMERA_FEATURE_IMAGE_SIZE_LL_WIDTH, CAMERA_FEATURE_IMAGE_SIZE_LL_HEIGHT,
			},
#endif
};

#define CAMERA_IMG_SIZE_COUNT   (sizeof(g_camera_img_size_map)/sizeof(g_camera_img_size_map[0]))
/****************************************************************************
* Global Variable - Extern                                                                 
*****************************************************************************/

/****************************************************************************
* Global Function                                                           
*****************************************************************************/
extern void custom_start_flashlight(kal_uint8 red_level, kal_uint8 green_level, kal_uint8 blue_level, kal_uint8 duty);
extern void custom_stop_flashlight(void);

extern U16 GetCurKeypadTone(void);


#ifdef __MMI_TOUCH_SCREEN__
MMI_BOOL wgui_test_lsk_position(mmi_pen_point_struct pos);
#endif 

#if defined(__MTK_INTERNAL__)// && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/***************************************************************************** 
* Local Variable
*****************************************************************************/
/* camera contex */
camera_context_struct g_camera_cntx;
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
#if defined(__MTK_TARGET__)
static volatile kal_timerid resz_cp_ESD_timeout_timer = NULL;
volatile kal_bool resz_esd_check_flag = KAL_TRUE;

static void resz_cp_ESD_timeout_timer_hdlr(void);
static void mmi_camera_app_reset_watchdog_callback(void);
static void mmi_camera_app_reset_watchdog_ESD(void);
#endif
#endif

/*****************************************************************************
* Local Function 
*****************************************************************************/
static const camera_key_struct* mmi_camera_get_key(U16 Keycode);

#ifdef __CAMERA_FEATURE_XENON_FLASH__
static void mmi_camera_xenon_flash_callback(mdi_result result, void* user_data);
#endif

static MMI_BOOL mmi_camera_del_app_sceen_hdlr(void);

/* setting / path / stroage */
static void mmi_camera_get_next_filename(CHAR * file_buf_p);
static void mmi_camera_display_error_popup(void);
static void mmi_camera_countdown(S32 count,void (*LED_callback) (void),void (*countdown_callback) (void));


/* app */
static void mmi_camera_lauch_init(void);
void mmi_camera_hilight_app(void);
static void mmi_camera_exit_app_screen(void);
static void mmi_camera_enter_state(camera_state_enum state);
static void mmi_camera_exit_current_state(void);

#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__)
static mmi_ret mmi_camera_clam_close_event_hdlr(mmi_event_struct *evt);
extern void mmi_idle_display(void);
#endif

#ifdef __CAMERA_FEATURE_REMAIN_STORAGE__
static void mmi_camera_calc_remain_storage(void);
#endif

static void mmi_camera_toggle_hide_osd(void);

static void mmi_camera_turn_on_preview_led_highlight(void);
static void mmi_camera_turn_on_capture_led_highlight(void);
static void mmi_camera_turn_off_led_highlight(void);

/* mainlcd preview state */
static void mmi_camera_entry_preview_state(void);
static void mmi_camera_exit_preview_state(void);
#if defined(__MMI_CAMERA_BG_CALL__)
static void mmi_camera_incall_popup_error(void);
#endif
static void mmi_camera_preview_set_key_hdlr(void);
static void mmi_camera_preview_create_resource(void);
static void mmi_camera_preview_free_resource(void);

static void mmi_camera_preview_create_preview_resource(S32 offset_x, S32 offset_y, S32 width, S32 height);
static void mmi_camera_preview_free_preview_resource(void);

static void mmi_camera_preview_start(void);
static void mmi_camera_preview_stop(void);
static void mmi_camera_preview_set_blt_layer(BOOL is_previewing);

static void mmi_camera_preview_flatten_layer(BOOL is_previewing);

static void mmi_camera_preview_draw_osd(void);
static void mmi_camera_preview_draw_title(void);
static void mmi_camera_preview_draw_softkey(void);
static void mmi_camera_preview_draw_hint(void);

static void mmi_camera_preview_draw_osd_timer(void);
static void mmi_camera_commit_filename_seq_no(void);

#ifdef __CAMERA_FAST_ZOOM_SUPPORT__
static void mmi_camera_start_fast_zoom(void *is_zoomin);
static void mmi_camera_stop_fast_zoom(void);
#endif /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 

#ifdef __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__
static void mmi_camera_preview_draw_contshot_countbar(void);
#endif 

static void mmi_camera_preview_set_hint(CHAR * hint_str1, CHAR *  hint_str2, U16 fade_time);
static void mmi_camera_preview_hide_hint(void);

#ifdef __CAMERA_FEATURE_EV__
static void mmi_camera_preview_ev_inc_key_press(void);
static void mmi_camera_preview_ev_dec_key_press(void);
static void mmi_camera_preview_ev_key_release(void);

#endif

#ifdef __CAMERA_FEATURE_ZOOM__
static void mmi_camera_preview_zoom(void *is_zoomin);
static void mmi_camera_preview_up_arrow_press(void);
static void mmi_camera_preview_zoom_arrow_release(void);
static void mmi_camera_preview_down_arrow_press(void);
#endif /* __CAMERA_FEATURE_ZOOM__ */ 

#ifdef __CAMERA_FEATURE_CONT_SHOT__
static void mmi_camera_entry_contshot_state(void);
static void mmi_camera_exit_contshot_state(void);
static void mmi_camera_contshot_cyclic(void);
static void mmi_camera_contshot_quickview(void);

#endif 



#ifdef __MMI_CAMERA_AF_TEST__
static void mmi_camera_af_test(void);
static void mmi_camera_af_test_start(void);
#endif /* __MMI_CAMERA_AF_TEST__ */ 

#if defined(__AF_SUPPORT_ONE_KEY__) || defined(__MMI_CAMERA_AF_TEST__)
static void mmi_camera_af_and_capture(void);
#endif

static void mmi_camera_preview_lsk_release(void);
static void mmi_camera_preview_rsk_release(void);

/* countdown state */
static void mmi_camera_entry_countdown_state(void);
static void mmi_camera_exit_countdown_state(void);
static void mmi_camera_countdown_cyclic(void);
static void mmi_camera_countdown_stop_LED(void);

#ifdef __COUNTDOWN_USING_MMA__
static void mmi_camera_init_countdown_mma(void);
static void mmi_camera_deinit_countdown_mma(void);
#endif


#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
/* burstshot state */
static void mmi_camera_entry_burstshot_capture_state(void);
static void mmi_camera_exit_burstshot_capture_state(void);

#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)
static void mmi_camera_burstshot_capture_result_hdlr(MDI_RESULT ret, U16 captured_count);
static void mmi_camera_burstshot_close_multi_sound(void);
static void mmi_camera_capture_play_multi_channel_sound(void);
#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

/* burstshot save confirm state */
static void mmi_camera_entry_burstshot_save_confirm_state(void);
static void mmi_camera_exit_burstshot_save_confirm_state(void);
static void mmi_camera_burstshot_save_confirm_lsk_press(void);
static void mmi_camera_burstshot_save_confirm_lsk_release(void);
static void mmi_camera_burstshot_save_confirm_rsk_press(void);
static void mmi_camera_burstshot_save_confirm_rsk_release(void);

/* burstshot saving state */
static void mmi_camera_entry_burstshot_saving_state(void);
static void mmi_camera_exit_burstshot_saving_state(void);
static void mmi_camera_burstshot_saving_cyclic(void);
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

/* save confirm state */
static void mmi_camera_entry_delete_confirm_state(void);
static void mmi_camera_exit_delete_confirm_state(void);
static void mmi_camera_delete_confirm_lsk_press(void);
static void mmi_camera_delete_confirm_lsk_release(void);
static void mmi_camera_delete_confirm_rsk_press(void);
static void mmi_camera_delete_confirm_rsk_release(void);
static void mmi_camera_delete_confirm_delete_file(void);
#if defined(__MMI_TOUCH_SCREEN__) && defined(__MMI_CAMERA_FORWARD_SUPPORT__)
static void mmi_camera_forward_icon_press(void);
static void mmi_camera_forward_icon_release(void);
#endif /* __MMI_CAMERA_FORWARD_SUPPORT__ */ 

/* capture */
static void mmi_camera_capture(void);
static void mmi_camera_capture_button_press(void);
static void mmi_camera_capture_button_release(void);

#ifdef __CAMERA_AUTOFOCUS__
static void mmi_camera_capture_button_autofocus_pressed(void);
static void mmi_camera_capture_button_autofocus_released(void);
static void mmi_camera_autofocus_callback(mdi_camera_af_result_struct pMsg, void* user_data);
static void mmi_camera_play_af_succeed_finished(mdi_result result, void* user_data);
static void mmi_camera_draw_autofocus_process(void);
static void mmi_camera_preview_draw_osd_timer(void);
static void mmi_camera_draw_bolder_rect(S32 x1, S32 y1, S32 x2, S32 y2, S32 bolder_width, gdi_color frame_color);
#endif /* __CAMERA_AUTOFOCUS__ */ 



/* save done */
static void mmi_camera_entry_delete_done_state(void);
static void mmi_camera_exit_delete_done_state(void);
static void mmi_camera_delete_done_timeout(void);
#ifdef __CAMERA_FEATURE_EV__
static void mmi_camera_preview_ev_cyclic(void *is_inc);
#endif


#ifdef __MMI_SUBLCD__
/* sub screen */
void mmi_camera_entry_sublcd_screen(void);
void mmi_camera_exit_sublcd_screen(void);
static void mmi_camera_sublcd_capture(void);
#endif /* __MMI_SUBLCD__ */ 

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
static void mmi_camera_display_sublcd_error_popup(void);
static void mmi_camera_toggle_self_capture(void);

/* toggle to sub state */
static void mmi_camera_entry_toggle_to_sub_state(void);
static void mmi_camera_exit_toggle_to_sub_state(void);
static void mmi_camera_toggle_to_sub_timeout(void);

/* toggle to main state */
static void mmi_camera_entry_toggle_to_main_state(void);
static void mmi_camera_exit_toggle_to_main_state(void);
static void mmi_camera_toggle_to_main_timeout(void);

/* sublcd preview state */
static void mmi_camera_entry_sublcd_preview_state(void);
static void mmi_camera_exit_sublcd_preview_state(void);
static void mmi_camera_sublcd_preview_set_key_hdlr(void);
static void mmi_camera_sublcd_preview_start(void);
static void mmi_camera_sublcd_preview_stop(void);
static void mmi_camera_sublcd_preview_set_blt_layer(BOOL is_previewing);
static void mmi_camera_sublcd_preview_lsk_press(void);
static void mmi_camera_sublcd_preview_rsk_press(void);
static void mmi_camera_sublcd_preview_lsk_release(void);
static void mmi_camera_sublcd_preview_rsk_release(void);

/* sublcd countdown state */
static void mmi_camera_entry_sublcd_countdown_state(void);
static void mmi_camera_exit_sublcd_countdown_state(void);
static void mmi_camera_sublcd_countdown_cyclic(void);
static void mmi_camera_sublcd_countdown_stop_LED(void);

/* sublcd contshot state */
#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
#ifdef __CAMERA_FEATURE_CONT_SHOT__
static void mmi_camera_entry_sublcd_contshot_state(void);
static void mmi_camera_exit_sublcd_contshot_state(void);
static void mmi_camera_sublcd_contshot_cyclic(void);
#endif
#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
/* sublcd burstshot state */
static void mmi_camera_entry_sublcd_burstshot_state(void);
static void mmi_camera_exit_sublcd_burstshot_state(void);

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__
static void mmi_camera_sublcd_burstshot_capture_result_hdlr(MDI_RESULT ret, U16 captured_count);
#endif 

/* sublcd burstshot saving state */
static void mmi_camera_entry_sublcd_burstshot_saving_state(void);
static void mmi_camera_exit_sublcd_burstshot_saving_state(void);
static void mmi_camera_sublcd_burstshot_saving_cyclic(void);

#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

/* sublcd capture */
static void mmi_camera_sublcd_capture_button_press(void);
static void mmi_camera_sublcd_capture(void);


#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

/* util draw */

#if defined(__MMI_TOUCH_SCREEN__)
static void mmi_camera_update_osd_touch_icon(void);
static void mmi_camera_touch_scr_pen_down_hdlr(mmi_pen_point_struct pos);
static void mmi_camera_touch_scr_pen_up_hdlr(mmi_pen_point_struct pos);
static void mmi_camera_touch_scr_pen_move_hdlr(mmi_pen_point_struct pos);
//static BOOL mmi_camera_touch_scr_hit_test(S32 pos_x, S32 pos_y, camera_ui_touch_struct *touch_obj);
#endif /* defined(__CAMERA_FEATURE_TOUCH_SCREEN__) && defined(__MMI_TOUCH_SCREEN__) */ 



#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__

////////////////////////////////////////////////////////
static void mmi_camera_watchdog_start(camera_watchdog_struct *pwatchdog);
static void mmi_camera_watchdog_create(camera_watchdog_struct *pwatchdog, S32 delay, void (*timeout)(void));
static void mmi_camera_watchdog_delete(camera_watchdog_struct *pwatchdog);
static void mmi_camera_watchdog_stop(camera_watchdog_struct *pwatchdog);
static void mmi_camera_watchdog_restart(camera_watchdog_struct *pwatchdog);
static void mmi_camera_app_watchdog_callback(void);
static void mmi_camera_delete_confirm_watchdog_timer_callback(void);


#ifndef __MMI_CAMERA_SLIM__

#define MMI_CAMERA_CREATE_WATCHDOGS()   \
	do {                                \
	mmi_camera_watchdog_create(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP], MMI_CAMERA_APP_WATCHDOG_DURATION, \
	mmi_camera_app_watchdog_callback);           \
	mmi_camera_watchdog_create(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM], MMI_CAMERA_DELETE_CONFIRM_WATCHDOG_DURATION, \
	mmi_camera_delete_confirm_watchdog_timer_callback);     \
	}while(0);

#define MMI_CAMERA_DELETE_WATCHDOGS()   \
	do {                                \
	mmi_camera_watchdog_delete(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);              \
	mmi_camera_watchdog_delete(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);   \
	}while(0);
#define MMI_CAMERA_RESTART_APP_WATCHDOG()   mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP])
#define MMI_CAMERA_STOP_APP_WATCHDOG()   mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP])
#define MMI_CAMERA_RESTART_DELCONF_WATCHDOG()   mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM])
#define MMI_CAMERA_STOP_DELCONF_WATCHDOG()   mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM])
#define MMI_CAMERA_STOP_ALL_WATCHDOG() \
	do{ \
	MMI_CAMERA_STOP_APP_WATCHDOG(); \
	MMI_CAMERA_STOP_DELCONF_WATCHDOG(); \
	}while(0);

#define MMI_CAMERA_START_ALL_WATCHDOG() \
	do{ \
	MMI_CAMERA_RESTART_APP_WATCHDOG(); \
	MMI_CAMERA_RESTART_DELCONF_WATCHDOG(); \
	}while(0);

#else //__MMI_CAMERA_SLIM__
static void mmi_camera_delete_watchdogs(void);
static void mmi_camera_create_watchdogs(void);
static void mmi_camera_stop_all_watchdog(void);

#endif // __MMI_CAMERA_SLIM__

#endif /*__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__*/


/* screen snapshot */
#if defined(__CAMERA_OSD_HORIZONTAL__)
static void mmi_camera_config_layer_orientation(void);
static void mmi_camera_check_osd_orientation(void);
#endif
static void mmi_camera_app_mem_stop_callback(void);
#if (defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__))
static void mmi_camera_free_app_mem(void);
#if 0
/* under construction !*/
/* under construction !*/
#endif
#endif
static void mmi_camera_pre_init_app(void);
static void mmi_camera_post_init_app(void);
static void mmi_camera_init_framework(void);
static void mmi_camera_entry_app_screen_internal(void);
#ifdef __MMI_CAMERA_SLIM__
static void mmi_camera_init_title_bar(void);
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
static void mmi_camera_create_osd_layer(void);
#endif
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
static void mmi_camera_create_osd_region_layer(U8 osd_region_id);

static void mmi_camera_create_osd_region_layers();

static void mmi_camera_rotate_osd_region_layer(U8 osd_region_id);

static void mmi_camera_clear_osd_layer(gdi_handle layer_handle);

static void mmi_camera_select_osd_region_layer(U8 osd_region_id);

#endif
static void camera_enter_state(camera_state_enum state);
void mmi_camera_config_osd_layer(gdi_handle handle,U8 rotate_value);
#endif
static void mmi_camera_app_screen(void);
mmi_ret mmi_camera_group_proc(mmi_event_struct *evt);

/**
* Adding functions for operatoer 
****/
#ifdef __MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__
void mmi_camera_switch_to_vdorec_app(void);
void mmi_camera_highlight_to_vdorec_app(void);
#endif /* __MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__ */

void mmi_camera_entry_forward_menu_screen(void);
MMI_BOOL mmi_camera_is_forward_function_ready(void);


void mmi_camera_forward_to_hdlr(void);


#if defined(__MMI_SUBLCD_CAMERA__)
mmi_ret mmi_sublcd_camera_gpio_clam_open_hdlr(mmi_event_struct *evt);
mmi_ret mmi_sublcd_camera_gpio_clam_close_hdlr(mmi_event_struct *evt);
mmi_ret mmi_sublcd_camera_usb_plug_proc(mmi_event_struct *evt);
static void mmi_sublcd_camera_exit_option_screen(void);
static void mmi_sublcd_camera_entry_preview_screen(void);
static void mmi_sublcd_camera_entry_flash_screen(void);
static void mmi_sublcd_camera_flash_highlight_hdlr(S32 idx);
static void mmi_sublcd_camera_exit_flash_screen(void);
static void mmi_sublcd_camera_exit(void);
static void mmi_sublcd_camera_set_flash(void);
void mmi_sublcd_camera_hilight_preview(void);
void mmi_sublcd_camera_hilight_flash(void);
void mmi_sublcd_camera_hilight_flash_option(void);
void mmi_sublcd_camera_hilight_exit(void);
U8 mmi_sublcd_camera_clam_close_event_hdlr(void *ptr);
static void mmi_sublicd_camera_display_error_screen(void);
static void mmi_sublcd_camera_capture(void);
static void mmi_sublcd_camera_preview_start(void);
static void mmi_sublcd_camera_entry_flash_screen_ex(void);
static void mmi_sublcd_camera_entry_preview_screen_ex(void);
static void mmi_sublcd_camera_entry_option_screen_ex(void);
static void mmi_camera_dummy_func(void);
#endif /* __MMI_SUBLCD_CAMERA */

static void mmi_camera_reentry_preview_state(void);
static void mmi_camera_reset_osd_layer(void);
static void mmi_camera_reset_base_layer(void);
#ifdef __MMI_CASCADED_OPTION_MENU__ 
static MMI_BOOL mmi_camera_delete_confirm_option_cmd_hdlr(U16 menu_id);
#endif
void mmi_camera_change_to_largest_img_size(void);
static void mmi_camera_delete_group(void);
MMI_BOOL mmi_camera_entry_app_pre_check(void);

#if defined(__CAMERA_FEATURE_STORAGE__)
static MMI_BOOL mmi_camera_check_storage(void);
#endif


#ifdef __MMI_SUPPORT_ASMV2__
static MMI_RET mmi_camera_register_proc(mmi_event_struct *evt);
#endif

#ifdef __CAMERA_HOTKEY__
static void mmi_camera_hotkey_press(U16 key_code);
#endif
void mmi_camera_init_none_save_setting(void);

typedef struct camera_hotkey_item
{
	S32 hot_key;
	U16 icon_base_id;
	U16 str_base_id;
	U16 str_title_id;
	U16 select_count;
	U16 *val_addr;
	const U8  *map_table;
	void (*mdi_update)(U16 data);
	void (*custom_func)(const struct camera_hotkey_item *pitem);
}camera_hotkey_item_struct;
#if defined(__CAMERA_FEATURE_DRAW_ICON__)
static const camera_hotkey_item_struct* mmi_camera_get_setting_item_by_icon(U16 icon_id);
static void mmi_camera_common_hotkey_func(const camera_hotkey_item_struct *pitem);

#endif
MMI_BOOL mmi_camera_enter_imageviewer_check(void);
/*****************************************************************************
* FUNCTION
*  mmi_camera_load_setting
* DESCRIPTION
*  load camera settings from NVRAM
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
APP_API void mmi_camera_load_setting(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S16 error;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* if setting is already loaded from NVRAM, it is already exist in memory, do not loaded again */
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_LOAD_SETTING);
	if (!g_camera_cntx.is_setting_loaded)
	{
		ReadRecordSlim(
			NVRAM_EF_CAMERA_SETTING_LID,
			1,
			(void*)&g_camera_cntx.setting,
			NVRAM_EF_CAMERA_SETTING_SIZE
			);

		/* first time init */
		if (g_camera_cntx.setting.wb == 0xffff)
		{
			mmi_camera_restore_setting();
		}

		g_camera_cntx.setting.preview_led_value = CAMERA_DEFAULT_PREVIEW_LED_VALUE;
		g_camera_cntx.setting.capture_led_value = CAMERA_DEFAULT_CAPTURE_LED_VALUE;

		/* init preview size based on LCD size */
		mmi_camera_preview_update_capture_size();

		/* load image viewer setting - for storage path */
		mmi_imgview_load_setting();

		ReadValueSlim(NVRAM_CAM_FILENAME_SEQ_NO, &g_camera_cntx.filename_seq_no, DS_SHORT);

		g_camera_cntx.is_setting_loaded = TRUE;		
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_init_none_save_setting
* DESCRIPTION
*  init the none save settins to default value
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_init_none_save_setting(void)
{
	g_camera_cntx.setting.wb = CAMERA_DEFAULT_SETTING_WB;
	g_camera_cntx.setting.flash = CAMERA_DEFAULT_SETTING_FLASH;
	g_camera_cntx.setting.led_highlight = CAMERA_DEFAULT_SETTING_LED_HIGHLIGHT;
#ifdef __CAMERA_FEATURE_SHUTTER_SOUND__
	g_camera_cntx.setting.shutter_sound = CAMERA_DEFAULT_SETTING_SHUTTER_SOUND;
#endif    
	g_camera_cntx.setting.ev = CAMERA_DEFAULT_SETTING_EV;
	g_camera_cntx.setting.night = CAMERA_DEFAULT_SETTING_NIGHT;
	g_camera_cntx.setting.closeup = CAMERA_DEFAULT_SETTING_CLOSEUP;
	g_camera_cntx.setting.banding = CAMERA_DEFAULT_SETTING_BANDING;
	g_camera_cntx.setting.contrast = CAMERA_DEFAULT_SETTING_CONTRAST;

	g_camera_cntx.setting.zoom_idx = CAMERA_DEFAULT_SETTING_ZOOM_IDX;
	g_camera_cntx.setting.effect = CAMERA_DEFAULT_SETTING_EFFECT;
	g_camera_cntx.setting.add_frame = CAMERA_DEFAULT_SETTING_ADD_FRAME;
	g_camera_cntx.setting.add_frame_tileshot = CAMERA_DEFAULT_SETTING_ADD_FRAME;
	g_camera_cntx.setting.add_frame_color_idx = CAMERA_DEFAULT_SETTING_ADD_FRAME;

	g_camera_cntx.setting.cont_shot = CAMERA_DEFAULT_SETTING_CONT_SHOT;
	g_camera_cntx.contshot_backup = g_camera_cntx.setting.cont_shot;

	g_camera_cntx.setting.delay_timer = CAMERA_DEFAULT_SETTING_DELAY_TIMER;

	g_camera_cntx.setting.iso = CAMERA_DEFAULT_SETTING_ISO;
	g_camera_cntx.setting.ae_meter = CAMERA_DEFAULT_SETTING_AE_METER;
	g_camera_cntx.setting.af_meter = CAMERA_DEFAULT_SETTING_AUTOFOCUS;
	g_camera_cntx.setting.af_mode = 0;
	g_camera_cntx.setting.dsc_mode = CAMERA_DEFAULT_SETTING_DSC_MODE;

	g_camera_cntx.is_hide_osd = FALSE;

#ifdef __CAMERA_FEATURE_XENON_FLASH__
	g_camera_cntx.setting.flash = CAMERA_SETTING_FLASH_OFF;
	g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_OFF;    
#endif

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_get_camera_banding
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  U16 OUT camera banding 
*****************************************************************************/
U8 mmi_camera_get_camera_banding(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_load_setting();
	return camera_banding_command_map[g_camera_cntx.setting.banding];
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_hilight_app
* DESCRIPTION
*  app menu item hilight hdlr
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
SYS_CALLBACK void mmi_camera_hilight_app(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	SetLeftSoftkeyFunction(mmi_camera_lauch, KEY_EVENT_UP);
	SetCenterSoftkeyFunction(mmi_camera_lauch, KEY_EVENT_UP);
#ifndef __MMI_WGUI_DISABLE_CSK__
	ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_init_app
* DESCRIPTION
*  nit camera application
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_init_app(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* print trace Info */
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	U32 i;
#endif
#ifdef __MMI_AP_DCM_CAMIMGV__
	mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_CAMIMGV);
#endif
	CAMERA_TRACE_FUNC_INIT();
	/* initialize camera app-based memory */
#ifdef __MMI_CAMERA_SLIM__
	applib_mem_ap_register(APPLIB_MEM_AP_ID_CAMERA,STR_ID_CAMERA_APP_NAME 
		,0 ,mmi_camera_app_mem_stop_callback);
#else
	applib_mem_ap_register(APPLIB_MEM_AP_ID_CAMERA,STR_ID_CAMERA_APP_NAME 
		,IMG_ID_CAMERA_APP_ICON ,mmi_camera_app_mem_stop_callback);
#endif

	/* init context */
	g_camera_cntx.app_state = CAMERA_STATE_EXIT;
	g_camera_cntx.app_prev_state = CAMERA_STATE_EXIT;
	g_camera_cntx.app_next_state = CAMERA_STATE_EXIT;

	g_camera_cntx.is_force_self_capture = FALSE;
	g_camera_cntx.is_setting_loaded = FALSE;
	g_camera_cntx.is_mainlcd_resource = FALSE;
	
#ifdef __MMI_SUBLCD__
	g_camera_cntx.is_sublcd_display = FALSE;
#endif

	g_camera_cntx.is_fullscreen = FALSE;
	g_camera_cntx.is_dis_clam_open = FALSE;
	g_camera_cntx.is_cat65_show = FALSE;
	g_camera_cntx.is_multi_sound_open = FALSE;
	g_camera_cntx.is_continue_capture = FALSE;
	g_camera_cntx.is_audio_finished = TRUE;
	g_camera_cntx.is_hide_osd = FALSE;
	g_camera_cntx.is_enable_PQ = FALSE;
	/* for External Request */
	g_camera_cntx.external_request_mode = MMI_CAMERA_EXTERNAL_MODE_OFF;
	g_camera_cntx.is_in_fast_forward = FALSE;

	g_camera_cntx.osd_layer_handle = GDI_LAYER_EMPTY_HANDLE;
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	for(i = 0; i < CAMERA_OSD_REGION_MAX; i++)
	{
		g_camera_cntx.osd_layer_region_handle[i] = GDI_LAYER_EMPTY_HANDLE;
		g_camera_cntx.osd_idp_layer_region_handle[i] = GDI_LAYER_EMPTY_HANDLE;
	}


#endif
	g_camera_cntx.sublcd_base_layer_handle = GDI_LAYER_EMPTY_HANDLE;
	g_camera_cntx.preview_layer_handle = GDI_LAYER_EMPTY_HANDLE;

#if defined(__CAMERA_OSD_HORIZONTAL__)
	g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_270;
#else /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
	g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_0;
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	g_camera_cntx.active_camera_osd_ptr = &g_camera_skin_cntx;
	g_camera_cntx.osd_data.show_hint = g_camera_skin_cntx.hint_box.is_show;

	g_camera_cntx.osd_UI_device_width = LCD_WIDTH;
	g_camera_cntx.osd_UI_device_height = LCD_HEIGHT;

	mmi_camera_preview_update_capture_size();
	g_camera_cntx.multi_sound_dummy_bg = 0;
#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	
	g_camera_cntx.multi_sound_capture0 = 0;
	g_camera_cntx.multi_sound_capture1 = 0;
	g_camera_cntx.multi_sound_capture2 = 0;
	
#endif // __CAMERA_FEATURE_CONT_SHOT_BURST__
	

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	g_camera_cntx.image_size_before_burst = CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX;
#endif 
	/*
	memset(g_camera_cntx.hint1_buf, 0, CAMERA_HINT_BUF_SIZE);
	memset(g_camera_cntx.hint2_buf, 0, CAMERA_HINT_BUF_SIZE);
	*/
	*((U16*)(g_camera_cntx.hint1_buf)) = 0;
	*((U16*)(g_camera_cntx.hint2_buf)) = 0;


#if defined(__MMI_TOUCH_SCREEN__)
	mmi_camera_update_osd_touch_icon();
#endif

#ifdef __CAMERA_FEATURE_XENON_FLASH__
	g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_OFF;
#endif

	g_camera_cntx.cur_gid = GRP_ID_INVALID;
	g_camera_cntx.gdi_layer_handle = GDI_NULL_HANDLE;

#ifdef __CAMERA_FEATURE_ROTATE_OSD_SELF__
	g_camera_cntx.app_mem_pool = NULL;
#endif

	g_camera_cntx.cbm_app_id = 0xff;

#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	#if defined(__MTK_TARGET__)
	resz_cp_ESD_timeout_timer = kal_create_timer("MDP_ESD_CP_CRZ_TIMEOUT"); 
    #endif
#endif

#ifdef __MMI_AP_DCM_CAMIMGV__
	mmi_ap_send_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_CAMIMGV);
#endif


}

/*****************************************************************************
* FUNCTION
*  mmi_camera_lauch
* DESCRIPTION
*  
* PARAMETERS
*   void   
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_lauch()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifdef __MMI_SUPPORT_ASMV2__
	mem_ptr_struct *ptr = (mem_ptr_struct *)mmi_malloc(sizeof(mem_ptr_struct));
#endif
#ifdef __MMI_AP_DCM_CAMIMGV__
	mmi_ap_send_dcm_load_evt(DYNAMIC_CODE_COMPRESS_CAMIMGV);
#endif
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_LAUNCH);
#ifdef __MMI_SUPPORT_ASMV2__
	mmi_frm_app_launch(APP_CAMERA, 0, 0, mmi_camera_register_proc, (void *)ptr, MMI_FRM_APP_SKIP_SIZE_CHECK | MMI_FRM_APP_SKIP_RESVERVE_CHECK);
#else
    mmi_camera_lauch_init();
#endif
}


#if defined( __MMI_SCREEN_LOCK_ANY_TIME__) || defined (__MMI_SCREEN_LOCK_ANY_TIME_WDEVICE__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_notify_screen_lock_hdlr
* DESCRIPTION
*  camera handle screen  lock function.
* PARAMETERS
*  evt     [IN]        The event for lock screen
* RETURNS
*  mmi_ret event handle result
*****************************************************************************/
extern mmi_ret mmi_camera_notify_screen_lock_hdlr(mmi_event_struct *evt)
{

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mmi_scr_locker_pre_lock_evt_struct* lock_event = NULL; 
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (evt->evt_id)
	{
	case EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING:
		{
			lock_event = (mmi_scr_locker_pre_lock_evt_struct*)evt;
			if ((mmi_frm_group_get_active_id()== g_camera_cntx.cur_gid) &&  (NULL != g_camera_cntx.cur_gid))
			{
				if(lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_POWER_KEY)
				{
					return MMI_RET_ERR;
				}
				else if(lock_event->lock_mode == MMI_SCR_LOCKER_LOCK_MODE_AUTO_LOCK)
				{
					return MMI_RET_ERR;
				}
				else
				{
					return MMI_RET_ERR;
				}          			
			}
			break;
		}
	default:
		return MMI_RET_OK;
	}
	return MMI_RET_OK;
}
#endif
#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__)

/*****************************************************************************
* FUNCTION
*  mmi_camera_clam_close_event_hdlr
* DESCRIPTION
*  handle clam close event
* PARAMETERS
*  ptr     [IN]        Message data ptr
* RETURNS
*  void
*****************************************************************************/
U8 mmi_camera_clam_close_event_hdlr_int(kal_uint8 digua_gpio_device)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (digua_gpio_device == EXT_DEV_CLAM_CLOSE)
	{
		g_camera_cntx.is_clam_close = TRUE;
		srv_clam_set_state(EXT_DEV_CLAM_CLOSE);

		/* print debug info */
		CAMERA_TRACE_CLAM_CLOSE_EVENT();

		switch (g_camera_cntx.app_state)
		{
			/* main lcd */
		case CAMERA_STATE_PREVIEW:
		case CAMERA_STATE_COUNTDOWN:
		case CAMERA_STATE_CONTSHOT:
#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
		case CAMERA_STATE_BURSTSHOT:
		case CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM:
		case CAMERA_STATE_BURSTSHOT_SAVING:
#endif
		case CAMERA_STATE_DELETE_DONE:
		case CAMERA_STATE_DELETE_CONFIRM:
		case CAMERA_STATE_TOGGLE_TO_MAIN:
		case CAMERA_STATE_TOGGLE_TO_SUB:
			/* if clam close will not back to idle, goback to previous screen */
#ifndef __MMI_CLAMCLOSE_BACK2IDLE__
			mmi_frm_scrn_close_active_id();
#endif 

			return FALSE;   /* pass this interrupt to framwork's handler */
			/* sub lcd */
		case CAMERA_STATE_SUB_COUNTDOWN:
		case CAMERA_STATE_SUB_CONTSHOT:
		case CAMERA_STATE_SUB_BURSTSHOT:
		case CAMERA_STATE_SUB_BURSTSHOT_SAVING:
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
			srv_gpio_detect_send_ack(digua_gpio_device);
			return TRUE;    /* block this event - do not call default handler */

		case CAMERA_STATE_SUB_PREVIEW:
#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
			/* stop and restart sublcd preview, will display correcly according to clam close/open */
			mmi_camera_sublcd_preview_stop();

			/* config rotate of preview layer, only ISP_SUPPORT need */
#if defined(ISP_SUPPORT)
			gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
			gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_CLOSE_ROTATE);
			gdi_layer_pop_and_restore_active();
#endif /* defined(ISP_SUPPORT) */ 

			mmi_camera_sublcd_preview_start();
			srv_gpio_detect_send_ack(digua_gpio_device);
			return TRUE;    /* block this event - do not call default handler */
#else /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 
			MMI_ASSERT(0);
			break;
#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

		default:
			MMI_ASSERT(0);  /* make sure all state is handled */
			break;
		}
	}
	else if (digua_gpio_device == EXT_DEV_CLAM_OPEN)
	{
		g_camera_cntx.is_clam_close = FALSE;
		srv_clam_set_state(EXT_DEV_CLAM_OPEN);

		/* print debug info */
		CAMERA_TRACE_CLAM_OPEN_EVENT();

		switch (g_camera_cntx.app_state)
		{
			/* main lcd */
		case CAMERA_STATE_PREVIEW:
		case CAMERA_STATE_COUNTDOWN:
		case CAMERA_STATE_CONTSHOT:
#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
		case CAMERA_STATE_BURSTSHOT:
		case CAMERA_STATE_BURSTSHOT_SAVING:
#endif
		case CAMERA_STATE_DELETE_DONE:
		case CAMERA_STATE_TOGGLE_TO_MAIN:
		case CAMERA_STATE_TOGGLE_TO_SUB:
			/* clam open do nothing */
			return FALSE;   /* pass this interrupt to framwork's handler */

		case CAMERA_STATE_DELETE_CONFIRM:
			/* 
			* this may happened when user capture tile image on sub. and all images
			* are captured and enter save confirm state 
			*/
			if (g_camera_cntx.is_dis_clam_open)
			{
				/* block this event - do not call default handler */
				g_camera_cntx.is_dis_clam_open = FALSE;
				srv_gpio_detect_send_ack(digua_gpio_device);
				return TRUE;
			}
			else
			{
				return FALSE;
			}

			/* sub lcd */
		case CAMERA_STATE_SUB_COUNTDOWN:
		case CAMERA_STATE_SUB_CONTSHOT:
		case CAMERA_STATE_SUB_BURSTSHOT:
		case CAMERA_STATE_SUB_BURSTSHOT_SAVING:
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
			srv_gpio_detect_send_ack(digua_gpio_device);
			return TRUE;    /* block this event - do not call default handler */

		case CAMERA_STATE_SUB_PREVIEW:
#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
			/* stop and restart sublcd preview, will display correcly according to clam close/open */
			mmi_camera_sublcd_preview_stop();

			/* config rotate of preview layer, only ISP_SUPPORT need */
#if defined(ISP_SUPPORT)
			gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
			gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_OPEN_ROTATE);
			gdi_layer_pop_and_restore_active();
#endif /* defined(ISP_SUPPORT) */ 

			mmi_camera_sublcd_preview_start();
			srv_gpio_detect_send_ack(digua_gpio_device);
			return TRUE;    /* block this event - do not call default handler */
#else /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 
			MMI_ASSERT(0);
			break;
#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

		default:
			MMI_ASSERT(0);  /* make sure all state is handled */
			break;
		}
	}


	/* return false means will pass this interrut to default handler */
	return FALSE;
}

static mmi_ret mmi_camera_clam_close_event_hdlr(mmi_event_struct *evt)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mmi_frm_pre_post_protocol_event_struct *pevt = (mmi_frm_pre_post_protocol_event_struct *)evt;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if(pevt->message->msg_id == MSG_ID_MMI_EQ_GPIO_DETECT_IND)
	{
		mmi_eq_gpio_detect_ind_struct *ind = (mmi_eq_gpio_detect_ind_struct *)pevt->message->local_para_ptr;
		if(mmi_camera_clam_close_event_hdlr_int(ind->gpio_device)){
			return MMI_RET_STOP_PROTOCOL;
		}
	}

	return MMI_RET_OK;

}

#endif /* defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) */ 


#ifdef __MMI_AP_DCM_CAMIMGV__
#pragma arm section code = "DYNAMIC_CODE_CAMIMGV_ROCODE", rodata = "DYNAMIC_CODE_CAMIMGV_RODATA"
#endif



#if defined(__MMI_TOUCH_SCREEN__)
static void mmi_camera_touch_feedback_action(void)
{
	gui_touch_feedback_play(GUI_TOUCH_FEEDBACK_DOWN);
}
#endif

static void mmi_camera_resume_blt(void)
{
	mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_PRIMITIVE);
}

static void mmi_camera_compute_preview_size(U16 img_w, U16 img_h, U16 *prev_w, U16 *prev_h)
{
	U16 scrn_w = LCD_WIDTH > MDI_CAMERA_MAX_HW_LAYER_SIZE ? MDI_CAMERA_MAX_HW_LAYER_SIZE : LCD_WIDTH;
	U16 scrn_h = LCD_HEIGHT > MDI_CAMERA_MAX_HW_LAYER_SIZE ? MDI_CAMERA_MAX_HW_LAYER_SIZE : LCD_HEIGHT;
	S32 x, y, w, h;

#ifdef HORIZONTAL_CAMERA
	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270){
		U16 temp = scrn_w;
		scrn_w = scrn_h;
		scrn_h = temp;
	}

#endif
	gdi_util_fit_box(
		GDI_UTIL_MODE_LONG_SIDE_FIT,
		scrn_w,
		scrn_h,
		img_w,
		img_h,
		&x,
		&y,
		&w,
		&h);

	*prev_w = ((U16)w) & (~0x1);
	*prev_h = ((U16)h) & (~0x1);
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_COMPUTE_PREVIEW_SIZE,scrn_w,scrn_h,w,h,g_camera_cntx.image_width,g_camera_cntx.image_height);

}

static void mmi_camera_update_img_size(void)
{
	const struct img_size_map *pitem = &g_camera_img_size_map[g_camera_cntx.setting.image_size];
	g_camera_cntx.image_width = pitem->img_w;
	g_camera_cntx.image_height = pitem->img_h;
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_UPDATE_IMG_SIZE,g_camera_cntx.image_width,g_camera_cntx.image_height);

	/*update osd rotate value */
#if defined(__MMI_CAMERA_QVGA_WALLPAPER_ON_WQVGA_LCM__) || defined(__MMI_CAMERA_QVGA_WALLPAPER_ON_WQVGA_LCM_FOR_MODIS__)
	if (g_camera_cntx.image_width < g_camera_cntx.image_height)
#else
	if ((g_camera_cntx.image_width == LCD_WIDTH) && (g_camera_cntx.image_height == LCD_HEIGHT))
#endif
	{
		g_camera_cntx.is_fullscreen = TRUE;

#if defined(__CAMERA_OSD_HORIZONTAL__)
		g_camera_cntx.osd_data.previous_osd_rotate = CAMERA_DISPLAY_ROTATE_RESET;
		g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_0;
#endif 
	}
	else
	{
#if defined(__CAMERA_OSD_HORIZONTAL__)
		if (g_camera_cntx.is_fullscreen == TRUE)
		{
			g_camera_cntx.osd_data.previous_osd_rotate = g_camera_cntx.osd_data.osd_rotate;
			g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_270;
		}

		if(g_camera_cntx.image_width <= g_camera_cntx.image_height && LCD_WIDTH <= LCD_HEIGHT
			|| g_camera_cntx.image_width > g_camera_cntx.image_height && LCD_WIDTH > LCD_HEIGHT){
				g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_0;
		}else{
			g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_270;
		}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
		g_camera_cntx.is_fullscreen = FALSE;
	}


#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__)
	if (g_camera_cntx.setting.cont_shot == CAMERA_SETTING_CONT_SHOT_BURST)
	{
		g_camera_cntx.osd_data.previous_osd_rotate = CAMERA_DISPLAY_ROTATE_RESET;
		g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_270;
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) */     
	mmi_camera_compute_preview_size(pitem->img_w, pitem->img_h, 
		&g_camera_cntx.preview_width, &g_camera_cntx.preview_height);
}

/* Sub LCD code start from here*/
#if defined(__MMI_SUBLCD_CAMERA__)

mmi_ret mmi_sublcd_camera_gpio_clam_open_hdlr(mmi_event_struct *evt)
{
	if (mmi_sublcd_camera_is_previewing())
		mmi_sublcd_camera_exit_preview_screen();

	if(mmi_sublcd_camera_delete_screen_if_present())
		mmi_frm_scrn_close_active_id();

	return MMI_RET_OK;
}

mmi_ret mmi_sublcd_camera_gpio_clam_close_hdlr(mmi_event_struct *evt)
{
	if (mmi_idle_is_active() && mmi_bootup_is_sim_valid() && !mmi_scr_locker_is_locked())
	{
		SetKeyDownHandler(mmi_sublcd_camera_entry_option_screen, CAMERA_SHORTCUT_KEY);
	}

	return MMI_RET_OK;
}


#ifdef __MMI_USB_SUPPORT__
mmi_ret mmi_sublcd_camera_usb_plug_proc(mmi_event_struct *evt)
{

	srv_usb_mmi_notify_action_enum act = (srv_usb_mmi_notify_action_enum)evt->user_data;

	if (evt->evt_id == EVT_ID_USB_MMI_NOTIFY &&
		act == SRV_USB_MMI_NOTIFY_REMOVED)          //plug out
	{
		if (mmi_sublcd_camera_is_previewing())
			mmi_sublcd_camera_exit_preview_screen();

		if(mmi_sublcd_camera_delete_screen_if_present())
			mmi_frm_scrn_close_active_id();
	}
	else if (evt->evt_id == EVT_ID_USB_PERMIT_CFG)  //plug in
	{
		if (mmi_sublcd_camera_is_previewing())
			mmi_sublcd_camera_exit_preview_screen();

		if(mmi_sublcd_camera_delete_screen_if_present())
			mmi_frm_scrn_close_active_id();
	}

	return MMI_RET_OK;
}
#endif

static void mmi_sublcd_camera_event_handler(void)
{
	if (mmi_sublcd_camera_is_previewing())
		mmi_sublcd_camera_exit_preview_screen();

	/* resume background audio */
	mdi_audio_resume_background_play();
}


static void mmi_sublcd_camera_capture(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];
	U32 ticks = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	/* this function has nvram access */
	mmi_camera_get_next_filename(buf_filename);

	mmi_camera_commit_filename_seq_no();

	mmi_camera_turn_on_capture_led_highlight();

	g_camera_cntx.is_continue_capture = FALSE;
	g_camera_cntx.last_error = mdi_camera_capture(buf_filename);

	/* play capture sound after capture */
	mmi_camera_capture_play_sound();

	/* restore black background */
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
#endif /* CAMERA_MODULE_WITH_LCD */ 

	mmi_camera_turn_off_led_highlight();

	/* captured, previwing is stopped, change blt layer */
	mmi_camera_sublcd_preview_set_blt_layer(FALSE);

	ClearKeyEvents();
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		FS_Delete((U16*) buf_filename);
		kal_get_time(&ticks);
		while (ticks - g_camera_cntx.multi_sound_tick < 100 || g_camera_cntx.multi_sound_tick - ticks < 100)
		{
			kal_get_time(&ticks);
		}
		//mmi_camera_restore_filename_seq_no();
		DisplaySubLcdPopup(IMG_GLOBAL_ERROR);
		DeleteSubLCDScreen(SCR_ID_CAMERA_SUBLCD_APP);
		ClearInputEventHandler(MMI_DEVICE_KEY);
		return;
	}
	g_camera_cntx.last_error = mdi_camera_save_captured_image();
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		FS_Delete((U16*) buf_filename);
		kal_get_time(&ticks);
		while (ticks - g_camera_cntx.multi_sound_tick < 100 || g_camera_cntx.multi_sound_tick - ticks < 100)
		{
			kal_get_time(&ticks);
		}
		//mmi_camera_restore_filename_seq_no();
		DisplaySubLcdPopup(IMG_GLOBAL_ERROR);
		DeleteSubLCDScreen(SCR_ID_CAMERA_SUBLCD_APP);
		ClearInputEventHandler(MMI_DEVICE_KEY);
		return;
	}
	mmi_sublcd_camera_preview_start();

}

static void mmi_sublcd_camera_preview_start(void)
{
	mdi_camera_setting_struct camera_setting_data;
	mdi_camera_preview_struct camera_preview_data;
	S32 sublcd_width;
	S32 sublcd_height;

#if defined(ISP_SUPPORT)
	/* set correct lcm rotate && config rotate of preview layer, only ISP_SUPPORT need */
	gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
#if defined(CLAM53_DEMO_BB)
	gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_OPEN_ROTATE);
#else
	gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_CLOSE_ROTATE);
#endif
	gdi_layer_pop_and_restore_active();
#endif /* defined(ISP_SUPPORT) */ 

	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_get_dimension(&sublcd_width, &sublcd_height);
	gdi_layer_set_blt_layer(g_camera_cntx.sublcd_base_layer_handle, 0, 0, 0);

#ifdef CAMERA_MODULE_WITH_LCD
	gdi_layer_clear(CAMEAR_BG_TRASN_COLOR);
#endif 
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	/* turn on led highlight */
	mmi_camera_turn_on_preview_led_highlight();


	mdi_camera_load_default_setting(&camera_setting_data);
	camera_setting_data.lcm = MDI_CAMERA_PREVIEW_LCM_SUBLCD;

	camera_setting_data.preview_width = SUBLCD_CAMERA_PREVIEW_WIDTH;
	camera_setting_data.preview_height = SUBLCD_CAMERA_PREVIEW_HEIGHT;
	//camera_setting_data.preview_rotate = CAMERA_PREVIEW_SUBLCD_CLAM_CLOSE_ROTATE;
	//camera_setting_data.lcm_rotate = CAMERA_LCM_SUBLCD_CLAM_CLOSE_ROTATE;

	camera_setting_data.image_width = SUBLCD_CAMERA_CAPTURE_WIDTH;
	camera_setting_data.image_height = SUBLCD_CAMERA_CAPTURE_HEIGHT;

	//    camera_setting_data.continue_capture = g_camera_cntx.is_continue_capture;
	camera_setting_data.xenon_flash_status_callback = NULL;
	/* preview data for preview start */
	camera_preview_data.preview_layer_handle = g_camera_cntx.sublcd_base_layer_handle;
	//camera_preview_data.preview_wnd_offset_x = 0;
	//camera_preview_data.preview_wnd_offset_y = 0;
	//camera_preview_data.preview_wnd_width = sublcd_width;
	//camera_preview_data.preview_wnd_height = sublcd_height;
	camera_preview_data.blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
	camera_preview_data.preview_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
	camera_preview_data.is_lcd_update = TRUE;
	camera_preview_data.src_key_color = CAMEAR_BG_TRASN_COLOR;/* this value is use only CAMERA_MODULE_WITH_LCD */
	camera_preview_data.is_tvout = FALSE;

	/* start preview */
	g_camera_cntx.last_error = mdi_camera_preview_start(
		&camera_preview_data,
		&camera_setting_data,
		NULL);

}
BOOL mmi_sublcd_camera_delete_screen_if_present(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 scrnid;
	BOOL ret = FALSE;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	for(scrnid= SCR_ID_CAMERA_SUBLCD_APP; scrnid <= SCR_ID_CAMERA_SUBLCD_OPTION_FLASH; scrnid++)
	{
		if (IsSubLCDScreenPresent(scrnid))
		{
			DeleteSubLCDScreen(scrnid);
			ret = TRUE;
		}
		else if (GetSubLCActiveScreenId()==scrnid)
			ret = TRUE;
	}

	return ret;
}
static void mmi_sublicd_camera_display_error_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U32 ticks = 0;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	kal_get_time(&ticks);
	while (ticks - g_camera_cntx.multi_sound_tick < 100 || g_camera_cntx.multi_sound_tick - ticks < 100)
	{
		kal_get_time(&ticks);
	}
	DisplaySubLcdPopup(IMG_GLOBAL_ERROR);
	mmi_sublcd_camera_delete_screen_if_present();
}


U8 mmi_sublcd_camera_clam_close_event_hdlr(void *ptr)
{
	return FALSE;
}


static void mmi_sublcd_camera_set_flash(void)
{
	/* off */
	if(g_camera_cntx.cur_select_flash_idx == 1) 
	{
#ifdef __CAMERA_FEATURE_FLASH__
		g_camera_cntx.setting.flash = CAMERA_SETTING_FLASH_OFF;
#endif
#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__
		g_camera_cntx.setting.led_highlight = CAMERA_SETTING_LED_HIGHLIGHT_OFF;
#endif
	}
	else
	{
#ifdef __CAMERA_FEATURE_FLASH__
		g_camera_cntx.setting.flash = CAMERA_SETTING_FLASH_ON;
#endif
#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__
		g_camera_cntx.setting.led_highlight = CAMERA_SETTING_LED_HIGHLIGHT_ON;
#endif
	}
	mmi_camera_store_setting();
	ClearKeyEvents();
	ClearInputEventHandler(MMI_DEVICE_KEY);
	GoBackSubLCDHistory();
}
static void mmi_sublcd_camera_entry_preview_screen(void)
{
	DisplaySubLCDScreen(SCR_ID_CAMERA_SUBLCD_APP, mmi_sublcd_camera_entry_preview_screen_ex, MMI_TRUE);
}
static void mmi_sublcd_camera_entry_preview_screen_ex(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U8 *guiBuffer = NULL;
	U16 cur_storage = 0;
	S32 create_result;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	ExecSubLCDCurrExitHandler();
	ClearInputEventHandler(MMI_DEVICE_KEY);

#ifdef __USB_IN_NORMAL_MODE__
	if (srv_usb_is_in_mass_storage_mode())
	{
		/* in mass storage mode */

		if (srv_usb_check_path_exported((WCHAR*) MMI_IMGVIEW_STORAGE_FILEPATH_PHONE))
		{
			/* phone drive is exported, cant use this app */
			mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */
			return;
		}
	}
#endif /* __USB_IN_NORMAL_MODE__ */ 

	g_camera_cntx.is_sublcd_previewing = TRUE;

	/* turn off 3D sound */
#ifdef __MMI_AUDIO_REVERB_EFFECT__
	g_camera_cntx.is_3d_sound_on = mmi_settings_audio_reverb_get_status();
	if (g_camera_cntx.is_3d_sound_on == TRUE)
	{
		mdi_audio_reverb_turn_off();
	}
#endif /* __MMI_AUDIO_REVERB_EFFECT__ */ 

	/************ init/config framework's environment  ************/

	/* entry full screen app */
	entry_full_screen();

	/* 
	* This is used to solve a very rare situation. When playing a IMELODY 
	* with backlight on/off, and the screen previous to this screen is a 
	* horizontal screen. Before enter this screen, the IMELODY turn off the
	* backlight. While exit previous screen, the layer rotate back to normal
	* size and the content is not correct. So when calling srv_backlight_turn_on, 
	* LCD is in sleepin state and draw wrong content to LCD.
	* So we need to clear the buffer first to avoid this situation.
	*/
	gdi_layer_clear(GDI_COLOR_BLACK);

	/* stop MMI sleep */
	srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

	/* force all playing keypad tone off */
	srv_profiles_stop_tone((srv_prof_tone_enum)GetCurKeypadTone());

	/* disable key pad tone */
	mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);

	/* disalbe align timer  */
	UI_disable_alignment_timers();

	/* stop LED patten */
	srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_STOP);

	/* get sublcd base layer handle */
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_get_base_handle(&g_camera_cntx.sublcd_base_layer_handle);
	gdi_layer_clear(GDI_COLOR_BLACK);
#ifndef __MTK_TARGET__
	{
		S32 lcd_width;
		S32 lcd_height;
		gdi_lcd_get_dimension(&lcd_width, &lcd_height);
		gdi_layer_blt_base_layer(0, 0, lcd_width - 1, lcd_height - 1);
	}
#endif    
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	gdi_lcd_freeze(TRUE);
	/************ init camera app environment ************/

	/* init some flags */
	g_camera_cntx.last_error = MDI_RES_CAMERA_SUCCEED;
	//g_camera_cntx.lcm_rotate = CAMERA_LCM_MAINLCD_ROTATE;

	/* load Setting */
	mmi_camera_load_setting();

	/* allocate storage path buffer */
	g_camera_cntx.storage_filepath = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
	//memset(g_camera_cntx.storage_filepath, 0, SRV_FMGR_PATH_BUFFER_SIZE);
	*((U16*)(g_camera_cntx.storage_filepath)) = 0;
	if (mmi_camera_check_and_restore_valid_drv())
	{
		/* drv is valid, create directory */
		//mmi_imgview_get_storage_file_path(g_camera_cntx.storage_filepath);
		create_result = mmi_imgview_get_storage_file_path((WCHAR*)g_camera_cntx.storage_filepath);

		/* create directory failed */
		if (create_result == FS_WRITE_PROTECTION)
		{
			g_camera_cntx.last_error = CAMERA_ERR_WRITE_PROTECT;

			/* has error - restore to phone */
			mmi_imgview_set_storage((U16)SRV_FMGR_PUBLIC_DRV);
		}
		else if (create_result == FS_DISK_FULL)
		{
			if (cur_storage == SRV_FMGR_PUBLIC_DRV)
			{
				g_camera_cntx.last_error = CAMERA_ERR_PHONE_DISK_FULL;
			}
			else
			{
				/* storage is card */
				g_camera_cntx.last_error = CAMERA_ERR_CARD_DISK_FULL;

				/* has error - restore to phone */
				mmi_imgview_set_storage((U16)SRV_FMGR_PUBLIC_DRV);
			}
		}
		else if (create_result == FS_ROOT_DIR_FULL)
		{
			if (cur_storage == SRV_FMGR_PUBLIC_DRV)
			{
				g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;
			}
			else
			{
				/* storage is card */
				g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;

				/* has error - restore to phone */
				mmi_imgview_set_storage((U16)SRV_FMGR_PUBLIC_DRV);
			}
		}
	}
	else
	{
		g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_NO_DISK;
		mmi_imgview_set_storage_not_ready();
	}

	guiBuffer = mmi_frm_scrn_get_gui_buf(g_camera_cntx.cur_gid, SCR_ID_CAMERA_SUBLCD_APP);
	/* each time newly enter camera, zoom will be reset to default */
	if (!guiBuffer)
	{
		g_camera_cntx.setting.zoom_idx = CAMERA_DEFAULT_SETTING_ZOOM_IDX;
	}

	/* power on and init hardware module */
	if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
	{
		g_camera_cntx.last_error = mdi_camera_power_on(APP_CAMERA);
	}


	/************ enter next state ************/
	/* entry preview */
	if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)  /* no error, if has error, will enter main then show error popup */
	{
		/* set key handler */

		/* preview start */
		mmi_sublcd_camera_preview_start();

		/* check if preview function has error */
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			mmi_sublicd_camera_display_error_screen();
			return;
		}
	}
	else
	{
		mmi_sublicd_camera_display_error_screen();
		return;
	}

	SetKeyUpHandler(mmi_sublcd_camera_capture, KEY_CAMERA);
	SetKeyLongpressHandler(mmi_frm_scrn_close_active_id, KEY_CAMERA);
	SetSubLCDExitHandler(mmi_sublcd_camera_exit_preview_screen);
	ClearKeyEvents();
}


BOOL mmi_sublcd_camera_is_previewing(void)
{
	return g_camera_cntx.is_sublcd_previewing;
}
void mmi_sublcd_camera_exit_preview_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (!IsSubLCDScreenPresent(SCR_ID_CAMERA_SUBLCD_APP))
	{
		SubLCDHistoryNode SubLCDHistory;

		SubLCDHistory.entryFuncPtr = mmi_sublcd_camera_entry_preview_screen_ex;
		AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_CAMERA_SUBLCD_APP);
	}


	/* turn off led highlight */
	mmi_camera_turn_off_led_highlight();

	/* stop previewing */
	mmi_camera_sublcd_preview_stop();

	/* turn on/of 3D sound */
#ifdef __MMI_AUDIO_REVERB_EFFECT__
	if (g_camera_cntx.is_3d_sound_on == TRUE)
	{
		mdi_audio_reverb_turn_on();
	}
#endif /* __MMI_AUDIO_REVERB_EFFECT__ */ 

	/* shut down camera */
	mdi_camera_power_off();

	/* resume alignment timer */
	UI_enable_alignment_timers();

	/* resume LED patten */
	srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_START);

	/* let MMI can sleep */
	srv_backlight_turn_off();


	/* re-enable keypad tone */
	mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);

	/* free buffer */
	gui_free(g_camera_cntx.storage_filepath);
	g_camera_cntx.storage_filepath = NULL;

	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	gdi_lcd_freeze(FALSE);

	gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
	gdi_layer_set_rotate(CAMERA_LCM_ROTATE_0);
	gdi_layer_pop_and_restore_active();

	/* store camera setting back to NVRAM */
	mmi_camera_store_setting();

	g_camera_cntx.is_sublcd_previewing = FALSE;
}
/*****************************************************************************
* FUNCTION
*  mmi_camera_add_frame_highlight_hdlr
* DESCRIPTION
*  add frame highlight handler
* PARAMETERS
*  idx     [IN]        Highlight index
* RETURNS
*  void
*****************************************************************************/
static void mmi_sublcd_camera_flash_highlight_hdlr(S32 idx)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.cur_select_flash_idx= idx;
}

static void mmi_sublcd_camera_entry_flash_screen(void)
{
	DisplaySubLCDScreen(SCR_ID_CAMERA_SUBLCD_OPTION_FLASH, mmi_sublcd_camera_entry_flash_screen_ex, MMI_TRUE);
}
static void mmi_sublcd_camera_entry_flash_screen_ex(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 ItemList[16];
	U16 ItemIcons[16];
	U16 nItems;
	U8 *guiBuffer;
	U8 *PopUpList[32];
	S32 i;
	S32 hilight_item = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	ExecSubLCDCurrExitHandler();

	mmi_camera_load_setting();
#if defined(__CAMERA_FEATURE_FLASH__) 
	if (g_camera_cntx.setting.flash == CAMERA_SETTING_FLASH_OFF)
		hilight_item = 1;
	else 
		hilight_item = 0;
#elif defined(__CAMERA_FEATURE_LED_HIGHLIGHT__)
	if (g_camera_cntx.setting.led_highlight == CAMERA_SETTING_LED_HIGHLIGHT_OFF )
		hilight_item = 1;
	else 
		hilight_item = 0;
#endif

	ClearInputEventHandler(MMI_DEVICE_KEY);

	guiBuffer = mmi_frm_scrn_get_gui_buf(g_camera_cntx.cur_gid, SCR_ID_CAMERA_SUBLCD_OPTION_FLASH);
	nItems = GetNumOfChild_Ext(MENU_ID_CAMERA_SUBLCD_FLASH);
	GetSequenceStringIds_Ext(MENU_ID_CAMERA_SUBLCD_FLASH, ItemList);
	SetParentHandler(MENU_ID_CAMERA_SUBLCD_FLASH);

	RegisterHighlightHandler(mmi_sublcd_camera_flash_highlight_hdlr);

	for (i = 0; i < nItems; i++)
	{
		PopUpList[i] = NULL;
		ItemIcons[i] = IMG_GLOBAL_L1 + i;
	}

	ConstructHintsList(MENU_ID_CAMERA_SUBLCD_FLASH, PopUpList);

	/* need to register clam open/close handler */

	ShowCategory314Screen(
	#if defined(__CAMERA_FEATURE_FLASH__)
		(U8*) GetString(STR_ID_CAMERA_FLASH),
	#else
	     NULL,
	#endif
		MAIN_MENU_TITLE_MULTIMEDIA_ICON,
		nItems,
		ItemList,
		ItemIcons,
		(U8 **) PopUpList,
		hilight_item,
		guiBuffer);

	SetKeyUpHandler(mmi_sublcd_camera_set_flash, KEY_CAMERA);
	SetSubLCDExitHandler(mmi_sublcd_camera_exit_flash_screen);

}
static void mmi_sublcd_camera_exit(void)
{
	mmi_frm_scrn_close_active_id();
	ClearKeyEvents();
}

static void mmi_sublcd_camera_exit_flash_screen(void)
{
	if (!IsSubLCDScreenPresent(SCR_ID_CAMERA_SUBLCD_OPTION_FLASH))
	{
		SubLCDHistoryNode SubLCDHistory;

		SubLCDHistory.entryFuncPtr = mmi_sublcd_camera_entry_flash_screen_ex;
		AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_CAMERA_SUBLCD_OPTION_FLASH);
	}
	ExitCategory314Screen();
}


void mmi_sublcd_camera_hilight_preview(void)
{
	SetKeyDownHandler(mmi_camera_dummy_func, KEY_CAMERA);
	SetKeyUpHandler(mmi_sublcd_camera_entry_preview_screen, KEY_CAMERA);
}


void mmi_sublcd_camera_hilight_flash(void)
{
	SetKeyDownHandler(mmi_camera_dummy_func, KEY_CAMERA);
	SetKeyUpHandler(mmi_sublcd_camera_entry_flash_screen, KEY_CAMERA);
}


void mmi_sublcd_camera_hilight_flash_option(void)
{
	SetKeyDownHandler(mmi_camera_dummy_func, KEY_CAMERA);
	SetKeyUpHandler(mmi_sublcd_camera_set_flash, KEY_CAMERA);
}


void mmi_sublcd_camera_hilight_exit(void)
{
  SetKeyDownHandler(mmi_camera_dummy_func, KEY_CAMERA);
  SetKeyUpHandler(mmi_sublcd_camera_exit, KEY_CAMERA);
}


void mmi_sublcd_camera_entry_option_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_BOOL entry_ret;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	/* stop bg music */
	mdi_audio_suspend_background_play();

	/* for hiding audioplayr title */
	if (mmi_idle_is_active() == TRUE)
		mmi_idle_display();

	if (mmi_frm_group_is_present(g_camera_cntx.cur_gid))
	{
		mmi_frm_group_close(g_camera_cntx.cur_gid);   
	}
	/*
	g_camera_cntx.cur_gid = mmi_frm_group_create (GRP_ID_ROOT,  SCR_ID_GROUP_CAMERA_SUBLCD, mmi_camera_group_proc, NULL);
	mmi_frm_group_enter(g_camera_cntx.cur_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);
	*/
	g_camera_cntx.cur_gid = mmi_frm_group_create_ex(GRP_ID_ROOT,  SCR_ID_GROUP_CAMERA_SUBLCD, mmi_camera_group_proc, NULL, MMI_FRM_NODE_SMART_CLOSE_FLAG);

	entry_ret = mmi_frm_scrn_enter (g_camera_cntx.cur_gid, SCR_ID_CAMERA_SUBLCD_OPTION, mmi_camera_resume_blt, (mmi_proc_func)mmi_sublcd_camera_event_handler, MMI_FRM_UNKNOW_SCRN);
	if (!entry_ret)
	{
		return;
	}
	mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);

	ShowCategoryDummyScreen();
	DisplaySubLCDScreen(SCR_ID_CAMERA_SUBLCD_OPTION, mmi_sublcd_camera_entry_option_screen_ex, MMI_TRUE);
}

void mmi_sublcd_camera_entry_option_screen_ex(void)
{   
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 ItemList[16];
	U16 ItemIcons[16];
	U16 nItems;
	U8 *guiBuffer;
	U8 *PopUpList[32];
	S32 i;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	ExecSubLCDCurrExitHandler();

#ifndef __CAMERA_FEATURE_FLASH__
	mmi_frm_hide_menu_item(MENU_ID_CAMERA_SUBLCD_FLASH);
#endif

	guiBuffer = mmi_frm_scrn_get_gui_buf(g_camera_cntx.cur_gid, SCR_ID_CAMERA_SUBLCD_OPTION);
	nItems = GetNumOfChild_Ext(MENU_ID_CAMERA_SUBLCD_OPTION);
	GetSequenceStringIds_Ext(MENU_ID_CAMERA_SUBLCD_OPTION, ItemList);
	GetSequenceImageIds_Ext(MENU_ID_CAMERA_SUBLCD_OPTION, ItemIcons);
	SetParentHandler(MENU_ID_CAMERA_SUBLCD_OPTION);

	RegisterHighlightHandler(ExecuteCurrHiliteHandler);

	for (i = 0; i < nItems; i++)
	{
		PopUpList[i] = NULL;
		ItemIcons[i] = IMG_GLOBAL_L1 + i;
	}

	ConstructHintsList(MENU_ID_CAMERA_SUBLCD_OPTION, PopUpList);

	/* need to register clam open/close handler */

	ShowCategory314Screen(
		(U8*) GetString(STR_GLOBAL_OPTIONS),
		MAIN_MENU_TITLE_MULTIMEDIA_ICON,
		nItems,
		ItemList,
		ItemIcons,
		(U8 **) PopUpList,
		0,
		guiBuffer);

	SetKeyLongpressHandler(mmi_sublcd_camera_exit, KEY_CAMERA);
	ClearKeyEvents();    
	SetSubLCDExitHandler(mmi_sublcd_camera_exit_option_screen);

}

static void mmi_sublcd_camera_exit_option_screen(void)
{
	if (!IsSubLCDScreenPresent(SCR_ID_CAMERA_SUBLCD_OPTION))
	{
		SubLCDHistoryNode SubLCDHistory;

		SubLCDHistory.entryFuncPtr = mmi_sublcd_camera_entry_option_screen_ex;
		AddSubLCDHistoryWithScrID(&SubLCDHistory, SCR_ID_CAMERA_SUBLCD_OPTION);
	}
	ExitCategory314Screen();
}
#endif /* __MMI_CAMERA_SUBLCD__ */

/* main LCD code start from here*/
/***************************************************************************
*
*  Settings / File Path / Storage handling                                                     
*
***************************************************************************/

/*****************************************************************************
* FUNCTION
*  mmi_camera_check_and_restore_valid_drv
* DESCRIPTION
*  Check if desired path is ready or not. If not, will restore to valid path.
* PARAMETERS
*  void
* RETURNS
* BOOL
*****************************************************************************/
static BOOL mmi_camera_check_and_restore_valid_drv(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 storage;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	storage = mmi_imgview_get_storage();

	if (FS_NO_ERROR == FS_GetDevStatus(storage ,FS_MOUNT_STATE_ENUM))
	{
		return TRUE;
	}

		return FALSE;
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_store_setting
* DESCRIPTION
*  store camera settings to NVRAM
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
MOD_API void mmi_camera_store_setting(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S16 error;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	WriteRecordSlim(NVRAM_EF_CAMERA_SETTING_LID, 1, (void*)&g_camera_cntx.setting, NVRAM_EF_CAMERA_SETTING_SIZE);
	WriteValueSlim(NVRAM_CAM_FILENAME_SEQ_NO, &g_camera_cntx.filename_seq_no, DS_SHORT);
}

#ifdef __CAMERA_FEATURE_RESTORE_DEFAULT__

/*****************************************************************************
* FUNCTION
*  mmi_camera_restore_factory
* DESCRIPTION
*  restore camera setting to default value
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
MOD_API void mmi_camera_restore_factory(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	mmi_frm_reset_record(NVRAM_RESET_CERTAIN, 0, NVRAM_EF_CAMERA_SETTING_LID, 1, NVRAM_EF_CAMERA_SETTING_SIZE);
	mmi_imgview_set_storage((U16)0xffff);
	mmi_imgview_set_storage_not_ready();
	g_camera_cntx.is_setting_loaded = MMI_FALSE;
	mmi_camera_load_setting();
}
#endif




/*****************************************************************************
* FUNCTION
*  mmi_camera_restore_setting
* DESCRIPTION
*  restore camera setting to default value
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_restore_setting(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_RESTORE_SETTING);
	mmi_camera_init_none_save_setting();

	/* restore the saved settings */
	g_camera_cntx.setting.image_size = CAMERA_DEFAULT_SETTING_IMAGE_SIZE;
	g_camera_cntx.setting.image_qty = CAMERA_DEFAULT_SETTING_IMAGE_QTY;


#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM__

	g_camera_cntx.setting.fx_brightness[0] = CAMERA_DEFAULT_SETTING_BRIGHTNESS;
	g_camera_cntx.setting.fx_brightness[1] = CAMERA_DEFAULT_SETTING_BRIGHTNESS;
	g_camera_cntx.setting.fx_brightness[2] = CAMERA_DEFAULT_SETTING_BRIGHTNESS;
	g_camera_cntx.setting.fx_saturation[0] = CAMERA_DEFAULT_SETTING_SATURATION;
	g_camera_cntx.setting.fx_saturation[1] = CAMERA_DEFAULT_SETTING_SATURATION;
	g_camera_cntx.setting.fx_saturation[2] = CAMERA_DEFAULT_SETTING_SATURATION;
	g_camera_cntx.setting.fx_contrast[0] = CAMERA_DEFAULT_SETTING_CONTRAST;
	g_camera_cntx.setting.fx_contrast[1] = CAMERA_DEFAULT_SETTING_CONTRAST;
	g_camera_cntx.setting.fx_contrast[2] = CAMERA_DEFAULT_SETTING_CONTRAST;
	g_camera_cntx.setting.fx_hue[0] = CAMERA_DEFAULT_SETTING_HUE;
	g_camera_cntx.setting.fx_hue[1] = CAMERA_DEFAULT_SETTING_HUE;
	g_camera_cntx.setting.fx_hue[2] = CAMERA_DEFAULT_SETTING_HUE;

#endif __CAMERA_FEATURE_EFFECT_CUSTOM__


#if defined(__MMI_OP12_CAMERA_VDOREC_CUSTOMIZE__)
	mmi_camera_change_to_largest_img_size();
#if defined(__CAMERA_OSD_HORIZONTAL__)
	g_camera_cntx.osd_data.previous_osd_rotate = CAMERA_DISPLAY_ROTATE_RESET;
	g_camera_cntx.osd_data.osd_rotate = CAMERA_DISPLAY_ROTATE_270;
	g_camera_cntx.capture_path = CAPTURE_FROM_MEMORY;
	g_camera_cntx.img_size_backup = g_camera_cntx.setting.image_size;
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) */ 
#endif

	g_camera_cntx.filename_seq_no = 0xffff;    

	mmi_camera_preview_update_capture_size();

	mmi_camera_store_setting();
}

static void mmi_camera_commit_filename_seq_no(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	//S16 error = 0;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.is_filename_committed = TRUE;
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_get_next_filename
* DESCRIPTION
*  get next file name for jpeg image
* PARAMETERS
*  file_buf_p      [IN]        
*  a(?)            [OUT]       Next filename
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_get_next_filename(CHAR * file_buf_p)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	//#if !defined(__MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__)
#define MMI_CAMERA_MAX_APP_FILE_NAME    (20)
#define MMI_CAMERA_CHAR_COUNT    (26)
	U16 filename_seq_no;
	FS_HANDLE file_handle;
	U16 file_check = 0;
	FS_HANDLE findfirst_hdl;
	FS_DOSDirEntry info;
	U16 app_name_temp[MMI_CAMERA_MAX_APP_FILE_NAME];
	S32 ret;
	U16 m_alpha;
	U8  m_alpha_array_mask[MMI_CAMERA_CHAR_COUNT];
	U8 i;
	//#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/*    
	#ifdef __MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__
	mdi_get_ucs2_filename(file_buf_p,(SRV_FMGR_PATH_MAX_LEN+1),g_camera_cntx.storage_filepath,MDI_NAMING_TYPE_DDMMYY_HHMM,FMGR_TYPE_JPG);
	#else
	*/
	/* get/store sequentail number */
	//ReadValue(NVRAM_CAM_FILENAME_SEQ_NO, &filename_seq_no, DS_SHORT, &error);
	filename_seq_no = g_camera_cntx.filename_seq_no;

	if (filename_seq_no == 0xffff)
	{
		filename_seq_no = 1;    /* init value */
	}
	else
	{
		if (g_camera_cntx.is_filename_committed == TRUE)
			filename_seq_no++;

		g_camera_cntx.is_filename_committed = FALSE;

		if (filename_seq_no > 9999) /* more than 4 digits */
		{
			filename_seq_no = 1;
		}
	}

	while (1)
	{
		kal_wsprintf((WCHAR*)file_buf_p, "%wIMG%04d?.jpg", (kal_wchar*)(g_camera_cntx.storage_filepath), 
			filename_seq_no );

		memset(m_alpha_array_mask, 0, MMI_CAMERA_CHAR_COUNT);
		findfirst_hdl = FS_FindFirst((WCHAR*)file_buf_p, 0, FS_ATTR_DIR, &info, app_name_temp, MMI_CAMERA_MAX_APP_FILE_NAME * ENCODING_LENGTH);

		ret = 0;
		while (ret >= 0 && findfirst_hdl >= 0)
		{
			m_alpha = app_ucs2_towupper((U8)app_name_temp[7]);
			if (m_alpha >= 'A' && m_alpha <= 'Z')
			{
				m_alpha_array_mask[m_alpha - 'A'] = MMI_TRUE;
			}
			ret = FS_FindNextN(
				findfirst_hdl,
				NULL,
				0,
				FS_ATTR_DIR,
				&info,
				(PU16)app_name_temp,
				(MMI_CAMERA_MAX_APP_FILE_NAME + 1) * ENCODING_LENGTH,
				FS_FIND_DEFAULT);
			if (ret < 0)
			{
				FS_FindClose(findfirst_hdl);
			}
		}
		for (i=0 ; i<MMI_CAMERA_CHAR_COUNT; i++)
		{
			if (m_alpha_array_mask[i] == 0)
			{
				kal_wsprintf((WCHAR*)file_buf_p, "%wIMG%04d%c.jpg", (kal_wchar*)(g_camera_cntx.storage_filepath), 
					filename_seq_no, 'A'+i);

				file_handle = FS_Open((U16*) file_buf_p, FS_READ_ONLY);
				if (file_handle < 0)
				{
					g_camera_cntx.filename_seq_no = filename_seq_no;
					FS_FindClose(findfirst_hdl);
					return;
				}
				FS_Close(file_handle);
			}
		}
		filename_seq_no++;
		file_check++;
		/* check if number of files are > 9999 * 26*/
		if (file_check >= 9999)
		{
			FS_FindClose(findfirst_hdl);
			return;
		}
	}

	//#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_display_error_popup
* DESCRIPTION
*  display a popup error message
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_display_error_popup(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_ID_TYPE string_id = 0;
	//mmi_event_notify_enum event_id = MMI_EVENT_DEFAULT;

	U32 ticks;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DISPLAY_ERROR_POPUP,g_camera_cntx.last_error);
	/* if has error */
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		/* wait a short while, let sound finish play, aviod sound cover with popup sound */
		kal_get_time(&ticks);
		while (ticks - g_camera_cntx.multi_sound_tick < 100 || g_camera_cntx.multi_sound_tick - ticks < 100)
		{
			kal_get_time(&ticks);
		}
		ClearInputEventHandler(MMI_DEVICE_KEY);

		string_id = mmi_camera_get_error_string_by_error_enum((S32)g_camera_cntx.last_error);
		
		if ((g_camera_cntx.last_error == CAMERA_ERR_PHONE_DISK_FULL)
			|| (g_camera_cntx.last_error == CAMERA_ERR_CARD_DISK_FULL)
			|| (g_camera_cntx.last_error == CAMERA_ERR_CORRUPT_FAT)
			|| (g_camera_cntx.last_error == CAMERA_ERR_ROOT_DIR_FULL)
			|| (g_camera_cntx.last_error == MDI_RES_CAMERA_ERR_NO_DISK))
		{
			/* if there is only phone storage, we will delete camera screen,
			else we will popup select storage screen for user */
#if defined(__CAMERA_FEATURE_STORAGE__)
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP(string_id, MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
			mmi_camera_display_popup(string_id, MMI_EVENT_FAILURE, (void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif
			return;
#else
			mmi_imgview_set_storage_ready();
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP(string_id, MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
			mmi_camera_display_popup(string_id, MMI_EVENT_FAILURE, (void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif //__MMI_CAMERA_SLIM__
#endif //__CAMERA_FEATURE_STORAGE__
		}
		else if (g_camera_cntx.last_error == MDI_RES_CAMERA_ERR_HW_NOT_READY
			|| g_camera_cntx.last_error == MDI_RES_CAMERA_ERR_MEMORY_NOT_ENOUGH
			|| g_camera_cntx.last_error == MDI_RES_CAMERA_ERR_FAILED)
		{
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP(string_id, MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
			mmi_camera_display_popup(string_id, MMI_EVENT_FAILURE, (void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
		}
		else
		{
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP(string_id, MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
			mmi_camera_display_popup(string_id, MMI_EVENT_FAILURE, (void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif
		}
		g_camera_cntx.last_error = MDI_RES_CAMERA_SUCCEED;  
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_get_error_string_by_error_enum
* DESCRIPTION
*  Get error string by error code.
* PARAMETERS
*  err_code
* RETURNS
*  error string id
*****************************************************************************/
/*static mmi_event_notify_enum mmi_camera_get_error_type_by_error_enum(S32 err_code)
{
return MMI_EVENT_FAILURE;

}
*/


/*****************************************************************************
* FUNCTION
*  mmi_camera_get_error_string_by_error_enum
* DESCRIPTION
*  Get error string by error code.
* PARAMETERS
*  err_code
* RETURNS
*  error string id
*****************************************************************************/
MOD_API MMI_ID_TYPE mmi_camera_get_error_string_by_error_enum(S32 err_code)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	// MMI_ID_TYPE string_id = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	S32 i;
	/*switch (err_code)
	{
	case CAMERA_ERR_BEARER_IS_ACTIVE:
	string_id = STR_ID_CAMERA_NOTIFY_BEARER_IS_ACTIVE;
	break;
	case CAMERA_ERR_BT_IS_WORKING:
	string_id = STR_ID_CAMERA_NOTIFY_BT_IS_WORKING;
	break;
	case MDI_RES_CAMERA_ERR_DISK_FULL:
	string_id = FMGR_FS_DISK_FULL_TEXT;
	break;
	case MDI_RES_CAMERA_ERR_NO_DISK:
	string_id = STR_ID_CAMERA_NOTIFY_NO_MEMORY_CARD;
	break;
	case MDI_RES_CAMERA_ERR_WRITE_PROTECTION:
	string_id = STR_ID_CAMERA_NOTIFY_WRITE_PROTECTION;
	break;
	case MDI_RES_CAMERA_ERR_CAPTURE_FAILED:
	string_id = STR_ID_CAMERA_NOTIFY_CAPTURE_FAILED;
	break;
	case CAMERA_ERR_CARD_DISK_FULL:
	string_id = FMGR_FS_DISK_FULL_TEXT;
	break;
	case CAMERA_ERR_ROOT_DIR_FULL:
	string_id = FMGR_FS_ROOT_DIR_FULL_TEXT;
	break;
	case CAMERA_ERR_WRITE_PROTECT:
	string_id = FMGR_FS_WRITE_PROTECTION_TEXT;
	break;
	case MDI_RES_CAMERA_ERR_HW_NOT_READY:
	string_id = STR_ID_CAMERA_NOTIFY_HW_NOT_READY;
	break;
	case MDI_RES_CAMERA_ERR_MEMORY_NOT_ENOUGH:
	string_id = STR_GLOBAL_NOT_ENOUGH_MEMORY;
	break;
	case CAMERA_ERR_CORRUPT_FAT:
	string_id = FMGR_FS_FAT_ALLOC_ERROR_TEXT;
	break;
	case CAMERA_ERR_PHONE_DISK_FULL:
	// phone disk full, cant create "Photos" folder 
	string_id = FMGR_FS_DISK_FULL_TEXT;
	break;
	case CAMERA_ERR_SAVE_FAIL:
	string_id = STR_ID_CAMERA_NOTIFY_SAVING_FAIL;
	break;
	case MDI_RES_CAMERA_ERR_XENONFLASH_TIMEOUT:
	string_id = STR_ID_CAMERA_NOTIFY_XENON_TIMEOUT;
	break;
	case MDI_RES_CAMERA_ERR_XENONFLASH_LOW_BATTERY:
	string_id = STR_ID_CAMERA_NOTIFY_XENON_LOW_BATTERY;
	break;
	case CAMERA_ERR_CREATE_DIR:
	string_id = STR_ID_CAMERA_NOTIFY_CREATE_DIR_ERR;
	break;
	default:
	string_id = STR_ID_CAMERA_NOTIFY_ERROR;
	break;
	}

	return string_id;
	*/

	for (i = 0; g_camera_error_table[i].error != 0; i++)
	{
		if (g_camera_error_table[i].error == err_code)
		{
			return g_camera_error_table[i].str_id;
		}
	}

	return  STR_ID_CAMERA_NOTIFY_ERROR; 
}

#if defined(__MMI_SUBLCD_CAMERA__)

/*****************************************************************************
* FUNCTION
*  mmi_camera_dummy_func
* DESCRIPTION
*  dummy function
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_dummy_func(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* empty function */
}
#endif

/****************************************************************************
*
*  Camera App                                                   
*
****************************************************************************/
/*****************************************************************************
* FUNCTION
*  mmi_camera_blt
* DESCRIPTION
*  blt api.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_blt(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_BLT);
	gdi_layer_blt_previous(0, 0, LCD_WIDTH - 1, LCD_HEIGHT - 1);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_del_app_sceen_hdlr
* DESCRIPTION
*  camera delete screen callback handler
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static MMI_BOOL mmi_camera_del_app_sceen_hdlr(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* exit camera state */
	if (!CAMERA_STATE_IN(CAMERA_STATE_EXIT))
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
#else
		camera_enter_state(CAMERA_STATE_EXIT);
#endif
	}

#ifdef __CAMERA_FEATURE_ROTATE_OSD_SELF__
	mmi_camera_free_app_mem();
#endif

	/* for External Request */
	if (g_camera_cntx.external_request_mode != MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		if(g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_LARGEST_RESOLUTION)
			g_camera_cntx.setting.image_size = g_camera_cntx.img_size_backup;

		g_camera_cntx.setting.cont_shot = g_camera_cntx.contshot_backup;
		g_camera_cntx.external_request_mode = MMI_CAMERA_EXTERNAL_MODE_OFF;
	}

	/* to rsolve reentry issue of camera -> mms -> camera -> captuer -> back -> back to camera, we need to reserve the last capture file name */
	if (mmi_frm_scrn_get_active_id()!=SCR_ID_CAMERA_EXTERNAL_REQUESET_SCREEN) 
		/*IsScreenPresent(SCR_ID_CAMERA_APP)==TRUE) seems unuseless code, so remove it*/
	{
		/* free buffer */
		if (g_camera_cntx.storage_filepath != NULL)
		{
			gui_free(g_camera_cntx.storage_filepath);
			g_camera_cntx.storage_filepath = NULL;
		}
		if (g_camera_cntx.captured_filepath != NULL)
		{
			gui_free(g_camera_cntx.captured_filepath);
			g_camera_cntx.captured_filepath = NULL;
		}
	}

	return MMI_TRUE;
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_free_app_mem
* DESCRIPTION
*  This function is called to free camera app-based memory
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#ifdef __CAMERA_FEATURE_ROTATE_OSD_SELF__
static void mmi_camera_free_app_mem(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (g_camera_cntx.app_mem_pool != NULL)
	{
		applib_mem_ap_free((void*)g_camera_cntx.app_mem_pool);
		g_camera_cntx.app_mem_pool = NULL;
	}
}
#endif

/*****************************************************************************
* FUNCTION
*  mmi_camera_app_mem_stop_callback
* DESCRIPTION
*  callback function used by applib to free APP-Based Memory
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_app_mem_stop_callback(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* Free Memory */
#ifdef __CAMERA_FEATURE_ROTATE_OSD_SELF__
	mmi_camera_free_app_mem();
#endif

	/*Notify MMI that this application is already stopped */
	applib_mem_ap_notify_stop_finished(APPLIB_MEM_AP_ID_CAMERA,KAL_TRUE);

	mmi_camera_delete_group();
}

#if (defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__))
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef __MMI_CAMERA_SLIM__
/* under construction !*/
#else
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif


MOD_API void mmi_camera_enter_from_cui(mmi_id cur_gid, p_cui_camera_run_struct p_args)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/   
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_FROM_CUI, g_camera_cntx.cur_gid);
	if (mmi_frm_group_is_present(g_camera_cntx.cur_gid))
	{
		mmi_camera_delete_group();
	}

	mmi_camera_load_setting();

	g_camera_cntx.external_request_mode = (mmi_camera_external_mode_enum)(p_args->req_mode);
	g_camera_cntx.contshot_backup = g_camera_cntx.setting.cont_shot;
	g_camera_cntx.setting.cont_shot = 0;

	if (CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
		g_camera_cntx.is_in_fast_forward = TRUE;
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
#else
		camera_enter_state(CAMERA_STATE_EXIT);
#endif
	}    

	switch(g_camera_cntx.external_request_mode)
	{
	case MMI_CAMERA_EXTERNAL_MODE_LARGEST_RESOLUTION:
		g_camera_cntx.img_size_backup = g_camera_cntx.setting.image_size;
		mmi_camera_change_to_largest_img_size();
		break;
	default:
		break;
	}

	g_camera_cntx.cur_gid = cur_gid;

	mmi_camera_app_screen();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_app_screen
* DESCRIPTION
*  entry camera application screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_app_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_APP_SCREEN,g_camera_cntx.cur_gid);
	mmi_camera_load_setting();

#ifdef __MMI_CAMERA_SIMPLE_UI__
	/* slim version will not save these settings */
	mmi_camera_init_none_save_setting();
#endif

	mmi_frm_group_enter(g_camera_cntx.cur_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);

	if(mmi_camera_entry_app_pre_check() == MMI_FALSE)
	{
	return;
	}

	/* user press camera key when clam close in Idle screen, ignore it */
#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) && defined(__MTK_TARGET__)
	if (srv_clam_is_close())
	{
		if (mmi_frm_scrn_get_active_id() == IDLE_SCREEN_ID)
		{
			return;
		}
		else
		{
			mmi_idle_display();
			return;
		}
	}
	else if (mmi_frm_scrn_get_active_id() != SCR_ID_CAMERA_OPTION)
	{
		g_camera_cntx.is_clam_close = FALSE;
	}
#endif /* defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) && defined(__MTK_TARGET__) */ 
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
	if (g_camera_cntx.app_mem_pool==NULL)
	{

		g_camera_cntx.app_mem_pool 
			= applib_mem_ap_alloc_framebuffer(g_camera_cntx.cur_gid, CAMERA_HW_ROTATE_TMP_BUFFER);

		if (g_camera_cntx.app_mem_pool == NULL)
		{
			return;
		}       
	}
#else
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) 
	g_camera_cntx.app_mem_pool = NULL;
#endif
#endif
#endif


	/* Pass pre-check, enter Camera Application */
	mmi_camera_entry_app_screen_internal();
	return;
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_lauch
* DESCRIPTION
*  entry camera application screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_lauch_init(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/    
	g_camera_cntx.external_request_mode = MMI_CAMERA_EXTERNAL_MODE_OFF;

	if (mmi_frm_group_is_present(g_camera_cntx.cur_gid))
	{
		mmi_frm_group_close(g_camera_cntx.cur_gid);   
	}
	g_camera_cntx.cur_gid = NULL;
	if(mmi_camera_entry_app_pre_check() == MMI_FALSE)
	{
		return;
	}
    #ifdef __MMI_SUPPORT_ASMV2__
	g_camera_cntx.cur_gid = mmi_frm_group_create (APP_CAMERA,  GRP_ID_AUTO_GEN, mmi_camera_group_proc, NULL);
	#else
	g_camera_cntx.cur_gid = mmi_frm_group_create (GRP_ID_ROOT,  GRP_ID_AUTO_GEN, mmi_camera_group_proc, NULL);
	#endif

	mmi_camera_app_screen();
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_pre_init_app
* DESCRIPTION
*  entry camera application screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_pre_init_app(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 create_result;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* init some flags */
	g_camera_cntx.last_error = MDI_RES_CAMERA_SUCCEED;
	g_camera_cntx.is_dis_clam_open = FALSE;
	g_camera_cntx.is_continue_capture = FALSE;

	g_camera_cntx.is_preview_started = MMI_FALSE;
	g_camera_cntx.pressed_key = KEY_INVALID;

#ifdef __CAMERA_AUTOFOCUS__
	g_camera_cntx.af_state = AF_CANCEL;
	g_camera_cntx.is_af_capture = FALSE;
#endif /* __CAMERA_AUTOFOCUS__ */ 


	if (!g_camera_cntx.is_force_self_capture)
	{
		g_camera_cntx.is_clam_close = FALSE;
	}

	g_camera_cntx.hint1_buf[0] = 0;
	g_camera_cntx.hint2_buf[0] = 0;

	/* allocate storage path buffer */
	if (g_camera_cntx.storage_filepath == NULL)
	{
		g_camera_cntx.storage_filepath = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
		*(g_camera_cntx.storage_filepath) = 0;
	}

	if (g_camera_cntx.captured_filepath == NULL)
	{
		g_camera_cntx.captured_filepath = gui_malloc(SRV_FMGR_PATH_BUFFER_SIZE);
		*(g_camera_cntx.captured_filepath) = 0;
	}

	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif

}



/*****************************************************************************
* FUNCTION
*  mmi_camera_post_init_app
* DESCRIPTION
*  init camera after camera power on
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_post_init_app(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_POST_INIT_APP);
	/* init advanced dsc mode */
	mmi_camera_preview_update_capture_size();
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__   
	/* create preview resource */
	mmi_camera_preview_create_resource();

	/* config layer/lcd orientation if HORIZONTAL_CAMERA */
#if defined(__CAMERA_OSD_HORIZONTAL__)
	mmi_camera_config_layer_orientation();
#endif 
#else
	/* config layer/lcd orientation if HORIZONTAL_CAMERA */
#if defined(__CAMERA_OSD_HORIZONTAL__)
	mmi_camera_config_layer_orientation();
#endif 
	/* create preview resource */
	mmi_camera_preview_create_resource();
#endif

}

static void mmi_camera_restore_layer(gdi_handle layer_h)
{
	gdi_layer_push_and_set_active(layer_h);
	gdi_layer_resize(LCD_WIDTH, LCD_HEIGHT);
	gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
}

static void mmi_camera_use_base_layer(void)
{
	GDI_HANDLE base_layer;
	

	gdi_layer_get_base_handle(&base_layer);
	mmi_camera_restore_layer(base_layer);
	gdi_layer_push_and_set_active(base_layer);
	gdi_layer_get_buffer_ptr(&g_camera_cntx.preview_buf_p);
	gdi_layer_pop_and_restore_active();

}

#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
static void mmi_camera_use_gdi_layer(void)
{
	if (g_camera_cntx.gdi_layer_handle == GDI_NULL_HANDLE)
	{
		gdi_layer_create(0, 0, LCD_WIDTH, LCD_HEIGHT, &g_camera_cntx.gdi_layer_handle);
	}

	gdi_layer_push_and_set_active(g_camera_cntx.gdi_layer_handle);
	gdi_layer_get_buffer_ptr(&g_camera_cntx.osd_buf_p);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
}
#endif
static void mmi_camera_config_layer(void)
{    
	mmi_camera_use_base_layer();
	#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_use_gdi_layer();  
	#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_init_framework
* DESCRIPTION
*  entry camera application screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_init_framework(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* turn off 3D sound */
#ifdef __MMI_AUDIO_REVERB_EFFECT__
	g_camera_cntx.is_3d_sound_on = mmi_settings_audio_reverb_get_status();
	if (g_camera_cntx.is_3d_sound_on == TRUE)
	{
		mdi_audio_reverb_turn_off();
	}
#endif /* __MMI_AUDIO_REVERB_EFFECT__ */ 

	/* entry full screen app */
	entry_full_screen();

	gdi_layer_reset_clip();
	gdi_layer_reset_text_clip();

	/* stop bg music */
	mdi_audio_suspend_background_play();

	/* 
	* This is used to solve a very rare situation. When playing a IMELODY 
	* with backlight on/off, and the screen previous to this screen is a 
	* horizontal screen. Before enter this screen, the IMELODY turn off the
	* backlight. While exit previous screen, the layer rotate back to normal
	* size and the content is not correct. So when calling srv_backlight_turn_on, 
	* LCD is in sleepin state and draw wrong content to LCD.
	* So we need to clear the buffer first to avoid this situation.
	*/
	gdi_layer_clear(GDI_COLOR_BLACK);


	/* 
	* set this to avoid tearing 
	* gdi will help to cover this before, now app should set this itself 
	*/
	g_camera_cntx.ori_te_ctrl = (MMI_BOOL)gdi_lcd_set_te_ctrl(KAL_TRUE);

	/* stop MMI sleep */
	srv_backlight_turn_on(SRV_BACKLIGHT_PERMANENT);

	/* force all playing keypad tone off */
	srv_profiles_stop_tone((srv_prof_tone_enum)GetCurKeypadTone());

	/* disable key pad tone */
	mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_DISABLED);

	/* disalbe align timer  */
	UI_disable_alignment_timers();

	/* stop LED patten */
	srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_STOP);

	/* enable multi-layer */
	gdi_layer_multi_layer_enable();

	mmi_camera_config_layer();

	/* get sublcd base layer handle */
#ifdef __MMI_SUBLCD__
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_get_base_handle(&g_camera_cntx.sublcd_base_layer_handle);
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	/************ draw sublcd and hook msg hdlr ************/
	/* entry sublcd */
	if (!g_camera_cntx.is_sublcd_display)
	{
		ForceSubLCDScreen(mmi_camera_entry_sublcd_screen);
	}
#endif /* __MMI_SUBLCD__ */ 

#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) 
	/* register event hdlr */
	mmi_frm_cb_reg_event(EVT_ID_PRE_PROTOCOL, mmi_camera_clam_close_event_hdlr, NULL);
#endif /* defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) */ 
}

/*****************************************************
*          OSD handler
*****************************************************/
#define MMI_CAMERA_OSD_MOD

#ifdef MMI_CAMERA_OSD_MOD
#if defined(__CAMERA_FEATURE_DRAW_ICON__)
static const camera_icon_struct g_camera_icons[] = 
{
#if defined(__CAMERA_FEATURE_WB__) && (WB_IS_SHOW == TRUE)
	{IMG_ID_CAMERA_OSD_WB_START, IMG_ID_CAMERA_OSD_WB_AUTO, &g_camera_skin_cntx.wb
#ifdef __CAMERA_OSD_HORIZONTAL__
	,&g_camera_skin_cntx_270.wb
#endif
	},
#endif

#if defined(__CAMERA_FEATURE_FLASH__) && (FLASH_IS_SHOW == TRUE)
	{IMG_ID_CAMERA_OSD_FLASH_START, 0, &g_camera_skin_cntx.flash
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.flash
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_LED_HIGHLIGHT__) && (LED_HIGHLIGHT_IS_SHOW == TRUE)
	{IMG_ID_CAMERA_OSD_LED_HIGHLIGHT_START, 0, &g_camera_skin_cntx.led_highlight
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.led_highlight
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_NIGHT__) && (NIGHT_IS_SHOW == TRUE)    
	{IMG_ID_CAMERA_OSD_NIGHT_START, 0, &g_camera_skin_cntx.night
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.night
#endif
	},

#endif

#if (IMAGE_SIZE_IS_SHOW == TRUE)    
	{IMG_ID_CAMERA_OSD_IMAGE_SIZE_START, 0, &g_camera_skin_cntx.image_size
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.image_size
#endif
	},
#endif

#if (IMAGE_QTY_IS_SHOW == TRUE)
	{IMG_ID_CAMERA_OSD_IMAGE_QTY_START, 0, &g_camera_skin_cntx.image_qty
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.image_qty
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_CONT_SHOT__) && (CONT_SHOT_IS_SHOW == TRUE)    
	{IMG_ID_CAMERA_OSD_CONT_SHOT_START, IMG_ID_CAMERA_OSD_CONT_SHOT_OFF, &g_camera_skin_cntx.cont_shot
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.cont_shot
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_DELAY_TIMER__) && (DELAY_TIMER_IS_SHOW == TRUE)    
	{IMG_ID_CAMERA_OSD_DELAY_TIMER_START, IMG_ID_CAMERA_OSD_DELAY_TIMER_OFF, &g_camera_skin_cntx.delay_timer
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.delay_timer
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_STORAGE__) && (STORAGE_IS_SHOW == TRUE) 
	{IMG_ID_CAMERA_OSD_STORAGE_START, 0, &g_camera_skin_cntx.storage     /*?????*/
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.storage
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_EFFECT__) && (EFFECT_IS_SHOW == TRUE) 
	{IMG_ID_CAMERA_OSD_EFFECT_START, IMG_ID_CAMERA_OSD_EFFECT_NORMAL, &g_camera_skin_cntx.effect
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.effect
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_AE_METER__) && (AE_METER_IS_SHOW == TRUE)     
	{IMG_ID_CAMERA_OSD_AE_METER_START, 0, &g_camera_skin_cntx.ae_meter
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.ae_meter
#endif
	},

#endif

#if defined(__CAMERA_FEATURE_ISO_SUPPORT__) && (ISO_IS_SHOW == TRUE)     
	{IMG_ID_CAMERA_OSD_ISO_START, 0, &g_camera_skin_cntx.iso
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.iso
#endif
	},

#endif

#if defined(__CAMERA_DSC_MODE__) && (SCENE_MODE_IS_SHOW == TRUE)     
	{IMG_ID_CAMERA_OSD_DSC_MODE_START, IMG_ID_CAMERA_OSD_DSC_MODE_AUTO, &g_camera_skin_cntx.dsc_mode
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.dsc_mode
#endif
	},

#endif

#if defined(__CAMERA_AUTOFOCUS_MODE__) && (AF_MODE_IS_SHOW == TRUE)     
	{IMG_ID_CAMERA_OSD_FOCUS_MODE_START, 0, &g_camera_skin_cntx.af_mode
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.af_mode
#endif
	},

#endif

#if defined(__CAMERA_AUTOFOCUS_METERING__) && (AF_METER_IS_SHOW == TRUE)     
	{IMG_ID_CAMERA_OSD_FOCUS_METER_START, 0, &g_camera_skin_cntx.af_meter
#ifdef __CAMERA_OSD_HORIZONTAL__
	, &g_camera_skin_cntx_270.af_meter
#endif
	},

#endif
};

#define CAMERA_TOUCH_ICON_MAX (sizeof(g_camera_icons)/sizeof(g_camera_icons[0]))
static camera_ui_touch_struct g_camera_touch_icons[CAMERA_TOUCH_ICON_MAX];
#endif


#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__

static void mmi_camera_osd_init_button(camera_ui_button_struct *pbutton, U16 key_code, 
									   U16 icon, const camera_skin_icon_struct *ppos, MMI_BOOL is_init)
{
	if(is_init)
	{
		pbutton->key = key_code;
		pbutton->x = ppos->offset_x;
		pbutton->y = ppos->offset_y;
		gdi_image_get_dimension_id(icon, 
			&pbutton->width, 
			&pbutton->height);
	}

}

static void mmi_camera_osd_init_buttons()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	camera_ui_button_struct *pbuttons = NULL;
	const camera_skin_layout_struct *p_act_skin = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	//mmi_camera_osd_init_button(pbuttons, NULL, NULL, (const camera_skin_icon_struct *)p_act_skin,MMI_FALSE);
	
	pbuttons = g_camera_cntx.osd_data.buttons;
	p_act_skin = &g_camera_skin_cntx;

#ifdef __CAMERA_OSD_HORIZONTAL__
	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270){

		p_act_skin = &g_camera_skin_cntx_270;
	}
#endif   


#if defined(__CAMERA_FEATURE_EV__) && (EV_IS_SHOW == TRUE)
	mmi_camera_osd_init_button(&pbuttons[CAMERA_TOUCH_EV_INC], KEY_RIGHT_ARROW, 
		IMG_ID_CAMERA_OSD_EV_INC, &p_act_skin->ev_inc,MMI_TRUE);
	mmi_camera_osd_init_button(&pbuttons[CAMERA_TOUCH_EV_DEC], KEY_LEFT_ARROW, 
		IMG_ID_CAMERA_OSD_EV_DEC, &p_act_skin->ev_dec,MMI_TRUE);
#endif

#if defined(__CAMERA_FEATURE_ZOOM__) && (ZOOM_IS_SHOW == TRUE)
	mmi_camera_osd_init_button(&pbuttons[CAMERA_TOUCH_ZOOM_INC], KEY_UP_ARROW, 
		IMG_ID_CAMERA_OSD_ZOOM_INC, &p_act_skin->zoom_inc,MMI_TRUE);
	mmi_camera_osd_init_button(&pbuttons[CAMERA_TOUCH_ZOOM_DEC], KEY_DOWN_ARROW, 
		IMG_ID_CAMERA_OSD_ZOOM_DEC, &p_act_skin->zoom_dec,MMI_TRUE);
#endif

}
#endif // __CAMERA_FEATURE_DRAW_BUTTONS__


#ifdef __CAMERA_FEATURE_DRAW_ICON__
static void mmi_camera_preview_draw_icon(void)
{
	S32 i;
	camera_ui_touch_struct *picon = NULL; 
	const camera_skin_icon_struct *ppos; 
	const camera_hotkey_item_struct *psetting; 
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_select_osd_region_layer(CAMERA_ICON_REGION);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DRAW_ICON);

	for(i=0; i<sizeof(g_camera_icons)/sizeof(g_camera_icons[0]); i++){
#ifndef __MMI_TOUCH_SCREEN__
		g_camera_touch_icons[i].picon = &g_camera_icons[i];
#endif
		picon = &g_camera_touch_icons[i];
		ppos = picon->picon->ppos;
#ifdef __CAMERA_OSD_HORIZONTAL__
		if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
		{
			ppos = picon->picon->ppos_270;
		}
#endif
		psetting = mmi_camera_get_setting_item_by_icon(picon->picon->id_img_start);

#ifdef	__MMI_CAMERA_SIMPLE_UI__    /* simple UI not draw the default setting icon */
		if(picon->picon->id_img_start + (*psetting->val_addr) + 1 != picon->picon->id_img_hide){
			picon->is_hide = 0;
		}else{
			picon->is_hide = 1;
		}
#endif
		if(!picon->is_hide){
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
			gdi_image_draw_id(ppos->offset_x - g_camera_cntx.active_camera_osd_ptr->osd_region[CAMERA_ICON_REGION].offset_x , 
				ppos->offset_y - g_camera_cntx.active_camera_osd_ptr->osd_region[CAMERA_ICON_REGION].offset_y, 
				picon->picon->id_img_start + (*psetting->val_addr) + 1);
#else
			gdi_image_draw_id(ppos->offset_x, 
				ppos->offset_y, 
				picon->picon->id_img_start + (*psetting->val_addr) + 1);
#endif 
		}
	} 
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_layer_pop_and_restore_active();
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)     
	mmi_camera_rotate_osd_region_layer(CAMERA_ICON_REGION);
#endif //defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) 

#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
}
#endif //__CAMERA_FEATURE_DRAW_ICON__

#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
static void mmi_camera_preview_draw_buttons(void)
{
#if (defined(__CAMERA_FEATURE_EV__) && (EV_IS_SHOW == TRUE))||(defined(__CAMERA_FEATURE_ZOOM__) && (ZOOM_IS_SHOW == TRUE))

	const camera_skin_icon_struct *picon;
	U16 icon;
#endif
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	PU8 temp_buf;
	S32 offset_x;
	S32 offset_y;

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DRAW_BUTTONS);

	gui_lock_double_buffer();
	offset_x = g_camera_cntx.active_camera_osd_ptr->osd_region[CAMERA_BUTTON_REGION].offset_x;
	offset_y = g_camera_cntx.active_camera_osd_ptr->osd_region[CAMERA_BUTTON_REGION].offset_y;

	mmi_camera_select_osd_region_layer(CAMERA_BUTTON_REGION);
#endif//__MMI_CAMERA_MULTI_OSD_LAYER__
	/* draw ev */
#if defined(__CAMERA_FEATURE_EV__) && (EV_IS_SHOW == TRUE) && !defined(__CAMERA_FEATURE_FTE_SUPPORT__)
	picon = &(g_camera_cntx.active_camera_osd_ptr->ev);
#ifdef	__MMI_CAMERA_SIMPLE_UI__ /* draw header icon */
	{
		U16 head_id;
		S32 w, h, offset = 0;
		if(g_camera_cntx.setting.ev > CAMERA_SETTING_EV_0){
			head_id = IMG_ID_CAMERA_OSD_EV_HEAD_P;
		}else if(g_camera_cntx.setting.ev == CAMERA_SETTING_EV_0){
			head_id = IMG_ID_CAMERA_OSD_EV_HEAD_0;
		}else{
			head_id = IMG_ID_CAMERA_OSD_EV_HEAD_N;
		}

		gdi_image_get_dimension_id(IMG_ID_CAMERA_OSD_EV_HEAD, &w, &h);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_id(picon->offset_x, 
			0, 
			IMG_ID_CAMERA_OSD_EV_HEAD);
#else
		gdi_image_draw_id(picon->offset_x, 
			picon->offset_y, 
			IMG_ID_CAMERA_OSD_EV_HEAD);
#endif
		offset += w;
		gdi_image_get_dimension_id(head_id, &w, &h);

#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_id(picon->offset_x + offset, 
			0, 
			head_id);
#else
		gdi_image_draw_id(picon->offset_x + offset, 
			picon->offset_y, 
			head_id);
#endif
		offset += w;

#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_id(picon->offset_x + offset, 
			0, 
			IMG_ID_CAMERA_OSD_EV_START+g_camera_cntx.setting.ev+1);
#else
		gdi_image_draw_id(picon->offset_x + offset, 
			picon->offset_y, 
			IMG_ID_CAMERA_OSD_EV_START+g_camera_cntx.setting.ev+1);
#endif
	}
#else //__MMI_CAMERA_SIMPLE_UI__

#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_image_draw_id(picon->offset_x - offset_x, 
		0, 
		IMG_ID_CAMERA_OSD_EV_START+g_camera_cntx.setting.ev+1);
#else
	gdi_image_draw_id(picon->offset_x, 
		picon->offset_y, 
		IMG_ID_CAMERA_OSD_EV_START+g_camera_cntx.setting.ev+1);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__

#endif //__MMI_CAMERA_SIMPLE_UI__

	picon = &(g_camera_cntx.active_camera_osd_ptr->ev_inc);
	if (g_camera_cntx.setting.ev == CAMERA_SETTING_EV_COUNT - 1){
		icon = IMG_ID_CAMERA_OSD_EV_INC_DIS;
	}else if (g_camera_cntx.pressed_key == g_camera_cntx.osd_data.buttons[CAMERA_TOUCH_EV_INC].key){
		icon = IMG_ID_CAMERA_OSD_EV_INC_SEL;
	}else{
		icon = IMG_ID_CAMERA_OSD_EV_INC;
	}

#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_image_draw_id(picon->offset_x, 
		0, 
		icon);
#else
	gdi_image_draw_id(picon->offset_x, 
		picon->offset_y, 
		icon);
#endif

	picon = &(g_camera_cntx.active_camera_osd_ptr->ev_dec);
	if (g_camera_cntx.setting.ev == 0){
		icon = IMG_ID_CAMERA_OSD_EV_DEC_DIS;
	}else if (g_camera_cntx.pressed_key == g_camera_cntx.osd_data.buttons[CAMERA_TOUCH_EV_DEC].key){
		icon = IMG_ID_CAMERA_OSD_EV_DEC_SEL;
	}else{
		icon = IMG_ID_CAMERA_OSD_EV_DEC;
	}
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_image_draw_id(picon->offset_x, 
		0, 
		icon);
#else
	gdi_image_draw_id(picon->offset_x, 
		picon->offset_y, 
		icon);
#endif

#endif /* __CAMERA_FEATURE_EV__ */ 

#if defined(__CAMERA_FEATURE_ZOOM__) && (ZOOM_IS_SHOW == TRUE)
	/* zooming icon */
	if (g_camera_cntx.max_zoom_steps > 0)
	{
		U32 total_idx, current_idx;
		U32 zoom_head_width,zoom_head_height;
		U32 zoom_inc_width,zoom_inc_height;
		U32 zoom_dec_width,zoom_dec_height;

		gdi_image_get_dimension_id(IMG_ID_CAMERA_OSD_ZOOM_HEAD, &zoom_head_width, &zoom_head_height);
		gdi_image_get_dimension_id(IMG_ID_CAMERA_OSD_ZOOM_INC, &zoom_inc_width, &zoom_inc_height);
		gdi_image_get_dimension_id(IMG_ID_CAMERA_OSD_ZOOM_DEC, &zoom_dec_width, &zoom_dec_height);
		total_idx = g_camera_cntx.max_zoom_steps;
		current_idx = (U32) g_camera_cntx.setting.zoom_idx;
		picon = &(g_camera_cntx.active_camera_osd_ptr->zoom);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_resized_id(picon->offset_x - offset_x, 
			picon->offset_y - offset_y, zoom_head_width + zoom_inc_width + zoom_dec_width + 10, zoom_head_height,
			IMG_ID_CAMERA_OSD_ZOOM_HEAD);
#else
		gdi_image_draw_resized_id(picon->offset_x, 
			picon->offset_y, zoom_head_width + zoom_inc_width + zoom_dec_width + 10, zoom_head_height,
			IMG_ID_CAMERA_OSD_ZOOM_HEAD);
#endif
		picon = &(g_camera_cntx.active_camera_osd_ptr->zoom_inc);

		if (current_idx == total_idx){
			icon = IMG_ID_CAMERA_OSD_ZOOM_INC_DIS;
		}else if (g_camera_cntx.pressed_key == g_camera_cntx.osd_data.buttons[CAMERA_TOUCH_ZOOM_INC].key){
			icon = IMG_ID_CAMERA_OSD_ZOOM_INC_SEL;
		}else{
			icon = IMG_ID_CAMERA_OSD_ZOOM_INC;
		}
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_id(picon->offset_x - offset_x, 
			picon->offset_y - offset_y, 
			icon); 
#else
		gdi_image_draw_id(picon->offset_x, 
			picon->offset_y, 
			icon); 
#endif

		picon = &(g_camera_cntx.active_camera_osd_ptr->zoom_dec);
		if (current_idx == 0){
			icon = IMG_ID_CAMERA_OSD_ZOOM_DEC_DIS;
		}else if (g_camera_cntx.pressed_key == g_camera_cntx.osd_data.buttons[CAMERA_TOUCH_ZOOM_DEC].key){
			icon = IMG_ID_CAMERA_OSD_ZOOM_DEC_SEL;
		}else{
			icon = IMG_ID_CAMERA_OSD_ZOOM_DEC;
		}
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_id(picon->offset_x - offset_x, 
			picon->offset_y - offset_y, 
			icon);
#else
		gdi_image_draw_id(picon->offset_x, 
			picon->offset_y, 
			icon);
#endif

#ifndef __MMI_CAMERA_SIMPLE_UI__
		{

			S32 num_width, num_height, num_x, num;
			U32 cur_zoom_factor;

			picon = &(g_camera_cntx.active_camera_osd_ptr->zoom);
			gdi_image_get_dimension_id(IMG_ID_CAMERA_OSD_ZOOM_BAR, &num_width, &num_height);
			gdi_image_draw_id(picon->offset_x, 
				picon->offset_y, 
				IMG_ID_CAMERA_OSD_ZOOM_BAR);   
			/* before HAL (zoom_factor = 10 * actual_factor) and (zoom_factor = 100 * actual_factor) after*/
			if (g_camera_cntx.setting.zoom_idx == 0)
			{
				cur_zoom_factor = 10;
			}
			else
			{
				cur_zoom_factor = mdi_camera_get_para_zoom_factor();
				cur_zoom_factor /= 10;
			}

			num_x = num_width;
			num = cur_zoom_factor / 10;

			gdi_image_draw_id(picon->offset_x + num_x, 
				picon->offset_y, 
				IMG_ID_CAMERA_OSD_NUM_00 + num);   
			gdi_image_get_dimension_id((U16)(IMG_ID_CAMERA_OSD_NUM_00 + num), &num_width, &num_height);
			num_x = num_x + num_width;
			gdi_image_draw_id(picon->offset_x + num_x, 
				picon->offset_y, 
				IMG_ID_CAMERA_OSD_NUM_DOT);   

			gdi_image_get_dimension_id((U16)(IMG_ID_CAMERA_OSD_NUM_DOT), &num_width, &num_height);
			num = cur_zoom_factor - num * 10;
			num_x = num_x + num_width;
			gdi_image_draw_id(picon->offset_x + num_x, 
				picon->offset_y, 
				IMG_ID_CAMERA_OSD_NUM_00 + num);   
		}
#endif  //__MMI_CAMERA_SIMPLE_UI__          
	}

#endif /* __CAMERA_FEATURE_ZOOM__ */ 
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_layer_pop_and_restore_active();
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)
	mmi_camera_rotate_osd_region_layer(CAMERA_BUTTON_REGION);
#endif
    gui_unlock_double_buffer();
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
}
#endif// __CAMERA_FEATURE_DRAW_BUTTONS__

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_draw_osd
* DESCRIPTION
*  draw preview title
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_draw_osd(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	U32 i = 0;
#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_DRAW_OSD);
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	/*@ Add by Vincent */
	/* if using idp rotate, we need to config osd buffer for idp rotate only, we do not need to config original osd layer as horizontal */
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)

	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_0)
	{
		gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
		gdi_layer_toggle_double();
		/* toggle double buffer */
		gdi_layer_clear(GDI_COLOR_TRANSPARENT);

		gdi_set_alpha_blending_source_layer(g_camera_cntx.osd_layer_handle);
	}
	else
	{
		gdi_layer_push_and_set_active(g_camera_cntx.osd_idp_rotate_layer_handle);
		gdi_layer_clear(GDI_COLOR_TRANSPARENT);

		gdi_set_alpha_blending_source_layer(g_camera_cntx.osd_idp_rotate_layer_handle);
	}
#else /* defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) */

	gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
	gdi_layer_toggle_double();
	/* toggle double buffer */
	gdi_layer_clear(GDI_COLOR_TRANSPARENT);

	gdi_set_alpha_blending_source_layer(g_camera_cntx.osd_layer_handle);
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)*/
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
	/****** wanna draw any thing on OSD layer, please add code after this ******/
#ifdef __CAMERA_AUTOFOCUS__
	if (g_camera_cntx.is_autofocus_pressed == TRUE)
	{
		mmi_camera_draw_autofocus_process();
	}
#endif /* __CAMERA_AUTOFOCUS__ */ 

	/* Init buttons */

#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__		

	mmi_camera_osd_init_buttons();
#endif // __CAMERA_FEATURE_DRAW_BUTTONS__

	mmi_camera_preview_draw_softkey();
	mmi_camera_preview_draw_title();

	if (g_camera_cntx.fade_time != 255)
	{
		mmi_camera_preview_draw_hint();
		g_camera_cntx.fade_time = 0;
	}

	if ((g_camera_cntx.app_state != CAMERA_STATE_DELETE_CONFIRM) &&
		(g_camera_cntx.app_state != CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM))
	{
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__		
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
#ifdef __CAMERA_FEATURE_DRAW_ICON__
		mmi_camera_preview_draw_icon();
#endif
#ifdef __CAMERA_FEATURE_CONT_SHOT__
		if (g_camera_cntx.app_state == CAMERA_STATE_CONTSHOT)
		{
#ifdef __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__
			mmi_camera_preview_draw_contshot_countbar();
#endif 
		}
#endif
	}
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_layer_pop_and_restore_active();

	/*@ Add by Vincent */
	/* if using idp rotate, we need to config osd buffer for idp rotate only, we do not need to config original osd layer as horizontal */
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) 

	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
		gdi_layer_toggle_double();
		gdi_layer_clear(GDI_COLOR_TRANSPARENT);
		gdi_set_alpha_blending_source_layer(g_camera_cntx.osd_layer_handle);
		mdi_util_rotate_osd_for_hw_rotator(g_camera_cntx.osd_idp_rotate_layer_handle, g_camera_cntx.osd_layer_handle);
		gdi_layer_pop_and_restore_active();
	}

#endif /* defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)  */
#endif //ndef __MMI_CAMERA_MULTI_OSD_LAYER__
#if defined(__MMI_CAMERA_BG_CALL__)
	if (srv_ucm_is_background_call() == TRUE && CAMERA_STATE_IN(CAMERA_STATE_EXIT))
	{
		gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
		gdi_layer_clear(GDI_COLOR_BLACK);
		gdi_layer_pop_and_restore_active();
		gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
	}
#endif /* __MMI_CAMERA_BG_CALL__ */
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_draw_title
* DESCRIPTION
*  draw preview title
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_draw_title(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DRAW_TITLE);
	/* if is fullscreen display, do not draw title */
	if (g_camera_cntx.is_fullscreen)
	{
		return;
	}

	/* if not fullscreen and need title */
	if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_title_bar &&
		g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_caption)
	{
		gdi_layer_lock_frame_buffer();

		show_title_status_icon();
		draw_title();

		gdi_layer_unlock_frame_buffer();
		gdi_layer_reset_clip();
		gdi_layer_reset_text_clip();
	}
}

static void mmi_camera_preview_draw_softkey_button(U16 str_id, WGUI_SOFTKEY_ENUM softkey_id, 
												   BOOL is_pressed, camera_ui_button_struct *p_touch_obj, 
												   S32 regn_offset_x, S32 regn_offset_y, const camera_style_text_struct *style_txt)
{
	CHAR * str_ptr;
	S32 str_width;
	S32 str_height;
	S32 offset_x, offset_y;
	S32 truncated_width = 0;
	MMI_BOOL truncated;

	
	mmi_frm_screen_rotate_enum rotate;


	str_ptr = (CHAR *) GetString(str_id);

	gui_measure_string((UI_string_type) str_ptr, &str_width, &str_height);

#if defined(__CAMERA_OSD_HORIZONTAL__)
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
		rotate = MMI_FRM_SCREEN_ROTATE_270;
	else
#endif 

#ifdef __MMI_SCREEN_ROTATE__
		rotate =mmi_frm_get_screen_rotate();
#else
		rotate = MMI_FRM_SCREEN_ROTATE_0;
#endif

	truncated = wgui_softkey_get_offset(
		(UI_string_type) str_ptr,
		&offset_x,
		&offset_y,
		&truncated_width,
		softkey_id,
		rotate);


#if 0 //2013.07.09	
/* under construction !*/
#if defined(__CAMERA_OSD_HORIZONTAL__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
/* under construction !*/
#ifdef __MMI_SCREEN_ROTATE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
#endif  //2013.07.09

	/* check r2lMMIFlag flag to correct offset_x of string, due to we will do the change in 
	* mmi_camera_draw_style_text() */
	if (mmi_fe_get_r2l_state())
	{
		if (truncated)
		{
			offset_x -= truncated_width;
		}
		else
		{
			offset_x -= gui_get_string_width((UI_string_type) str_ptr);
		}
	}

	if (is_pressed)
	{
		offset_x++;
		offset_y++;
	}

	mmi_camera_draw_style_text(
		str_ptr,
		offset_x - regn_offset_x,
		offset_y - regn_offset_y,
		truncated_width,
		style_txt);

	p_touch_obj->x = offset_x;
	p_touch_obj->y = offset_y;
	p_touch_obj->width = str_width;
	p_touch_obj->height = str_height;
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_draw_softkey
* DESCRIPTION
*  draw preview softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_draw_softkey(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 lsk_id = 0;
	U16 rsk_id = 0;
	S32 offset_x = 0;
	S32 offset_y = 0;
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	S32 layer_offset_x = 0;
	S32 layer_offset_y = 0;
	PU8 temp_buf;
#endif
#ifndef __MMI_CAMERA_SIMPLE_UI__  
	camera_osd_struct *psd = &g_camera_cntx.osd_data;
#endif
	camera_ui_button_struct *pbutton;


	S32 image_w = 0;
	S32 image_h = 0;
	U16 csk_icon = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DRAW_SOFTKEY);
	if(CAMERA_STATE_IN(CAMERA_STATE_CONTSHOT))  //???????? new modification by yiping, need consider
		return;
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	layer_offset_x = g_camera_cntx.active_camera_osd_ptr->osd_region[CAMERA_SOFTKEY_REGION].offset_x;
	layer_offset_y = g_camera_cntx.active_camera_osd_ptr->osd_region[CAMERA_SOFTKEY_REGION].offset_y;
	//#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)
	mmi_camera_select_osd_region_layer(CAMERA_SOFTKEY_REGION);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__

	/******* Draw LSK & RSK **************/
#ifndef __MMI_WEARABLE_DEVICE__
	lsk_id = STR_GLOBAL_OPTIONS;
	rsk_id = STR_GLOBAL_BACK;

	if (g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM && g_camera_cntx.external_request_mode != MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		lsk_id = STR_GLOBAL_CONTINUE;
		rsk_id = STR_GLOBAL_DELETE;
	}
#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	else if (g_camera_cntx.app_state == CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM)
	{
		lsk_id = STR_GLOBAL_SAVE;
		rsk_id = STR_GLOBAL_CLEAR;
	}
#endif

	gdi_layer_reset_clip();
	gdi_layer_reset_text_clip();

	/* slim always draw by self for is_draw_mmi_softkey is always true */
	gui_set_font(gui_font_get_type(GUI_FONT_SIZE_BUTTON));
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	pbutton = &g_camera_cntx.osd_data.buttons[CMAERA_TOUCH_LSK];
	pbutton->key = KEY_LSK;
	mmi_camera_preview_draw_softkey_button(lsk_id, MMI_LEFT_SOFTKEY, g_camera_cntx.pressed_key == KEY_LSK, 
		pbutton, offset_x + layer_offset_x, offset_y+layer_offset_y, &g_camera_cntx.active_camera_osd_ptr->softkey.lsk);
	pbutton = &g_camera_cntx.osd_data.buttons[CMAERA_TOUCH_RSK];
	pbutton->key = KEY_RSK;
	mmi_camera_preview_draw_softkey_button(rsk_id, MMI_RIGHT_SOFTKEY, g_camera_cntx.pressed_key == KEY_RSK, 
		pbutton, offset_x + layer_offset_x, offset_y + layer_offset_y, &g_camera_cntx.active_camera_osd_ptr->softkey.rsk);
#else
	pbutton = &g_camera_cntx.osd_data.buttons[CMAERA_TOUCH_LSK];
	pbutton->key = KEY_LSK;
	mmi_camera_preview_draw_softkey_button(lsk_id, MMI_LEFT_SOFTKEY, g_camera_cntx.pressed_key == KEY_LSK, 
		pbutton, offset_x, offset_y, &g_camera_cntx.active_camera_osd_ptr->softkey.lsk);
	pbutton = &g_camera_cntx.osd_data.buttons[CMAERA_TOUCH_RSK];
	pbutton->key = KEY_RSK;
	mmi_camera_preview_draw_softkey_button(rsk_id, MMI_RIGHT_SOFTKEY, g_camera_cntx.pressed_key == KEY_RSK, 
		pbutton, offset_x, offset_y, &g_camera_cntx.active_camera_osd_ptr->softkey.rsk);
#endif
#endif

	/* Draw CSK */
#ifndef __MMI_TOUCH_SCREEN__
	if(mmi_frm_kbd_is_key_supported(KEY_ENTER) == MMI_TRUE)
#endif
	{
		if ((g_camera_cntx.app_state != CAMERA_STATE_DELETE_CONFIRM) &&
			(g_camera_cntx.app_state != CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM))
		{

			/* csk_icon */
			csk_icon = IMG_ID_CAMERA_OSD_CAPTURE;

			/* offset_x, offset_y, image_w, image_h */
			offset_x = g_camera_cntx.active_camera_osd_ptr->capture.offset_x;
			offset_y = g_camera_cntx.active_camera_osd_ptr->capture.offset_y;
			if (g_camera_cntx.is_capturing)
			{
#ifdef __MMI_CAMERA_SIMPLE_UI__
				offset_x += 2;
				offset_y += 2;
#else
				csk_icon = IMG_ID_CAMERA_OSD_CAPTURE_SEL;
#endif
			}

			gdi_image_get_dimension_id(csk_icon, &image_w, &image_h);
		}

#if defined(__MMI_CAMERA_FORWARD_SUPPORT__)
		else if(g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM && g_camera_cntx.can_be_forward)
		{
			/* csk_icon */
			csk_icon = IMG_ID_CAMERA_FORWARD_TO_MMS;

			/* offset_x, offset_y, image_w, image_h */
			offset_x = g_camera_cntx.active_camera_osd_ptr->mms_icon.offset_x;
			offset_y = g_camera_cntx.active_camera_osd_ptr->mms_icon.offset_y;
			if(g_camera_cntx.pressed_key == KEY_CSK)
			{
				offset_x += 1;
				offset_y += 1;
			}

			gdi_image_get_dimension_id(csk_icon, &image_w, &image_h);
		}
#endif /* defined(__MMI_CAMERA_FORWARD_SUPPORT__) */ 

#ifndef __MMI_CAMERA_SIMPLE_UI__    

		else
		{
			#ifndef __MMI_WGUI_DISABLE_CSK__
			/* draw csk */
			if (wgui_softkey_is_csk_enabled())
			{
				S32 csk_w=0, csk_h=0, csk_offset_x=0, csk_offset_y=0;

				/* csk_icon */
				if (STR_GLOBAL_OPTIONS == lsk_id)
				{
					csk_icon = IMG_GLOBAL_OPTION_CSK;
				}
				else
				{
					csk_icon = IMG_GLOBAL_COMMON_CSK;
				}

				/* offset_x, offset_y, image_w, image_h */
				wgui_softkey_get_position(MMI_CENTER_SOFTKEY, &csk_offset_x, &csk_offset_y);
				if (0 != csk_offset_x && 0 != csk_offset_y)
				{
					wgui_softkey_get_dimension(MMI_CENTER_SOFTKEY, &csk_w, &csk_h);
					gdi_image_get_dimension_id((U16)(csk_icon), &image_w, &image_h);
				}

				if (psd->osd_rotate == CAMERA_DISPLAY_ROTATE_270)
				{
					offset_x = csk_offset_y + csk_h - image_h - 2;
					offset_y = csk_offset_x + csk_w/2 - image_w/2;
				}
				else
				{
					offset_x = csk_offset_x + csk_w/2 - image_w/2;
					offset_y = csk_offset_y + csk_h/2 - image_h/2;
				}


				if (g_camera_cntx.pressed_key == KEY_CSK)
				{
					offset_x += 1;
					offset_y += 1;
				}
			}
		#endif
		}
#endif /*__MMI_CAMERA_SIMPLE_UI__*/ 
	}


	pbutton = &g_camera_cntx.osd_data.buttons[CMAERA_TOUCH_CSK];
	pbutton->x = offset_x;
	pbutton->y = offset_y;
	pbutton->width = image_w;
	pbutton->height = image_h;
	if(csk_icon != 0){
		/* init button struct */
		pbutton->key = KEY_CSK;
		/* Draw CSK */
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		gdi_image_draw_id(
			pbutton->x - layer_offset_x,
			pbutton->y - layer_offset_y,
			csk_icon);
#else
		gdi_image_draw_id(
			pbutton->x,
			pbutton->y,
			csk_icon);
#endif

	}else{
		pbutton->key = KEY_INVALID;
	}
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_layer_pop_and_restore_active();
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)   
	mmi_camera_rotate_osd_region_layer(CAMERA_SOFTKEY_REGION);
#endif //defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_draw_hint
* DESCRIPTION
*  draw preview OSD panel
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/

static void mmi_camera_preview_draw_hint(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 str1_width;
	S32 str1_height;
	S32 str2_width;
	S32 str2_height;
	S32 str1_offset_x;
	S32 str1_offset_y;
	S32 str2_offset_x;
	S32 str2_offset_y;
	S32 spacing;
	CHAR * hint_str1;
	CHAR * hint_str2;

	S32 hint_box_x = g_camera_cntx.active_camera_osd_ptr->hint_box.offset_x;
	S32 hint_box_y = g_camera_cntx.active_camera_osd_ptr->hint_box.offset_y;
	S32 hint_box_width = g_camera_cntx.active_camera_osd_ptr->hint_box.width;
	S32 hint_box_height = g_camera_cntx.active_camera_osd_ptr->hint_box.height;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DRAW_HINT);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_select_osd_region_layer(CAMERA_HINT_REGION);

	gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION]);
	if((g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM) ||
		(g_camera_cntx.app_state == CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM))
	{
		if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
			gdi_layer_set_position(LCD_WIDTH - hint_box_height,
			hint_box_x);
		else
			gdi_layer_set_position(hint_box_x,0);
	}
	else
	{
		if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
			gdi_layer_set_position(hint_box_y,hint_box_x);
		else
			gdi_layer_set_position(hint_box_x,hint_box_y);
	}
	gdi_layer_pop_and_restore_active();
#endif // __MMI_CAMERA_MULTI_OSD_LAYER__
	/* draw hint */
	if (g_camera_cntx.osd_data.show_hint)
	{
		gui_set_font(&MMI_medium_font);
		hint_str1 = (CHAR * )(g_camera_cntx.hint1_buf);
		hint_str2 = (CHAR * )(g_camera_cntx.hint2_buf);

		/* be removed : clear hint backgounrd */
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
		gui_set_text_clip(
			hint_box_x,
			hint_box_y,
			hint_box_x + hint_box_width - 1,
			hint_box_y + hint_box_height - 1);
#else
		gui_set_text_clip(
			0,
			0,
			hint_box_width - 1,
			hint_box_height - 1);
#endif
		gui_measure_string((UI_string_type) hint_str1, &str1_width, &str1_height);
		gui_measure_string((UI_string_type) hint_str2, &str2_width, &str2_height);

		str1_offset_x = (hint_box_width - str1_width) >> 1;

		spacing = hint_box_height - str1_height - str1_height;
		spacing = (spacing > 0) ? (spacing / 3 + 1) : 0;

		str1_offset_y = (hint_box_height - str1_height - str1_height)/2;
		str2_offset_y = str1_offset_y + spacing + str1_height;
		str2_offset_x = (hint_box_width - str2_width) >> 1;

		gdi_layer_reset_clip();
		gui_reset_text_clip();

		if ((g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM) ||
			(g_camera_cntx.app_state == CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM))
		{
			/* when in delete confirm screen when horizontal screen,(landscape lcm also)
			filename will overlap softkey, so we need to find another way to display filename. 
			if it will overlap softkey, we will truncate it and replace with "..." */
#if defined(__MMI_CAMERA_LANDSCAPE_LCM__)
			U16 rsk_id = STR_GLOBAL_DELETE;
			S32 lsk_offset_x;
			S32 lsk_offset_y;
			CHAR *  str_ptr;
			S32 truncated_width = 0;

			/* lsk */
			str_ptr = (CHAR * ) GetString(rsk_id);
			wgui_softkey_get_offset((UI_string_type) str_ptr, &lsk_offset_x, &lsk_offset_y, &truncated_width, MMI_LEFT_SOFTKEY, MMI_FRM_SCREEN_ROTATE_270);

			/*str1_offset_x = (lsk_offset_x - str1_width) >> 1;*/
			str1_offset_x = (LCD_WIDTH - str1_width) >> 1;
			if (str1_offset_x < 0)
			{
				str1_offset_x = 0;
			}

			mmi_camera_draw_style_text(
				hint_str1,
				str1_offset_x,
				((MMI_title_height - str1_height) >> 1),
				LCD_WIDTH,
				&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#else /* __MMI_CAMERA_LANDSCAPE_LCM__ */
#if defined(__CAMERA_OSD_HORIZONTAL__)
			if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
			{
				U16 rsk_id = STR_GLOBAL_DELETE;
				S32 lsk_offset_x;
				S32 lsk_offset_y;
				CHAR *  str_ptr;
				S32 truncated_width = 0;

#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
				/* lsk */
				str_ptr = (CHAR * ) GetString(rsk_id);
				wgui_softkey_get_offset((UI_string_type) str_ptr, &lsk_offset_x, &lsk_offset_y, &truncated_width, MMI_LEFT_SOFTKEY, MMI_FRM_SCREEN_ROTATE_270);

				str1_offset_x = (lsk_offset_x - str1_width) >> 1;

				mmi_camera_draw_style_text(
					hint_str1,
					str1_offset_x,
					((MMI_title_height - str1_height) >> 1),
					lsk_offset_x - (str1_offset_x),
					&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#else
				mmi_camera_draw_style_text(
					hint_str1,
					str1_offset_x,
					((MMI_title_height - str1_height) >> 1),
					0,
					&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#endif	
			}
			else
#endif /* __CAMERA_OSD_HORIZONTAL__ */
			{
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
				mmi_camera_draw_style_text(
					hint_str1,
					g_camera_cntx.active_camera_osd_ptr->hint_box.offset_x + str1_offset_x,
					((MMI_title_height - str1_height) >> 1),
					0,
					&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#else
				mmi_camera_draw_style_text(
					hint_str1,
					str1_offset_x,
					((MMI_title_height - str1_height) >> 1),
					0,
					&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#endif
			}
#endif /* __MMI_CAMERA_LANDSCAPE_LCM__ */
		}
		else
		{
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
			mmi_camera_draw_style_text(
				hint_str1,
				hint_box_x+ str1_offset_x,
				hint_box_y+ str1_offset_y,
				0,
				&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);

			mmi_camera_draw_style_text(
				hint_str2,
				hint_box_x + str2_offset_x,
				hint_box_y + str2_offset_y,
				0,
				&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#else
			mmi_camera_draw_style_text(
				hint_str1,
				str1_offset_x,
				str1_offset_y,
				0,
				&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);

			mmi_camera_draw_style_text(
				hint_str2,
				str2_offset_x,
				str2_offset_y,
				0,
				&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
		}

		if (g_camera_cntx.fade_time != 0 && g_camera_cntx.fade_time != 255)
		{
			gui_start_timer(HINT_POPUP_FADE_TIME, mmi_camera_preview_hide_hint);
			g_camera_cntx.fade_time = 0;
		}
	}
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_layer_pop_and_restore_active();
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) 

	mmi_camera_rotate_osd_region_layer(CAMERA_HINT_REGION);

#endif //defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)

#endif//__MMI_CAMERA_MULTI_OSD_LAYER__
}


#endif /*MMI_CAMERA_OSD_MOD*/

/*****************************************************
*          key handler
****************************************************/
#define CAMERA_KEY_MOD
#ifdef CAMERA_KEY_MOD
typedef struct{
	U32 state;
	S32 x, y, w, h;
	U16 icon_up, icon_down, icon_disable;
	void (*down)(void);
	void (*up)(void);
}camera_button_struct;

#define MMI_CAMERA_KE_FLAG_SW   0x1

typedef struct {
	const camera_key_struct *pkey_array;
	U32 count;
	void (*default_hdlr)(U8 key_event, U16 key_code);
}camera_key_hdlr_struct;

/*****************************************************
*          key handler of each states
****************************************************/
#ifdef __CAMERA_HOTKEY__
static void mmi_camera_preview_default_keyhdlr(U8 key_event, U16 key_code)
{
	if(key_event == KEY_EVENT_DOWN){
		mmi_camera_hotkey_press(key_code);
	}
}
#endif
/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_lsk_release
* DESCRIPTION
*  previwe lsk released
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_lsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_LSK_RELEASE);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_preview_draw_softkey();
#else
	mmi_camera_preview_draw_osd();
#endif
	mmi_camera_blt();
	mmi_camera_entry_option_menu_screen();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_rsk_release
* DESCRIPTION
*  previwe rsk released
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_rsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_RSK_RELEASE);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_preview_draw_softkey();
#else
	mmi_camera_preview_draw_osd();
#endif

	/* for External Request */
	if (g_camera_cntx.external_request_mode != MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		if(g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_LARGEST_RESOLUTION)
			g_camera_cntx.setting.image_size = g_camera_cntx.img_size_backup;

		g_camera_cntx.setting.cont_shot = g_camera_cntx.contshot_backup;
		g_camera_cntx.external_request_mode = MMI_CAMERA_EXTERNAL_MODE_OFF;
	}

	mmi_camera_blt();

	/* camera with only 23key, will use RSK to capture */
#ifdef __MMI_CAMERA_23KEY__
	mmi_camera_capture_button_press();
#else 
	mmi_frm_scrn_close_active_id();
#endif 
}


static const camera_key_struct preview_keys[] = 

{
	/* register soft keys */
	{KEY_LSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_lsk_release, NULL},
	{KEY_RSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_rsk_release, NULL},    

#if (CAMERA_CAPTURE_KEY != -1)
#ifdef __AF_SUPPORT_ONE_KEY__
	{CAMERA_CAPTURE_KEY, 0, mmi_camera_af_and_capture, mmi_camera_capture_button_autofocus_released, NULL},    
#else
	{CAMERA_CAPTURE_KEY, 0, mmi_camera_capture_button_press, mmi_camera_capture_button_release, NULL},    
#endif
#else /*(CAMERA_CAPTURE_KEY != -1)*/    
#ifdef __CAMERA_AUTOFOCUS__
	{CAMERA_CAPTURE_KEY, MMI_CAMERA_KE_FLAG_SW, mmi_camera_capture_button_autofocus_pressed, mmi_camera_capture_button_autofocus_released, NULL},    
#ifdef __MMI_CAMERA_AF_TEST__
	/* 50 cont shot */
	{KEY_9, 0, mmi_camera_af_test, NULL, NULL},    
	{KEY_1, 0, mmi_camera_capture_button_autofocus_pressed, mmi_camera_capture_button_autofocus_released, NULL},
	{KEY_0, 0, mmi_camera_af_and_capture, mmi_camera_capture_button_autofocus_released, NULL},
#endif /* __MMI_CAMERA_AF_TEST__ */ 
#endif /* __CAMERA_AUTOFOCUS__ */
#endif /*(CAMERA_CAPTURE_KEY != -1)*/

#if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{CAMERA_CAPTURE_EXTRA_KEY1, 0, mmi_camera_capture_button_press, mmi_camera_capture_button_release, NULL},    
#endif    

#if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{CAMERA_CAPTURE_EXTRA_KEY2, 0, mmi_camera_capture_button_press, mmi_camera_capture_button_release, NULL},    
#endif    


#ifdef __CAMERA_FEATURE_EV__
	/* ev / zooming */
	{KEY_RIGHT_ARROW, MMI_CAMERA_KE_FLAG_SW, mmi_camera_preview_ev_inc_key_press, mmi_camera_preview_ev_key_release, mmi_camera_preview_ev_key_release},    
	{KEY_LEFT_ARROW, MMI_CAMERA_KE_FLAG_SW, mmi_camera_preview_ev_dec_key_press, mmi_camera_preview_ev_key_release, mmi_camera_preview_ev_key_release},    
#endif  /*__CAMERA_FEATURE_EV__*/

#ifdef __CAMERA_FEATURE_ZOOM__
	{KEY_UP_ARROW, MMI_CAMERA_KE_FLAG_SW, mmi_camera_preview_up_arrow_press, mmi_camera_preview_zoom_arrow_release, mmi_camera_preview_zoom_arrow_release},    
	{KEY_DOWN_ARROW, MMI_CAMERA_KE_FLAG_SW, mmi_camera_preview_down_arrow_press, mmi_camera_preview_zoom_arrow_release, mmi_camera_preview_zoom_arrow_release},    
#endif /* __CAMERA_FEATURE_ZOOM__ */ 

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
	{CAMERA_TOGGLE_SELF_CAPTURE_KEY, 0, mmi_camera_toggle_self_capture, NULL, NULL},    
#endif 

#if (CAMERA_TOGGLE_HIDE_OSD_KEY != -1)
	{CAMERA_TOGGLE_HIDE_OSD_KEY, 0, mmi_camera_toggle_hide_osd, NULL, NULL},    
#endif

#ifdef __MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__
#if (CAMERA_SWITCH_TO_VDOREC_KEY != -1)
	{CAMERA_SWITCH_TO_VDOREC_KEY, 0, mmi_camera_switch_to_vdorec_app, NULL, NULL},    
#endif

#endif /* #ifdef __MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__ */

};

#ifdef __CAMERA_HOTKEY__
static const camera_key_hdlr_struct g_preview_key_hdlr = 
{preview_keys, sizeof(preview_keys)/sizeof(camera_key_struct), mmi_camera_preview_default_keyhdlr};
#else
static const camera_key_hdlr_struct g_preview_key_hdlr = 
{preview_keys, sizeof(preview_keys)/sizeof(camera_key_struct), NULL};
#endif

static const camera_key_hdlr_struct *p_act_key_hdlr;


static const camera_key_struct* mmi_camera_get_key(U16 Keycode)
{
	U32 i;
	if(p_act_key_hdlr){
		for(i=0; i < p_act_key_hdlr->count; i++){
			if(p_act_key_hdlr->pkey_array[i].value == Keycode){
				return &(p_act_key_hdlr->pkey_array[i]);
			}
		}
	}

	return NULL;
}

static void mmi_camera_key_down_hdlr(U16 Keycode)
{
	const camera_key_struct *pkey = mmi_camera_get_key(Keycode);
	//kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: mmi_camera_key_down_hdlr,line = %d",__LINE__);			 

	g_camera_cntx.pressed_key = Keycode;
	if(pkey){
		if(pkey->flag & MMI_CAMERA_KE_FLAG_SW){
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__		
			if(Keycode == KEY_UP_ARROW || Keycode == KEY_DOWN_ARROW)
			{
				mmi_camera_preview_draw_buttons();

			}
			else
			{
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
				mmi_camera_preview_draw_softkey();
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__

			}
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
#else
			mmi_camera_preview_draw_osd();
#endif
			mmi_camera_blt();
		} 

		if(pkey->down){
			pkey->down();
		}
	}else if(p_act_key_hdlr && p_act_key_hdlr->default_hdlr){
		p_act_key_hdlr->default_hdlr(KEY_EVENT_DOWN, Keycode);
	}
}

static void mmi_camera_key_up_hdlr(U16 Keycode)
{
	const camera_key_struct *pkey = mmi_camera_get_key(Keycode);

	//kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: mmi_camera_key_up_hdlr,line = %d",__LINE__); 		 

	if(g_camera_cntx.pressed_key != Keycode)
	{
		return;
	}
	g_camera_cntx.pressed_key = KEY_INVALID;

	if(pkey){
		if(pkey->flag & MMI_CAMERA_KE_FLAG_SW){
			//kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: mmi_camera_key_up_hdlr,line = %d",__LINE__);			 
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
			if(Keycode == KEY_UP_ARROW || Keycode == KEY_DOWN_ARROW)
			{
				mmi_camera_preview_draw_buttons();
			}
			else
			{		
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
				mmi_camera_preview_draw_softkey();
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__

			}

#endif // __CAMERA_FEATURE_DRAW_BUTTONS__

#else
			mmi_camera_preview_draw_osd();
#endif
			mmi_camera_blt();
		} 

		if(pkey->up){
			pkey->up();
		}
	}

}

static void mmi_camera_key_half_down_hdlr(U16 Keycode)
{
}

static void mmi_camera_key_half_up_hdlr(U16 Keycode)
{
#ifdef __CAMERA_AUTOFOCUS__
	if(Keycode == CAMERA_CAPTURE_KEY){
		if(g_camera_cntx.is_autofocus_pressed == TRUE){
			mmi_camera_capture_button_autofocus_released();
		}
	}
#endif /* __CAMERA_AUTOFOCUS__ */ 

}


static mmi_ret mmi_camera_scrn_key_proc(mmi_event_struct *evt)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mmi_frm_key_evt_struct *key_evt = (mmi_frm_key_evt_struct*)evt;
	U16 keyCode = key_evt->key_code;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if(mmi_frm_scrn_get_active_id() != SCR_ID_CAMERA_APP && mmi_frm_scrn_get_active_id()!= SCR_ID_CAMERA_EXTERNAL_REQUESET_SCREEN){
		//log
		//kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: mmi_camera_scrn_key_proc,line = %d",__LINE__);
		//kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: mmi_camera_scrn_key_proc,key = %d,state = %d",keyCode,key_evt->key_type);	
		return MMI_RET_OK;
	}
#ifdef __CAMERA_FEATURE_CONT_SHOT__ 
	else
	{
		if(g_camera_cntx.app_state == CAMERA_STATE_CONTSHOT)
		{
			return MMI_RET_OK;
		}
	}
#endif
	if (evt->evt_id == EVT_ID_ON_KEY)
	{
		/* ignore sys keys */
		if (keyCode == KEY_END || keyCode == KEY_POWER)
			return MMI_RET_OK;

		if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_90 || g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
		{
			switch(keyCode)
			{
			case KEY_DOWN_ARROW:
				keyCode = KEY_RIGHT_ARROW;
				break;
			case KEY_UP_ARROW:
				keyCode = KEY_LEFT_ARROW;
				break;
			case KEY_LEFT_ARROW:
				keyCode = KEY_DOWN_ARROW;
				break;
			case KEY_RIGHT_ARROW:
				keyCode = KEY_UP_ARROW;
				break;
			};
		}

		if(key_evt->key_type == KEY_EVENT_DOWN)
		{
			/* Stop Watchdog */
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__

#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_STOP_APP_WATCHDOG();
#else
			mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif
#endif
			/* Record down key */
			mmi_camera_key_down_hdlr(keyCode);
		}
		else if(key_evt->key_type == KEY_EVENT_UP)
		{
			/* Clear down key */
			mmi_camera_key_up_hdlr(keyCode);
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
			mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__

#endif
			/* Start Watchdog */
		}
		else if(key_evt->key_type == KEY_HALF_PRESS_DOWN)
		{
			mmi_camera_key_half_down_hdlr(keyCode);
		}
		else if(key_evt->key_type == KEY_HALF_PRESS_UP)
		{
			mmi_camera_key_half_up_hdlr(keyCode);
		}

		return MMI_RET_KEY_HANDLED;

	}
	return MMI_RET_OK;

}
#endif /*CAMERA_KEY_MOD*/



#if defined(__CAMERA_FEATURE_STORAGE__)

static MMI_BOOL mmi_camera_check_storage(void)
{
	if (SRV_FMGR_PUBLIC_DRV == SRV_FMGR_CARD_DRV || SRV_FMGR_PUBLIC_DRV == FS_DRIVE_NOT_FOUND)
	{
		/* only memory card but plugout, need show popup*/
		if (FS_NO_ERROR != FS_GetDevStatus(SRV_FMGR_CARD_DRV ,FS_MOUNT_STATE_ENUM))
		{
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP((STR_GLOBAL_INSERT_MEMORY_CARD), MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
			mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_INSERT_MEMORY_CARD), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
				(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif

			return MMI_FALSE ;
		}
	}
}
#endif

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_app_screen_internal
* DESCRIPTION
*  entry camera application screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_app_screen_internal(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_ID scrn_id;
	U8 *guiBuffer;
	S32 ret;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTRY_APP_SCREEN_INTERNAL,g_camera_cntx.app_state);
	if (g_camera_cntx.captured_filepath != NULL && CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
		ret = FS_Open((const WCHAR *)g_camera_cntx.captured_filepath, FS_READ_ONLY);
		if (ret < 0)
		{
#ifndef __MMI_CAMERA_SLIM__
			CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
#else
			camera_enter_state(CAMERA_STATE_EXIT);
#endif
		}
		FS_Close(ret);
	}//g_camera_cntx.captured_filepath != NULL && CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO)

	/* debug info */
	CAMERA_TRACE_FUNC_ENTER_APP();
	if (!CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
		CAMERA_CHECK_STATE(CAMERA_STATE_EXIT);


	/* if clam is opened and not enter from camera option menu */
	if (mmi_frm_scrn_get_active_id() != SCR_ID_CAMERA_OPTION && g_camera_cntx.is_clam_close == FALSE)
	{
		/* reset force enter sub flag */
		g_camera_cntx.is_force_self_capture = FALSE;
	}
	if (mmi_is_redrawing_bk_screens() == MMI_FALSE)
	{
		if(mmi_camera_entry_app_pre_check() == MMI_FALSE)
		{
			return;
		}
	}

	/************ entry screen ************/
	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		scrn_id = SCR_ID_CAMERA_APP;
	}
	else
	{
		scrn_id = SCR_ID_CAMERA_EXTERNAL_REQUESET_SCREEN;
	}

	if (!mmi_frm_scrn_enter (g_camera_cntx.cur_gid, scrn_id, 
		mmi_camera_exit_app_screen, 
		mmi_camera_entry_app_screen_internal, 
		MMI_FRM_UNKNOW_SCRN))
	{
		return;
	}
	guiBuffer = mmi_frm_scrn_get_gui_buf(g_camera_cntx.cur_gid, scrn_id);

#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
	
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_CREATE_WATCHDOGS();
#else // __MMI_CAMERA_SLIM__
	mmi_camera_create_watchdogs();
#endif // __MMI_CAMERA_SLIM__
	
#endif

	mmi_frm_scrn_set_key_proc(g_camera_cntx.cur_gid, scrn_id, mmi_camera_scrn_key_proc);
	mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

#ifdef __MMI_SCREEN_SWITCH_EFFECT__    /* disable SSE */
	gui_screen_switch_effect_block(MMI_TRUE);
#endif

#ifdef __MMI_VECTOR_FONT_SUPPORT__
	mmi_fe_set_antialias(MMI_FALSE);
#endif

	/* check if there is small screen above camera */
	if (mmi_is_redrawing_bk_screens() == TRUE && CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
		/* only when cascading menu is current screen and in forward state, we will need to draw bg for small screen*/
		mmi_camera_preview_free_resource();
		mmi_camera_preview_create_resource();
		mmi_camera_entry_delete_confirm_state();
		return;
	}
	else if (mmi_is_redrawing_bk_screens() == TRUE)
	{
		GDI_HANDLE base_layer;

		gdi_layer_get_base_handle(&base_layer);
		mmi_camera_restore_layer(base_layer);
		return;
	}


#if defined(__CAMERA_FEATURE_STORAGE__)

	/*No phone storage*/
	// mmi_camera_check_storage();

	/* if (SRV_FMGR_PUBLIC_DRV == SRV_FMGR_CARD_DRV || SRV_FMGR_PUBLIC_DRV == FS_DRIVE_NOT_FOUND)
	{
	// only memory card but plugout, need show popup
	if (FS_NO_ERROR != FS_GetDevStatus(SRV_FMGR_CARD_DRV ,FS_MOUNT_STATE_ENUM))
	{
	#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_DISPLAY_POPUP((STR_GLOBAL_INSERT_MEMORY_CARD), MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
	#else
	mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_INSERT_MEMORY_CARD), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
	(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
	#endif

	return;
	}
	}*/

	//if storage is not ready, entry select storage screen 
	/*
	{
	WCHAR buf_filepath[SRV_FMGR_PATH_BUFFER_SIZE/2];
	S32 create_result;

	create_result = mmi_imgview_get_storage_file_path((WCHAR*)buf_filepath);//mmi_imgview_create_file_dir(storage_filepath);
	if (create_result < 0)
	{
	if (SRV_FMGR_PUBLIC_DRV == SRV_FMGR_CARD_DRV)
	{
	#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_DISPLAY_POPUP(srv_fmgr_fs_error_get_string(create_result), MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
	#else
	mmi_camera_display_popup(((MMI_ID_TYPE)srv_fmgr_fs_error_get_string(create_result)), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
	(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
	#endif
	}else{
	mmi_camera_entry_storage_screen();
	}
	return;
	}
	}*/
#endif

	/* Disable HW mute for capture performance degrate issues: MAUI_01280858 */
	mdi_audio_set_hw_mute(MMI_FALSE);


	/* each time newly enter camera, zoom will be reset to default */
	if (!guiBuffer)
	{
		g_camera_cntx.setting.zoom_idx = CAMERA_DEFAULT_SETTING_ZOOM_IDX;
	}

	/************ init/config framework's environment  ************/
	mmi_camera_init_framework();

	/************ pre-init camera app environment ************
	* 1. init some flag before power on camera
	* 2. check storage 
	********************************************************/
	mmi_camera_pre_init_app();


	if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED 
#if defined(__MMI_CAMERA_BG_CALL__)
		&& srv_ucm_is_background_call()==FALSE
#endif
		)
	{
		/* Power on and init hardware module */
		g_camera_cntx.last_error = mdi_camera_power_on(g_camera_cntx.cur_gid);
	}

	/************ post-init camera app environment ************
	* no matter power on success or not, have to do post init
	*********************************************************/
	mmi_camera_post_init_app();

	/************ enter next state ************/
	if (CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_DELETE_CONFIRM);
#else
		camera_enter_state(CAMERA_STATE_DELETE_CONFIRM);
#endif

		/* if there is error happend before entering delete confirm state from forward to, 
		popup error and reset camera state */
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			mmi_camera_preview_flatten_layer(FALSE);
			mmi_camera_display_error_popup();
#ifndef __MMI_CAMERA_SLIM__
			CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
#else
			camera_enter_state(CAMERA_STATE_EXIT);
#endif
			return;
		}

	}
	else if ((g_camera_cntx.is_force_self_capture) && (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED))  /* no error, if has error, will enter main then show error popup */
	{
		/* force to enter sublcd preview from option menu */
#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
		g_camera_cntx.is_force_self_capture = FALSE;
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_SUB_PREVIEW);
#endif
#else 
		MMI_ASSERT(0);
#endif
	}
	else
	{
		/* entry preview */
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_PREVIEW);
#endif
	}

	if (g_camera_cntx.app_state != CAMERA_STATE_EXIT)
	{
#if defined(__MMI_TOUCH_SCREEN__)
		wgui_register_pen_down_handler(mmi_camera_touch_scr_pen_down_hdlr);
		wgui_register_pen_up_handler(mmi_camera_touch_scr_pen_up_hdlr);
		wgui_register_pen_move_handler(mmi_camera_touch_scr_pen_move_hdlr);
		if (g_camera_cntx.app_state != CAMERA_STATE_DELETE_CONFIRM)
			{
			wgui_register_pen_long_tap_handler(mmi_camera_entry_option_menu_screen);
			}
#endif /*__MMI_TOUCH_SCREEN__ */ 
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_app_screen
* DESCRIPTION
*  exit camera application screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_app_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

    PU8 layer_buf_ptr = NULL;
	U32 layer_buf_size = 0;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EXIT_APP_SCREEN);
	/* print debug info */
	CAMERA_TRACE_FUNC_EXIT_APP();
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	#if defined(__MTK_TARGET__)
	kal_cancel_timer(resz_cp_ESD_timeout_timer);
	gui_cancel_timer(mmi_camera_app_reset_watchdog_callback);
    #endif
#endif

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
	if(g_camera_cntx.is_enable_PQ)
	{
		mdi_camera_color_engine_disable();
		mdi_camera_color_engine_close();
		g_camera_cntx.is_enable_PQ = FALSE;
	}


	/* exit camera state */
	if (!CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
#else
		camera_enter_state(CAMERA_STATE_EXIT);
#endif
	}    

#ifdef __MMI_VECTOR_FONT_SUPPORT__
	mmi_fe_set_antialias(MMI_TRUE);
#endif


#if defined(MMI_CAMERA_CHECK_BEARER)
#if defined(__TCPIP__)
	srv_cbm_allow_nwk_srv(SRV_CBM_BEARER_GPRS, g_camera_cntx.cbm_app_id);
	cbm_deregister_app_id(g_camera_cntx.cbm_app_id);
	g_camera_cntx.cbm_app_id = 0xff;
#endif
#endif

	/* Enable HW mute when exiting camera application: MAUI_01280858 */
	mdi_audio_set_hw_mute(MMI_TRUE);

	/* stop capture and stop dummy bg midi for multi-channel sound */
#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)
	mmi_camera_burstshot_close_multi_sound();
	gui_cancel_timer(mmi_camera_burstshot_close_multi_sound);
#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

	/* reset af related var */
#if defined(__CAMERA_AUTOFOCUS__)
	/* !IMPORTANT! Manual focus should not be turned on, it is not a matual function */
	if (g_camera_cntx.af_state != AF_CANCEL)
	{
		mdi_camera_stop_autofocus_process();
		g_camera_cntx.af_state = AF_CANCEL;
	}
#endif /* defined(__CAMERA_AUTOFOCUS__) */ 

#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__

#ifndef __MMI_CAMERA_SLIM__


	MMI_CAMERA_DELETE_WATCHDOGS();


#else // __MMI_CAMERA_SLIM__


	mmi_camera_delete_watchdogs();
#endif // __MMI_CAMERA_SLIM__


#endif

	/* stop hide hint timer */
	gui_cancel_timer(mmi_camera_preview_hide_hint);
#ifdef __CAMERA_FEATURE_EV__
	gui_cancel_timer((FuncPtr)mmi_camera_preview_ev_cyclic);
#endif


	/* turn on/of 3D sound */
#ifdef __MMI_AUDIO_REVERB_EFFECT__
	if (g_camera_cntx.is_3d_sound_on == TRUE)
	{
		mdi_audio_reverb_turn_on();
	}
#endif /* __MMI_AUDIO_REVERB_EFFECT__ */ 

	if (g_camera_cntx.is_preview_started == MMI_TRUE)
	{
		mmi_camera_preview_stop();
	}

	/* shut down camera */
	mdi_camera_power_off();

	/* resume alignment timer */
	UI_enable_alignment_timers();

	/* resume LED patten */
	srv_gpio_play_pattern((srv_gpio_pattern_id_enum)srv_led_pattern_get_bg_pattern(), SRV_GPIO_PATN_PLAY_START);

	/* let MMI can sleep */
	srv_backlight_turn_off();

	/* enable multi-layer */
	gdi_layer_multi_layer_disable();

	/* resume background audio */
	mdi_audio_resume_background_play();

	/* re-enable keypad tone */
	mmi_frm_kbd_set_tone_state(MMI_KEY_TONE_ENABLED);

	gdi_lcd_set_te_ctrl((kal_bool)g_camera_cntx.ori_te_ctrl);

#ifdef __MMI_SUBLCD__
	if (g_camera_cntx.sublcd_base_layer_handle != NULL)
	{
		gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
		gdi_layer_set_rotate(CAMERA_LCM_ROTATE_0);
		gdi_layer_pop_and_restore_active();
	}
	/* exit sublcd */
	if (g_camera_cntx.is_sublcd_display)
	{
		GoBackSubLCDHistory();
		g_camera_cntx.is_sublcd_display = FALSE;
	}
#endif /* __MMI_SUBLCD__ */ 

	/* reset lcd set by layer flag */
	gdi_lcd_set_rotate_by_layer(FALSE);

	/* free preview resource */
	mmi_camera_preview_free_resource();
	mmi_camera_preview_free_preview_resource();

	{   
		// use base layer as background
		gdi_layer_get_base_handle(&g_camera_cntx.base_layer_handle);

		if (CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
		{
#ifdef __CAMERA_OSD_HORIZONTAL__
			if (g_camera_cntx.osd_data.osd_rotate == GDI_LAYER_ROTATE_90 || g_camera_cntx.osd_data.osd_rotate == GDI_LAYER_ROTATE_270)
			{
#ifdef __MMI_SCREEN_ROTATE__
				gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
				gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
				gdi_layer_pop_and_restore_active();
#else
				if (g_camera_cntx.gdi_layer_handle == NULL)
				{
					
				    #ifndef __GDI_MEMORY_PROFILE_2__
				    layer_buf_size = (LCD_WIDTH *LCD_HEIGHT*GDI_MAINLCD_BIT_PER_PIXEL)>>3;
					layer_buf_ptr = mmi_frm_scrmem_alloc_framebuffer(layer_buf_size);
					
					 gdi_layer_create_cf_using_outside_memory(
		             GDI_COLOR_FORMAT_16,
		             0,
		             0,
		             LCD_WIDTH,
		             LCD_HEIGHT,
		             &g_camera_cntx.gdi_layer_handle,
		             layer_buf_ptr,
		             (S32)layer_buf_size);
                     #else
					 gdi_layer_create(0, 0, LCD_WIDTH, LCD_HEIGHT, &g_camera_cntx.gdi_layer_handle);
                     #endif
					
				}
				mmi_camera_restore_layer(g_camera_cntx.gdi_layer_handle);
				mdi_util_rotate_osd_for_hw_rotator(g_camera_cntx.base_layer_handle, g_camera_cntx.gdi_layer_handle);
				mmi_camera_restore_layer(g_camera_cntx.base_layer_handle);
				gdi_layer_flatten_to_base(g_camera_cntx.gdi_layer_handle, 0, 0, 0);
#endif
			}
#endif
		}
		else
		{
			mmi_camera_restore_layer(g_camera_cntx.base_layer_handle);
		}
	}
	
	if (g_camera_cntx.gdi_layer_handle != GDI_NULL_HANDLE)
	{
		gdi_layer_free(g_camera_cntx.gdi_layer_handle);
		g_camera_cntx.gdi_layer_handle = NULL;
		
		if(layer_buf_ptr != NULL)
			{
		mmi_frm_scrmem_free((void*)layer_buf_ptr);
		layer_buf_ptr = NULL;
			}
	}
	/* steal done */

#if 0
#ifdef __MDI_DISPLAY_YUYV422_SUPPORT__ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

	/* store camera setting back to NVRAM */
	mmi_camera_store_setting();
	
	mmi_camera_resume_blt();
	/* this will force title status to redraw */
	entry_full_screen();

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

#if defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) 
	/* unregister event hdlr */
	mmi_frm_cb_dereg_event(EVT_ID_PRE_PROTOCOL, mmi_camera_clam_close_event_hdlr, NULL);
#endif /* defined(__MMI_CLAMSHELL__) && !defined(__MMI_SLIDE__) */ 

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_enter_state
* DESCRIPTION
*  enter next state
* PARAMETERS
*  state       [IN]        State to enter
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_enter_state(camera_state_enum state)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_STATE,g_camera_cntx.app_state,state);
	g_camera_cntx.app_prev_state = g_camera_cntx.app_state;
	g_camera_cntx.app_state = state;
	switch (state)
	{
	case CAMERA_STATE_EXIT:
		/* do nothing */
		break;

		/* main lcd */
	case CAMERA_STATE_PREVIEW:
		mmi_camera_entry_preview_state();
		break;

	case CAMERA_STATE_COUNTDOWN:
		mmi_camera_entry_countdown_state();
		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT__        
	case CAMERA_STATE_CONTSHOT:
		mmi_camera_entry_contshot_state();
		break;
#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__

	case CAMERA_STATE_BURSTSHOT:
		mmi_camera_entry_burstshot_capture_state();
		break;

	case CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM:
		mmi_camera_entry_burstshot_save_confirm_state();
		break;

	case CAMERA_STATE_BURSTSHOT_SAVING:
		mmi_camera_entry_burstshot_saving_state();
		break;

#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	case CAMERA_STATE_DELETE_DONE:
		mmi_camera_entry_delete_done_state();
		break;

	case CAMERA_STATE_DELETE_CONFIRM:
		mmi_camera_entry_delete_confirm_state();
		break;

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__

		/* toggle popup */
	case CAMERA_STATE_TOGGLE_TO_SUB:
		mmi_camera_entry_toggle_to_sub_state();
		break;

	case CAMERA_STATE_TOGGLE_TO_MAIN:
		mmi_camera_entry_toggle_to_main_state();
		break;

		/* sub lcd */
	case CAMERA_STATE_SUB_PREVIEW:
		mmi_camera_entry_sublcd_preview_state();
		break;

	case CAMERA_STATE_SUB_COUNTDOWN:
		mmi_camera_entry_sublcd_countdown_state();
		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT__        
	case CAMERA_STATE_SUB_CONTSHOT:
		mmi_camera_entry_sublcd_contshot_state();
		break;
#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	case CAMERA_STATE_SUB_BURSTSHOT:
		mmi_camera_entry_sublcd_burstshot_state();
		break;

	case CAMERA_STATE_SUB_BURSTSHOT_SAVING:
		mmi_camera_entry_sublcd_burstshot_saving_state();
		break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

	}
}

#ifdef __MMI_CAMERA_SLIM__

static void camera_enter_state(camera_state_enum state)
{
	CAMERA_TRACE_EXIT_STATE();			   
	g_camera_cntx.app_next_state = state;
	mmi_camera_exit_current_state(); 	  
	CAMERA_TRACE_ENTER_STATE();			  
	mmi_camera_enter_state(state); 

}
#endif
/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_current_state
* DESCRIPTION
*  exit camera current state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_current_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (g_camera_cntx.app_state)
	{
	case CAMERA_STATE_EXIT:
		/* do nothing */
		break;

		/* main lcd */
	case CAMERA_STATE_PREVIEW:
		mmi_camera_exit_preview_state();
		break;

	case CAMERA_STATE_COUNTDOWN:
		mmi_camera_exit_countdown_state();
		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT__        
	case CAMERA_STATE_CONTSHOT:
		mmi_camera_exit_contshot_state();
		break;
#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__

	case CAMERA_STATE_BURSTSHOT:
		mmi_camera_exit_burstshot_capture_state();
		break;

	case CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM:
		mmi_camera_exit_burstshot_save_confirm_state();
		break;

	case CAMERA_STATE_BURSTSHOT_SAVING:
		mmi_camera_exit_burstshot_saving_state();
		break;

#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	case CAMERA_STATE_DELETE_DONE:
		mmi_camera_exit_delete_done_state();
		break;

	case CAMERA_STATE_DELETE_CONFIRM:
		mmi_camera_exit_delete_confirm_state();
		break;

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__

		/* toggle popup */
	case CAMERA_STATE_TOGGLE_TO_SUB:
		mmi_camera_exit_toggle_to_sub_state();
		break;

	case CAMERA_STATE_TOGGLE_TO_MAIN:
		mmi_camera_exit_toggle_to_main_state();
		break;

		/* sub lcd */
	case CAMERA_STATE_SUB_PREVIEW:
		mmi_camera_exit_sublcd_preview_state();
		break;

	case CAMERA_STATE_SUB_COUNTDOWN:
		mmi_camera_exit_sublcd_countdown_state();
		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT__        
	case CAMERA_STATE_SUB_CONTSHOT:
		mmi_camera_exit_sublcd_contshot_state();
		break;
#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	case CAMERA_STATE_SUB_BURSTSHOT:
		mmi_camera_exit_sublcd_burstshot_state();
		break;

	case CAMERA_STATE_SUB_BURSTSHOT_SAVING:
		mmi_camera_exit_sublcd_burstshot_saving_state();
		break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

	}
}


#ifdef __CAMERA_FEATURE_REMAIN_STORAGE__
/*****************************************************************************
* FUNCTION
*  mmi_camera_get_storage_disk_path
* DESCRIPTION
*  get current active storage disk path.
* PARAMETERS
*  drv_buf     [IN]        
*  a(?)        [OUT]       Fill disk's name string.
* RETURNS
*  void
*****************************************************************************/
static BOOL mmi_camera_get_storage_disk_path(CHAR *  drv_buf)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	CHAR buf[64];
	U16 storage;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	storage = mmi_imgview_get_storage();

	if (FS_NO_ERROR == FS_GetDevStatus(storage ,FS_MOUNT_STATE_ENUM))
	{
		sprintf(buf, "%c:\\", (U8)storage );
		mmi_asc_to_ucs2(drv_buf, buf);
		return TRUE;
	}
	else
	{
		return FALSE;
	}   
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_calc_remain_storage
* DESCRIPTION
*  calculate remain storage precent
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_calc_remain_storage(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	FS_DiskInfo disk_info;
	CHAR disk_path[10];
	U32 disk_free_space;
	U32 disk_total_space;
	S32 fs_ret;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* Get disk name, calculate available disk space */
	//memset(disk_path, 0, sizeof(disk_path));

	if (FALSE == mmi_camera_get_storage_disk_path(disk_path))
	{
		g_camera_cntx.remain_percent = 0;
	}
	else
	{
		fs_ret = FS_GetDiskInfo((kal_uint16*) disk_path, &disk_info, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE);

		g_camera_cntx.remain_percent = 0;

		if (fs_ret >= 0)
		{
			disk_free_space = disk_info.FreeClusters;
			disk_total_space = disk_info.TotalClusters;

			if (disk_total_space > 0)
			{
				g_camera_cntx.remain_percent = (U8) (disk_free_space * 100 / disk_total_space);
			}
			else
			{
				g_camera_cntx.remain_percent = 0;
			}
		}
	}
}

#endif  /*__CAMERA_FEATURE_REMAIN_STORAGE__*/

/*****************************************************************************
* FUNCTION
*  mmi_camera_toggle_hide_osd
* DESCRIPTION
*  toggle hide osd
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_toggle_hide_osd(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.is_hide_osd = (g_camera_cntx.is_hide_osd) ? FALSE : TRUE;
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
}



/*****************************************************************************
* FUNCTION
*  mmi_camera_turn_on_preview_led_highlight
* DESCRIPTION
*  turn on preview led highlght
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_turn_on_preview_led_highlight(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U8 duty;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	duty = (U8) g_camera_cntx.setting.preview_led_value;

	if (duty == 0)
	{
		custom_stop_flashlight();
		return;
	}

#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_7_COLOR__
	switch (g_camera_cntx.setting.led_highlight)
	{
	case CAMERA_SETTING_LED_HIGHLIGHT_WHITE:
		custom_start_flashlight(1, 1, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_RED:
		custom_start_flashlight(1, 0, 0, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_GREEN:
		custom_start_flashlight(0, 1, 0, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_BLUE:
		custom_start_flashlight(0, 0, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_YELLOW:
		custom_start_flashlight(1, 1, 0, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_PURPLE:
		custom_start_flashlight(1, 0, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_CYAN:
		custom_start_flashlight(0, 1, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_OFF:
		custom_stop_flashlight();
		break;

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;
	}
#endif /* __CAMERA_FEATURE_LED_HIGHLIGHT_7_COLOR__ */ 

#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__
	switch (g_camera_cntx.setting.led_highlight)
	{
	case CAMERA_SETTING_LED_HIGHLIGHT_ON:
		custom_start_flashlight(1, 1, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_OFF:
		custom_stop_flashlight();
		break;

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;
	}
#endif /* __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__ */ 

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_turn_on_capture_led_highlight
* DESCRIPTION
*  turn on preview led highlght
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_turn_on_capture_led_highlight(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U8 duty;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	duty = (U8) g_camera_cntx.setting.capture_led_value;

	if (duty == 0)
	{
		custom_stop_flashlight();
		return;
	}

#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_7_COLOR__
	switch (g_camera_cntx.setting.led_highlight)
	{
	case CAMERA_SETTING_LED_HIGHLIGHT_WHITE:
		custom_start_flashlight(1, 1, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_RED:
		custom_start_flashlight(1, 0, 0, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_GREEN:
		custom_start_flashlight(0, 1, 0, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_BLUE:
		custom_start_flashlight(0, 0, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_YELLOW:
		custom_start_flashlight(1, 1, 0, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_PURPLE:
		custom_start_flashlight(1, 0, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_CYAN:
		custom_start_flashlight(0, 1, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_OFF:
		custom_stop_flashlight();
		break;

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;
	}
#endif /* __CAMERA_FEATURE_LED_HIGHLIGHT_7_COLOR__ */ 

#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__
	switch (g_camera_cntx.setting.led_highlight)
	{
	case CAMERA_SETTING_LED_HIGHLIGHT_ON:
		custom_start_flashlight(1, 1, 1, duty);
		break;

	case CAMERA_SETTING_LED_HIGHLIGHT_OFF:
		custom_stop_flashlight();
		break;

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;
	}
#endif /* __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__ */ 

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_turn_off_led_highlight
* DESCRIPTION
*  turn off preview led highlght
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_turn_off_led_highlight(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	custom_stop_flashlight();
}

/*****************************************************************************
*
*  Camera Main LCD Preview State
*
*****************************************************************************/
#ifdef __MMI_CAMERA_SLIM__

static void mmi_camera_init_title_bar(void)
{
	if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_title_bar)
	{
#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		reset_title_status_icon();
		wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif /* defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__) */ 

		/* hide short cut */
		wgui_title_set_menu_shortcut_number(-1);

		if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_caption)
		{
			ChangeTitle(MAIN_MENU_TITLE_MULTIMEDIA_ICON, (PU8) GetString(STR_ID_CAMERA_APP_NAME));
		}
		else
		{
			ChangeTitle(0, (PU8) GetString(STR_ID_CAMERA_APP_NAME));
		}
	}
	else
	{
#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif 
	}

}
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
static void mmi_camera_create_osd_layer(void)
{
	if (g_camera_cntx.osd_layer_buf_ptr0 == NULL )
	{

		g_camera_cntx.osd_layer_buf_ptr0 = mmi_frm_scrmem_alloc_framebuffer(CAMERA_OSD_BUFFER_SIZE);
		ASSERT(g_camera_cntx.osd_layer_buf_ptr0 != NULL);
	}

	gdi_layer_create_cf_double_using_outside_memory(
		GDI_COLOR_FORMAT_16,
		0,
		0,
		LCD_WIDTH,
		LCD_HEIGHT,
		&g_camera_cntx.osd_layer_handle,
		(PU8) g_camera_cntx.osd_layer_buf_ptr0,
		(S32) CAMERA_OSD_BUFFER_SIZE,
		(PU8) g_camera_cntx.osd_buf_p, 
		(S32) CAMERA_OSD_BUFFER_SIZE);

	gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
	gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
	gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
	gdi_layer_pop_and_restore_active();

}
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__

#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__


static void mmi_camera_rotate_osd_region_layer(U8 osd_region_id)
{
	gdi_handle layer_handle = g_camera_cntx.osd_layer_region_handle[osd_region_id];
	gdi_handle idp_layer_handle = g_camera_cntx.osd_idp_layer_region_handle[osd_region_id];

	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		mmi_camera_clear_osd_layer(layer_handle);
		mdi_util_rotate_osd_for_hw_rotator(idp_layer_handle, layer_handle);
	}  
	mmi_camera_clear_osd_layer(idp_layer_handle);
}


static void mmi_camera_select_osd_region_layer(U8 osd_region_id)
{
	gdi_handle layer_handle;

#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)
	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		layer_handle = g_camera_cntx.osd_idp_layer_region_handle[osd_region_id];
	}
	else
#endif //defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)
	{
		layer_handle = g_camera_cntx.osd_layer_region_handle[osd_region_id];
	}
	mmi_camera_clear_osd_layer(layer_handle);
	gdi_layer_push_and_set_active(layer_handle);
}

static void mmi_camera_clear_osd_layer(gdi_handle layer_handle)
{

	gdi_layer_push_and_set_active(layer_handle);
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
	if(layer_handle == g_camera_cntx.osd_layer_region_handle[CAMERA_BUTTON_REGION])
		gdi_layer_toggle_double();
#endif
	gdi_layer_clear(GDI_COLOR_TRANSPARENT);
	gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
	gdi_set_alpha_blending_source_layer(layer_handle);
	gdi_layer_pop_and_restore_active();	
}

static void mmi_camera_create_osd_region_layers()
{
	U8 i;

	for ( i = 0; i < CAMERA_OSD_REGION_MAX; i++)
		if(g_camera_cntx.osd_layer_region_handle[i] == GDI_LAYER_EMPTY_HANDLE)
			mmi_camera_create_osd_region_layer(i);
}


static void mmi_camera_create_osd_region_layer(U8 osd_region_id)
{

	U32 buf_size;
	S16 layer_width, layer_height, layer_offset_x, layer_offset_y;


	camera_osd_region_struct osd_region = g_camera_cntx.active_camera_osd_ptr->osd_region[osd_region_id];
	ASSERT( 0 <= osd_region_id < CAMERA_OSD_REGION_MAX );

#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)
	if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		layer_offset_x = LCD_WIDTH - osd_region.height - osd_region.offset_y;
		layer_offset_y =  osd_region.offset_x;
		layer_width = osd_region.height;
		layer_height = osd_region.width;
	}
	else
 #endif
	{
		layer_offset_x = osd_region.offset_x;
		layer_offset_y = osd_region.offset_y;
		layer_width = osd_region.width;
		layer_height= osd_region.height;
	}

	buf_size = (((layer_width*layer_height*GDI_MAINLCD_BIT_PER_PIXEL)>>3));

	g_camera_cntx.osd_layer_region_handle_ptr[osd_region_id] = mmi_frm_scrmem_alloc_framebuffer(buf_size); 
	ASSERT( g_camera_cntx.osd_layer_region_handle_ptr[osd_region_id] != NULL );

#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
	if(osd_region_id == CAMERA_BUTTON_REGION)
	{
		g_camera_cntx.osd_layer_region_handle_ptr2 = mmi_frm_scrmem_alloc_framebuffer(buf_size);
		ASSERT( g_camera_cntx.osd_layer_region_handle_ptr2!= NULL );
		gdi_layer_create_cf_double_using_outside_memory(
			GDI_COLOR_FORMAT_16,
			layer_offset_x,
			layer_offset_y,
			layer_width,
			layer_height,
			&g_camera_cntx.osd_layer_region_handle[osd_region_id],
			(PU8)g_camera_cntx.osd_layer_region_handle_ptr[osd_region_id],
			(S32)buf_size,
			(PU8)g_camera_cntx.osd_layer_region_handle_ptr2,
			(S32)buf_size);
	}
	else
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
		gdi_layer_create_cf_using_outside_memory(
		GDI_COLOR_FORMAT_16,
		layer_offset_x,
		layer_offset_y,
		layer_width,
		layer_height,
		&g_camera_cntx.osd_layer_region_handle[osd_region_id],
		g_camera_cntx.osd_layer_region_handle_ptr[osd_region_id],
		(S32)buf_size);



	mmi_camera_clear_osd_layer(g_camera_cntx.osd_layer_region_handle[osd_region_id]);

#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__)

	/* get buffer from diffent source */
	g_camera_cntx.osd_idp_layer_region_handle_ptr[osd_region_id]
	= (PU8) mmi_frm_scrmem_alloc_framebuffer(buf_size); ; 
	ASSERT( g_camera_cntx.osd_layer_region_handle_ptr[osd_region_id] != NULL );

	/* get temp layer handle */	            
	gdi_layer_create_using_outside_memory(
		osd_region.offset_x,
		osd_region.offset_y,
		osd_region.width,        
		osd_region.height,        
		&g_camera_cntx.osd_idp_layer_region_handle[osd_region_id],   
		g_camera_cntx.osd_idp_layer_region_handle_ptr[osd_region_id],
		(S32)buf_size);

	/* clear temp buffer */
	mmi_camera_clear_osd_layer(g_camera_cntx.osd_idp_layer_region_handle[osd_region_id]);
#endif

}
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
#endif //__MMI_CAMERA_SLIM__

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_preview_state
* DESCRIPTION
*  entry mainlcd preview state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_preview_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	//PU8 temp_buf;

#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_PREVIEW_STATE);
	/************ init global var ************/
	g_camera_cntx.is_clam_close = FALSE;
	g_camera_cntx.is_capturing = FALSE;
	g_camera_cntx.is_fast_zoom = FALSE;
	g_camera_cntx.is_draw_timer_on = FALSE;

	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
	if(g_camera_cntx.is_enable_PQ)
	{
		mdi_camera_color_engine_disable();
		mdi_camera_color_engine_close();
		g_camera_cntx.is_enable_PQ = FALSE;
	}

	/************ osd layer ************/
	/*currently in order to save memory, we will steal GDI memory, 
	NOTE : we only use the memory, but do not use the handle */
	if (g_camera_cntx.gdi_layer_handle == GDI_NULL_HANDLE)
	{
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
		mmi_camera_use_gdi_layer();
		if (g_camera_cntx.osd_layer_handle != NULL)
		{
			gdi_layer_free(g_camera_cntx.osd_layer_handle);
			g_camera_cntx.osd_layer_handle = NULL;

			mmi_frm_scrmem_free((void*)g_camera_cntx.osd_layer_buf_ptr0);
			g_camera_cntx.osd_layer_buf_ptr0 = NULL;
		}
#endif
	}
	/* steal done */
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	if (g_camera_cntx.osd_layer_handle == NULL)
	{   
		/* create a double layer frame from outside memory */
#ifndef __MMI_CAMERA_SLIM__
		g_camera_cntx.osd_layer_buf_ptr0 = mmi_frm_scrmem_alloc_framebuffer(CAMERA_OSD_BUFFER_SIZE);
		ASSERT(g_camera_cntx.osd_layer_buf_ptr0 != NULL);

		gdi_layer_create_cf_double_using_outside_memory(
			GDI_COLOR_FORMAT_16,
			0,
			0,
			LCD_WIDTH,
			LCD_HEIGHT,
			&g_camera_cntx.osd_layer_handle,
			(PU8) g_camera_cntx.osd_layer_buf_ptr0,
			(S32) CAMERA_OSD_BUFFER_SIZE,
			(PU8) g_camera_cntx.osd_buf_p, 
			(S32) CAMERA_OSD_BUFFER_SIZE);

		gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
		gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
		gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
		gdi_layer_pop_and_restore_active();
#else
		mmi_camera_create_osd_layer();
#endif //__MMI_CAMERA_SLIM__
	}
#endif//__MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_REMAIN_STORAGE__
	/* calculate remain storage */
	mmi_camera_calc_remain_storage();
#endif /* __CAMERA_FEATURE_REMAIN_STORAGE__ */

	/* update preview/capture size para */
	mmi_camera_preview_update_capture_size();

#if defined(__CAMERA_OSD_HORIZONTAL__)
	g_camera_cntx.osd_data.previous_osd_rotate = CAMERA_DISPLAY_ROTATE_RESET;
	mmi_camera_check_osd_orientation();
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_create_osd_region_layers();
#endif    
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);
#endif 

#ifdef __MMI_SUBLCD__
	/* draw sublcd icon */
	mmi_camera_sublcd_draw_icon();
#endif /* __MMI_SUBLCD__ */ 


	// if (g_camera_cntx.app_prev_state != CAMERA_STATE_CONTSHOT)
	{
		mmi_camera_preview_create_preview_resource(
			0,
			0,
			g_camera_cntx.preview_width,
			g_camera_cntx.preview_height);
	}

	/* init title bar */
#ifndef __MMI_CAMERA_SLIM__
	if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_title_bar)
	{
#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		reset_title_status_icon();
		wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif /* defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__) */ 

		/* hide short cut */
		wgui_title_set_menu_shortcut_number(-1);

		if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_caption)
		{
			ChangeTitle(MAIN_MENU_TITLE_MULTIMEDIA_ICON, (PU8) GetString(STR_ID_CAMERA_APP_NAME));
		}
		else
		{
			ChangeTitle(0, (PU8) GetString(STR_ID_CAMERA_APP_NAME));
		}
	}
	else
	{
#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif 
	}
#else //ifndef __MMI_CAMERA_SLIM__
	mmi_camera_init_title_bar();
#endif //ifndef __MMI_CAMERA_SLIM__

	/* register keys */
	mmi_camera_preview_set_key_hdlr();    

	/* draw panel and softkey */
	mmi_camera_preview_set_hint(NULL, NULL, 0);
	mmi_camera_preview_draw_osd();

	mmi_camera_preview_set_blt_layer(TRUE);
	mmi_camera_blt();

	/* check if any error occurs in mmi_camera_app_screen function */
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		mmi_camera_display_error_popup();
		return;
	}
	else
	{
		mmi_camera_preview_start();
	}

	/* check if preview success */
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		mmi_camera_display_error_popup();
		return;
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_preview_state
* DESCRIPTION
*  exit preview state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_preview_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EXIT_PREVIEW_STATE);
	/* stop timer */
	if (g_camera_cntx.app_next_state != CAMERA_STATE_COUNTDOWN)
	{
		gui_cancel_timer(mmi_camera_preview_hide_hint);
	}

#ifdef __CAMERA_FEATURE_ZOOM__
	/*
	gui_cancel_timer(mmi_camera_preview_zoom_out);
	gui_cancel_timer(mmi_camera_preview_zoom_in);
	*/
	gui_cancel_timer((FuncPtr)mmi_camera_preview_zoom);
#endif /* __CAMERA_FEATURE_ZOOM__ */ 

#ifdef __CAMERA_FEATURE_EV__
	gui_cancel_timer(mmi_camera_preview_ev_inc_key_press);
	gui_cancel_timer(mmi_camera_preview_ev_dec_key_press);
#endif

#ifdef __CAMERA_FAST_ZOOM_SUPPORT__
	mmi_camera_stop_fast_zoom();

	/*
	gui_cancel_timer(mmi_camera_start_fast_zoom_out);
	gui_cancel_timer(mmi_camera_start_fast_zoom_in);
	*/
	gui_cancel_timer((FuncPtr)mmi_camera_start_fast_zoom);
#endif /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 

	gui_cancel_timer(mmi_camera_preview_draw_osd_timer);
	g_camera_cntx.is_draw_timer_on = FALSE;

	/* there are some setting changed by using hotkey or preview panel, save them to NVRAM */
	// remove for performance enhancement W08.34 mmi_camera_store_setting();

	/* exit app */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* stop previewing */
		mmi_camera_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();


		/* flatten layer */
		mmi_camera_preview_flatten_layer(TRUE);
	}
#ifndef __MMI_CAMERA_SLIM__   
	/* toggle to sub */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_TOGGLE_TO_SUB)
	{
		GDI_HANDLE base_layer;

		/* stop previewing */
		mmi_camera_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		mmi_camera_preview_free_preview_resource();
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
		if (g_camera_cntx.osd_layer_handle != NULL)
		{
			gdi_layer_free(g_camera_cntx.osd_layer_handle);
			g_camera_cntx.osd_layer_handle = NULL;

			mmi_frm_scrmem_free((void*)g_camera_cntx.osd_layer_buf_ptr0);
			g_camera_cntx.osd_layer_buf_ptr0 = NULL;
		}
#endif
		if (g_camera_cntx.gdi_layer_handle != NULL)
		{
			gdi_layer_free(g_camera_cntx.gdi_layer_handle);
			g_camera_cntx.gdi_layer_handle = NULL;
		}

		gdi_layer_get_base_handle(&base_layer);
		gdi_layer_set_blt_layer(base_layer, 0, 0, 0);

#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif 
	}
#endif

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_set_key_hdlr
* DESCRIPTION
*  set key handler
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_set_key_hdlr(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_SET_KEY_HDLR);
	ClearInputEventHandler(MMI_DEVICE_KEY);
	ClearKeyEvents();
#ifdef __MMI_TOUCH_SCREEN__
	mmi_pen_reset();
#endif

	p_act_key_hdlr = &g_preview_key_hdlr;
}




/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_create_preview_resource
* DESCRIPTION
*  free main lcd's preview layer resource
* PARAMETERS
*  offset_x        [IN]        Preview layer offset x
*  offset_y        [IN]        Preview layer offset y
*  width           [IN]        Preview layer width
*  height          [IN]        Preview_layer height
*  rotate          [IN]        Lcm rotate
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_preview_create_preview_resource(S32 offset_x, S32 offset_y, S32 width, S32 height)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	//GDI_HANDLE base_layer;
	//PU8 buf_ptr;
	// S32 buf_size;
	mdi_util_create_hw_layer_extmemory_in_struct layer_in;
	mdi_util_create_hw_layer_out_struct layer_out;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	ASSERT(width * height <= LCD_WIDTH * LCD_HEIGHT);

	mmi_camera_preview_free_preview_resource();

#ifdef HORIZONTAL_CAMERA
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_0)
	{
		g_camera_cntx.preview_offset_x = (LCD_WIDTH - g_camera_cntx.preview_width) >> 1;
		g_camera_cntx.preview_offset_y = (LCD_HEIGHT - g_camera_cntx.preview_height) >> 1;

	}
	else
	{
		g_camera_cntx.preview_offset_x = (LCD_HEIGHT - g_camera_cntx.preview_width) >> 1 ;
		g_camera_cntx.preview_offset_y = (LCD_WIDTH - g_camera_cntx.preview_height) >> 1;

	}		 
#else
	g_camera_cntx.preview_offset_x = (LCD_WIDTH - g_camera_cntx.preview_width) >> 1;
	g_camera_cntx.preview_offset_y = (LCD_HEIGHT - g_camera_cntx.preview_height) >> 1;

#endif 

#ifdef __MMI_CAMERA_TOP_ALIGN__
	g_camera_cntx.preview_offset_x = 0;
	g_camera_cntx.preview_offset_y = 0;

#endif

	// gdi_layer_get_base_handle(&base_layer);
	//  gdi_layer_push_and_set_active(base_layer);
	// gdi_layer_get_buffer_ptr(&buf_ptr);

	//buf_size = ((width * height * GDI_MAINLCD_BIT_PER_PIXEL) >> 3);
	layer_in.buffer = g_camera_cntx.preview_buf_p;
	layer_in.buffer_size = ((width * height * GDI_MAINLCD_BIT_PER_PIXEL) >> 3);
	layer_in.offset_x = g_camera_cntx.preview_offset_x;
	layer_in.offset_y = g_camera_cntx.preview_offset_y;
	layer_in.width = width;
	layer_in.height = height;
	layer_in.scenario_id = MDI_MULTIMEDIA_CAMERA;
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CREATE_PREVIEW_RESOURCE,width,height);
	g_camera_cntx.preview_layer_handle = mdi_util_hw_layer_create_with_extmemory(&layer_in, &layer_out);

	gdi_layer_set_active(g_camera_cntx.preview_layer_handle);
#ifdef GDI_USING_LAYER_BACKGROUND
	gdi_layer_set_background(GDI_COLOR_BLACK);
#endif 

#if defined(__CAMERA_OSD_HORIZONTAL__)
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_0)
	{
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
	}
	else
	{
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);
	}
#else
	gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
#endif

	// gdi_layer_pop_and_restore_active();


}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_free_preview_resource
* DESCRIPTION
*  free main lcd's preview layer resource
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_preview_free_preview_resource(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.preview_layer_handle == GDI_LAYER_EMPTY_HANDLE)
	{
		return;
	}
	mdi_util_hw_layer_free(g_camera_cntx.preview_layer_handle);
	g_camera_cntx.preview_layer_handle = GDI_LAYER_EMPTY_HANDLE;
	gdi_layer_set_active(g_camera_cntx.base_layer_handle);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_create_resource
* DESCRIPTION
*  create main lcd's preview layer resource
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_create_resource(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	//PU8 temp_buf;

#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_CREATE_RESOURCE);
	MMI_ASSERT(g_camera_cntx.is_mainlcd_resource == FALSE);
	/* if main lcd resoruce is not created */

	/************ base layer ************/
	/* get both MainLCD and SubLCD base handle */
	gdi_layer_get_base_handle(&g_camera_cntx.base_layer_handle);

	/* clear fullscreen */
	gdi_layer_clear(GDI_COLOR_BLACK);
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_layer_set_source_key(FALSE, GDI_COLOR_TRANSPARENT);
#endif 

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
	/* make sublcd active and get it's base layer handle */
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_get_base_handle(&g_camera_cntx.sublcd_base_layer_handle);

	gdi_layer_clear(GDI_COLOR_BLACK);

	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

	/************ frame layer ************/

	/************ osd layer ************/
	/*currently in order to save memory, we will steal GDI memory, 
	NOTE : we only use the memory, but do not use the handle */
	#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_use_gdi_layer();
	#endif

	/* create a double layer frame from outside memory */
#ifndef __MMI_CAMERA_SLIM__
	g_camera_cntx.osd_layer_buf_ptr0 = mmi_frm_scrmem_alloc_framebuffer(CAMERA_OSD_BUFFER_SIZE);
	ASSERT(g_camera_cntx.osd_layer_buf_ptr0 != NULL);

	gdi_layer_create_cf_double_using_outside_memory(
		GDI_COLOR_FORMAT_16,
		0,
		0,
		LCD_WIDTH,
		LCD_HEIGHT,
		&g_camera_cntx.osd_layer_handle,
		(PU8) g_camera_cntx.osd_layer_buf_ptr0,
		(S32) CAMERA_OSD_BUFFER_SIZE,
		(PU8) g_camera_cntx.osd_buf_p, 
		(S32) CAMERA_OSD_BUFFER_SIZE);

	gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
	gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
	gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
	gdi_layer_pop_and_restore_active();
#else
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_create_osd_layer();
#else
	
	mmi_camera_create_osd_region_layers();

#endif	//__MMI_CAMERA_MULTI_OSD_LAYER__
#endif //__MMI_CAMERA_SLIM__
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__    
	/*@ Add by Vincent  */
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
	/*    kal_wap_trace(MOD_MMI, TRACE_GROUP_3, "[cam][6253] create buffer for hw rotate, line:%d",__LINE__);*/

	gdi_layer_create_using_outside_memory(
		0,
		0,
		LCD_WIDTH,
		LCD_HEIGHT,
		&g_camera_cntx.osd_idp_rotate_layer_handle,
		(PU8)g_camera_cntx.app_mem_pool,
		CAMERA_OSD_BUFFER_SIZE);

	gdi_layer_push_and_set_active(g_camera_cntx.osd_idp_rotate_layer_handle);
	gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
	gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
	gdi_layer_pop_and_restore_active();
#endif
#endif __MMI_CAMERA_SLIM__   

	g_camera_cntx.is_mainlcd_resource = TRUE;

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_free_resource
* DESCRIPTION
*  free main lcd's preview layer resource
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_free_resource(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	GDI_HANDLE base_layer;
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	int i;
#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
#endif 
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__       
	/****** free add frame layer ******/
	/****** free osd layer ******/
	if (g_camera_cntx.osd_layer_handle != GDI_LAYER_EMPTY_HANDLE)
	{
		gdi_layer_free(g_camera_cntx.osd_layer_handle);
		g_camera_cntx.osd_layer_handle = GDI_LAYER_EMPTY_HANDLE;

		mmi_frm_scrmem_free((void*)g_camera_cntx.osd_layer_buf_ptr0);
		g_camera_cntx.osd_layer_buf_ptr0 = NULL;
	}
	#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
		if (g_camera_cntx.osd_idp_rotate_layer_handle != GDI_LAYER_EMPTY_HANDLE)
		{
			gdi_layer_free(g_camera_cntx.osd_idp_rotate_layer_handle);
			g_camera_cntx.osd_idp_rotate_layer_handle = GDI_LAYER_EMPTY_HANDLE;
		}
    #endif /* defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) */

#else 
	for (i = 0 ; i < CAMERA_OSD_REGION_MAX ; i++)
	{
		if (g_camera_cntx.osd_layer_region_handle[i] != GDI_LAYER_EMPTY_HANDLE)
		{
			gdi_layer_free(g_camera_cntx.osd_layer_region_handle[i]);
			g_camera_cntx.osd_layer_region_handle[i] = GDI_LAYER_EMPTY_HANDLE;
			mmi_frm_scrmem_free((void*)g_camera_cntx.osd_layer_region_handle_ptr[i]);
			g_camera_cntx.osd_layer_region_handle_ptr[i] = NULL;
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__	
			if( i == CAMERA_BUTTON_REGION)
			{
				mmi_frm_scrmem_free((void*)g_camera_cntx.osd_layer_region_handle_ptr2);
				g_camera_cntx.osd_layer_region_handle_ptr2 = NULL;
			}
#endif     
		}
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
		if (g_camera_cntx.osd_idp_layer_region_handle[i] != GDI_LAYER_EMPTY_HANDLE)
		{
			gdi_layer_free(g_camera_cntx.osd_idp_layer_region_handle[i]);
			g_camera_cntx.osd_idp_layer_region_handle[i] = GDI_LAYER_EMPTY_HANDLE;
			mmi_frm_scrmem_free((void*)g_camera_cntx.osd_idp_layer_region_handle_ptr[i]);
			g_camera_cntx.osd_idp_layer_region_handle_ptr[i] = NULL;   
		}
#endif /* defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) */
	}       
#endif    

	/* restore only base layer active */
	gdi_layer_get_base_handle(&base_layer);
	gdi_layer_set_blt_layer(base_layer, 0, 0, 0);

	g_camera_cntx.is_mainlcd_resource = FALSE;

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_start
* DESCRIPTION
*  start previewing of main lcd
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_start(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mdi_camera_setting_struct camera_setting_data;
	mdi_camera_preview_struct camera_preview_data;
	GDI_HANDLE preview_layer_handle = 0;
	U32 preview_layer_flag = 0;
	U32 blt_layer_flag = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_START);
	memset(&camera_setting_data, 0, sizeof(mdi_camera_setting_struct));
	memset(&camera_preview_data, 0, sizeof(mdi_camera_preview_struct));
	/* preview parametes */
	camera_setting_data.zoom = g_camera_cntx.setting.zoom_idx; /*HAL*/
	camera_setting_data.wb = camera_wb_command_map[g_camera_cntx.setting.wb];
	camera_setting_data.ev = camera_ev_command_map[g_camera_cntx.setting.ev];
	camera_setting_data.banding = camera_banding_command_map[g_camera_cntx.setting.banding];
	camera_setting_data.flash = camera_flash_command_map[g_camera_cntx.setting.flash];
	//    camera_setting_data.night = g_camera_cntx.setting.night;

	camera_setting_data.iso = camera_iso_command_map[g_camera_cntx.setting.iso];
	camera_setting_data.ae_meter = camera_ae_meter_command_map[g_camera_cntx.setting.ae_meter];
	camera_setting_data.scene_mode = camera_dsc_mode_command_map[g_camera_cntx.setting.dsc_mode];
	camera_setting_data.af_range = camera_autofocus_mode_command_map[g_camera_cntx.setting.af_mode];
	camera_setting_data.af_operation_mode = camera_autofocus_command_map[g_camera_cntx.setting.af_meter];

#ifdef __CAMERA_FEATURE_XENON_FLASH__
	camera_setting_data.xenon_flash_status_callback = mmi_camera_xenon_flash_callback;
#else
	camera_setting_data.xenon_flash_status_callback = NULL;
#endif

	/* default effect */
	camera_setting_data.effect = camera_effect_command_map[g_camera_cntx.setting.effect];
	camera_setting_data.sharpness = MDI_CAMERA_SHARPNESS_MEDIUM;
	camera_setting_data.saturation = MDI_CAMERA_SATURATION_MEDIUM;
	camera_setting_data.contrast = MDI_CAMERA_CONTRAST_MEDIUM;
#ifdef __CAMERA_FEATURE_CONTRAST__
	switch(g_camera_cntx.setting.contrast)
	{
	case 0://contrast high
		camera_setting_data.contrast = MDI_CAMERA_IE_LEVEL_HIGH;
		break;

	case 1://contrast medium
		camera_setting_data.contrast = MDI_CAMERA_IE_LEVEL_MEDIUM;
		break;

	case 2://contrast low
		camera_setting_data.contrast = MDI_CAMERA_IE_LEVEL_LOW;
		break;
	}
#endif
	camera_setting_data.hue = 0;

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM__


#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_1__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_1)
	{
		camera_setting_data.effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
		camera_setting_data.sharpness = g_camera_cntx.setting.fx_brightness[0];
		camera_setting_data.saturation = g_camera_cntx.setting.fx_saturation[0];
		camera_setting_data.contrast = g_camera_cntx.setting.fx_contrast[0];
		camera_setting_data.hue = g_camera_cntx.setting.fx_hue[0];
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_1__ */ 

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_2__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_2)
	{
		camera_setting_data.effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
		camera_setting_data.sharpness = g_camera_cntx.setting.fx_brightness[1];
		camera_setting_data.saturation = g_camera_cntx.setting.fx_saturation[1];
		camera_setting_data.contrast = g_camera_cntx.setting.fx_contrast[1];
		camera_setting_data.hue = g_camera_cntx.setting.fx_hue[1];
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_2__ */ 

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_3__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_3)
	{
		camera_setting_data.effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
		camera_setting_data.sharpness = g_camera_cntx.setting.fx_brightness[2];
		camera_setting_data.saturation = g_camera_cntx.setting.fx_saturation[2];
		camera_setting_data.contrast = g_camera_cntx.setting.fx_contrast[2];
		camera_setting_data.hue = g_camera_cntx.setting.fx_hue[2];
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_3__ */ 
#endif 

	camera_setting_data.overlay_frame_mode = FALSE;
	camera_setting_data.overlay_frame_depth = 0;
	camera_setting_data.overlay_frame_width = 0;
	camera_setting_data.overlay_frame_height = 0;
	camera_setting_data.overlay_frame_source_key = 0;
	camera_setting_data.overlay_frame_buffer_address = 0;

	camera_setting_data.preview_width = g_camera_cntx.preview_width;
	camera_setting_data.preview_height = g_camera_cntx.preview_height;

	/* capture parameters */
	camera_setting_data.image_qty = camera_image_qty_command_map[g_camera_cntx.setting.image_qty];
	camera_setting_data.image_width = g_camera_cntx.image_width;
	camera_setting_data.image_height = g_camera_cntx.image_height;

	camera_setting_data.lcm = MDI_CAMERA_PREVIEW_LCM_MAINLCD;
	//    camera_setting_data.preview_rotate = CAMERA_PREVIEW_MAINLCD_ROTATE;
	//    camera_setting_data.lcm_rotate = CAMERA_LCM_MAINLCD_ROTATE;

	//    camera_setting_data.continue_capture = g_camera_cntx.is_continue_capture;
#ifdef __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__
	switch (g_camera_cntx.setting.led_highlight)
	{
	case CAMERA_SETTING_LED_HIGHLIGHT_ON:
		camera_setting_data.flash = CAM_FLASH_ON;
		break;
	default:
		camera_setting_data.flash = CAM_FLASH_OFF;
		break;
	}
#endif /* __CAMERA_FEATURE_LED_HIGHLIGHT_ON_OFF__ */ 
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
	if(g_camera_cntx.is_enable_PQ)
	{
		mdi_camera_color_engine_disable();
		mdi_camera_color_engine_close();
		g_camera_cntx.is_enable_PQ = FALSE;
	}

	/* AF */
	/* turn on led highlight */
	mmi_camera_turn_on_preview_led_highlight();

	/* 
	* if using MT6218B series moudle with a Master backend (AIT700, etc),
	* we have to clear the preview layer's background to transparent,
	* and we have to resoret it after preview stop (stopped by capture command)
	*/

#ifdef CAMERA_MODULE_WITH_LCD
	gdi_layer_clear(CAMEAR_BG_TRASN_COLOR);
#endif 

#ifdef __CAMERA_FEATURE_TILESHOT__    
	if (g_camera_cntx.is_tileshot)
	{
		ASSERT(0);
	}
	else
#endif  /*__CAMERA_FEATURE_TILESHOT__*/
	{
		preview_layer_handle = g_camera_cntx.preview_layer_handle;

		/* preview (hw), OSD */
#if defined(__MMI_CAMERA_BASELAYER_SET_COLOR_SUPPORT__)
		preview_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
		blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1;
#else /* defined(__MMI_CAMERA_BASELAYER_SET_COLOR_SUPPORT__)*/ 
		blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0 | GDI_LAYER_ENABLE_LAYER_1 | GDI_LAYER_ENABLE_LAYER_2;
		preview_layer_flag = GDI_LAYER_ENABLE_LAYER_1;
#endif /* defined(__MMI_CAMERA_BASELAYER_SET_COLOR_SUPPORT__) */ 
	}

#ifdef __CAMERA_FEATURE_XENON_FLASH__
	g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_OFF;
#endif

	/* preview data for preview start */
	camera_preview_data.preview_layer_handle = preview_layer_handle;
	camera_preview_data.blt_layer_flag = blt_layer_flag;
	camera_preview_data.preview_layer_flag = preview_layer_flag;
	camera_preview_data.is_lcd_update = TRUE;
	camera_preview_data.src_key_color = GDI_COLOR_TRANSPARENT;
	camera_preview_data.is_tvout = TRUE;

	
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
	mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__
#endif

	g_camera_cntx.last_error = mdi_camera_preview_start(
		&camera_preview_data,
		&camera_setting_data,
		NULL);

	g_camera_cntx.is_preview_started = MMI_TRUE;
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
#if defined(__MTK_TARGET__)
	kal_set_timer(resz_cp_ESD_timeout_timer, (kal_timer_func_ptr)resz_cp_ESD_timeout_timer_hdlr,NULL, KAL_TICKS_3_SEC, 0);
#endif

#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_stop
* DESCRIPTION
*  stop previewing of main lcd
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_stop(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_STOP);
	/* stop previewing */
	mdi_camera_preview_stop();

	g_camera_cntx.is_preview_started = MMI_FALSE;
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	#if defined(__MTK_TARGET__)
	kal_cancel_timer(resz_cp_ESD_timeout_timer);  
	gui_cancel_timer(mmi_camera_app_reset_watchdog_callback);
    #endif
#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_set_blt_layer
* DESCRIPTION
*  set blt layer based on current status (ex: is previwing, has add frame, etc )
* PARAMETERS
*  is_previewing       [IN]        Is preview flag
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_set_blt_layer(BOOL is_previewing)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
    gdi_handle handle0, handle1, handle2, handle3;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CREATE_PREVIEW_SET_BLT_LAYER,is_previewing);
	
	if(is_previewing) 
		handle0 = g_camera_cntx.preview_layer_handle;
	else
		handle0 = g_camera_cntx.base_layer_handle;
	
	#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
            handle1 = g_camera_cntx.osd_layer_region_handle[CAMERA_BUTTON_REGION];
	#else
		    handle1 = 0;
	#endif
		 
		if(g_camera_cntx.is_capturing)
		{		
		#ifdef __CAMERA_FEATURE_DRAW_ICON__
		handle2 = g_camera_cntx.osd_layer_region_handle[CAMERA_ICON_REGION];
		#else
		handle2 = g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION];
		#endif
		
		handle3 = g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION];
		}
		else //g_camera_cntx.is_capturing
		{         
       	handle2 = g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION];

		#ifdef __CAMERA_FEATURE_DRAW_ICON__
		handle3 = g_camera_cntx.osd_layer_region_handle[CAMERA_ICON_REGION];
		#else
		handle3 = g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION];
		#endif			
		}

	#else //__MMI_CAMERA_MULTI_OSD_LAYER__
	handle1 = g_camera_cntx.osd_layer_handle;
	handle2 = 0;
	handle3 = 0;
	#endif
    gdi_layer_set_blt_layer(handle0,handle1,handle2,handle3);

}



/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_flatten_layer
* DESCRIPTION
*  flatten layers to base
* PARAMETERS
*  is_previewing       [IN]        
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_flatten_layer(BOOL is_previewing)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (is_previewing)
	{
#ifdef __CAMERA_FEATURE_TILESHOT__    

		if (g_camera_cntx.is_tileshot)
		{
			MMI_ASSERT(0);
		}
		else
#endif  /*__CAMERA_FEATURE_TILESHOT__*/
		{
			return;

		}
	}
	else
	{
#if (MMI_MAIN_BASE_LAYER_BITS_PER_PIXEL==24)          
		gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
		gdi_layer_clear(GDI_COLOR_BLACK);
		gdi_layer_pop_and_restore_active();
		gdi_layer_flatten_to_base(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
#endif
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_hide_hint
* DESCRIPTION
*  hide hint
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_hide_hint(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* for reducing tearing effect on WQVGA lcm */
#if defined(__MMI_CAMERA_QVGA_WALLPAPER_ON_WQVGA_LCM__)
	if (CAMERA_STATE_IN(CAMERA_STATE_PREVIEW))
	{
		gdi_layer_set_blt_layer(
			g_camera_cntx.preview_layer_handle,
			g_camera_cntx.osd_layer_handle,
			NULL,
			NULL,
			);
	}
#endif /* __MMI_CAMERA_QVGA_WALLPAPER_ON_WQVGA_LCM__ */
	mmi_camera_preview_set_hint(NULL, NULL, 255);
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
}



/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_set_hint
* DESCRIPTION
*  set hint string
* PARAMETERS
*  hint_str1       [IN]        String 1
*  hint_str2       [IN]        String 2
*  fade_time       [IN]        Hint fade out time
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_set_hint(CHAR *  hint_str1, CHAR *  hint_str2, U16 fade_time)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* clear buffer */
	/*
	memset(g_camera_cntx.hint1_buf, 0, CAMERA_HINT_BUF_SIZE);
	memset(g_camera_cntx.hint2_buf, 0, CAMERA_HINT_BUF_SIZE);
	*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_SET_HINT);
	*((U16*)(g_camera_cntx.hint1_buf)) = 0;
	*((U16*)(g_camera_cntx.hint2_buf)) = 0;

	if (hint_str1 != NULL)
	{
		mmi_ucs2ncpy((CHAR * ) g_camera_cntx.hint1_buf, (CHAR * ) hint_str1, CAMERA_HINT_CHAR_COUNT);
	}

	if (hint_str2 != NULL)
	{
		mmi_ucs2ncpy((CHAR * ) g_camera_cntx.hint2_buf, (CHAR * ) hint_str2, CAMERA_HINT_CHAR_COUNT);
	}

	g_camera_cntx.fade_time = fade_time;

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_update_zoom_limit
* DESCRIPTION
*  get zoom limit
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_update_zoom_limit(U16 capture_size_enum)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mdi_camera_zoom_info p_info;
	const struct img_size_map *pitem = &g_camera_img_size_map[capture_size_enum];

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	ASSERT(CAMERA_SETTING_IMAGE_SIZE_COUNT>capture_size_enum);

	mdi_camera_update_para_image_size(pitem->img_w, pitem->img_h);
	mdi_camera_query_zoom_info(&p_info);
	g_camera_cntx.max_zoom_steps = p_info.zoom_steps;

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_update_capture_size
* DESCRIPTION
*  update capture size and preview size due to setting change
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_preview_update_capture_size(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_UPDATE_CAPTURE_SIZE);
#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	/* check if is burst shot, if yes, change and store previous capture size */
	if (g_camera_cntx.setting.cont_shot == CAMERA_SETTING_CONT_SHOT_BURST)
	{    
		/* if not correct image size, change to it */
		if (g_camera_cntx.setting.image_size != CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX)
		{
			g_camera_cntx.image_size_before_burst = g_camera_cntx.setting.image_size;
			g_camera_cntx.setting.image_size = CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX;
		}
	}
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	mmi_camera_update_img_size();

	/* g_camera_cntx.zoom_limit = mmi_camera_get_zoom_limit(g_camera_cntx.setting.image_size); */
	mmi_camera_update_zoom_limit(g_camera_cntx.setting.image_size);


}

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_draw_osd_timer
* DESCRIPTION
*  redraw osd timer
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_draw_osd_timer(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DRAW_OSD_TIMER);
#ifdef __CAMERA_FAST_ZOOM_SUPPORT__
	if (g_camera_cntx.is_fast_zoom)
	{
#ifdef __MTK_TARGET__
		U32 current_idx;
		mdi_camera_get_fast_zoom_step(&current_idx);
		g_camera_cntx.setting.zoom_idx = (U16)current_idx;

#endif
	}
#endif /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 

#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__		

	mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__

#else
	mmi_camera_preview_draw_osd();
#endif
	mmi_camera_blt();
	if (g_camera_cntx.is_draw_timer_on)
	{
		gui_start_timer(100, mmi_camera_preview_draw_osd_timer);
	}
}


/*****************************************************************************
*
*  Main LCD Countdown State
*
*****************************************************************************/

static const camera_key_struct countdown_keys[] = 

{
	/* register soft keys */
	{KEY_LSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_lsk_release, NULL},
	{KEY_RSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_rsk_release, NULL},    
};

static const camera_key_hdlr_struct g_countdown_key_hdlr = 
{countdown_keys, sizeof(countdown_keys)/sizeof(camera_key_struct), NULL};

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_countdown_state
* DESCRIPTION
*  entry count down state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_countdown_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_COUNTDOWN_STATE,g_camera_cntx.setting.delay_timer);
	/* register soft keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);
	p_act_key_hdlr = &g_countdown_key_hdlr;

	/* init countdown para */
	switch (g_camera_cntx.setting.delay_timer)
	{
	case CAMERA_SETTING_DELAY_TIMER_1:
		{
			g_camera_cntx.capture_countdown = CAMERA_FEATURE_DELAY_TIMER_1_DURATION * 1000;
		}
		break;

	case CAMERA_SETTING_DELAY_TIMER_2:
		{
			g_camera_cntx.capture_countdown = CAMERA_FEATURE_DELAY_TIMER_2_DURATION * 1000;
		}
		break;

	case CAMERA_SETTING_DELAY_TIMER_3:
		{
			g_camera_cntx.capture_countdown = CAMERA_FEATURE_DELAY_TIMER_3_DURATION * 1000;
		}
		break;

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;
	}

#ifdef __COUNTDOWN_USING_MMA__
	mmi_camera_init_countdown_mma();
#endif

	/* start count down */
	mmi_camera_countdown_cyclic();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_countdown_state
* DESCRIPTION
*  entry count down state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_countdown_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EXIT_COUNTDOWN_STATE);
	/* stop countdown timer */
	gui_cancel_timer(mmi_camera_countdown_stop_LED);
	mmi_camera_countdown_stop_LED();
	gui_cancel_timer(mmi_camera_countdown_cyclic);

#ifdef __COUNTDOWN_USING_MMA__
	gui_cancel_timer(mmi_camera_capture);
	gui_cancel_timer(mmi_camera_deinit_countdown_mma);
#endif

	/* free preview resource */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
#ifdef __COUNTDOWN_USING_MMA__
#ifndef __AUDIO_ULTRA_SLIM__
		if (g_camera_cntx.multi_sound_countdown != 0 && g_camera_cntx.multi_sound_dummy_bg != 0)
#else
		if (g_camera_cntx.multi_sound_countdown != 0)
#endif
		{
			mmi_camera_deinit_countdown_mma();
		}
#endif

		/* stop previewing */
		mmi_camera_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* flatten layer */
		mmi_camera_preview_flatten_layer(TRUE);
	}

}

static void mmi_camera_countdown(S32 count,void (*LED_callback) (void),void (*countdown_callback) (void))
{
	if (g_camera_cntx.setting.led_highlight == CAMERA_SETTING_LED_HIGHLIGHT_OFF)
		{
			srv_gpio_set_device_level(GPIO_DEV_LED_STATUS_1, LED_LIGHT_LEVEL5);
		}

		gui_start_timer(100, LED_callback);
		gui_start_timer(count, countdown_callback);
		g_camera_cntx.capture_countdown -= count;

		if (!MMI_CAMERA_IS_SILENT_MODE())
		{
#ifdef __COUNTDOWN_USING_MMA__
			mdi_audio_set_headset_mode_output_path(MDI_DEVICE_SPEAKER_BOTH);
			mdi_audio_set_volume(VOL_TYPE_MEDIA,CAMERA_SHUTTER_SOUND_VOLUMN);
			mdi_audio_mma_stop(g_camera_cntx.multi_sound_countdown);
			mdi_audio_mma_play(g_camera_cntx.multi_sound_countdown);
#else
			mdi_audio_play_string_with_vol_path((void*)camera_sound_countdown, (U32) CAMREA_SOUND_COUNTDOWN_LEN,
				MDI_FORMAT_DVI_ADPCM,
				DEVICE_AUDIO_PLAY_ONCE,
				NULL, NULL, CAMERA_SHUTTER_SOUND_VOLUMN, MDI_DEVICE_SPEAKER_BOTH);
#endif

}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_countdown_cyclic
* DESCRIPTION
*  count down delay timer cyclic loop
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_countdown_cyclic(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_COUNTDOWN_CYCLIC,g_camera_cntx.capture_countdown);
	/* countdonw duration and freq */
	if (g_camera_cntx.capture_countdown > 6000)
	{
		mmi_camera_countdown(1000,mmi_camera_countdown_stop_LED,mmi_camera_countdown_cyclic);
	}
	else if (g_camera_cntx.capture_countdown > 2000)
	{
		mmi_camera_countdown(500,mmi_camera_countdown_stop_LED,mmi_camera_countdown_cyclic);
	}
	else if (g_camera_cntx.capture_countdown >= 0)
	{
		mmi_camera_countdown(400,mmi_camera_countdown_stop_LED,mmi_camera_countdown_cyclic);
	}
	else
	{
#ifdef __COUNTDOWN_USING_MMA__
		gui_start_timer(200, mmi_camera_deinit_countdown_mma);
		gui_start_timer(300, mmi_camera_capture);
#else
		mmi_camera_capture();
#endif
		return;
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_countdown_stop_LED
* DESCRIPTION
*  stop count down LED
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_countdown_stop_LED(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.setting.led_highlight == CAMERA_SETTING_LED_HIGHLIGHT_OFF)
	{
		srv_gpio_set_device_level(GPIO_DEV_LED_STATUS_1, LED_LIGHT_LEVEL0);
	}
}

static void camera_delete_confirm_csk_release(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELETE_CSK_RELEASE);

	if(g_camera_cntx.can_be_forward){
#if defined(__MMI_CAMERA_FORWARD_SUPPORT__)
		mmi_camera_forward_icon_release();
#endif
	}else{
		mmi_camera_delete_confirm_lsk_release();
	}
}

static const camera_key_struct confirm_keys[] = 

{
	/* register soft keys */
	{KEY_LSK, MMI_CAMERA_KE_FLAG_SW, mmi_camera_delete_confirm_lsk_press, mmi_camera_delete_confirm_lsk_release, NULL},
	{KEY_RSK, MMI_CAMERA_KE_FLAG_SW, mmi_camera_delete_confirm_rsk_press, mmi_camera_delete_confirm_rsk_release, NULL},    
	{KEY_CSK, MMI_CAMERA_KE_FLAG_SW, NULL, camera_delete_confirm_csk_release, NULL},
	{KEY_CAMERA, 0, mmi_camera_reentry_preview_state, NULL, NULL},    
};

static const camera_key_hdlr_struct g_confirm_key_hdlr = 
{confirm_keys, sizeof(confirm_keys)/sizeof(camera_key_struct), NULL};

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_delete_confirm_state
* DESCRIPTION
*  enter save confirm state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_delete_confirm_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 image_width;
	S32 image_height;
	S32 offset_x;
	S32 offset_y;
	S32 resized_offset_x;
	S32 resized_offset_y;
	S32 resized_width;
	S32 resized_height;
	S32 result;
	S32 image_region_width;
	S32 image_region_height;
	S32 image_region_offset_x;
	S32 image_region_offset_y;
	S32 index;
	S32 str_len = mmi_ucs2strlen(g_camera_cntx.captured_filepath);

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_CAMERA_START_MEASURE("ADC");

	/* init var */
#if defined(__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__)
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_STOP_APP_WATCHDOG();   
	MMI_CAMERA_RESTART_DELCONF_WATCHDOG();

#else
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
	mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);

#endif //__MMI_CAMERA_SLIM__
#endif
	/*PQ*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
	if(!g_camera_cntx.is_enable_PQ)
	{
		mdi_camera_color_engine_open();
		mdi_camera_color_engine_enable();
		g_camera_cntx.is_enable_PQ = TRUE;
	}
	/* register soft keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);
	g_camera_cntx.pressed_key = 0;
	p_act_key_hdlr = &g_confirm_key_hdlr;
	g_camera_cntx.can_be_forward = FALSE;
#if defined(__MMI_TOUCH_SCREEN__)
		wgui_register_pen_long_tap_handler(mmi_camera_delete_confirm_lsk_release);
#endif /*__MMI_TOUCH_SCREEN__ */ 
#if defined(__MMI_CAMERA_FORWARD_SUPPORT__)
	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF
		&& g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM 
		&& mmi_camera_is_forward_function_ready() == MMI_TRUE)
	{
		g_camera_cntx.can_be_forward = TRUE;
	}
#endif /* defined(__MMI_CAMERA_FORWARD_SUPPORT__) */ 
	/* free preview resource */
	mmi_camera_preview_free_preview_resource();
	/* reset osd layer, due to we may use 3osd or 5osd, currently we use 1osd, so need to reset */
	mmi_camera_reset_osd_layer();

	/* before drawing captured jpeg on osd, we need to reset base layer if no direct couplbe support */
	/* in direct couple mode, the image is saved in base layer ,so can not reset base layer*/
	mmi_camera_reset_base_layer();

	/* init title bar */
#ifndef __MMI_CAMERA_SLIM__
	if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_title_bar)
	{
#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		reset_title_status_icon();
		wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif /* defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__) */ 

		/* hide short cut */
		wgui_title_set_menu_shortcut_number(-1);

		if (g_camera_cntx.active_camera_osd_ptr->title.is_draw_mmi_caption)
		{
			ChangeTitle(MAIN_MENU_TITLE_MULTIMEDIA_ICON, (PU8) GetString(STR_ID_CAMERA_APP_NAME));
		}
		else
		{
			ChangeTitle(0, (PU8) GetString(STR_ID_CAMERA_APP_NAME));
		}
	}
	else
	{
#if defined(__MMI_MAINLCD_176X220__) || defined(__MMI_MAINLCD_240X320__)
		wgui_status_icon_bar_reset_display(WGUI_STATUS_ICON_BAR_H_BAR);
#endif 
	}
#else
	mmi_camera_init_title_bar();
#endif

	/* clear base layer background */
	/* in direct couple mode, the image is saved in base layer ,so can not reset base layer*/
	gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
	gdi_layer_clear_background(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
#else
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, 
		g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION],
		g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION],
		0);
#endif

#ifdef __CAMERA_UI_DEBUG__
	image_width = g_camera_cntx.image_width;
	image_height = g_camera_cntx.image_height;
	result = 0;
#else   /*__CAMERA_UI_DEBUG__*/
	if (g_camera_cntx.app_prev_state == CAMERA_STATE_FORWARD_TO || CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
		/* get file dimension */
		result = gdi_image_jpeg_get_dimension_file(
			g_camera_cntx.captured_filepath,
			&image_width,
			&image_height);
	}
	else
	{
		/*in this case, direct couple will no capture buffer for you, only direct couple buffer for you
		so we may get the file info from file, but this may lead mmi run much time, maybe some time it will 
		crash , then on that project, it should not open this compile option*/
#ifdef __YUVCAM_ENCODE_DIRECT_WRITE_FILE__
		/* get file dimension */
		result = gdi_image_jpeg_get_dimension_file(
			g_camera_cntx.captured_filepath,
			&image_width,
			&image_height);
#else
		result = gdi_image_jpeg_get_dimension(
			g_camera_cntx.capture_buf_ptr,
			g_camera_cntx.capture_size,
			&image_width,
			&image_height);
#endif
	}
#endif  /*__CAMERA_UI_DEBUG__*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_DELTE_CONFIRM,g_camera_cntx.app_prev_state,g_camera_cntx.app_state,result);
	/* set clip region as content region */
	gdi_layer_reset_clip();

	MMI_CAMERA_GET_START_TIME(MMI_TRC_CAMERA_DECODE_JPEG_TIME);
	MMI_CAMERA_START_MEASURE("ADJ");
	/* calc image region */
	image_region_width = g_camera_cntx.osd_UI_device_width;
	image_region_height = g_camera_cntx.osd_UI_device_height;
	image_region_offset_x = 0;
	image_region_offset_y = 0;
	if (result >= 0)
	{
		if ((image_region_width >= image_width) && (image_region_height >= image_height))
		{
			/* align preview window at the center of screen */
			offset_x = image_region_offset_x + ((image_region_width - image_width) >> 1);
			offset_y = image_region_offset_y + ((image_region_height - image_height) >> 1);

#ifdef __CAMERA_UI_DEBUG__
			gdi_draw_solid_rect(offset_x, offset_y, offset_x+image_width, offset_y+image_height, GDI_COLOR_BLUE);
#else   /*__CAMERA_UI_DEBUG__*/
			if (g_camera_cntx.app_prev_state == CAMERA_STATE_FORWARD_TO || CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
			{
				result = gdi_image_jpeg_draw_file(offset_x, offset_y, g_camera_cntx.captured_filepath);
				MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_DELTE_CONFIRM_DRAW,result,__LINE__);
			}
			else
			{
				/*in this case, direct couple will no capture buffer for you, only direct couple buffer for you
				so we may get the file info from file, but this may lead mmi run much time, maybe some time it will 
				crash , then on that project, it should not open this compile option*/
#ifdef __YUVCAM_ENCODE_DIRECT_WRITE_FILE__
				gdi_image_jpeg_draw_file(offset_x, offset_y, g_camera_cntx.captured_filepath);
#else
				result = gdi_image_jpeg_draw(offset_x, offset_y, g_camera_cntx.capture_buf_ptr, g_camera_cntx.capture_size);
				MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_DELTE_CONFIRM_DRAW,result,__LINE__);
#endif
			}
#endif /*__CAMERA_UI_DEBUG__*/
		}
		else
		{
			gdi_image_util_fit_bbox(
				image_region_width,
				image_region_height,
				image_width,
				image_height,
				&resized_offset_x,
				&resized_offset_y,
				&resized_width,
				&resized_height);

#ifdef __CAMERA_UI_DEBUG__
			gdi_draw_solid_rect(
				resized_offset_x + image_region_offset_x, 
				resized_offset_y + image_region_offset_y, 
				resized_offset_x + image_region_offset_x + resized_width, 
				resized_offset_y + image_region_offset_y + resized_height, 
				GDI_COLOR_BLUE);
#else   /*__CAMERA_UI_DEBUG__*/

			if (g_camera_cntx.app_prev_state == CAMERA_STATE_FORWARD_TO || CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
			{
				result = gdi_image_jpeg_draw_resized_file(
					resized_offset_x + image_region_offset_x,
					resized_offset_y + image_region_offset_y,
					resized_width,
					resized_height,
					g_camera_cntx.captured_filepath);
				MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_DELTE_CONFIRM_DRAW,result,__LINE__);
			}
			else
			{
				/*in this case, direct couple will no capture buffer for you, only direct couple buffer for you
				so we may get the file info from file, but this may lead mmi run much time, maybe some time it will 
				crash , then on that project, it should not open this compile option*/
#ifdef __YUVCAM_ENCODE_DIRECT_WRITE_FILE__
				gdi_image_jpeg_draw_resized_file(
					resized_offset_x + image_region_offset_x,
					resized_offset_y + image_region_offset_y,
					resized_width,
					resized_height,
					g_camera_cntx.captured_filepath);
#else
				result = gdi_image_jpeg_draw_resized(
					resized_offset_x + image_region_offset_x,
					resized_offset_y + image_region_offset_y,
					resized_width,
					resized_height,
					g_camera_cntx.capture_buf_ptr,
					g_camera_cntx.capture_size);
				MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_DELTE_CONFIRM_DRAW,result,__LINE__);
#endif
			}
#endif /*__CAMERA_UI_DEBUG__*/

		}
	}
	else 
	{
		/*Correct the result of GDI*/
		if (!mmi_camera_check_and_restore_valid_drv())
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_NO_DISK;
		}
		else
		{
			g_camera_cntx.last_error = result;
		}
		return;
	}
	MMI_CAMERA_STOP_MEASURE("ADJ");
	MMI_CAMERA_GET_STOP_TIME_AND_PRINT_TRACE(MMI_TRC_CAMERA_DECODE_JPEG_TIME);

	/* find file name - by finding "\\" */
	for (index = str_len * 2 - 2; index >= 2; index -= 2)
	{
		if (mmi_ucs2ncmp((CHAR * ) & g_camera_cntx.captured_filepath[index], (CHAR * ) L"\\", 1) == 0)
		{
			index += 2;
			break;
		}
	}

	/* draw filename, for we use hint style to draw filename, we must make the hint display to TRUE*/
	{
		BOOL is_display_hint_org;

		is_display_hint_org = g_camera_cntx.osd_data.show_hint;
		g_camera_cntx.osd_data.show_hint = TRUE;
		mmi_camera_preview_set_hint((CHAR * ) &(g_camera_cntx.captured_filepath[index]), NULL, 0);
		mmi_camera_preview_draw_osd();

		g_camera_cntx.osd_data.show_hint = is_display_hint_org;
	}

	/* blt */
	mmi_camera_blt();
	MMI_CAMERA_STOP_MEASURE("ADC");
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_delete_confirm_state
* DESCRIPTION
*  exit save confirm state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_delete_confirm_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U8 rotate = GDI_LAYER_ROTATE_0;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EXIT_DELETE_CONFIRM_STATE);
#if defined(__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__)
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_STOP_DELCONF_WATCHDOG();
#else
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif
#endif
	/*@ Add by Vincent */
	/* need to set back base layer's rotation due to direct couple */
	rotate = gdi_layer_get_rotate();
	gdi_layer_resize(LCD_WIDTH,LCD_HEIGHT);
	gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
	if (rotate != GDI_LAYER_ROTATE_0)
	{
		gdi_layer_clear(GDI_COLOR_BLACK);
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_lsk_press
* DESCRIPTION
*  draw save confirm softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_confirm_lsk_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELETE_LSK_PRESS);
#if defined(__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__)
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_STOP_DELCONF_WATCHDOG();
#else
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif
#endif
	//    g_camera_cntx.is_lsk_pressed = TRUE;
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_preview_draw_osd();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
#else
	mmi_camera_preview_draw_softkey();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle,
		g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION],
		g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION],
		0);
#endif
}


#ifdef __MMI_SCREEN_ROTATE__
static void cam_hide_softkey (WGUI_SOFTKEY_ENUM softkey_type)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 ret;
	S32 image_width;
	S32 image_height;
	S32 offset_x;
	S32 offset_y;
	S32 resized_offset_x;
	S32 resized_offset_y;
	S32 resized_width;
	S32 resized_height;
	S32 result;
	S32 image_region_width;
	S32 image_region_height;
	S32 image_region_offset_x;
	S32 image_region_offset_y;
	S32 str_len = mmi_ucs2strlen(g_camera_cntx.captured_filepath);
	gdi_color bg_color;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.captured_filepath != NULL && CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
		ret = FS_Open((const WCHAR *)g_camera_cntx.captured_filepath, FS_READ_ONLY);
		if (ret < 0)
		{
			CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
		}
		FS_Close(ret);
	}

	gdi_layer_push_and_set_clip(MMI_softkeys[softkey_type].x,
		MMI_softkeys[softkey_type].y,
		MMI_softkeys[softkey_type].x + MMI_softkeys[softkey_type].width - 1,
		MMI_softkeys[softkey_type].y + MMI_softkeys[softkey_type].height - 1);


	/*Clear background*/
	{
		bg_color = GDI_COLOR_BLACK;
		if(g_camera_cntx.active_camera_osd_ptr->bg.is_draw_bg_color){
			bg_color = GDI_RGB_TO_BUFFER_FORMAT(
				g_camera_cntx.active_camera_osd_ptr->bg.r,
				g_camera_cntx.active_camera_osd_ptr->bg.g,
				g_camera_cntx.active_camera_osd_ptr->bg.b);
		}

		gdi_draw_solid_rect(0, 0, g_camera_cntx.osd_UI_device_width, g_camera_cntx.osd_UI_device_height, bg_color);
	}


	if (g_camera_cntx.app_prev_state == CAMERA_STATE_FORWARD_TO || CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
	{
		/* get file dimension */
		result = gdi_image_jpeg_get_dimension_file(
			g_camera_cntx.captured_filepath,
			&image_width,
			&image_height);
	}
	else
	{
		/*in this case, direct couple will no capture buffer for you, only direct couple buffer for you
		so we may get the file info from file, but this may lead mmi run much time, maybe some time it will 
		crash , then on that project, it should not open this compile option*/
#ifdef __YUVCAM_ENCODE_DIRECT_WRITE_FILE__
		/* get file dimension */
		result = gdi_image_jpeg_get_dimension_file(
			g_camera_cntx.captured_filepath,
			&image_width,
			&image_height);
#else
		result = gdi_image_jpeg_get_dimension(
			g_camera_cntx.capture_buf_ptr,
			g_camera_cntx.capture_size,
			&image_width,
			&image_height);
#endif
	}
	MMI_CAMERA_GET_START_TIME(MMI_TRC_CAMERA_DECODE_JPEG_TIME);
	MMI_CAMERA_START_MEASURE("ADJ");
	/* calc image region */
	image_region_width = g_camera_cntx.osd_UI_device_width;
	image_region_height = g_camera_cntx.osd_UI_device_height;
	image_region_offset_x = 0;
	image_region_offset_y = 0;

	if (result >= 0)
	{
		if ((image_region_width >= image_width) && (image_region_height >= image_height))
		{
			/* align preview window at the center of screen */
			offset_x = image_region_offset_x + ((image_region_width - image_width) >> 1);
			offset_y = image_region_offset_y + ((image_region_height - image_height) >> 1);

			if (g_camera_cntx.app_prev_state == CAMERA_STATE_FORWARD_TO || CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
			{
				gdi_image_jpeg_draw_file(offset_x, offset_y, g_camera_cntx.captured_filepath);
			}
			else
			{
				/*in this case, direct couple will no capture buffer for you, only direct couple buffer for you
				so we may get the file info from file, but this may lead mmi run much time, maybe some time it will 
				crash , then on that project, it should not open this compile option*/
#ifdef __YUVCAM_ENCODE_DIRECT_WRITE_FILE__
				gdi_image_jpeg_draw_file(offset_x, offset_y, g_camera_cntx.captured_filepath);
#else
				gdi_image_jpeg_draw(offset_x, offset_y, g_camera_cntx.capture_buf_ptr, g_camera_cntx.capture_size);
#endif
			}   
		}
		else
		{
			gdi_image_util_fit_bbox(
				image_region_width,
				image_region_height,
				image_width,
				image_height,
				&resized_offset_x,
				&resized_offset_y,
				&resized_width,
				&resized_height);

			if (g_camera_cntx.app_prev_state == CAMERA_STATE_FORWARD_TO || CAMERA_STATE_IN(CAMERA_STATE_FORWARD_TO))
			{
				gdi_image_jpeg_draw_resized_file(
					resized_offset_x + image_region_offset_x,
					resized_offset_y + image_region_offset_y,
					resized_width,
					resized_height,
					g_camera_cntx.captured_filepath);
			}
			else
			{
				/*in this case, direct couple will no capture buffer for you, only direct couple buffer for you
				so we may get the file info from file, but this may lead mmi run much time, maybe some time it will 
				crash , then on that project, it should not open this compile option*/
#ifdef __YUVCAM_ENCODE_DIRECT_WRITE_FILE__
				gdi_image_jpeg_draw_resized_file(
					resized_offset_x + image_region_offset_x,
					resized_offset_y + image_region_offset_y,
					resized_width,
					resized_height,
					g_camera_cntx.captured_filepath);
#else
				gdi_image_jpeg_draw_resized(
					resized_offset_x + image_region_offset_x,
					resized_offset_y + image_region_offset_y,
					resized_width,
					resized_height,
					g_camera_cntx.capture_buf_ptr,
					g_camera_cntx.capture_size);
#endif
			}
		}
	}
	else 
	{
		/*Correct the result of GDI*/
		if (!mmi_camera_check_and_restore_valid_drv())
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_NO_DISK;
		}
		else
		{
			g_camera_cntx.last_error = result;
		}
	}
	MMI_CAMERA_STOP_MEASURE("ADJ");
	MMI_CAMERA_GET_STOP_TIME_AND_PRINT_TRACE(MMI_TRC_CAMERA_DECODE_JPEG_TIME);

	gui_greyscale_rectangle(
		MMI_softkeys[softkey_type].x,
		MMI_softkeys[softkey_type].y,
		MMI_softkeys[softkey_type].x + MMI_softkeys[softkey_type].width - 1,
		MMI_softkeys[softkey_type].y + MMI_softkeys[softkey_type].height - 1,
		0,
		0);
	gdi_layer_pop_clip();
}
#endif

/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_lsk_release
* DESCRIPTION
*  lsk release
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_confirm_lsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
    MMI_ID menu_gid;
	
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELETE_LSK_RELEASE);
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_preview_draw_osd();

	gdi_lcd_blt(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
#else
	mmi_camera_preview_draw_softkey();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle, 
		g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION],
		g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION],
		0);
#endif

	/*@ Add by Vincent */
	/* need to set back base layer's rotation for direct couple */
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) 
	/*@ Remove by mtk80018, only change dimention with out process is wrong*/
	/*gdi_layer_resize(LCD_WIDTH,LCD_HEIGHT);
	gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);*/
#endif
	mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS);
	mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL);
	mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_BT);

	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		g_camera_cntx.app_prev_state = g_camera_cntx.app_state;
		g_camera_cntx.app_state = CAMERA_STATE_FORWARD_TO;
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
		if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
		{
			mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
		}
		else
		{
			mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_0);
		}
#endif /* __CAMERA_OSD_HORIZONTAL__ */
		if (mmi_camera_is_forward_function_ready()) /* not in flight mode */
		{
			mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION);
#if defined(__MMI_MMS_POSTCARD__)
			if (mms_is_ready())
			{
				mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_POSTCARD);
			}
			else
			{
				mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_POSTCARD);
			}
#endif

			/*OP12 spec request not show E-mail after capture*/
#if !defined(__OP12__)
#if defined(__MMI_EMAIL__)
			if (mmi_email_is_email_can_forward()==TRUE)
			{
				mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL);
			}
			else
			{
				mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL);
			}
#endif
#endif

#if defined(__MMI_MMS__)
			if (mms_is_ready())
			{
				mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS);
			}
			else
			{
				mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS);
			}
#endif
#if defined(__MMI_OPP_SUPPORT__)
			if (mmi_bt_is_to_display_bt_menu() == MMI_TRUE)
			{
				mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_BT);
			}
#endif    
		}
		else
		{
			mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION);
		}
#ifdef __MMI_SCREEN_ROTATE__     
		wgui_cascading_menu_register_hide_softkey(cam_hide_softkey);
#endif

#ifdef __MMI_CASCADED_OPTION_MENU__
		DisplayCascadingMenu(
			MENU_ID_CAMERA_CONFIRM_OPTION,
			mmi_camera_delete_confirm_option_cmd_hdlr);
#else
    menu_gid = cui_menu_create(g_camera_cntx.cur_gid, 
                               CUI_MENU_SRC_TYPE_RESOURCE, 
                               CUI_MENU_TYPE_FROM_RESOURCE, 
                               MENU_ID_CAMERA_CONFIRM_OPTION, 
                               MMI_TRUE, 
                               NULL);
    cui_menu_set_default_title_by_id(menu_gid, STR_GLOBAL_OPTIONS, GetRootTitleIcon(MENU_ID_CAMERA_APP));
    cui_menu_set_default_left_softkey_by_id(menu_gid, STR_GLOBAL_OK);
    cui_menu_set_default_right_softkey_by_id(menu_gid, STR_GLOBAL_BACK);
    cui_menu_run(menu_gid);
#endif
	}
	else 
	{
		/* for External Request */
		cui_camera_event_struct evt;

		MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), g_camera_cntx.cur_gid);
		evt.evt_id = CUI_CAMERA_EVENT_RESULT_SUCCESS;
		evt.file_path = g_camera_cntx.captured_filepath;
		mmi_frm_group_post_to_parent (g_camera_cntx.cur_gid, (mmi_group_event_struct *)&evt);

		//mmi_frm_scrn_close_active_id();
		if (g_camera_cntx.is_in_fast_forward == TRUE)
		{
			g_camera_cntx.app_state = CAMERA_STATE_FORWARD_TO;
			g_camera_cntx.is_in_fast_forward = FALSE;
		}
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_rsk_press
* DESCRIPTION
*  draw save confirm softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_confirm_rsk_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELETE_RSK_PRESS);
#if defined(__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__)
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_STOP_DELCONF_WATCHDOG();
#else
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif
#endif
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_preview_draw_osd();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
#else
	mmi_camera_preview_draw_softkey();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle, 
		g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION],
		g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION],
		0);
#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_rsk_release
* DESCRIPTION
*  draw save confirm softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_confirm_rsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELETE_RSK_RELEASE);
#if defined(__CAMERA_OSD_HORIZONTAL__)
	gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
	gdi_layer_clear_background(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
#else
	mmi_camera_reset_base_layer();
#endif
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
	mmi_camera_preview_draw_osd();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);
#else
	mmi_camera_preview_draw_softkey();
	gdi_lcd_blt(g_camera_cntx.base_layer_handle, 
		g_camera_cntx.osd_layer_region_handle[CAMERA_SOFTKEY_REGION],
		g_camera_cntx.osd_layer_region_handle[CAMERA_HINT_REGION],
		0);
#endif
	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_PREVIEW);
#endif
	}
	else
	{
		mmi_camera_delete_confirm_delete_file();
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_delete_file
* DESCRIPTION
*  save file
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_confirm_delete_file(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	FS_HANDLE file_check;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELETE_CONFIRM_FILE);
	/* blt base only */
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, 0, 0, 0);

	gdi_layer_lock_frame_buffer();

	/* show popup category */
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_reset_screen_rotation();
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		/* rotate base layer */
		gdi_layer_resize(LCD_HEIGHT,LCD_WIDTH);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	/* currently we use gdi layer buffer for OSD, but when show category, it also use gdi buffer, 
	so we should release the memory */
	if (g_camera_cntx.gdi_layer_handle != GDI_NULL_HANDLE)
	{       
		gdi_layer_free(g_camera_cntx.gdi_layer_handle);
		g_camera_cntx.gdi_layer_handle = GDI_NULL_HANDLE;
	}

	force_no_small_screen();
	ExitCategoryFunction();
	gdi_layer_lock_frame_buffer();
	ShowCategory65Screen((PU8) GetString(STR_GLOBAL_DELETING), mmi_get_event_based_image(MMI_EVENT_PROGRESS), NULL);
	gdi_layer_unlock_frame_buffer();
	g_camera_cntx.is_cat65_show = TRUE;


	gdi_layer_unlock_frame_buffer();
	mmi_camera_blt();

	file_check = FS_Delete((U16*) g_camera_cntx.captured_filepath);    

	/* cant write in whole file, must be disk full */
	if (file_check != FS_NO_ERROR)
	{
		MMI_ID_TYPE str_id;        
		str_id = srv_fmgr_fs_error_get_string(file_check);        
		if (g_camera_cntx.is_cat65_show)
		{
			g_camera_cntx.is_cat65_show = FALSE;
			ExitCategoryFunction();
		}   
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP(str_id, MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE); 
#else
		mmi_camera_display_popup(str_id, ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
			(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
		return;
	}

	if (g_camera_cntx.is_cat65_show)
	{
		g_camera_cntx.is_cat65_show = FALSE;
		ExitCategoryFunction();
	}

	/* enter save done */
#ifndef __MMI_CAMERA_SLIM__
	CAMERA_ENTER_STATE(CAMERA_STATE_DELETE_DONE);
#else
	camera_enter_state(CAMERA_STATE_DELETE_DONE);
#endif
}


/*****************************************************************************
*
*  Save Done State 
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_delete_done_state
* DESCRIPTION
*  enter save done state, show a save done popup
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_delete_done_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_DELTE_DONE);
	/* clear all keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	/* draw base layer only */
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, 0, 0, 0);

	gdi_layer_lock_frame_buffer();

	/* show popup category */
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_reset_screen_rotation();
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270 &&
		mmi_frm_get_screen_rotate() != CAMERA_DISPLAY_ROTATE_270)
	{
		gdi_layer_resize(LCD_HEIGHT,LCD_WIDTH);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	force_no_small_screen();
	ExitCategoryFunction();

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__)    
	if (g_camera_cntx.app_prev_state == CAMERA_STATE_BURSTSHOT_SAVING)
	{
		gdi_layer_lock_frame_buffer();
		ShowCategory65Screen((PU8) GetString(STR_GLOBAL_SAVED), mmi_get_event_based_image(MMI_EVENT_SUCCESS), NULL);
		gdi_layer_unlock_frame_buffer();
	}
	else
	{
#endif

		gdi_layer_lock_frame_buffer();
		ShowCategory65Screen((PU8) GetString(STR_GLOBAL_DELETED), mmi_get_event_based_image(MMI_EVENT_SUCCESS), NULL);
		gdi_layer_unlock_frame_buffer();
#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__)  
	}
#endif

	g_camera_cntx.is_cat65_show = TRUE;

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

	gdi_layer_unlock_frame_buffer();

	mmi_camera_blt();

	gui_start_timer(mmi_get_event_based_duration(MMI_EVENT_SUCCESS), mmi_camera_delete_done_timeout);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_delete_done_state
* DESCRIPTION
*  exit save done state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_delete_done_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EXIT_DELETE_DONE);
	/* will display a popup, go out application and re-enter */
	if (g_camera_cntx.is_cat65_show)
	{
		g_camera_cntx.is_cat65_show = FALSE;
		ExitCategoryFunction();
	}

	gui_cancel_timer(mmi_camera_delete_done_timeout);

	/* stop anmation on popup category */
	gdi_image_stop_animation_all();
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)

	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_0);
		gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
		gdi_layer_clear_background(GDI_COLOR_BLACK);
		gdi_layer_pop_and_restore_active();

	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_done_timeout
* DESCRIPTION
*  save done popup timeout
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_done_timeout(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* enter sub preview state */
#ifndef __MMI_CAMERA_SLIM__
	CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW); 
#else
	camera_enter_state(CAMERA_STATE_PREVIEW);
#endif
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_capture
* DESCRIPTION
*  capture photo
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_capture(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 quickview_width;
	U16 quickview_height;    
    S32 create_result;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CAPTURE,g_camera_cntx.setting.cont_shot);
	MMI_CAMERA_GET_START_TIME(MMI_TRC_CAMERA_KEY_TO_CAPTURE_TIME);

   if (mmi_camera_check_and_restore_valid_drv())
	{
		/* drv is valid, create directory */
		create_result = mmi_imgview_get_storage_file_path((WCHAR*)g_camera_cntx.storage_filepath);

		switch (create_result)
		{            	
		case FS_WRITE_PROTECTION:
			g_camera_cntx.last_error = CAMERA_ERR_WRITE_PROTECT;
			break;
		case FS_DISK_FULL:
			g_camera_cntx.last_error = CAMERA_ERR_CARD_DISK_FULL;
			break;
		case FS_ROOT_DIR_FULL:
			g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;
			break;
		case FS_INVALID_FILENAME:
			g_camera_cntx.last_error = CAMERA_ERR_CREATE_DIR;
			break;
		default:
			break;
		}
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
			{
				mmi_camera_display_error_popup();
				return;
			}
	}
	else
	{
		#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP(((MMI_ID_TYPE)STR_GLOBAL_INSERT_MEMORY_CARD), ((mmi_event_notify_enum)MMI_EVENT_FAILURE),
		(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE); 
    #else
		mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_INSERT_MEMORY_CARD), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
			(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
    #endif
		return;
	}

    mmi_camera_get_next_filename(g_camera_cntx.captured_filepath);

#if defined(__MMI_CAMERA_DIRECT_SENSOR_SUPPORT__)
	/*
	* When __DIRECT_SENSOR_SUPPORT__, always use capture from layer.
	*/
	g_camera_cntx.capture_path = CAPTURE_FROM_LAYER;
#endif
#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
	#if defined(__MTK_TARGET__)
	kal_cancel_timer(resz_cp_ESD_timeout_timer);
	gui_cancel_timer(mmi_camera_app_reset_watchdog_callback);
    #endif
#endif

	switch (g_camera_cntx.setting.cont_shot)
	{
	case CAMERA_SETTING_CONT_SHOT_OFF:
		{
			/* capture button pressed */
			g_camera_cntx.is_capturing = TRUE;

			mmi_camera_turn_on_capture_led_highlight();
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
			mmi_camera_preview_set_blt_layer(TRUE);
#endif
			MMI_CAMERA_START_MEASURE("OSD");
			mmi_camera_preview_set_hint((CHAR * ) GetString(STR_GLOBAL_SAVING), NULL, 0);
			mmi_camera_preview_draw_osd();

			mmi_camera_blt();
			MMI_CAMERA_STOP_MEASURE("OSD");

			MMI_CAMERA_START_MEASURE("SND");
			/* play capture sound after capture */
			mmi_camera_capture_play_sound();
			MMI_CAMERA_STOP_MEASURE("SND");

			MMI_CAMERA_START_MEASURE("PRE");

#ifdef __CAMERA_UI_DEBUG__
			g_camera_cntx.last_error = MDI_RES_CAMERA_SUCCEED;
			gdi_lcd_set_hw_update(0);
#else   /*__CAMERA_UI_DEBUG__*/

			if (g_camera_cntx.image_width <= g_camera_cntx.preview_width && g_camera_cntx.image_height <= g_camera_cntx.preview_height)
			{
				quickview_width  = g_camera_cntx.image_width;
				quickview_height = g_camera_cntx.image_height;
				gdi_layer_push_and_set_active(g_camera_cntx.preview_layer_handle);
				gdi_layer_resize(quickview_width, quickview_height);
				gdi_layer_set_position(
					g_camera_cntx.preview_offset_x + (g_camera_cntx.preview_width  - quickview_width >>1),
					g_camera_cntx.preview_offset_y + (g_camera_cntx.preview_height - quickview_height>>1));
				gdi_layer_pop_and_restore_active();
			}
			else
			{
				quickview_width  = g_camera_cntx.preview_width;
				quickview_height = g_camera_cntx.preview_height;
			}

			MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CAPTURE_QUICKVIEW,quickview_width,quickview_height,__LINE__);
			g_camera_cntx.last_error = mdi_camera_capture_with_quickview(
				(U32) g_camera_cntx.preview_buf_p, 
				(quickview_width * quickview_height * GDI_MAINLCD_BIT_PER_PIXEL)>>3, 
				quickview_width,
				quickview_height,
				g_camera_cntx.captured_filepath);


			if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
			{
				g_camera_cntx.last_error = mdi_camera_encode_capture_image(&g_camera_cntx.capture_buf_ptr, &g_camera_cntx.capture_size);
			}
			/*PQ*/
			MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
			if(!g_camera_cntx.is_enable_PQ)
			{
				mdi_camera_color_engine_open();
				mdi_camera_color_engine_enable();
				g_camera_cntx.is_enable_PQ = TRUE;
			}
#endif  /*__CAMERA_UI_DEBUG__*/

			/* will enter save confirm, close led highlight */
			mmi_camera_turn_off_led_highlight();

			/* captured, previewing is stopped, change blt layer */
			mmi_camera_preview_set_blt_layer(TRUE);

			if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
			{
				MMI_CAMERA_START_MEASURE("DCP");


#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */


				MMI_CAMERA_STOP_MEASURE("DCP");

				MMI_CAMERA_GET_START_TIME(MMI_TRC_CAMERA_SAVING_TIME);
				MMI_CAMERA_START_MEASURE("ASV");
#ifdef __CAMERA_UI_DEBUG__
				g_camera_cntx.last_error = MDI_RES_CAMERA_SUCCEED;
#else   /*__CAMERA_UI_DEBUG__*/
				g_camera_cntx.last_error = mdi_camera_save_captured_image();
#endif  /*__CAMERA_UI_DEBUG__*/
				MMI_CAMERA_STOP_MEASURE("ASV");
				MMI_CAMERA_GET_STOP_TIME_AND_PRINT_TRACE(MMI_TRC_CAMERA_SAVING_TIME);

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 

				//MMI_TRACE(MMI_MEDIA_TRC_G2_APP,MMI_TRC_CAMERA_SAVING_TIME, g_mmi_cam_duration,__LINE__);
			}
			else
			{
#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */ 
			}
			g_camera_cntx.is_capturing = FALSE;

			if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
			{
				FS_Delete((U16*) g_camera_cntx.captured_filepath);
				mmi_camera_display_error_popup();
				return;
			}
			else
			{
				/* will capture then save to file */
				mmi_camera_commit_filename_seq_no();
#ifndef __MMI_CAMERA_SLIM__
				CAMERA_ENTER_STATE(CAMERA_STATE_DELETE_CONFIRM);
#else
				camera_enter_state(CAMERA_STATE_DELETE_CONFIRM);
#endif
			}
		}
		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT__
	case CAMERA_SETTING_CONT_SHOT_1:
#ifdef __CAMERA_FEATURE_CONT_SHOT_2__
	case CAMERA_SETTING_CONT_SHOT_2:
#endif 
#ifdef __CAMERA_FEATURE_CONT_SHOT_3__
	case CAMERA_SETTING_CONT_SHOT_3:
#endif 
		{
#ifndef __MMI_CAMERA_SLIM__
			CAMERA_ENTER_STATE(CAMERA_STATE_CONTSHOT);
#else
			camera_enter_state(CAMERA_STATE_CONTSHOT);
#endif
		}
		break;
#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	case CAMERA_SETTING_CONT_SHOT_BURST:
		{
			CAMERA_ENTER_STATE(CAMERA_STATE_BURSTSHOT);
		}
		break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;

	}

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_capture_button_press
* DESCRIPTION
*  capture button presse
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_capture_button_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CAPTURE_BUTTON_PRESS);
	/* capture only works if camera is ready, otherwise will ignore this action */
	if (mdi_camera_is_ready_to_capture() == TRUE)
	{
		/* HANDLE AF STATE */
#ifdef __CAMERA_AUTOFOCUS__
		if (g_camera_cntx.af_state == AF_CALCULATE)
		{
			g_camera_cntx.is_af_capture = TRUE;
			return;
		}

		/* avoid that audio hang when playing focus succeed sound */ 
		if (!MMI_CAMERA_IS_SILENT_MODE() && g_camera_cntx.setting.shutter_sound != CAMERA_SETTING_SHUTTER_SOUND_OFF && g_camera_cntx.is_audio_finished == FALSE)
		{
			return;
		}
#endif /* __CAMERA_AUTOFOCUS__ */ 

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

		/* if not self timer, capture the image */
		if (g_camera_cntx.setting.delay_timer == CAMERA_SETTING_DELAY_TIMER_OFF)
		{
			mmi_camera_capture();
		}
		else
		{
#ifndef __MMI_CAMERA_SLIM__
			CAMERA_ENTER_STATE(CAMERA_STATE_COUNTDOWN);
#else
			camera_enter_state(CAMERA_STATE_COUNTDOWN);
#endif
		}
	}
#ifdef __MMI_CAMERA_AF_TEST__
	else if (g_camera_cntx.is_af_test == TRUE)
	{
		mmi_camera_capture_button_press();
	}
#endif /* __MMI_CAMERA_AF_TEST__ */ 
	/* flush key event */
	ClearKeyEvents();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_capture_button_release
* DESCRIPTION
*  capture button release
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_capture_button_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CAPTURE_BUTTON_RELEASE);
	/* flush all key event */
	ClearKeyEvents();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_capture_play_sound
* DESCRIPTION
*  play capture shutter sound effect
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_capture_play_sound(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (MMI_CAMERA_IS_SILENT_MODE())
	{
		return;
	}
	kal_get_time(&g_camera_cntx.multi_sound_tick);
#if defined (__MMI_CAMERA_DIRECT_SENSOR_SUPPORT__)
	mdi_audio_play_id(TONE_WARNING1,DEVICE_AUDIO_PLAY_ONCE);
#else
	/* force to close multi channel sound */
#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)
	mmi_camera_burstshot_close_multi_sound();
	gui_cancel_timer(mmi_camera_burstshot_close_multi_sound);
#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

	/* play capture sound */
#ifndef __CAMERA_FEATURE_SHUTTER_SOUND__
#ifdef  __CAMERA_FEATURE_SHUTTER_SOUND_1__
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CAPTURE_SOUND,g_camera_cntx.setting.shutter_sound,__LINE__);
	mdi_audio_play_string_with_vol_path((void*)camera_sound_shutter_1, (U32) CAMERA_SOUND_SHUTTER_1_LEN,
#if defined(__MMI_CAMERA_HIGH_END__)
		MDI_FORMAT_WAV,
#else 
		MDI_FORMAT_DVI_ADPCM,
#endif 
		DEVICE_AUDIO_PLAY_ONCE,
		NULL, NULL, CAMERA_SHUTTER_SOUND_VOLUMN, MDI_DEVICE_SPEAKER_BOTH);
#endif /*__CAMERA_FEATURE_SHUTTER_SOUND_1__*/

#else   /*__CAMERA_FEATURE_SHUTTER_SOUND__*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CAPTURE_SOUND,g_camera_cntx.setting.shutter_sound,__LINE__);
	switch (g_camera_cntx.setting.shutter_sound)
	{
	case CAMERA_SETTING_SHUTTER_SOUND_1:
		{
#ifdef  __CAMERA_FEATURE_SHUTTER_SOUND_1__
			mdi_audio_play_string_with_vol_path((void*)camera_sound_shutter_1, (U32) CAMERA_SOUND_SHUTTER_1_LEN,
#if defined(__MMI_CAMERA_HIGH_END__)
				MDI_FORMAT_WAV,
#else 
				MDI_FORMAT_DVI_ADPCM,
#endif 
				DEVICE_AUDIO_PLAY_ONCE,
				NULL, NULL, CAMERA_SHUTTER_SOUND_VOLUMN, MDI_DEVICE_SPEAKER_BOTH);
#endif /*__CAMERA_FEATURE_SHUTTER_SOUND_1__*/
		} 
		break;

	case CAMERA_SETTING_SHUTTER_SOUND_2:
		{
#ifdef  __CAMERA_FEATURE_SHUTTER_SOUND_2__            
			mdi_audio_play_string_with_vol_path((void*)camera_sound_shutter_2, (U32) CAMERA_SOUND_SHUTTER_2_LEN,
#if defined(__MMI_CAMERA_HIGH_END__)
				MDI_FORMAT_WAV,
#else 
				MDI_FORMAT_DVI_ADPCM,
#endif 
				DEVICE_AUDIO_PLAY_ONCE,
				NULL, NULL, CAMERA_SHUTTER_SOUND_VOLUMN, MDI_DEVICE_SPEAKER_BOTH);
#endif /*__CAMERA_FEATURE_SHUTTER_SOUND_2__*/
		}
		break;

	case CAMERA_SETTING_SHUTTER_SOUND_3:
		{
#ifdef  __CAMERA_FEATURE_SHUTTER_SOUND_3__            
			mdi_audio_play_string_with_vol_path((void*)camera_sound_shutter_3, (U32) CAMERA_SOUND_SHUTTER_3_LEN,
#if defined(__MMI_CAMERA_HIGH_END__)
				MDI_FORMAT_WAV,
#else 
				MDI_FORMAT_DVI_ADPCM,
#endif 
				DEVICE_AUDIO_PLAY_ONCE,
				NULL, NULL, CAMERA_SHUTTER_SOUND_VOLUMN, MDI_DEVICE_SPEAKER_BOTH);
#endif /*__CAMERA_FEATURE_SHUTTER_SOUND_3__*/
		}
		break;

	case CAMERA_SETTING_SHUTTER_SOUND_OFF:
	default:
		/* do not play sound */
		break;
	}
#endif //__CAMERA_FEATURE_SHUTTER_SOUND__

#endif //__MMI_CAMERA_DIRECT_SENSOR_SUPPORT__
}

/*****************************************************************************
*
*  Utility drawing functions
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_draw_style_text
* DESCRIPTION
*  draw style text
* PARAMETERS
*  str             [IN]        String
*  offset_x        [IN]        Offset x
*  offset_y        [IN]        Offset y
*  style_txt       [IN]        Text style
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_draw_style_text(CHAR *  str, S32 offset_x, S32 offset_y, S32 truncated_width, const camera_style_text_struct *style_txt)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (mmi_fe_get_r2l_state())
	{
		offset_x += gui_get_string_width((UI_string_type) str);
	}

	if (truncated_width == 0){
		truncated_width = 10000;    /* a dummy large number */
	}
	if (style_txt->style == CAMERA_TEXT_STYLE_SHADOW){
		gui_set_text_color(gui_color(style_txt->style_r, style_txt->style_g, style_txt->style_b));
		gui_print_truncated_text(offset_x+1,offset_y+1,truncated_width,(UI_string_type) str);
		gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
		gui_print_truncated_text(offset_x,offset_y,truncated_width,(UI_string_type) str);
	}else if (style_txt->style == CAMERA_TEXT_STYLE_BORDER)
	{
		gui_set_text_border_color(gui_color(style_txt->style_r, style_txt->style_g, style_txt->style_b));
		gui_set_text_color(gui_color(style_txt->r, style_txt->g, style_txt->b));
		gui_print_truncated_borderd_text(offset_x,offset_y,truncated_width,(UI_string_type) str);
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_change_to_largest_img_size
* DESCRIPTION
*  change capture image size of camera application to the larget resolution.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_change_to_largest_img_size(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_CHANGE_TO_LARGEST_IMG_SIZE);
	g_camera_cntx.setting.image_size = 0;
	mmi_camera_update_img_size();

}

/*****************************************************************************
* FUNCTION
*  mmi_camco_get_ext_memory_usage
* DESCRIPTION
*  
* PARAMETERS
*  is_external     [IN]        
*  cur_id          [IN]        
* RETURNS
*  MMI_BOOL [OUT] can launch camcorde or not
*****************************************************************************/
U32 mmi_camera_get_ext_memory_usage(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U32 appmem_size = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
	appmem_size = CAMERA_HW_ROTATE_TMP_BUFFER;
#endif
	return appmem_size;

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_forward_to_hdlr
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_forward_to_hdlr(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
#ifdef __MMI_OPP_SUPPORT__
	cui_bt_sending_para_struct para;
	cui_bt_sending_obj_struct obj;
#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	switch(g_camera_cntx.forward_to)
	{
		/* Bluetooth sending API revise */
#ifdef __MMI_OPP_SUPPORT__
	case MMI_CAMERA_FORWARD_TO_BT:
		memset(&obj, 0, sizeof(obj));
		obj.data.obj_type = CUI_BT_SENDIND_USE_FILE;
		obj.data.u.file.path = (U16 *)g_camera_cntx.captured_filepath;
		para.obj = &obj;
#ifdef __MMI_BT_DEF_SEND_DEVICE__    
		para.option = CUI_BT_SENDIND_OPT_DEFAULT_DEVICE;
#else
		para.option = CUI_BT_SENDIND_OPT_NORMAL;
#endif
		cui_bt_sending_launch(g_camera_cntx.cur_gid, &para);
		break;
#endif /* __MMI_OPP_SUPPORT */

#ifdef __MMI_EMAIL__
	case MMI_CAMERA_FORWARD_TO_EMAIL:
		{
#ifndef __MMI_OP11_CAMERA_VDOREC_CUSTOMIZE__    
			mmi_email_app_send_param_struct email_param;
#endif

#ifdef __MMI_OP11_CAMERA_VDOREC_CUSTOMIZE__
			mmi_email_app_send_attch_to_addr((CHAR * ) g_camera_cntx.captured_filepath);
#else /* __MMI_OP11_CAMERA_VDOREC_CUSTOMIZE__ */
			mmi_email_app_send_init_param_to_null(&email_param);
			email_param.attch_file_path = (CHAR * )g_camera_cntx.captured_filepath;
			mmi_email_app_send(&email_param, EMAIL_ATTCH_FILL_FLAG);
#endif /* __MMI_OP11_CAMERA_VDOREC_CUSTOMIZE__ */
		}
		break;
#endif /* __MMI_EMAIL__ */

#ifdef __MMI_MMS__
	case MMI_CAMERA_FORWARD_TO_MMS:
		mms_content_insert_hdlr((CHAR * ) g_camera_cntx.captured_filepath);
		break;
#endif /* __MMI_MMS__ */

#ifdef __MMI_MMS_POSTCARD__
	case MMI_CAMERA_FORWARD_TO_POSTCARD:
		{
			mms_content_entry_struct mms_content;
			memset(&mms_content, 0x00, sizeof(mms_content_entry_struct));

			mms_content.mode = MMS_NEW_FILE;
			mms_content.msg_type = MMS_MSG_TYPE_POSTCARD;
			mms_content.file_path = g_camera_cntx.captured_filepath;
			mms_content.addr = 0;
			mms_content.subject = 0;
			mms_content.text_buffer = 0;
			mms_general_insert_hdlr(&mms_content);
		}
		break;
#endif /* __MMI_MMS_POSTCARD__ */
	default:
		ASSERT(0);
		break;
	}
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_forward_menu_screen
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_entry_forward_menu_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 ItemList[16];
	U16 ItemIcons[16];
	U16 nItems;
	U8 *guiBuffer;
	U8 *PopUpList[32];
	S32 i;
	MMI_BOOL entry_ret;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	entry_ret = mmi_frm_scrn_enter (g_camera_cntx.cur_gid, SCR_ID_CAMERA_FORWARD_OPTION, mmi_camera_resume_blt, mmi_camera_entry_forward_menu_screen, MMI_FRM_FG_ONLY_SCRN);
	if (!entry_ret)
	{
		return;
	}
	mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_IMMEDIATE);

#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	if (mmi_camera_is_forward_function_ready())
	{
		mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION);
		mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS);
		mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL);
	}
	else
	{
		mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION);
	}
#if defined(__MMI_MMS_POSTCARD__)
	if (mms_is_ready())
	{
		mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_POSTCARD);
	}
	else
	{
		mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_POSTCARD);
	}

#endif

	/*OP12 spec request not show E-mail after capture*/
#if !defined(__OP12__)
#if defined(__MMI_EMAIL__) 
	if (mmi_email_is_email_can_forward()==TRUE)
	{
		mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL);
	}
	else
	{
		mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL);
	}
#endif
#endif


#if defined(__MMI_MMS__)
	if (mms_is_ready())
	{
		mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS);
	}
	else
	{
		mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS);
	}
#endif

#if defined(__MMI_OPP_SUPPORT__)
	if (mmi_bt_is_to_display_bt_menu() == MMI_TRUE)
	{
		mmi_frm_unhide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_BT);
	}
#else
	mmi_frm_hide_menu_item(MENU_ID_CAMERA_FORWARD_OPTION_TO_BT);
#endif

	guiBuffer = mmi_frm_scrn_get_gui_buf(g_camera_cntx.cur_gid, SCR_ID_CAMERA_FORWARD_OPTION);
	nItems = GetNumOfChild_Ext(MENU_ID_CAMERA_FORWARD_OPTION);
	GetSequenceStringIds_Ext(MENU_ID_CAMERA_FORWARD_OPTION, ItemList);
	GetSequenceImageIds_Ext(MENU_ID_CAMERA_FORWARD_OPTION, ItemIcons);
	SetParentHandler(MENU_ID_CAMERA_FORWARD_OPTION);

	RegisterHighlightHandler(ExecuteCurrHiliteHandler_Ext);

	for (i = 0; i < nItems && i < 16; i++)
	{
		PopUpList[i] = NULL;
		ItemIcons[i] = (U16) (IMG_GLOBAL_L1 + i);
	}

	ConstructHintsList(MENU_ID_CAMERA_FORWARD_OPTION, PopUpList);

	ShowCategory52Screen(
		STR_GLOBAL_SEND,
		GetRootTitleIcon(MENU_ID_CAMERA_APP),
		STR_GLOBAL_OK,
		IMG_GLOBAL_OK,
		STR_GLOBAL_BACK,
		IMG_GLOBAL_BACK,
		nItems,
		ItemList,
		ItemIcons,
		(U8 **) PopUpList,
		0,
		0,
		guiBuffer);
#ifndef __MMI_WGUI_DISABLE_CSK__
	ChangeCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
#endif
	SetCenterSoftkeyFunction(mmi_camera_forward_to_hdlr, KEY_EVENT_UP);
	SetLeftSoftkeyFunction(mmi_camera_forward_to_hdlr, KEY_EVENT_UP);
	SetRightSoftkeyFunction((mmi_void_funcptr_type)mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_is_forward_function_ready
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  MMI_BOOL
*****************************************************************************/
MMI_BOOL mmi_camera_is_forward_function_ready(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	MMI_BOOL ret = MMI_FALSE;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

#if defined(__MMI_OPP_SUPPORT__)
	/*if (srv_mode_switch_is_network_service_available() == MMI_TRUE ||
		mmi_bt_is_to_display_bt_menu() == MMI_TRUE)*/
	if (mmi_bt_is_to_display_bt_menu() == MMI_TRUE)	
	{
		ret = MMI_TRUE;
	}
#endif

#if defined(__MMI_EMAIL__)
	//if (mmi_email_is_email_can_forward() && srv_mode_switch_is_network_service_available() == MMI_TRUE)
	if (mmi_email_is_email_can_forward())
	{
		ret = MMI_TRUE;
	}
#endif

#if defined(__MMI_MMS__)
	if (mms_is_ready())
		// when flight mode, user can compose MMS, so do not need check this condition
		//&& srv_mode_switch_is_network_service_available() == MMI_TRUE)t
	{
		ret = MMI_TRUE;
	}
#endif

	return ret;
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_get_max_capture_resolution
* DESCRIPTION
*  
* PARAMETERS
*  S32 *width  [out] width of max capture resolution
*  S32 *height [out] height of max capture resolution
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_get_max_capture_resolution(S32 *width, S32 *height)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#if defined(__CAMERA_FEATURE_IMAGE_SIZE_LL__)
	*width = CAMERA_FEATURE_IMAGE_SIZE_LL_WIDTH;
	*height = CAMERA_FEATURE_IMAGE_SIZE_LL_HEIGHT;
#elif defined(__CAMERA_FEATURE_IMAGE_SIZE_L__)
	*width = CAMERA_FEATURE_IMAGE_SIZE_L_WIDTH;
	*height = CAMERA_FEATURE_IMAGE_SIZE_L_HEIGHT;
#elif defined(__CAMERA_FEATURE_IMAGE_SIZE_M__)
	*width = CAMERA_FEATURE_IMAGE_SIZE_M_WIDTH;
	*height = CAMERA_FEATURE_IMAGE_SIZE_M_HEIGHT;
#elif defined(__CAMERA_FEATURE_IMAGE_SIZE_S__)
	*width = CAMERA_FEATURE_IMAGE_SIZE_S_WIDTH;
	*height = CAMERA_FEATURE_IMAGE_SIZE_S_HEIGHT;
#elif defined(__CAMERA_FEATURE_IMAGE_SIZE_SS__)
	*width = CAMERA_FEATURE_IMAGE_SIZE_SS_WIDTH;
	*height = CAMERA_FEATURE_IMAGE_SIZE_SS_HEIGHT;
#else
#error "please check setting of mmi_features_camera.h" 
#endif
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_reentry_preview_state
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_reentry_preview_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_PREVIEW);
#endif
	}
	ClearKeyEvents();    
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_reset_osd_layer
* DESCRIPTION
*  this api is used in delete confirm state to reset osdlayer to correct state.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_reset_osd_layer(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifndef __MMI_CAMERA_SLIM__
	if (g_camera_cntx.osd_layer_buf_ptr0 == NULL )
	{

		g_camera_cntx.osd_layer_buf_ptr0 = mmi_frm_scrmem_alloc_framebuffer(CAMERA_OSD_BUFFER_SIZE);
		ASSERT(g_camera_cntx.osd_layer_buf_ptr0 != NULL);
	}
#endif
	/*currently in order to save memory, we will steal GDI memory, 
	NOTE : we only use the memory, but do not use the handle */
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
    mmi_camera_use_gdi_layer();
	if (g_camera_cntx.osd_layer_handle == GDI_NULL_HANDLE)
	{        
#ifndef __MMI_CAMERA_SLIM__
		gdi_layer_create_cf_double_using_outside_memory(
			GDI_COLOR_FORMAT_16,
			0,
			0,
			LCD_WIDTH,
			LCD_HEIGHT,
			&g_camera_cntx.osd_layer_handle,
			(PU8) g_camera_cntx.osd_layer_buf_ptr0,
			(S32) CAMERA_OSD_BUFFER_SIZE,
			(PU8) g_camera_cntx.osd_buf_p, 
			(S32) CAMERA_OSD_BUFFER_SIZE);

		gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
		gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
		gdi_layer_set_source_key(TRUE, GDI_COLOR_TRANSPARENT);
		gdi_layer_pop_and_restore_active();
#else
		mmi_camera_create_osd_layer();
#endif
	}
#endif
#if defined(__CAMERA_OSD_HORIZONTAL__)
	mmi_camera_check_osd_orientation();
#endif
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	
	mmi_camera_create_osd_region_layers();

#endif

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_reset_base_layer
* DESCRIPTION
*  this api is used in delete confirm state to reset baselayer to correct state.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_reset_base_layer(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
	int i;
#endif
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

#if defined(__CAMERA_OSD_HORIZONTAL__)
	gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_0)
	{
		gdi_layer_resize(LCD_WIDTH, LCD_HEIGHT);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
		gdi_layer_clear_background(GDI_COLOR_BLACK);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
		for(i = 0; i < 4; i++)
		{
			gdi_layer_set_active(g_camera_cntx.osd_layer_region_handle[i]);
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
		}
#else
		gdi_layer_set_active(g_camera_cntx.osd_layer_handle);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
#endif
	}
	else if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		gdi_layer_resize(LCD_HEIGHT, LCD_WIDTH);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);

		gdi_layer_clear_background(GDI_COLOR_BLACK);
	}
	gdi_layer_pop_and_restore_active();
#else
	gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
	// gdi_layer_resize(LCD_WIDTH, LCD_HEIGHT);
	gdi_layer_clear_background(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_file
* DESCRIPTION
*  This function is delete captured image
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_delete_file(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	FS_HANDLE file_check;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* ENTER EXIT STATE */
	g_camera_cntx.app_state = CAMERA_STATE_EXIT;

	file_check = FS_Delete((U16*) g_camera_cntx.captured_filepath);
	if (file_check != FS_NO_ERROR)
	{
		MMI_ID_TYPE str_id;

		str_id = srv_fmgr_fs_error_get_string(file_check);
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP(str_id, MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
		mmi_camera_display_popup(str_id, ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
			(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif

		return;
	}
}


mmi_ret mmi_camera_delete_confirmCb(mmi_alert_result_evt_struct *evt)
{
	if (evt->evt_id == EVT_ID_ALERT_QUIT)
	{
		switch (evt->result)
		{
		case MMI_ALERT_CNFM_OK:
			// handle softkey event here
			break;
		case MMI_ALERT_CNFM_YES:
			mmi_camera_delete_file();
			break;
		case MMI_ALERT_CNFM_NO:
			mmi_frm_scrn_close_active_id();
			// handle softkey event here
			break;
		}
	}
	return MMI_RET_OK;
}
/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_option_cmd_hdlr
* DESCRIPTION
*  This function is the menu item handler for cascading menu.
* PARAMETERS
*  menu_id         [IN]        Menu ID
* RETURNS
*  MMI_TRUE if the command is handled; otherwise, MMI_FALSE to follow the 
*  cascading menu rule.
*****************************************************************************/
#ifdef __MMI_CASCADED_OPTION_MENU__
static MMI_BOOL mmi_camera_delete_confirm_option_cmd_hdlr(U16 menu_id)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mmi_confirm_property_struct arg;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DELTE_CONFIRM_OPTION_HDLR);
	mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
	arg.callback = (mmi_proc_func)mmi_camera_delete_confirmCb;
	arg.parent_id = g_camera_cntx.cur_gid;
	arg.f_auto_map_empty_softkey = MMI_FALSE;
	switch (menu_id)
	{
	case MENU_ID_CAMERA_FORWARD_OPTION:
		return MMI_FALSE;            
#if defined(__MMI_PHOTOEDITOR__)
	case MENU_ID_CAMERA_CONFIRM_OPTION_EDIT:
		mmi_phoedt_entry_from_fmgr((WCHAR*)g_camera_cntx.captured_filepath);
		return MMI_TRUE;
#endif /* __MMI_PHOTOEDITOR__ */
	case MENU_ID_CAMERA_CONFIRM_OPTION_DELETE:
#if defined(__MMI_SCREEN_ROTATE__)
		arg.rotation = (mmi_frm_screen_rotate_enum)g_camera_cntx.osd_data.osd_rotate;
		arg.f_auto_map_empty_softkey = MMI_FALSE;
#endif /* __MMI_SCREEN_ROTATE__ */
		mmi_confirm_display_ext(STR_ID_CAMERA_DELETE_ASK, MMI_EVENT_QUERY, &arg);
		return MMI_TRUE;

#ifdef __MMI_OPP_SUPPORT__
	case MENU_ID_CAMERA_FORWARD_OPTION_TO_BT:
		g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_BT;
		mmi_camera_forward_to_hdlr();
		return MMI_TRUE;
#endif
		
#ifdef __MMI_EMAIL__
	case MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL:
		g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_EMAIL;
		mmi_camera_forward_to_hdlr();
		return MMI_TRUE;
#endif
		
#ifdef __MMI_MMS__	
	case MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS:
		g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_MMS;
		mmi_camera_forward_to_hdlr();
		return MMI_TRUE;
#endif
		
#if defined(__MMI_MMS_POSTCARD__)
	case MENU_ID_CAMERA_FORWARD_OPTION_TO_POSTCARD:
		g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_POSTCARD;
		mmi_camera_forward_to_hdlr();
		return MMI_TRUE;
#endif
	default:
		break;
	}

	return MMI_FALSE;
}
#endif

MMI_BOOL mmi_camera_entry_app_pre_check(void)
{
	MMI_STR_ID string_id = 0;
	mmi_event_notify_enum event_type = MMI_EVENT_DEFAULT;
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_APP_SCREEN);

	if (mmi_is_redrawing_bk_screens() == MMI_TRUE)
	{
		return MMI_TRUE;
	}
#if defined(__MMI_CAMERA_BG_CALL__)
	if (srv_ucm_is_background_call()==TRUE)
	{
		string_id = mmi_ucm_get_error_info(MMI_UCM_ERR_IS_BG_CALL, &event_type);
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP((string_id), event_type, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
		mmi_camera_display_popup(string_id,event_type,(void *)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
		return MMI_FALSE;
	}
#endif

#ifdef __USB_IN_NORMAL_MODE__
	if (srv_usb_is_in_mass_storage_mode())
	{
		/* phone drive is exported, cant use this app */
		string_id = mmi_usb_get_error_info(SRV_USB_ERROR_UNAVAILABLE, &event_type);

		//if (!CAMERA_STATE_IN(CAMERA_STATE_EXIT))
		//CAMERA_ENTER_STATE(CAMERA_STATE_EXIT);
		//if (mmi_frm_group_is_present(APP_CAMERA))
		//{
		//mmi_frm_group_close(APP_CAMERA);   
		//}

#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP((string_id), event_type, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
		mmi_camera_display_popup(string_id,event_type,(void *)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
		return MMI_FALSE;
	}
#endif /* __USB_IN_NORMAL_MODE__ */ 

#if defined(__CAMERA_FEATURE_STORAGE__)
	/*No phone storage*/

	//mmi_camera_check_storage();

	/*No phone storage*/
	/* if (SRV_FMGR_PUBLIC_DRV == SRV_FMGR_CARD_DRV || SRV_FMGR_PUBLIC_DRV == FS_DRIVE_NOT_FOUND)
	{
	// only memory card but plugout, need show popup
	if (FS_NO_ERROR != FS_GetDevStatus(SRV_FMGR_CARD_DRV ,FS_MOUNT_STATE_ENUM))
	{
	#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_DISPLAY_POPUP((STR_GLOBAL_INSERT_MEMORY_CARD), MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
	#else
	mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_INSERT_MEMORY_CARD), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
	(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
	#endif
	return MMI_FALSE;
	}
	}*/
#endif

#if defined(__MMI_CAMERA_DIRECT_SENSOR_SUPPORT__) || defined(MMI_CAMERA_CHECK_BEARER)
#if defined(__TCPIP__)
	{
		mmi_event_notify_enum event_id = MMI_EVENT_DEFAULT;
		srv_cbm_result_error_enum cbm_result;

		if (g_camera_cntx.cbm_app_id == 0xFF)
		{
			cbm_result = cbm_register_app_id(&g_camera_cntx.cbm_app_id);
			if (cbm_result != 0)
			{
				srv_cbm_get_nwk_srv_error_info(cbm_result, &string_id, &event_id);
#ifndef __MMI_CAMERA_SLIM__
				MMI_CAMERA_DISPLAY_POPUP((string_id), event_id, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
				mmi_camera_display_popup((string_id), event_id, 
					(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
				return MMI_FALSE;
			}
		}
		cbm_result = srv_cbm_disallow_nwk_srv(SRV_CBM_BEARER_GPRS, g_camera_cntx.cbm_app_id);
		if (cbm_result != 0)
		{
			srv_cbm_get_nwk_srv_error_info(cbm_result, &string_id, &event_id);
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP((string_id), event_id, MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
			mmi_camera_display_popup((string_id), event_id, 
				(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
			return MMI_FALSE;
		}
	}
#endif
#endif

#if !defined(__MMI_CAMERA_DIRECT_COUPLE__) && (!defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) || !defined(__CAMERA_OSD_HORIZONTAL__))
	if (mmi_am_is_using_media_memory())
	{
		S32 popup_type;
		string_id = mmi_am_get_error_info(MMI_MRE_ERR_IS_UNAVAILABLE, &popup_type);
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP(
			(string_id),
			MMI_EVENT_FAILURE,
			MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
		mmi_camera_display_popup((string_id), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
			(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
		return MMI_FALSE;
	}
#endif

	return MMI_TRUE;
}


#if defined(__CAMERA_FEATURE_STORAGE__)

MOD_API void mmi_camera_set_storage_to(U16 storage)
{
	CHAR storage_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
	S32 create_result;
	MMI_ID_TYPE error_str_id;

	mmi_imgview_set_storage((U16)storage);

	create_result = mmi_imgview_get_storage_file_path((WCHAR*)storage_filepath);//mmi_imgview_create_file_dir(storage_filepath);
	if (create_result < 0)
	{
		error_str_id = srv_fmgr_fs_error_get_string(create_result);
		mmi_imgview_set_storage(storage);
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP((error_str_id), srv_fmgr_fs_error_get_popup_type(create_result), MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#else
		mmi_camera_display_popup((error_str_id), ((mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(create_result)), 
			(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP);
#endif
	}
	else
	{
		mmi_imgview_set_storage_ready();
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_DISPLAY_POPUP((STR_GLOBAL_DONE), MMI_EVENT_SUCCESS, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
		mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_DONE), ((mmi_event_notify_enum)MMI_EVENT_SUCCESS), 
			(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_wgtmgr_select_storage_rsp_hdlr
* DESCRIPTION
*  This function is to sort widget with quick sort algorithm
* PARAMETERS
*  left:  [IN] left position 
*  right: [IN] right position
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_select_storage_rsp_hdlr(mmi_event_struct *evt)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	cui_storage_selector_result_event_struct *param = 
		(cui_storage_selector_result_event_struct *)evt;
	CHAR storage_filepath[SRV_FMGR_PATH_BUFFER_SIZE];
	S32 create_result;
	MMI_ID_TYPE error_str_id;
	U16 storage;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (param->result > 0) /* user selects a storage */
	{
		storage = mmi_imgview_get_storage();

		create_result = mmi_imgview_set_storage((U16)param->result);
		if (create_result < 0)
		{
			error_str_id = srv_fmgr_fs_error_get_string(create_result);
			mmi_imgview_set_storage(storage);
			gdi_layer_get_base_handle(&g_camera_cntx.base_layer_handle);
			gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
			gdi_layer_clear(GDI_COLOR_BLACK);
			gdi_layer_pop_and_restore_active();
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP((error_str_id), srv_fmgr_fs_error_get_popup_type(create_result), MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
			mmi_camera_display_popup((error_str_id), ((mmi_event_notify_enum)srv_fmgr_fs_error_get_popup_type(create_result)), 
				(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif
		}
		else
		{
			mmi_imgview_get_storage_file_path((WCHAR*)storage_filepath);//mmi_imgview_create_file_dir(storage_filepath);
			mmi_imgview_set_storage_ready();
#ifndef __MMI_CAMERA_SLIM__
			MMI_CAMERA_DISPLAY_POPUP((STR_GLOBAL_DONE), MMI_EVENT_SUCCESS, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
			mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_DONE), ((mmi_event_notify_enum)MMI_EVENT_SUCCESS), 
				(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif
		}
	}
	else
	{
		create_result = mmi_imgview_get_storage_file_path((WCHAR*)storage_filepath);//mmi_imgview_create_file_dir(storage_filepath);
		if (create_result < 0)
		{
			mmi_frm_group_close(g_camera_cntx.cur_gid);
		}
		else
		{
			mmi_imgview_set_storage_ready();
		}
	}
	/* close File Manger CUI */
	cui_storage_selector_close(param->sender_id);
}
#endif //__CAMERA_FEATURE_STORAGE__

#if defined(__CAMERA_OSD_HORIZONTAL__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_config_layer_orientation
* DESCRIPTION
*  config layer orientation while HORIZONTAL_CAMERA is on.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_config_layer_orientation(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	/* if no tvout, we always use LCD rotate */
	gdi_lcd_set_rotate_by_layer(TRUE);

	g_camera_cntx.osd_data.previous_osd_rotate = CAMERA_DISPLAY_ROTATE_RESET;
	mmi_camera_check_osd_orientation();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_check_osd_orientation
* DESCRIPTION
*  update display rotate (0 | 90 | 180 | 270 )
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_config_osd_layer(gdi_handle handle,U8 rotate_value)
{
	gdi_layer_push_and_set_active(handle);
	if(handle == g_camera_cntx.osd_layer_handle)
	{
		gdi_layer_toggle_double();
	}
	gdi_layer_set_rotate(rotate_value);
	gdi_layer_resize(g_camera_cntx.osd_UI_device_width, g_camera_cntx.osd_UI_device_height);
	gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
	gdi_layer_pop_and_restore_active(); 

}
static void mmi_camera_check_osd_orientation(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.osd_data.previous_osd_rotate != g_camera_cntx.osd_data.osd_rotate)
	{
		switch (g_camera_cntx.osd_data.osd_rotate)
		{
		case CAMERA_DISPLAY_ROTATE_0:
			g_camera_cntx.active_camera_osd_ptr = &g_camera_skin_cntx;
			g_camera_cntx.osd_UI_device_height = LCD_HEIGHT;
			g_camera_cntx.osd_UI_device_width = LCD_WIDTH;
			/*@ Add by Vincent  */
			/* if using idp rotate, we need to config osd buffer for idp rotate only, we do not need to config original osd layer as horizontal */
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
			/*            kal_wap_trace(MOD_MMI, TRACE_GROUP_3, "[cam][6253] 6) config idp_rotate_layer (width,height) = (%d,%d)",g_camera_cntx.osd_UI_device_width,g_camera_cntx.osd_UI_device_height);*/
#ifndef __MMI_CAMERA_SLIM__
			gdi_layer_push_and_set_active(g_camera_cntx.osd_idp_rotate_layer_handle);
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
			gdi_layer_resize(g_camera_cntx.osd_UI_device_width, g_camera_cntx.osd_UI_device_height);
			gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
			gdi_layer_pop_and_restore_active();
#else
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
			mmi_camera_config_osd_layer(g_camera_cntx.osd_idp_rotate_layer_handle,GDI_LAYER_ROTATE_0);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
#endif//__MMI_CAMERA_SLIM__
#else
#ifndef __MMI_CAMERA_SLIM__
			gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
			gdi_layer_toggle_double();
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
			gdi_layer_resize(g_camera_cntx.osd_UI_device_width, g_camera_cntx.osd_UI_device_height);
			gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
			gdi_layer_pop_and_restore_active();
#else
			mmi_camera_config_osd_layer(g_camera_cntx.osd_layer_handle,GDI_LAYER_ROTATE_0);
#endif
#endif//__CAMERA_OSD_HORIZONTAL__
			break;
#if defined(__CAMERA_OSD_HORIZONTAL__)
		case CAMERA_DISPLAY_ROTATE_270:
			g_camera_cntx.active_camera_osd_ptr = &g_camera_skin_cntx_270;
			g_camera_cntx.osd_UI_device_height = LCD_WIDTH;
			g_camera_cntx.osd_UI_device_width = LCD_HEIGHT;
			/*@ Add by Vincent */
			/* if using idp rotate, we need to config osd buffer for idp rotate only, we do not need to config original osd layer as horizontal */
#if defined(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
			/*            kal_wap_trace(MOD_MMI, TRACE_GROUP_3, "[cam][6253] 6) config idp_rotate_layer (width,height) = (%d,%d)",g_camera_cntx.osd_UI_device_width,g_camera_cntx.osd_UI_device_height);*/
#ifndef __MMI_CAMERA_SLIM__
			gdi_layer_push_and_set_active(g_camera_cntx.osd_idp_rotate_layer_handle);
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);
			gdi_layer_resize(g_camera_cntx.osd_UI_device_width, g_camera_cntx.osd_UI_device_height);
			gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
			gdi_layer_pop_and_restore_active(); 
#else 
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
			mmi_camera_config_osd_layer(g_camera_cntx.osd_idp_rotate_layer_handle,GDI_LAYER_ROTATE_90);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
#endif //__MMI_CAMERA_SLIM__
#else //(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)
#ifndef __MMI_CAMERA_SLIM__
			gdi_layer_push_and_set_active(g_camera_cntx.osd_layer_handle);
			gdi_layer_toggle_double();
			gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);
			gdi_layer_resize(g_camera_cntx.osd_UI_device_width, g_camera_cntx.osd_UI_device_height);
			gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
			gdi_layer_pop_and_restore_active();
#else
#ifndef __MMI_CAMERA_MULTI_OSD_LAYER__
			mmi_camera_config_osd_layer(g_camera_cntx.osd_layer_handle,GDI_LAYER_ROTATE_90);
#endif //__MMI_CAMERA_MULTI_OSD_LAYER__
#endif //__MMI_CAMERA_SLIM__
#endif //(__CAMERA_FEATURE_ROTATE_OSD_SELF__) && defined(__CAMERA_OSD_HORIZONTAL__)

			break;
#endif /* __CAMERA_OSD_HORIZONTAL__ */
		default:
			ASSERT(0);
			break;
		}

		g_camera_cntx.osd_data.previous_osd_rotate = g_camera_cntx.osd_data.osd_rotate;
#if defined(__MMI_TOUCH_SCREEN__)
		mmi_camera_update_osd_touch_icon();
#endif
	}
}

#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

#if defined(__MMI_CAMERA_BG_CALL__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_incall_set_key_hdlr
* DESCRIPTION
*  set key handler
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_incall_popup_error(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_DISPLAY_POPUP((STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL), MMI_EVENT_FAILURE, MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#else
	mmi_camera_display_popup(((MMI_ID_TYPE)STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL), ((mmi_event_notify_enum)MMI_EVENT_FAILURE), 
		(void*)MMI_CAMERA_POPUP_RESULT_PROCESS_NONE);
#endif
}


#endif /* __MMI_CAMERA_BG_CALL__ */


#ifdef __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__
/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_draw_contshot_countbar
* DESCRIPTION
*  draw contshot contbar
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_draw_contshot_countbar(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 img_id;
	S32 image_width;
	S32 image_height;
	S32 box_height;
	S32 offset_x;
	S32 offset_y;
	S32 remain_shot;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (g_camera_cntx.setting.cont_shot)
	{
	case CAMERA_SETTING_CONT_SHOT_1:
		img_id = IMG_ID_CAMERA_OSD_CONT_SHOT_BAR_1;
		break;

	case CAMERA_SETTING_CONT_SHOT_2:
		img_id = IMG_ID_CAMERA_OSD_CONT_SHOT_BAR_2;
		break;

	case CAMERA_SETTING_CONT_SHOT_3:
		img_id = IMG_ID_CAMERA_OSD_CONT_SHOT_BAR_3;
		break;

	default:
		img_id = 0;
	}

	gdi_image_get_dimension_id(img_id, &image_width, &image_height);

	box_height = image_height / g_camera_cntx.cont_shot_total_count;
	remain_shot = g_camera_cntx.cont_shot_total_count - g_camera_cntx.cont_shot_count;

	if (g_camera_skin_cntx.cont_count_bar.is_top_align)
	{
		/* top align */
		offset_x = g_camera_skin_cntx.cont_count_bar.offset_x;
		offset_y = g_camera_skin_cntx.cont_count_bar.offset_y;

		gdi_layer_push_and_set_clip(offset_x, 
			offset_y, 
			offset_x + image_width - 1, 
			offset_y + box_height * remain_shot - 1);

		gdi_image_draw_id(offset_x, offset_y, img_id);
		gdi_layer_pop_clip();
	}
	else
	{
		/* bottom align */
		offset_x = g_camera_skin_cntx.cont_count_bar.offset_x;
		offset_y = g_camera_skin_cntx.cont_count_bar.offset_y;

		gdi_layer_push_and_set_clip(offset_x, 
			offset_y - box_height * remain_shot + 1, 
			offset_x + image_width - 1, 
			offset_y);

		gdi_image_draw_id(offset_x, offset_y - image_height + 1, img_id);
		gdi_layer_pop_clip();
	}

}
#endif /* __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__ */ 

#if defined(__CAMERA_FEATURE_XENON_FLASH__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_xenon_flash_callback
* DESCRIPTION
*  xenon flash light indicator (from MED) hdlr
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_xenon_flash_callback(mdi_result result, void* user_data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (CAMERA_STATE_IN(CAMERA_STATE_PREVIEW)||CAMERA_STATE_IN(CAMERA_STATE_SUB_PREVIEW))
	{
		switch(result)
		{
		case MDI_RES_CAMERA_SUCCEED:
			g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_READY;
			mmi_camera_preview_draw_osd();
			mmi_camera_blt();
			break;
		case MDI_RES_CAMERA_XENONFLASH_CHARGING:
			if (g_camera_cntx.xenon_flash_state == MMI_CAMERA_XENON_FLASH_CHARGING)
				g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_CHARGING_1;
			else
				g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_CHARGING;

			mmi_camera_preview_draw_osd();
			mmi_camera_blt();
			break;
		case MDI_RES_CAMERA_ERR_XENONFLASH_TIMEOUT:
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_XENONFLASH_TIMEOUT;
			g_camera_cntx.setting.flash = CAMERA_SETTING_FLASH_OFF;
			g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_OFF;
			mmi_camera_display_error_popup();                
			break;
		case MDI_RES_CAMERA_ERR_XENONFLASH_LOW_BATTERY:
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_XENONFLASH_LOW_BATTERY;
			g_camera_cntx.setting.flash = CAMERA_SETTING_FLASH_OFF;
			g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_OFF;
			mmi_camera_display_error_popup();                
			break;
		}
	}
}
#endif

#ifdef __CAMERA_AUTOFOCUS__

/*****************************************************************************
* FUNCTION
*  mmi_camera_play_af_succeed_finished
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_play_af_succeed_finished(mdi_result result, void* user_data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.is_audio_finished = TRUE;

	/* check if af is calculating by user half press soon after af callback,
	if no, reset is_autofocus_pressed flag , 2007/10/31 */
	if (g_camera_cntx.af_state != AF_CALCULATE)
		g_camera_cntx.is_autofocus_pressed = MMI_FALSE;    

	if (g_camera_cntx.is_af_capture == TRUE)
	{
		g_camera_cntx.is_af_capture = FALSE;
		mmi_camera_capture_button_press();
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_autofocus_callback
* DESCRIPTION
*  callback while AF is succeed/fail
* PARAMETERS
*  result      [IN]        
*  void(?)     [OUT]       PMsg
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_autofocus_callback(mdi_camera_af_result_struct result, void* user_data)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* parse pMsg to get result */
	/* and response to osd layer */
	if (g_camera_cntx.af_state == AF_CANCEL)
	{
		return;
	}

#if !defined(MT6238) && !defined(MT6239)
	g_camera_cntx.af_result = (U8) result.af_result;
#else
	g_camera_cntx.af_result = (U8) result.af_result;
#endif
	if (g_camera_cntx.app_state != CAMERA_STATE_EXIT)
	{
		if (g_camera_cntx.af_result == 0xFF)
		{
			g_camera_cntx.af_state = AF_FAIL;
			/* send cancel command to driver to stop cal focus */
			gui_cancel_timer(mmi_camera_preview_draw_osd_timer);

			mmi_camera_preview_draw_osd();
			mmi_camera_blt();

			if (g_camera_cntx.is_af_capture == TRUE)
			{
				g_camera_cntx.is_af_capture = FALSE;
				mmi_camera_capture_button_press();
			}

			/* reset is_autofocus_pressed flag */
			g_camera_cntx.is_autofocus_pressed = MMI_FALSE;

		}
		else
		{
			g_camera_cntx.af_state = AF_SUCCEED;

			/* send cancel command to driver to stop cal focus */
			gui_cancel_timer(mmi_camera_preview_draw_osd_timer);
			mmi_camera_preview_draw_osd();
			mmi_camera_blt();

			{   /* play sound tmp */

				BEFORE_PLAY_AUDIO();
				if (!MMI_CAMERA_IS_SILENT_MODE() && g_camera_cntx.setting.shutter_sound != CAMERA_SETTING_SHUTTER_SOUND_OFF)
				{
#if defined(__MMI_CAMERA_HIGH_END__)
					mdi_audio_play_string_with_vol_path(
						(void*)camera_af_succeed,
						(U32) CAMERA_SOUND_AF_SUCCEED_LEN,
						MDI_FORMAT_WAV,
						DEVICE_AUDIO_PLAY_ONCE,
						(mdi_ext_callback) mmi_camera_play_af_succeed_finished,
						NULL,
						CAMERA_SHUTTER_SOUND_VOLUMN,
						MDI_DEVICE_SPEAKER_BOTH);
#else /* __MMI_CAMERA_HIGH_END__ */ 
					mdi_audio_play_string_with_vol_path(
						(void*)camera_sound_shutter_3,
						(U32) CAMERA_SOUND_SHUTTER_3_LEN,
						MDI_FORMAT_DVI_ADPCM,
						DEVICE_AUDIO_PLAY_ONCE,
						(mdi_ext_callback) mmi_camera_play_af_succeed_finished,
						NULL,
						CAMERA_SHUTTER_SOUND_VOLUMN,
						MDI_DEVICE_SPEAKER_BOTH);
#endif /* __MMI_CAMERA_HIGH_END__ */ 
				}
				else
				{
					mmi_camera_play_af_succeed_finished(MDI_AUDIO_SUCCESS, NULL);
				}
			}
		}
	}
}

#ifdef __MMI_CAMERA_AF_TEST__


/*****************************************************************************
* FUNCTION
*  mmi_camera_af_test
* DESCRIPTION
*  press AF button
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_af_test()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.setting.cont_shot = CAMERA_SETTING_CONT_SHOT_1;
	g_camera_cntx.cont_shot_total_count = 50;
	g_camera_cntx.cont_shot_count = 0;
	g_camera_cntx.is_af_test = TRUE;

	mmi_camera_af_test_start();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_af_test_start
* DESCRIPTION
*  press AF button
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_af_test_start()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.is_autofocus_pressed = TRUE;
	g_camera_cntx.af_state = AF_CALCULATE;
	g_camera_cntx.af_animation_process = AF_ANIMATION_STEP1;

	/* send command to driver to start cal focus */
	mdi_camera_start_autofocus_process((mdi_callback) mmi_camera_autofocus_callback, NULL);

	/* draw animation for focus process */
	g_camera_cntx.is_draw_timer_on = TRUE;
	gui_start_timer(100, mmi_camera_preview_draw_osd_timer);

	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
	mmi_camera_capture_button_press();
}
#endif /* __MMI_CAMERA_AF_TEST__ */ 

#if defined(__AF_SUPPORT_ONE_KEY__) || defined(__MMI_CAMERA_AF_TEST__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_af_and_capture
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_af_and_capture(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_capture_button_autofocus_pressed();
	mmi_camera_capture_button_press();
}
#endif

static const camera_key_struct autofocus_keys[] = 

{

	/* register soft keys */
	{KEY_LSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_lsk_release, NULL},
	{KEY_RSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_rsk_release, NULL},    
#ifdef __CAMERA_AUTOFOCUS__
	{KEY_9, 0, NULL, mmi_camera_capture_button_autofocus_released, NULL},    
#endif /* __CAMERA_AUTOFOCUS__ */ 
	/* register capture and control keys */
#if (CAMERA_CAPTURE_KEY != -1)
	{CAMERA_CAPTURE_KEY, 0, mmi_camera_capture_button_press, mmi_camera_capture_button_release, NULL}, 
#endif

#if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{CAMERA_CAPTURE_EXTRA_KEY1, 0, mmi_camera_capture_button_press, mmi_camera_capture_button_release, NULL}, 
#endif

#if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{CAMERA_CAPTURE_EXTRA_KEY2, 0, mmi_camera_capture_button_press, mmi_camera_capture_button_release, NULL}, 
#endif

};

static const camera_key_hdlr_struct g_autofocus_key_hdlr = 
{autofocus_keys, sizeof(autofocus_keys)/sizeof(camera_key_struct), NULL};

/*****************************************************************************
* FUNCTION
*  mmi_camera_capture_button_autofocus_pressed
* DESCRIPTION
*  press AF button
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_capture_button_autofocus_pressed()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if (mdi_camera_is_ready_to_capture() == TRUE && g_camera_cntx.af_state != AF_CALCULATE)
	{
		g_camera_cntx.is_autofocus_pressed = MMI_TRUE;
		g_camera_cntx.af_state = AF_CALCULATE;
		g_camera_cntx.af_animation_process = AF_ANIMATION_STEP1;

		/* send command to driver to start cal focus */
		mdi_camera_start_autofocus_process((mdi_camera_af_ind_callback) mmi_camera_autofocus_callback,NULL);

		/* clear key handler */
		ClearInputEventHandler(MMI_DEVICE_KEY);
		p_act_key_hdlr = &g_autofocus_key_hdlr;

		/* draw animation for focus process */
		g_camera_cntx.is_draw_timer_on = TRUE;
		gui_start_timer(100, mmi_camera_preview_draw_osd_timer);

		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_capture_button_autofocus_released
* DESCRIPTION
*  release AF button
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_capture_button_autofocus_released()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.is_af_capture == FALSE)
	{

		g_camera_cntx.is_autofocus_pressed = MMI_FALSE;
		mdi_camera_stop_autofocus_process();

		g_camera_cntx.af_state = AF_CANCEL;

		/* register key */
		mmi_camera_preview_set_key_hdlr();

		/* send cancel command to driver to stop cal focus */
		gui_cancel_timer(mmi_camera_preview_draw_osd_timer);
		g_camera_cntx.is_draw_timer_on = FALSE;

		/* draw animation for stopping focus process */
		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_draw_bolder_rect
* DESCRIPTION
*  draw rect with bolder
* PARAMETERS
*  x1                  [IN]        Start x
*  y1                  [IN]        Start y
*  x2                  [IN]        End x
*  y2                  [IN]        End y
*  bolder_width        [IN]        Width of bolder
*  frame_color         [IN]        
*  gdi_color(?)        [IN]        Color of bolder
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_draw_bolder_rect(S32 x1, S32 y1, S32 x2, S32 y2, S32 bolder_width, gdi_color frame_color)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	gdi_draw_rect(x1 - bolder_width, y1 - bolder_width, x2 + bolder_width, y2 + bolder_width, frame_color);
	gdi_draw_rect(x1 + bolder_width, y1 + bolder_width, x2 - bolder_width, y2 - bolder_width, frame_color);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_draw_autofocus_process
* DESCRIPTION
*  draw AF related OSD
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_draw_autofocus_process()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/* U16 image_id = 0; */
	U16 af_x = 0;
	U16 af_y = 0;
	U16 af_width = 0;
#if defined(__CAMERA_AUTOFOCUS_5_ZONE__) || defined(__CAMERA_AUTOFOCUS_3_ZONE__)|| defined(__CAMERA_AUTOFOCUS_1_ZONE__)
	gdi_color af_color = 0;
#endif

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	switch (g_camera_cntx.af_state)
	{
	case AF_CALCULATE:

		if (g_camera_cntx.is_manual_autofocus == FALSE)
		{
			if (g_camera_cntx.af_animation_process == AF_ANIMATION_END)
			{
				g_camera_cntx.af_animation_process = AF_ANIMATION_STEP1;
			}

			switch (g_camera_cntx.setting.af_meter)
			{
#ifdef __CAMERA_AUTOFOCUS_5_ZONE__
	case CAMERA_SETTING_AUTOFOCUS_5_ZONE:
		switch (g_camera_cntx.af_animation_process)
		{
		case AF_ANIMATION_STEP1:
			af_color = GDI_COLOR_WHITE;
			break;
		case AF_ANIMATION_STEP2:
			af_color = GDI_COLOR_GRAY;
			break;
		case AF_ANIMATION_STEP3:
			af_color = GDI_COLOR_BLACK;
			break;
		}

		af_width = CAMERA_AF_SMALL_WIDTH;
		af_x = g_camera_cntx.af_zone0_x - af_width / 2;
		af_y = g_camera_cntx.af_zone0_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		af_x = g_camera_cntx.af_zone1_x - af_width / 2;
		af_y = g_camera_cntx.af_zone1_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		af_x = g_camera_cntx.af_zone2_x - af_width / 2;
		af_y = g_camera_cntx.af_zone2_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		af_x = g_camera_cntx.af_zone3_x - af_width / 2;
		af_y = g_camera_cntx.af_zone3_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		af_x = g_camera_cntx.af_zone4_x - af_width / 2;
		af_y = g_camera_cntx.af_zone4_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		break;
#endif /* __CAMERA_AUTOFOCUS_5_ZONE__ */ 
#ifdef __CAMERA_AUTOFOCUS_3_ZONE__
	case CAMERA_SETTING_AUTOFOCUS_3_ZONE:
		switch (g_camera_cntx.af_animation_process)
		{
		case AF_ANIMATION_STEP1:
			af_color = GDI_COLOR_WHITE;
			break;
		case AF_ANIMATION_STEP2:
			af_color = GDI_COLOR_GRAY;
			break;
		case AF_ANIMATION_STEP3:
			af_color = GDI_COLOR_BLACK;
			break;
		}

		af_width = CAMERA_AF_SMALL_WIDTH;
		af_x = g_camera_cntx.af_zone0_x - af_width / 2;
		af_y = g_camera_cntx.af_zone0_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		af_x = g_camera_cntx.af_zone1_x - af_width / 2;
		af_y = g_camera_cntx.af_zone1_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		af_x = g_camera_cntx.af_zone2_x - af_width / 2;
		af_y = g_camera_cntx.af_zone2_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, af_color);
		break;
#endif /* __CAMERA_AUTOFOCUS_3_ZONE__ */ 
#ifdef __CAMERA_AUTOFOCUS_1_ZONE__
	case CAMERA_SETTING_AUTOFOCUS_1_ZONE:
		{
			switch (g_camera_cntx.af_animation_process)
			{
			case AF_ANIMATION_STEP1:
				af_width = CAMERA_AF_LARGE_WIDTH;
				af_color = GDI_COLOR_WHITE;
				break;
			case AF_ANIMATION_STEP2:
				af_color = GDI_COLOR_GRAY;
				af_width = CAMERA_AF_NORMAL_WIDTH;
				break;
			case AF_ANIMATION_STEP3:
				af_color = GDI_COLOR_BLACK;
				af_width = CAMERA_AF_SMALL_WIDTH;
				break;
			}

			af_x = g_camera_cntx.af_zone0_x - af_width / 2;
			af_y = g_camera_cntx.af_zone0_y - af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_WHITE);
		}
		break;
#endif /* __CAMERA_AUTOFOCUS_1_ZONE__ */ 
	default:
		break;
			}
			g_camera_cntx.af_animation_process++;
		}
		else
		{

		}

		break;
	case AF_SUCCEED:
		switch (g_camera_cntx.setting.af_meter)
		{
#ifdef __CAMERA_AUTOFOCUS_5_ZONE__
	case CAMERA_SETTING_AUTOFOCUS_5_ZONE:
		af_width = CAMERA_AF_SMALL_WIDTH;
		if (g_camera_cntx.af_result & 0x01)
		{
			af_x = g_camera_cntx.af_zone0_x;
			af_y = g_camera_cntx.af_zone0_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		if (g_camera_cntx.af_result & 0x02)
		{
			af_x = g_camera_cntx.af_zone1_x;
			af_y = g_camera_cntx.af_zone1_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		if (g_camera_cntx.af_result & 0x04)
		{
			af_x = g_camera_cntx.af_zone2_x;
			af_y = g_camera_cntx.af_zone2_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		if (g_camera_cntx.af_result & 0x08)
		{
			af_x = g_camera_cntx.af_zone3_x;
			af_y = g_camera_cntx.af_zone3_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		if (g_camera_cntx.af_result & 0x10)
		{
			af_x = g_camera_cntx.af_zone4_x;
			af_y = g_camera_cntx.af_zone4_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		break;
#endif /* __CAMERA_AUTOFOCUS_5_ZONE__ */ 
#ifdef __CAMERA_AUTOFOCUS_3_ZONE__
	case CAMERA_SETTING_AUTOFOCUS_3_ZONE:
		af_width = CAMERA_AF_SMALL_WIDTH;

		if (g_camera_cntx.af_result & 0x01)
		{
			af_x = g_camera_cntx.af_zone0_x;
			af_y = g_camera_cntx.af_zone0_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		if (g_camera_cntx.af_result & 0x02)
		{
			af_x = g_camera_cntx.af_zone1_x;
			af_y = g_camera_cntx.af_zone1_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		if (g_camera_cntx.af_result & 0x04)
		{
			af_x = g_camera_cntx.af_zone2_x;
			af_y = g_camera_cntx.af_zone2_y;
			af_x -= af_width / 2;
			af_y -= af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		break;
#endif /* __CAMERA_AUTOFOCUS_3_ZONE__ */ 
#ifdef __CAMERA_AUTOFOCUS_1_ZONE__
	case CAMERA_SETTING_AUTOFOCUS_1_ZONE:
		{
			af_width = CAMERA_AF_SMALL_WIDTH;

			af_x = g_camera_cntx.af_zone0_x - af_width / 2;
			af_y = g_camera_cntx.af_zone0_y - af_width / 2;
			mmi_camera_draw_bolder_rect(
				af_x,
				af_y,
				af_x + af_width - 1,
				af_y + af_width - 1,
				1,
				GDI_COLOR_GREEN);
		}
		break;
#endif /* __CAMERA_AUTOFOCUS_1_ZONE__ */ 
	default:
		ASSERT(0);
		break;
		}

		break;
	case AF_FAIL:
		af_width = CAMERA_AF_SMALL_WIDTH;

		af_x = g_camera_cntx.af_zone0_x - af_width / 2;
		af_y = g_camera_cntx.af_zone0_y - af_width / 2;
		mmi_camera_draw_bolder_rect(af_x, af_y, af_x + af_width - 1, af_y + af_width - 1, 1, GDI_COLOR_RED);

		break;
	case AF_CANCEL:
		break;

	}

}

#endif /* __CAMERA_AUTOFOCUS__ */ 

#ifdef __CAMERA_FEATURE_EV__
/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_ev_cyclic
* DESCRIPTION
*  EV ajustment
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_ev_cyclic(void *is_inc)
{
#if !defined(__CAMERA_FEATURE_FTE_SUPPORT__)
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 is_terminate;
	S32 step;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EV_CYCLIC,is_inc,g_camera_cntx.setting.ev);
	if(is_inc){
		is_terminate = (g_camera_cntx.setting.ev >= CAMERA_SETTING_EV_COUNT - 1);
		step = 1;
	}else{
		is_terminate = (g_camera_cntx.setting.ev <= 0);
		step = -1;
	}

	if(!is_terminate)
	{
		g_camera_cntx.setting.ev += step;            

		mdi_camera_update_para_ev(camera_ev_command_map[g_camera_cntx.setting.ev]);

		mmi_camera_preview_set_hint(NULL, NULL, 0);
		mmi_camera_preview_draw_osd();
		mmi_camera_blt();

		gui_start_timer_ex(g_camera_cntx.is_long_key ? 300 : 100, mmi_camera_preview_ev_cyclic, is_inc);

	}
	else
	{
		g_camera_cntx.pressed_key = 0;
		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}
#endif
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_ev_inc_key_press
* DESCRIPTION
*  preview right arrow pressed, adjust EV
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_ev_inc_key_press(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EV_INC_PRESS);

#if !defined(__CAMERA_FEATURE_FTE_SUPPORT__)
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_ASSERT(g_camera_cntx.app_state == CAMERA_STATE_PREVIEW);
	g_camera_cntx.is_long_key = TRUE;
	mmi_camera_preview_ev_cyclic((void*)1);
	g_camera_cntx.is_long_key = FALSE;
#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_ev_dec_key_press
* DESCRIPTION
*  preview left arrow pressed, adjust EV
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_ev_dec_key_press(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EV_DEC_PRESS);

#if !defined(__CAMERA_FEATURE_FTE_SUPPORT__)
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_ASSERT(g_camera_cntx.app_state == CAMERA_STATE_PREVIEW);
	g_camera_cntx.is_long_key = TRUE;
	mmi_camera_preview_ev_cyclic((void*)0);
	g_camera_cntx.is_long_key = FALSE;
#endif
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_ev_dec_key_release
* DESCRIPTION
*  preview left arrow release
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_ev_key_release(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EV_RELEASE);

#if !defined(__CAMERA_FEATURE_FTE_SUPPORT__)

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	gui_cancel_timer((FuncPtr)mmi_camera_preview_ev_cyclic);
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
#endif
}

#endif /* __CAMERA_FEATURE_EV__ */


#ifdef __CAMERA_FEATURE_ZOOM__

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_zoom
* DESCRIPTION
*  zoom out
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_zoom(void *is_zoomin)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 is_terminate;
	S32 step;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PREVIEW_ZOOM,is_zoomin,g_camera_cntx.setting.zoom_idx);
	if(is_zoomin){
		is_terminate = (g_camera_cntx.setting.zoom_idx >= g_camera_cntx.max_zoom_steps);
		step = 1;
	}else{
		is_terminate = (g_camera_cntx.setting.zoom_idx == 0);
		step = -1;
	}

	if(!is_terminate)
	{
		g_camera_cntx.setting.zoom_idx += step;            

		mdi_camera_update_para_zoom(g_camera_cntx.setting.zoom_idx);

		mmi_camera_preview_set_hint(NULL, NULL, 0);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__	
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
#else
		mmi_camera_preview_draw_osd();
#endif
		mmi_camera_blt();

#if defined(ISP_SUPPORT)
		/* only build-in camera use long pressed zooming feature */
		/* since backend module's zooming time is not stable, will cause zooming jump two level */
#ifdef __CAMERA_FAST_ZOOM_SUPPORT__
		gui_start_timer_ex(500, mmi_camera_start_fast_zoom, is_zoomin);
#else /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 
		gui_start_timer_ex(g_camera_cntx.is_long_key ? 300 : 100, mmi_camera_preview_zoom, is_zoomin);
#endif /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 
#endif /* defined(ISP_SUPPORT) */ 

	}
	else
	{
		g_camera_cntx.pressed_key = 0;
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__

#else
		mmi_camera_preview_draw_osd();
#endif
		mmi_camera_blt();
	}
}

static void mmi_camera_preview_zoom_arrow_release()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	//kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: mmi_camera_preview_zoom_arrow_release,line = %d",__LINE__);			 
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ZOOM_RELEASE);

#ifdef __CAMERA_FAST_ZOOM_SUPPORT__
	if (g_camera_cntx.is_fast_zoom == TRUE)
	{
		g_camera_cntx.is_draw_timer_on = FALSE;
		gui_cancel_timer((FuncPtr)mmi_camera_start_fast_zoom);
		mmi_camera_stop_fast_zoom();
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__	
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
#else
		mmi_camera_preview_draw_osd();
#endif
		mmi_camera_blt();
		gui_cancel_timer(mmi_camera_preview_draw_osd_timer);
	}
	else
	{
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__

#else
		mmi_camera_preview_draw_osd();
#endif
		mmi_camera_blt();
		gui_cancel_timer((FuncPtr)mmi_camera_start_fast_zoom);
	}
#else /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 
	gui_cancel_timer((FuncPtr)mmi_camera_preview_zoom);
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
	mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__

#else
	mmi_camera_preview_draw_osd();
#endif
	mmi_camera_blt();
#endif /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_up_arrow_press
* DESCRIPTION
*  preview up arrow pressed, adjust zooming
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_up_arrow_press(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ZOOM_UP_PRESS);

	g_camera_cntx.is_long_key = TRUE;
	mmi_camera_preview_zoom((void*)1);
	g_camera_cntx.is_long_key = FALSE;
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_down_arrow_press
* DESCRIPTION
*  preview down arrow pressed, adjust zooming
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_down_arrow_press(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ZOOM_DOWN_PRESS);

	g_camera_cntx.is_long_key = TRUE;
	mmi_camera_preview_zoom((void*)0);
	g_camera_cntx.is_long_key = FALSE;
}


#endif /* defined(__CAMERA_FEATURE_ZOOM__)*/ 


#define CMERA_HOTKEY_MOD
#ifdef CMERA_HOTKEY_MOD
#ifdef __CAMERA_HOTKEY__
static void mmi_camera_update_setting(U16 *pval, U16 count, U16 title_str_id, U16 cont_str_base_id)
{
	(*pval)++;
	if(*pval >= count){
		*pval = 0;
	}

#ifndef __CAMERA_FEATURE_HIDE_HINT__
	{
		WCHAR str_buf[50];

		kal_wsprintf(str_buf, "[ %w ]", GetString(title_str_id));
		mmi_camera_preview_set_hint(
			(CHAR * ) str_buf,
			(CHAR * ) GetString(cont_str_base_id + (*pval) + 1),
			HINT_POPUP_FADE_TIME);
	}
#endif /* __CAMERA_FEATURE_HIDE_HINT__ */ 

}

#if defined(__CAMERA_FEATURE_EFFECT__)

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_effect_change
* DESCRIPTION
*  chage effect
* PARAMETERS
*  is_next     [IN]        Change effect to next, otherwise is previous
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_effect_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U16 effect;
	U16 sharpness = CAMERA_DEFAULT_SETTING_BRIGHTNESS;
	U16 saturation = CAMERA_DEFAULT_SETTING_SATURATION;
	U16 contrast = CAMERA_DEFAULT_SETTING_CONTRAST;
	U16 hue = 0;
	S32 index = -1;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_common_hotkey_func(pitem);

	effect = camera_effect_command_map[g_camera_cntx.setting.effect];

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_1__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_1)
	{
		index = 0;
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_1__ */ 

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_2__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_2)
	{
		index = 1;
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_2__ */ 

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_3__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_3)
	{
		index = 2;
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_3__ */ 

	if(index != -1){
		effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM__
		sharpness = g_camera_cntx.setting.fx_brightness[2];
		saturation = g_camera_cntx.setting.fx_saturation[2];
		contrast = g_camera_cntx.setting.fx_contrast[2];
		hue = g_camera_cntx.setting.fx_hue[2];
#endif
	}

	mdi_camera_update_para_effect(effect);
	mdi_camera_update_para_sharpness(sharpness);
	mdi_camera_update_para_saturation(saturation);
	mdi_camera_update_para_contrast(contrast);
	mdi_camera_update_para_hue(hue);

}
#endif /* __CAMERA_FEATURE_EFFECT__ */ 

#if defined(__CAMERA_FEATURE_LED_HIGHLIGHT__)

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_led_highlight_change
* DESCRIPTION
*  led highlight change
* PARAMETERS
*  is_next     [IN]        Change led highlight to next, otherwise is previous
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_led_highlight_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_common_hotkey_func(pitem);
	/* trun on/off led highlight */
	mmi_camera_turn_on_preview_led_highlight();

}
#endif /* __CAMERA_FEATURE_LED_HIGHLIGHT__ */ 

#ifdef __CAMERA_FEATURE_FLASH__
static void mmi_camera_preview_flash_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	mmi_camera_common_hotkey_func(pitem);

#ifdef __CAMERA_FEATURE_XENON_FLASH__
	if (g_camera_cntx.setting.flash == CAMERA_SETTING_FLASH_OFF){
		g_camera_cntx.xenon_flash_state = MMI_CAMERA_XENON_FLASH_OFF;

		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}
#endif

}
#endif /* __CAMERA_FEATURE_FLASH__ */ 

#if defined(__CAMERA_FEATURE_CONT_SHOT__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_cont_shot_change
* DESCRIPTION
*  cont shot change
* PARAMETERS
*  is_next     [IN]        Change cont shot to next, otherwise is previous
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_cont_shot_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	BOOL need_restart_preview;
	BOOL need_change_capture_size = FALSE;
	S32 prev_preview_width;
	S32 prev_preview_height;

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	BOOL need_restore_image_size;
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.external_request_mode != MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		return;
	}


	need_restart_preview = FALSE;

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	/* inti var */
	need_restore_image_size = FALSE;

	/* leaving burst shot */
	if (g_camera_cntx.setting.cont_shot == CAMERA_SETTING_CONT_SHOT_BURST)
	{
		need_restore_image_size = TRUE;
	}
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	mmi_camera_update_setting(&g_camera_cntx.setting.cont_shot, 
		CAMERA_SETTING_CONT_SHOT_COUNT, STR_ID_CAMERA_CONT_SHOT, 
		STR_ID_CAMERA_CONT_SHOT_START);


#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	/* check change out from burst need to change image and preview size */
	if (need_restore_image_size)
	{
		if (g_camera_cntx.image_size_before_burst != CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX)
		{
			/* restore preview */
			g_camera_cntx.setting.image_size = g_camera_cntx.image_size_before_burst;
			need_change_capture_size = TRUE;
		}
	}

	/* check if change to burst need to change image and preview size */
	if (g_camera_cntx.setting.cont_shot == CAMERA_SETTING_CONT_SHOT_BURST)
	{
		/* store image size before enter burst shot */
		g_camera_cntx.image_size_before_burst = g_camera_cntx.setting.image_size;

		/* if not correct image size, change to it */
		if (g_camera_cntx.setting.image_size != CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX)
		{
			g_camera_cntx.setting.image_size = CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX;
			need_change_capture_size = TRUE;
		}
	}
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	if (need_change_capture_size)
	{
		prev_preview_width = g_camera_cntx.preview_width;
		prev_preview_height = g_camera_cntx.preview_height;

		mmi_camera_preview_update_capture_size();
		mdi_camera_update_para_image_size(g_camera_cntx.image_width, g_camera_cntx.image_height);

		if ((prev_preview_width != g_camera_cntx.preview_width) ||
			(prev_preview_height != g_camera_cntx.preview_height) ||
			(g_camera_cntx.setting.zoom_idx != CAMERA_DEFAULT_SETTING_ZOOM_IDX))
		{
			need_restart_preview = TRUE;
		}

#if defined(__CAMERA_OSD_HORIZONTAL__)
		if (g_camera_cntx.osd_data.previous_osd_rotate == CAMERA_DISPLAY_ROTATE_RESET)
		{
			need_restart_preview = TRUE;
		}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 
	}

	if (need_restart_preview)
	{
		/* since preview para is changed, stop and restart preview */
		mmi_camera_preview_stop();

		/* check if need to update osd orienation */
#if defined(__CAMERA_OSD_HORIZONTAL__)
		if (g_camera_cntx.osd_data.previous_osd_rotate == CAMERA_DISPLAY_ROTATE_RESET)
		{
			mmi_camera_check_osd_orientation();
			mmi_camera_preview_set_key_hdlr();
		}
#endif

		/* restore zoom setting */
		g_camera_cntx.setting.zoom_idx = CAMERA_DEFAULT_SETTING_ZOOM_IDX;

		/* update add frame */
		/* set blt */
		mmi_camera_preview_set_blt_layer(FALSE);

		mmi_camera_preview_draw_osd();
		mmi_camera_blt();

		mmi_camera_preview_create_preview_resource(
			0,
			0,
			g_camera_cntx.preview_width,
			g_camera_cntx.preview_height);

		/* set blt layer for previwing */
		mmi_camera_preview_set_blt_layer(TRUE);

		mmi_camera_preview_start();

		/* check if preview success */
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			mmi_camera_display_error_popup();
			return;
		}
	}
	else
	{
		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}

}
#endif /* __CAMERA_FEATURE_CONT_SHOT__ */ 

#ifdef __CAMERA_DSC_MODE__
/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_dsc_mode_change
* DESCRIPTION
*  shot mode hotkey pressed
* PARAMETERS
*  is_next     [IN]        Change shot mode to next, otherwise is previous
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_dsc_mode_change(U16 value)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* night mode: should also set night_mode for DRV use */
#ifdef __CAMERA_DSC_MODE_NIGHT__
	if(g_camera_cntx.setting.dsc_mode == CAMERA_SETTING_DSC_MODE_NIGHT)
		g_camera_cntx.setting.night = 1;
	else
		g_camera_cntx.setting.night = 0;
#endif 

	/* update quality parameter to mdi_camera */
	mdi_camera_update_para_scene_mode(value);

}
#endif /*__CAMERA_DSC_MODE__*/

#if defined(__CAMERA_FEATURE_STORAGE__)

/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_storage_change
* DESCRIPTION
*  storage change
* PARAMETERS
*  is_next     [IN]        Change storage to next, otherwise is previous
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_storage_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	WCHAR str_buf[100], name_buf[100];
	U16 cur_storage;
	S32 create_result;
	S32 total_num = 0;
	S32 index = 0;
	BOOL is_storage_path_changed;
	SRV_FMGR_DRVLIST_HANDLE drvlist;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	cur_storage = mmi_imgview_get_storage();

	drvlist = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
	total_num = srv_fmgr_drivelist_count(drvlist);
	index = srv_fmgr_drivelist_get_index_by_drv_letter(drvlist, (U8)cur_storage);

	if (total_num > 1) 
		is_storage_path_changed = TRUE;
	else
		is_storage_path_changed = FALSE;

	if (index < total_num - 1)
	{
		index++;
	}
	else
	{
		index= 0;
	}
	cur_storage = srv_fmgr_drivelist_get_drv_letter(drvlist, index);
	mmi_imgview_set_storage(cur_storage);

#ifndef __CAMERA_FEATURE_HIDE_HINT__

	srv_fmgr_drv_get_name((U8)cur_storage, name_buf, 100);

	kal_wsprintf(str_buf, "[ %w ]", GetString(STR_GLOBAL_STORAGE));

	mmi_camera_preview_set_hint(
		(CHAR * ) str_buf,
		(CHAR * ) name_buf,
		HINT_POPUP_FADE_TIME);
#endif /* __CAMERA_FEATURE_HIDE_HINT__ */ 

	mmi_camera_preview_draw_osd();
	mmi_camera_blt();    

	/* storage changed */
	if (is_storage_path_changed)
	{
		if (mmi_camera_check_and_restore_valid_drv())
		{
			/* drv is valid, create directory */
			//mmi_imgview_get_storage_file_path(g_camera_cntx.storage_filepath);
			create_result = mmi_imgview_get_storage_file_path((WCHAR*)g_camera_cntx.storage_filepath);//mmi_imgview_create_file_dir(storage_filepath);

			/* create directory failed */
			if (create_result == FS_WRITE_PROTECTION)
			{
				g_camera_cntx.last_error = CAMERA_ERR_WRITE_PROTECT;

				/* has error - restore to phone */
				mmi_imgview_set_storage((U16)SRV_FMGR_PUBLIC_DRV);
			}
			else if (create_result == FS_DISK_FULL)
			{
				if (cur_storage == (U16) SRV_FMGR_PUBLIC_DRV)
				{
					g_camera_cntx.last_error = CAMERA_ERR_PHONE_DISK_FULL;
				}
				else
				{
					/* storage is card */
					g_camera_cntx.last_error = CAMERA_ERR_CARD_DISK_FULL;

					/* has error - restore to phone */
					mmi_imgview_set_storage((U16)SRV_FMGR_PUBLIC_DRV);
				}
			}
			else if (create_result == FS_ROOT_DIR_FULL)
			{
				if (cur_storage == (U16) SRV_FMGR_PUBLIC_DRV)
				{
					g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;
				}
				else
				{
					/* storage is card */
					g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;

					/* has error - restore to phone */
					mmi_imgview_set_storage((U16)SRV_FMGR_PUBLIC_DRV);
				}
			}
			mmi_camera_get_next_filename(g_camera_cntx.captured_filepath);
		}
		else
		{
			/* drv no valid, means card is plugged out (or phone FAT corrupted) */
			/* if storage before restoration is already in phone, means FAT is corrupted */
			if (cur_storage == (U16) SRV_FMGR_PUBLIC_DRV)
			{
				g_camera_cntx.last_error = CAMERA_ERR_CORRUPT_FAT;
			}
			else
			{
				g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_NO_DISK;
			}
		}

		/* check if preview success */
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			mmi_camera_display_error_popup();
		}

	}

	srv_fmgr_drivelist_destroy(drvlist);

}
#endif /* __CAMERA_FEATURE_STORAGE__ */ 


/*****************************************************************************
* FUNCTION
*  mmi_camera_preview_image_size_change
* DESCRIPTION
*  image size change
* PARAMETERS
*  is_next     [IN]        Change image size to next, otherwise is previous
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_preview_image_size_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 prev_preview_width;
	S32 prev_preview_height;
	BOOL prev_is_fullscreen;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	if(g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_LARGEST_RESOLUTION){
		return;
	}

	mmi_camera_update_setting(pitem->val_addr, 
		pitem->select_count, pitem->str_title_id, 
		pitem->str_base_id);

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	/* disable burst shot if size can not support */
	if ((g_camera_cntx.setting.image_size != CAMERA_FEATURE_CONT_SHOT_BURST_IMAGE_IDX) &&
		(g_camera_cntx.setting.cont_shot == CAMERA_SETTING_CONT_SHOT_BURST))
	{
		g_camera_cntx.setting.cont_shot = CAMERA_SETTING_CONT_SHOT_OFF;
	}
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	/* backup previous */
	prev_preview_width = g_camera_cntx.preview_width;
	prev_preview_height = g_camera_cntx.preview_height;
	prev_is_fullscreen = g_camera_cntx.is_fullscreen;

	/* update parameters */
	mmi_camera_preview_update_capture_size();

#ifdef __LANDSCAPE_UI_ON_PORTRAIT_LCM__
	prev_is_fullscreen = g_camera_cntx.is_fullscreen; /*Landscape on portait no need check this and will cause issue of show black a while*/
#endif
	if ((prev_preview_width != g_camera_cntx.preview_width) ||
		(prev_preview_height != g_camera_cntx.preview_height) ||
		(prev_is_fullscreen != g_camera_cntx.is_fullscreen) ||
		(g_camera_cntx.setting.zoom_idx != CAMERA_DEFAULT_SETTING_ZOOM_IDX))
	{
		/* since preview para is changed, stop and restart preview */
		mmi_camera_preview_stop();

		/* restore zoom setting */
		g_camera_cntx.setting.zoom_idx = CAMERA_DEFAULT_SETTING_ZOOM_IDX;

		/* set blt */
		mmi_camera_preview_set_blt_layer(FALSE);

		/* update add frame */
#if defined(__CAMERA_OSD_HORIZONTAL__)
		mmi_camera_check_osd_orientation();

		/* update functions of up/down/left/right key */
		mmi_camera_preview_set_key_hdlr();
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

		/* clear background color */
#if defined(__CAMERA_OSD_HORIZONTAL__)
		gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
		gdi_layer_clear_background(GDI_COLOR_BLACK);
		gdi_layer_pop_and_restore_active();
#else
		mmi_camera_reset_base_layer();
#endif

		mmi_camera_preview_draw_osd();
		mmi_camera_blt();

		mmi_camera_preview_create_preview_resource(
			0,
			0,
			g_camera_cntx.preview_width,
			g_camera_cntx.preview_height);

		/* set blt layer for previwing */
		mmi_camera_preview_set_blt_layer(TRUE);

		mmi_camera_preview_start();
		//mmi_camera_preview_set_blt_layer(TRUE);

		/* check if preview success */
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			mmi_camera_display_error_popup();
		}

	}
	else
	{
		mdi_camera_update_para_zoom(g_camera_cntx.setting.zoom_idx);
		mdi_camera_update_para_image_size(g_camera_cntx.image_width, g_camera_cntx.image_height);

		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}

}


#ifdef __CAMERA_FEATURE_ISO_SUPPORT__
static void mmi_camera_preview_iso_change(const camera_hotkey_item_struct *pitem)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifdef __CAMERA_DSC_MODE_NIGHT__
	if (g_camera_cntx.setting.dsc_mode == CAMERA_SETTING_DSC_MODE_NIGHT)
		return;
#endif

	mmi_camera_common_hotkey_func(pitem);

}

#endif /* __CAMERA_FEATURE_ISO_SUPPORT__ */ 
#endif


#if defined(__CAMERA_FEATURE_DRAW_ICON__)||defined(__CAMERA_HOTKEY__)
static const camera_hotkey_item_struct g_camera_hotkeys[] = 
{
#ifdef __CAMERA_HOTKEY__
	{   CAMERA_IMAGE_SIZE_KEY, 
	IMG_ID_CAMERA_OSD_IMAGE_SIZE_START,
	STR_ID_CAMERA_IMAGE_SIZE_START, STR_ID_CAMERA_IMAGE_SIZE, CAMERA_SETTING_IMAGE_SIZE_COUNT, 
	&g_camera_cntx.setting.image_size,
	NULL, NULL, mmi_camera_preview_image_size_change 
	},
#else
	{   CAMERA_IMAGE_SIZE_KEY, 
	IMG_ID_CAMERA_OSD_IMAGE_SIZE_START,
	STR_ID_CAMERA_IMAGE_SIZE_START, STR_ID_CAMERA_IMAGE_SIZE, CAMERA_SETTING_IMAGE_SIZE_COUNT, 
	&g_camera_cntx.setting.image_size,
	NULL, NULL, NULL 
	},
#endif

	{ CAMERA_IMAGE_QTY_KEY, 
	IMG_ID_CAMERA_OSD_IMAGE_QTY_START,
	STR_ID_CAMERA_IMAGE_QTY_START, STR_ID_CAMERA_IMAGE_QTY, CAMERA_SETTING_IMAGE_QTY_COUNT, 
	&g_camera_cntx.setting.image_qty, 
	camera_image_qty_command_map, mdi_camera_update_para_image_qty, NULL 
	},
#if 0
#if defined (__CAMERA_FEATURE_NIGHT__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __CAMERA_FEATURE_NIGHT__ */ 
#endif

#if defined (__CAMERA_FEATURE_EFFECT__)
	{ CAMERA_EFFECT_KEY, 
	IMG_ID_CAMERA_OSD_EFFECT_START, 
	STR_ID_CAMERA_EFFECT_START, STR_ID_CAMERA_EFFECT_SETTING, CAMERA_SETTING_EFFECT_COUNT, 
	&g_camera_cntx.setting.effect, 
	NULL, NULL, mmi_camera_preview_effect_change 
	},
#endif /*__CAMERA_FEATURE_EFFECT__*/

#if defined(__CAMERA_FEATURE_WB__)
	{ CAMERA_WB_KEY, 
	IMG_ID_CAMERA_OSD_WB_START, 
	STR_ID_CAMERA_WB_START, STR_ID_CAMERA_WB, CAMERA_SETTING_WB_COUNT, 
	&g_camera_cntx.setting.wb, 
	camera_wb_command_map, mdi_camera_update_para_wb, NULL 
	},
#endif /* __CAMERA_FEATURE_WB__ */ 

#if defined(__CAMERA_FEATURE_LED_HIGHLIGHT__)
	{ CAMERA_LED_HIGHLIGHT_KEY, 
	IMG_ID_CAMERA_OSD_LED_HIGHLIGHT_START,
	STR_ID_CAMERA_LED_HIGHLIGHT_START, STR_ID_CAMERA_LED_HIGHLIGHT, CAMERA_SETTING_LED_HIGHLIGHT_COUNT, 
	&g_camera_cntx.setting.led_highlight, 
	NULL, NULL, mmi_camera_preview_led_highlight_change 
	},

#endif /*__CAMERA_FEATURE_LED_HIGHLIGHT__*/

#if defined(__CAMERA_FEATURE_FLASH__)
	{ CAMERA_FLASH_KEY, 
	IMG_ID_CAMERA_OSD_FLASH_START, 
	STR_ID_CAMERA_FLASH_START, STR_ID_CAMERA_FLASH, CAMERA_SETTING_FLASH_COUNT, 
	&g_camera_cntx.setting.flash, 
	camera_flash_command_map, mdi_camera_update_para_flash, mmi_camera_preview_flash_change 
	},
#endif /*__CAMERA_FEATURE_FLASH__*/

#if defined(__CAMERA_FEATURE_CONT_SHOT__)
	{ CAMERA_CONT_SHOT_KEY, 
	IMG_ID_CAMERA_OSD_CONT_SHOT_START,
	STR_ID_CAMERA_CONT_SHOT_START, STR_ID_CAMERA_CONT_SHOT, CAMERA_SETTING_CONT_SHOT_COUNT, 
	&g_camera_cntx.setting.cont_shot, 
	NULL, NULL, mmi_camera_preview_cont_shot_change 
	},
#endif /*__CAMERA_FEATURE_CONT_SHOT__*/

#if defined(__CAMERA_FEATURE_DELAY_TIMER__)
	{ CAMERA_DELAY_TIMER_KEY, 
	IMG_ID_CAMERA_OSD_DELAY_TIMER_START,
	STR_ID_CAMERA_DELAY_TIMER_START, STR_ID_CAMERA_DELAY_TIMER, CAMERA_SETTING_DELAY_TIMER_COUNT, 
	&g_camera_cntx.setting.delay_timer, 
	NULL, NULL, NULL 
	},
#endif /* __CAMERA_FEATURE_DELAY_TIMER__ */ 

#if defined (__CAMERA_DSC_MODE__)
	{ CAMERA_DSC_MODE_KEY, 
	IMG_ID_CAMERA_OSD_DSC_MODE_START,
	STR_ID_CAMERA_DSC_MODE_START, STR_ID_CAMERA_DSC_MODE, CAMERA_SETTING_DSC_MODE_COUNT, 
	&g_camera_cntx.setting.dsc_mode, 
	camera_dsc_mode_command_map, mmi_camera_preview_dsc_mode_change, NULL 
	},

#endif /* __CAMERA_DSC_MODE__ */ 

#if defined (__CAMERA_FEATURE_ISO_SUPPORT__)
	{ CAMERA_ISO_KEY, 
	IMG_ID_CAMERA_OSD_ISO_START,
	STR_ID_CAMERA_ISO_START, STR_ID_CAMERA_ISO, CAMERA_SETTING_ISO_COUNT, 
	&g_camera_cntx.setting.iso, 
	camera_iso_command_map, mdi_camera_update_para_iso, mmi_camera_preview_iso_change 
	},
#endif /* __CAMERA_FEATURE_ISO_SUPPORT__ */ 

#if defined (__CAMERA_FEATURE_AE_METER__)
	{ CAMERA_AE_METER_KEY, 
	IMG_ID_CAMERA_OSD_AE_METER_START,
	STR_ID_CAMERA_AE_METER_START, STR_ID_CAMERA_AE_METER, CAMERA_SETTING_AE_METER_COUNT, 
	&g_camera_cntx.setting.ae_meter, 
	camera_ae_meter_command_map, mdi_camera_update_para_ae_meter, NULL 
	},
#endif /* __CAMERA_FEATURE_AE_METER__ */ 

#if defined(__CAMERA_AUTOFOCUS_MODE__)
	{ CAMERA_AF_MODE_KEY, 
	IMG_ID_CAMERA_OSD_FOCUS_MODE_START,
	STR_ID_CAMERA_AUTOFOCUS_MODE_START, STR_ID_CAMERA_AUTOFOCUS_MODE, CAMERA_SETTING_AUTOFOCUS_MODE_COUNT, 
	&g_camera_cntx.setting.af_mode, 
	camera_autofocus_mode_command_map, mdi_camera_update_para_af_mode, NULL 
	},
#endif /* defined(__CAMERA_AUTOFOCUS_MODE__) */

#if defined(__CAMERA_AUTOFOCUS_METERING__)
	{ CAMERA_AF_METER_KEY, 
	IMG_ID_CAMERA_OSD_FOCUS_METER_START, 
	STR_ID_CAMERA_AUTOFOCUS_START, STR_ID_CAMERA_AUTOFOCUS_METERING, CAMERA_SETTING_AUTOFOCUS_COUNT, 
	&g_camera_cntx.setting.af_meter, 
	camera_autofocus_command_map, mdi_camera_update_para_af_metering, NULL 
	},

#endif /* defined(__CAMERA_AUTOFOCUS_METERING__) */ 

#if defined(__CAMERA_FEATURE_STORAGE__)
#ifdef __CAMERA_HOTKEY__
	{ CAMERA_STORAGE_KEY, 
	0, 
	0, 0, 0, 
	NULL, 
	NULL, NULL, mmi_camera_preview_storage_change 
	},
#else
	{ CAMERA_STORAGE_KEY, 
	0, 
	0, 0, 0, 
	NULL, 
	NULL, NULL, NULL 
	},
#endif
#endif

#if defined(__MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__)
	{ CAMERA_SWITCH_TO_VDOREC_KEY, 
	0, 
	0, 0, 0, 
	NULL, 
	NULL, mmi_camera_switch_to_vdorec_app, NULL 
	},

#endif /* defined(__MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__) */ 
};
#endif

#if defined(__CAMERA_FEATURE_DRAW_ICON__)
static void mmi_camera_common_hotkey_func(const camera_hotkey_item_struct *pitem)
{
	mmi_camera_update_setting(pitem->val_addr, 
		pitem->select_count, pitem->str_title_id, 
		pitem->str_base_id);

	if(pitem->mdi_update){
		if(pitem->map_table){
			pitem->mdi_update(pitem->map_table[*(pitem->val_addr)]);
		}else{
			pitem->mdi_update(*(pitem->val_addr));
		}
	}

	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
}

static const camera_hotkey_item_struct* mmi_camera_get_setting_item_by_icon(U16 icon_id)
{
	S32 i;

	for(i=0; i<sizeof(g_camera_hotkeys)/sizeof(camera_hotkey_item_struct); i++)
	{
		if(icon_id == g_camera_hotkeys[i].icon_base_id){
			return &g_camera_hotkeys[i];
		}
	}

	return NULL;

}

static void mmi_camera_setting_change(const camera_hotkey_item_struct *pitem)
{
	if(pitem->custom_func){
		pitem->custom_func(pitem);
	}else{
		mmi_camera_common_hotkey_func(pitem);
	}

}

static void mmi_camera_icon_press(U16 icon_id)
{
	const camera_hotkey_item_struct *pitem;

	pitem = mmi_camera_get_setting_item_by_icon(icon_id);
	if(pitem != NULL){
		mmi_camera_setting_change(pitem);
	}
}
#endif
#ifdef __CAMERA_HOTKEY__
static const camera_hotkey_item_struct* mmi_camera_get_setting_item_by_key(U16 key_code)
{
	S32 i;

	for(i=0; i<sizeof(g_camera_hotkeys)/sizeof(camera_hotkey_item_struct); i++)
	{
		if(key_code == g_camera_hotkeys[i].hot_key){
			return &g_camera_hotkeys[i];
		}
	}

	return NULL;

}

static void mmi_camera_hotkey_press(U16 key_code)
{
	const camera_hotkey_item_struct *pitem;
	pitem = mmi_camera_get_setting_item_by_key(key_code);
	if(pitem != NULL){
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
		mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__

#endif
		mmi_camera_setting_change(pitem);
	}
}
#endif
#endif /*CMERA_HOTKEY_MOD*/


#ifdef __COUNTDOWN_USING_MMA__
static void mmi_camera_init_countdown_mma(void)
{
	/* set flag */
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_INIT_COUTDWN_MMA);
	/* open and play a dummy midi at backgroup - this is a must do to play multi-channel sound */
#ifndef __AUDIO_ULTRA_SLIM__
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_INIT_COUTDWN_MMA_NSLIM,__LINE__);
	g_camera_cntx.multi_sound_dummy_bg = mdi_audio_mma_open_string(0, (void*)camera_sound_dummy_bg, CAMERA_SOUND_DUMMY_BG_LEN, MDI_FORMAT_SMF, 0, NULL, NULL);
	mdi_audio_mma_play(g_camera_cntx.multi_sound_dummy_bg);
#endif

	g_camera_cntx.multi_sound_countdown = mdi_audio_mma_open_string(
		0,
		(void*)camera_sound_countdown,
		(U32) CAMREA_SOUND_COUNTDOWN_LEN,
		MDI_FORMAT_WAV,
		1,
		NULL,
		NULL);
}


static void mmi_camera_deinit_countdown_mma(void)
{
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_DEINIT_COUNTDOWN_MMA);

#ifndef __AUDIO_ULTRA_SLIM__
	mdi_audio_mma_stop(g_camera_cntx.multi_sound_dummy_bg);
	mdi_audio_mma_close(g_camera_cntx.multi_sound_dummy_bg);
#endif

	mdi_audio_mma_stop(g_camera_cntx.multi_sound_countdown);
	mdi_audio_mma_close(g_camera_cntx.multi_sound_countdown);

	g_camera_cntx.multi_sound_countdown = 0;
	g_camera_cntx.multi_sound_dummy_bg = 0;
}
#endif

/*****************************************************************************
*
*  Main LCD Cont Shot State
*
*****************************************************************************/

#ifdef __CAMERA_FEATURE_CONT_SHOT__

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_contshot_state
* DESCRIPTION
*  entry contshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_contshot_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTER_STATE,g_camera_cntx.setting.cont_shot);
	/* register soft keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);
	p_act_key_hdlr = NULL;


#ifdef __MMI_CAMERA_AF_TEST__
	if (g_camera_cntx.is_af_test == FALSE)
	{
#endif /* __MMI_CAMERA_AF_TEST__ */ 
		/* init count down para */
		switch (g_camera_cntx.setting.cont_shot)
		{
		case CAMERA_SETTING_CONT_SHOT_1:
			{
				g_camera_cntx.cont_shot_total_count = CAMERA_FEATURE_CONT_SHOT_1_COUNT;
				g_camera_cntx.cont_shot_count = 0;
			}
			break;

#ifdef __CAMERA_FEATURE_CONT_SHOT_2__
		case CAMERA_SETTING_CONT_SHOT_2:
			{
				g_camera_cntx.cont_shot_total_count = CAMERA_FEATURE_CONT_SHOT_2_COUNT;
				g_camera_cntx.cont_shot_count = 0;
			}
			break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_2__ */ 
#ifdef __CAMERA_FEATURE_CONT_SHOT_3__
		case CAMERA_SETTING_CONT_SHOT_3:
			{
				g_camera_cntx.cont_shot_total_count = CAMERA_FEATURE_CONT_SHOT_3_COUNT;
				g_camera_cntx.cont_shot_count = 0;
			}
			break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_3__ */ 
		}
#ifdef __MMI_CAMERA_AF_TEST__
	}
#endif 
	mmi_camera_contshot_cyclic();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_contshot_state
* DESCRIPTION
*  entry contshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_contshot_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_EXIT_CONTSHOT_STATE);
	/* cancel countdown timer */
	gui_cancel_timer(mmi_camera_contshot_cyclic);

	/* free preview resource */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* stop previewing */
		mmi_camera_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* flatten layer */
		mmi_camera_preview_flatten_layer(TRUE);
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_contshot_cyclic
* DESCRIPTION
*  cont shot cyclic loop
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_contshot_cyclic(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

#ifndef __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__
	CHAR buffer[100];
	CHAR UCS2_buffer[100];
#endif /* __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__ */ 
	S32 quickview_width;
	S32 quickview_height; 
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_ENTEY_CONTSHOT_CYCLIC,g_camera_cntx.cont_shot_count);
	/* set capturing flag */
	g_camera_cntx.is_capturing = TRUE;

	if (g_camera_cntx.cont_shot_count + 1 == g_camera_cntx.cont_shot_total_count)
	{
		g_camera_cntx.is_continue_capture = FALSE;
	}
	else
	{
		g_camera_cntx.is_continue_capture = TRUE;
	}

	MMI_CAMERA_START_MEASURE("OSD");
	
			if (g_camera_cntx.cont_shot_total_count != 1)
			{
#ifndef __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__
				sprintf(buffer, "%d / %d", g_camera_cntx.cont_shot_count + 1, g_camera_cntx.cont_shot_total_count);
				mmi_asc_to_ucs2((CHAR * ) UCS2_buffer, (CHAR * ) buffer);
				mmi_ucs2cpy((CHAR * ) buffer, (CHAR * ) GetString(STR_ID_CAMERA_NOFIFY_CAPTURING));
				mmi_camera_preview_set_hint((CHAR * ) buffer, UCS2_buffer, 0);
#else /* __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__ */ 
				mmi_camera_preview_set_hint(NULL, NULL, 0);
#endif /* __CAMERA_FEATURE_CONT_SHOT_DRAW_COUNTBAR__ */ 
	
				mmi_camera_preview_draw_osd();
				mmi_camera_blt();
			}
			else
			{
				/* if only 1 image, draw "Capture.." string */
				mmi_camera_preview_set_hint((CHAR * ) GetString(STR_ID_CAMERA_NOFIFY_CAPTURING), NULL, 0);
				mmi_camera_preview_draw_osd();
				mmi_camera_blt();
			}
	
	MMI_CAMERA_STOP_MEASURE("OSD");

	/* will capture then save to file */
	mmi_camera_commit_filename_seq_no();

	/* start timer for next shot */
#ifdef __MMI_CAMERA_AF_TEST__
	if (g_camera_cntx.is_af_test == FALSE)
	{
		gui_start_timer(800, mmi_camera_contshot_cyclic);
	}
#else /* __MMI_CAMERA_AF_TEST__ */ 
	gui_start_timer(800, mmi_camera_contshot_cyclic);
#endif /* __MMI_CAMERA_AF_TEST__ */ 

	mmi_camera_turn_on_capture_led_highlight();

	MMI_CAMERA_START_MEASURE("SND");	
	mmi_camera_capture_play_sound();    
	MMI_CAMERA_STOP_MEASURE("SND");
	MMI_CAMERA_START_MEASURE("ACJ");


	MMI_CAMERA_START_MEASURE("ACJ");


	quickview_width  = g_camera_cntx.preview_width;
	quickview_height = g_camera_cntx.preview_height;

	mdi_camera_set_quickview_rotation(MDI_CAMERA_UI_ROTATE_0_WITH_LCD_CONFIG);
	g_camera_cntx.last_error = mdi_camera_capture_continuous_shot_with_quickview(
		(U32) g_camera_cntx.preview_buf_p, 
		(quickview_width * quickview_height * GDI_MAINLCD_BIT_PER_PIXEL)>>3, 
		quickview_width,
		quickview_height,
		g_camera_cntx.captured_filepath);

	if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
	{
		g_camera_cntx.last_error = mdi_camera_encode_capture_image(&g_camera_cntx.capture_buf_ptr, &g_camera_cntx.capture_size);
	}
	MMI_CAMERA_STOP_MEASURE("ACJ");

	MMI_CAMERA_START_MEASURE("ASV");
	if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
		// if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED && g_camera_cntx.is_continue_capture)
	{
		g_camera_cntx.last_error = mdi_camera_save_captured_image();
	}
	MMI_CAMERA_STOP_MEASURE("ASV");    

	mmi_camera_turn_off_led_highlight();

	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
#ifdef __CAMERA_AUTOFOCUS__
		mdi_camera_stop_autofocus_process();
		g_camera_cntx.af_state = AF_CANCEL;
#endif /* __CAMERA_AUTOFOCUS__ */ 

		g_camera_cntx.is_continue_capture = FALSE;

		gui_cancel_timer(mmi_camera_contshot_cyclic);
		FS_Delete((U16*) g_camera_cntx.captured_filepath);
		mmi_camera_display_error_popup();
		return;
	}
	g_camera_cntx.cont_shot_count++;

	/* terminate condition */
	if (g_camera_cntx.cont_shot_count >= g_camera_cntx.cont_shot_total_count)
	{
#ifdef __MMI_CAMERA_AF_TEST__
		if (g_camera_cntx.is_af_test == TRUE)
		{
			g_camera_cntx.is_af_test = FALSE;
		}
#endif /* __MMI_CAMERA_AF_TEST__ */ 

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

		/* stop timer */
		gui_cancel_timer(mmi_camera_contshot_cyclic);

		mmi_camera_restore_layer(g_camera_cntx.base_layer_handle);

		MMI_CAMERA_START_MEASURE("RSP");
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_PREVIEW);
#endif
		MMI_CAMERA_STOP_MEASURE("RSP");

		return;
	}
	else
	{
		/* change blt layer for previwing */
		mmi_camera_preview_set_blt_layer(TRUE);
		// g_camera_cntx.cont_shot_count++;


		MMI_CAMERA_START_MEASURE("RSP");
		mmi_camera_turn_on_preview_led_highlight();
		mmi_camera_get_next_filename(g_camera_cntx.captured_filepath);
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
		mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__

#endif
		MMI_CAMERA_STOP_MEASURE("RSP");
#ifndef __MMI_CAMERA_SLIM__     
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			g_camera_cntx.is_continue_capture = FALSE;
			/* stop timer */
			gui_cancel_timer(mmi_camera_contshot_cyclic);
			mmi_camera_display_error_popup();
			return;
		}
#endif
#ifdef __MMI_CAMERA_AF_TEST__
		if (g_camera_cntx.is_af_test == TRUE)
		{
			mmi_camera_af_test_start();
		}
#endif /* __MMI_CAMERA_AF_TEST__ */ 
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_contshot_quickview
* DESCRIPTION
* quickview contshot capture picture
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#ifndef __MMI_CAMERA_SLIM__
static void mmi_camera_contshot_quickview(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 image_width;
	S32 image_height;
	S32 offset_x;
	S32 offset_y;
	S32 resized_offset_x;
	S32 resized_offset_y;
	S32 resized_width;
	S32 resized_height;
	S32 result;
	S32 image_region_width;
	S32 image_region_height;
	S32 image_region_offset_x;
	S32 image_region_offset_y;
	S32 index;
	S32 str_len = mmi_ucs2strlen(g_camera_cntx.captured_filepath);

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* free preview resource */
	mmi_camera_preview_free_preview_resource();
	/* reset osd layer, due to we may use 3osd or 5osd, currently we use 1osd, so need to reset */
	mmi_camera_reset_osd_layer();

	/* before drawing captured jpeg on osd, we need to reset base layer if no direct couplbe support */
	/* in direct couple mode, the image is saved in base layer ,so can not reset base layer*/
	mmi_camera_reset_base_layer();

	/* clear base layer background */
	/* in direct couple mode, the image is saved in base layer ,so can not reset base layer*/
	gdi_layer_push_and_set_active(g_camera_cntx.base_layer_handle);
	gdi_layer_clear_background(GDI_COLOR_BLACK);
	gdi_layer_pop_and_restore_active();
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);

	result = gdi_image_jpeg_get_dimension(
		g_camera_cntx.capture_buf_ptr,
		g_camera_cntx.capture_size,
		&image_width,
		&image_height);

	/* set clip region as content region */
	gdi_layer_reset_clip();

	/* calc image region */
	image_region_width = g_camera_cntx.osd_UI_device_width;
	image_region_height = g_camera_cntx.osd_UI_device_height;
	image_region_offset_x = 0;
	image_region_offset_y = 0;
	if (result >= 0)
	{
		if ((image_region_width >= image_width) && (image_region_height >= image_height))
		{
			/* align preview window at the center of screen */
			offset_x = image_region_offset_x + ((image_region_width - image_width) >> 1);
			offset_y = image_region_offset_y + ((image_region_height - image_height) >> 1);

			gdi_image_jpeg_draw(offset_x, offset_y, g_camera_cntx.capture_buf_ptr, g_camera_cntx.capture_size);
		}
		else
		{
			gdi_image_util_fit_bbox(
				image_region_width,
				image_region_height,
				image_width,
				image_height,
				&resized_offset_x,
				&resized_offset_y,
				&resized_width,
				&resized_height);

			gdi_image_jpeg_draw_resized(
				resized_offset_x + image_region_offset_x,
				resized_offset_y + image_region_offset_y,
				resized_width,
				resized_height,
				g_camera_cntx.capture_buf_ptr,
				g_camera_cntx.capture_size);

		}
	}
	else 
	{
		/*Correct the result of GDI*/
		if (!mmi_camera_check_and_restore_valid_drv())
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_NO_DISK;
		}
		else
		{
			g_camera_cntx.last_error = result;
		}
		return;
	}
	/* blt */
	mmi_camera_blt();   
}

#endif
#endif

/*****************************************************************************
*
*  Burstshot State
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_capture_result_hdlr
* DESCRIPTION
*  no block burst shot capture result handler
* PARAMETERS
*  ret                 [IN]        Burst shot result
*  captured_count      [IN]        
*  count(?)            [IN]        How many image is captured, count start from 1
* RETURNS
*  void
*****************************************************************************/
#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)
static void mmi_camera_burstshot_capture_result_hdlr(MDI_RESULT ret, U16 captured_count)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* if camera is in EXIT state by interrup, just do nothing */
	if (g_camera_cntx.app_state == CAMERA_STATE_EXIT)
	{
		return;
	}

	/* capture count start from 1 */
	mmi_camera_capture_play_multi_channel_sound();

	if (ret >= 0)
	{
		/* no error happened */
		if (captured_count == CAMERA_FEATURE_CONT_SHOT_BURST_COUNT)
		{
#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

			g_camera_cntx.is_capturing = FALSE;
#ifdef __CAMERA_AUTOFOCUS__
			mdi_camera_stop_autofocus_process();
#endif /* __CAMERA_AUTOFOCUS__ */ 
			PowerAndEndKeyHandler();

			/* will enter save confirm, close led highlight */
			mmi_camera_turn_off_led_highlight();
#ifdef __MMI_BIP_SUPPORT__
			if (mmi_bt_bip_server_is_working())
				mmi_bt_bip_server_continue_fs_operation();
#endif
			CAMERA_ENTER_STATE(CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM);
			return;
		}
	}
	else
	{
		g_camera_cntx.is_capturing = FALSE;
		g_camera_cntx.last_error = ret;
		mmi_camera_display_error_popup();
	}
}
#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ /* __CAMERA_FEATURE_CONT_SHOT_BURST__ & __CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__ */


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_close_multi_sound
* DESCRIPTION
*  no block burst shot capture result handler
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)
static void mmi_camera_burstshot_close_multi_sound(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* capture count start from 1 */
	if (g_camera_cntx.is_multi_sound_open)
	{
#ifndef __AUDIO_ULTRA_SLIM__
		mdi_audio_mma_stop(g_camera_cntx.multi_sound_dummy_bg);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_dummy_bg);
#endif

		mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture0);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_capture0);

		mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture1);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_capture1);

		mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture2);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_capture2);

		g_camera_cntx.multi_sound_capture0 = 0;
		g_camera_cntx.multi_sound_capture1 = 0;
		g_camera_cntx.multi_sound_capture2 = 0;
		g_camera_cntx.multi_sound_dummy_bg = 0;

		g_camera_cntx.is_multi_sound_open = FALSE;
	}

}
#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ /* __CAMERA_FEATURE_CONT_SHOT_BURST__ & __CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__ */

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
static const camera_key_struct burstshot_keys[] = 

{
	/* register soft keys */
	{KEY_LSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_lsk_release, NULL},
	{KEY_RSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_preview_rsk_release, NULL},    

};

static const camera_key_hdlr_struct g_burstshot_key_hdlr = 
{burstshot_keys, sizeof(burstshot_keys)/sizeof(camera_key_struct), NULL};

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_burstshot_capture_state
* DESCRIPTION
*  entry burstshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_burstshot_capture_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* register softkeys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	mmi_camera_turn_on_capture_led_highlight();

	/* set capturing flag */
	g_camera_cntx.is_capturing = TRUE;

	mmi_camera_preview_set_hint((CHAR * ) GetString(STR_ID_CAMERA_NOFIFY_BURST_CAPTURING), NULL, 0);

#ifdef __CAMERA_AUTOFOCUS__
	g_camera_cntx.is_autofocus_pressed = FALSE;
#endif 

	mmi_camera_preview_draw_osd();
	mmi_camera_blt();

#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)

	ClearKeyHandler(KEY_END, KEY_EVENT_DOWN);
	p_act_key_hdlr = NULL;

	if (g_camera_cntx.setting.shutter_sound != CAMERA_SETTING_SHUTTER_SOUND_OFF && !MMI_CAMERA_IS_SILENT_MODE())
	{
		/* start multi_channel sound, for capture sound effect */

		if (g_camera_cntx.is_multi_sound_open == FALSE)
		{
			/* multi_sound still not opened, open them */

			/* set flag */
			g_camera_cntx.is_multi_sound_open = TRUE;

			/* open and play a dummy midi at backgroup - this is a must do to play multi-channel sound */
#ifndef __AUDIO_ULTRA_SLIM__
			g_camera_cntx.multi_sound_dummy_bg = mdi_audio_mma_open_string(0, (void*)camera_sound_dummy_bg, CAMERA_SOUND_DUMMY_BG_LEN, MDI_FORMAT_SMF, 0, NULL, NULL);

			mdi_audio_mma_play(g_camera_cntx.multi_sound_dummy_bg);
#endif

			g_camera_cntx.multi_sound_cap_idx = 0;

			switch (g_camera_cntx.setting.shutter_sound)
			{
			case CAMERA_SETTING_SHUTTER_SOUND_1:
				{
					g_camera_cntx.multi_sound_capture0 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_1,
						(U32) CAMERA_SOUND_SHUTTER_1_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);

					g_camera_cntx.multi_sound_capture1 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_1,
						(U32) CAMERA_SOUND_SHUTTER_1_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);

					g_camera_cntx.multi_sound_capture2 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_1,
						(U32) CAMERA_SOUND_SHUTTER_1_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);
				}
				break;

			case CAMERA_SETTING_SHUTTER_SOUND_2:
				{
					g_camera_cntx.multi_sound_capture0 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_2,
						(U32) CAMERA_SOUND_SHUTTER_2_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);

					g_camera_cntx.multi_sound_capture1 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_2,
						(U32) CAMERA_SOUND_SHUTTER_2_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);

					g_camera_cntx.multi_sound_capture2 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_2,
						(U32) CAMERA_SOUND_SHUTTER_2_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);
				}
				break;

			case CAMERA_SETTING_SHUTTER_SOUND_3:
				{
					g_camera_cntx.multi_sound_capture0 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_3,
						(U32) CAMERA_SOUND_SHUTTER_3_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);

					g_camera_cntx.multi_sound_capture1 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_3,
						(U32) CAMERA_SOUND_SHUTTER_3_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);

					g_camera_cntx.multi_sound_capture2 = mdi_audio_mma_open_string(
						0,
						(void*)camera_sound_shutter_3,
						(U32) CAMERA_SOUND_SHUTTER_3_LEN,
						MDI_FORMAT_WAV,
						1,
						NULL,
						NULL);
				}
				break;
			}
		}
		else
		{
			/* multi_sound is alrady opened, stop the timer that will close it */
			gui_cancel_timer(mmi_camera_burstshot_close_multi_sound);
		}

	}

#ifdef __MMI_BIP_SUPPORT__
	if (mmi_bt_bip_server_is_working())
		mmi_bt_bip_server_pause_fs_operation();
#endif

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

	/* MT6228 support non-blocking burst shot */
	/* call mdi to capture and save */
	g_camera_cntx.last_error
		= mdi_camera_non_block_burst_capture_to_memory(
		CAMERA_FEATURE_CONT_SHOT_BURST_COUNT,
		&g_camera_cntx.burst_jpg_data,
		mmi_camera_burstshot_capture_result_hdlr);

	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		mmi_camera_display_error_popup();
		return;
	}

#else /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 
	p_act_key_hdlr = g_burstshot_key_hdlr;

	/* burst shot shall play before capture */
	mmi_camera_capture_play_sound();

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

	/* call mdi to capture and save */
	g_camera_cntx.last_error
		= mdi_camera_burst_capture_to_memory(CAMERA_FEATURE_CONT_SHOT_BURST_COUNT, &g_camera_cntx.burst_jpg_data);

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

	/* clear capturing flag */
	g_camera_cntx.is_capturing = FALSE;

	/* will enter save confirm, close led highlight */
	mmi_camera_turn_off_led_highlight();

	/* captured, previewing is stopped, change blt layer */
	mmi_camera_preview_set_blt_layer(FALSE);

	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		mmi_camera_display_error_popup();
		return;
	}
	else
	{
		CAMERA_ENTER_STATE(CAMERA_STATE_BURSTSHOT_SAVE_CONFIRM);
	}

#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_burstshot_capture_state
* DESCRIPTION
*  entry burstshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_burstshot_capture_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* stop capture and stop dummy bg midi for multi-channel sound */
#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)

	if (g_camera_cntx.is_capturing)
	{
		mdi_camera_stop_non_block_burst_capture();
#ifdef __MMI_BIP_SUPPORT__
		if (mmi_bt_bip_server_is_working())
			mmi_bt_bip_server_continue_fs_operation();
#endif
	}

	/*
	* close multi-channel sound after 500 ms, this is used to 
	* avoid last sound be terminate when play to half 
	*/
	gui_start_timer(500, mmi_camera_burstshot_close_multi_sound);

#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

	/* hide hint on panel if it is not fade out */
	mmi_camera_preview_hide_hint();

	/* free preview resource */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* mdi_camera_burst_shot_stop */
		/* need this function if burstshot is non-blocking */

		/* flatten layer */
		mmi_camera_preview_flatten_layer(TRUE);
	}

}

/*****************************************************************************
*
*  BurstShot Save Confirm State
*
*****************************************************************************/
static const camera_key_struct burstshot_save_confirm_keys[] = 

{
	/* register soft keys */
	{KEY_LSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_burstshot_save_confirm_lsk_release, NULL},
	{KEY_RSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_burstshot_save_confirm_rsk_release, NULL},    
	{KEY_CSK, MMI_CAMERA_KE_FLAG_SW, NULL, mmi_camera_burstshot_save_confirm_lsk_release, NULL},

};

static const camera_key_hdlr_struct g_burstshot_save_confirm_key_hdlr = 
{burstshot_save_confirm_keys, sizeof(burstshot_save_confirm_keys)/sizeof(camera_key_struct), NULL};

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_burstshot_save_confirm_state
* DESCRIPTION
*  enter save confirm state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_burstshot_save_confirm_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 offset_x;
	S32 offset_y;
	S32 resized_offset_x;
	S32 resized_offset_y;
	S32 resized_width;
	S32 resized_height;
	S32 image_region_width;
	S32 image_region_height;
	S32 image_region_offset_x;
	S32 image_region_offset_y;
	S32 i, j;
	S32 image_box_width;
	S32 image_box_height;
	S32 image_box_offset_x;
	S32 image_box_offset_y;
	S32 spacing;
	S32 index;
	PU8 image_buf_ptr;
	U32 image_buf_size;
	S32 image_width = 0;
	S32 image_height = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* init var */
	g_camera_cntx.is_lsk_pressed = FALSE;
	g_camera_cntx.is_rsk_pressed = FALSE;

	spacing = 2;

	/* register soft keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);
	p_act_key_hdlr = g_burstshot_save_confirm_key_hdlr;
	mmi_camera_set_common_csk();

#if defined(__CAMERA_OSD_HORIZONTAL__)
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		gdi_layer_resize(LCD_HEIGHT,LCD_WIDTH);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_90);
	}
#endif
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, g_camera_cntx.osd_layer_handle, 0, 0);

	/* hide icons  */
	mmi_camera_preview_set_hint(NULL, NULL, 0);
	mmi_camera_preview_draw_osd();

	gdi_image_jpeg_get_dimension(
		(PU8) g_camera_cntx.burst_jpg_data.file_address[0],
		g_camera_cntx.burst_jpg_data.file_size[0],
		&image_width,
		&image_height);

	/* set clip region as content region */
	gdi_layer_reset_clip();

	/* calc image region */
	image_region_width = g_camera_cntx.osd_UI_device_width;
	image_region_height = g_camera_cntx.osd_UI_device_height;
	image_region_offset_x = 0;
	image_region_offset_y = 0;

	/* TODO: check image_width & image_height no Zero */

	image_box_width = image_region_width - spacing * (CAMERA_FEATURE_CONT_SHOT_BURST_SAVE_COL * 2);
	image_box_width /= CAMERA_FEATURE_CONT_SHOT_BURST_SAVE_COL;

	image_box_height = image_region_height - spacing * (CAMERA_FEATURE_CONT_SHOT_BURST_SAVE_ROW * 2);
	image_box_height /= CAMERA_FEATURE_CONT_SHOT_BURST_SAVE_ROW;

	index = 0;
	for (i = 0; i < CAMERA_FEATURE_CONT_SHOT_BURST_SAVE_ROW; i++)
	{
		for (j = 0; j < CAMERA_FEATURE_CONT_SHOT_BURST_SAVE_COL; j++)
		{
			image_buf_ptr = (PU8) g_camera_cntx.burst_jpg_data.file_address[index];
			image_buf_size = (U32) g_camera_cntx.burst_jpg_data.file_size[index];

			image_box_offset_x = image_region_offset_x + (j * 2 + 1) * spacing + j * image_box_width;
			image_box_offset_y = image_region_offset_y + (i * 2 + 1) * spacing + i * image_box_height;

			if ((image_box_width >= image_width) && (image_box_height >= image_height))
			{
				/* align preview window at the center of box */
				offset_x = image_box_offset_x + ((image_box_width - image_width) >> 1);
				offset_y = image_box_offset_y + ((image_box_height - image_height) >> 1);

				gdi_image_jpeg_draw(offset_x, offset_y, image_buf_ptr, image_buf_size);

				gdi_draw_rect(
					image_box_offset_x + offset_x - 1,
					image_box_offset_y + offset_y - 1,
					image_box_offset_x + offset_x + image_width,
					image_box_offset_y + offset_y + image_height,
					GDI_COLOR_WHITE);
			}
			else
			{
				gdi_image_util_fit_bbox(
					image_box_width,
					image_box_height,
					image_width,
					image_height,
					&resized_offset_x,
					&resized_offset_y,
					&resized_width,
					&resized_height);
				gdi_image_jpeg_draw_resized(
					resized_offset_x + image_box_offset_x,
					resized_offset_y + image_box_offset_y,
					resized_width,
					resized_height,
					image_buf_ptr,
					image_buf_size);

				gdi_draw_rect(
					image_box_offset_x + resized_offset_x - 1,
					image_box_offset_y + resized_offset_y - 1,
					image_box_offset_x + resized_offset_x + resized_width,
					image_box_offset_y + resized_offset_y + resized_height,
					GDI_COLOR_WHITE);

			}

#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) */

			/* blt */
			mmi_camera_blt();

			/* next image */
			index++;
		}
	}

	/* draw save notify text */
	mmi_camera_preview_set_hint((CHAR * ) GetString(STR_ID_CAMERA_NOTIFY_SAVE_CONFIRM), NULL, 0);
	mmi_camera_preview_draw_osd();

	/* blt */
	mmi_camera_blt();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_burstshot_save_confirm_state
* DESCRIPTION
*  exit save confirm state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_burstshot_save_confirm_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	/* free preview resource */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();
	}
	else
	{
		/* clear panel */
		mmi_camera_preview_set_hint(NULL, NULL, 0);
		mmi_camera_preview_draw_osd();

		mmi_camera_blt();
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_save_confirm_lsk_press
* DESCRIPTION
*  draw save confirm softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_burstshot_save_confirm_lsk_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.is_lsk_pressed = TRUE;
	mmi_camera_preview_draw_osd();

	mmi_camera_blt();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_save_confirm_lsk_release
* DESCRIPTION
*  lsk release
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_burstshot_save_confirm_lsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();

	/* enter burstshot saving to save file */
	CAMERA_ENTER_STATE(CAMERA_STATE_BURSTSHOT_SAVING);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_save_confirm_rsk_press
* DESCRIPTION
*  draw save confirm softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_burstshot_save_confirm_rsk_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	g_camera_cntx.is_rsk_pressed = TRUE;
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_save_confirm_rsk_release
* DESCRIPTION
*  draw save confirm softkey
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_burstshot_save_confirm_rsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();

	CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
}

/*****************************************************************************
*
*  Save Burstshot State
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_burstshot_saving_state
* DESCRIPTION
*  entry save burstshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_burstshot_saving_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* register softkeys */
	ClearInputEventHandler(MMI_DEVICE_KEY);
	p_act_key_hdlr = NULL;

	/* draw base layer only */
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, 0, 0, 0);

#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_reset_screen_rotation();
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		gdi_layer_resize(LCD_HEIGHT,LCD_WIDTH);
		gdi_layer_set_rotate(GDI_LAYER_ROTATE_0);
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	/* currently we use gdi layer buffer for OSD, but when show category, it also use gdi buffer, 
	so we should release the memory */
	if (g_camera_cntx.gdi_layer_handle != GDI_NULL_HANDLE)
	{       
		gdi_layer_free(g_camera_cntx.gdi_layer_handle);
		g_camera_cntx.gdi_layer_handle = GDI_NULL_HANDLE;
		g_camera_cntx.gdi_layer_buffer_ptr = NULL;
	}

	force_no_small_screen();
	ExitCategoryFunction();
	gdi_layer_lock_frame_buffer();
	ShowCategory65Screen((PU8) GetString(STR_GLOBAL_SAVING), mmi_get_event_based_image(MMI_EVENT_PROGRESS), NULL);
	gdi_layer_unlock_frame_buffer();
	g_camera_cntx.is_cat65_show = TRUE;


	/* start save burst shot */
	g_camera_cntx.burst_save_index = 0;
	mmi_camera_burstshot_saving_cyclic();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_burstshot_saving_state
* DESCRIPTION
*  exit save burstshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_burstshot_saving_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* exit popup screen to free drawmanager's resource */
	if (g_camera_cntx.is_cat65_show)
	{
		g_camera_cntx.is_cat65_show = FALSE;
		ExitCategoryFunction();
	}

	gui_cancel_timer(mmi_camera_burstshot_saving_cyclic);
	gdi_image_stop_animation_all();

	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* flatten layer */
		mmi_camera_preview_flatten_layer(FALSE);
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_burstshot_saving_cyclic
* DESCRIPTION
*  loop to save burstshot image
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_burstshot_saving_cyclic(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];
	PU8 image_buf_ptr;
	U32 image_buf_size;
	U32 written;
	FS_HANDLE file_handle;

#ifdef EXIF_SUPPORT
	U32 size_of_exif_info = 0;
#endif 

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* this function has nvram access */
	mmi_camera_get_next_filename(buf_filename);

	mmi_camera_commit_filename_seq_no();

	/* start timer for next shot */
	gui_start_timer(100, mmi_camera_burstshot_saving_cyclic);

	/* save burst shot image */

	image_buf_ptr = (PU8) g_camera_cntx.burst_jpg_data.file_address[g_camera_cntx.burst_save_index];
	image_buf_size = (U32) g_camera_cntx.burst_jpg_data.file_size[g_camera_cntx.burst_save_index];

	file_handle = FS_Open((U16*) buf_filename, FS_CREATE | FS_READ_WRITE);

	if (file_handle > 0)
	{
#ifdef EXIF_SUPPORT
		/* eixf_burst_mode_fill_header(kal_uint8* Buffer,kal_uint32 BufferOffset); */
#if defined(__MTK_TARGET__)
		size_of_exif_info = eixf_burst_mode_fill_header(image_buf_ptr);
#endif 
		image_buf_size += size_of_exif_info;
		image_buf_ptr -= size_of_exif_info;
#endif /* EXIF_SUPPORT */ 
		FS_Write(file_handle, (void*)image_buf_ptr, image_buf_size, (U32*) & written);
		FS_Close(file_handle);

		/* cant write in whole file, must be disk full */
		if (image_buf_size != written)
		{
			/* delete the file that is not save complete */
			FS_Delete((U16*) buf_filename);
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_DISK_FULL;
			/* will display a popup, go out application and re-enter */
			mmi_camera_display_error_popup();
			return;
		}
	}
	else
	{
		if (file_handle == FS_DISK_FULL)
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_DISK_FULL;
		}
		else if (file_handle == FS_ROOT_DIR_FULL)
		{
			g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;
		}
		else if (file_handle == FS_WRITE_PROTECTION)
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_WRITE_PROTECTION;
		}
		else
		{
			g_camera_cntx.last_error = CAMERA_ERR_SAVE_FAIL;
		}
		/* will display a popup, go out application and re-enter */
		mmi_camera_display_error_popup();
		return;
	}

	/* teminate condition */
	if (g_camera_cntx.burst_save_index >= CAMERA_FEATURE_CONT_SHOT_BURST_COUNT - 1)
	{
		CAMERA_ENTER_STATE(CAMERA_STATE_DELETE_DONE);
		return;
	}

	/* increase index */
	g_camera_cntx.burst_save_index++;

}
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

/***************************************************************************
*
*  Mainlcd Capture 
*
***************************************************************************/

#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)

/*****************************************************************************
* FUNCTION
*  mmi_camera_capture_play_multi_channel_sound
* DESCRIPTION
*  play capture shutter sound effect when support multi-channel
*  this is for no-blocking burst shot for MT6228
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_capture_play_multi_channel_sound(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* play capture sound */

	if (g_camera_cntx.is_multi_sound_open==FALSE)
		return;

	switch (g_camera_cntx.setting.shutter_sound)
	{
	case CAMERA_SETTING_SHUTTER_SOUND_1:
	case CAMERA_SETTING_SHUTTER_SOUND_2:
	case CAMERA_SETTING_SHUTTER_SOUND_3:
		{
			if (g_camera_cntx.multi_sound_cap_idx == 0)
			{
				mdi_audio_set_headset_mode_output_path(MDI_DEVICE_SPEAKER_BOTH);
				mdi_audio_set_volume(VOL_TYPE_MEDIA,CAMERA_SHUTTER_SOUND_VOLUMN);
				mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture0);
				mdi_audio_mma_play(g_camera_cntx.multi_sound_capture0);
			}
			else if (g_camera_cntx.multi_sound_cap_idx == 1)
			{
				mdi_audio_set_headset_mode_output_path(MDI_DEVICE_SPEAKER_BOTH);
				mdi_audio_set_volume(VOL_TYPE_MEDIA,CAMERA_SHUTTER_SOUND_VOLUMN);
				mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture1);
				mdi_audio_mma_play(g_camera_cntx.multi_sound_capture1);
			}
			else
			{
				mdi_audio_set_headset_mode_output_path(MDI_DEVICE_SPEAKER_BOTH);
				mdi_audio_set_volume(VOL_TYPE_MEDIA,CAMERA_SHUTTER_SOUND_VOLUMN);
				mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture2);
				mdi_audio_mma_play(g_camera_cntx.multi_sound_capture2);
			}

			g_camera_cntx.multi_sound_cap_idx++;

			if (g_camera_cntx.multi_sound_cap_idx >= 3)
			{
				g_camera_cntx.multi_sound_cap_idx = 0;
			}

		}
		break;

	case CAMERA_SETTING_SHUTTER_SOUND_OFF:
	default:
		/* do not play sound */
		break;
	}

}
#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

/*****************************************************************************
*
*  Toggle To Sub State 
*
*****************************************************************************/



/*****************************************************************************
*
*  Sublcd Screen
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_sublcd_screen
* DESCRIPTION
*  entry sublcd screen, if still remain on standard MMI sublcd screen, time update will
*  redraw sublcd while mainlcd is previewing, will cause driver assert.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#ifdef __MMI_SUBLCD__
void mmi_camera_entry_sublcd_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* print debug info */
	CAMERA_TRACE_FUNC_ENTER_SUBLCD();

	ExecSubLCDCurrExitHandler();
	ShowCategory331Screen();
	SetSubLCDExitHandler(mmi_camera_exit_sublcd_screen);

	g_camera_cntx.is_sublcd_display = TRUE;
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_sublcd_screen
* DESCRIPTION
*  exit sublcd screen
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_exit_sublcd_screen(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	SubLCDHistoryNode sub_history;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* print debug info */
	CAMERA_TRACE_FUNC_EXIT_SUBLCD();

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
	/* someone may exit/draw sublcd first then exit mainlcd, this may cause driver assert */
	/* also stop preview here */
	mmi_camera_sublcd_preview_stop();
#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

	g_camera_cntx.is_sublcd_display = FALSE;

	sub_history.entryFuncPtr = mmi_camera_entry_sublcd_screen;
	AddSubLCDHistory(&sub_history);

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_draw_icon
* DESCRIPTION
*  draw a sublcd icon.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_sublcd_draw_icon(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 image_width;
	S32 image_height;
	S32 lcd_width;
	S32 lcd_height;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_lcd_get_dimension(&lcd_width, &lcd_height);

	gdi_layer_reset_clip();

	gdi_layer_clear_background(GDI_COLOR_WHITE);
	gdi_image_get_dimension_id(IMG_ID_CAMERA_PREVIEW_SUBLCD_ICON, &image_width, &image_height);
	gdi_image_draw_id(
		(lcd_width - image_width) >> 1,
		(lcd_height - image_height) >> 1,
		IMG_ID_CAMERA_PREVIEW_SUBLCD_ICON);
	gdi_layer_blt_base_layer(0, 0, lcd_width - 1, lcd_height - 1);

	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
}
#endif /* __MMI_SUBLCD__ */ 

/*****************************************************************************
*
*  Sublcd Preview State 
*
*****************************************************************************/
#ifdef __CAMERA_FEATURE_SELF_CAPTURE__

/*****************************************************************************
* FUNCTION
*  mmi_camera_display_sublcd_error_popup
* DESCRIPTION
*  display a popup error message
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_display_sublcd_error_popup(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mmi_eq_gpio_detect_ind_struct clam_event;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* if has error */
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		ClearInputEventHandler(MMI_DEVICE_KEY);
		switch (g_camera_cntx.last_error)
		{
			/* these are recoverable errors */
			/* show on sublcd screen and keep previewing */
		case MDI_RES_CAMERA_ERR_DISK_FULL:
		case MDI_RES_CAMERA_ERR_NO_DISK:
		case MDI_RES_CAMERA_ERR_WRITE_PROTECTION:
		case MDI_RES_CAMERA_ERR_CAPTURE_FAILED:
		case CAMERA_ERR_SAVE_FAIL:
			/* play warning tone and re-entry preview state */
			srv_prof_play_tone(ERROR_TONE, NULL);
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
			break;

		default:
			/* serious error, will exit camera app */
			mmi_frm_scrn_close_active_id();

			/* 
			* since clam close if aready intercept by camera app,
			* we shall notify framework (gpio.c) to process clam close action 
			*/
			if (g_camera_cntx.is_clam_close)
			{
				clam_event.gpio_device = EXT_DEV_CLAM_CLOSE;
				srv_gpio_detect_ind_hdlr(&clam_event);
			}

			break;
		}
	}

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_toggle_self_capture
* DESCRIPTION
*  toggle self capture (Main/Sub)
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_toggle_self_capture(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	//for current not support
	return ;
	if (g_camera_cntx.app_state == CAMERA_STATE_PREVIEW)
	{
		CAMERA_ENTER_STATE(CAMERA_STATE_TOGGLE_TO_SUB);
	}
	else if (g_camera_cntx.app_state == CAMERA_STATE_SUB_PREVIEW)
	{
		/* only when clam is open may toggle to main */
		if (!g_camera_cntx.is_clam_close)
		{
			CAMERA_ENTER_STATE(CAMERA_STATE_TOGGLE_TO_MAIN);
		}
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_toggle_to_sub_state
* DESCRIPTION
*  enter toggle to sub state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_toggle_to_sub_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* clear all keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, 0, 0, 0);
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_reset_screen_rotation();
	if (g_camera_cntx.osd_rotate == CAMERA_DISPLAY_ROTATE_270 &&
		mmi_frm_get_screen_rotate() != CAMERA_DISPLAY_ROTATE_270)
	{
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	force_no_small_screen();

#ifdef __CAMERA_FEATURE_ADD_FRAME__
	mmi_camera_free_add_frame_layer();
#endif
	ExitCategoryFunction();
	gdi_layer_lock_frame_buffer();
	ShowCategory65Screen((PU8) GetString(STR_ID_CAMERA_NOTIFY_SELF_CAPTURE_ON), mmi_get_event_based_image(MMI_EVENT_SUCCESS), NULL);
	gdi_layer_unlock_frame_buffer();
	g_camera_cntx.is_cat65_show = TRUE;


	gui_start_timer(TOGGLE_POPUP_FADE_TIME, mmi_camera_toggle_to_sub_timeout);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_toggle_to_sub_state
* DESCRIPTION
*  exit save confirm state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_toggle_to_sub_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* will display a popup, go out application and re-enter */
	if (g_camera_cntx.is_cat65_show)
	{
		g_camera_cntx.is_cat65_show = FALSE;
		ExitCategoryFunction();
	}

	gui_cancel_timer(mmi_camera_toggle_to_sub_timeout);

	/* stop anmation on popup category */
	gdi_image_stop_animation_all();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_toggle_to_sub_timeout
* DESCRIPTION
*  exit save confirm state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_toggle_to_sub_timeout(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* enter sub preview state */
	CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
}

/*****************************************************************************
*
*  Toggle To Main State 
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_toggle_to_main_state
* DESCRIPTION
*  enter toggle to main state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_toggle_to_main_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* clear all keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	/* show popup category */
	gdi_layer_set_blt_layer(g_camera_cntx.base_layer_handle, 0, 0, 0);
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
	mmi_frm_reset_screen_rotation();    
	if (g_camera_cntx.osd_rotate == CAMERA_DISPLAY_ROTATE_270 &&
		mmi_frm_get_screen_rotate() != CAMERA_DISPLAY_ROTATE_270)
	{
		mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
	}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

	force_no_small_screen();

#ifdef __CAMERA_FEATURE_ADD_FRAME__
	mmi_camera_free_add_frame_layer();
#endif


	ExitCategoryFunction();
	gdi_layer_lock_frame_buffer();
	ShowCategory65Screen((PU8) GetString(STR_ID_CAMERA_NOTIFY_SELF_CAPTURE_OFF), mmi_get_event_based_image(MMI_EVENT_SUCCESS), NULL);
	gdi_layer_unlock_frame_buffer();
	g_camera_cntx.is_cat65_show = TRUE;


	gui_start_timer(TOGGLE_POPUP_FADE_TIME, mmi_camera_toggle_to_main_timeout);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_toggle_to_main_state
* DESCRIPTION
*  exit toggle to main state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_toggle_to_main_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* will display a popup, go out application and re-enter */
	if (g_camera_cntx.is_cat65_show)
	{
		g_camera_cntx.is_cat65_show = FALSE;
		ExitCategoryFunction();
	}

	gui_cancel_timer(mmi_camera_toggle_to_main_timeout);

	/* stop anmation on popup category */
	gdi_image_stop_animation_all();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_toggle_to_main_timeout
* DESCRIPTION
*  toggle to main popup timeout
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_toggle_to_main_timeout(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* enter sub preview state */
	CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_sublcd_preview_state
* DESCRIPTION
*  entry sublcd preview state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_sublcd_preview_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* draw a popup on mainlcd  */
	/* only first time enter sub preview needs to draw main lcd */
	if ((g_camera_cntx.app_prev_state == CAMERA_STATE_EXIT) ||
		(g_camera_cntx.app_prev_state == CAMERA_STATE_TOGGLE_TO_SUB))
	{
		gdi_layer_lock_frame_buffer();

		/* clear fullscreen */
#ifdef CAMERA_MODULE_WITH_LCD
		gdi_layer_clear(CAMEAR_BG_TRASN_COLOR);
#else 
		gdi_layer_clear(GDI_COLOR_BLACK);
#endif 

#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
		mmi_frm_reset_screen_rotation();
		if (g_camera_cntx.osd_rotate == CAMERA_DISPLAY_ROTATE_270 &&
			mmi_frm_get_screen_rotate() != CAMERA_DISPLAY_ROTATE_270)
		{
			mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
		}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */ 

		force_no_small_screen();

#ifdef __CAMERA_FEATURE_ADD_FRAME__
		mmi_camera_free_add_frame_layer();
#endif

		ExitCategoryFunction();
		gdi_layer_lock_frame_buffer();
		ShowCategory65Screen((PU8) GetString(STR_ID_CAMERA_NOFITY_SELF_CAPTURE_SUBLCD_PREVIEW), mmi_get_event_based_image(MMI_EVENT_SUCCESS), NULL);
		gdi_layer_unlock_frame_buffer();
		g_camera_cntx.is_cat65_show = TRUE;

		/* IMG_GLOBAL_INFO may be an animation, we have to stop it avoid both lcd updating */
		gdi_image_stop_animation_all();
		gdi_layer_unlock_frame_buffer();

		mmi_camera_sublcd_preview_set_key_hdlr();
		mmi_camera_blt();
	}

	/* turn on led highlight */
	mmi_camera_turn_on_preview_led_highlight();

	/* set key handler */
	mmi_camera_sublcd_preview_set_key_hdlr();

	/* set correct lcm rotate */
	/* config rotate of preview layer, only ISP_SUPPORT need */
#if defined(ISP_SUPPORT)
	gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
	if (g_camera_cntx.is_clam_close == TRUE)
	{
		gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_CLOSE_ROTATE);
	}
	else
	{
		gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_OPEN_ROTATE);
	}
	gdi_layer_pop_and_restore_active();
#endif /* defined(ISP_SUPPORT) */ 
	/* preview start */
	mmi_camera_sublcd_preview_start();

	/* check if preview function has error */
	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		mmi_camera_display_sublcd_error_popup();
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_sublcd_preview_state
* DESCRIPTION
*  exit sublcd preview state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_sublcd_preview_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* exit app || toggle to main */

	/* config rotate of preview layer, only ISP_SUPPORT need */
#if defined(ISP_SUPPORT)
	gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);
	gdi_layer_set_rotate(CAMERA_LCM_ROTATE_0);
	gdi_layer_pop_and_restore_active();
#endif /* defined(ISP_SUPPORT) */ 
	if ((g_camera_cntx.app_next_state == CAMERA_STATE_EXIT) ||
		(g_camera_cntx.app_next_state == CAMERA_STATE_TOGGLE_TO_MAIN))
	{
		/* stop previewing */
		mmi_camera_sublcd_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* exit popup screen to free drawmanager's resource */
		/* this shall call after preview is stopped, or will cause multiple lcd access */
		if (g_camera_cntx.is_cat65_show)
		{
			ExitCategoryFunction();
		}
	}

	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* 
		* when interrupt happened while clam is close (preview on sub)
		* we will go handling interrupt, when back from interrupt, 
		* we shall force enter sub again to keep clam open close state correct 
		*/

		if (g_camera_cntx.is_clam_close)
		{
			g_camera_cntx.is_force_self_capture = TRUE;
		}
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_set_key_hdlr
* DESCRIPTION
*  set sublcd key handler
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_set_key_hdlr()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	SetKeyUpHandler(mmi_camera_sublcd_preview_lsk_release, KEY_LSK);
	SetKeyDownHandler(mmi_camera_sublcd_preview_lsk_press, KEY_LSK);

  SetKeyUpHandler(mmi_camera_sublcd_preview_rsk_release, KEY_RSK);
	SetKeyDownHandler(mmi_camera_sublcd_preview_rsk_press, KEY_RSK);

  SetKeyDownHandler(mmi_camera_sublcd_capture_button_press, CAMERA_CAPTURE_KEY);

	if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{
    SetKeyDownHandler(mmi_camera_sublcd_capture_button_press, (U16)CAMERA_CAPTURE_EXTRA_KEY1);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{
		SetKeyDownHandler(mmi_camera_sublcd_capture_button_press, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyRepeatHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyLongpressHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
	}



	SetKeyDownHandler(mmi_camera_toggle_self_capture, CAMERA_TOGGLE_SELF_CAPTURE_KEY);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_start
* DESCRIPTION
*  start previewing on sublcd
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_start(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	mdi_camera_setting_struct camera_setting_data;
	mdi_camera_preview_struct camera_preview_data;
	S32 sublcd_width;
	S32 sublcd_height;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* get sublcd base layer handle */
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_get_dimension(&sublcd_width, &sublcd_height);

#ifdef CAMERA_MODULE_WITH_LCD
	gdi_layer_clear(CAMEAR_BG_TRASN_COLOR);
#endif 

	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	/* preview parametes */
	camera_setting_data.zoom = g_camera_cntx.setting.zoom_idx;
	camera_setting_data.wb = camera_wb_command_map[g_camera_cntx.setting.wb];
	camera_setting_data.ev = camera_ev_command_map[g_camera_cntx.setting.ev];
	camera_setting_data.banding = camera_banding_command_map[g_camera_cntx.setting.banding];
	camera_setting_data.flash = camera_flash_command_map[g_camera_cntx.setting.flash];
	camera_setting_data.ae_meter = camera_ae_meter_command_map[g_camera_cntx.setting.ae_meter];
	camera_setting_data.iso = camera_iso_command_map[g_camera_cntx.setting.iso];
	//  camera_setting_data.night = g_camera_cntx.setting.night;
	//  camera_setting_data.dsc_mode = camera_dsc_mode_command_map[g_camera_cntx.setting.dsc_mode];

	/* effect */
	camera_setting_data.effect = camera_effect_command_map[g_camera_cntx.setting.effect];
	camera_setting_data.sharpness = MDI_CAMERA_SHARPNESS_MEDIUM;
	camera_setting_data.saturation = MDI_CAMERA_SATURATION_MEDIUM;
	camera_setting_data.contrast = MDI_CAMERA_CONTRAST_MEDIUM;
	camera_setting_data.hue = 0;
	camera_setting_data.xenon_flash_status_callback = NULL;

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_1__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_1)
	{
		camera_setting_data.effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
		camera_setting_data.sharpness = g_camera_cntx.setting.fx_brightness[0];
		camera_setting_data.saturation = g_camera_cntx.setting.fx_saturation[0];
		camera_setting_data.contrast = g_camera_cntx.setting.fx_contrast[0];
		camera_setting_data.hue = g_camera_cntx.setting.fx_hue[0];
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_1__ */ 

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_2__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_2)
	{
		camera_setting_data.effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
		camera_setting_data.sharpness = g_camera_cntx.setting.fx_brightness[1];
		camera_setting_data.saturation = g_camera_cntx.setting.fx_saturation[1];
		camera_setting_data.contrast = g_camera_cntx.setting.fx_contrast[1];
		camera_setting_data.hue = g_camera_cntx.setting.fx_hue[1];
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_2__ */ 

#ifdef __CAMERA_FEATURE_EFFECT_CUSTOM_FX_3__
	if (g_camera_cntx.setting.effect == CAMERA_SETTING_EFFECT_CUSTOM_FX_3)
	{
		camera_setting_data.effect = camera_effect_command_map[CAMERA_SETTING_EFFECT_NORMAL];
		camera_setting_data.sharpness = g_camera_cntx.setting.fx_brightness[2];
		camera_setting_data.saturation = g_camera_cntx.setting.fx_saturation[2];
		camera_setting_data.contrast = g_camera_cntx.setting.fx_contrast[2];
		camera_setting_data.hue = g_camera_cntx.setting.fx_hue[2];
	}
#endif /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_3__ */ /* __CAMERA_FEATURE_EFFECT_CUSTOM_FX_32__ */

	/* preview size is sublcd size */
	camera_setting_data.preview_width = CAMERA_FEATURE_SUBLCD_PREVIEW_SIZE_WIDTH;
	camera_setting_data.preview_height = CAMERA_FEATURE_SUBLCD_PREVIEW_SIZE_HEIGHT;

	/* capture parameters */
	camera_setting_data.image_qty = camera_image_qty_command_map[g_camera_cntx.setting.image_qty];
	camera_setting_data.image_width = g_camera_cntx.image_width;
	camera_setting_data.image_height = g_camera_cntx.image_height;

	/* preview on sublcd */
	camera_setting_data.lcm = MDI_CAMERA_PREVIEW_LCM_SUBLCD;

	if (g_camera_cntx.is_clam_close == TRUE)
	{
		//      camera_setting_data.preview_rotate = CAMERA_PREVIEW_SUBLCD_CLAM_CLOSE_ROTATE;
		//      camera_setting_data.lcm_rotate = CAMERA_LCM_SUBLCD_CLAM_CLOSE_ROTATE;
	}
	else
	{
		//      camera_setting_data.preview_rotate = CAMERA_PREVIEW_SUBLCD_CLAM_OPEN_ROTATE;
		//      camera_setting_data.lcm_rotate = CAMERA_LCM_SUBLCD_CLAM_OPEN_ROTATE;
	}

	//    camera_setting_data.continue_capture = g_camera_cntx.is_continue_capture;

	//  camera_setting_data.osd_rotate = CAMERA_DISPLAY_ROTATE_0;
	/* set sublcd's layer info to lcd driver by calling gdi_layer_set_blt_layer() */
	/* set layer for preview */
	mmi_camera_sublcd_preview_set_blt_layer(TRUE);  /* TRUE == Preview */

	/* turn on led highlight */
	mmi_camera_turn_on_preview_led_highlight();

	camera_preview_data.preview_layer_handle = g_camera_cntx.sublcd_base_layer_handle;
	camera_preview_data.blt_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
	camera_preview_data.preview_layer_flag = GDI_LAYER_ENABLE_LAYER_0;
	camera_preview_data.is_lcd_update = TRUE;
	camera_preview_data.src_key_color = CAMEAR_BG_TRASN_COLOR;/* this value is use only CAMERA_MODULE_WITH_LCD */
	camera_preview_data.is_tvout = FALSE;

	/* start preview */
	g_camera_cntx.last_error = mdi_camera_preview_start(
		&camera_preview_data,
		&camera_setting_data,
		NULL);

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_stop
* DESCRIPTION
*  stop previewing on sublcd
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_stop(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mdi_camera_preview_stop();

	/* restore black background */
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
#endif /* CAMERA_MODULE_WITH_LCD */ 
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_set_blt_layer
* DESCRIPTION
*  set blt layer based on current status
* PARAMETERS
*  is_previewing       [IN]        Is preview flag
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_set_blt_layer(BOOL is_previewing)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* currently no function, reserve it when sublcd will use multi-layer */
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_set_blt_layer(g_camera_cntx.sublcd_base_layer_handle, 0, 0, 0);
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_lsk_press
* DESCRIPTION
*  stop sublcd preview then mimic softkey press.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_lsk_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* this function will stop sublcd preview when soft key is down */
	/* if not stop sublcd preview first, mainlcd will draw softkey down and cause driver assert */

	if ((g_camera_cntx.app_state == CAMERA_STATE_SUB_PREVIEW) ||
		(g_camera_cntx.app_state == CAMERA_STATE_SUB_CONTSHOT) ||
		(g_camera_cntx.app_state == CAMERA_STATE_SUB_COUNTDOWN))
	{
		mmi_camera_sublcd_preview_stop();
#ifdef __CAMERA_FEATURE_CONT_SHOT__
		gui_cancel_timer(mmi_camera_sublcd_contshot_cyclic);
#endif
		gui_cancel_timer(mmi_camera_sublcd_countdown_cyclic);
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_rsk_press
* DESCRIPTION
*  stop sublcd preview then mimic softkey press.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_rsk_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* this function will stop sublcd preview when soft key is down */
	/* if not stop sublcd preview first, mainlcd will draw softkey down and cause driver assert */
	/* if is preview on sub and RSK pressm, has to stop preview first then darw on Main */

	if ((g_camera_cntx.app_state == CAMERA_STATE_SUB_PREVIEW) ||
		(g_camera_cntx.app_state == CAMERA_STATE_SUB_CONTSHOT) ||
		(g_camera_cntx.app_state == CAMERA_STATE_SUB_COUNTDOWN))
	{
		mmi_camera_sublcd_preview_stop();
#ifdef __CAMERA_FEATURE_CONT_SHOT__
		gui_cancel_timer(mmi_camera_sublcd_contshot_cyclic);
#endif
		gui_cancel_timer(mmi_camera_sublcd_countdown_cyclic);
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_lsk_release
* DESCRIPTION
*  stop sublcd preview then mimic softkey press.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_lsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_camera_entry_option_menu_screen();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_preview_rsk_release
* DESCRIPTION
*  stop sublcd preview then mimic softkey press.
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_preview_rsk_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	mmi_frm_scrn_close_active_id();
}

/*****************************************************************************
*
*  Sublcd Countdown State
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_sublcd_countdown_state
* DESCRIPTION
*  entry count down state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_entry_sublcd_countdown_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* register soft keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	SetKeyUpHandler(mmi_camera_sublcd_preview_lsk_release, KEY_LSK);
	SetKeyDownHandler(mmi_camera_sublcd_preview_lsk_press, KEY_LSK);

	SetKeyUpHandler(mmi_camera_sublcd_preview_rsk_release, KEY_RSK);
	SetKeyDownHandler(mmi_camera_sublcd_preview_rsk_press, KEY_RSK);


	/* clearn center key - since if not clear, this key will mappign to LSK */
	if (CAMERA_CAPTURE_KEY != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, CAMERA_CAPTURE_KEY);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY1);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyRepeatHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyLongpressHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
	}

	/* init countdown para */
	switch (g_camera_cntx.setting.delay_timer)
	{
	case CAMERA_SETTING_DELAY_TIMER_1:
		{
			g_camera_cntx.capture_countdown = CAMERA_FEATURE_DELAY_TIMER_1_DURATION * 1000;
		}
		break;

	case CAMERA_SETTING_DELAY_TIMER_2:
		{
			g_camera_cntx.capture_countdown = CAMERA_FEATURE_DELAY_TIMER_2_DURATION * 1000;
		}
		break;

	case CAMERA_SETTING_DELAY_TIMER_3:
		{
			g_camera_cntx.capture_countdown = CAMERA_FEATURE_DELAY_TIMER_3_DURATION * 1000;
		}
		break;

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;
	}

#ifdef __COUNTDOWN_USING_MMA__
	mmi_camera_init_countdown_mma();
#endif

	/* start count down */
	mmi_camera_sublcd_countdown_cyclic();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_sublcd_countdown_state
* DESCRIPTION
*  entry count down state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_sublcd_countdown_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* stop countdown timer */
	gui_cancel_timer(mmi_camera_sublcd_countdown_stop_LED);
	mmi_camera_sublcd_countdown_stop_LED();
	gui_cancel_timer(mmi_camera_sublcd_countdown_cyclic);
#ifdef __COUNTDOWN_USING_MMA__
	gui_cancel_timer(mmi_camera_capture);
	gui_cancel_timer(mmi_camera_deinit_countdown_mma);
#endif

	/* free preview resource */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
#ifdef __COUNTDOWN_USING_MMA__
#ifndef __AUDIO_ULTRA_SLIM__
		if (g_camera_cntx.multi_sound_countdown != 0 && g_camera_cntx.multi_sound_dummy_bg != 0)
#else
		if (g_camera_cntx.multi_sound_countdown != 0)
#endif

		{
			mmi_camera_deinit_countdown_mma();
		}
#endif

		/* stop previewing */
		mmi_camera_sublcd_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* 
		* when interrupt happened while clam is close (preview on sub)
		* we will go handling interrupt, when back from interrupt, 
		* we shall force enter sub again to keep clam open close state correct 
		*/
		if (g_camera_cntx.is_clam_close)
		{
			g_camera_cntx.is_force_self_capture = TRUE;
		}
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_countdown_cyclic
* DESCRIPTION
*  count down delay timer cyclic loop
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_countdown_cyclic(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* countdonw duration and freq */
	if (g_camera_cntx.capture_countdown > 6000)
	{
		mmi_camera_countdown(1000,mmi_camera_sublcd_countdown_stop_LED,mmi_camera_sublcd_countdown_cyclic);
	}
	else if (g_camera_cntx.capture_countdown > 2000)
	{
		mmi_camera_countdown(500,mmi_camera_sublcd_countdown_stop_LED,mmi_camera_sublcd_countdown_cyclic);
	}
	else if (g_camera_cntx.capture_countdown >= 0)
	{
		mmi_camera_countdown(200,mmi_camera_sublcd_countdown_stop_LED,mmi_camera_sublcd_countdown_cyclic);
	}
	else
	{
#ifdef __COUNTDOWN_USING_MMA__
		gui_start_timer(200, mmi_camera_deinit_countdown_mma);
		gui_start_timer(300, mmi_camera_sublcd_capture);
#else
		mmi_camera_sublcd_capture();
#endif
		return;
	}
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_countdown_stop_LED
* DESCRIPTION
*  stop count down LED
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_countdown_stop_LED(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.setting.led_highlight == CAMERA_SETTING_LED_HIGHLIGHT_OFF)
	{
		srv_gpio_set_device_level(GPIO_DEV_LED_STATUS_1, LED_LIGHT_LEVEL0);
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_capture
* DESCRIPTION
*  capture photo
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_capture(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
#ifdef __MMI_CAMERA_DIRECT_COUPLE__
	S32 image_region_width;
	S32 image_region_height;
	//S32 image_region_offset_x;
	//S32 image_region_offset_y;
	S32 resized_offset_x;
	S32 resized_offset_y;
	S32 resized_width;
	S32 resized_height;    
	U32 buf_size;
#endif

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	switch (g_camera_cntx.setting.cont_shot)
	{

	case CAMERA_SETTING_CONT_SHOT_OFF:
		mmi_camera_turn_on_capture_led_highlight();

		/* since user may capture when clam close, and open clam to view the captured image */
		/* disable clam open action */
		g_camera_cntx.is_dis_clam_open = TRUE;

#ifdef __MMI_CAMERA_DIRECT_COUPLE__
		/* Calculate the image buffer size */
		image_region_width = g_camera_cntx.osd_UI_device_width;
		image_region_height = g_camera_cntx.osd_UI_device_height;
		//image_region_offset_x = 0;
		//image_region_offset_y = 0;
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif    
		if ((image_region_width >= g_camera_cntx.image_width) && (image_region_height >= g_camera_cntx.image_height))
		{
			resized_width = g_camera_cntx.image_width;
			resized_height = g_camera_cntx.image_height;
		}
		else
		{
			gdi_image_util_fit_bbox(
				image_region_width,
				image_region_height,
				g_camera_cntx.image_width,
				g_camera_cntx.image_height,
				&resized_offset_x,
				&resized_offset_y,
				&resized_width,
				&resized_height);

		}

		buf_size = (((resized_width *resized_height*GDI_MAINLCD_BIT_PER_PIXEL)>>3)*2);

		ASSERT(g_camera_cntx.direct_couple_buffer!=NULL);

		g_camera_cntx.last_error = mdi_camera_capture_with_quickview(
			(U32) g_camera_cntx.direct_couple_buffer, 
			buf_size, 
			resized_width,
			resized_height,
			g_camera_cntx.captured_filepath);

		if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
		{
			g_camera_cntx.last_error = mdi_camera_encode_capture_image(&g_camera_cntx.capture_buf_ptr, &g_camera_cntx.capture_size);
		} 
		if ((g_camera_cntx.image_width > g_camera_cntx.preview_width) && 
			(g_camera_cntx.image_height > g_camera_cntx.preview_height))
		{
			g_camera_cntx.is_direct_couple = TRUE;
		}
		else
		{
			g_camera_cntx.is_direct_couple = FALSE;
		}

#else
		g_camera_cntx.last_error
			= mdi_camera_capture_to_memory(&g_camera_cntx.capture_buf_ptr, &g_camera_cntx.capture_size, g_camera_cntx.captured_filepath);
		mmi_camera_turn_off_led_highlight();
		if (g_camera_cntx.last_error == MDI_RES_CAMERA_SUCCEED)
		{
			g_camera_cntx.last_error = mdi_camera_save_captured_image();
		}
		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			FS_Delete((U16*) g_camera_cntx.captured_filepath);
			mmi_camera_display_error_popup();
			return;
		}
#endif

		/* play capture sound after capture */
		mmi_camera_capture_play_sound();

		mmi_camera_sublcd_draw_icon();

		mmi_camera_turn_off_led_highlight();
		CAMERA_ENTER_STATE(CAMERA_STATE_DELETE_CONFIRM);

		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT__

	case CAMERA_SETTING_CONT_SHOT_1:

#ifdef __CAMERA_FEATURE_CONT_SHOT_2__
	case CAMERA_SETTING_CONT_SHOT_2:
#endif 

#ifdef __CAMERA_FEATURE_CONT_SHOT_3__
	case CAMERA_SETTING_CONT_SHOT_3:
#endif 
		{
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_CONTSHOT);
			return;
		}
		break;

#endif

#ifdef __CAMERA_FEATURE_CONT_SHOT_BURST__
	case CAMERA_SETTING_CONT_SHOT_BURST:
		{
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_BURSTSHOT);
			return;
		}
		break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_BURST__ */ 

	default:
		/* restore default value */
		mmi_camera_restore_setting();
		break;

	}

}

/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_capture_button_press
* DESCRIPTION
*  capture button presse
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_capture_button_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
	mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__

	if(g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM)
	{
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_RESTART_DELCONF_WATCHDOG();
#else
		mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif//__MMI_CAMERA_SLIM__
	}
#endif
	/* capture only works is camera is ready, otherwise will ignore this action */
	if (mdi_camera_is_ready_to_capture() == TRUE)
	{
		/* if not self timer, capture the image */
		if (g_camera_cntx.setting.delay_timer == CAMERA_SETTING_DELAY_TIMER_OFF)
		{
			mmi_camera_sublcd_capture();
		}
		else
		{
#ifndef __MMI_CAMERA_SLIM__
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_COUNTDOWN);
#else
			camera_enter_state(CAMERA_STATE_SUB_COUNTDOWN);
#endif
		}
	}

	/* flush key event */
	ClearKeyEvents();
}

/*****************************************************************************
*
*  Sublcd Cont Shot State
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_sublcd_contshot_state
* DESCRIPTION
*  entry contshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#ifdef __CAMERA_FEATURE_CONT_SHOT__
static void mmi_camera_entry_sublcd_contshot_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* register soft keys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	SetKeyDownHandler(mmi_camera_sublcd_preview_lsk_press, KEY_LSK);
	SetKeyUpHandler(mmi_camera_sublcd_preview_lsk_release, KEY_LSK);

	SetKeyDownHandler(mmi_camera_sublcd_preview_rsk_press, KEY_RSK);
	SetKeyUpHandler(mmi_camera_sublcd_preview_rsk_release, KEY_RSK);

	/* clearn center key - since if not clear, this key will mappign to LSK */
	if (CAMERA_CAPTURE_KEY != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, CAMERA_CAPTURE_KEY);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY1);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
	  SetKeyRepeatHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyLongpressHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
	}

	/* init count down para */
	switch (g_camera_cntx.setting.cont_shot)
	{
	case CAMERA_SETTING_CONT_SHOT_OFF:
		{
			g_camera_cntx.cont_shot_total_count = 1;
			g_camera_cntx.cont_shot_count = 0;
		}
		break;

	case CAMERA_SETTING_CONT_SHOT_1:
		{
			g_camera_cntx.cont_shot_total_count = CAMERA_FEATURE_CONT_SHOT_1_COUNT;
			g_camera_cntx.cont_shot_count = 0;
		}
		break;

#ifdef __CAMERA_FEATURE_CONT_SHOT_2__
	case CAMERA_SETTING_CONT_SHOT_2:
		{
			g_camera_cntx.cont_shot_total_count = CAMERA_FEATURE_CONT_SHOT_2_COUNT;
			g_camera_cntx.cont_shot_count = 0;
		}
		break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_2__ */ 
#ifdef __CAMERA_FEATURE_CONT_SHOT_3__
	case CAMERA_SETTING_CONT_SHOT_3:
		{
			g_camera_cntx.cont_shot_total_count = CAMERA_FEATURE_CONT_SHOT_3_COUNT;
			g_camera_cntx.cont_shot_count = 0;
		}
		break;
#endif /* __CAMERA_FEATURE_CONT_SHOT_3__ */ 
	}

	mmi_camera_sublcd_contshot_cyclic();

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_sublcd_contshot_state
* DESCRIPTION
*  entry contshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_sublcd_contshot_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* cancel contshot timer */
	gui_cancel_timer(mmi_camera_sublcd_contshot_cyclic);

	/* free preview resource */
	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* stop previewing */
		mmi_camera_sublcd_preview_stop();

		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();

		/* 
		* when interrupt happened while clam is close (preview on sub)
		* we will go handling interrupt, when back from interrupt, 
		* we shall force enter sub again to keep clam open close state correct 
		*/

		if (g_camera_cntx.is_clam_close)
		{
			g_camera_cntx.is_force_self_capture = TRUE;
		}
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_contshot_cyclic
* DESCRIPTION
*  cont shot cyclic loop
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_contshot_cyclic(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* this function has nvram access */
	//mmi_camera_get_next_filename(buf_filename);
	mmi_camera_commit_filename_seq_no();

	/* start timer for next shot */
	gui_start_timer(100, mmi_camera_sublcd_contshot_cyclic);

	mmi_camera_turn_on_capture_led_highlight();

	if (g_camera_cntx.cont_shot_count + 1 == g_camera_cntx.cont_shot_total_count)
	{
		g_camera_cntx.is_continue_capture = FALSE;
	}
	else
	{
		g_camera_cntx.is_continue_capture = TRUE;
	}

	g_camera_cntx.last_error = mdi_camera_capture_to_file(buf_filename, g_camera_cntx.is_continue_capture);

	/* play capture sound after capture */
	mmi_camera_capture_play_sound();

	/* restore black background */
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
#endif /* CAMERA_MODULE_WITH_LCD */ 

	mmi_camera_turn_off_led_highlight();

	/* captured, previwing is stopped, change blt layer */
	mmi_camera_sublcd_preview_set_blt_layer(FALSE);

	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		g_camera_cntx.is_continue_capture = FALSE;
		gui_cancel_timer(mmi_camera_sublcd_contshot_cyclic);
		FS_Delete((U16*) buf_filename);
		//mmi_camera_restore_filename_seq_no();
		mmi_camera_display_sublcd_error_popup();
		return;
	}

	g_camera_cntx.cont_shot_count++;

	/* terminate condition */
	if (g_camera_cntx.cont_shot_count >= g_camera_cntx.cont_shot_total_count)
	{
		/* stop timer */
		gui_cancel_timer(mmi_camera_sublcd_contshot_cyclic);
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_SUB_PREVIEW);
#endif
		return;
	}
	else
	{
		/* change blt layer for previwing */
		mmi_camera_sublcd_preview_set_blt_layer(TRUE);

		/* config rotate of preview layer, only ISP_SUPPORT need */
#if defined(ISP_SUPPORT)
		gdi_layer_push_and_set_active(g_camera_cntx.sublcd_base_layer_handle);

		if (g_camera_cntx.is_clam_close == TRUE)
		{
			gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_CLOSE_ROTATE);
		}
		else
		{
			gdi_layer_set_rotate(CAMERA_LCM_SUBLCD_CLAM_OPEN_ROTATE);
		}

		gdi_layer_pop_and_restore_active();
#endif /* defined(ISP_SUPPORT) */ 

		mmi_camera_sublcd_preview_start();

		if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
		{
			g_camera_cntx.is_continue_capture = FALSE;
			/* stop timer */
			gui_cancel_timer(mmi_camera_sublcd_contshot_cyclic);
			mmi_camera_display_sublcd_error_popup();
			return;
		}
	}

}
#endif  /* __CAMERA_FEATURE_CONT_SHOT__ */
#endif /* __CAMERA_FEATURE_SELF_CAPTURE__ */ 

/*****************************************************************************
*
*  Sublcd Capture Burst State
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_sublcd_burstshot_state
* DESCRIPTION
*  entry contshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#if defined(__CAMERA_FEATURE_SELF_CAPTURE__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__)
static void mmi_camera_entry_sublcd_burstshot_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	/* register softkeys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	SetKeyDownHandler(mmi_camera_sublcd_preview_lsk_press, KEY_LSK);
	SetKeyUpHandler(mmi_camera_sublcd_preview_lsk_release, KEY_LSK);

	SetKeyDownHandler(mmi_camera_sublcd_preview_rsk_press, KEY_RSK);
	SetKeyUpHandler(mmi_camera_sublcd_preview_rsk_release, KEY_RSK);

	/* clearn center key - since if not clear, this key will mappign to LSK */
	if (CAMERA_CAPTURE_KEY != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, CAMERA_CAPTURE_KEY);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY1);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyRepeatHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyLongpressHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
	}

	mmi_camera_turn_on_capture_led_highlight();

	g_camera_cntx.is_capturing = TRUE;

#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)

	if (!MMI_CAMERA_IS_SILENT_MODE() && g_camera_cntx.setting.shutter_sound != CAMERA_SETTING_SHUTTER_SOUND_OFF)
	{
		/* start multi_channel sound, for capture sound effect */

		/* open and play a dummy midi at backgroup - this is a must do to play multi-channel sound */
#ifndef __AUDIO_ULTRA_SLIM__
		g_camera_cntx.multi_sound_dummy_bg = mdi_audio_mma_open_string(0, (void*)camera_sound_dummy_bg, CAMERA_SOUND_DUMMY_BG_LEN, MDI_FORMAT_SMF, 0, NULL, NULL);

		mdi_audio_mma_play(g_camera_cntx.multi_sound_dummy_bg);
#endif

		g_camera_cntx.multi_sound_cap_idx = 0;

		switch (g_camera_cntx.setting.shutter_sound)
		{
		case CAMERA_SETTING_SHUTTER_SOUND_1:
			{
				g_camera_cntx.multi_sound_capture0 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_1, (U32) CAMERA_SOUND_SHUTTER_1_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);

				g_camera_cntx.multi_sound_capture1 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_1, (U32) CAMERA_SOUND_SHUTTER_1_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);

				g_camera_cntx.multi_sound_capture2 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_1, (U32) CAMERA_SOUND_SHUTTER_1_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);
			}

			break;

		case CAMERA_SETTING_SHUTTER_SOUND_2:
			{
				g_camera_cntx.multi_sound_capture0 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_2, (U32) CAMERA_SOUND_SHUTTER_2_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);

				g_camera_cntx.multi_sound_capture1 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_2, (U32) CAMERA_SOUND_SHUTTER_2_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);

				g_camera_cntx.multi_sound_capture2 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_2, (U32) CAMERA_SOUND_SHUTTER_2_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);
			}
			break;

		case CAMERA_SETTING_SHUTTER_SOUND_3:
			{
				g_camera_cntx.multi_sound_capture0 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_3, (U32) CAMERA_SOUND_SHUTTER_3_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);

				g_camera_cntx.multi_sound_capture1 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_3, (U32) CAMERA_SOUND_SHUTTER_3_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);

				g_camera_cntx.multi_sound_capture2 = mdi_audio_mma_open_string(0, (void*)camera_sound_shutter_3, (U32) CAMERA_SOUND_SHUTTER_3_LEN, MDI_FORMAT_WAV, 1, NULL, NULL);
			}
			break;
		}
	}

	/* MT6228 support non-blocking burst shot */
	/* call mdi to capture and save */
	g_camera_cntx.last_error
		= mdi_camera_non_block_burst_capture_to_memory(
		CAMERA_FEATURE_CONT_SHOT_BURST_COUNT,
		&g_camera_cntx.burst_jpg_data,
		mmi_camera_sublcd_burstshot_capture_result_hdlr);

#else /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 
	/* burst shot shall play before capture */
	mmi_camera_capture_play_sound();

	/* call mdi to capture and save */
	g_camera_cntx.last_error
		= mdi_camera_burst_capture_to_memory(CAMERA_FEATURE_CONT_SHOT_BURST_COUNT, &g_camera_cntx.burst_jpg_data);

	/* restore black background */
#ifdef CAMERA_MODULE_WITH_LCD
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_clear(GDI_COLOR_BLACK);
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);
#endif /* CAMERA_MODULE_WITH_LCD */ 

	/* stop led */
	mmi_camera_turn_off_led_highlight();

	if (g_camera_cntx.last_error != MDI_RES_CAMERA_SUCCEED)
	{
		srv_prof_play_tone(ERROR_TONE,NULL);
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_SUB_PREVIEW);
#endif
	}
	else
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_SUB_BURSTSHOT_SAVING);
#else
		camera_enter_state(CAMERA_STATE_SUB_BURSTSHOT_SAVING);
#endif
	}

#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_sublcd_burstshot_state
* DESCRIPTION
*  entry contshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_sublcd_burstshot_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* stop dummy bg midi for multi-channel sound */
#if defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)

	if (g_camera_cntx.is_capturing)
	{
		mdi_camera_stop_non_block_burst_capture();
	}

	if (!MMI_CAMERA_IS_SILENT_MODE() && g_camera_cntx.setting.shutter_sound != CAMERA_SETTING_SHUTTER_SOUND_OFF)
	{
#ifndef __AUDIO_ULTRA_SLIM__
		mdi_audio_mma_stop(g_camera_cntx.multi_sound_dummy_bg);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_dummy_bg);
#endif

		mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture0);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_capture0);

		mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture1);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_capture1);

		mdi_audio_mma_stop(g_camera_cntx.multi_sound_capture2);
		mdi_audio_mma_close(g_camera_cntx.multi_sound_capture2);

		g_camera_cntx.multi_sound_capture0 = 0;
		g_camera_cntx.multi_sound_capture1 = 0;
		g_camera_cntx.multi_sound_capture2 = 0;
		g_camera_cntx.multi_sound_dummy_bg = 0;
	}

#endif /* defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ 

	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* turn off led highlight */
		mmi_camera_turn_off_led_highlight();
	}

	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* 
		* when interrupt happened while clam is close (preview on sub)
		* we will go handling interrupt, when back from interrupt, 
		* we shall force enter sub again to keep clam open close state correct 
		*/

		if (g_camera_cntx.is_clam_close)
		{
			g_camera_cntx.is_force_self_capture = TRUE;
		}
	}

}
#endif /* defined(__CAMERA_FEATURE_SELF_CAPTURE__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) */ 


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_burstshot_capture_result_hdlr
* DESCRIPTION
*  no block burst shot capture result handler
* PARAMETERS
*  ret                 [IN]        
*  captured_count      [IN]        
* RETURNS
*  void
*****************************************************************************/
#if defined(__CAMERA_FEATURE_SELF_CAPTURE__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__)
static void mmi_camera_sublcd_burstshot_capture_result_hdlr(MDI_RESULT ret, U16 captured_count)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* if camera is in EXIT state by interrup, just do nothing */
	if (g_camera_cntx.app_state == CAMERA_STATE_EXIT)
	{
		return;
	}

	/* capture count start from 1 */
	mmi_camera_capture_play_multi_channel_sound();

	if (ret >= 0)
	{
		/* no error happened */
		if (captured_count == CAMERA_FEATURE_CONT_SHOT_BURST_COUNT)
		{
			g_camera_cntx.is_capturing = FALSE;
#ifndef __MMI_CAMERA_SLIM__
			CAMERA_ENTER_STATE(CAMERA_STATE_SUB_BURSTSHOT_SAVING);
#else
			camera_enter_state(CAMERA_STATE_SUB_BURSTSHOT_SAVING);
#endif
			return;
		}
	}
	else
	{
		g_camera_cntx.is_capturing = FALSE;
		srv_prof_play_tone(ERROR_TONE,NULL);
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_SUB_PREVIEW);
#endif
	}
}
#endif /* defined(__CAMERA_FEATURE_SELF_CAPTURE__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__) */ /* __CAMERA_FEATURE_SELF_CAPTURE__ & __CAMERA_FEATURE_CONT_SHOT_BURST__ & __CAMERA_FEATURE_CONT_SHOT_BURST_NON_BLOCK__ */

/*****************************************************************************
*
*  Sublcd Save Burstshot State
*
*****************************************************************************/


/*****************************************************************************
* FUNCTION
*  mmi_camera_entry_sublcd_burstshot_saving_state
* DESCRIPTION
*  entry sublcd save burstshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
#if defined(__CAMERA_FEATURE_SELF_CAPTURE__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__)
static void mmi_camera_entry_sublcd_burstshot_saving_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	S32 str_width;
	S32 str_height;
	CHAR *  str_ptr;
	S32 lcd_width;
	S32 lcd_height;
	gdi_handle layer_handle;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* register softkeys */
	ClearInputEventHandler(MMI_DEVICE_KEY);

	SetKeyDownHandler(mmi_camera_dummy_func, KEY_LSK);
	SetKeyUpHandler(mmi_camera_dummy_func, KEY_LSK);

	SetKeyDownHandler(mmi_camera_dummy_func, KEY_RSK);
	SetKeyUpHandler(mmi_camera_dummy_func, KEY_RSK);

	/* clearn center key - since if not clear, this key will mappign to LSK */
	if (CAMERA_CAPTURE_KEY != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, CAMERA_CAPTURE_KEY);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY1 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY1);
	}

	if (CAMERA_CAPTURE_EXTRA_KEY2 != -1)
	{
		SetKeyDownHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyRepeatHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
		SetKeyLongpressHandler(mmi_camera_dummy_func, (U16)CAMERA_CAPTURE_EXTRA_KEY2);
	}

	/* drwa saving string */
	gdi_lcd_set_active(GDI_LCD_SUB_LCD_HANDLE);
	gdi_layer_reset_text_clip();

	gdi_lcd_get_dimension(&lcd_width, &lcd_height);
	gdi_layer_get_active(&layer_handle);

	str_ptr = (CHAR * ) GetString(STR_ID_CAMERA_NOTIFY_SAVING);

	gui_measure_string((UI_string_type) str_ptr, &str_width, &str_height);

	mmi_camera_draw_style_text(
		str_ptr,
		(lcd_width - str_width) >> 1,
		(lcd_height - str_height) >> 1,
		0,
		&g_camera_cntx.active_camera_osd_ptr->hint_box.style_text);

	gdi_layer_blt(layer_handle, 0, 0, 0, 0, 0, lcd_width - 1, lcd_height - 1);

	/* restore to main */
	gdi_lcd_set_active(GDI_LCD_MAIN_LCD_HANDLE);

	/* start save burst shot */
	g_camera_cntx.burst_save_index = 0;
	mmi_camera_sublcd_burstshot_saving_cyclic();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_exit_sublcd_burstshot_saving_state
* DESCRIPTION
*  exit sublcd save burstshot state
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_exit_sublcd_burstshot_saving_state(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	gui_cancel_timer(mmi_camera_sublcd_burstshot_saving_cyclic);
	gdi_image_stop_animation_all();

	if (g_camera_cntx.app_next_state == CAMERA_STATE_EXIT)
	{
		/* 
		* when interrupt happened while clam is close (preview on sub)
		* we will go handling interrupt, when back from interrupt, 
		* we shall force enter sub again to keep clam open close state correct 
		*/

		if (g_camera_cntx.is_clam_close)
		{
			g_camera_cntx.is_force_self_capture = TRUE;
		}
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_sublcd_burstshot_saving_cyclic
* DESCRIPTION
*  loop to save sublcd burstshot image
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_sublcd_burstshot_saving_cyclic(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	CHAR buf_filename[SRV_FMGR_PATH_BUFFER_SIZE];
	PU8 image_buf_ptr;
	U32 image_buf_size;
	U32 written;
	FS_HANDLE file_handle;

#ifdef EXIF_SUPPORT
	U32 size_of_exif_info = 0;
#endif 
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	/* this function has nvram access */
	mmi_camera_get_next_filename(buf_filename);

	mmi_camera_commit_filename_seq_no();
	/* start timer for next shot */
	gui_start_timer(100, mmi_camera_sublcd_burstshot_saving_cyclic);

	/* save burst shot image */
	image_buf_ptr = (PU8) g_camera_cntx.burst_jpg_data.file_address[g_camera_cntx.burst_save_index];
	image_buf_size = (U32) g_camera_cntx.burst_jpg_data.file_size[g_camera_cntx.burst_save_index];

	file_handle = FS_Open((U16*) buf_filename, FS_CREATE | FS_READ_WRITE);

	if (file_handle > 0)
	{
#ifdef EXIF_SUPPORT
		/* eixf_burst_mode_fill_header(kal_uint8* Buffer,kal_uint32 BufferOffset); */
#if defined(__MTK_TARGET__)
		size_of_exif_info = eixf_burst_mode_fill_header(image_buf_ptr);
#endif 
		image_buf_size += size_of_exif_info;
		image_buf_ptr -= size_of_exif_info;
#endif /* EXIF_SUPPORT */ 

		FS_Write(file_handle, (void*)image_buf_ptr, image_buf_size, (U32*) & written);
		FS_Close(file_handle);

		/* cant write in whole file, must be disk full */
		if (image_buf_size != written)
		{
			/* delete the file that is not save complete */
			FS_Delete((U16*) buf_filename);

			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_DISK_FULL;

			//mmi_camera_restore_filename_seq_no();
			/* this is not serious error, will play a notify tone */
			/* it will directly re-entry sub preview state */
			mmi_camera_display_sublcd_error_popup();

			return;
		}
	}
	else
	{
		if (file_handle == FS_DISK_FULL)
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_DISK_FULL;
		}
		else if (file_handle == FS_ROOT_DIR_FULL)
		{
			g_camera_cntx.last_error = CAMERA_ERR_ROOT_DIR_FULL;
		}
		else if (file_handle == FS_WRITE_PROTECTION)
		{
			g_camera_cntx.last_error = MDI_RES_CAMERA_ERR_WRITE_PROTECTION;
		}
		else
		{
			g_camera_cntx.last_error = CAMERA_ERR_SAVE_FAIL;
		}

		//mmi_camera_restore_filename_seq_no();
		/* this is not serious error, will play a notify tone */
		/* it will directly re-entry sub preview state */
		mmi_camera_display_sublcd_error_popup();
		return;
	}

	/* teminate condition */
	if (g_camera_cntx.burst_save_index >= CAMERA_FEATURE_CONT_SHOT_BURST_COUNT - 1)
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_SUB_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_SUB_PREVIEW);
#endif
		return;
	}

	/* increase index */
	g_camera_cntx.burst_save_index++;

}
#endif /* defined(__CAMERA_FEATURE_SELF_CAPTURE__) && defined(__CAMERA_FEATURE_CONT_SHOT_BURST__) */ 

/***************************************************************************
*
*  Sublcd Capture 
*
***************************************************************************/



/*****************************************************************************
*
*  Touch Screen Support
*
*****************************************************************************/



#if defined(__MMI_TOUCH_SCREEN__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_update_osd_touch_icon
* DESCRIPTION
*  update osd touch icons' positions
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_update_osd_touch_icon()
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#ifdef __CAMERA_FEATURE_DRAW_ICON__
	S32 i;
	//camera_ui_button_struct *pbuttons;


	/* update icons */
	for(i=0; i<sizeof(g_camera_icons)/sizeof(g_camera_icons[0]); i++)
	{
		g_camera_touch_icons[i].picon = &g_camera_icons[i];
#ifdef __CAMERA_FEATURE_TOUCH_CLICKICON__
		gdi_image_get_dimension_id(g_camera_icons[i].id_img_start+1, 
			&g_camera_touch_icons[i].width,
			&g_camera_touch_icons[i].height);
#endif

	}
#endif

	/* update buttons */
	//pbuttons = g_camera_cntx.osd_data.buttons;
	memset(g_camera_cntx.osd_data.buttons, 0, sizeof(g_camera_cntx.osd_data.buttons));
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_touch_scr_pen_down_hdlr
* DESCRIPTION
*  touch screen hdlr when pen down
* PARAMETERS
*  pos     [IN]        Pen down position
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_touch_scr_pen_down_hdlr(mmi_pen_point_struct pos)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		S32 tmp;

		tmp = pos.x;
		pos.x = pos.y;
		pos.y = (LCD_WIDTH - 1) - tmp;
	}


	/* while af is calculating, disable touch panel */
#ifdef __CAMERA_AUTOFOCUS__
	if (g_camera_cntx.af_state == AF_CALCULATE || g_camera_cntx.is_autofocus_pressed == TRUE)
	{
		g_camera_cntx.pressed_key = 0;
		return;
	}
#endif /* __CAMERA_AUTOFOCUS__ */ 

#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_STOP_ALL_WATCHDOG();
#else
	mmi_camera_stop_all_watchdog();
#endif
#endif
	if (g_camera_cntx.app_state == CAMERA_STATE_PREVIEW && g_camera_cntx.is_capturing == FALSE)
	{
		if (!g_camera_cntx.is_hide_osd)
		{
			S32 i;


			camera_ui_button_struct *pbutton;
#ifdef __CAMERA_FEATURE_DRAW_ICON__
			const camera_skin_icon_struct *ppos;
			camera_ui_touch_struct *picon;
			for(i=0; i<sizeof(g_camera_icons)/sizeof(g_camera_icons[0]); i++)
			{
				picon = &g_camera_touch_icons[i];
				if(picon->is_hide)
					continue;
				ppos = picon->picon->ppos;
#ifdef __CAMERA_OSD_HORIZONTAL__
				if(g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
				{
					ppos = picon->picon->ppos_270;
				}
#endif
				if ((pos.x >= ppos->offset_x) &&
					(pos.x < ppos->offset_x + picon->width) &&
					(pos.y >= ppos->offset_y) && (pos.y < ppos->offset_y + picon->height))
				{
					mmi_camera_touch_feedback_action();    
					mmi_camera_icon_press(picon->picon->id_img_start);
					return;
				}
			}
#endif

			for(i=0; i<CAMERA_BUTTON_MAX; i++)
			{
				pbutton = &g_camera_cntx.osd_data.buttons[i];
				if ((pos.x >= pbutton->x) &&
					(pos.x < pbutton->x + pbutton->width) &&
					(pos.y >= pbutton->y) && (pos.y < pbutton->y + pbutton->height))
				{
					mmi_camera_touch_feedback_action();    
					mmi_camera_key_down_hdlr(pbutton->key);
					return;
				}
			}
		}
	}
	if (g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM)
	{
		S32 i;
		camera_ui_button_struct *pbutton;
		for(i=CMAERA_TOUCH_LSK; i<CAMERA_BUTTON_MAX; i++)
		{
			pbutton = &g_camera_cntx.osd_data.buttons[i];
			if ((pos.x >= pbutton->x) &&
				(pos.x < pbutton->x + pbutton->width) &&
				(pos.y >= pbutton->y) && (pos.y < pbutton->y + pbutton->height))
			{
				kal_print_string_trace(MOD_MMI_MEDIA_APP, TRACE_GROUP_2,"[Camera]: line = %d,i = %d",__LINE__,i);            
				mmi_camera_touch_feedback_action();    
				mmi_camera_key_down_hdlr(pbutton->key);
				return;
			}
		}

	}
}

static camera_ui_button_struct* mmi_camera_get_button(mmi_pen_point_struct pos)
{
	S32 i;
	camera_ui_button_struct *pbutton = g_camera_cntx.osd_data.buttons;

	for(i=0; i<CAMERA_BUTTON_MAX; i++){
		if ((pos.x >= pbutton->x) &&
			(pos.x < pbutton->x + pbutton->width) &&
			(pos.y >= pbutton->y) && (pos.y < pbutton->y + pbutton->height))
		{
			return pbutton;
		}

		pbutton++;
	}

	return NULL;
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_touch_scr_pen_up_hdlr
* DESCRIPTION
*  touch screen hdlr when pen up
* PARAMETERS
*  pos     [IN]        Pen up position
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_touch_scr_pen_up_hdlr(mmi_pen_point_struct pos)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	camera_ui_button_struct *pbutton;
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		S32 tmp;

		tmp = pos.x;
		pos.x = pos.y;
		pos.y = (LCD_WIDTH - 1) - tmp;
	}

	pbutton = mmi_camera_get_button(pos);
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
	mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__

	if(g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM)
	{
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_RESTART_DELCONF_WATCHDOG();
#else
		mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif//__MMI_CAMERA_SLIM__
	}
#endif
#ifdef __CAMERA_FEATURE_ZOOM__
	if(NULL == pbutton &&  (CAMERA_TOUCH_ZOOM_INC == g_camera_cntx.pressed_key 
		|| CAMERA_TOUCH_ZOOM_DEC == g_camera_cntx.pressed_key) )
	{
		g_camera_cntx.is_draw_timer_on = FALSE;
		gui_cancel_timer((FuncPtr)mmi_camera_start_fast_zoom);
		mmi_camera_stop_fast_zoom();
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
#else
		mmi_camera_preview_draw_osd();
#endif
		mmi_camera_blt();
		gui_cancel_timer(mmi_camera_preview_draw_osd_timer);
	}
#endif
	if(pbutton && g_camera_cntx.pressed_key == pbutton->key){
		mmi_camera_key_up_hdlr(pbutton->key);
	}else{
		g_camera_cntx.pressed_key = 0;
		mmi_camera_preview_draw_osd();
		mmi_camera_blt();
	}

}


/*****************************************************************************
* FUNCTION
*  mmi_camera_touch_scr_pen_move_hdlr
* DESCRIPTION
*  touch screen hdlr when pen move
* PARAMETERS
*  pos     [IN]        Pen move position
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_touch_scr_pen_move_hdlr(mmi_pen_point_struct pos)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	//BOOL softkey_pressed;
	camera_ui_button_struct *pbutton;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	//softkey_pressed = FALSE;
	if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
	{
		S32 tmp;

		tmp = pos.x;
		pos.x = pos.y;
		pos.y = (LCD_WIDTH - 1) - tmp;
	}

	pbutton = mmi_camera_get_button(pos);
#ifdef __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__
#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_RESTART_APP_WATCHDOG();

#else
	mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
#endif   //__MMI_CAMERA_SLIM__

	if(g_camera_cntx.app_state == CAMERA_STATE_DELETE_CONFIRM)
	{
#ifndef __MMI_CAMERA_SLIM__
		MMI_CAMERA_RESTART_DELCONF_WATCHDOG();
#else
		mmi_camera_watchdog_restart(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif//__MMI_CAMERA_SLIM__
	}
#endif

#ifdef __CAMERA_FEATURE_ZOOM__
	if(NULL == pbutton &&  (CAMERA_TOUCH_ZOOM_INC == g_camera_cntx.pressed_key 
		|| CAMERA_TOUCH_ZOOM_DEC == g_camera_cntx.pressed_key) )
	{
		g_camera_cntx.pressed_key = 0;
		g_camera_cntx.is_draw_timer_on = FALSE;
		gui_cancel_timer((FuncPtr)mmi_camera_start_fast_zoom);
		mmi_camera_stop_fast_zoom();
#ifdef __MMI_CAMERA_MULTI_OSD_LAYER__
#ifdef __CAMERA_FEATURE_DRAW_BUTTONS__
		mmi_camera_preview_draw_buttons();
#endif //__CAMERA_FEATURE_DRAW_BUTTONS__
#else
		mmi_camera_preview_draw_osd();
#endif
		mmi_camera_blt();
		gui_cancel_timer(mmi_camera_preview_draw_osd_timer);
	}
#endif

	if(!pbutton || g_camera_cntx.pressed_key != pbutton->key)
	{
		if(g_camera_cntx.pressed_key == KEY_LEFT_ARROW || g_camera_cntx.pressed_key == KEY_RIGHT_ARROW
			|| g_camera_cntx.pressed_key == KEY_LEFT_ARROW || g_camera_cntx.pressed_key == KEY_LEFT_ARROW
			|| g_camera_cntx.pressed_key == KEY_LSK|| g_camera_cntx.pressed_key == KEY_RSK
			|| g_camera_cntx.pressed_key == KEY_CSK)
		{
			mmi_camera_key_up_hdlr(g_camera_cntx.pressed_key);
		}else{
			g_camera_cntx.pressed_key = 0;
			mmi_camera_preview_draw_osd();
			mmi_camera_blt();
		}

	}


}



#if defined(__MMI_CAMERA_FORWARD_SUPPORT__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_forward_icon_press
* DESCRIPTION
*  press forward_icon
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_forward_icon_press(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

#if defined(__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__)

#ifndef __MMI_CAMERA_SLIM__
	MMI_CAMERA_STOP_DELCONF_WATCHDOG();
#else
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
#endif
#endif
	g_camera_cntx.is_mms_icon_pressed = TRUE;
	mmi_camera_preview_draw_osd();
	mmi_camera_blt();
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_forward_icon_release
* DESCRIPTION
*  release forward_icon
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_forward_icon_release(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
#if defined(__MMI_CAMERA_FORWARD_SUPPORT__)
	g_camera_cntx.app_prev_state = g_camera_cntx.app_state;
	g_camera_cntx.app_state = CAMERA_STATE_FORWARD_TO;
	mmi_camera_entry_forward_menu_screen();
#else
	mms_content_insert_hdlr((CHAR * ) g_camera_cntx.captured_filepath);
#endif
}

#endif /* defined(__MMI_CAMERA_FORWARD_SUPPORT__) */ 
#endif /* (__MMI_TOUCH_SCREEN__) */ 


#ifdef __CAMERA_FAST_ZOOM_SUPPORT__

/*****************************************************************************
* FUNCTION
*  mmi_camera_start_fast_zoom
* DESCRIPTION
*  start fast zoom operation
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/

static void mmi_camera_start_fast_zoom(void *is_zoomin)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_START_FAST_ZOOM,is_zoomin,g_camera_cntx.max_zoom_steps);
	g_camera_cntx.is_fast_zoom = TRUE;
	g_camera_cntx.is_draw_timer_on = TRUE;
	gui_start_timer(100, mmi_camera_preview_draw_osd_timer);
	mdi_camera_start_fast_zoom((BOOL)((U32)is_zoomin), (U8) g_camera_cntx.max_zoom_steps, 1, 1);
}



/*****************************************************************************
* FUNCTION
*  mmi_camera_stop_fast_zoom
* DESCRIPTION
*  stop fast zoom operation
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_stop_fast_zoom(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	U32 current_idx = 0;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_START_FAST_ZOOM);
	mdi_camera_stop_fast_zoom();
	g_camera_cntx.is_fast_zoom = FALSE;
	mdi_camera_get_fast_zoom_step(&current_idx);
	g_camera_cntx.setting.zoom_idx = (U16)current_idx;
}
#endif /* __CAMERA_FAST_ZOOM_SUPPORT__ */ 

#if defined(__MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__)


#ifdef __MMI_CAMERA_SLIM__

static void mmi_camera_create_watchdogs(void)

{
	mmi_camera_watchdog_create(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP], MMI_CAMERA_APP_WATCHDOG_DURATION, mmi_camera_app_watchdog_callback);     
	mmi_camera_watchdog_create(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM], MMI_CAMERA_DELETE_CONFIRM_WATCHDOG_DURATION,mmi_camera_delete_confirm_watchdog_timer_callback);  

}

static void mmi_camera_delete_watchdogs(void)

{

	mmi_camera_watchdog_delete(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]); 
	mmi_camera_watchdog_delete(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);  

}

static void mmi_camera_stop_all_watchdog(void)

{
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_APP]);
	mmi_camera_watchdog_stop(&g_camera_cntx.watchdog[MMI_CAMERA_WG_DELETE_CONFIRM]);
}

#endif //__MMI_CAMERA_SLIM__


static void mmi_camera_watchdog_start(camera_watchdog_struct *pwatchdog)
{
	if(pwatchdog->stat != MMI_CAMERA_WG_STAT_STOP){
		return;
	}

	gui_start_timer(pwatchdog->delay, pwatchdog->timeout);
	pwatchdog->stat = MMI_CAMERA_WG_STAT_RUN;
}

static void mmi_camera_watchdog_create(camera_watchdog_struct *pwatchdog, S32 delay, void (*timeout)(void))
{
	pwatchdog->delay = delay;
	pwatchdog->timeout = timeout;
	pwatchdog->stat = MMI_CAMERA_WG_STAT_STOP;
}

static void mmi_camera_watchdog_stop(camera_watchdog_struct *pwatchdog)
{
	if(pwatchdog->stat == MMI_CAMERA_WG_STAT_RUN){
		gui_cancel_timer(pwatchdog->timeout);
	}

	pwatchdog->stat = MMI_CAMERA_WG_STAT_STOP;
}

static void mmi_camera_watchdog_restart(camera_watchdog_struct *pwatchdog)
{
	if(pwatchdog->stat == MMI_CAMERA_WG_STAT_INVALID)
	{
		return;
	}

	mmi_camera_watchdog_stop(pwatchdog);
	mmi_camera_watchdog_start(pwatchdog);
}


static void mmi_camera_watchdog_delete(camera_watchdog_struct *pwatchdog)
{
	if(pwatchdog->stat == MMI_CAMERA_WG_STAT_RUN){
		gui_cancel_timer(pwatchdog->timeout);
	}

	pwatchdog->stat = MMI_CAMERA_WG_STAT_INVALID;
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_app_watchdog_callback
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
static void mmi_camera_app_watchdog_callback(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if(mmi_frm_group_get_active_id() == g_camera_cntx.cur_gid)
	{
		mmi_frm_scrn_close_active_id();
	}
}

/*****************************************************************************
* FUNCTION
*  mmi_camera_delete_confirm_watchdog_timer_callback
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_delete_confirm_watchdog_timer_callback(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
#ifndef __MMI_CAMERA_SLIM__
		CAMERA_ENTER_STATE(CAMERA_STATE_PREVIEW);
#else
		camera_enter_state(CAMERA_STATE_PREVIEW);
#endif
	}
	else 
	{
		/* for External Request */
		cui_camera_event_struct evt;

		MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), g_camera_cntx.cur_gid);
		evt.evt_id = CUI_CAMERA_EVENT_RESULT_SUCCESS;
		evt.file_path = g_camera_cntx.captured_filepath;
		mmi_frm_group_post_to_parent (g_camera_cntx.cur_gid, (mmi_group_event_struct *)&evt);

		//mmi_frm_scrn_close_active_id();
	}
}

#endif /* __MMI_CAMERA_FEATURE_WATCHDOG_TIMEOUT__ */


/*****************************************************************************
* FUNCTION
*  mmi_camera_save_profiling_log
* DESCRIPTION
*  EM save capture profiling log
* PARAMETERS
*  
* RETURNS
*  
*****************************************************************************/
#if defined(__MTK_INTERNAL__)// && defined(__MTK_TARGET__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


#if defined(__CAMERA_MATV_ESD_RECOVERY_SUPPORT__)
#if defined(__MTK_TARGET__)

static void resz_cp_ESD_timeout_timer_hdlr(void)
{
	if(resz_esd_check_flag)
	{
		resz_esd_check_flag = KAL_FALSE;
		kal_set_timer(resz_cp_ESD_timeout_timer, (kal_timer_func_ptr)resz_cp_ESD_timeout_timer_hdlr,NULL, KAL_TICKS_3_SEC, 0);
	}
	else
	{
		kal_cancel_timer(resz_cp_ESD_timeout_timer);  
		mmi_camera_app_reset_watchdog_ESD();
	}
}

static void mmi_camera_app_reset_watchdog_callback(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	gui_cancel_timer(mmi_camera_app_reset_watchdog_callback);

	mmi_camera_preview_stop();
	mdi_camera_power_off();
	kal_sleep_task(100);

	mdi_camera_power_on(g_camera_cntx.cur_gid);
	mmi_camera_preview_start();
	mmi_camera_blt();
}

static void mmi_camera_app_reset_watchdog_ESD(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	gui_cancel_timer(mmi_camera_app_reset_watchdog_callback);
	gui_start_timer(1, mmi_camera_app_reset_watchdog_callback);        
}
#endif //__MTK_TARGET__

#endif //__CAMERA_MATV_ESD_RECOVERY_SUPPORT__
MMI_BOOL mmi_camera_enter_imageviewer_check(void)
{
	return mmi_frm_app_is_launched(APP_CAMERA);
}


#ifdef __MMI_AP_DCM_CAMIMGV__
#pragma arm section code,rodata
#endif

#ifdef __MMI_SUPPORT_ASMV2__
/*****************************************************************************
* FUNCTION
*  mmi_camera_register_proc
* DESCRIPTION
*  
* PARAMETERS
*  evt_type        [IN]        
*  param           [OUT]       
* RETURNS
*  void
*****************************************************************************/
static MMI_RET mmi_camera_register_proc(mmi_event_struct *evt)
{

	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	MMI_ID app_id =	GET_APP_ID(evt);
	mem_ptr_struct *ptr = (mem_ptr_struct *)evt->user_data;
	switch (evt->evt_id)
	{
	case EVT_ID_APP_ENTER:
		{
			U32 base = mmi_res_get_app_base_mem_size(app_id);
			ptr->base_ptr = mmi_frm_asm_alloc_r(app_id, base);
			MMI_ASSERT(ptr->base_ptr);

			if (GET_DEINIT_REASON(evt) != MMI_APP_DEINIT_BY_ASM_CANCEL)
			{
				mmi_frm_asm_free_r(app_id, ptr->base_ptr);
			}
			mmi_camera_lauch_init();
			break;
		}

	case EVT_ID_APP_TOP_ACTIVE:
		{
			U32 fg = mmi_res_get_app_fg_mem_size(app_id);
			ptr->fg_ptr = mmi_frm_asm_alloc_r(app_id, fg);
			MMI_ASSERT(ptr->fg_ptr);
			mmi_frm_asm_free_r(app_id, ptr->fg_ptr);
			break;
		}

	case EVT_ID_APP_TOP_INACTIVE:
		break;

	case EVT_ID_APP_DEINIT:
#ifdef __MMI_AP_DCM_CAMIMGV__
		mmi_ap_send_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_CAMIMGV);
#endif
		MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
		if(g_camera_cntx.is_enable_PQ)
		{
			mdi_camera_color_engine_disable();
			mdi_camera_color_engine_close();
			g_camera_cntx.is_enable_PQ = FALSE;
		}
		mmi_mfree(evt->user_data);
		break;
	}

	return MMI_RET_OK;

}
#endif

mmi_ret mmi_camera_group_proc(mmi_event_struct *evt)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	cui_menu_event_struct* menu_event;
    #ifndef __MMI_CASCADED_OPTION_MENU__
	mmi_confirm_property_struct arg;
	#endif
	
	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	menu_event = (cui_menu_event_struct*)evt;

	#ifndef __MMI_CASCADED_OPTION_MENU__
	mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
	arg.callback = (mmi_proc_func)mmi_camera_delete_confirmCb;
	arg.parent_id = g_camera_cntx.cur_gid;
	arg.f_auto_map_empty_softkey = MMI_FALSE;
	#endif
	
	switch (evt->evt_id)
	{
	case EVT_ID_GROUP_DEINIT:
		mmi_camera_del_app_sceen_hdlr();
		mmi_frm_group_close(g_camera_cntx.setting_menu_gid);
#ifdef __MMI_AP_DCM_CAMIMGV__
		mmi_ap_post_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_CAMIMGV);
#endif

		MMI_TRACE(MMI_MEDIA_TRC_G2_APP, MMI_TRC_CAMERA_PQ_VALUE,g_camera_cntx.is_enable_PQ);
		if(g_camera_cntx.is_enable_PQ)
		{
			mdi_camera_color_engine_disable();
			mdi_camera_color_engine_close();
			g_camera_cntx.is_enable_PQ = FALSE;
		}
		break;

	case EVT_ID_POPUP_QUIT:
		if (((mmi_event_popoupcallback_result_struct*)evt)->user_tag == (void*)MMI_CAMERA_POPUP_RESULT_PROCESS_DELETE_GROUP)
		{
			mmi_camera_delete_group();
		}
		break;

		/* sent from File Manager CUI, indicate the storage selected by users  */
		
#if defined(__CAMERA_FEATURE_STORAGE__)
	case EVT_ID_CUI_STORAGE_SELECTOR_RESULT:
		mmi_camera_select_storage_rsp_hdlr(evt);
		break;
#endif
		         
		/*menu cui*/
	case EVT_ID_CUI_MENU_LIST_ENTRY:
		{
			/*cui_menu_set_currlist_flags(menu_event->sender_id, CUI_MENU_NORMAL_LIST_WITH_NUMBERED_ICONS);*/
			mmi_menu_id m_menuitem;
			S32 i;
			S32 nItems;

			nItems =  cui_menu_get_currlist_item_count(menu_event->sender_id);
			for (i = 0; i< nItems; i++)
			{
				m_menuitem = cui_menu_get_currlist_menu_id_from_index(menu_event->sender_id, i);
				cui_menu_set_non_leaf_item(menu_event->sender_id, m_menuitem, MMI_FALSE);
			}
			/*  cui_menu_set_currlist_flags(menu_event->sender_id, CUI_MENU_NORMAL_LIST_WITH_NUMBERED_ICONS);*/
			break;
		}
	case EVT_ID_CUI_MENU_LIST_EXIT:
		break;
	case EVT_ID_CUI_MENU_ITEM_SELECT:
		switch (menu_event->highlighted_menu_id)
		{
#if defined(__MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__)
	case MENU_ID_CAMERA_TO_VDOREC_APP:
		mmi_camera_switch_to_vdorec_app();
		break;
#endif
	case MENU_ID_CAMERA_TO_IMGVIEW:
		mmi_imgview_launch();
		break;
#ifdef __CAMERA_FEATURE_EFFECT__
	case MENU_ID_CAMERA_EFFECT_SETTING:
		mmi_camera_entry_effect_setting_screen();
		break;
#endif
	case MENU_ID_CAMERA_CAMERA_SETTING:
		mmi_camera_entry_camera_setting_screen();
		break;

	case MENU_ID_CAMERA_IMAGE_SETTING:
		mmi_camera_entry_image_setting_screen();
		break;

#ifdef __CAMERA_FEATURE_ISO_SUPPORT__
	case MENU_ID_CAMERA_ISO:
		mmi_camera_entry_iso_screen();
		break;
#endif

#ifdef __CAMERA_AUTOFOCUS_METERING__
	case MENU_ID_CAMERA_AUTOFOCUS_METERING:
		mmi_camera_entry_autofocus_screen();
		break;
#endif

#ifdef __CAMERA_AUTOFOCUS__
	case MENU_ID_CAMERA_AUTOFOCUS_MODE:
		mmi_camera_entry_autofocus_mode_screen();
		break;
#endif

#ifdef __CAMERA_FEATURE_SELF_CAPTURE__
	case MENU_ID_CAMERA_SELF_CAPTURE:
		mmi_camera_set_self_capture();
		break;
#endif



#ifdef __CAMERA_FEATURE_STORAGE__
	case MENU_ID_CAMERA_STORAGE:
		mmi_camera_entry_storage_screen();
		break;
#endif
#ifdef __CAMERA_FEATURE_RESTORE_DEFAULT__
	case MENU_ID_CAMERA_RESTORE_DEFAULT:
		mmi_camera_entry_restore_default_confirm_screen();
		break;
#endif 

	/* add for 61 slim, due to menu FW disable cascade menu, use CUI menu replaced*/
#ifndef __MMI_CASCADED_OPTION_MENU__ 
		case MENU_ID_CAMERA_FORWARD_OPTION:
			mmi_camera_entry_forward_screen();
			break;
	
		case MENU_ID_CAMERA_CONFIRM_OPTION_DELETE:
#ifdef __MMI_SCREEN_ROTATE__
			arg.rotation = (mmi_frm_screen_rotate_enum)g_camera_cntx.osd_data.osd_rotate;
			arg.f_auto_map_empty_softkey = MMI_FALSE;
#endif /* __MMI_SCREEN_ROTATE__ */
			mmi_confirm_display_ext(STR_ID_CAMERA_DELETE_ASK, MMI_EVENT_QUERY, &arg);
			break;
	
#ifdef __MMI_OPP_SUPPORT__
		case MENU_ID_CAMERA_FORWARD_OPTION_TO_BT:
			g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_BT;
			mmi_camera_forward_to_hdlr();
			break;
#endif
			
#ifdef __MMI_EMAIL__
		case MENU_ID_CAMERA_FORWARD_OPTION_TO_EMAIL:
			g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_EMAIL;
			mmi_camera_forward_to_hdlr();
			break;
#endif
			
#ifdef __MMI_MMS__	
		case MENU_ID_CAMERA_FORWARD_OPTION_TO_MMS:
			g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_MMS;
			mmi_camera_forward_to_hdlr();
			break;
#endif
			
#if defined(__MMI_MMS_POSTCARD__)
		case MENU_ID_CAMERA_FORWARD_OPTION_TO_POSTCARD:
			g_camera_cntx.forward_to = MMI_CAMERA_FORWARD_TO_POSTCARD;
			mmi_camera_forward_to_hdlr();
			break;
#endif
#endif //__MMI_CASCADED_OPTION_MENU__ 

	default:
		cui_menu_close(menu_event->sender_id);
		break;
		}
		break;
	case EVT_ID_CUI_MENU_ITEM_HILITE:
		break;
	case EVT_ID_CUI_MENU_CLOSE_REQUEST:
		cui_menu_set_rotate_screen(menu_event->sender_id, MMI_FRM_SCREEN_ROTATE_0);
		cui_menu_close(menu_event->sender_id);
		g_camera_cntx.setting_menu_gid = 0;
		break;

		/*inline cui*/
	case EVT_ID_CUI_INLINE_NOTIFY:
		{
			break;
		}
	case EVT_ID_CUI_INLINE_SET_KEY:
		{
			SetCenterSoftkeyFunction(get_softkey_function(KEY_EVENT_UP,MMI_LEFT_SOFTKEY), KEY_EVENT_UP);
			break;
		}


	case EVT_ID_CUI_INLINE_MAIN_SCREEN_ACTIVE:
		{
#if defined(__CAMERA_OSD_HORIZONTAL__) && defined(__MMI_SCREEN_ROTATE__)
			if (g_camera_cntx.osd_data.osd_rotate == CAMERA_DISPLAY_ROTATE_270)
			{
				mmi_frm_screen_rotate(MMI_FRM_SCREEN_ROTATE_270);
			}
#endif /* defined(__CAMERA_OSD_HORIZONTAL__) */         
			break;
		}

	case EVT_ID_CUI_INLINE_SUBMIT:
		{
			mmi_camera_setting_inline_on_commit(menu_event->sender_id);
			cui_menu_close(menu_event->sender_id);
			break;
		}

	case EVT_ID_CUI_INLINE_ABORT:
		{
			cui_event_inline_abort_struct *abort = (cui_event_inline_abort_struct*)evt;
			cui_inline_close(abort->sender_id);
			break;
		}    
	}
	return MMI_RET_OK;
}


static void mmi_camera_delete_group(void)
{
	if (g_camera_cntx.external_request_mode == MMI_CAMERA_EXTERNAL_MODE_OFF)
	{
		mmi_frm_group_close(g_camera_cntx.cur_gid);
	}
	else
	{
		cui_camera_event_struct evt;

		MMI_FRM_INIT_GROUP_EVENT(&evt, sizeof(cui_camera_event_struct), g_camera_cntx.cur_gid);
		evt.evt_id = CUI_CAMERA_EVENT_RESULT_FAILED;
		evt.file_path = NULL;
		mmi_frm_group_send_to_parent (g_camera_cntx.cur_gid, (mmi_group_event_struct *)&evt);
	}
#ifdef __MMI_AP_DCM_CAMIMGV__
	mmi_ap_send_dcm_unload_evt(DYNAMIC_CODE_COMPRESS_CAMIMGV);
#endif
}

#if defined(__MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__)
/*****************************************************************************
* FUNCTION
*  mmi_camera_switch_to_vdorec_app
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_switch_to_vdorec_app(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/


	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/

	/* aim to avoid screen change when close camera group */
	mmi_frm_set_curr_scr_blt_mode(MMI_FRM_SCR_BLT_DEFAULT);
	mmi_camera_delete_group();
	mmi_vdorec_lauch(); 
}


/*****************************************************************************
* FUNCTION
*  mmi_camera_highlight_to_vdorec_app
* DESCRIPTION
*  
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
void mmi_camera_highlight_to_vdorec_app(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	SetLeftSoftkeyFunction(mmi_camera_switch_to_vdorec_app, KEY_EVENT_UP);
	ClearKeyHandler(KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
	ChangeLeftSoftkey(STR_GLOBAL_OK, IMG_GLOBAL_OK);
}
#endif /* _MMI_CAMERA_RECORDER_ONE_KEY_TOGGLE__ */


#endif /* defined(__MMI_CAMERA__) && !defined(__MMI_CAMCORDER__) */ 

