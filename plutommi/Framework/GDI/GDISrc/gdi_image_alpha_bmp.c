/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES. ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  gdi_image_alpha_bmp.c
 *
 * Project:
 * --------
 *  PlutoMMI
 *
 * Description:
 * ------------
 *  Alpha BitMap (ABM) - a palette-based bitmap supporting per pixel alpha
 *
 *  ABM currently only supports 16, 24, 32-bit source and destination buffer.
 *  The source and destination layer must be in the same dimension but different
 *  bpps are allowed. (NO GREATER THAN the main base layer bpp)
 *
 *  NOTE: 1. The ARM/thumb inline assembly is deprecated for RVDS 3.3.
 *        2. The layer source color key check is omitted by preventing the output 
 *           blue color from saturation.
 *        3. The ABM image data must be at least 2-byte aligned (HALF WORD ALIGNED).
 *        4. Putting the INTERNCODE section, gdi_image_abm_draw_internal(), into the 
 *           internal SRAM can boost the speed from 2x to 3x.
 *        5. The decoder is fine-tuned to make sure there is NO stack push/pop in
 *           the decoding loop (MAIN_BASE_LAYER_IS_16_BIT). It is recommended to check
 *           assembly code generated by the C compiler after code modification is made.
 *           (with ADS 1.2)
 *        6. If the source layer will change, the result may not be correct since
 *           ABM brings source layer pixels to the destination layer when the 
 *           ABM pixel alpha value is not 1.0.
 *           The only solution is to invoke redrawing when the source layer is changed.
 *
 *  TODO: 1. gdi_image_abm_set_source_layer() is a temporary solution to set the 
 *           source layer without introducing a new API, such as gdi_image_draw_alpha().
 *        2. Support layers with different dimensions
 *        3. Optimize gdi_image_abm_draw_internal() more
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/***************************************************************************** 
 * Include 
 *****************************************************************************/
#include "kal_public_api.h"
#include "kal_general_types.h"
#include "CustDataRes.h"
#include "lcd_sw_rnd.h"
#include "string.h"

#include "gdi_mutex.h"
#include "gdi_include.h"
#include "gdi_image_gif.h"
/* media memory alloc/free for drawing ABM from files */
#include "med_utility.h"

#include "fs_type.h"
#include "fs_func.h"
#include "fs_errcode.h"
#include "med_smalloc.h"
#include "MMIDataType.h"
#include "MMI_features.h"

#include "gdi_const.h"
#include "gdi_datatype.h"
#include "gdi_primitive.h"
#include "gdi_util.h"
#include "gdi_image.h"
#include "gdi_features.h"
#include "gdi_internal.h"
#include "gdi_image_alpha_bmp.h"
#include "gdi_image_alpha_bmp_internal.h"

/***************************************************************************** 
 * Define
 *****************************************************************************/ 
#define GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888


/***************************************************************************** 
 * Static Declaration
 *****************************************************************************/ 
static GDI_RESULT gdi_image_abm_get_dimension_mem(U8 *data_ptr, S32 *width, S32 *height);
static GDI_RESULT gdi_image_abm_get_dimension_file(S8 *filename, S32 *width, S32 *height);
static GDI_RESULT gdi_image_abm_draw_file(U32 flag, S32 x, S32 y, S32 width, S32 height, S8 *filename);
static void gdi_image_abm_layer_copy(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle dst_layer, gdi_handle src_layer);

static RET_VALUE_IN_REGS rect_struct get_draw_rect_in_layer_clip(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle layer);
static U32 rgb565_to_rgb888(U32 p);
static U32 rgb888_to_rgb565(U32 p);
static U32 argb8888_to_pargb8888(U32 p);
static U32 rgb565_to_rgb666(U32 p);
static U32 rgb888_to_rgb666(U32 p);

static U32 alpha_blend_24bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha);
static U32 alpha_blend_16bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha);
static U32 alpha_blend_24bit_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha);
static U32 alpha_blend_16bit_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha);
static U32 alpha_blend_32bit_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha);
static U32 alpha_blend_6666_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha);


/***************************************************************************** 
 * Global Variable
 *****************************************************************************/
/* ABM decoder mutex */
static gdi_mutex_struct g_gdi_image_abm_mutex;


/***************************************************************************** 
 * Local Function
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  need_bits
 * DESCRIPTION
 *  return the needed bits to save max number
 * PARAMETERS
 *  max_number      [IN]    the number to caculate
 * RETURNS
 *  Needed bits
 *****************************************************************************/
static U32 need_bits(U32 max_number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 bits = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (max_number != 0)
    {
        max_number >>= 1;
        bits++;
    }
    
    return bits;
}


/*****************************************************************************
 * FUNCTION
 *  get_draw_rect_in_layer_clip
 * DESCRIPTION
 *  calculate the overlapped rect between the image rect and layer clip rect
 * PARAMETERS
 *  x1          [IN]    x1 of the draw rect top-left point (x1, y1)
 *  y1          [IN]    y1 of the draw rect top-left point (x1, y1)
 *  x2          [IN]    x2 of the draw rect bottom-right point (x2, y2)
 *  y2          [IN]    y2 of the draw rect bottom-right point (x2, y2)
 *  layer       [IN]    layer handle
 * RETURNS
 *  clipped rect, if out of clip, x1 is INVALID_RECT (-1)
 *****************************************************************************/
static RET_VALUE_IN_REGS rect_struct get_draw_rect_in_layer_clip(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle layer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32                 start_x, start_y, end_x, end_y;
    S32                 layer_clip_x1, layer_clip_y1, layer_clip_x2, layer_clip_y2;
    rect_struct         clip_rect = {INVALID_RECT, INVALID_RECT, INVALID_RECT, INVALID_RECT};
    gdi_layer_struct    *layer_struct;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    layer_struct = (gdi_layer_struct*)layer;

    /* get active layer clip */
    layer_clip_x1 = (S32)layer_struct->clipx1;
    layer_clip_y1 = (S32)layer_struct->clipy1;
    layer_clip_x2 = (S32)layer_struct->clipx2;
    layer_clip_y2 = (S32)layer_struct->clipy2;

    /* check if the draw rect is out of the clip */
    if ((x1 > layer_clip_x2) || (y1 > layer_clip_y2) || (x2 < layer_clip_x1) || (y2 < layer_clip_y1))
    {
        return clip_rect;
    }

    /* calculate the overlapped rect */
    start_y = ABM_MAX(y1, layer_clip_y1);
    end_y = ABM_MIN(y2, layer_clip_y2);
    start_x = ABM_MAX(x1, layer_clip_x1);
    end_x = ABM_MIN(x2, layer_clip_x2);

    clip_rect.x1 = start_x;
    clip_rect.y1 = start_y;
    clip_rect.x2 = end_x;
    clip_rect.y2 = end_y;

    return clip_rect;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_layer_copy
 * DESCRIPTION
 *  Copy a rect between the source and destination layer. This function supports
 *  16, 24, and 32 bpp only.
 * PARAMETERS
 *  x1          [IN]    x1 of the draw rect top-left point (x1, y1)
 *  y1          [IN]    y1 of the draw rect top-left point (x1, y1)
 *  x2          [IN]    x2 of the draw rect bottom-right point (x2, y2)
 *  y2          [IN]    y2 of the draw rect bottom-right point (x2, y2)
 *  dst_layer   [IN]    destination layer handle
 *  src_layer   [IN]    source layer handle
 * RETURNS
 *  void
 *****************************************************************************/
static void gdi_image_abm_layer_copy(S32 x1, S32 y1, S32 x2, S32 y2, gdi_handle dst_layer_handle, gdi_handle src_layer_handle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    rect_struct clip_rect;
    
    S32     dst_layer_offset_x, dst_layer_offset_y;
    S32     dst_bpp;
    S32     dst_pixel_bytes; 
    S32     dst_line_jump_bytes;
    U8     *dst_line_p;
    U8      dst_cf;
    
    S32     src_layer_offset_x, src_layer_offset_y;
    S32     src_bpp;
    S32     src_pixel_bytes; 
    S32     src_line_jump_bytes;
    U8     *src_line_p;
    U8      src_cf;
    
    S32     line_width;
    S32     line_size;
    S32     x, y;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Get clipped rect */
    clip_rect = get_draw_rect_in_layer_clip(x1, y1, x2, y2, dst_layer_handle);
    if (clip_rect.x1 == INVALID_RECT)
    {
        return;
    }
    x1 = clip_rect.x1;
    y1 = clip_rect.y1;
    x2 = clip_rect.x2;
    y2 = clip_rect.y2;

    /* Get destination layer offset */
    dst_layer_offset_x  = ((gdi_layer_struct *)dst_layer_handle)->offset_x;
    dst_layer_offset_y  = ((gdi_layer_struct *)dst_layer_handle)->offset_y;
    dst_bpp             = ((gdi_layer_struct *)dst_layer_handle)->bits_per_pixel;
    dst_pixel_bytes     = dst_bpp / 8;
    dst_cf              = ((gdi_layer_struct *)dst_layer_handle)->cf;
    if (dst_cf == GDI_COLOR_FORMAT_PARGB6666)
    {
        dst_bpp += 1;
    }
    dst_line_jump_bytes = ((gdi_layer_struct *)dst_layer_handle)->width * dst_pixel_bytes;
    dst_line_p          = 
        ((gdi_layer_struct *)dst_layer_handle)->buf_ptr + 
        y1 * dst_line_jump_bytes + 
        x1 * dst_pixel_bytes;

    line_width = x2 - x1 + 1;

    if (src_layer_handle != GDI_NULL_HANDLE)
    {
        /* get source layer offset */
        src_layer_offset_x  = ((gdi_layer_struct *)src_layer_handle)->offset_x - dst_layer_offset_x;
        src_layer_offset_y  = ((gdi_layer_struct *)src_layer_handle)->offset_y - dst_layer_offset_y;
        src_bpp             = ((gdi_layer_struct*)src_layer_handle)->bits_per_pixel;
        src_pixel_bytes      = src_bpp / 8;
        src_cf              = ((gdi_layer_struct *)src_layer_handle)->cf;
        if (src_cf == GDI_COLOR_FORMAT_PARGB6666)
        {
            src_bpp += 1;
        }
        src_line_jump_bytes = ((gdi_layer_struct*)src_layer_handle)->width * src_pixel_bytes;
        src_line_p          = 
            ((gdi_layer_struct*)src_layer_handle)->buf_ptr + 
            (y1 - src_layer_offset_y) * src_line_jump_bytes + 
            (x1 - src_layer_offset_x) * src_pixel_bytes;
    
        /* do layer copy */
        if (src_bpp == dst_bpp)
        {   
            /* same pixel format, memcpy line by line */
            line_size = line_width * dst_pixel_bytes;

            for (y = y2 - y1; y >= 0; y--)
            {
                memcpy(dst_line_p, src_line_p, line_size);

                src_line_p += src_line_jump_bytes;
                dst_line_p += dst_line_jump_bytes;            
            }
        }
        else
        {   
            /* different pixel format: 16->24, 16->32, 24->16, 24->32, 32->16, 32->24 */
            // TODO: MORE OPTIMIZATION IS REQUIRED.
            src_line_jump_bytes -= line_width * src_pixel_bytes;
            dst_line_jump_bytes -= line_width * dst_pixel_bytes;

            for (y = y2 - y1; y >= 0; y--)
            {
                for (x = x2 - x1; x >= 0; x--)
                {
                    U32 color;
                    ABM_READ_PIXEL(src_line_p, color, src_bpp);
                    ABM_CONVERT_COLOR(color, color, dst_bpp, src_bpp);
                    ABM_PUT_PIXEL(dst_line_p, color, dst_bpp);

                    src_line_p += src_bpp / 8;
                    dst_line_p += dst_bpp / 8;
                }
                
                src_line_p += src_line_jump_bytes;
                dst_line_p += dst_line_jump_bytes;
            }
        }
    }
    else
    {
        /* same pixel format, memcpy line by line */
        line_size = line_width * dst_pixel_bytes;

        for (y = y2 - y1; y >= 0; y--)
        {
            memset(dst_line_p, 0, line_size);
            dst_line_p += dst_line_jump_bytes;            
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_pre_process
 * DESCRIPTION
 *  parse ABM header and calculate necessary data for the core decoder
 * PARAMETERS
 *  offset_x       [IN]     x offset to draw
 *  offset_y       [IN]     y offset to draw
 *  abm_data_ptr   [IN]     pointer to ABM data
 *  abm            [IN]
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
static S32 gdi_image_abm_pre_process(gdi_handle dst_layer_handle, int offset_x, int offset_y, gdi_handle src_layer_handle, U8 *abm_data_ptr, abm_info_struct *abm, gdi_image_abm_decode_mode_enum decode_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8      *abm_bitstream_ptr;
    U32     img_w, img_h, color_num;
    
    U32     bpp;

    U16     *abm_data_16_ptr;

    S32     x1, x2, y1, y2;

    /* clipped image range and size */
    S32     start_x, start_y, end_x, end_y;
    S32     clip_width, clip_height;

    U32     alpha_color_start_index;
    U8     *alpha_ptr;
    U32     alpha_color_num;
    U32     normal_color_num;
    U32     palette_bpp;

    U32     bb_w1, bb_h1, bb_w2, bb_h2;

    S32     dst_layer_offset_x, dst_layer_offset_y;
    U32     dst_layer_width;
    gdi_color_format dst_layer_vcf;
    U32     dst_byte_per_pixel;
    U8     *dst_mem_ptr;    
    rect_struct dst_clip_rect;

    S32     src_layer_offset_x, src_layer_offset_y;
    S32     src_layer_width;
    gdi_color_format src_layer_vcf;
    U32     src_byte_per_pixel;
    U8     *src_mem_ptr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    GDI_ASSERT(abm_data_ptr != NULL);
    GDI_ASSERT(decode_mode < GDI_IMAGE_ABM_DECODE_MODE_END_OF_ENUM);
    
    /* 
     * parse ABM header 
     */
    abm_data_16_ptr = (U16*)abm_data_ptr;
    img_w = abm_data_16_ptr[0];
    img_h = abm_data_16_ptr[1];   
    
    /* bit 15 for palette type. 0: 16-bit. 1: 24-bit. */
    if (img_h & 0x8000)
    {
        palette_bpp = 24;
    }
    else
    {
        palette_bpp = 16;
    }

    abm->palette_bpp = palette_bpp;

    img_w &= 0x7FFF;
    img_h &= 0x7FFF;

    /* discard empty images (only possible from the GDI ABM font and wrong image) */
    if (!img_w || !img_h)
    {       
        return GDI_FAILED;
    }

    /* get color number */    
    normal_color_num = abm_data_16_ptr[2];
    alpha_color_num = abm_data_16_ptr[3];
    abm->alpha_color_num = alpha_color_num;
    
    color_num = normal_color_num + alpha_color_num;
    alpha_color_start_index = normal_color_num;

    /* Get destination layer information */    
    dst_layer_offset_x  = ((gdi_layer_struct *)dst_layer_handle)->offset_x;
    dst_layer_offset_y  = ((gdi_layer_struct *)dst_layer_handle)->offset_y;
    dst_layer_width     = ((gdi_layer_struct *)dst_layer_handle)->width;
    dst_layer_vcf       = ((gdi_layer_struct *)dst_layer_handle)->vcf;
    dst_byte_per_pixel  = ((gdi_layer_struct *)dst_layer_handle)->bits_per_pixel / 8;
    dst_mem_ptr         = ((gdi_layer_struct *)dst_layer_handle)->buf_ptr;
    
    /* no alpha blending, simply equal src_layer to dst_layer_handle */
    if (alpha_color_num == 0)
    {
        src_layer_handle = dst_layer_handle;
    }
    
    if (src_layer_handle != GDI_NULL_HANDLE)
    {
        src_layer_offset_x  = ((gdi_layer_struct *)src_layer_handle)->offset_x;
        src_layer_offset_y  = ((gdi_layer_struct *)src_layer_handle)->offset_y;
        src_layer_width     = ((gdi_layer_struct *)src_layer_handle)->width;
        src_layer_vcf       = ((gdi_layer_struct *)src_layer_handle)->vcf;
        src_byte_per_pixel  = ((gdi_layer_struct *)src_layer_handle)->bits_per_pixel / 8;
        src_mem_ptr         = ((gdi_layer_struct *)src_layer_handle)->buf_ptr;

        /* Offset to destination layer */        
        src_layer_offset_x -= dst_layer_offset_x;
        src_layer_offset_y -= dst_layer_offset_y;
    }
    else
    {
        src_layer_offset_x  = 0;
        src_layer_offset_y  = 0;
        src_layer_width     = 0;
        src_layer_vcf       = 0;
        src_byte_per_pixel  = 0;
        src_mem_ptr         = NULL;
    }

    /* get image bounding box */
    bb_w1 = abm_data_16_ptr[4] & 0xFF;
    bb_h1 = abm_data_16_ptr[4] >> 8;
    bb_w2 = abm_data_16_ptr[5] & 0xFF;
    bb_h2 = abm_data_16_ptr[5] >> 8;

    /* fill 4 transparent rects outside the bounding box for alpha images */
    if (GDI_IMAGE_ABM_DECODE_MODE_2_LAYERS != decode_mode)
    {
        /* do nothing on 2 layers mode */
        x1 = offset_x;
        y1 = offset_y;
        x2 = x1 + img_w - 1;
        y2 = y1 + img_h - 1;
        if (dst_layer_vcf == GDI_COLOR_FORMAT_32 || dst_layer_vcf == GDI_COLOR_FORMAT_32_PARGB
            || dst_layer_vcf == GDI_COLOR_FORMAT_PARGB6666
            || (alpha_color_num && (src_layer_handle != dst_layer_handle) && (bb_w1 || bb_w2 || bb_h1 || bb_h2)))
        {
            gdi_handle src_handle = src_layer_handle;
            if (dst_layer_vcf == GDI_COLOR_FORMAT_32 || dst_layer_vcf == GDI_COLOR_FORMAT_32_PARGB
                || dst_layer_vcf == GDI_COLOR_FORMAT_PARGB6666)
            {
                src_handle = GDI_NULL_HANDLE;
            }
            gdi_image_abm_layer_copy(x1, y1, x2, y1 + bb_h1 - 1, dst_layer_handle, src_handle);        
            gdi_image_abm_layer_copy(x1, y2 - bb_h2 + 1, x2, y2, dst_layer_handle, src_handle);
            gdi_image_abm_layer_copy(x1, y1 + bb_h1, x1 + bb_w1 - 1, y2 - bb_h2, dst_layer_handle, src_handle);
            gdi_image_abm_layer_copy(x2 - bb_w2 + 1, y1 + bb_h1, x2, y2 - bb_h2, dst_layer_handle, src_handle);
        }
    }
    /* 
     * calculate the bounding box rect
     */
    offset_x += bb_w1;
    img_w -= bb_w1 + bb_w2;

    offset_y += bb_h1;
    img_h -= bb_h1 + bb_h2;

    x1 = offset_x;
    y1 = offset_y;
    x2 = x1 + img_w - 1;
    y2 = y1 + img_h - 1;

    /* get active layer information */
    dst_clip_rect = get_draw_rect_in_layer_clip(x1, y1, x2, y2, dst_layer_handle);

    /* if out of clip, simply return without drawing */
    if (dst_clip_rect.x1 == INVALID_RECT)
    {       
        return GDI_FAILED;
    }

    /* get source layer informaion */
    // TODO: Check clip must in source layer
    
    /* acquire overlapped rect */
    start_x = dst_clip_rect.x1;
    start_y = dst_clip_rect.y1;
    end_x = dst_clip_rect.x2;
    end_y = dst_clip_rect.y2;
    
    /* get clip width and height */
    clip_width = end_x - start_x + 1;
    clip_height = end_y - start_y + 1;
    abm->r8 = ((clip_width - 1) << 16) | clip_height;

    /* get BITS per pixel */
    if (color_num != 0)
    {
        bpp = need_bits(color_num - 1);    
    }
    else
    {
        bpp = 1;
    }
    abm->bpp = bpp;    

    /* R9: bit[31:28] 4-bit BPP, bit[27:16] 12-bit ALPHA_CI_START, bit[15:0] BPP_BIT_MASK */
    abm->r9 = (bpp << 28) | (alpha_color_start_index << 16) | ((1 << bpp) - 1);
                    
    /* color 0 is not stored in ABM, so we have to decrease 1 palette size */
    abm->palette_ptr = (U8*)abm_data_16_ptr + 12 - (palette_bpp / 8);

    alpha_ptr = abm->palette_ptr + color_num * (palette_bpp / 8);
    abm->r10 = (U32)alpha_ptr;
    
    abm_bitstream_ptr = alpha_ptr + alpha_color_num;

    /* the bitstream is 2-byte aligned, so there might be one-byte padding */
    if ((U32)abm_bitstream_ptr & 1)
    {
        abm_bitstream_ptr++;
    }

    /*
     * setup variables required by ABM decoder
     */
    abm->abm_bitstream_ptr = abm_bitstream_ptr;
    
    /* get the ABM start offset relative to the first pixel */
    abm->abm_start_bit_offset = ((start_y - y1) * img_w + (start_x - x1)) * bpp;
        
    /* bits to skipped for a line jump of the source ABM */
    abm->abm_line_jump_bits = (img_w - clip_width) * bpp;
    
    /* line jump bytes of the source and destination layer */
    abm->dst_bpp = dst_byte_per_pixel * 8;
    if (dst_layer_vcf == GDI_COLOR_FORMAT_32_PARGB || dst_layer_vcf == GDI_COLOR_FORMAT_PARGB6666)
    {
        abm->dst_bpp += 1;
    }
    abm->src_bpp = src_byte_per_pixel * 8;
    /* If source layer format is PARGB8888, let source BPP to be 33 */
    if (src_layer_vcf == GDI_COLOR_FORMAT_32_PARGB || src_layer_vcf == GDI_COLOR_FORMAT_PARGB6666)
    {
        abm->src_bpp += 1;
    }
    abm->dst_line_jump_bytes = (dst_layer_width - clip_width) * dst_byte_per_pixel;
    abm->src_line_jump_bytes = (src_layer_width - clip_width) * src_byte_per_pixel;

    /* combine seek bits and jump pixel number into the same register */
    abm->r11 = abm->abm_line_jump_bits + (abm->dst_line_jump_bytes << 16);

    /* intialize source and destination memory pointer */            
    /* set memory pointers to the start pixel */
    abm->out_mem_ptr = dst_mem_ptr + (start_y * dst_layer_width + start_x) * dst_byte_per_pixel;
    abm->src_mem_ptr = src_mem_ptr + ((start_y - src_layer_offset_y) * src_layer_width + start_x - src_layer_offset_x) * src_byte_per_pixel;
    
    return GDI_SUCCEED;
}


/*****************************************************************************
 * FUNCTION
 *  rgb565_to_rgb888
 * DESCRIPTION
 *  convert RGB565 to RGB888
 * PARAMETERS
 *  p       [IN]    RGB565 pixel
 * RETURNS
 *  24-bit RGB888 pixel
 *****************************************************************************/
static U32 rgb565_to_rgb888(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* extend p's B[4:0] to result B[7:0] */
    result = B_OF_RGB565(p) << (0 + 3);
    //result = GDI_IMAGE_ABM_BITS_5_to_8(B_OF_RGB565(p));

    /* extend p's G[10:5] to result G[15:8] */
    result |= G_OF_RGB565(p) << (8 + 2);
    //result |= GDI_IMAGE_ABM_BITS_6_to_8(G_OF_RGB565(p)) << 8;

    /* extend p's R[15:11] to result R[23:16] */
    result |= R_OF_RGB565(p) << (16 + 3);
    //result |= GDI_IMAGE_ABM_BITS_5_to_8(R_OF_RGB565(p)) << 16;
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  rgb888_to_rgb565
 * DESCRIPTION
 *  convert RGB888 to RGB565
 * PARAMETERS
 *  p       [IN]    RGB888 pixel
 * RETURNS
 *  16-bit RGB565 pixel
 *****************************************************************************/
static U32 rgb888_to_rgb565(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reduce p's B[7:0] to result[4:0] */
    result = B_OF_RGB888(p) >> 3;

    /* reduce p's G[15:8] to result[10:5] */
    result |= (G_OF_RGB888(p) >> 2) << 5;

    /* reduce p's R[15:8] to result[15:11] */
    result |= (R_OF_RGB888(p) >> 3) << 11;

    return result;
}

/*****************************************************************************
 * FUNCTION
 *  rgb888_to_rgb666
 * DESCRIPTION
 *  convert RGB888 to RGB565
 * PARAMETERS
 *  p       [IN]    RGB888 pixel
 * RETURNS
 *  18-bit RGB666 pixel
 *****************************************************************************/
static U32 rgb888_to_rgb666(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = B_OF_RGB888(p) >> 2;

    result |= (G_OF_RGB888(p) >> 2) << 6;

    result |= (R_OF_RGB888(p) >> 2) << 12;

    return result;
}

/*****************************************************************************
 * FUNCTION
 *  rgb565_to_rgb666
 * DESCRIPTION
 *  convert RGB565 to RGB666
 * PARAMETERS
 *  p       [IN]    RGB888 pixel
 * RETURNS
 *  18-bit RGB666 pixel
 *****************************************************************************/
static U32 rgb565_to_rgb666(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = GDI_BITS_5_to_6(B_OF_RGB565(p));

    result |= (G_OF_RGB565(p) << 6);

    result |= (GDI_BITS_5_to_6(R_OF_RGB565(p)) << 12);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  argb8888_to_pargb8888
 * DESCRIPTION
 *  convert ARGB8888 to PARGB8888
 * PARAMETERS
 *  p       [IN]    ARGB8888 pixel
 * RETURNS
 *  32-bit PARGB8888 pixel
 *****************************************************************************/
static U32 argb8888_to_pargb8888(U32 p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 alpha;
    U32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    alpha = A_OF_ARGB8888(p);

#if 1
    result = ABM_DIV_255(B_OF_ARGB8888(p) * alpha);
    result |= ABM_DIV_255(G_OF_ARGB8888(p) * alpha) << 8;
    result |= ABM_DIV_255(R_OF_ARGB8888(p) * alpha) << 16;
    result |= alpha << 24;
#else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    return result;
}


/*
 * optimization for time
 */
#ifdef __MTK_TARGET__
#pragma Otime
#pragma arm section code = "INTERNCODE"
#endif


/*****************************************************************************
 * FUNCTION
 *  alpha_blend_24bit_pixel
 * DESCRIPTION
 *  alpha blend two RGB888 or ARGB8888 pixels.
 *
 *  If the output format is ARGB8888, ARGB's A is set to 255 later in PUT_PIXEL_32().
 *
 *  result pixel = src_pixel * alpha / 256 + img_pixel
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel
 *  img_pixel       [IN]    ABM image pixel RGB565 (pre-calculated)
 *  alpha           [IN]    alpha value for the source pixel (0 ~ 255)
 * RETURNS
 *  24-bit pixel or 32-bit pixel (A is untouched)
 *****************************************************************************/
static U32 alpha_blend_24bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32     src_r, src_g, src_b, result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = img_pixel;
    
#ifdef GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888

    /* 
     * Do saturation check for high quality 16-bit to 24-bit since
     * the LSBs are not 0s.
     */
     
    /* R */    
    src_r = R_OF_RGB888(src_pixel);
    src_r = (src_r * alpha) >> 8;
    src_r += R_OF_RGB888(img_pixel);
    if (src_r > 255)
    {
        src_r = 255;
    }    
    result = src_r << 16;

    /* G */
    src_g = G_OF_RGB888(src_pixel);
    src_g = (src_g * alpha) >> 8; 
    src_g += G_OF_RGB888(img_pixel);
    if (src_g > 255)
    {
        src_g = 255;
    }     
    result += src_g << 8;

    /* B */
    src_b = B_OF_RGB888(src_pixel);
    src_b = (src_b * alpha) >> 8;
    src_b += B_OF_RGB888(img_pixel);
    if (src_b > 255)
    {
        src_b = 255;
    }
    result += src_b;

#else /* GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888 */
   
    /* R */
    src_r = R_OF_RGB888(src_pixel);
    src_r = (src_r * alpha) >> 8;    
    result += src_r << 16;               /* align to R of img_pixel */

    /* G */
    src_g = G_OF_RGB888(src_pixel);
    src_g = (src_g * alpha) >> 8;               
    result += src_g << 8;                /* align to G of img_pixel */

    /* B */
    src_b = B_OF_RGB888(src_pixel);
    src_b = (src_b * alpha) >> 8;
    result += src_b;                     /* align to B of img_pixel */

#endif /* GDI_IMAGE_ABM_USE_HIGH_QUALITY_RGB565_TO_RGB888 */

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  alpha_blend_16bit_pixel
 * DESCRIPTION
 *  alpha blend 2 16-bit pixels (RGB565 or RGB3553)
 *
 *  result pixel = src_pixel * alpha / 256 + img_pixel
 *
 *  THE RGB565 or RGB3553 CODE PATH IS DECIDED AT COMPILE TIME.
 *  Only 6205B and 6218 utilize RGB3553.
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel
 *  img_pixel       [IN]    ABM image pixel (pre-calculated)
 *  alpha           [IN]    alpha value for the source pixel (0 ~ 255)
 * RETURNS
 *  16-bit pixel
 *****************************************************************************/
static U32 alpha_blend_16bit_pixel(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 c;
    U32 src_r, src_g, src_b;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* combined two 16-bit pixels into one 32-bit register to save register usage */
    c = (src_pixel << 16) | img_pixel;

    if (RGB_16_BIT_TYPE == COLOR_FORMAT_RGB565)
    {   /* RGB 565 path */
        /* R */
        src_r = R_OF_HIGH_RGB565(c);                   
        c += ((src_r * alpha) >> 8) << 11;  /* align to R of img_pixel */

        /* G */
        src_g = G_OF_HIGH_RGB565(c);
        c += ((src_g * alpha) >> 8) << 5;   /* align to G of img_pixel */

        /* B */
        src_b = B_OF_HIGH_RGB565(c);
        c += (src_b * alpha) >> 8;          /* align to B of img_pixel */
    }
    else 
    {   /* RGB 3553 path, {Gl, B, R, Gh} */                   
        /* B */                
        src_b = (c << 3) >> 27;
        c += ((src_b * alpha) >> 8) << 8;

        /* R */
        src_r = (c << 8) >> 27;
        c += ((src_r * alpha) >> 8) << 3;

        /* G */                 
        src_g = (c >> 29) << 26;
        alpha |= src_g;             /* Gl at alpha[28:26] */
        src_g = (c >> 16) << 29;
        alpha |= src_g;             /* Gh at alpha[31:29] */                    
        src_g = alpha >> 26;        /* src_g = {Gh[2:0], Gl[2:0]} */

        src_g = ((src_g * alpha) >> 8) << 13;   /* G at alpha[31:26] does not affect the result */

        c = (c << 16) >> 16;        /* clear source pixel in c */

        c += src_g;                 /* add Gl */                         
        c += c >> 16;               /* add Gh */
    }   

    return c;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_core_hs
 * DESCRIPTION
 *  The main loop to draw ABM image (High Speed version)
 * PARAMETERS
 *
 * RETURNS
 *
 *****************************************************************************/
static void gdi_image_abm_draw_core_hs(
    abm_info_struct *abm, 
    U8 *abm_bs_ptr, 
    gdi_image_abm_decode_mode_enum decode_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U8  *abm_bitstream_ptr;
    
    U32 bpp;
    U8  *src_mem_ptr, *out_mem_ptr;
    
    S32 x, y; 

    U32 abm_line_jump_bits;
    U32 abm_start_bit_offset;
    
    U8  *palette_ptr;

    S32 color_index;
    U32 img_pixel;
    U32 alpha;

    U32 src_pixel = 0;

    U32 src_line_jump_bytes, dst_line_jump_bytes;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    /* save r8 to r11 */
    SAVE_REGISTER();
    
    /* set variables by abm_pre_process() */
    set_r8(abm->r8);
    set_r9(abm->r9);
    set_r10(abm->r10);
    set_r11(abm->r11);

    palette_ptr = abm->palette_ptr;
    set_r12((U32)palette_ptr);

    abm_start_bit_offset = abm->abm_start_bit_offset;
    src_mem_ptr = abm->src_mem_ptr;
    out_mem_ptr = abm->out_mem_ptr;
    src_line_jump_bytes = abm->src_line_jump_bytes;
    dst_line_jump_bytes = abm->dst_line_jump_bytes;
    abm_line_jump_bits = abm->abm_line_jump_bits;
    bpp = abm->bpp;

    /* The header and bitstream are not continuous for font engine. */
    if (abm_bs_ptr)
    {
        abm_bitstream_ptr = abm_bs_ptr;
    }
    else
    {
        abm_bitstream_ptr = abm->abm_bitstream_ptr;
    }

    /* initialize bitstream reader */
    BIT_INIT(abm_bitstream_ptr);

    /* seek to the start pixel */
    BIT_SEEK(abm_start_bit_offset);

    //if (dst_bpp == ABM_DEFAULT_PALETTE_BPP)
    {
        if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_SRC_KEY)
        {   
            ABM_DECODER_WITHOUT_ALPHA(ABM_DEFAULT_PALETTE_BPP, ABM_DEFAULT_PALETTE_BPP);
        }
        else// if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_ALPHA)
        {   
            /* ABM with alpha */
            ABM_DECODER_ALPHA(ABM_DEFAULT_PALETTE_BPP, ABM_DEFAULT_PALETTE_BPP, ABM_DEFAULT_PALETTE_BPP);
        }        
    }
    /* Not enough internal RAM, so move other case to general case */

    /* close bitstream reader */
    BIT_END();

    /* restore r8 to r11 */
    RESTORE_REGISTER();
}


/*
 * optimization for time
 */
#ifdef __MTK_TARGET__

#pragma Otime
#pragma arm section code

#endif


/*****************************************************************************
 * FUNCTION
 *  alpha_blend_32bit_pixel_hq
 * DESCRIPTION
 *  alpha blend two RGB8888 or PARGB8888 pixels.
 *
 *  result pixel = src_pixel * alpha / 256 + img_pixel
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel (PARGB8888)
 *  img_pixel       [IN]    image pixel (RGB888)
 *  alpha           [IN]    alpha value for the image pixel (255 - alpha)
 *****************************************************************************/
static U32 alpha_blend_32bit_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 a, r, g, b;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Caculate blending alpha value to variable a */
    a = 255 - alpha;
    a += ABM_DIV_255(A_OF_ARGB8888(src_pixel) * alpha);
    
    /* Cacluate blending R value and clamp to a */
    r = R_OF_RGB888(img_pixel);
    r += ABM_DIV_255(R_OF_ARGB8888(src_pixel) * alpha);
    if (r > a)
    {
        r = a;
    }

    /* Cacluate blending G value and clamp to a */
    g = G_OF_RGB888(img_pixel);
    g += ABM_DIV_255(G_OF_ARGB8888(src_pixel) * alpha);
    if (g > a)
    {
        g = a;
    }
    
    /* Cacluate blending B value and clamp to a */
    b = B_OF_RGB888(img_pixel);
    b += ABM_DIV_255(B_OF_ARGB8888(src_pixel) * alpha);
    if (b > a)
    {
        b = a;
    }

    return (a << 24) | (r << 16) | (g << 8) | b;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  alpha_blend_24bit_pixel_hq
 * DESCRIPTION
 *  alpha blend two RGB888 or ARGB8888 pixels in high quality.
 *
 *  result pixel = (src_pixel * alpha + 127) / 255 + img_pixel
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel
 *  img_pixel       [IN]    ABM image pixel RGB565 (pre-calculated)
 *  alpha           [IN]    alpha value for the source pixel (0 ~ 255)
 * RETURNS
 *  24-bit pixel or 32-bit pixel (A is untouched)
 *****************************************************************************/
static U32 alpha_blend_24bit_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 src_r, src_g, src_b, result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = img_pixel;

    /* R */
    src_r = R_OF_RGB888(src_pixel);
    src_r = ABM_DIV_255(src_r * alpha);
    result += src_r << 16;

    /* G */
    src_g = G_OF_RGB888(src_pixel);
    src_g = ABM_DIV_255(src_g * alpha);
    result += src_g << 8;

    /* B */
    src_b = B_OF_RGB888(src_pixel);
    src_b = ABM_DIV_255(src_b * alpha);
    result += src_b;

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  alpha_blend_16bit_pixel_hq
 * DESCRIPTION
 *  alpha blend 2 16-bit pixels in high quality
 *
 *  result pixel = (src_pixel * alpha + 127) / 255 + img_pixel
 *
 *  THE RGB565 or RGB3553 CODE PATH IS DECIDED AT COMPILE TIME.
 *  Only 6205B and 6218 utilize RGB3553.
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel
 *  img_pixel       [IN]    ABM image pixel (pre-calculated)
 *  alpha           [IN]    alpha value for the source pixel (0 ~ 255)
 * RETURNS
 *  16-bit pixel
 *****************************************************************************/
static U32 alpha_blend_16bit_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U32 c;
    U32 src_r, src_g, src_b;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* combined two 16-bit pixels into one 32-bit register to save register usage */
    c = (src_pixel << 16) | img_pixel;

    if (RGB_16_BIT_TYPE == COLOR_FORMAT_RGB565)
    {   /* RGB 565 path */
        /* R */
        src_r = R_OF_HIGH_RGB565(c);                   
        c += ABM_DIV_255(src_r * alpha) << 11;  /* align to R of img_pixel */

        /* G */
        src_g = G_OF_HIGH_RGB565(c);
        c += ABM_DIV_255(src_g * alpha) << 5;   /* align to G of img_pixel */

        /* B */
        src_b = B_OF_HIGH_RGB565(c);
        c += ABM_DIV_255(src_b * alpha);        /* align to B of img_pixel */
    }
    else 
    {   /* RGB 3553 path, {Gl, B, R, Gh} */                   
        /* B */                
        src_b = (c << 3) >> 27;
        c += ABM_DIV_255(src_b * alpha) << 8;

        /* R */
        src_r = (c << 8) >> 27;
        c += ABM_DIV_255(src_r * alpha) << 3;

        /* G */                 
        src_g = (c >> 29) << 26;
        alpha |= src_g;             /* Gl at alpha[28:26] */
        src_g = (c >> 16) << 29;
        alpha |= src_g;             /* Gh at alpha[31:29] */                    
        src_g = alpha >> 26;        /* src_g = {Gh[2:0], Gl[2:0]} */

        src_g = ABM_DIV_255(src_g * alpha) << 13;   /* G at alpha[31:26] does not affect the result */

        c = (c << 16) >> 16;        /* clear source pixel in c */

        c += src_g;                 /* add Gl */                         
        c += c >> 16;               /* add Gh */
    }   

    return c;
}


/*****************************************************************************
 * FUNCTION
 *  alpha_blend_6666_pixel_hq
 * DESCRIPTION
 *  alpha blend two PARGB6666 pixels.
 *
 *  result pixel = src_pixel * alpha / 256 + img_pixel
 *
 * PARAMETERS
 *  src_pixel       [IN]    source pixel (PARGB6666)
 *  img_pixel       [IN]    image pixel (PARGB6666)
 *  alpha           [IN]    alpha value for the image pixel (255 - alpha)
 *****************************************************************************/
static U32 alpha_blend_6666_pixel_hq(U32 src_pixel, U32 img_pixel, U32 alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 a, r, g, b;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Caculate blending alpha value to variable a */
    alpha = GDI_BITS_8_to_6(alpha);
    a = 63 - alpha;
    a += GDI_DIV_63(GDI_A_OF_PARGB6666(src_pixel) * alpha);
    
    /* Cacluate blending R value and clamp to a */
    r = GDI_PR_OF_PARGB6666(img_pixel);
    r += GDI_DIV_63(GDI_PR_OF_PARGB6666(src_pixel) * alpha);
    if (r > a)
    {
        r = a;
    }

    /* Cacluate blending G value and clamp to a */
    g = GDI_PG_OF_PARGB6666(img_pixel);
    g += GDI_DIV_63(GDI_PG_OF_PARGB6666(src_pixel) * alpha);
    if (g > a)
    {
        g = a;
    }
    
    /* Cacluate blending B value and clamp to a */
    b = GDI_PB_OF_PARGB6666(img_pixel);
    b += GDI_DIV_63(GDI_PB_OF_PARGB6666(src_pixel) * alpha);
    if (b > a)
    {
        b = a;
    }

    return (a << 18) | (r << 12) | (g << 6) | b;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_core
 * DESCRIPTION
 *  The main loop to draw ABM image (High Speed version)
 * PARAMETERS
 *
 * RETURNS
 *
 *****************************************************************************/
static void gdi_image_abm_draw_core(
    abm_info_struct *abm, 
    U8 *abm_bs_ptr,
    gdi_image_abm_decode_mode_enum decode_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/   
    U8  *abm_bitstream_ptr;
    
    U32 bpp;
    U8  *src_mem_ptr, *out_mem_ptr;
    
    S32 x, y; 

    U32 abm_line_jump_bits;
    U32 abm_start_bit_offset;
    
    U8  *palette_ptr;

    S32 color_index;
    U32 img_pixel;
    U32 alpha;

    U32 dst_bpp, src_bpp;
    U32 palette_bpp;    

    BOOL src_key_enable = 0;
    gdi_color src_key_value = 0;

    U32 src_pixel = 0;

    U32 src_line_jump_bytes, dst_line_jump_bytes;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    /* Get source key informations */
    gdi_layer_get_source_key(&src_key_enable, &src_key_value);

    /* 
     *  Imporent do not do any function call in this section, or 
     *  the register may be changed
     */    
    /* save r8 to r11 */
    SAVE_REGISTER();
    
    /* set variables by abm_pre_process() */
    set_r8(abm->r8);
    set_r9(abm->r9);
    set_r10(abm->r10);
    set_r11(abm->r11);

    palette_ptr = abm->palette_ptr;
    set_r12((U32)palette_ptr);

    abm_start_bit_offset = abm->abm_start_bit_offset;
    palette_bpp = abm->palette_bpp;
    dst_bpp = abm->dst_bpp;
    src_bpp = abm->src_bpp;
    src_mem_ptr = abm->src_mem_ptr;
    out_mem_ptr = abm->out_mem_ptr;
    src_line_jump_bytes = abm->src_line_jump_bytes;
    dst_line_jump_bytes = abm->dst_line_jump_bytes;
    abm_line_jump_bits = abm->abm_line_jump_bits;
    bpp = abm->bpp;

    /* The header and bitstream are not continuous for font engine. */
    if (abm_bs_ptr)
    {
        abm_bitstream_ptr = abm_bs_ptr;
    }
    else
    {
        abm_bitstream_ptr = abm->abm_bitstream_ptr;
    }

    /* initialize bitstream reader */
    BIT_INIT(abm_bitstream_ptr);

    /* seek to the start pixel */
    BIT_SEEK(abm_start_bit_offset);
    {
        if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_OUTPUT)
        {
            ABM_DECODER_OUTPUT(dst_bpp, palette_bpp);

        }
        else if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_SRC_KEY)
        {   
            ABM_DECODER_WITHOUT_ALPHA(dst_bpp, palette_bpp);

        }
        else if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_ALPHA)
        {
            /* ABM with alpha */
            ABM_DECODER_ALPHA(dst_bpp, src_bpp, palette_bpp);

        }
        else if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_2_LAYERS)
        {
            ABM_DECODER_2_LAYERS(dst_bpp, src_bpp, palette_bpp);

        }
    }

    /* close bitstream reader */
    BIT_END();

    /* restore r8 to r11 */
    RESTORE_REGISTER();
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_internal
 * DESCRIPTION
 *  draw ABM image on the current active layer
 * PARAMETERS
 *  offset_x        [IN]    x offset to draw
 *  offset_y        [IN]    y offset to draw
 *  abm_data_ptr    [IN]    pointer to ABM data
 *  abm_bs_ptr      [IN]    pointer to ABM bitstream data (NULL for normal image mode)
 *  decode_mode     [IN]    decode mode
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_draw_internal(
    gdi_handle dst_layer,
    S32 offset_x, 
    S32 offset_y, 
    gdi_handle src_layer,
    U8 *abm_data_ptr, 
    U8 *abm_bs_ptr,
    gdi_image_abm_decode_mode_enum decode_mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    abm_info_struct abm;
    gdi_color_format dst_layer_vcf;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    /* return when out of clip */
    if (gdi_image_abm_pre_process(dst_layer, offset_x, offset_y, src_layer, abm_data_ptr, &abm, decode_mode) == GDI_FAILED)
    {
        return GDI_SUCCEED;
    }

    /* Get destination layer color format */
    dst_layer_vcf = ((gdi_layer_struct*)dst_layer)->vcf;
    if (dst_layer_vcf != GDI_COLOR_FORMAT_16 && 
        dst_layer_vcf != GDI_COLOR_FORMAT_24 &&
        dst_layer_vcf != GDI_COLOR_FORMAT_32 &&
        dst_layer_vcf != GDI_COLOR_FORMAT_32_PARGB &&
        dst_layer_vcf != GDI_COLOR_FORMAT_PARGB6666)
    {
        /* Not supported destination layer format */
        return GDI_FAILED;
    }

    /*
     * Decide a decode mode
     */
    if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_AUTO)
    {
        if (dst_layer_vcf == GDI_COLOR_FORMAT_32 || dst_layer_vcf == GDI_COLOR_FORMAT_32_PARGB ||
            dst_layer_vcf == GDI_COLOR_FORMAT_PARGB6666)
        {
            decode_mode = GDI_IMAGE_ABM_DECODE_MODE_OUTPUT;
        }
        else if (abm.alpha_color_num == 0)
        {
            decode_mode = GDI_IMAGE_ABM_DECODE_MODE_SRC_KEY;
        }
        else
        {
            decode_mode = GDI_IMAGE_ABM_DECODE_MODE_ALPHA;
        }
    }

    /* Must has blending source layer in alpha mode */
    if (decode_mode == GDI_IMAGE_ABM_DECODE_MODE_ALPHA)
    {
        if (src_layer == GDI_NULL_HANDLE)
        {
            return GDI_FAILED;
        }
    }

    /*
     * Do decoding
     */
    if (abm.dst_bpp == ABM_DEFAULT_PALETTE_BPP && 
        abm.palette_bpp == ABM_DEFAULT_PALETTE_BPP &&
        decode_mode == GDI_IMAGE_ABM_DECODE_MODE_SRC_KEY)
    {
        /* Speed up for special case */
        gdi_image_abm_draw_core_hs(&abm, abm_bs_ptr, decode_mode);
    }
    else if (abm.dst_bpp == ABM_DEFAULT_PALETTE_BPP && 
        abm.src_bpp == ABM_DEFAULT_PALETTE_BPP && 
        abm.palette_bpp == ABM_DEFAULT_PALETTE_BPP &&
        decode_mode == GDI_IMAGE_ABM_DECODE_MODE_ALPHA)
    {
        /* Speed up for special case */
        gdi_image_abm_draw_core_hs(&abm, abm_bs_ptr, decode_mode);
    }
    else
    {
        gdi_image_abm_draw_core(&abm, abm_bs_ptr, decode_mode);
    }
    
    /* 
     * De-PARGB if the output to ARGB layer 
     */
    if (dst_layer_vcf == GDI_COLOR_FORMAT_32 && 
        decode_mode != GDI_IMAGE_ABM_DECODE_MODE_SRC_KEY)
    {
        S32 out_width = (abm.r8 >> 16) + 1;
        S32 out_height = (abm.r8 & 0xffff);
        
        gdi_util_convert_PARGB8888_to_ARGB8888_buf(
            abm.out_mem_ptr,
            out_width + (abm.dst_line_jump_bytes * 8 / abm.dst_bpp),
            0,
            0,
            out_width,
            out_height);
    }
    
    return GDI_SUCCEED;    
}

/*
 * optimization for space
 */
#ifdef __MTK_TARGET__

#pragma Ospace
#pragma arm section code

#endif


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_mem
 * DESCRIPTION
 *  get ABM dimension from memory
 * PARAMETERS
 *  data_ptr       [IN]     pointer to image data  
 *  width          [OUT]    image width
 *  height         [OUT]    image height
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED      
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_get_dimension_mem(U8 *data_ptr, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16    *mem16_ptr;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mem16_ptr = (U16*)data_ptr;

    *width = mem16_ptr[0] & 0x7FFF;     /* width:  byte 0 and 1 */
    *height = mem16_ptr[1] & 0x7FFF;    /* height: byte 2 and 3. Bit 15 is palette type. */

    return GDI_SUCCEED;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_file
 * DESCRIPTION
 *  get ABM dimension from a file
 * PARAMETERS
 *  filename       [IN]     filename  
 *  width          [OUT]    image width
 *  height         [OUT]    image height
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_get_dimension_file(S8 *filename, S32 *width, S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE   abm_file_handle;
    U32         read_len;
    U8          buf[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* open file */
    abm_file_handle = FS_Open((U16*)filename, FS_READ_ONLY | FS_OPEN_NO_DIR);
    
    if (abm_file_handle < 0)
    {
        return GDI_FAILED;
    }

    /* read 4 bytes for width and height from the file */
    if (FS_Read(abm_file_handle, buf, 4, &read_len) != FS_NO_ERROR)
    {
        return GDI_FAILED;
    }

    /* close file */
    FS_Close(abm_file_handle);

    /* call get dimension from memory */
    return gdi_image_abm_get_dimension_mem(buf, width, height);
}

 
/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_mem
 * DESCRIPTION
 *  draw ABM image on the current active layer from memory
 * PARAMETERS
 *  offset_x       [IN]     x offset to draw
 *  offset_y       [IN]     y offset to draw
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_draw_mem(S32 x, S32 y, S32 width, S32 height, U8 *abm_data_ptr, U8 *abm_bs_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_FAILED;
    gdi_handle temp_layer_handle = GDI_NULL_HANDLE;
    gdi_handle dst_layer_handle, src_layer_handle;
    S32 img_width, img_height;
    U8 temp_layer_cf;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_active(&dst_layer_handle);

    /* No scale */
    if (width == 0 || height == 0)
    {
        gdi_get_alpha_blending_source_layer(&src_layer_handle);
        
        return gdi_image_abm_draw_internal(
            dst_layer_handle,
            x, 
            y, 
            src_layer_handle,
            abm_data_ptr, 
            abm_bs_ptr, 
            GDI_IMAGE_ABM_DECODE_MODE_AUTO);
    }

    /* No need to scale */
    gdi_image_abm_get_dimension_mem(abm_data_ptr, &img_width, &img_height);
    if (img_width == width && img_height == height)
    {
        gdi_get_alpha_blending_source_layer(&src_layer_handle);
        
        return gdi_image_abm_draw_internal(
            dst_layer_handle,
            x, 
            y, 
            src_layer_handle,
            abm_data_ptr, 
            abm_bs_ptr, 
            GDI_IMAGE_ABM_DECODE_MODE_AUTO);
    }

    do
    {
        if (((gdi_layer_struct*)dst_layer_handle)->cf == GDI_COLOR_FORMAT_PARGB6666)
        {
            temp_layer_cf = GDI_COLOR_FORMAT_PARGB6666;
        }
        else
        {
            temp_layer_cf = GDI_COLOR_FORMAT_32_PARGB;
        }
        
        gdi_image_create_temp_layer(
            &temp_layer_handle, 
            temp_layer_cf, 
            0, 
            0, 
            img_width, 
            img_height);
        if (temp_layer_handle == GDI_NULL_HANDLE)
        {
            break;
        }

        ret = gdi_image_abm_draw_internal(
            temp_layer_handle,
            0, 
            0, 
            GDI_NULL_HANDLE,
            abm_data_ptr, 
            abm_bs_ptr, 
            GDI_IMAGE_ABM_DECODE_MODE_OUTPUT);
        if (ret != GDI_SUCCEED)
        {
            break;
        }

        /* Resize and blit */
        ret = gdi_image_resize_and_blending(
            temp_layer_handle, 
            x, 
            y, 
            width, 
            height);
        if (ret != GDI_SUCCEED)
        {
            break;
        }
    } while (0);

    if (temp_layer_handle != GDI_NULL_HANDLE)
    {
        gdi_image_free_temp_layer(temp_layer_handle);
    }

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abmp_draw_file
 * DESCRIPTION
 *  draw ABM image on the current active layer from a file 
 * PARAMETERS
 *  offset_x       [IN]     x offset to draw
 *  offset_y       [IN]     y offset to draw
 *  filename       [IN]     filename
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *****************************************************************************/
static GDI_RESULT gdi_image_abm_draw_file(U32 flag, S32 x, S32 y, S32 width, S32 height, S8 *filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE   abm_file_handle;
    U32         read_len;
    U32         file_size;
    PU8         file_buf_p;
    GDI_RESULT  ret;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    abm_file_handle = FS_Open((U16*)filename, FS_READ_ONLY | FS_OPEN_NO_DIR);
    if (abm_file_handle < 0)
    {
        return GDI_IMAGE_ERR_OPEN_FILE_FAILED;
    }    

    /* get file size */
    if ((FS_GetFileSize(abm_file_handle, &file_size) < 0))
    {
        FS_Close(abm_file_handle);

        return GDI_IMAGE_ERR_INVALID_IMAGE_SIZE;
    }

    /* Try to get buffer from media task memory. */
    file_buf_p = (U8*)gdi_alloc_ext_mem(file_size);
    if (file_buf_p == NULL)
    {
        FS_Close(abm_file_handle);
        return GDI_IMAGE_ERR_MEMORY_NOT_AVAILABLE;
    }     

    /* read whole file into the file buffer once (fastest and easiest) */
    if (FS_Read(
            abm_file_handle, 
            file_buf_p, 
            file_size, 
            &read_len) < 0)
    {
        FS_Close(abm_file_handle);
        
        return GDI_FAILED;
    }

    FS_Close(abm_file_handle);

    /* draw ABM from memory */
    if (flag & GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS)
    {
        gdi_handle dst_layer_handle, src_layer_handle;
        
        gdi_layer_get_active(&dst_layer_handle);
        gdi_get_alpha_blending_source_layer(&src_layer_handle);
        
        ret = gdi_image_abm_draw_internal(
            dst_layer_handle,
            x, 
            y, 
            src_layer_handle,
            (U8 *)file_buf_p, 
            NULL, 
            GDI_IMAGE_ABM_DECODE_MODE_2_LAYERS);
    }
    else
    {
        ret = gdi_image_abm_draw_mem(
            x, 
            y, 
            width, 
            height, 
            (U8*)file_buf_p, 
            NULL);    
    }

    /* free the media memory if it is used */
    if (file_buf_p != NULL)
    {
        gdi_free_ext_mem((void**)&file_buf_p);
    }

    return ret;
}


/***************************************************************************** 
 * Global Function 
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_init
 * DESCRIPTION
 *  Initialize the ABM decoder
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_mutex_init(&g_gdi_image_abm_mutex);
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_handler
 * DESCRIPTION
 *  handler to draw ABM
 * PARAMETERS
 *  flag            [IN]    image resource flag    
 *  frame_pos       [IN]    frame number
 *  x               [IN]    x
 *  y               [IN]    y
 *  w               [IN]    width
 *  h               [IN]    height
 *  data_ptr        [IN]    pointer to image data
 *  img_size        [IN]    image size
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
GDI_RESULT gdi_image_abm_draw_handler(
            U32 flag, 
            U32 frame_pos, 
            S32 x, 
            S32 y, 
            S32 w, 
            S32 h, 
            U8 *data_ptr, 
            U32 img_size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_SUCCEED;
    U8 bits_per_pixel;
        
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 
     * make sure 1. The image data pointer is not NULL and half word aligned.
     *           2. The destination layer color format is 16, 24, or 32-bit.
     */
    bits_per_pixel = gdi_layer_get_bit_per_pixel();
    if ((data_ptr == NULL) || ((U32)data_ptr & 1) || (bits_per_pixel < 16))
    {
        return GDI_FAILED;
    }        
    
    flag |= gdi_image_codec_get_flag();

    if (flag & GDI_IMAGE_CODEC_FLAG_IS_FILE)
    {
        S8 *filename = (S8*)data_ptr;
        
        ret = gdi_image_abm_draw_file(flag, x, y, w, h, filename);    
    }
    else
    {
        if (flag & GDI_IMAGE_CODEC_FLAG_BLEND_2_LAYERS)
        {
            gdi_handle dst_layer_handle, src_layer_handle;

            gdi_layer_get_active(&dst_layer_handle);
            gdi_get_alpha_blending_source_layer(&src_layer_handle);
                    
            ret = gdi_image_abm_draw_internal(
                dst_layer_handle,
                x, 
                y, 
                src_layer_handle,
                data_ptr, 
                NULL,
                GDI_IMAGE_ABM_DECODE_MODE_2_LAYERS);
        }
        else
        {
            ret = gdi_image_abm_draw_mem(
                x, 
                y, 
                w, 
                h, 
                data_ptr, 
                NULL);
        }
    }
    
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_handler
 * DESCRIPTION
 *  handler to get ABM dimension
 * PARAMETERS
 *  flag            [IN]   image resource flag     
 *  data_ptr        [IN]   pointer to image data      
 *  img_size        [IN]   image size        
 *  width           [OUT]  image width        
 *  height          [OUT]  image height       
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
GDI_RESULT gdi_image_abm_get_dimension_handler(
            U32 flag, 
            U8 *data_ptr, 
            U32 img_size, 
            S32 *width, 
            S32 *height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8      *filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (flag & GDI_IMAGE_CODEC_FLAG_IS_FILE)
    {
        filename = (S8*)data_ptr;
        
        return gdi_image_abm_get_dimension_file(filename, width, height);
    }
    else
    {
        return gdi_image_abm_get_dimension_mem(data_ptr, width, height);
    }
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_id_nb_concurrent
 * DESCRIPTION
 *  description
 * PARAMETERS
 *  param          [IN]     param usage
 * RETURNS
 *  
 *****************************************************************************/
GDI_RESULT gdi_image_abm_draw_id_nb_concurrent(
    gdi_handle dst_layer,
    S32 dst_layer_x, 
    S32 dst_layer_y, 
    gdi_handle src_layer,
    U16 ImageId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT ret = GDI_SUCCEED;
    U8 *data_ptr;
    U8  img_type;
    S32 img_size;
    S32 frame_number;
    S32 width;
    S32 height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GDI_ASSERT(dst_layer != NULL);

    gdi_mutex_lock(&g_gdi_image_abm_mutex);

    gdi_image_parse_resource_internal(
        (U8 *)GetImage(ImageId), 
        &data_ptr, 
        &img_type, 
        &img_size, 
        &frame_number, 
        &width, 
        &height);
    
    GDI_ASSERT(img_type == GDI_IMAGE_TYPE_ABM);
    
    ret = gdi_image_abm_draw_internal(
        dst_layer,
        dst_layer_x,
        dst_layer_y,
        src_layer,
        data_ptr,
        NULL,
        GDI_IMAGE_ABM_DECODE_MODE_AUTO);

    gdi_mutex_unlock(&g_gdi_image_abm_mutex);

    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_font
 * DESCRIPTION
 *  Draw a 1-bit bitmap font by the ABM decoder
 * PARAMETERS
 *  offset_x             [IN]   x offset
 *  offset_y             [IN]   y offset
 *  abm_header_ptr       [IN]   ABM header
 *  font_data            [IN]   font data
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_draw_font(S32 offset_x, S32 offset_y, U8 *abm_header_ptr, U8 *font_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle dst_layer_handle, src_layer_handle;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_active(&dst_layer_handle);
    gdi_get_alpha_blending_source_layer(&src_layer_handle);
    
    gdi_image_abm_draw_internal(
        dst_layer_handle,
        offset_x, 
        offset_y, 
        src_layer_handle,
        abm_header_ptr, 
        font_data, 
        GDI_IMAGE_ABM_DECODE_MODE_SRC_KEY);
}


#ifdef __MMI_VECTOR_FONT_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_draw_vector_font
 * DESCRIPTION
 *  Draw a vector font by the ABM decoder
 * PARAMETERS
 *  offset_x             [IN]   x offset
 *  offset_y             [IN]   y offset
 *  abm_header_ptr       [IN]   ABM header
 *  font_data            [IN]   font data
 * RETURNS
 *  void
 *****************************************************************************/
void gdi_image_abm_draw_vector_font(S32 offset_x, S32 offset_y, U8 *abm_header_ptr, U8 *font_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    gdi_handle dst_layer_handle, src_layer_handle;
    gdi_handle orig_src_layer_handle = GDI_NULL_HANDLE;
    MMI_BOOL force_src_layer = MMI_FALSE;
    S32 width, height;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_active(&dst_layer_handle);
    gdi_get_alpha_blending_source_layer(&src_layer_handle);
    
    gdi_image_abm_get_dimension_mem(abm_header_ptr, &width, &height);
    if (width == 0 || height == 0)
    {
        /* do nothing */
        return;
    }
    
    if (src_layer_handle == GDI_NULL_HANDLE)
    {
        force_src_layer = MMI_TRUE;
    }
    else
    {
        gdi_color_format dst_layer_vcf = ((gdi_layer_struct *)dst_layer_handle)->vcf;
        if (dst_layer_vcf == GDI_COLOR_FORMAT_32 || 
            dst_layer_vcf == GDI_COLOR_FORMAT_32_PARGB ||
            dst_layer_vcf == GDI_COLOR_FORMAT_PARGB6666)        
        {
            force_src_layer = MMI_TRUE;
        }
    }

    if (force_src_layer)
    {
        gdi_set_alpha_blending_source_layer(dst_layer_handle);
        
        orig_src_layer_handle = src_layer_handle;
        src_layer_handle = dst_layer_handle;
    }
    
    if (src_layer_handle == dst_layer_handle)
    {
        gdi_image_abm_draw_internal(
            dst_layer_handle,
            offset_x, 
            offset_y, 
            src_layer_handle,
            abm_header_ptr, 
            font_data, 
            GDI_IMAGE_ABM_DECODE_MODE_ALPHA);
    }
    else
    {
        gdi_image_abm_draw_internal(
            dst_layer_handle,
            offset_x, 
            offset_y, 
            src_layer_handle,
            abm_header_ptr, 
            font_data, 
            GDI_IMAGE_ABM_DECODE_MODE_2_LAYERS);
    }

    if (force_src_layer)
    {
        /* restore alpha blending source layer */
        gdi_set_alpha_blending_source_layer(orig_src_layer_handle);
    }
}

#endif /* __MMI_VECTOR_FONT_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_info
 * DESCRIPTION
 *  Gets the info flag.
 * PARAMETERS
 *  data_ptr       [IN]
 *  is_file        [IN]
 * RETURNS
 *  info flag
 *****************************************************************************/
U32 gdi_image_abm_get_info(U8 *data_ptr, BOOL is_file)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16    *mem16_ptr;
    U32    info;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    info = GDI_IMAGE_INFO_FLAG_DEFAULT;

    if (!is_file)
    {
        mem16_ptr = (U16*)data_ptr;

        if (mem16_ptr[0] & 0x8000)
        {
            GDI_IMAGE_INFO_FLAG_SET(info, GDI_IMAGE_INFO_FLAG_IS_FULLY_OPAQUE);
        }

        if (mem16_ptr[3] > 0)
        {
            GDI_IMAGE_INFO_FLAG_SET(info, GDI_IMAGE_INFO_FLAG_HAS_ALPHA);
        }
    }        

    return info;
}

/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_check_alpha_mem
 * DESCRIPTION
 *  get if ABM image is with or without alpha value from memory
 * PARAMETERS
 *  data_ptr       [IN]     pointer to image data  
 *  with_alpha     [OUT]    image is with/without alpha
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED  
 *  + GDI_SUCCEED
 *****************************************************************************/
GDI_RESULT gdi_image_abm_check_alpha_mem(const U8 *data_ptr, kal_bool *with_alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16    *mem16_ptr;
     
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mem16_ptr = (U16*)data_ptr;
    *with_alpha = KAL_FALSE;

    if(mem16_ptr[3] != 0) // byte 6 & 7 (total 16 bits) is for alpha color number
    {
        *with_alpha = KAL_TRUE;
    }
    
    return GDI_SUCCEED;
}


/*****************************************************************************
 * FUNCTION
 *  gdi_image_abm_get_dimension_file
 * DESCRIPTION
 *  get if ABM image is with or without alpha value from file
 * PARAMETERS
 *  filename       [IN]     filename  
 *  with_alpha     [OUT]    image is with/without alpha
 * RETURNS
 *  GDI_SUCCEED if successful, otherwise GDI_FAILED
 *  + GDI_SUCCEED
 *  + GDI_FAILED
 *****************************************************************************/
GDI_RESULT gdi_image_abm_check_alpha_file(S8 *filename, kal_bool *with_alpha)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE   abm_file_handle;
    U32         read_len;
    U8          buf[8];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* open file */
    abm_file_handle = FS_Open((U16*)filename, FS_READ_ONLY | FS_OPEN_NO_DIR);
    
    if (abm_file_handle < 0)
    {
        return GDI_FAILED;
    }

    /* read 8 bytes (mainly use last 2 bytes is for see alpha color num from the file) */
    if (FS_Read(abm_file_handle, buf, 8, &read_len) != FS_NO_ERROR)
    {
        return GDI_FAILED;
    }

    /* close file */
    FS_Close(abm_file_handle);

    /* call get dimension from memory */
    return gdi_image_abm_check_alpha_mem(buf, with_alpha);
}


