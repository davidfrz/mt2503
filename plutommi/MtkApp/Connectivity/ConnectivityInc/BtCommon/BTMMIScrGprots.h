/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 * BTMMIScrGprots.h
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *   This file is the header file of btmmiscr.c
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#ifndef __BT_MMI_SCR_GPROTS_H__
#define __BT_MMI_SCR_GPROTS_H__

#include "MMI_features.h"
#include "BtcmSrvGprot.h"
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "ProcedureGprot.h"
#ifdef __MMI_BT_DIALER_SUPPORT__
#include "BtConnCfg.h"
#include "BtConnScr.h"
#endif

#ifdef __MMI_BT_SLIM__
#ifndef _MMI_BT_ULTRA_SLIM_
#define _MMI_BT_ULTRA_SLIM_
#endif 
#endif

/***************************************************************************** 
* Extern Global Function Pointer
*****************************************************************************/
//extern PS8(*mmi_bt_ucs2_str_utility) (S8 *str_dest, const S8 *str_src);
typedef void (*mmi_bt_authorize_callback) (srv_bt_cm_bt_addr *bd_addr,U32 profile_id, U32 result);
/*---------------------------------------------------------------------------
 * Event Emit
 *--------------------------------------------------------------------------*/
typedef struct
{
    MMI_EVT_PARAM_HEADER
    void *event_info;               /* Event information data. For each event's event infomation structure,
                                     * refer the discription of each event in enum srv_sms_event_enum. */
    MMI_BOOL is_dis_all;
} srv_bt_dialer_event_struct;


/*---------------------------------------------------------------------------
 * Event Emit
 *--------------------------------------------------------------------------*/
typedef struct
{
    MMI_EVT_PARAM_HEADER
    void *event_info;               /* Event information data. For each event's event infomation structure,
                                     * refer the discription of each event in enum srv_sms_event_enum. */
} srv_avrcp_ct_event_struct;

/***************************************************************************** 
* Enum
*****************************************************************************/

/*
    the role in a profile, could be a server or a client
*/
typedef enum
{
    MMI_BT_SERVER_ROLE, /* server */
    MMI_BT_CLIENT_ROLE  /* client */
} MMI_BT_PROFILE_ROLE;



/* class of device bit mask */

/* <GROUP Major Service Mask>
postioning major service mask */
#define MMI_BT_POSTIONING_MAJOR_SERVICE_MASK                            (0x010000)
/* <GROUP Major Service Mask>
networking major service mask */
#define MMI_BT_NETWORKING_MAJOR_SERVICE_MASK                            (0x020000)
/* <GROUP Major Service Mask>
rendering major service mask */
#define MMI_BT_RENDERING_MAJOR_SERVICE_MASK                                (0x040000)
/* <GROUP Major Service Mask>
capturing major service mask */
#define MMI_BT_CAPTURING_MAJOR_SERVICE_MASK                                (0x080000)
/* <GROUP Major Service Mask>
object transfer major service mask */
#define MMI_BT_OBJECT_TRANSFER_MAJOR_SERVICE_MASK                        (0x100000)
/* <GROUP Major Service Mask>
audio major service mask */
#define MMI_BT_AUDIO_MAJOR_SERVICE_MASK                                    (0x200000)
/* <GROUP Major Service Mask>
telephony major service mask */
#define MMI_BT_TELEPHONY_MAJOR_SERVICE_MASK                                (0x400000)
/* <GROUP Major Service Mask>
information major service mask */
#define MMI_BT_INFORMATION_MAJOR_SERVICE_MASK                            (0x800000)


/* <GROUP Major Device Mask>
miscellaneous major device mask */
#define MMI_BT_MISCELLANEOUS_MAJOR_DEVICE_MASK                            (0x000000)
/* <GROUP Major Device Mask>
computer major device mask */
#define MMI_BT_COMPUTER_MAJOR_DEVICE_MASK                                (0x000100)
/* <GROUP Major Device Mask>
phone major device mask */
#define MMI_BT_PHONE_MAJOR_DEVICE_MASK                                    (0x000200)
/* <GROUP Major Device Mask>
LAN major device mask */
#define MMI_BT_LAN_MAJOR_DEVICE_MASK                                    (0x000300)
/* <GROUP Major Device Mask>
AV major device mask */
#define MMI_BT_AV_MAJOR_DEVICE_MASK                                        (0x000400)
/* <GROUP Major Device Mask>
peripheral major device mask */
#define MMI_BT_PERIPHERAL_MAJOR_DEVICE_MASK                                (0x000500)
/* <GROUP Major Device Mask>
imaging major device mask */
#define MMI_BT_IMAGING_MAJOR_DEVICE_MASK                                (0x000600)
/* <GROUP Major Device Mask>
unclassified major device mask */
#define MMI_BT_UNCLASSIFIED_MAJOR_DEVICE_MASK                            (0x001F00)

/* <GROUP Minor Device    Mask under computer major class>
desktop workstation minor device mask */
#define MMI_BT_DESKTOP_WORKSTATION_MINOR_DEVICE_MASK                    (0x000004)
/* <GROUP Minor Device    Mask under computer major class>
server class computer minor device mask */
#define MMI_BT_SERVER_CLASS_COMPUTER_MINOR_DEVICE_MASK                    (0x000008)
/* <GROUP Minor Device    Mask under computer major class>
laptop minor device mask */
#define MMI_BT_LAPTOP_MINOR_DEVICE_MASK                                    (0x00000C)
/* <GROUP Minor Device    Mask under computer major class>
handhelp PC PDA minor device mask */
#define MMI_BT_HANDHELP_PC_PDA_MINOR_DEVICE_MASK                        (0x000010)
/* <GROUP Minor Device    Mask under computer major class>
palm sized PC PDA minor device mask */
#define MMI_BT_PALM_SIZED_PC_PDA_MINOR_DEVICE_MASK                        (0x000014)
/* <GROUP Minor Device    Mask under computer major class>
unclassified computer minor device mask */
#define    MMI_BT_UNCLASSIFIED_COMPUTER_MINOR_DEVICE_MASK                    (0x000000)


/* <GROUP Minor Device    Mask under phone major class>
cellular minor device mask */
#define MMI_BT_CELLULAR_MINOR_DEVICE_MASK                                (0x000004)
/* <GROUP Minor Device    Mask under phone major class>
cordless minor device mask */
#define MMI_BT_CORDLESS_MINOR_DEVICE_MASK                                (0x000008)
/* <GROUP Minor Device    Mask under phone major class>
smart phone minor device mask */
#define MMI_BT_SMART_PHONE_MINOR_DEVICE_MASK                            (0x00000C)
/* <GROUP Minor Device    Mask under phone major class>
wired modem or voice gateway minor device mask */
#define MMI_BT_WIRED_MODEM_OR_VOICE_GATEWAY_MINOR_DEVICE_MASK            (0x000010)    
/* <GROUP Minor Device    Mask under phone major class>
unclassified phone minor device mask */
#define    MMI_BT_UNCLASSIFIED_PHONE_MINOR_DEVICE_MASK                        (0x000000)


/* <GROUP Minor Device    Mask under audio/video major class>
uncategorised AV minor device mask */
#define    MMI_BT_UNCATEGORISED_AV_MINOR_DEVICE_MASK                        (0x000000)
/* <GROUP Minor Device    Mask under audio/video major class>
wearable headset AV minor device mask */
#define MMI_BT_WEARABLE_HEADSET_AV_MINOR_DEVICE_CLASS                    (0x000004)
/* <GROUP Minor Device    Mask under audio/video major class>
handsfree AV minor device mask */
#define MMI_BT_HANDSFREE_AV_MINOR_DEVICE_CLASS                            (0x000008)
/* <GROUP Minor Device    Mask under audio/video major class>
microphone AV minor device mask */
#define MMI_BT_MICROPHONE_AV_MINOR_DEVICE_CLASS                            (0x000010)
/* <GROUP Minor Device    Mask under audio/video major class>
loudspeaker AV minor device mask */
#define MMI_BT_LOUDSPEAKER_AV_MINOR_DEVICE_CLASS                        (0x000014)
/* <GROUP Minor Device    Mask under audio/video major class>
headphone AV minor device mask */
#define MMI_BT_HEADPHONES_AV_MINOR_DEVICE_CLASS                            (0x000018)
/* <GROUP Minor Device    Mask under audio/video major class>
portable audio AV minor device mask */
#define MMI_BT_PORTABLE_AUDIO_AV_MINOR_DEVICE_CLASS                        (0x00001C)
/* <GROUP Minor Device    Mask under audio/video major class>
car audio AV minor device mask */
#define MMI_BT_CAR_AUDIO_AV_MINOR_DEVICE_CLASS                            (0x000020)
/* <GROUP Minor Device    Mask under audio/video major class>
settop box AV minor device mask */
#define MMI_BT_SETTOP_BOX_AV_MINOR_DEVICE_CLASS                            (0x000024)
/* <GROUP Minor Device    Mask under audio/video major class>
hifi audio AV minor device mask */
#define MMI_BT_HIFI_AUDIO_AV_MINOR_DEVICE_CLASS                            (0x000028)
/* <GROUP Minor Device    Mask under audio/video major class>
VCR AV minor device mask */
#define MMI_BT_VCR_AV_MINOR_DEVICE_CLASS                                (0x00002C)
/* <GROUP Minor Device    Mask under audio/video major class>
video camera AV minor device mask */
#define MMI_BT_VIDEO_CAMERA_AV_MINOR_DEVICE_CLASS                        (0x000030)
/* <GROUP Minor Device    Mask under audio/video major class>
camcorder AV minor device mask */
#define MMI_BT_CAMCORDER_AV_MINOR_DEVICE_CLASS                            (0x000034)
/* <GROUP Minor Device    Mask under audio/video major class>
video monitor AV minor device mask */
#define MMI_BT_VIDEO_MONITOR_AV_MINOR_DEVICE_CLASS                        (0x000038)
/* <GROUP Minor Device    Mask under audio/video major class>
video display and loudspeaker AV minor device mask */
#define MMI_BT_VIDEO_DISPLAY_AND_LOUDSPEAKER_AV_MINOR_DEVICE_CLASS        (0x00003C)
/* <GROUP Minor Device    Mask under audio/video major class>
video conferencing AV minor device mask */
#define MMI_BT_VIDEO_CONFERENCING_AV_MINOR_DEVICE_CLASS                    (0x000040)
/* <GROUP Minor Device    Mask under audio/video major class>
game toy AV minor device mask */
#define MMI_BT_GAME_TOY_AV_MINOR_DEVICE_CLASS                            (0x000048)

/* <GROUP Minor Device    Mask under LAN major class>
fully available minor device mask */
#define MMI_BT_FULLY_AVAILABLE_MINOR_DEVICE_MASK                        (0x000000) 
/* <GROUP Minor Device    Mask under LAN major class>
one to seventeen percent minor device mask */
#define MMI_BT_ONE_TO_SEVENTEEN_PERCENT_MINOR_DEVICE_MASK                (0x000020)
/* <GROUP Minor Device    Mask under LAN major class>
seventeen to thirtythree percent minor device mask */
#define MMI_BT_SEVENTEEN_TO_THIRTYTHREE_PERCENT_MINOR_DEVICE_MASK        (0x000040)
/* <GROUP Minor Device    Mask under LAN major class>
thirtythree to fifty percent minor device mask */
#define MMI_BT_THIRTYTHREE_TO_FIFTY_PERCENT_MINOR_DEVICE_MASK            (0x000060)
/* <GROUP Minor Device    Mask under LAN major class>
fifty to sixtyseven percent minor device mask */
#define MMI_BT_FIFTY_TO_SIXTYSEVEN_PERCENT_MINOR_DEVICE_MASK            (0x000080)
/* <GROUP Minor Device    Mask under LAN major class>
sixtyseven to eightythree percent minor device mask */
#define MMI_BT_SIXTYSEVEN_TO_EIGHTYTHREE_PERCENT_MINOR_DEVICE_MASK        (0x0000A0)
/* <GROUP Minor Device    Mask under LAN major class>
eightythree to ninetynine percent minor device mask */
#define MMI_BT_EIGHTYTHREE_TO_NINETYNINE_PERCENT_MINOR_DEVICE_MASK        (0x0000C0)
/* <GROUP Minor Device    Mask under LAN major class>
no service available minor device mask */
#define MMI_BT_NO_SERVICE_AVAILABLE_MINOR_DEVICE_MASK                    (0x0000E0)
/* <GROUP Minor Device    Mask under LAN major class>
unclassified LAN minor device mask */
#define    MMI_BT_UNCLASSIFIED_LAN_MINOR_DEVICE_MASK                        (0x000000)

/* <GROUP Minor Device Mask under Peripheral major Class (Keyboard/pointing device filed)>
joystick peripheral minor device mask */
#define MMI_BT_JOYSTICK_PERIPHERALS_MINOR_DEVICE_CLASS                    (0x000004)
/* <GROUP Minor Device Mask under Peripheral major Class (Keyboard/pointing device filed)>
gamepad device peripheral minor device mask */
#define MMI_BT_GAMEPAD_DEVICE_PERIPHERAL_MINOR_DEVICE_CLASS                (0x000008)
/* <GROUP Minor Device Mask under Peripheral major Class (Keyboard/pointing device filed)>
remote control device peripheral minor device mask */
#define MMI_BT_REMOTE_CONTRO_DEVICE_PERIPHERAL_MINOR_DEVICE_CLASS        (0x00000C)
/* <GROUP Minor Device Mask under Peripheral major Class (Keyboard/pointing device filed)>
sensing device peripheral minor device mask */
#define MMI_BT_SENSING_DEVICE_PERIPHERAL_MINOR_DEVICE_CLASS                (0x000010)
/* <GROUP Minor Device Mask under Peripheral major Class (Keyboard/pointing device filed)>
digitizer tablet peripheral minor device mask */
#define MMI_BT_DIGITIZER_TABLET_PERIPHERAL_MINOR_DEVICE_CLASS            (0x000014)
/* <GROUP Minor Device Mask under Peripheral major Class (Keyboard/pointing device filed)>
card reader peripheral minor device mask */
#define MMI_BT_CARD_READER_PERIPHERAL_MINOR_DEVICE_CLASS                (0x000018)

/* <GROUP Minor Device Mask under Imaging major Class (printing, scanner, caramera...)>
display imaging minor device mask */
#define MMI_BT_DISPLAY_IMAGING_MINOR_DEVICE_CLASS                        (0x000010)
/* <GROUP Minor Device Mask under Imaging major Class (printing, scanner, caramera...)>
camera imaging minor device mask */
#define MMI_BT_CAMERA_IMAGING_MINOR_DEVICE_CLASS                        (0x000020)
/* <GROUP Minor Device Mask under Imaging major Class (printing, scanner, caramera...)>
scanner imaging minor device mask */
#define MMI_BT_SCANNER_IMAGING_MINOR_DEVICE_CLASS                        (0x000040)
/* <GROUP Minor Device Mask under Imaging major Class (printing, scanner, caramera...)>
printer imaging minor device mask */
#define MMI_BT_PRINTER_IMAGING_MINOR_DEVICE_CLASS                        (0x000080)

/*******************************/
/* main menu */
/*******************************/
extern void mmi_bt_entry_main_menu(void);

extern void mmi_bt_entry_power_switch(void);


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_init
 * DESCRIPTION
 *  This function is to initialize Bluetooth profiles, and initialize BT screen function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_init(void);


/*****************************************************************************
 * <GROUP query function>
 * FUNCTION
 *  mmi_bt_is_hf_car_kit_connected
 * DESCRIPTION
 *  This function is to check if the cod of connected handsfree profile is car-kit
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL        TRUE : car kit connected
 *                   FALSE : no car kit connected
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_hf_car_kit_connected(void);

/*****************************************************************************
 * <GROUP query function>
 * FUNCTION
 *  mmi_bt_is_hw_ready
 * DESCRIPTION
 *  This function is to check if Bluetooth hardware is ready
 *  It will check power status and ready state.
 * PARAMETERS
 *  is_popup :        [IN]            if Bluetooth hardware is not ready, whether to prompt popup or not
 * RETURNS
 *  MMI_BOOL            TRUE : Bluetooth hardware is ready
 *                       FALSE : Bluetooth hardware is not ready
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_hw_ready(MMI_BOOL is_popup);

/*****************************************************************************
 * <GROUP query function>
 * FUNCTION
 *  mmi_bt_is_doing_far_end_loopback_test
 * DESCRIPTION
 *  This function is to check if bt is doing far end LP test
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL    TRUE : bt is doing far end LP test
 *               FALSE : bt is not doing far end LP test
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_doing_far_end_loopback_test(void);

extern MMI_BOOL mmi_bt_is_message_access_profile_supported(void);

extern MMI_BOOL mmi_bt_is_call_supported(void);
/*****************************************************************************
 * <GROUP query function>
 * FUNCTION
 *  mmi_bt_is_power_on
 * DESCRIPTION
 *  This function is to check if Bluetooth is power on
 * PARAMETERS
 *  is_popup :        [IN]            if Bluetooth is not power on, whether to show the power on confirm
 * RETURNS
 *  MMI_BOOL        TRUE : Bluetooth is power on
 *                   FALSE : Bluetooth is not power on
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_power_on(MMI_BOOL);

/*****************************************************************************
 * <GROUP query function>
 * FUNCTION
 *  mmi_bt_is_power_on_with_power_on_confirm
 * DESCRIPTION
 *  This function is to check if Bluetooth is power on, and will popup a power on confirm
 * PARAMETERS
 *  is_popup :             [IN]            if Bluetooth is not power on, whether to show the power on confirm
 *  power_on_cb_func_ptr : [IN]     power on callback function pointer
 * RETURNS
 *  MMI_BOOL        TRUE : Bluetooth is power on
 *                   FALSE : Bluetooth is not power on
*****************************************************************************/
extern MMI_BOOL mmi_bt_is_power_on_with_power_on_confirm(MMI_BOOL is_popup, void (*power_on_cb_func_ptr) (MMI_BOOL));

/*****************************************************************************
 * <GROUP query function>
 * FUNCTION
 *  mmi_bt_is_permission
 * DESCRIPTION
 *  This function is check whether CM is ready to do the operations
 *  CM will block operations if 
 *     1. hw not ready
 *     2. it's pairing or bonding
 *     3. it's connecting or disconnecting
 *     4. it's doing inquiry
 *     5. it's switching off
 * PARAMETERS
 *  is_popup : [IN]      TRUE : to show the popup
 *                    FALSE : not to show the popup 
 * RETURNS
 *  MMI_BOOL        TRUE : Bluetooth CM is permissible to do the operations
 *                   FALSE : otherwise
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_permission(MMI_BOOL is_popup);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_is_to_display_bt_menu
 * DESCRIPTION
 *  This function is to decide to show BT menu or not
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL        TRUE : show BT menu
 *                  FALSE : don't show BT menu
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_to_display_bt_menu(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_is_bt_in_flight_mode
 * DESCRIPTION
 *  This function is to check if __MMI_BT_IN_FLIGHT_MODE__ is on and it's in flight mode now
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL        TRUE : __MMI_BT_IN_FLIGHT_MODE__ is on and it's in flight mode now
 *                  FALSE : otherwise
 *****************************************************************************/
extern MMI_BOOL mmi_bt_is_bt_in_flight_mode(void);

/*****************************************************************************
 * <GROUP hilight handler>
 * FUNCTION
 *  mmi_bt_main_hilight_handler
 * DESCRIPTION
 *  This function is Bluetooth main highiight handler 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_main_hilight_handler(void);


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_status_icon_start_blinking
 * DESCRIPTION
 *  This function is to start blinking the status icon
 * PARAMETERS
 *  profile_id :          [IN]           profile id
 *  profile_role :        [IN]           profile role, server or client
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_status_icon_start_blinking(U32 profile_id, MMI_BT_PROFILE_ROLE profile_role);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_status_icon_stop_blinking
 * DESCRIPTION
 *  This function is to stop blinking the status icon
 * PARAMETERS
 *  profile_id :         [IN]            profile id
 *  profile_role :       [IN]            profile role, server or client
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_status_icon_stop_blinking(U32 profile_id, MMI_BT_PROFILE_ROLE profile_role);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_hfp_sco_link_connect_req
 * DESCRIPTION
 *  This function is Handsfree profile SCO link connect request
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_hfp_sco_link_connect_req(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_hfp_sco_link_disconnect_req
 * DESCRIPTION
 *  This function is Handsfree SCO link disconnect request
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_hfp_sco_link_disconnect_req(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_connect_last_headset
 * DESCRIPTION
 *  This function is to connect the last headset
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_connect_last_headset(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_hfp_set_speaker_vol
 * DESCRIPTION
 *  This function is to set remote headset speaker volume
 * PARAMETERS
 *  volume_gain :     [IN] the gain shall be >= 0 and <= 15. 
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_hfp_set_speaker_vol(U32 volume_gain);


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_get_active_signal_connection_id
 * DESCRIPTION
 *  This function is to get signal connection id
 *  It will use the profile id to check the connection table to find out the connection id 
 * PARAMETERS
 *  profile_uuid :       [IN]            profile id
 * RETURNS
 *  S32         connction id
 *****************************************************************************/
extern S32 mmi_bt_get_active_signal_connection_id(U32 profile_uuid);


/*****************************************************************************
 * FUNCTION
 *  mmi_bt_get_interrupt_suppress_level
 * DESCRIPTION
 *  This function is to get the interrupt suppress level
 *   It can be used to block popup in some situations
 * PARAMETERS
 *  void
 * RETURNS
 *  U32   if the return value is zero, it means that BT modules donot need to suppress any popup screens
 *          if the return value is non-zero, BT modules shall use following bit mask definition to suppress different popup screens
 *  MMI_FRM_INT_BT_LEVEL_1 means to suppress the general popup, ex: dis/connected, file received ... 
 *  MMI_FRM_INT_BT_LEVEL_2 means to supperss error notification, ex: disk full ...
 *  MMI_FRM_INT_BT_LEVEL_3 means to supperss confirmation screen, ex: OPPS, FTPS, HID connect accept confirmation screen ...
 *****************************************************************************/
extern U32 mmi_bt_get_interrupt_suppress_level(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_panic_ind_pre_process
 * DESCRIPTION
 *  This function is to pre process of panic indication
 *   It will invoke mmi_profiles_bt_reset()
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_panic_ind_pre_process(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_panic_ind_post_process
 * DESCRIPTION
 *  This function is post process on panic indication
 *   It will stop all timer, re-init all profiles, and update status icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_panic_ind_post_process(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_sco_far_end_loopback_test
 * DESCRIPTION
 *  This function is to do far end loopback test
 * PARAMETERS
 *  lap :             [IN]        bluetooth address
 *  uap :             [IN]        bluetooth address
 *  nap :             [IN]        bluetooth address
 *  pin_code :        [IN]        pin code of remote bt headset, max number of PIN is 16 digits
 *  size_of_pin :     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_sco_far_end_loopback_test(
                U32 lap,
                U8 uap,
                U16 nap,
                U8 *pin_code /* ascii encoding */ ,
                U8 size_of_pin);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_sco_far_end_loopback_cancel_test
 * DESCRIPTION
 *  This function is to do far end loopback cancel test
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_sco_far_end_loopback_cancel_test(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_reject_passkey_ind
 * DESCRIPTION
 *  This function is reject passkey indication, and also reject pair request
 * PARAMETERS
 *  lap :                 [IN]        BD address
 *  uap :                 [IN]        BD address
 *  nap :                 [IN]        BD address
 * RETURNS
 *  MMI_BOOL        TRUE : there is PIN INPUT screen
 *                   FALSE : otherwise
 *****************************************************************************/
extern MMI_BOOL mmi_bt_reject_passkey_ind(U32 lap, U8 uap, U16 nap);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_popup_operation_not_allowed
 * DESCRIPTION
 *  to popup operation not allowed information
 *   It will show STR_BT_OPERATION_NOT_ALLOWED_DIS_HFP_FIRST to notify user
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_popup_operation_not_allowed(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_popup_prohibited_by_simap
 * DESCRIPTION
 *  to popup operation not allowed information
 *   It will show STR_BT_PROHIBIT_BY_SIMAP to notify user
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_popup_prohibited_by_simap(void);
#ifdef __MMI_BT_AUTHORIZE__

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_popup_prohibited_by_blocked_device
 * DESCRIPTION
 *  before initiating the outgoing connection(FTPC, OPPC, HID, BIP-I, BPP), check if this device is blocked or not
 *  If device is blocked, then invoke this function to popup information to end user.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_popup_prohibited_by_blocked_device(void);
#endif /* __MMI_BT_AUTHORIZE__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_enable_pts_test
 * DESCRIPTION
 *  to enable the global variable to indicate that pts testing is active
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_enable_pts_test(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_disable_pts_test
 * DESCRIPTION
 *  to disable the global variable to indicate that pts testing is off
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_disable_pts_test(void);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_register_power_on_callback
 * DESCRIPTION
 *  This function is register the callback. CM will invoke the callback while finished switching power to be ON. 
 * PARAMETERS
 *  power_on_cb_func_ptr :    [IN] Application's callback.
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_register_power_on_callback(void (*power_on_cb_func_ptr) (void));

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_register_power_on_callback_with_result
 * DESCRIPTION
 *  This function is register the callback. CM will invoke the callback while finished power switching. 
 * PARAMETERS
 *  power_on_cb_func_ptr  :    [IN] Application's callback. 
 *                            TRUE means switching power to be ON successfuly.
 *                            FALSE means switching power failed.
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_register_power_on_callback_with_result(void (*power_on_cb_func_ptr) (MMI_BOOL));

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_suppress_popup
 * DESCRIPTION
 *  This function is to set the interrupt suppress level
 *  Other applications can use this function to suppress the popup if they don't want to be interrupted
 * PARAMETERS
 *  suppress_switch :  [IN] MMI_TRUE means to enable the BT popup suppression 
 *                    MMI_FALSE means to disable the BT popup suppression
 *  suppress_level :  [IN] if suppress_switch is MMI_TRUE, suppress_level is the bitmask with following bits.
 *                  if suppress_switch is MMI_FALSE, suppress_level shall be NULL(zero)
 *                  MMI_FRM_INT_BT_LEVEL_1 means to suppress the general popup, ex: dis/connected, file received ... 
 *                  MMI_FRM_INT_BT_LEVEL_2 means to supperss error notification, ex: disk full ...
 *                  MMI_FRM_INT_BT_LEVEL_3 means to supperss confirmation screen, ex: OPPS, FTPS, HID connect accept confirmation screen ...
 *                  
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_suppress_popup(MMI_BOOL suppress_switch, U32 supress_level);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_suppress_profile_popup
 * DESCRIPTION
 *  This function is to set the interrupt suppress popup for specific profile
 * PARAMETERS
 *  suppress_switch  MMI_TRUE means to enable the BT popup suppression 
 *                  MMI_FALSE means to disable the BT popup suppression
 *  profile_id  profile UUID
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_suppress_profile_popup(U32 profile_id, MMI_BOOL suppress_switch);


#ifdef __MMI_BT_AUTO_POWER_SWITCH__

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_auto_on
 * DESCRIPTION
 *  This function is to power on Bluetooth automatically
 * PARAMETERS
 *  profile_id :        [IN] to indicate that which profile needs to auto power on BT. And CM cannot power off BT before this profile invokes mmi_bt_auto_off
 *                         although other profile wants to auto power off BT. So profiles shall invoke mmi_bt_auto_on and mmi_bt_auto_off paired.
 * RETURNS
 *  MMI_BOOL TRUE: continue to power on BT automatically
 *             FALSE: not allow to do auto power on now. Will display "Not Allowed".
 *****************************************************************************/
extern MMI_BOOL mmi_bt_auto_on(U32 profile_id, mmi_id parent_gid);

/*****************************************************************************
 * FUNCTION
 *  mmi_bt_auto_off
 * DESCRIPTION
 *  This function is to power off Bluetooth automatically
 * PARAMETERS
 *  profile_id :        [IN] to indicate that which profile needs to auto power of BT. And CM cannot power off BT before this profile invokes mmi_bt_auto_off
 *                         although other profile wants to auto power off BT. So profiles shall invoke mmi_bt_auto_on and mmi_bt_auto_off paired.
 * RETURNS
 *  MMI_BOOL TRUE: continue to power off BT automatically
 *             FALSE: not allow to do auto power off now. CM will retry later.
 *****************************************************************************/
extern MMI_BOOL mmi_bt_auto_off(U32 profile_id);
#endif /*__MMI_BT_AUTO_POWER_SWITCH__*/


/*****************************************************************************
* FUNCTION
 *  mmi_bt_power_on_bt
 * DESCRIPTION
 *  This function is to turn on BT without showing progressing screen and popup
 * PARAMETERS
 *  power_on_cb_func_ptr    [IN]    power on callback
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_power_on_bt(void (*power_on_cb_func_ptr) (MMI_BOOL));


/*****************************************************************************
* FUNCTION
 *  mmi_bt_power_off_bt
 * DESCRIPTION
 *  This function is to turn off BT without showing progressing screen and popup
 * PARAMETERS
 *  power_off_cb_func_ptr   [IN]    power off callback
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_power_off_bt(void (*power_off_cb_func_ptr) (MMI_BOOL));


/*****************************************************************************
* FUNCTION
 *  mmi_bt_entry_mydev_menu_by_shell
 * DESCRIPTION
 *  This function is to turn off BT without showing progressing screen and popup
 * PARAMETERS
 *  power_off_cb_func_ptr   [IN]    power off callback
 * RETURNS
 *  void
 *****************************************************************************/
extern void mmi_bt_entry_mydev_menu_by_shell(void);


/*****************************************************************************
* FUNCTION
 *  mmi_bt_get_popup_string
 * DESCRIPTION
 *  This function is to return string which shell popup used
 * PARAMETERS
 *  void
 * RETURNS
 *  U16 string_id
 *****************************************************************************/
extern U16 mmi_bt_get_popup_string(void);

/*****************************************************************************
* FUNCTION
 *  mmi_bt_authorize_ind_notify
 * DESCRIPTION
 *  This function is to let cm display authorize screen
 * PARAMETERS
 *  U8* dev_name  [IN]
 *  srv_bt_cm_bt_addr *dev_addr     [IN]
 *  U32 profile_id,             [IN]
 *  void *func_ptr          [IN]  type mmi_bt_authorize_callback
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_authorize_ind_notify(U8* dev_name,
    srv_bt_cm_bt_addr *dev_addr,
    U32 profile_id,
    void *callback);

/*****************************************************************************
* FUNCTION
 *  mmi_bt_authorize_screen_close
 * DESCRIPTION
 *  This function is to when profile disconnected, but cm also display authorize screen, so should notify cm to close it
 * PARAMETERS
 *  U32 profile_id,             [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_bt_authorize_screen_close(U32 profile_id);


MMI_BOOL mmi_bt_switch_voice_path_incall(MMI_BOOL is_on);
extern void mmi_bt_show_progress_scr(mmi_id group_id, U16 scrid, U16 title, U16 context_id, FuncPtr fp);
extern void mmi_bt_popup_display(U16 string_id, U32 event, mmi_id group_id);
#endif /* __BT_MMI_SCR_GPROTS_H__ */ 


/*------------------------------------------------------------*/
/*-------------------end--------------------------------------*/
/*------------------------------------------------------------*/

