/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
* 
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * 
 *
 * Project:
 * --------
 *   MMI
 *
 * Description:
 * ------------
 *   
 *
 * Author:
 * -------
 * 
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include "MMI_features.h"

#ifdef __MMI_USB_SUPPORT__

    
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "mmi_frm_queue_gprot.h"
#include "app_ltlcom.h"
#include "stack_config.h"
#include "stack_msgs.h"
#include "nvram_data_items.h"
#include "mmi_frm_nvram_gprot.h"
//#include "l4c_common_enum.h"
#include "ps_public_enum.h"
#include "mmi_frm_events_gprot.h"
#include "string.h"
#include "mmi_cb_mgr_gprot.h"
#include "MMI_common_app_trc.h"
#include "DebugInitDef_Int.h"
#include "kal_trace.h"
#include "mmi_common_app_trc.h"
#include "mmi_frm_mem_gprot.h"
#include "kal_public_api.h"
#include "mmi_msg_struct.h"
#include "custom_mmi_default_value.h"
#include "mmiapi_dm_struct.h"
#include "mmi_res_range_def.h"
#include "mmi_frm_timer_gprot.h"
#include "TimerEvents.h"
#include "Unicodexdcl.h"
#include "uart_sw.h"
#include "ShutdownSrvGprot.h"
#include "ProtocolEvents.h"
#include "device.h"
#include "gpiosrvgprot.h"

#if defined(__DM_LAWMO_SUPPORT__)
#include "DmuiGprot.h"
#endif
#if defined(__J2ME__) && defined(__USB_COM_PORT_ENABLE__)
#include "Jvm_interface.h"
#endif

#include "usb_mode.h"
#include "BootupSrvGprot.h"
#include "AlarmFrameworkProt.h"
//#include "usb_dummy.h"
#ifdef __MMI_TETHERING__
#include "TetheringSrvGProt.h"
#endif
#include "mmi_rp_app_usbsrv_def.h"
#include "USBSrvIprot.h"
#include "usbsrvgprot.h"
#include "usbsrvprot.h"

SRV_USB_CONTEXT g_srv_usb_cntx;
SRV_USB_CONTEXT *srv_usb_ptr = &g_srv_usb_cntx;

/* USB split revise*/
static U8 g_usb_cfg_pre_check_pass;
static U8 g_usb_blocked_enter_ms;
static U8 g_usb_blocked_exit_ms;
//static U8 g_usb_wait_do_exit_ms;
//static MMI_BOOL g_usb_config_result = MMI_TRUE;
static MMI_BOOL g_usb_is_ms_exit_done; /* 0:default, 1: exit down */

#if defined(__DM_LAWMO_SUPPORT__)
MMI_BOOL g_srv_usb_dmui_lock_process; /* 0:default, 1: dm lock */

typedef void (*dm_event_cb)(MMI_BOOL, const CHAR*);
static dm_event_cb g_srv_usb_dmui_lock_cb;
static void srv_usb_dmui_lock_process_finished(void);
#endif

static void srv_usb_unblock_config_rsp_timer_hdlr(void);

static void srv_usb_post_mmi_notify(srv_usb_mmi_notify_action_enum act);
static void srv_usb_emit_mmi_notify(srv_usb_mmi_notify_action_enum act);

static void srv_usb_start_config_ms(void);

static void srv_usb_config_cdcacm(void);
static void srv_usb_pending_detection_hdlr(void);
//static void srv_usb_exit_ms_proc(void);

static MMI_BOOL srv_usb_config_pre_check(void);
static void srv_usb_send_removal_event_req(void);
static void srv_usb_send_removal_event_rsp(void);
static void srv_usb_stop_pending_detection(void);
static void srv_usb_start_pending_timer(void);
static void srv_usb_plug_in_before_power_on(void);
static void srv_usb_get_uart_rsp_hdlr(void *inMsg);
static MMI_BOOL srv_usb_alm_shown(void);

#if defined(__DM_LAWMO_SUPPORT__)
static MMI_BOOL srv_usb_report_dmui_result(void);
#endif

MMI_BOOL srv_usb_is_ms_exit_done(void)
{
    return g_usb_is_ms_exit_done;
}
/*****************************************************************************
 * FUNCTION
 *  srv_usb_send_msg_to_hw
 * DESCRIPTION
 *  This function is to send message to PS
 *  
 *  PARAMETERS: void
 *  msg_id              [IN]        
 *  local_param_ptr     [?]         
 *  peer_buf_ptr        [?]         
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
static void srv_usb_send_msg_to_hw(U16 msg_id, void *local_param_ptr, void *peer_buf_ptr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 source_id = MOD_L4C;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(MMI_MAX_SIM_NUM) && (MMI_MAX_SIM_NUM > 1)
    if (msg_id == PRT_EQ_USBUART_SWITCH_PORT_REQ)
    {
        U8   buffer[NVRAM_EF_SYS_CACHE_OCTET_SIZE];
        //S32 count;
    
        ReadRecordSlim(NVRAM_EF_SYS_CACHE_OCTET_LID,
               NVRAM_SYS_FLIGHTMODE_STATE, 
               (void*)buffer, 
               NVRAM_EF_SYS_CACHE_OCTET_SIZE);

        switch(buffer[L4C_SETTING_DUAL_SIM_UART])
        {
            case RMMI_UART_TO_SIM1:
                source_id = MOD_L4C;
                break;
        #if (MMI_MAX_SIM_NUM >= 2)
            case RMMI_UART_TO_SIM2:
                source_id = MOD_L4C_2;
                break;
        #endif
        #if (MMI_MAX_SIM_NUM >= 3)
            case RMMI_UART_TO_SIM3:
                source_id = MOD_L4C_3;
                break;
        #endif
        #if (MMI_MAX_SIM_NUM >= 4)
            case RMMI_UART_TO_SIM4:
                source_id = MOD_L4C_4;
                break;
        #endif
            default:
                source_id = MOD_L4C;
                break;
        }

/*
        count = buffer[L4C_SETTING_DUAL_SIM_UART] - RMMI__UART_TO_SIM1;
        if (count < MMI_MAX_SIM_NUM)
            source_id = MOD_L4C + count;
*/
    }
#endif /* #if (MMI_MAX_SIM_NUM > 1)*/    
      
    mmi_frm_send_ilm((oslModuleType) source_id, (oslMsgType)msg_id, 
                        (oslParaType*)local_param_ptr, (oslPeerBuffType*)peer_buf_ptr);

}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_usb_emit_event
 * DESCRIPTION
 *  emit GPIO event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_usb_emit_event(U16 event_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_struct evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, event_id);
    return mmi_frm_cb_emit_event(&evt);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_block_event
 * DESCRIPTION
 *  This function is to block usb event.
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *****************************************************************************/
void srv_usb_block_event(U16 event_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_BLOCK_EVENT, event_id, g_usb_blocked_enter_ms, g_usb_blocked_exit_ms);
	
	switch (event_id)
	{
	/* USB split revise*/
	    case EVT_ID_USB_PERMIT_CFG_PRE_CHECK:
	        g_usb_cfg_pre_check_pass = 0;
	        break;
	        
	    case EVT_ID_USB_PERMIT_CFG:
            srv_usb_pending_detection_hdlr();
            break;
            
        case EVT_ID_USB_ENTER_MS_MODE:
            g_usb_blocked_enter_ms ++;
            break;
            
        case EVT_ID_USB_EXIT_MS_MODE:
            g_usb_blocked_exit_ms ++;
            break;
                
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_unblock_event
 * DESCRIPTION
 *  This function is to unblock usb event.
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *****************************************************************************/
void srv_usb_unblock_event(U16 event_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_bootup_mode_enum mode = srv_bootup_get_booting_mode();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_UNBLOCK_EVENT, event_id, g_usb_blocked_enter_ms, g_usb_blocked_exit_ms);
	
	switch (event_id)
	{
	    /* USB split revise*/
	    case EVT_ID_USB_PERMIT_CFG_PRE_CHECK:
	        g_usb_cfg_pre_check_pass = 1;
	        break;
	        
	    case EVT_ID_USB_PERMIT_CFG:
	        srv_usb_stop_pending_detection();
	        if (mode == SRV_BOOTUP_MODE_USB ||
        	  mode == SRV_BOOTUP_MODE_CHARGE ||
        	  mode == SRV_BOOTUP_MODE_PRECHARGE)
        	{
    	        if (srv_usb_get_status() == SRV_USBSTATUS_PLUGIN)
    	        {
                    srv_usb_emit_event(EVT_ID_USB_PLUG_IN);
                }
            }
            else
            {
              srv_usb_emit_event(EVT_ID_USB_PLUG_IN);
            }
            break;
            
        case EVT_ID_USB_ENTER_MS_MODE:
            if (g_usb_blocked_enter_ms == 0)
                break;

            g_usb_blocked_enter_ms --;

            if (g_usb_blocked_enter_ms == 0)
            {
                /* this is for when ms mode handler finish, user have plug out USB */
                if(!srv_usb_is_connected())
                {
                    //srv_usb_exit_ms_proc();
                    srv_usb_send_removal_event_req();
                }
                else
                {	
                    srv_usb_start_config_ms();
                }				
            }
            break;
            
        case EVT_ID_USB_EXIT_MS_MODE:
            if (g_usb_blocked_exit_ms == 0)
                break;

            g_usb_blocked_exit_ms --;
            if (g_usb_blocked_exit_ms == 0)
            {
            	srv_usb_send_removal_event_rsp();
            }
            break;
                
        case EVT_ID_USB_CONFIG_RSP:
            StartTimer(USB_SHUTDOWN_SCR_TIMER, 0, srv_usb_unblock_config_rsp_timer_hdlr);
            break;
            
        default:
            break;
    }
}

static void srv_usb_unblock_config_rsp_timer_hdlr(void)
{
    srv_usb_post_mmi_notify(SRV_USB_MMI_NOTIFY_CFG_END);
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_construct_config_result
 * DESCRIPTION
 *  construct config result
 *  
 *  PARAMETERS: void
 *  info        [?]     
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_emit_config_result(U8 mode, MMI_BOOL suc)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    mmi_event_struct evt;
    srv_usb_config_result_struct result;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result.mode = mode;
    result.suc = suc;
    
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_USB_CONFIG_RSP);
    evt.user_data = &result;

    mmi_frm_cb_emit_event(&evt);
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_construct_config_result
 * DESCRIPTION
 *  construct config result
 *  
 *  PARAMETERS: void
 *  info        [?]     
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_emit_mmi_notify(srv_usb_mmi_notify_action_enum act)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
   	mmi_event_struct evt;
   	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_USB_MMI_NOTIFY);	
    evt.user_data = (void*)act;
    mmi_frm_cb_emit_event(&evt);
}

void srv_usb_post_mmi_notify(srv_usb_mmi_notify_action_enum act)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    mmi_event_struct evt;
   	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_USB_MMI_NOTIFY);	
    evt.user_data = (void*)act;

    mmi_frm_cb_emit_post_event(&evt);
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_config_rsp_fail
 * DESCRIPTION
 *  This is usb config response handler
 *  
 *  PARAMETERS: void
 *  info        [?]     
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_config_rsp_fail(U8 mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(mode)
    {
        case DEVUSB_CFG_ACTION_CDC_ACM:
        case DEVUSB_CFG_ACTION_MULTI_COM:
            if (SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT))
            {
                srv_usb_set_status(SRV_USBSTATUS_PLUGIN);
            }
            else
            {
                srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            }
            srv_usb_emit_config_result(mode, MMI_FALSE);
            return;

        case DEVUSB_CFG_ACTION_WEBCAM:
            srv_usb_emit_config_result(mode, MMI_FALSE);
            return;

        default:
            break;
    }
    
#ifdef __USB_IN_NORMAL_MODE__

    /* Config error or USB device pluged out, drv will be reset so stop further processing */
    if (SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT))
    {
        srv_usb_ptr->ms_config_result = MMI_FALSE;
        srv_usb_set_status(SRV_USBSTATUS_MS);   
        srv_usb_send_removal_event_req();
    }
    else
    {
        if (mode == DEVUSB_CFG_ACTION_MASS_STORAGE 
            #ifdef __MTP_ENABLE__
            || mode == DEVUSB_CFG_ACTION_MTP
            #endif
            )
        {                    
            srv_usb_set_status(SRV_USBSTATUS_MS);
            srv_usb_send_removal_event_req();
        }
        else
        {
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            srv_usb_emit_config_result(mode, MMI_FALSE);
        }
    }
#else

    if (!SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT))
    {
        srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
    }
    srv_usb_emit_config_result(mode, MMI_FALSE);
    
#endif
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_config_rsp_hdlr
 * DESCRIPTION
 *  This is usb config response handler
 *  
 *  PARAMETERS: void
 *  info        [?]     
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_config_rsp_hdlr(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_usbconfig_rsp_struct *p_usbcfg_struct = (mmi_eq_usbconfig_rsp_struct*) info;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_CONF_RSP_HDLR);
 
    if (p_usbcfg_struct->result != KAL_TRUE)
    {    
        srv_usb_config_rsp_fail(p_usbcfg_struct->mode);
        return;
    }

    switch (p_usbcfg_struct->mode)
    {
        case DEVUSB_CFG_ACTION_MASS_STORAGE:
    #ifdef __MTP_ENABLE__			
        case DEVUSB_CFG_ACTION_MTP:
    #endif    
    #if defined(__DM_LAWMO_SUPPORT__)       	
        if (g_srv_usb_dmui_lock_process)
        {
            /* Exit MS mode, because DM notify comes after deinit done,so exit here */
            srv_usb_stop_config_ms();
            return;
        }
    #endif
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
        {
            srv_usb_set_status(SRV_USBSTATUS_MS);
        }
        break;

        case DEVUSB_CFG_ACTION_CDC_ACM /* USB_CDC_ACM */ :
    #ifdef __MMI_USB_MULTIPLE_COMPORT_SUPPORT__
        case DEVUSB_CFG_ACTION_MULTI_COM:
    #endif
            if (srv_usb_ptr->owner == SRV_USB_COMPORT_PS)
            {
               /* need to config cdcacm response to emit config result to MMI */
                srv_usb_config_cdcacm();
                return;
            }
        #if defined(__J2ME__) && defined(__USB_COM_PORT_ENABLE__)
            else if (srv_usb_ptr->owner == SRV_USB_COMPORT_JAVA)
            {                            
                jvm_comm_usb_in_java_register_cb(MMI_TRUE);
                srv_usb_set_status(SRV_USBSTATUS_JAVA_CONNECT);
            }
        #endif
            else
            {
                MMI_ASSERT(0);
            }				
            break;
        
        case DEVUSB_CFG_ACTION_STOP_MS /* USB_STOP_MS */ :
    #ifdef __MTP_ENABLE__
	 case DEVUSB_CFG_ACTION_STOP_MTP /* USB_STOP_MTP */ :
    #endif			

        #if defined(__DM_LAWMO_SUPPORT__)       	
            if (g_srv_usb_dmui_lock_process==MMI_TRUE)
            {
                srv_usb_send_removal_event_req();       	        
            }
        #endif
            break;
	
       default:
            break;
    }

    
	srv_usb_emit_config_result(p_usbcfg_struct->mode, p_usbcfg_struct->result);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_send_config_to_hw
 * DESCRIPTION
 *  This function is to send usb config request to PS
 *  
 *  PARAMETERS: mode, ms or cdcacm
 *  mode        [IN]        
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_send_config_to_hw(U8 mode)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    mmi_eq_usbconfig_req_struct *p_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    p_param = OslConstructDataPtr(sizeof(mmi_eq_usbconfig_req_struct));
    p_param->mode = mode;
    p_param->reserved = 0;

    SetProtocolEventHandler(srv_usb_config_rsp_hdlr, MSG_ID_MMI_EQ_USBCONFIG_RSP);
    srv_usb_send_msg_to_hw(MSG_ID_MMI_EQ_USBCONFIG_REQ, (void*)p_param, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_set_before_power_on_flag
 * DESCRIPTION
 *  This function is to set usb plug in/out flag before power on.
 *  (The usb detection indication might come to mmi before power on indication)
 *  
 *  PARAMETERS: void
 *  flag        [IN]        
 *  RETURNS: enum srv_usb_status_enum(?)
 *****************************************************************************/
void srv_usb_set_before_power_on_flag(BOOL flag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (flag == MMI_TRUE)
    {
        SRVUSB_SET_FLAG(SRVUSB_MASK_BEFORE_POWERON);
    }
    else
    {
        SRVUSB_RESET_FLAG(SRVUSB_MASK_BEFORE_POWERON);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_uart_switch_rsp_hdlr
 * DESCRIPTION
 *  This is uart switch port response handler
 *  
 *  PARAMETERS: void
 *  info        [?]     
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_uart_switch_rsp_hdlr(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_usbuart_switch_port_rsp_struct *rsp_p = info;
    srv_usb_status_enum usb_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_UART_SWITCH_RSP_HDLE);

    usb_state = srv_usb_get_status();

    if (rsp_p->result)
    {    
        if (usb_state != SRV_USBSTATUS_PLUGOUT &&
             usb_state != SRV_USBSTATUS_WEBCAM)
        {
            /* Finish CDCACM config and port switch, change state */
            srv_usb_set_status(SRV_USBSTATUS_CDCACM);
        }
    }
    srv_usb_emit_config_result(DEVUSB_CFG_ACTION_CDC_ACM, rsp_p->result);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_config_cdcacm
 * DESCRIPTION
 *  This fucntion is cdcacm following action after usb conigure response comes,
 *  (MSG_ID_MMI_EQ_USBCONFIG_RSP)
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
static void srv_usb_config_cdcacm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_usbuart_switch_port_req_struct *p_param;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_CONF_CDCACM);
	
    p_param = OslConstructDataPtr(sizeof(mmi_eq_usbuart_switch_port_req_struct));
    p_param->app = USB_SWITCH_PORT_APP_DATA;

    SetProtocolEventHandler(srv_usb_uart_switch_rsp_hdlr, PRT_EQ_USBUART_SWITCH_PORT_RSP);
    srv_usb_send_msg_to_hw(PRT_EQ_USBUART_SWITCH_PORT_REQ, (void*)p_param, (void*)NULL);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_stop_config_ms
 * DESCRIPTION
 *  stop usb config mass storage
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_usb_stop_config_ms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
#ifdef __MTP_ENABLE__
   if (srv_usb_ptr->owner == SRV_USB_MS_STORAGE_MTP)
   {
        srv_usb_send_config_to_hw(DEVUSB_CFG_ACTION_STOP_MTP);
   }
   else
#endif
   {
        srv_usb_send_config_to_hw(DEVUSB_CFG_ACTION_STOP_MS);
   }        
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_start_config_ms
 * DESCRIPTION
 *  start usb config mass storage
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_usb_start_config_ms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_SRV_USB_START_CONFIG_MS);
    
    /* USB split revise*/
#if defined(__DM_LAWMO_SUPPORT__)
     if (srv_usb_report_dmui_result())
        return;
#endif

#ifdef __MTP_ENABLE__
    if (srv_usb_ptr->owner == SRV_USB_MS_STORAGE_MTP)
    {   
        srv_usb_send_config_to_hw(DEVUSB_CFG_ACTION_MTP);   
    }
    else
#endif
    {
        srv_usb_send_config_to_hw(DEVUSB_CFG_ACTION_MASS_STORAGE);
    }        
}

#ifdef __USB_IN_NORMAL_MODE__
/*****************************************************************************
 * FUNCTION
 *  srv_usb_is_leaving_ms_mode
 * DESCRIPTION
 *  Get the USB status
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL srv_usb_is_leaving_ms_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((SRV_USB_CTX(usb_status_prev) == SRV_USBSTATUS_MS && SRV_USB_CTX(usb_status) == SRV_USBSTATUS_MS_PROC) ||
        (!SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT) && SRV_USB_CTX(usb_status) == SRV_USBSTATUS_MS_PROC) ||(SRV_USB_CTX(usb_status) == SRV_USBSTATUS_EXIT_MS_PROC))
        
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif

/*****************************************************************************
 * FUNCTION
 *  UsbCfgMSTimeoutHdlr
 * DESCRIPTION
 *  This fucntion is mass storage following action after usb conigure response comes,
 *  (MSG_ID_MMI_EQ_USBCONFIG_RSP) and the screen timer expire
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_ms_shutdown_timeout_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_bootup_get_booting_mode() != SRV_BOOTUP_MODE_NORMAL && 
        !srv_bootup_is_exception_mode())
    {
        srv_reminder_deinit();
        srv_usb_send_msg_to_hw(PRT_POWER_OFF_REQ, NULL, NULL);
    }
    else
    {
        srv_shutdown_normal_start(APP_USBSRV);
    }
}


/*****************************************************************************
 * FUNCTION
 *  UsbConfigMassStorage
 * DESCRIPTION
 *  This fucntion is mass storage following action after usb conigure response comes,
 *  (MSG_ID_MMI_EQ_USBCONFIG_RSP)
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_start_ms_shutdown(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_CONF_MS);
    srv_usb_ms_shutdown_timeout_hdlr();
}

static void srv_usb_start_config_state(void)
{
    srv_usb_emit_event((U16)EVT_ID_USB_PERMIT_CFG);
}

static MMI_BOOL srv_usb_config_pre_check(void)
{
    srv_usb_emit_event(EVT_ID_USB_PERMIT_CFG_PRE_CHECK);
    return (MMI_BOOL)g_usb_cfg_pre_check_pass;
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_pending_detection_timeout_hdlr
 * DESCRIPTION
 *  This function try to display usb config screen if usb device still there.
 *  If could not display, will wait a period of time and retry again.
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_pending_detection_timeout_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_usb_status_enum usb_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_PEND_DETECT_TIMEOUT);

    StopTimer(PENDING_USBDETECTION_HDLR_TIMER);
    usb_state = srv_usb_get_status();

    if (usb_state == SRV_USBSTATUS_PLUGIN ||
         (usb_state == SRV_USBSTATUS_PLUGOUT && SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT)))
    {
    	//MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_PENDING_TIMEOUT_HDLR_PLUG_IN);
    	MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_STATE_TRANSITION, SRV_USB_CTX(usb_status_prev), SRV_USB_CTX(usb_status));
    	
        if (!srv_usb_config_pre_check())
        {
            SRVUSB_SET_FLAG(SRVUSB_MASK_PENDING_TIMER);
            srv_usb_start_pending_timer();
        }
        else
        {
            SRVUSB_RESET_FLAG(SRVUSB_MASK_PENDING_TIMER);
            srv_usb_set_status(SRV_USBSTATUS_PLUGIN);
            srv_usb_start_config_state();
        }
    }
#ifdef __USB_IN_NORMAL_MODE__
    else if (srv_usb_is_leaving_ms_mode())
    {
        MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_STATE_TRANSITION, SRV_USB_CTX(usb_status_prev), SRV_USB_CTX(usb_status));
        srv_usb_start_pending_timer();
    }
#endif
}



/*****************************************************************************
 * FUNCTION
 *  PendingUsbDetectionHdlr
 * DESCRIPTION
 *  This function is to handle panding usb detection event. When usb detected
 *  at critical time and is not allow to display config screen, the detected event
 *  will be pending. After the time over, shall call this to deal with the pending
 *  event. This will start a timer then show config screen to prevent screen overlap
 *  case by function call.
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
static void srv_usb_pending_detection_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_usb_status_enum usb_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_START_TIMER);

    usb_state = srv_usb_get_status();

    switch (usb_state)
    {
        case SRV_USBSTATUS_PLUGIN:    
        case SRV_USBSTATUS_MS_PROC:    
        {
            MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_START_PEND_TIMEER);

            SRVUSB_SET_FLAG(SRVUSB_MASK_PENDING_TIMER);
            srv_usb_start_pending_timer();
            break;
        }
        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_stop_pending_detection
 * DESCRIPTION
 *  This function is to handle panding usb detection event. When usb detected
 *  at critical time and is not allow to display config screen, the detected event
 *  will be pending. After the time over, shall call this to deal with the pending
 *  event. This will start a timer then show config screen to prevent screen overlap
 *  case by function call.
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
static void srv_usb_stop_pending_detection(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (SRVUSB_GET_FLAG(SRVUSB_MASK_PENDING_TIMER))
    {
        SRVUSB_RESET_FLAG(SRVUSB_MASK_PENDING_TIMER);
        StopTimer(PENDING_USBDETECTION_HDLR_TIMER);
    }
}



/*****************************************************************************
 * FUNCTION
 *  srv_usb_handle_plug_in
 * DESCRIPTION
 *  This function is usb plug in
 *  
 *  PARAMETERS: 
 *  void
 *  RETURNS:
 *  void 
 *****************************************************************************/
void srv_usb_handle_plug_in(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_usb_status_enum usb_state = srv_usb_get_status();
    srv_bootup_mode_enum mode = srv_bootup_get_booting_mode();
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/* USB split revise*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_DETECT_SCR_PLUGIN, usb_state);

    SRVUSB_SET_FLAG(SRVUSB_MASK_IS_CONNECT);

    /* It is before system bootup, wait*/
    if (( (!srv_bootup_is_launched() || srv_bootup_is_booting()) &&
         mode == SRV_BOOTUP_MODE_NORMAL) ||
         mode == SRV_BOOTUP_MODE_INVALID)
    {
        srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);
        srv_usb_plug_in_before_power_on();
        return;
    }
    else if (srv_shutdown_is_running())
    {
        return;
    }
        
    switch (usb_state)
    {
        case SRV_USBSTATUS_UNKNOW:
            srv_usb_plug_in_before_power_on();
            break;

        case SRV_USBSTATUS_USBTETHERING:
        case SRV_USBSTATUS_EXIT_MS_PROC:
        case SRV_USBSTATUS_PLUGOUT:
        {
            if ((mode == SRV_BOOTUP_MODE_PRECHARGE ||
                mode == SRV_BOOTUP_MODE_CHARGE) &&
                !srv_reminder_is_reminder_active())
            {
                srv_usb_send_msg_to_hw(MSG_ID_MMI_EQ_POWER_OFF_REQ, (void*)NULL, (void*)NULL);
                break;
            }

            srv_usb_set_status(SRV_USBSTATUS_PLUGIN);
        #ifdef __MMI_TETHERING__
            //if (srv_tethering_is_off(SRV_TETHERING_TYPE_USB))
        #endif
            {
                srv_usb_start_config_state();
            }
        }
        break;

        case SRV_USBSTATUS_MS_PROC:
            srv_usb_pending_detection_hdlr();        
            break;

        case SRV_USBSTATUS_MS:
        case SRV_USBSTATUS_WEBCAM:
            break;
        
        default:
            MMI_ASSERT(0);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_exit_ms_proc
 * DESCRIPTION
 *  usb want to exit ms state
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __USB_IN_NORMAL_MODE__
void srv_usb_enter_ms_proc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_APP_DEINIT_PERFORM);

    srv_usb_emit_event(EVT_ID_USB_ENTER_MS_MODE);	
                        
    if (g_usb_blocked_enter_ms == 0)
    {
        srv_usb_start_config_ms();
    }
}
#endif

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifdef __USB_IN_NORMAL_MODE__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else /* __USB_IN_NORMAL_MODE__*/
#endif /* __USB_IN_NORMAL_MODE__*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_usb_handle_plug_out
 * DESCRIPTION
 *  This function is usb plug out
 *  
 *  PARAMETERS:
 *   void 
 *  RETURNS:
 *  void 
 *****************************************************************************/
void srv_usb_handle_plug_out(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_usb_status_enum state = srv_usb_get_status();
    srv_bootup_mode_enum boot_mode;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_DETECT_SCR_PLUGOUT, state);

    StopTimer(PENDING_USBDETECTION_HDLR_TIMER);
    SRVUSB_RESET_FLAG(SRVUSB_MASK_IS_CONNECT);

   /* if (state == SRV_USBSTATUS_PLUGOUT)
        return;
*/
    if (srv_shutdown_is_running())
    {
        return;
    }
    
    srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_PLUGOUT);    
    boot_mode = srv_bootup_get_booting_mode();
    
    if (((!srv_bootup_is_launched() || srv_bootup_is_booting()) &&
        boot_mode == SRV_BOOTUP_MODE_NORMAL) ||
        boot_mode == SRV_BOOTUP_MODE_INVALID)
    {
        srv_usb_set_before_power_on_flag(MMI_FALSE);        
        srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
        return;
    }

    switch(state)
    {
        case SRV_USBSTATUS_MS_PROC:
        case SRV_USBSTATUS_MS:
            if (boot_mode != SRV_BOOTUP_MODE_ALARM)
                srv_usb_send_removal_event_req();
            srv_usb_set_status(SRV_USBSTATUS_EXIT_MS_PROC);
            g_usb_is_ms_exit_done = MMI_FALSE;
            MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_IS_EXIT_DONE_FLAG_FALSE);
            break;

        case SRV_USBSTATUS_PLUGIN:
        case SRV_USBSTATUS_CONF_PAGE:
        case SRV_USBSTATUS_IGNORED:
            if (boot_mode == SRV_BOOTUP_MODE_USB ||
            	  boot_mode == SRV_BOOTUP_MODE_CHARGE ||
    	         boot_mode == SRV_BOOTUP_MODE_PRECHARGE)
            {
                srv_usb_send_removal_event_req();
                srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
                break;
            }
        case SRV_USBSTATUS_CDCACM:
        case SRV_USBSTATUS_CDCACM_PROC:
        case SRV_USBSTATUS_PLUGOUT:
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_CFG_LIST);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            break;
            
        case SRV_USBSTATUS_WEBCAM:
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_EXIT_WEBCAM);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            break;

#if defined(__J2ME__) && defined(__USB_COM_PORT_ENABLE__)
        case SRV_USBSTATUS_JAVA_CONNECT:
            jvm_comm_usb_in_java_register_cb(MMI_FALSE);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_CFG_LIST);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            break;
#endif

#ifdef __MMI_PICT_BRIDGE_SUPPORT__
        case SRV_USBSTATUS_PICTBRIGE:
        #ifdef MMI_ON_HARDWARE_P
            mmi_pict_dps_disconnect_ind();
        #endif
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            break;
#endif

#ifdef __MMI_TETHERING__
        case SRV_USBSTATUS_USBTETHERING:
            srv_tethering_usb_cable_disconnect_notify_hdlr();
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_CFG_LIST);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            break;
#endif

        default:
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_CFG_LIST);
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            return;
    }
}

void srv_usb_handle_ms_exit_done(void)
{  
    srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);

    srv_usb_emit_event(EVT_ID_USB_EXIT_MS_MODE);  
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_SEND_EXIT_MS_EVENT);

    g_usb_is_ms_exit_done = MMI_TRUE;
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_IS_EXIT_DONE_FLAG);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_usb_send_detect_ack
 * DESCRIPTION
 *  This function is to send usb detect ack to PS
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
static void srv_usb_send_detect_ack(devusb_detect_action_enum action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_usbdetect_res_req_struct *param_ack;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    param_ack = OslConstructDataPtr(sizeof(mmi_eq_usbdetect_res_req_struct));
    param_ack->action = action;

    srv_usb_send_msg_to_hw(MSG_ID_MMI_EQ_USBDETECT_RES_REQ, (void*)param_ack, (void*)NULL);
}
#ifdef __USB_MMI_DEBUG__


void srv_usb_ut(U8 index)
{
    switch (index)
    {
        case 0:
        {
            mmi_eq_usbdetect_ind_struct msg;
            msg.action = DEVUSB_DETECT_ACTION_PLUGIN;
            srv_usb_detect_ind_hdlr(&msg);
            break;
         }

        case 1:
        {
            mmi_eq_usbdetect_ind_struct msg;
            msg.action = DEVUSB_DETECT_ACTION_PLUGOUT;
            srv_usb_detect_ind_hdlr(&msg);
            break;
         }
        case 2:
        {
            mmi_eq_usbdetect_ind_struct msg;
            msg.action = DEVUSB_DETECT_ACTION_MS_EXIT_DONE;
            srv_usb_detect_ind_hdlr(&msg);
            break;
         }
        default:
            break;
    }
}
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_usb_detect_ind_hdlr
 * DESCRIPTION
 *  This function is usb detect indication event handler
 *  
 *  PARAMETERS: void
 *  info        [?]     
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: none(?)
 *****************************************************************************/
void srv_usb_detect_ind_hdlr(void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_usbdetect_ind_struct *p = (mmi_eq_usbdetect_ind_struct*) info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* USB split revise*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_DETECT_SCR, p->action);

    if (p->action == DEVUSB_DETECT_ACTION_PLUGIN)
    {
        srv_usb_handle_plug_in();
    }
    else if (p->action == DEVUSB_DETECT_ACTION_PLUGOUT)
    {
        srv_usb_handle_plug_out();
    }
    else if(p->action == DEVUSB_DETECT_ACTION_MS_EXIT_DONE)
    {
        srv_usb_handle_ms_exit_done();
        MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_MS_EXIT_DONE);
    }
    else
    {
        MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_FUNC_DETECT_SCR, p->action);        
    }
    srv_usb_send_detect_ack((devusb_detect_action_enum)p->action);

}


#if defined(__DM_LAWMO_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  mmi_usb_set_background_still
 * DESCRIPTION
 *  Set background image
 * PARAMETERS
 *  isStill     [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_usb_dmui_lock_notify(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dm_lawmo_lock_ind_evt_struct *lawmo_lock_ind = 
        (srv_dm_lawmo_lock_ind_evt_struct*)evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/	
    switch(lawmo_lock_ind->cmd)
    {
        case SRV_DM_LAWMO_LOCK_CMD_LOCK:
        /*operate lock*/
        g_srv_usb_dmui_lock_process = MMI_TRUE;    
        	
        if (srv_usb_get_status()== SRV_USBSTATUS_MS)
        {
                g_srv_usb_dmui_lock_cb = lawmo_lock_ind->cb;
        	srv_usb_stop_config_ms();
        }
        else if (srv_usb_get_status()== SRV_USBSTATUS_MS_PROC)
        {
            /* Wait enter ms or exit ms finished to report back to DM*/
                g_srv_usb_dmui_lock_cb = lawmo_lock_ind->cb;
                break;
        }
        else
        {
                (lawmo_lock_ind->cb)(MMI_TRUE, "USB Srv");
                g_srv_usb_dmui_lock_cb = NULL;
            }
            break;

        case SRV_DM_LAWMO_LOCK_CMD_UNLOCK:
            /*operate unlock*/        
           (lawmo_lock_ind->cb)(MMI_TRUE, "USB Srv");
           g_srv_usb_dmui_lock_process = MMI_FALSE;
           g_srv_usb_dmui_lock_cb = NULL;
           break;
               
        default:
            break;
        }

    return MMI_RET_OK;
    }

static void srv_usb_dmui_lock_process_finished(void)
    {
    if (g_srv_usb_dmui_lock_cb)
    {
        (*g_srv_usb_dmui_lock_cb)(MMI_TRUE, "USB Srv");
        g_srv_usb_dmui_lock_cb = NULL;
    }
}
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_usb_is_dm_lock
 * DESCRIPTION
 *  To check if dm is lock
 * PARAMETERS
 *  path        [?]     
 * RETURNS
 *  return MMI_TRUE if dm is lock, otherwise return MMI_FALSE
 *****************************************************************************/
#ifdef __DM_LAWMO_SUPPORT__
MMI_BOOL srv_usb_is_dm_lock(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return g_srv_usb_dmui_lock_process;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_usb_check_path_exported
 * DESCRIPTION
 *  To check if the path is exported to PC
 * PARAMETERS
 *  path        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL srv_usb_check_path_exported(WCHAR *path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_ucs2ncmp((const CHAR*)path, "Z:\\", 3)==0)
    {
    	return MMI_FALSE;
    }
    else
    {
    	return MMI_TRUE;
    }
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_is_any_exported_drive
 * DESCRIPTION
 *  is any exported drive
 * PARAMETERS
 *  void
 * RETURNS
 *  True or False
 *****************************************************************************/
MMI_BOOL srv_usb_is_any_exported_drive(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __USB_IN_NORMAL_MODE_IMPROVE__	

    return MMI_TRUE;
    
#elif (defined(__FS_CARD_SUPPORT__) && !defined(NAND_SUPPORT)) || (defined(__FS_CARD_SUPPORT__) && defined(_NAND_FLASH_BOOTING_))
    if (!srv_fmgr_drv_has_accessible_removable_drv())
    {
        return MMI_FALSE;
    }
    else

    {
        return MMI_TRUE;
    }
#else
    {
       return MMI_TRUE;
    }
#endif /* #ifdef __USB_IN_NORMAL_MODE_IMPROVE__ */
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_is_in_mass_storage_mode
 * DESCRIPTION
 *  Get current USB mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
MMI_BOOL srv_usb_is_in_mass_storage_mode(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return (MMI_BOOL)(srv_usb_is_in_mass_storage_mode_ext() || (srv_usb_get_status() == SRV_USBSTATUS_MS_PROC) || (srv_usb_get_status() == SRV_USBSTATUS_EXIT_MS_PROC));
}

MMI_BOOL srv_usb_is_in_mass_storage_mode_ext(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (MMI_BOOL)(srv_usb_get_status() == SRV_USBSTATUS_MS);
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_set_owner
 * DESCRIPTION
 *  This function is to set usb owner
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: 
 *  
 *****************************************************************************/
void srv_usb_set_owner(U8 owner)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_usb_ptr->owner = owner;
}

U8 srv_usb_get_owner(void)
{
    return srv_usb_ptr->owner;
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_is_connected
 * DESCRIPTION
 *  This function is to query whether USB cable is connected
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: 
 *  return whether USB cable is connected 
 *****************************************************************************/
MMI_BOOL srv_usb_is_connected(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_set_reset_type
 * DESCRIPTION
 *  Set reset type
 * PARAMETERS
 *  reset_type      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void srv_usb_set_reset_type(U8 reset_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_usb_ptr->reset_type = reset_type;
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_get_status
 * DESCRIPTION
 *  This function is to get the usb state
 *  
 *  PARAMETERS: 
 *  void
 *  RETURNS: 
 *  enum srv_usb_status_enum
 *****************************************************************************/
srv_usb_status_enum srv_usb_get_status(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_CUR_STATE, SRV_USB_CTX(usb_status));

    return SRV_USB_CTX(usb_status);
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_set_status
 * DESCRIPTION
 *  This function is to set the usb state
 *  
 *  PARAMETERS: 
 *  state       [IN]        enum srv_usb_status_enum
 *  RETURNS: 
 *  void
 *****************************************************************************/
void srv_usb_set_status(srv_usb_status_enum state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_STATE_TRANSITION, SRV_USB_CTX(usb_status), state);
    SRV_USB_CTX(usb_status_prev) = srv_usb_get_status();
    SRV_USB_CTX(usb_status) = state;
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_usb_init_context
 * DESCRIPTION
 *  This function is to initialize the mmi usb context.
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *****************************************************************************/
void srv_usb_init_context(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (SRVUSB_GET_FLAG(SRVUSB_MASK_BEFORE_POWERON) == MMI_TRUE)
    {
        /* Usb has been pluged in before power on */
        SRV_USB_CTX(usb_status) = SRV_USBSTATUS_PLUGIN;
        SRV_USB_CTX(usb_status_prev) = SRV_USBSTATUS_PLUGOUT;
    }
    else
    {
        /* Usb is not pluged in */
        SRV_USB_CTX(usb_status) = SRV_USBSTATUS_PLUGOUT;
    }

    //srv_usb_ptr->reset_type = NORMAL_RESET;
    mmi_frm_set_single_protocol_event_handler(MSG_ID_MMI_EQ_GET_UART_RSP, (PsIntFuncPtr)srv_usb_get_uart_rsp_hdlr);
    mmi_frm_send_ilm((oslModuleType) MOD_L4C, MSG_ID_MMI_EQ_GET_UART_REQ, 
                        (oslParaType*)NULL, (oslPeerBuffType*)NULL);
       g_usb_is_ms_exit_done = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_init_event_hdlr
 * DESCRIPTION
 *  This function is to initialize the event handler
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: None(?)
 *****************************************************************************/
void srv_usb_init_event_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetProtocolEventHandler(srv_usb_detect_ind_hdlr, MSG_ID_MMI_EQ_USBDETECT_IND);	    
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_init_bootup
 * DESCRIPTION
 *  This function is to initialize the event handler
 *  
 *  PARAMETERS: void
 *  void
 *  RETURNS: void(?)
 *  GLOBALS AFFECTED: None(?)
 *****************************************************************************/
void srv_usb_init_bootup(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_usb_init_context();
    srv_usb_set_status(SRV_USBSTATUS_MS);
    SRVUSB_SET_FLAG(SRVUSB_MASK_IS_CONNECT);
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_shutdown_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_usb_shutdown_handler(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_usb_get_status() == SRV_USBSTATUS_MS)
    {
        srv_usb_stop_config_ms();
        srv_usb_set_status(SRV_USBSTATUS_MS_PROC);
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  srv_usb_send_power_on_req
 * DESCRIPTION
 *  Send power on request (END key is long pressed) to L4C in USB power on mode
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_usb_send_power_on_req(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_eq_power_on_req_struct *myMsgPtr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    myMsgPtr = (mmi_eq_power_on_req_struct*) OslConstructDataPtr(sizeof(mmi_eq_power_on_req_struct));
    myMsgPtr->fun = srv_usb_ptr->reset_type;
    myMsgPtr->rst = 0;
	
    mmi_frm_send_ilm((oslModuleType) MOD_L4C, MSG_ID_MMI_EQ_POWER_ON_REQ, 
                        (oslParaType*)myMsgPtr, (oslPeerBuffType*)NULL);
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_send_removal_event_req
 * DESCRIPTION
 *  removal request handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_usb_send_removal_event_req(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_bootup_mode_enum mode;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_SEND_REMOVAL_EVENT_REQ);

    mode = srv_bootup_get_booting_mode();
    if (mode == SRV_BOOTUP_MODE_USB ||
    	  mode == SRV_BOOTUP_MODE_CHARGE ||
    	  mode == SRV_BOOTUP_MODE_PRECHARGE)
    {
        srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_POWER_OFF_REMOVED);
        if (!srv_usb_alm_shown())
        {
            srv_usb_send_msg_to_hw(MSG_ID_MMI_EQ_POWER_OFF_REQ, (void*)NULL, (void*)NULL);
        }
    }
    else
    {
    #ifdef __USB_IN_NORMAL_MODE__
        srv_usb_status_enum usb_state = srv_usb_get_status();

        if ((usb_state == SRV_USBSTATUS_MS)/* || (usb_state == SRV_USBSTATUS_IGNORED)*/)
        {
            srv_usb_set_status(SRV_USBSTATUS_MS_PROC);
        }
        else if (usb_state == SRV_USBSTATUS_MS_PROC)
        {
            if (g_usb_blocked_exit_ms > 0)
            {
                return; /* reinit already proceeding */
            }
            else if ((g_usb_blocked_enter_ms > 0)
        #if defined(__DM_LAWMO_SUPPORT__)
            	&& g_srv_usb_dmui_lock_process
        #endif
            	)
            {
                // g_usb_wait_do_exit_ms = 1;
                return;
            }
        }

        //srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_CFG_LIST);
        //srv_usb_exit_ms_proc(); /* reinit*/
        srv_usb_emit_event(EVT_ID_USB_PRE_EXIT_MODE);	
        MMI_TRACE(MMI_COMMON_TRC_G8_DEV, TRC_MMI_USB_SEND_PRE_EXIT_MODE_EVENT_REQ);
                        
        if (g_usb_blocked_exit_ms == 0)
        {
            //srv_usb_post_event(EVT_ID_USB_PLUG_OUT);
    		//srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
    		srv_usb_send_removal_event_rsp();
        }
        
    #else
        if (srv_bootup_is_booting() == MMI_FALSE)
        {
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
        }
    #endif /* __USB_IN_NORMAL_MODE__ */ 
    }
}

static MMI_BOOL srv_usb_alm_shown(void)
{
    mmi_ret ret;
    
    ret = srv_usb_emit_event(EVT_ID_USB_ALM_STATE);    
    if (ret == MMI_RET_ERR_NO_REG_CB)
    {
        return srv_reminder_is_expiring();
    }
    if(ret > 0)
    {
        ret = KAL_TRUE;
    }
    else
    {
        ret = KAL_FALSE;
    }
    return (MMI_BOOL)ret;
}

/*****************************************************************************
 * FUNCTION
 *  srv_usb_send_removal_event_rsp
 * DESCRIPTION
 *  removal response handler
 * PARAMETERS
 *  info        [?]     response message
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_usb_send_removal_event_rsp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_PROGRESS);
    
#if defined(__DM_LAWMO_SUPPORT__)
    if (srv_usb_report_dmui_result())
        return;
#endif    
    
    if (srv_usb_ptr->ms_config_result == MMI_FALSE)
    {
        srv_usb_ptr->ms_config_result = MMI_TRUE;

        //srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CLOSE_CFG_LIST);

        if (SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT))
        {
            srv_usb_set_status(SRV_USBSTATUS_PLUGIN);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_CFG_ERROR);
        }
        else
        {
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
            srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
        }
        
    }
    else
    {
        srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
        srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_REMOVED);
    }
}

#if defined(__DM_LAWMO_SUPPORT__)
static MMI_BOOL srv_usb_report_dmui_result(void)
{
    if (g_srv_usb_dmui_lock_process)
    {
    	if (SRVUSB_GET_FLAG(SRVUSB_MASK_IS_CONNECT))
        {
    	    srv_usb_set_status(SRV_USBSTATUS_PLUGIN);
        }
        else
        {
            srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
        }
        srv_usb_dmui_lock_process_finished();
                              
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif

static void srv_usb_get_uart_rsp_hdlr(void *inMsg)
{
    mmi_eq_get_uart_rsp_struct *rsp = inMsg;

    if (rsp->result)
    {
        srv_usb_ptr->ps_port = rsp->ps_uart_port;
    }
}

U8 srv_usb_get_ps_port(void)
{
    return srv_usb_ptr->ps_port;
}

void srv_usb_app_reset_poweron(void)
{
    if (srv_usb_get_status() != SRV_USBSTATUS_MS)
    {
    	srv_usb_set_reset_type(CHARGING_RESET);        
    }
    srv_usb_send_power_on_req();
}

void srv_usb_reset_poweron(void)
{
#if defined(__MMI_SUBLCD__)
    lcd_power_on(SUB_LCD, 0);
#endif 
#if defined(__MMI_BTBOX_NOLCD__) || defined(__IOT__)
    srv_backlight_all_lcd_off();
    mmi_frm_clear_all_key_handler();
#endif /* defined(__MMI_BTBOX_NOLCD__) || defined(__IOT__) */
    srv_usb_send_power_on_req();
}

void srv_usb_leave_usb_mode(void)
{
    srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_POWER_OFF_REMOVED);
}

#ifdef __MMI_TETHERING__
void srv_usb_tethering_off(void)
{
    srv_usb_status_enum status = srv_usb_get_status();
    
    if (status == SRV_USBSTATUS_USBTETHERING)
    {
        srv_usb_set_status(SRV_USBSTATUS_PLUGOUT);
        srv_usb_emit_mmi_notify(SRV_USB_MMI_NOTIFY_PLUGOUT);
    }
}
#endif

static void srv_usb_start_pending_timer(void)
{
    StartTimer(
        PENDING_USBDETECTION_HDLR_TIMER,
        PENDING_USBDETECTION_HDLR_TIMER_DUR,
        srv_usb_pending_detection_timeout_hdlr);
}

static void srv_usb_plug_in_before_power_on(void)
{
    srv_usb_set_before_power_on_flag(MMI_TRUE);
    srv_usb_set_status(SRV_USBSTATUS_PLUGIN);
    srv_usb_pending_detection_hdlr();
}

#else

#include "MMIDataType.h"

mmi_ret srv_usb_shutdown_handler(mmi_event_struct *evt)
{
    return MMI_RET_OK;
}

mmi_ret srv_usb_dmui_lock_notify(mmi_event_struct *evt)
{
    return MMI_RET_OK;
}

#endif /* __MMI_USB_SUPPORT__*/
