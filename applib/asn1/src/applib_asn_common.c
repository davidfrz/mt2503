/*******************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2007
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * applib_asn_common.c
 *
 * Project:
 * --------
 *   Maui
 *
 * Description:
 * ------------
 *   This file is intends for common function for AGPS project.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
 *
 * COMPONENT:   ASN
 * MODULE:      ASN_COMMON
 * DESCRIPTION: Auto generated by MTK ASN.1 Compiler
 *
 ****************************************************************************/
/**
 * @file asn_common.c
 *
 * ASN.1 Common functions
 *
 * @ingroup asn_common
 */
 
//#include <assert.h>
//#include "kal_release.h"
#include "applib_asn_common.h"
#include "applib_asn_memory.h"

///add for RHR
#include "applib_mtkasn_global.h"
#include "kal_general_types.h"
#include "setjmp.h"
#include "kal_public_api.h"
///


U16 applib_GetUperLengthDeterminant( applib_AsnContext *pContext )
{
   U16 length = 0;
   if( ! applib_getShortBits( pContext, 1 ) )
   {
      /* 7 bit length */
      length = applib_getShortBits( pContext, 7 );
   }
   else
   if( !applib_getShortBits( pContext, 1 ) )
   {
      /* 14 bit length */
      length = applib_getShortBits( pContext, 14 );
   }
   else
   {
      /* Unsupported length format */
      UA1_ERROR( 1 );
   }

   return length;
}

void applib_PutUperLengthDeterminant( applib_AsnContext *pContext, U16 length )
{
   if( length < 128 )
   {
      /* 8 bit length determinant */
      applib_putShortBits( pContext, 8, length );
   }
   else
   if( length < 16384 )
   {
      /* 16 bit length determinant */
      applib_putShortBits( pContext, 16, length | 0x8000 );
   }
   else
   {
      /* Unsupported length */
      UA1_ERROR( 2 );
   }
}

void applib_AsnFreeDecoded( void *pType, applib_PAsnMemFreeCallBack pFreeFunc)
{
   applib_AsnDecodeFree( ( applib_AllocRecord *)pType - 1, pFreeFunc);
}

void applib_AsnFreeEncoded( U8 *pEncoded, applib_PAsnMemFreeCallBack pFreeFunc)
{
   applib_AsnEncodeFree( pEncoded, pFreeFunc);
}

void applib_AsnRootDecodeAlloc( applib_AsnContext *pContext, void **ppType, int size )
{
   if( !(*ppType) )
   {
      size += sizeof( applib_AllocRecord );
      applib_asnMemAlloc(pContext, (void**) &pContext->decodeAlloc, size );
	  pContext->decodeAlloc->ppEnd = &(pContext->decodeAlloc->pMemBlock[0]) + sizeof( pContext->decodeAlloc->pMemBlock ) / sizeof( pContext->decodeAlloc->pMemBlock[0] );
	  pContext->decodeAlloc->ppNext = &(pContext->decodeAlloc->pMemBlock[0]);
      *ppType = pContext->decodeAlloc + 1;
   }
}

void applib_AsnDecodeAlloc( applib_AsnContext *pContext, void **ppMem, int size )
{
   if( !pContext->decodeAlloc )
   {
      /* Attempt to allocate memory when decoding to a user supplied buffer */
      UA1_ERROR( 3 );
   }

   if( pContext->decodeAlloc->ppNext >= pContext->decodeAlloc->ppEnd )
   {
      /* Limit of runtime allocated decode memory blocks reached */
	    //printf("Limit of runtime allocated decode memory blocks reached");
	    UA1_ERROR( 4 );
   }
   applib_asnMemAlloc(pContext, ppMem, size );
   *pContext->decodeAlloc->ppNext++ = *ppMem;
}

void applib_AsnDecodeFree( applib_AllocRecord *decodeAlloc, applib_PAsnMemFreeCallBack pFreeFunc)
{
  void **ppFree;
  if( decodeAlloc )
  {
    for( ppFree = decodeAlloc->pMemBlock; ppFree < decodeAlloc->ppNext; ppFree++ )
    {
      if (pFreeFunc == NULL)
      {
        applib_asnMemFree( ppFree );
      }
      else
      {
        pFreeFunc( ppFree );
      }
    }

    if (pFreeFunc == NULL)
    {
        applib_asnMemFree((void**)&decodeAlloc);
    }
    else
    {
        pFreeFunc((void**)&decodeAlloc);
    }
  }
}

void applib_AsnEncodeAlloc( applib_AsnContext *pContext, U8 **ppMem, U32 *pEncodedLength )
{
   U32 size;

   if (NULL == ppMem)
   {
      // Encode length test
      pContext->pEncoded = NULL;
   }
   else
   {
      if( !(*ppMem) )
      {
         size = 4000;
         applib_asnMemAlloc(pContext, (void**)&pContext->encodeAlloc, size );
         *ppMem = pContext->encodeAlloc;
      }
      NOT_USED( pEncodedLength );
   }
}

void applib_AsnEncodeFree( void *pFree, applib_PAsnMemFreeCallBack pFreeFunc)
{
   if( pFree )
   {
   	 if (pFreeFunc == NULL)
   	 {
   	   applib_asnMemFree( &pFree );
   	 }
   	 else
   	 {
   	 	 pFreeFunc( &pFree );
   	 }
   }
}

void applib_AsnError( applib_AsnContext *pContext, U32 errorCode )
{
   pContext->result = errorCode;
   longjmp( pContext->env, 1 );
}

extern S32	applib_GetAlphabetIndex(applib_ASN_OneByteAlphabet *pAlphabet, char *pChar)
{
	U32		uIndex, left, right;
	left = 0;
	right = pAlphabet->valueLen - 1;

	while(left <= right)
    {
        uIndex = (left + right) / 2;
        if(*(pAlphabet->value+uIndex) == *pChar)
		{
            return uIndex;
		}
        else if(*(pAlphabet->value+uIndex) > *pChar)
		{
			right = uIndex - 1; 
		}
        else
		{
            left = uIndex + 1;
		}
	}
	return -1;
}

extern U32 applib_GetNumberOctetLength(U32  Data)
{
	if (Data <= 0xFF) {
		return 1;
	}
	if (Data > 0xFF &&
		Data <= 0xFFFF) {
		return 2;
	}
	if (Data > 0xFFFF &&
		Data <= 0xFFFFFF) {
		return 3;
	}
	else if (Data > 0xFFFFFF &&
			Data <= 0xFFFFFFFF) {
		return 4;
	}
	else{
		return 0;
	}
}

extern Bool applib_OIDCompare(applib_OID  oidA, U32 lenght, U32 *pValue)
{
	if (oidA.valueLen != lenght)
	{
		return (Bool)FALSE;
	}
	if (0 == applib_asnMemCmp(oidA.value, pValue, lenght * sizeof(U32)))
	{
		return (Bool)TRUE;
	}
	else
	{
		return (Bool)FALSE;
	}
}

static	struct {
	U8 *pByte;
}applib_SkipedEncodeByte;

extern  void  applib_SkipEncodeByte(applib_AsnContext *pContext)
{
	applib_SkipedEncodeByte.pByte = pContext->pEncoded;
	pContext->pEncoded += 1;
}

extern EncodeBeginPoint applib_BeginTestEncodeLen(applib_AsnContext *pContext)
{
   if (NULL != pContext->pEncoded)
   {
      return (EncodeBeginPoint) pContext->pEncoded;
   }
   else
   {
      return (EncodeBeginPoint)pContext->shiftRegister;
   }
}

extern  U32 applib_EndTestEncodeLen(applib_AsnContext *pContext, EncodeBeginPoint	BeginPoint)
{
	S32	len;
	ASSERT(BeginPoint != 0);

   if (NULL == pContext->pEncoded)
   {
      len = (U32)pContext->shiftRegister - (U32)BeginPoint;
   }
   else
   {
	len = (U32)pContext->pEncoded - (U32)BeginPoint;
   }

	len = len > 0 ? len : -len ;
	return len;
}

extern U32 applib_testGetShortBits( applib_AsnContext *pContext, U32 numBits)
{
	U32		result;
	applib_AsnContext TempContext = *pContext;
	result = applib_getShortBits(&TempContext, numBits);

	return result;
}

extern  void applib_PutShortSkipedEncodeByte(applib_AsnContext *pContext,  U32 uByte, U32 Data, U32 uAfterSize)
{
	applib_AsnContext	tempContext;

	if (uAfterSize != 0)
	{
		ASSERT(1 >= uByte);
	}

	if (1 < uByte)
	{
		applib_asnMemMove(applib_SkipedEncodeByte.pByte+uByte, applib_SkipedEncodeByte.pByte + 1, uAfterSize);
	}

	tempContext = *pContext;
	pContext->pEncoded = applib_SkipedEncodeByte.pByte;
	applib_putShortBits(pContext, uByte * 8, Data);

	*pContext = tempContext;
}


#define MAX_BITS_FOR_SHORT (24)
#define BIT_MASK_ARRAY_LENGTH (65)

static const U64 lsbMask[BIT_MASK_ARRAY_LENGTH]=
{
0x0000000000000000,
0x0000000000000001, 0x0000000000000003, 0x0000000000000007, 0x000000000000000f,
0x000000000000001f, 0x000000000000003f, 0x000000000000007f, 0x00000000000000ff,
0x00000000000001ff, 0x00000000000003ff, 0x00000000000007ff, 0x0000000000000fff,
0x0000000000001fff, 0x0000000000003fff, 0x0000000000007fff, 0x000000000000ffff,
0x000000000001ffff, 0x000000000003ffff, 0x000000000007ffff, 0x00000000000fffff,
0x00000000001fffff, 0x00000000003fffff, 0x00000000007fffff, 0x0000000000ffffff,
0x0000000001ffffff, 0x0000000003ffffff, 0x0000000007ffffff, 0x000000000fffffff,
0x000000001fffffff, 0x000000003fffffff, 0x000000007fffffff, 0x00000000ffffffff,
0x00000001ffffffff, 0x00000003ffffffff, 0x00000007ffffffff, 0x0000000fffffffff,
0x0000001fffffffff, 0x0000003fffffffff, 0x0000007fffffffff, 0x000000ffffffffff,
0x000001ffffffffff, 0x000003ffffffffff, 0x000007ffffffffff, 0x00000fffffffffff,
0x00001fffffffffff, 0x00003fffffffffff, 0x00007fffffffffff, 0x0000ffffffffffff,
0x0001ffffffffffff, 0x0003ffffffffffff, 0x0007ffffffffffff, 0x000fffffffffffff,
0x001fffffffffffff, 0x003fffffffffffff, 0x007fffffffffffff, 0x00ffffffffffffff,
0x01ffffffffffffff, 0x03ffffffffffffff, 0x07ffffffffffffff, 0x0fffffffffffffff,
0x1fffffffffffffff, 0x3fffffffffffffff, 0x7fffffffffffffff, 0xffffffffffffffff
};

extern void applib_initFifo( applib_AsnContext *pContext, U8 *buffer, U32 bufferLength )
{
   pContext->pEncoded = buffer;
   pContext->pEncodedEnd = buffer + bufferLength;
   pContext->shiftRegister = pContext->shiftRegisterLength = 0;
   pContext->result = 0;
}

extern void applib_flushFifo( applib_AsnContext *pContext )
{
   if( pContext->shiftRegisterLength > 0 )
   {
      if (NULL == pContext->pEncoded)
      {
         pContext->shiftRegister++;
	  }
      else
      {
         *pContext->pEncoded++ = (U8)(pContext->shiftRegister >> 24);
	  }
   }
}

extern U32 applib_getShortBits( applib_AsnContext *pContext, U32 numBits )
{
   U32 retVal;
   ASSERT( numBits <= MAX_BITS_FOR_SHORT );

   while ( numBits > pContext->shiftRegisterLength )
   {
      if( pContext->pEncoded >= pContext->pEncodedEnd )
      {
         UA1_ERROR( 5 );
      }

      pContext->shiftRegister |= *pContext->pEncoded++ << (24 - pContext->shiftRegisterLength);
      pContext->shiftRegisterLength += 8;
   }

   retVal = pContext->shiftRegister >> (32 - numBits);
   pContext->shiftRegister <<= numBits;
   pContext->shiftRegisterLength -= numBits;

   return( retVal );
}

extern U32 applib_getBits( applib_AsnContext *pContext, U32 numBits )
{
   U32 retVal;
   ASSERT( numBits <= 32 );
   if ( numBits <= MAX_BITS_FOR_SHORT )
   {
      retVal = (U32)applib_getShortBits( pContext, numBits );
   }
   else
   {
      retVal = (U32) applib_getShortBits( pContext, MAX_BITS_FOR_SHORT );
      numBits -= MAX_BITS_FOR_SHORT;
      /* ASN.1 is big endian so first n bits go at top of word */
      retVal <<= numBits;
      retVal |= (U32)applib_getShortBits( pContext, numBits );
   }
   return( retVal );
}

extern void applib_getLongBits( applib_AsnContext *pContext, U32 numBits, U8 *outputBuffer )
{
   while ( numBits >= 8 )
   {
      if( pContext->pEncoded >= pContext->pEncodedEnd )
      {
         UA1_ERROR( 6 );
      }
      pContext->shiftRegister |= *pContext->pEncoded++ << (24 - pContext->shiftRegisterLength);
      *outputBuffer++ = (U8)(pContext->shiftRegister >> 24);
      pContext->shiftRegister <<= 8;
      numBits-= 8;
   }

   if ( numBits )
   {
      *outputBuffer = (U8)(applib_getShortBits( pContext, numBits ) << (8 - numBits));
   }
}

extern U64 applib_getInt64( applib_AsnContext *pContext, U32 numBits )
{
   U64 retVal;
   ASSERT( numBits <= 64 );
   if ( numBits <= 32 )
   {
      retVal = (U64)applib_getBits( pContext, numBits );
   }
   else
   {
      retVal = (U64) applib_getBits( pContext, 32 );
      numBits -= 32;
      /* ASN.1 is big endian so first n bits go at top of word */
      retVal <<= numBits;
      retVal |= (U64)applib_getBits( pContext, numBits );
   }
   return( retVal );
}

extern void applib_putShortBits( applib_AsnContext *pContext, U32 numBits, U32 data )
{
   ASSERT( numBits <= MAX_BITS_FOR_SHORT );
   ASSERT( 0 == (data & ~lsbMask[numBits]) );

   if (NULL != pContext->pEncoded)
   {
      pContext->shiftRegister |= data << (32 - pContext->shiftRegisterLength - numBits);
   }

   pContext->shiftRegisterLength += numBits;

   while ( pContext->shiftRegisterLength >= 8 )
   {
	  if (NULL == pContext->pEncoded)
      {
         pContext->shiftRegister++;
      }
      else
      {
         if (pContext->pEncoded >= pContext->pEncodedEnd)
         {
             UA1_ERROR(15);
         }

         *pContext->pEncoded++ = (U8)(pContext->shiftRegister >> 24);
         pContext->shiftRegister <<= 8;
      }

      pContext->shiftRegisterLength -= 8;
   }
}

extern void applib_putBits( applib_AsnContext *pContext, U32 numBits, U32 data )
{
   ASSERT( numBits <= 32 );
   if( numBits > MAX_BITS_FOR_SHORT )
   {
      /* Insert top 24 bits */
      applib_putShortBits( pContext, MAX_BITS_FOR_SHORT, data >> (numBits - MAX_BITS_FOR_SHORT) );
      /* reduce amount to fit, and then mask off bits inserted */
      numBits -= MAX_BITS_FOR_SHORT;
      data &= lsbMask[numBits];
   }
   applib_putShortBits( pContext, numBits, data );
}

extern void applib_putInt64( applib_AsnContext *pContext, U32 numBits, U64 data )
{
   ASSERT( numBits <= 64 );
   if( numBits > 32 )
   {
      /* Insert top 32 bits */
      applib_putBits( pContext, 32, data >> (numBits - 32) );
      /* reduce amount to fit, and then mask off bits inserted */
      numBits -= 32;
      data &= lsbMask[numBits];
   }
   applib_putBits( pContext, numBits, data );
}

extern void applib_putLongBits( applib_AsnContext *pContext, U32 numBits, U8 *data )
{
   while ( numBits >= 8 )
   {
	  if (NULL == pContext->pEncoded)
	  {
		  pContext->shiftRegister++;
	  }
	  else
      {
          if (pContext->pEncoded >= pContext->pEncodedEnd)
          {
              UA1_ERROR(15);
          }

          pContext->shiftRegister |= *data++ << ( 24 - pContext->shiftRegisterLength );
          *pContext->pEncoded++ = (U8)(pContext->shiftRegister >> 24);
          pContext->shiftRegister <<= 8;
      }

      numBits -= 8;
   }

   if ( numBits )
   {
      applib_putShortBits( pContext, numBits, *data >> (8 - numBits) );
   }
}

void applib_AsnRootDecodeAlloc2( applib_AsnContext *pContext, void **ppType, int size, const char *file, unsigned long line)
{
   if( !(*ppType) )
   {
      size += sizeof( applib_AllocRecord );
      applib_asnMemAlloc2(pContext, (void**)&pContext->decodeAlloc, size, file, line);
      pContext->decodeAlloc->ppEnd = &(pContext->decodeAlloc->pMemBlock[0]) + sizeof( pContext->decodeAlloc->pMemBlock ) / sizeof( pContext->decodeAlloc->pMemBlock[0] );
      pContext->decodeAlloc->ppNext = &(pContext->decodeAlloc->pMemBlock[0]);
      *ppType = pContext->decodeAlloc + 1;
   }
}

void applib_AsnDecodeAlloc2( applib_AsnContext *pContext, void **ppMem, int size, const char *file, int line)
{
   if( !pContext->decodeAlloc )
   {
      /* Attempt to allocate memory when decoding to a user supplied buffer */
      UA1_ERROR( 3 );
   }
   if( pContext->decodeAlloc->ppNext >= pContext->decodeAlloc->ppEnd )
   {
      /* Limit of runtime allocated decode memory blocks reached */
      UA1_ERROR( 4 );
   }

   applib_asnMemAlloc2(pContext, ppMem, size, file, line);
   *pContext->decodeAlloc->ppNext++ = *ppMem;
}

void applib_AsnEncodeAlloc2( applib_AsnContext *pContext, U8 **ppEncoded, U32 *pEncodedLength, const char *file, int line)
{
   U32 size;
   if( !(*ppEncoded) )
   {
      size = 4000;
      applib_asnMemAlloc2(pContext, (void**)&pContext->encodeAlloc, size, file, line);
      *ppEncoded = pContext->encodeAlloc;
   }
   NOT_USED( pEncodedLength );
}


