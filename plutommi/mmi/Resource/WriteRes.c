/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  WriteRes.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 *
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

/**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */
/**********************************************************************************
   FILENAME : WriteRes.c

   PURPOSE     : Helper Functions   to Write/Generate the Customizable Resources like Strings,Images,MenuItems..etc.

   REMARKS     : nil

   AUTHOR      : Subramanya BG

   DATE     : 20thSept 2002.

   Copyright (c) 2002 All rights reserved by Pixtel Communications
**********************************************************************************/
#include "GlobalMenuItems.h"
#include "MMIDataType.h"
#include "CustDataRes.h"
#include "CustDataProts.h"
#include "CustMenuRes.h"
#include "mmi_features.h"
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#define WIN32_LEAN_AND_MEAN
#include "windows.h"

#include "CustResDef.h"
#include "gui_resource_type.h"
#include "ABMLoader.h"
#include "CmidiGen.h"
#include "WriteResUtil.h"
#include "ResgenLogCAPI.h" 

/*RHR*/
    #include "mmi_res_range_def.h"

/* buffer size for shell command */
#define SHELL_CMD_BUFLEN            (MAX_FILENAME_LEN + 100)

#define MENUITEM_ID_TYPE            9
#define PARENT_ITEM_ID_TYPE         8
#define NUMBER_OF_MENUITEMS_TYPE    7
#define MENU_ITEM_ORDER_TYPE        6
#define HIDE_FLAG_TYPE              5
#define MOVEABLE_FLAG_TYPE          4
#define DISPLAY_ATTRIBUTE_TYPE      3
#define MENU_ITEM_STRING_ID_TYPE    2
#define MENU_ITEM_IMAGE_ID_TYPE     1
#define TRUE                        1
#define FALSE                       0

#define OUTPUT_DATA_FILENAME        "..\\..\\Customer\\CustResource\\CustImgDataHW.h"
#define OUTPUT_DATA_FILENAME_EXT    "..\\..\\Customer\\CustResource\\CustImgDataHWExt.h"
#define OUTPUT_MENUTREE_FILENAME    "..\\..\\Customer\\CustResource\\CustMenuTree_Out.c"

#define AUDIO_OUTPUT_DATA_FILENAME      "..\\..\\Customer\\CustResource\\CustAdoDataHW.h"
#define AUDIO_OUTPUT_DATA_FILENAME_EXT  "..\\..\\Customer\\CustResource\\CustAdoDataHWExt.h"
#define OUTPUT_AUDIO_NAMES_END          "[] =\n{"
#define NOAUDIO_FILENAMEBUFFER          "..\\\\..\\\\Customer\\\\AUDIO\\\\NOAUDIO.MP3"
#define AUDIO_DEFAULT_FILEBUFFER        "________CUSTOMER__AUDIO__DEFAULT_MP3"

#define OUTPUT_BINARY_NAMES_END          "[] =\n{"
#define NO_BINARY_FILE_NAME_BUFFER          "..\\\\..\\\\Customer\\\\Binary\\\\NoBinary.bin"
#define BINARY_DEFAULT_FILEBUFFER        "________CUSTOMER__BINARY__NOBINARY_BIN"

#define FONT_OUTPUT_DATA_FILENAME		"..\\..\\Customer\\CustResource\\CustFontDataHW.h"

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__
#define ENFB_IMAGE_DATA_FILENAME    "..\\..\\Customer\\CustResource\\CustENFBImgData"//100206 ENFB support
#endif

#ifdef __MMI_FONT_THIRD_ROM_SUPPORT__
#define ENFB_FONT_DATA_FILENAME    "..\\..\\Customer\\CustResource\\CustENFBFontData"
#endif



#define RESWRI_TAG       "WRITERES"
#define RESWRI_LOG_D(format, args...) RES_LOG_D((RESWRI_TAG), (format) , ##args)
#define RESWRI_LOG_V(format, args...) RES_LOG_V((RESWRI_TAG), (format) , ##args)
#define RESWRI_LOG_W(format, args...) RES_LOG_W((RESWRI_TAG), (format) , ##args)
#define RESWRI_LOG_E(format, args...) RES_LOG_E((RESWRI_TAG), (format) , ##args)


static BOOL ExtAudioFlag = FALSE;

#define ASSERT(expr) {if(!(expr)) {while(1);}else {}}

#if defined(__MMI_RESOURCE_AUDIO_COMPRESS__)

res_compress_struct res_compress_data[MAX_COMPRESSED_ITEM];
U32 res_compress_count = 0;

#else /* (__MMI_RESOURCE_AUDIO_COMPRESS__) */

#endif /* (__MMI_RESOURCE_AUDIO_COMPRESS__) */

static U8 is_first = 1;
static U32 audio_idx = 1;
static U32 binary_idx = 1;

void Extract_Name(S8 *dest, S8 *src, image_type_enum ExtImageFlag);
MMI_BOOL Aload(S8 *string);


U8 StrIsPopulate[MAX_STRING_MAP_SIZE];
U8 *StrEnum[MAX_STRING_MAP_SIZE];
U8 *Str[MAX_STRING_MAP_SIZE];

extern FILE *OutputMenutreeIDFile;
extern FILE *RepeatIDListFile;


static S32 g_ressize = 0;

extern mmi_resource_base_struct g_mmi_resource_base_table[];
extern FILE *fpMenuResourceUsage;
extern FILE *fpAudioResourceUsage;
extern FILE *fpStringResourceUsage;

static U32 g_resado_count = 0;
static CUSTOM_RESOURCE_SIZE g_resado_table[MAX_AUDIO_IDS_SIZE];


extern FILE *OutputAdoIDFile;
extern FILE *OutputBinaryIDFile;

/* decalred in the CustAudioRes.c */
extern AUDIONAME_LIST AudioNameList[];
extern CUSTOM_AUDIO_MAP AudioIdMap[];
extern AUDIONAME_LIST AudioNameListEXT[];
extern CUSTOM_AUDIO_MAP AudioIdMapEXT[];

/* declared in the CustMenuDataRes.c */
extern CUSTOM_MENU nCustMenus[];

/* Global Variables */

FILE *dest_file;

int toolFlag = 0;       /* decide if this is run by CustPack tool */
int resultFailFlag = 0; /* decide if this is run by CustPack tool */
MMI_BOOL g_is_log = MMI_TRUE;
static S32 g_force_ado_type = AUTO_ADO_TYPE;

#ifdef __MMI_RESOURCE_ENFB_SUPPORT__
FILE *enfb_img_data_file;
#endif

#ifdef __MMI_FONT_THIRD_ROM_SUPPORT__
FILE *enfb_font_data_file;
#endif

// local constants
static const S8 CustImgPath[] = CUST_IMG_PATH;
static const S8 CustAdoPath[] = CUST_ADO_PATH;
static const S8 CustBinaryPath[] = CUST_BINARY_PATH;

#ifdef __UCS2_ENCODING
static U16 AnsiiToUnicodeString(S8 *pOutBuffer, S8 *pInBuffer);
#endif

// global variables from other .c
extern U16 CurrMaxStringId;

extern U16 CurrMaxAudioNum;
extern U16 CurrMaxAudioId;
extern U16 CurrMaxAudioNumEXT;
extern U16 CurrMaxAudioIdEXT;

#ifdef __POPULATE_ENGINE_
static void AddStringInfo(int StrId, char *pString, char *pStringDisplay);
static void AddImageInfo(int ImgId, char *pImage, char *pIMageDisplay);
static void AddApplicationInfo(U32 nId, S8 *pName, U32 nMinId, U32 nMaxId);
#endif /* __POPULATE_ENGINE_ */


/* Local Functions */
U32 GetOffsetFromResourceBase(U16 ImageID, U8* enum_value); // XXX
static void ConvertToPrintable(S8 *original, S8 *converted);
static U16 MenuItemPresent(U16 ItemId);

static S32 Load_Audio_Data(
        FILE *output_file,
        FILE *input_file,
        U8 audio_identifier);
static MMI_BOOL isMainmenuImage(S8 *path);


U32 GetOffsetFromResourceBase(U16 ImageID, U8* enum_value)
{
    U32 i = 0;

    while (1)
    {
        if (strncmp(g_mmi_resource_base_table[i].appname, "END", 3) == 0)
        {
            break;
        }
        else if ((ImageID >= g_mmi_resource_base_table[i].min) &&
                 (ImageID < g_mmi_resource_base_table[i].max))
        {
            return i;
        }
        else if (ImageID == g_mmi_resource_base_table[i].max)
        {
            fprintf(stderr, "[ERR] ID:[%s] reach MAX of the Range, Please add some Range for APP[%s]\n", enum_value, g_mmi_resource_base_table[i].appname);
            RESWRI_LOG_E("Error!! ID:[%s] reach MAX of the Range, Please add some Range for APP[%s]", enum_value, g_mmi_resource_base_table[i].appname);
            exit(2);
        }
        else
        {
            i++;
        }
    }

    return 0xFFFFFFFF;
}


/*****************************************************************************
 * FUNCTION
 *  InitStrPopulate
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitStrPopulate()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    int i = 0;
    FILE *pFile;
    RESWRI_LOG_V("InitStrPopulat(): Prepare for string resource population");
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < MAX_STRING_MAP_SIZE; i++)
    {
        StrIsPopulate[i] = 0;
    }

    if(pFile = fopen(ZIP_OUTPUT_FILE, "w"))
    {
        RESWRI_LOG_V("Init ZIP_OUTPUT_FILE content, write to %s", ZIP_OUTPUT_FILE);
        fputs("symbol name,Ori.Size,Cpz.Size,Size Diff,Is Cpzd\n", pFile);
        fclose(pFile);
    }
	else
    {
        RESWRI_LOG_W("Init ZIP_OUTPUT_FILE failed: can't open %s", ZIP_OUTPUT_FILE);
    }
	fflush(stdout); // flush the trace log

}

/* MTK Leo add, to store new string */


/*****************************************************************************
 * FUNCTION
 *  ConvertToPrintable
 * DESCRIPTION
 *
 * PARAMETERS
 *  original        [?]
 *  converted       [?]
 * RETURNS
 *  void
 *****************************************************************************/
static void ConvertToPrintable(S8 *original, S8 *converted)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i = 0, j = 0, strlength = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    strlength = wcslen((wchar_t*) original);
    for (i = 0; i < strlength * 2; i++)
    {
        if (original[i] == 10)
        {
            converted[j] = 92;
            converted[++j] = 0;
            converted[++j] = 'n';
            j++;
        }
        else
        {
            converted[j++] = original[i];
        }
    }
    if (strlength == 0)
    {   /* If NULL string, fill in " " */
        converted[0] = 20;
        converted[1] = '\0';
        converted[2] = '\0';
        converted[3] = '\0';
    }
    else
    {
        converted[j++] = '\0';
        converted[j] = '\0';
    }
}


/*****************************************************************************
 * FUNCTION
 *  AnsiiToUnicodeString
 * DESCRIPTION
 *  Converts Ansii encode string to unicode
 *
 *  Caller has to ensure that pOutBuffer
 *  should be as large
 * PARAMETERS
 *  pOutBuffer      [OUT]
 *  pInBuffer       [IN]
 * RETURNS
 *  U16
 *****************************************************************************/
static U16 AnsiiToUnicodeString(S8 *pOutBuffer, S8 *pInBuffer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (*pInBuffer != '\0')
    {
        pOutBuffer[++count] = *pInBuffer;
        pOutBuffer[++count] = 0;
        pInBuffer++;
    }

    pOutBuffer[++count] = '\0';
    pOutBuffer[++count] = '\0';
    return count + 1;
}


/*****************************************************************************
 * FUNCTION
 *  SetStringWithDisplay
 * DESCRIPTION
 *
 * PARAMETERS
 *  nStrId          [IN]
 *  pString1        [IN]
 *  enum_value      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void SetStringWithDisplay(U16 nStrId, S8 *pString1, S8 *enum_value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *pString = NULL;
    S8 *pEnum_value = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ressize = 1;  //strlen(pString1);
    if (strstr(pString1, "\n") == NULL)
    {
        RESPRTONERECORD(fpStringResourceUsage, nStrId, pString1, enum_value, g_ressize);
    }
    else
    {
        RESPRTONERECORD(fpStringResourceUsage, nStrId, "N/A", enum_value, g_ressize);
    }
#ifdef __IOT__
    /* for IOT no string, replace with a specific marker(65) "?" */
    pString = malloc(4);
    if (pString == NULL)
    {
        RESWRI_LOG_E("Error!! SetStringWithDisaply: no memory");
        exit(2);
    }
    *pString = 63;
    *(pString + 1) = '\0';
    *(pString + 2) = '\0';
    *(pString + 3) = '\0';
#else /*__IOT__*/
    if (*pString1 == '\0')
    {
        /* for null string, replace with a specific marker(20) */
        pString = malloc(4);
        if (pString == NULL)
        {
            RESWRI_LOG_E("Error!! SetStringWithDisaply: no memory");
            exit(2);
        }
        *pString = 20;
        *(pString + 1) = '\0';
        *(pString + 2) = '\0';
        *(pString + 3) = '\0';
    }
    else
    {
        pString = malloc((strlen(pString1) + 1) * 2);
        ASSERT(pString != NULL);
        AnsiiToUnicodeString(pString, pString1);
    }
#endif /*__IOT__*/
    pEnum_value = malloc((strlen(enum_value) + 1) * 2);
    AnsiiToUnicodeString(pEnum_value, enum_value);

    /* Leo remove, no need to set limit */
    //      if(CurrMaxStringId >= MAX_STRING_IDS) return;   /* Can't add more than max number of string ids allowed */
    //      if (gpStringMapRes[nStrId]==(U16)-1)
    if (StrIsPopulate[nStrId] == 0)
    {
        CurrMaxStringId++;
        StrIsPopulate[nStrId] = 1;
        StrEnum[nStrId] = pEnum_value;
        Str[nStrId] = pString;
    }
    else    /* 102604 MTK Calvin added */
    {
        fprintf(RepeatIDListFile, "%d\t%s\t\t%s\n", nStrId, enum_value, "String");
    }
}


/*****************************************************************************
 * FUNCTION
 *  AddApp
 * DESCRIPTION
 *  Function to Add a new application into the framework
 * PARAMETERS
 *  nId         [IN]        App Id
 *  pName       [IN]        Application name.
 *  nMinId      [IN]        Minimum Id value supported
 *  nMaxId      [IN]        Maximum Id value
 * RETURNS
 *  void
 *****************************************************************************/
void AddApp(U32 nId, S8 *pName, U16 nMinId, U16 nMaxId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ResourceInfo sInfo;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    sInfo.nAppId = nId;
    sInfo.nMaxId = nMaxId;
    sInfo.nMinId = nMinId;
    sInfo.pValue = pName;
}


/*****************************************************************************
 * FUNCTION
 *  SetString
 * DESCRIPTION
 *  Function to Update the Customizable Resource String & Mapping Array.
 * PARAMETERS
 *  StrId           [IN]
 *  String1         [?]
 *  enum_value      [?]
 *  U16(?)          [OUT]       String Number which is Mapped with the StringId.
 * RETURNS
 *  StringNumber which is mapped with the StringID.(?)
 *****************************************************************************/
void SetString(U16 StrId, S8 *String1, S8 *enum_value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetStringWithDisplay(StrId, String1, enum_value);  /* 040805 CustPack: Calvin revised */
}


/*****************************************************************************
 * FUNCTION
 *  SetAudioWithBuffer
 *****************************************************************************/
void SetAudioWithBufferForceType(U16 nAdoId, S8 *filename, S8 *enum_value, BOOL adoFlag, S32 froce_type)
{
    g_force_ado_type = froce_type;
    SetAudioWithBuffer(nAdoId, filename, enum_value, adoFlag);
    g_force_ado_type = AUTO_ADO_TYPE;
}


/*****************************************************************************
 * FUNCTION
 *  SetAudioWithBuffer
 * DESCRIPTION
 *  Function to copy the audio file to buffer
 * PARAMETERS
 *  nAdoId              [IN]        -> audio ID
 *  filename            [IN]        -> audio resource filename
 *  enum_value          [IN]        -> enun value
 *  adoFlag             [IN]        -> audio flag
 * RETURNS
 *  void
 *****************************************************************************/
void SetAudioWithBuffer(
        U16 nAdoId,
        S8 *filename,
        S8 *enum_value,
        BOOL adoFlag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i;
    U16 found = 0;
    S16 nStrlen;
    S8 upperFileName[MAX_FILENAME_LEN];
    unsigned short *pCurrMaxAudioId;
    unsigned short *pCurrMaxAudioNum;
    AUDIONAME_LIST *pAudioNameList;
    CUSTOM_AUDIO_MAP *pAudioIdMap;
    S8 filename_buffer[BUFFER_SIZE];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (adoFlag == TRUE)
    {
        ExtAudioFlag = TRUE;
        pCurrMaxAudioId = &CurrMaxAudioIdEXT;
        pCurrMaxAudioNum = &CurrMaxAudioNumEXT;
        pAudioNameList = AudioNameListEXT;
        pAudioIdMap = AudioIdMapEXT;
    }
    else
    {
        ExtAudioFlag = FALSE;
        pCurrMaxAudioId = &CurrMaxAudioId;
        pCurrMaxAudioNum = &CurrMaxAudioNum;
        pAudioNameList = AudioNameList;
        pAudioIdMap = AudioIdMap;
    }

    if (*pCurrMaxAudioId >= MAX_AUDIO_IDS_SIZE)
    {
        RESWRI_LOG_W("Id overflow!! current id: %d, max audio id: %d", *pCurrMaxAudioId, MAX_AUDIO_IDS_SIZE); 
        /* Can't add more than max number of audio ids allowed */
        return;
    }

    RESWRI_LOG_V("Load audio resource: id = %d (%s), fileName = %s, adoFlag = %d", nAdoId, enum_value, filename, adoFlag); 
    fprintf(OutputAdoIDFile, "file name%d = %s \n", audio_idx++, filename);

    if (strlen(filename) >= MAX_FILENAME_LEN)
    {
        filename[MAX_FILENAME_LEN - 1] = '\0';
    }
    if (!(strcmp(filename, "")))
    {
        strcpy(filename_buffer, NOAUDIO_FILENAMEBUFFER);

    }
    strncpy(upperFileName, filename, MAX_FILENAME_LEN);
    str_upper(upperFileName, MAX_FILENAME_LEN);

    if (pAudioIdMap[nAdoId].nAudioNum != (U16)-1)
    {
        fprintf(RepeatIDListFile, "%d\t%s\t\t%s\n", nAdoId, enum_value, "Audio");
        return;
    }

    for (i = 0; i < *pCurrMaxAudioNum; i++)
    {
        if (!strcmp(pAudioNameList[i].filename, upperFileName))
        {
            found = 1;
            break;
        }
    }

    g_ressize = 0;

    if (found)
    {
        pAudioIdMap[nAdoId].nAudioNum = i;
        (*pCurrMaxAudioId)++;

        {
            S8 str1[MAX_AUDIO_NAMES_SIZE];
            S8 str2[MAX_AUDIO_NAMES_SIZE];
            U32 i, j;

            strncpy(str1, filename, MAX_AUDIO_NAMES_SIZE);
            str_upper(str1, MAX_AUDIO_NAMES_SIZE);
            for (i = 0; i < g_resado_count; i++)
            {
                strncpy(str2, g_resado_table[i].filename, MAX_AUDIO_NAMES_SIZE);
                str_upper(str2, MAX_AUDIO_NAMES_SIZE);
                if (strcmp(str1, str2) == 0)
                {
                    g_ressize = g_resado_table[i].size;
                    break;
                }
            }
        }
        RESPRTONERECORD(fpAudioResourceUsage, nAdoId, filename, enum_value, g_ressize);
    }
    else
    {
        if (Aload(upperFileName))
        {
            strcpy(pAudioNameList[*pCurrMaxAudioNum].filename, upperFileName);
            pAudioIdMap[nAdoId].nAudioNum = *pCurrMaxAudioNum;
            (*pCurrMaxAudioNum)++;
            (*pCurrMaxAudioId)++;

            g_resado_table[g_resado_count].size = g_ressize;
            strcpy(g_resado_table[g_resado_count].filename, filename);
            g_resado_count ++;
            RESPRTONERECORD(fpAudioResourceUsage, nAdoId, filename, enum_value, g_ressize);
        }
        else
        {
            if (toolFlag)
            {
                resultFailFlag = 1;
            }
            strcpy(AudioNameList[CurrMaxAudioNum].filename, AUDIO_DEFAULT_FILEBUFFER);
            AudioIdMap[nAdoId].nAudioNum = CurrMaxAudioNum;
            CurrMaxAudioNum++;
            CurrMaxAudioId++;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  SetBinaryWithBuffer
 * DESCRIPTION
 *  Function to add binary file to resource
 * PARAMETERS
 *  res_id              [IN]        -> respurce ID
 *  filename            [IN]        -> binary data filename
 *  enum_value          [IN]        -> enun value
 *  custpack_flag             [IN]        -> Custpack flag
 * RETURNS
 *  void
 *****************************************************************************/
void SetBinaryWithBuffer(
        U16 res_id,
        S8 *filename,
        S8 *enum_value,
        binary_type_enum binary_type_flag)
{
    LogSetBinaryWithBuffer(res_id, filename, binary_type_flag);
}



/*****************************************************************************
 * FUNCTION
 *  MenuItemPresent
 * DESCRIPTION
 *  Function to find ImageId
 * PARAMETERS
 *  ItemId      [IN]
 *  U16(?)      [IN]        -> ImageId
 * RETURNS
 *  U16
 *****************************************************************************/
static U16 MenuItemPresent(U16 ItemId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (ItemId == 0)
    {
        RESWRI_LOG_E("Error!! MenuItemPresent: ItemId == 0");
        exit(2);
    }
    if(nCustMenus[ItemId - 1].nParentId < MAX_MENU_ITEMS)
        {
            return TRUE;
        }
    return FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  PrintMenuItems
 * DESCRIPTION
 *  Fills the CUSTOM_MENU structure, for MenuTree Tool usage
 * PARAMETERS
 *  arg1        [?]
 *  U16(?)      [IN]        -> variable argument list
 * RETURNS
 *  void
 *****************************************************************************/
static char is_dummy_code = 0;  /* To check if it needs to generate for menu tree tool or not. */
void PrintMenuItems(char *arg1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /* static U8 is_first=1; */
    FILE *fout;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_dummy_code == 1)
    {
        return;
    }

    if (is_first)
    {
        fout = fopen(OUTPUT_MENUTREE_FILENAME, "w");
        is_first = 0;
    }
    else
    {
        fout = fopen(OUTPUT_MENUTREE_FILENAME, "a");
    }

    if (fout != NULL)
    {
        fprintf(fout, "ADD_APPLICATION_MENUITEM2(%s);\n", arg1);
        fclose(fout);
    }

}


/*****************************************************************************
 * FUNCTION
 *  PrintMenuItems2
 * DESCRIPTION
 *  Fills the CUSTOM_MENU structure, for MenuTree Tool usage
 * PARAMETERS
 *  arg1        [?]
 *  U16(?)      [IN]        -> variable argument list
 * RETURNS
 *  void
 *****************************************************************************/
void PrintMenuItems2(char *arg1, ...)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /* static U8 is_first=1; */
    FILE *fout;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_dummy_code == 1)
    {
        return;
    }

    if (is_first)
    {
        fout = fopen(OUTPUT_MENUTREE_FILENAME, "w");
        is_first = 0;
    }
    else
    {
        fout = fopen(OUTPUT_MENUTREE_FILENAME, "a");
    }

    if (fout != NULL)
    {
        fprintf(fout, "ADD_APPLICATION_MENUITEM3(%s);\n", arg1);
        fclose(fout);
    }

}

/*****************************************************************************
 * FUNCTION
 *  PrintMenuItems5
 * DESCRIPTION
 *  Fills the CUSTOM_MENU structure, for MenuTree Tool usage
 * PARAMETERS
 *  arg1        [?]
 *  U16(?)      [IN]        -> variable argument list
 * RETURNS
 *  void
 *****************************************************************************/
void PrintMenuItems5(char *arg1)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /* static U8 is_first=1; */
    FILE *fout;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_dummy_code == 1)
    {
        return;
    }

    if (is_first)
    {
        fout = fopen(OUTPUT_MENUTREE_FILENAME, "w");
        is_first = 0;
    }
    else
    {
        fout = fopen(OUTPUT_MENUTREE_FILENAME, "a");
    }

    if (fout != NULL)
    {
        fprintf(fout, "ADD_APPLICATION_MENUITEM5(%s);\n", arg1);
        fclose(fout);
    }

}


/*****************************************************************************
 * FUNCTION
 *  SetMenuItem
 * DESCRIPTION
 *  Fills the CUSTOM_MENU structure
 * PARAMETERS
 *  arg1        [IN]
 *  U16(?)      [IN]        -> variable argument list
 * RETURNS
 *  void
 *****************************************************************************/
void SetMenuItem(U16 arg1, ...)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 MemberCounter = 9;
    U16 i = arg1;
    U16 j;
    U16 menuItemID;
    va_list argumentPtr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 091004 MTK Calvin removed to reduce populate time */
    //FILE  *fout;
    //static U8 is_first=1;

    //if (is_first)
    //{
    //   fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"w");
    //   is_first= 0;
    //}
    /* MTK Calvin end */

    va_start(argumentPtr, arg1);

    RESPRT(fpMenuResourceUsage, "NO_APP", -1, i, "unknown", 1, "none");

    /* Need to decide whether menu item already present */
    if (!MenuItemPresent(i))
    {
        /* 091004 MTK Calvin removed fopen and fclose to reduce populate time and replaced fout with OutputMenutreeIDFile */
        /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
        fprintf(OutputMenutreeIDFile, "ADD_APPLICATION_MENUITEM2((", arg1);
        /* fclose(fout); */

        is_dummy_code = 0;
        while (MemberCounter)
        {
            switch (MemberCounter)
            {
                case MENUITEM_ID_TYPE:
                    menuItemID = i - 1;

                    //nCustMenus[menuItemID].nMenuItemId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case PARENT_ITEM_ID_TYPE:
                    nCustMenus[menuItemID].nParentId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case NUMBER_OF_MENUITEMS_TYPE:
                    nCustMenus[menuItemID].nNumofMenuItem = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MENU_ITEM_ORDER_TYPE:
                    if (nCustMenus[menuItemID].nNumofMenuItem == 0)
                    {
                        nCustMenus[menuItemID].nOrderMenuItemId = (U16*) 0;
                    }
                    else
                    {
                        nCustMenus[menuItemID].nOrderMenuItemId = (U16*) malloc(sizeof(U16) * MENU_ITEM_SIZE);
                        for (j = 0; j < nCustMenus[menuItemID].nNumofMenuItem; j++)
                        {
                            /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                            fprintf(OutputMenutreeIDFile, "%d,", i);
                            /* fclose(fout); */
                            nCustMenus[menuItemID].nOrderMenuItemId[j] = i;
                            i = va_arg(argumentPtr, int);
                        }
                    }
                    break;
                case HIDE_FLAG_TYPE:
                    nCustMenus[menuItemID].nFlags |= (((U8)i) & 0x1) << 7;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MOVEABLE_FLAG_TYPE:
                    nCustMenus[menuItemID].nFlags |= ((U8)i) & 0x7F;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case DISPLAY_ATTRIBUTE_TYPE:
                    nCustMenus[menuItemID].nDispAttribute = (U8)(i & 0xFF);
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MENU_ITEM_STRING_ID_TYPE:
                    nCustMenus[menuItemID].nStrId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MENU_ITEM_IMAGE_ID_TYPE:
                    nCustMenus[menuItemID].nImageId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d));\n", i);
                    /* fclose(fout); */
                    break;
            }
            if (MemberCounter != MENU_ITEM_ORDER_TYPE)
            {
                i = va_arg(argumentPtr, int);
            }

            MemberCounter--;
        }
        /* MTK Calvin end */
    }
    else
    {
        is_dummy_code = 1;
    }

    va_end(argumentPtr);
}


/*****************************************************************************
 * FUNCTION
 *  SetMenuItem2
 * DESCRIPTION
 *  Fills the CUSTOM_MENU structure
 * PARAMETERS
 *  arg1        [IN]
 *  U16(?)      [IN]        -> variable argument list
 * RETURNS
 *  void
 *****************************************************************************/
void SetMenuItem2(U16 arg1, ...)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 MemberCounter = 9;
    U16 i = arg1;
    U16 j;
    U16 menuItemID;
    va_list argumentPtr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    va_start(argumentPtr, arg1);

    RESPRT(fpMenuResourceUsage, "NO_APP", -1, i, "unknown", 1, "none");

    /* Need to decide whether menu item already present */
    if (!MenuItemPresent(i))
    {
        fprintf(OutputMenutreeIDFile, "ADD_APPLICATION_MENUITEM2((", arg1);

        is_dummy_code = 0;
        while (MemberCounter)
        {
            switch (MemberCounter)
            {
                case MENUITEM_ID_TYPE:
                    menuItemID = i - 1;

//                    nCustMenus[menuItemID].nMenuItemId = i;
                    fprintf(OutputMenutreeIDFile, "%d,", i);

                    break;

                case PARENT_ITEM_ID_TYPE:
                    nCustMenus[menuItemID].nParentId = i;
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    break;

                case MENU_ITEM_ORDER_TYPE:
                    if ( /* nCustMenus[menuItemID].nNumofMenuItem==0 || */ i == MENU_ITEM_END)
                    {
                        nCustMenus[menuItemID].nOrderMenuItemId = (U16*) 0;
                        fprintf(OutputMenutreeIDFile, "0,");
                        i = va_arg(argumentPtr, int);
                    }
                    else
                    {
                        U16 number_of_child = 0;

                        nCustMenus[menuItemID].nOrderMenuItemId = (U16*) malloc(sizeof(U16) * MENU_ITEM_SIZE);
                        while (i != MENU_ITEM_END)
                        {
                            nCustMenus[menuItemID].nOrderMenuItemId[number_of_child] = i;
                            i = va_arg(argumentPtr, int);

                            number_of_child++;
                        }
                        nCustMenus[menuItemID].nNumofMenuItem = number_of_child;        /* Set number of child field */
                        fprintf(OutputMenutreeIDFile, "%d,", number_of_child);
                        for (i = 0; i < number_of_child; i++)
                        {
                            fprintf(OutputMenutreeIDFile, "%d,", nCustMenus[menuItemID].nOrderMenuItemId[i]);
                        }
                        i = va_arg(argumentPtr, int);   /* read in next argument. */
                    }
                    break;

                case HIDE_FLAG_TYPE:
                    nCustMenus[menuItemID].nFlags |= (((U8)i) & 0x1) << 7;
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    break;

                case MOVEABLE_FLAG_TYPE:
                    nCustMenus[menuItemID].nFlags |= ((U8)i) & 0x7F;
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    break;

                case DISPLAY_ATTRIBUTE_TYPE:
                    nCustMenus[menuItemID].nDispAttribute = (U8)(i & 0xFF);
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    break;

                case MENU_ITEM_STRING_ID_TYPE:
                    nCustMenus[menuItemID].nStrId = i;
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    break;

                case MENU_ITEM_IMAGE_ID_TYPE:
                    nCustMenus[menuItemID].nImageId = i;
                    fprintf(OutputMenutreeIDFile, "%d));\n", i);
                    break;
            }
            if (MemberCounter != MENU_ITEM_ORDER_TYPE)
            {
                i = va_arg(argumentPtr, int);
            }

            if (MemberCounter == PARENT_ITEM_ID_TYPE)   /* Skip NUMBER_OF_MENUITEMS_TYPE field */
            {
                MemberCounter -= 2;
            }
            else
            {
                MemberCounter--;
            }
        }
    }
    else
    {
        is_dummy_code = 1;
    }

    va_end(argumentPtr);
}


/*****************************************************************************
 * FUNCTION
 *  SetMenuItem5
 * DESCRIPTION
 *  Fills the CUSTOM_MENU structure
 * PARAMETERS
 *  arg1        [IN]
 *  U16(?)      [IN]        -> variable argument list
 * RETURNS
 *  void
 *****************************************************************************/
void SetMenuItem5(U16 arg1, ...)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    U16 MemberCounter = 9;
    U16 i = arg1;
    U16 j;
    U16 menuItemID;
    va_list argumentPtr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 091004 MTK Calvin removed to reduce populate time */
    //FILE  *fout;
    //static U8 is_first=1;

    //if (is_first)
    //{
    //   fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"w");
    //   is_first= 0;
    //}
    /* MTK Calvin end */

    va_start(argumentPtr, arg1);

    RESPRT(fpMenuResourceUsage, "NO_APP", -1, i, "unknown", 1, "none");

    /* Need to decide whether menu item already present */
    if (!MenuItemPresent(i))
    {
        /* 091004 MTK Calvin removed fopen and fclose to reduce populate time and replaced fout with OutputMenutreeIDFile */
        /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
        fprintf(OutputMenutreeIDFile, "ADD_APPLICATION_MENUITEM5((", arg1);
        /* fclose(fout); */

        is_dummy_code = 0;
        while (MemberCounter)
        {
            switch (MemberCounter)
            {
                case MENUITEM_ID_TYPE:
                    menuItemID = i - 1;

                    //nCustMenus[menuItemID].nMenuItemId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case PARENT_ITEM_ID_TYPE:
                    nCustMenus[menuItemID].nParentId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case NUMBER_OF_MENUITEMS_TYPE:
                    nCustMenus[menuItemID].nNumofMenuItem = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MENU_ITEM_ORDER_TYPE:
                    if (nCustMenus[menuItemID].nNumofMenuItem == 0)
                    {
                        nCustMenus[menuItemID].nOrderMenuItemId = (U16*) 0;
                    }
                    else
                    {
                        nCustMenus[menuItemID].nOrderMenuItemId = (U16*) malloc(sizeof(U16) * MENU_ITEM_SIZE);
                        for (j = 0; j < nCustMenus[menuItemID].nNumofMenuItem; j++)
                        {
                            /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                            fprintf(OutputMenutreeIDFile, "%d,", i);
                            /* fclose(fout); */
                            nCustMenus[menuItemID].nOrderMenuItemId[j] = i;
                            i = va_arg(argumentPtr, int);
                        }
                    }
                    break;
                case HIDE_FLAG_TYPE:
                    nCustMenus[menuItemID].nFlags |= (((U8)i) & 0x1) << 7;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MOVEABLE_FLAG_TYPE:
                    nCustMenus[menuItemID].nFlags |= ((U8)i) & 0x7F;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case DISPLAY_ATTRIBUTE_TYPE:
                    nCustMenus[menuItemID].nDispAttribute = (U8)(i & 0xFF);
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MENU_ITEM_STRING_ID_TYPE:
                    nCustMenus[menuItemID].nStrId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d,", i);
                    /* fclose(fout); */
                    break;
                case MENU_ITEM_IMAGE_ID_TYPE:
                    nCustMenus[menuItemID].nImageId = i;
                    /* fout = fopen(OUTPUT_MENUTREE_ID_FILENAME,"a"); */
                    fprintf(OutputMenutreeIDFile, "%d));\n", i);
                    /* fclose(fout); */
                    break;
            }
            if (MemberCounter != MENU_ITEM_ORDER_TYPE)
            {
                i = va_arg(argumentPtr, int);
            }

            MemberCounter--;
        }
        /* MTK Calvin end */
    }
    else
    {
        is_dummy_code = 1;
    }

    va_end(argumentPtr);
}








/* Menuitem reduce memory, move registe hilite handlers to resgen */
S32 HiliteHdlrCount = 0;    /* count number of menuitems with hilite handler */
S32 HintHdlrCount = 0;      /* count number of menuitems with hint handler */

extern RESGEN_MENU_HILITE_HANDLER   nMenuHiliteHandlers[];
extern RESGEN_MENU_HINT_HANDLER     nMenuHintHandlers[];

/*****************************************************************************
 * FUNCTION
 *  SetMenuHiliteHandler
 * DESCRIPTION
 *  This Function will set MenuID and Hilite handler.
 * PARAMETERS
 *  MenuID          [IN]
 *  MenuIDEnum      [IN]
 *  FuncName        [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void SetMenuHiliteHandler(U16 MenuID, S8 *MenuIDEnum, S8 *FuncName)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MenuID >= MAX_MENU_ITEMS)
    {
        /* Invalid menu ID */
        RES_PRINT_INFO("SetMenuHiliteHandler Invalid menuID[%d][%s]\n", MenuID, MenuIDEnum);
        return;
    }

    if (nMenuHiliteHandlers[MenuID].HiliteFuncName[0] != '\0')
    {
        /* Menu ID have registered */
        RES_PRINT_INFO("SetMenuHiliteHandler MenuID[%d][%s] have registered\n", MenuID, MenuIDEnum);
        return;
    }

    nMenuHiliteHandlers[MenuID].nMenuItemId = MenuID;
    strncpy(nMenuHiliteHandlers[MenuID].MenuItemIdEnum, MenuIDEnum, MAX_MENUID_ENUM);
    strncpy(nMenuHiliteHandlers[MenuID].HiliteFuncName, FuncName, MAX_HANDLER_NAME);
    HiliteHdlrCount++;
}


/*****************************************************************************
 * FUNCTION
 *  SetMenuHintHandler
 * DESCRIPTION
 *  This Function will set MenuID and Hint handler.
 * PARAMETERS
 *  MenuID      [IN]
 *  MenuIDEnum  [IN]
 *  FuncName    [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void SetMenuHintHandler(U16 MenuID, S8 *MenuIDEnum, S8 *FuncName)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (MenuID >= MAX_MENU_ITEMS)
    {
        /* Invalid menu ID */
        RES_PRINT_INFO("SetMenuHintHandler Invalid menuID[%d][%s]\n", MenuID, MenuIDEnum);
        return;
    }

    if (nMenuHintHandlers[MenuID].HintFuncName[0] != '\0')
    {
        /* Menu ID have registered */
        RES_PRINT_INFO("SetMenuHintHandler MenuID[%d][%s] have registered\n", MenuID, MenuIDEnum);
        return;
    }

    nMenuHintHandlers[MenuID].nMenuItemId = MenuID;
    strncpy(nMenuHintHandlers[MenuID].MenuItemIdEnum, MenuIDEnum, MAX_MENUID_ENUM);
    strncpy(nMenuHintHandlers[MenuID].HintFuncName, FuncName, MAX_HANDLER_NAME);
    HintHdlrCount++;
}

/*****************************************************************************
 * FUNCTION
 *  Get_Image_Identifier
 * DESCRIPTION
 *  Identifies the image , BMP , ppf etc
 *
 *  This function will be refined later when multiple
 *  image type will be supported by the frame work
 *  rt. now it just a added hook to make the design complete
 * PARAMETERS
 *  extension_type      [IN]
 * RETURNS
 *  U8
 *****************************************************************************/
static U8 Get_Image_Identifier(S32 extension_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (extension_type < 0)
    {
        ret = 0;
    }

    else if (extension_type == 0)
    {
        ret = 1;
    }

    return (U8) ret;

}




/*****************************************************************************
 * FUNCTION
 *  Load_Audio_Data
 * DESCRIPTION
 *  load and write audio header and data
 * PARAMETERS
 *  output_file             [IN]        -> Name of the file to which buffer
 *  input_file              [IN]        ->  Name of the input audio file
 *  audio_identifier        [IN]        -> audio identifier
 *  is(?)                   [IN]        To be written
 * RETURNS
 *  S32 --> file size
 *****************************************************************************/
static S32 Load_Audio_Data(
        FILE *output_file,
        FILE *input_file,
        U8 audio_identifier)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 file_size, i, o = 0;
    U8 ch;
    U32 size;
    S8 *source_buf = NULL, *work_buf = NULL;
    CMIDI_Handle *cmidi_hdl;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fseek(input_file, 0, SEEK_END);
    file_size = ftell(input_file);
    fseek(input_file, 0, SEEK_SET);


    if (audio_identifier == AUDIO_TYPE_MID && g_force_ado_type != FORCE_ADO_MIDI)
    {
        /* If mid file, convert to CMidi */
        source_buf = (S8*)malloc(file_size);
        cmidi_hdl = (CMIDI_Handle*)malloc(sizeof(CMIDI_Handle));
        if (cmidi_hdl == NULL || source_buf == NULL)
        {
            fprintf(stderr, "Load_Audio_Data cmidi_hdl memory not available\n");
            RESWRI_LOG_E("Error!! Load_Audio_Data cmidi_hdl memory not available");
            exit(2);
        }
        size = fread(source_buf, 1, file_size, input_file);
        if (size != file_size)
        {
            fprintf(stderr, "Load_Audio_Data read file err\n");
            RESWRI_LOG_E("Error!! Load_Audio_Data read file err");
            exit(2);
        }
        
        cmidi_hdl->file_len = file_size;
        cmidi_hdl->midifile = source_buf;
        cmidi_hdl->blockperiod = 18;

        RESWRI_LOG_V("Load_Audio_Data(): file size = %d bytes, trying to get size of work_buf with CMIDI_GetBufSize()", file_size);
        CMIDI_GetBufSize(cmidi_hdl, &size);
        work_buf= (S8*)malloc(sizeof(unsigned char)*size);
        RESWRI_LOG_V("Load_Audio_Data(): Got work_buf: ADDR = %x, size = %d (bytes)", work_buf,  size);

        if (work_buf == NULL)
        {
            fprintf(stderr, "Load_Audio_Data work_buf memory not available\n");
            RESWRI_LOG_E("Error!! Load_Audio_Data work_buf memory not available");
            exit(2);
        }

        if (!CMIDI_Convert(cmidi_hdl, work_buf, &size))
        {
            free(source_buf);
            free(cmidi_hdl);
            free(work_buf);

            fprintf(stderr, "Load_Audio_Data midi convert err\n");
            RESWRI_LOG_E("Error!! Load_Audio_Data midi convert err");
            exit(2);
        }

        if (toolFlag)
        {
            fprintf(
                dest_file,
                "%c%c%c%c%c%c%c%c",
                audio_identifier,
                size & 0xff,
                (size & 0xff00) >> 8,
                (size & 0xff0000) >> 16,
                (size & 0xff000000) >> 24,
                0,
                0,
                0);
        }
        else
        {
            fprintf(
                output_file,
                "\n\t0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x00, 0x00, 0x00,\n\t",
                audio_identifier,
                size & 0xff,
                (size & 0xff00) >> 8,
                (size & 0xff0000) >> 16,
                (size & 0xff000000) >> 24);
        }

        for (i = 0; i < size; i++)
        {
            if (toolFlag)
            {
                fputc(cmidi_hdl->midifile[i], dest_file);
            }
            else
            {
                fprintf(output_file, "0x%02X, ", cmidi_hdl->midifile[i]);
                o++;
                if ((o % 16) == 0)
                {
                    fprintf(output_file, "\n\t");
                }
            }
        }

        free(source_buf);
        free(cmidi_hdl);
        free(work_buf);

        return size + 8;

    }
    else
    {
        if (toolFlag)
        {
            fprintf(
                dest_file,
                "%c%c%c%c%c%c%c%c",
                audio_identifier,
                file_size & 0xff,
                (file_size & 0xff00) >> 8,
                (file_size & 0xff0000) >> 16,
                (file_size & 0xff000000) >> 24,
                0,
                0,
                0);
        }
        else
        {
            fprintf(
                output_file,
                "\n\t0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x00, 0x00, 0x00,\n\t",
                audio_identifier,
                file_size & 0xff,
                (file_size & 0xff00) >> 8,
                (file_size & 0xff0000) >> 16,
                (file_size & 0xff000000) >> 24);
        }

        for (i = 0; i < file_size; i++)
        {
            ch = fgetc(input_file);

            if (toolFlag)
            {
                fputc(ch, dest_file);
            }
            else
            {
                fprintf(output_file, "0x%02X, ", ch);
                o++;
                if ((o % 16) == 0)
                {
                    fprintf(output_file, "\n\t");
                }
            }
        }

        return file_size + 8;

    }
}


/*****************************************************************************
 * FUNCTION
 *  Extract_Name
 * DESCRIPTION
 *  Exract image name from the supplied string
 * PARAMETERS
 *  dest            [OUT]       -> Extrected file name from string
 *  src             [IN]        -> string containing file name and path
 * RETURNS
 *  void
 *****************************************************************************/
void Extract_Name(S8 *dest, S8 *src, U32 ExtFlag)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 iLen = strlen(src);
    U16 nCount = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (iLen)
    {
        if ((src[nCount] == '.') || (src[nCount] == '-') || (src[nCount] == ' ') || (src[nCount] == '\\'))
        {
            dest[nCount] = '_';
        }
        else
        {
            dest[nCount] = src[nCount];
        }

        ++nCount;
        --iLen;
    }

    /* __CUSTPACK_MULTIBIN Calvin BEGIN */
    if (ExtFlag == 1)   /* 040805 CustPack: Calvin added */
    {
        dest[nCount] = '_'; /* add a '_' in the end to distinguish from the original */
        dest[nCount + 1] = '\0';
    }
    /* __CUSTPACK_MULTIBIN Calvin END */
    else
    {
        dest[nCount] = '\0';
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  isMainmenuImage
 * DESCRIPTION
 *  Decide if the iamge is used for Mainmenu picture
 * PARAMETERS
 *  path        [IN]        -> string containing file name and path
 * RETURNS
 *  U8 --> 1: Matrix Mainmenu picture, 0: Not Matrix mainmenu picture
 *****************************************************************************/
static MMI_BOOL isMainmenuImage(S8 *path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((strstr(path, "\\MATRIX\\") != NULL) && (strstr(path, ".GIF") != NULL))
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


/* __CUSTPACK_MULTIBIN Calvin BEGIN */
/* 040805 CustPack: Calvin added */


/* Calvin end */
/* __CUSTPACK_MULTIBIN Calvin END */


/*****************************************************************************
 * FUNCTION
 *  Aload
 * DESCRIPTION
 *  Load the file audio to buffer and writes to CustAdoRes.c
 * PARAMETERS
 *  string      [IN]        -> audio resource filename
 * RETURNS
 *  void* --> buffer containing Audio data
 *****************************************************************************/
MMI_BOOL Aload(S8 *string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *audio_data_file = NULL;
    MMI_BOOL failure_flag;
    U8 audio_identifier;
    S32 nAudioSize = 0;
    S16 filenameLen;
    char *curr_output_data_filename;
    FILE *output_data_file = NULL;
    S8 *output_audio_names = NULL;
    S8 filename_buffer[BUFFER_SIZE];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_ressize = 0;
    
    RESWRI_LOG_V("Aload: %s", string); 
    
    if (ExtAudioFlag == TRUE)
    {
        curr_output_data_filename = AUDIO_OUTPUT_DATA_FILENAME_EXT;
    }
    else
    {
        curr_output_data_filename = AUDIO_OUTPUT_DATA_FILENAME;
    }

    if (toolFlag == 1)
    {
        curr_output_data_filename = "temp_audio";
    }

    strcpy(filename_buffer, curr_output_data_filename);

    output_data_file = fopen(filename_buffer, "ab");
    while (output_data_file == NULL)
    {
        Sleep(50);
        output_data_file = fopen(filename_buffer, "ab");
    }

    output_audio_names = (S8*) malloc(MAX_FILENAME_LEN);
    strcpy(filename_buffer, string);
    if (!(strcmp(filename_buffer, "")))
    {
        strcpy(filename_buffer, NOAUDIO_FILENAMEBUFFER);
    }

    Extract_Name(output_audio_names, filename_buffer, ExtAudioFlag);

    failure_flag = MMI_FALSE;
    filenameLen = strlen(filename_buffer);

    if (failure_flag == MMI_FALSE)
    {
        audio_data_file = fopen(filename_buffer, "rb");
        if (audio_data_file == NULL)
        {
            /* Add extension add search */
            if (toolFlag == 0)
            {
                FILE *fail = fopen(".\\\\debug\\\\fail.txt", "a+");

                if (fail != NULL)
                {
                    fprintf(fail, "%s\n", filename_buffer);
                    MYFCLOSE(fail);
                }
            }

            failure_flag = MMI_FALSE;
        }
        else
        {
            failure_flag = MMI_TRUE;
            fseek(audio_data_file, 0, SEEK_END);
            nAudioSize = ftell(audio_data_file);
            fseek(audio_data_file, 0, SEEK_SET);
        }


        if (failure_flag == MMI_TRUE)
        {
            if (nAudioSize == 0)
            {
                audio_identifier = AUDIO_TYPE_INVALID;
            }
            else
            {
                audio_identifier = ExtractExtension(filename_buffer, RES_AUDIO);
            }

            /*   Load the data  */
#if defined(__MMI_RESOURCE_AUDIO_COMPRESS__)
            if (!toolFlag)
            {
                int array_size = 0;
                U8 *buffer = NULL;
                U8 *dest_buf = NULL;
                U32 dest_size = 0;
                U32 file_size, ret, i, o = 0;
                FILE *pFile;

                if (res_compress_count >= MAX_COMPRESSED_ITEM)
                {
                    fprintf(stderr, "[ResZip] Reach Max compress item count, please change MAX_COMPRESSED_ITEM [%d]\n", MAX_COMPRESSED_ITEM);
                    RESWRI_LOG_E("[ResZip] Error!! Reach Max compress item count, please change MAX_COMPRESSED_ITEM [%d]", MAX_COMPRESSED_ITEM);
                    exit(2);
                }

                fseek(audio_data_file, 0, SEEK_END);
                file_size = ftell(audio_data_file);
                fseek(audio_data_file, 0, SEEK_SET);

                array_size = file_size + 8;
                dest_size = array_size*2;
                buffer = malloc(array_size);
                dest_buf = malloc(array_size * 2);

                sprintf(
                    buffer,
                    "%c%c%c%c%c%c%c%c",
                    audio_identifier,
                    file_size & 0xff,
                    (file_size & 0xff00) >> 8,
                    (file_size & 0xff0000) >> 16,
                    (file_size & 0xff000000) >> 24,
                    0,
                    0,
                    0);

                ret = fread(buffer+8, sizeof(U8), file_size, audio_data_file);

                if (ret != file_size)
                {
                    fprintf(stderr, "[ResZip] Read file err [%s]\n", filename_buffer);
                    RESWRI_LOG_E("[ResZip] Error!! Read file err [%s]", filename_buffer);
                    exit(2);
                }

                if (ret != 0)
                {
                    compress2(dest_buf, &dest_size, buffer, array_size, Z_BEST_COMPRESSION);
                }


                if (ret != 0 && dest_size != 0 && array_size/dest_size >= 2)
                {
                    if(pFile = fopen(ZIP_OUTPUT_FILE, "a"))
                    {
                        fprintf(pFile, "%s,%d,%d,%d,Yes\n", output_audio_names, array_size, dest_size, array_size-dest_size);
                        fclose(pFile);
                    }

                    /* compress rate >= 50% then compress, else write directly*/
                    fprintf(output_data_file, "__align(4) U8 %s[%d];\n", output_audio_names, array_size);
                    fprintf(output_data_file, "__align(4) const U8 %s_zip%s", output_audio_names, OUTPUT_AUDIO_NAMES_END);

                    for (i = 0; i < dest_size-1; i++)
                    {
                        fprintf(output_data_file, "0x%02X, ", dest_buf[i]);
                        o++;
                        if ((o % 16) == 0)
                        {
                            fprintf(output_data_file, "\n\t");
                        }
                    }
                    fprintf(output_data_file, "0x%02X", dest_buf[i]);
                    fprintf(output_data_file, "\n };\n");

                    res_compress_data[res_compress_count].ro_len = dest_size;
                    res_compress_data[res_compress_count].zi_len = array_size;
                    strcpy(res_compress_data[res_compress_count].ro_name, output_audio_names);
                    strcpy(res_compress_data[res_compress_count].zi_name, output_audio_names);
                    strcat(res_compress_data[res_compress_count].ro_name, "_zip");

                    res_compress_count++;
                }
                else
                {
                    if(pFile = fopen(ZIP_OUTPUT_FILE, "a"))
                    {
                        fprintf(pFile, "%s,%d,%d,%d,No\n", output_audio_names, array_size, dest_size, array_size-dest_size);
                        fclose(pFile);
                    }
                    /* Construct the data structure name */
                    fprintf(output_data_file, "__align(4) const U8 %s%s", output_audio_names, OUTPUT_AUDIO_NAMES_END);

                    g_ressize = Load_Audio_Data(output_data_file, audio_data_file, audio_identifier);
                    fprintf(output_data_file, "\n };\n");
                }

                free(buffer);
                free(dest_buf);
            }
            else
#endif /* __MMI_RESOURCE_AUDIO_COMPRESS__ */
            {
                /* Construct the data structure name */
                fprintf(output_data_file, "__align(4) const U8 %s%s", output_audio_names, OUTPUT_AUDIO_NAMES_END);

                g_ressize = Load_Audio_Data(output_data_file, audio_data_file, audio_identifier);

                fprintf(output_data_file, "\n };\n");
            }
        }
    }

    MYFCLOSE(audio_data_file);
    MYFCLOSE(output_data_file);
    free(output_audio_names);

    return failure_flag;
}

/* 101205 audio resource Calvin End */


/*****************************************************************************
 * FUNCTION
 *  ClearHWIMageFile
 * DESCRIPTION
 *  Clear image file
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ClearHWIMageFile(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FILE *fp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fp = fopen(OUTPUT_DATA_FILENAME, "w+");
    if (fp)
    {
        fprintf(fp, "#if ( !defined (__MTK_TARGET__) )\n\t#define __align(x)\n#endif\n");
        fclose(fp);
    }

    /* __CUSTPACK_MULTIBIN Calvin BEGIN */
    fp = fopen(OUTPUT_DATA_FILENAME_EXT, "w+"); /* 040805 CustPack: Calvin added */
    /* __CUSTPACK_MULTIBIN Calvin END */
    if (fp)
    {
        fprintf(fp, "#if ( !defined (__MTK_TARGET__) )\n\t#define __align(x)\n#endif\n");
        fclose(fp);
    }

    /* 101205 audio resource Calvin Satrt */
    fp = fopen(AUDIO_OUTPUT_DATA_FILENAME, "w+");
    if (fp)
    {
        fprintf(fp, "#if ( !defined (__MTK_TARGET__) )\n\t#define __align(x)\n#endif\n");
        fclose(fp);
    }

    fp = fopen(AUDIO_OUTPUT_DATA_FILENAME_EXT, "w+");
    if (fp)
    {
        fprintf(fp, "#if ( !defined (__MTK_TARGET__) )\n\t#define __align(x)\n#endif\n");
        fclose(fp);
    }
    /* 101205 audio resource Calvin End */

    fp = fopen(FONT_OUTPUT_DATA_FILENAME, "w+");
    if (fp)
    {
        fprintf(fp, "#if !defined(__MTK_TARGET__)\n    #define __align(x)\n#endif /* !defined(__MTK_TARGET__) */\n");
        fclose(fp);
    }

    /* 100206 ENFB support Satrt */
#ifdef __MMI_RESOURCE_ENFB_SUPPORT__
    enfb_img_data_file = fopen(ENFB_IMAGE_DATA_FILENAME, "w+");

    if (enfb_img_data_file)
    {
        fclose(enfb_img_data_file);
    }
    enfb_img_data_file = fopen(ENFB_IMAGE_DATA_FILENAME, "ab");
#endif
    /* 100206 ENFB support End */

#ifdef __MMI_FONT_THIRD_ROM_SUPPORT__
    enfb_font_data_file = fopen(ENFB_FONT_DATA_FILENAME, "w+");

    if (enfb_font_data_file)
    {
        fclose(enfb_font_data_file);
    }
    enfb_font_data_file = fopen(ENFB_FONT_DATA_FILENAME, "ab");
#endif


}
