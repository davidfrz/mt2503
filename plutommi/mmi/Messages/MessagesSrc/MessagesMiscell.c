/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * MessagesMiscell.c
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for MMI SMS APP.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
/**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */
/******************************************************************************

   FILENAME : MessagesMiscell.c

   PURPOSE     : 

   REMARKS     : nil

   AUTHOR      : Magesh k 

   DATE     : 01-01-2003

******************************************************************************/
#include "MMI_features.h"
/*  Include: MMI header file */
#include "MMIDataType.h"
#include "kal_general_types.h"
#include "GlobalResDef.h"
#include "ems.h"
#include "MMI_common_app_trc.h"
#include "kal_trace.h"
#include "GlobalConstants.h"
#include "gui_ems.h"
#include "custom_led_patterns.h"
#include "GpioSrvGprot.h"
#include "wgui_categories_util.h"
#include "wgui_categories.h"
#include "kal_public_api.h"
#include "custom_phb_config.h"
#include "custom_mmi_default_value.h"
#include "Unicodexdcl.h"
#include "string.h"
#include "gui_typedef.h"
#include "gui_data_types.h"
#include "UmSrvDefs.h"
#include "TimerEvents.h"
#include "mmi_frm_input_gprot.h"
#include "mmi_frm_mem_gprot.h"
#include "mmi_frm_events_gprot.h"
#include "mmi_frm_history_gprot.h"
#include "mmi_frm_scenario_gprot.h"
#include "mmi_frm_timer_gprot.h"
#include "gui_config.h"
#include "ps_public_enum.h"
#include "Gsm7BitNationalLang.h"
#include "CustDataRes.h"
#include "stdlib.h"
#include "kal_release.h"
#include "wgui_categories_ems.h"
#include "SmsAppType.h"
#include "SmsSrvGprot.h"
#include "mmi_rp_app_sms_def.h"
#include "NotificationGprot.h"
#include "PhbSrvGprot.h"
#include "MMI_trc_Int.h"
#ifdef __MMI_BPP20_SUPPORT__
#include "app_mem.h"
#endif
#ifdef __MMI_OP12_MESSAGE_VOICEMAIL__
#include "mmi_msg_struct.h"
#endif

#include "mmi_msg_context.h"
#include "MessagesMiscell.h"
#include "MessagesExDcl.h"
#include "SmsGuiInterfaceProt.h"
#include "SmsGuiInterfaceType.h"
#include "SmsPsHandler.h"
#include "SmsAppGprot.h"
#include "SmsAppProt.h"
#include "SmsAppUtil.h"
#include "CbsAppGprot.h"
#include "wgui_ems.h"
#include "AlarmFrameworkProt.h"

#ifdef __MMI_MESSAGES_CLUB__
#include "mmiapi_res.h"
#endif 

#if defined(OBIGO_Q03C_MMS_V01)
#include "WapResDef.h"
#endif 

#include "Voicemail.h"
#include "SmsAppSetting.h"
#include "SmsAppProt.h"

#if defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
#ifdef __UM_SUPPORT__
#include "mmi_rp_app_unifiedmessage_def.h"
#endif
#include "smsal_l4c_enum.h"
#endif
#include "UMGProt.h"

#if (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__))
#include "UcResDef.h"
#include "UcAppGprot.h"
#endif /* (defined(__MMI_UNIFIED_COMPOSER__) || defined(__MMI_MMS_STANDALONE_COMPOSER__)) */ 

#ifdef __MMI_WLAN_FEATURES__
#ifdef __MMI_VOIP__
#include "VoIPGProt.h"
#endif /* __MMI_VOIP__ */
#endif /* __MMI_WLAN_FEATURES__ */

#if defined(__MMI_PROV_MESSAGE_SUPPORT__) && !defined(__MMI_PROV_IN_UM__)
#include "ProvBoxAPPGProt.h"
#include "mmi_rp_app_provbox_def.h"
#endif

#if defined(__MMI_IMPS__)
/* under construction !*/
/* under construction !*/
#endif
#include "mmi_frm_utility_gprot.h"
#ifdef __QQIM_SUPPORT__
#include "TencentQQ_vm.h"
#endif

#include "Conversions.h"

#ifdef __MMI_URI_AGENT__
#include "UriAgentSrvGprot.h"

#ifdef __MMI_BROWSER_2__
#include "BrowserGprots.h"
#endif /* __MMI_BROWSER_2__ */

static void mmi_msg_uri_request_handle(
 			srv_uriagent_appid_enum ura_appid,
 			char *url,
 			char *param,
 			srv_uriagent_options_enum options,
 			srv_uriagent_uri_request_hdlr_cb callback);
#endif /* __MMI_URI_AGENT__ */


#if defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
#include "HomeScreenOp11V32Def.h"
#include "HomeScreenOp11V32Gprot.h"           
#endif /* defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__) */

#if defined(__MMI_VUI_HOMESCREEN__)
#include "IdleRecentEventGprot.h"
#endif

#include "IdleNotificationManagerGprot.h"

#include "EmsMiscell.h"

#include "UcmSrvGprot.h"
#include "MenucuiGprot.h"
#include "IdleGprot.h"
#if defined(__MMI_SCREEN_SAVER__)
#include "ScrSaverGprot.h"
#endif
#include "ScrLockerGprot.h"
#include "SimCtrlSrvGProt.h"
#include "ProfilesSrvGprot.h"
#include "ModeSwitchSrvGprot.h"
#ifdef __MMI_WLAN_FEATURES__
#include "NetSetSrvGprot.h"
#endif /* __MMI_WLAN_FEATURES__ */
#include "ReminderSrvGprot.h"
#include "wgui_categories_text_viewer.h"

#include "UseDetailCuiGprot.h"

#include "NotificationSettingSrvGprot.h"

#include "mmi_rp_srv_status_icons_def.h"

typedef struct
{
    MMI_ID owner_gid;
    WCHAR msg_waiting_info[MMI_NEW_MSG_WAITING_INFO_LEN];
} mmi_sms_waiting_ind_struct;

#ifdef __MMI_OP11_PROF_SOUND__
/* under construction !*/
/* under construction !*/
#endif /* __MMI_OP11_PROF_SOUND__ */

static FuncPtr endKeyDownFuncPtr = NULL;
static U16 messagesCurrScrnID;
static MMI_ID mmi_sms_class0_gid = GRP_ID_INVALID;
static MMI_BOOL keep_class0_scrn = MMI_FALSE;

#if !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)
static mmi_sms_waiting_ind_struct *msg_waiting_ind_cntx;
#endif /* !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)*/

extern msg_msgbox_info_struct msgbox_info;
extern EMSData *GetEMSDataForView(EMSData **p, U8 force);

extern const U8 AsciiToDefaultArray[];
extern const U8 ExtendedAsciiToDefaultArray[];
extern const U8 DefaultToExtendedAsciiArray[];
extern const U8 DefaultToAsciiArray[];

#ifdef __SMS_R8_NATION_LANGUAGE__
#include "Gsm7BitNationalLang.h"
#include "SSCStringHandle.h"

extern sLanguageDetails *gLanguageArray;
extern U16 gCurrLangIndex;
#endif /* __SMS_R8_NATION_LANGUAGE__ */

#ifndef __ULC_SLIM_EMS__
extern void MoveCursorToPosition(EMSData *data, EMSPosition *dst);
#endif

#if defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
typedef struct
{
    U16 max_item;
    U16 cur_itme;
    mmi_op11_hs32_shct_data_struct *shct_data_p;
}mmi_sms_op11_data_struct;
static mmi_sms_op11_data_struct *mmi_sms_op11_data = NULL;
#endif /* defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__) */

#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
extern mmi_sms_hilite_struct hilite_cntx;

static void mmi_sms_class0_view_hilite_cb(S32 idx);
static void mmi_sms_class0_view_hilite_click_cb(S32 idx);
#endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */

#ifdef __MMI_MESSAGE_SMS_USE_DETAIL__
static void mmi_msg_entry_class_0_opt_use_number(MMI_ID group_id);
#endif

/*****************************************************************************
 * FUNCTION
 *  IsMMIInIdleState
 * DESCRIPTION
 *  Check if MMI is in idle state (idle screen or screen saver)
 * PARAMETERS
 *  void
 * RETURNS
 *  1: idle, 0: non-idle
 *****************************************************************************/
U16 IsMMIInIdleState(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_on_dile = mmi_idle_is_active();
#if defined(__MMI_SCREEN_SAVER__)
    MMI_BOOL saver_is_active = mmi_scr_saver_is_active();
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_SCREEN_SAVER__)
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_IS_MMI_IN_IDLE_STATE, is_on_dile, saver_is_active);
#endif

    if (is_on_dile
	#if defined(__MMI_SCREEN_SAVER__)
		|| saver_is_active
	#endif
	)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  IsKeyPadLockState
 * DESCRIPTION
 *  Check if MMI is in keypad lock state
 * PARAMETERS
 *  void
 * RETURNS
 *  keypad lock flag (1: lock, 0: unlock)
 *****************************************************************************/
U8 IsKeyPadLockState(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL is_locked = mmi_scr_locker_is_locked();

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_IS_KEYPAD_LOCK_STATE, is_locked);
    return is_locked;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_set_phb_send_case
 * DESCRIPTION
 *  Set PhbSmsInterfaceState
 * PARAMETERS
 *  PhbSmsInterfaceState        [IN]        
 *  a(?)                        [IN]        PhbSmsInterfaceState
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_set_phb_send_case(U8 PhbSmsInterfaceState)
{
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrEndKeyDownHandler
 * DESCRIPTION
 *  Get current end key down handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void GetCurrEndKeyDownHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_GET_CURR_END_KEY_DOWN_HANDLER);
    endKeyDownFuncPtr = NULL;
    endKeyDownFuncPtr = GetKeyHandler(KEY_END, KEY_EVENT_DOWN);
}


/*****************************************************************************
 * FUNCTION
 *  ExecCurrEndKeyDownHandler
 * DESCRIPTION
 *  Execute current end key down handler
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExecCurrEndKeyDownHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_EXEC_CURR_END_KEY_DOWN_HANDLER);

    g_msg_cntx.isNewMessagePopup = MMI_FALSE;

    if (endKeyDownFuncPtr != NULL)
    {
        (*endKeyDownFuncPtr) ();
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetMessagesCurrScrnID
 * DESCRIPTION
 *  Get MSG current screen ID
 * PARAMETERS
 *  void
 * RETURNS
 *  messagesCurrScrnID
 *****************************************************************************/
U16 GetMessagesCurrScrnID(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_GET_MESSAGE_CURR_SCRN_ID, messagesCurrScrnID);
    return messagesCurrScrnID;
}


/*****************************************************************************
 * FUNCTION
 *  SetMessagesCurrScrnID
 * DESCRIPTION
 *  Set MSG current screen ID
 * PARAMETERS
 *  scrnID      [IN]        
 *  a(?)        [IN]        Screen ID
 * RETURNS
 *  void
 *****************************************************************************/
void SetMessagesCurrScrnID(U16 scrnID)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_SET_MESSAGE_CURR_SCRN_ID);
    messagesCurrScrnID = scrnID;
}


#if defined(__MMI_MESSAGES_EMS__)
/*****************************************************************************
 * FUNCTION
 *  EnableDisableAudioPlayback
 * DESCRIPTION
 *  Decide to enable/disable audio playback
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void EnableDisableAudioPlayback(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) <= 0) &&
        srv_prof_if_can_ring())
    {
        EMS_enable_audio_playback();
    }
    else
    {
        EMS_disable_audio_playback();
    }
}
#endif /* defined(__MMI_MESSAGES_EMS__) */ 


/*****************************************************************************
 * FUNCTION
 *  PlayMessageArrivalTone
 * DESCRIPTION
 *  Play message arrival tone
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void PlayMessageArrivalTone(void)
{
    /* phase out */
}


/*****************************************************************************
 * FUNCTION
 *  InitMessageProtocolEventHandlers
 * DESCRIPTION
 *  Init MSG protocol event handler when boot up
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitMessageProtocolEventHandlers(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_msg_init_msg_data();
#ifdef __MMI_OP12_MESSAGE_VOICEMAIL__
    mmi_msg_set_protocol_event_handler();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  InitMessagesApp
 * DESCRIPTION
 *  Init MSG application when go to opening screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void InitMessagesApp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_INIT_MESSAGES_APP);

#ifdef __MMI_URI_AGENT__
	srv_uriagent_register_hdlr_by_scheme(
                                "sms",
                                mmi_msg_uri_request_handle,
                                MMI_FALSE);
	srv_uriagent_register_hdlr_by_scheme(
                                "smsto",
                                mmi_msg_uri_request_handle,
                                MMI_FALSE);
#endif /* __MMI_URI_AGENT__ */

#ifdef __MMI_BPP20_SUPPORT__
    applib_mem_ap_register(
        APPLIB_MEM_AP_ID_SMS_BPP, 
        STR_GLOBAL_TEXT_MESSAGE, 
        IMG_MESSAGE_SMS_MENUENTRY, 
        mmi_msg_bpp_app_mem_stop_callback);
#endif /* __MMI_BPP20_SUPPORT__ */

#ifdef __MMI_SMS_APP_EMS_SUPPORT__
    mmi_ems_create_ems_folder();
#endif
}


/*****************************************************************************
 * FUNCTION
 *  DeInitMessagesApp
 * DESCRIPTION
 *  Deinit MSG application
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DeInitMessagesApp(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_DEINIT_MESSAGES_APP);

    mmi_msg_deinit_msg_data();
}


/*****************************************************************************
 * FUNCTION
 *  IsMessagesReEntering
 * DESCRIPTION
 *  Check if MSG application is reentered
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE: MSG application is reentered, FALSE: MSG application is not reentered
 *****************************************************************************/
U8 IsMessagesReEntering(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_IS_MESSAGES_REENTERING);
#ifdef __MMI_TELEPHONY_SUPPORT__	
    if ((srv_sms_is_send_action_busy() == MMI_FALSE) &&
        (srv_sms_is_sms_busy() == MMI_FALSE))
    {
        mmi_frm_group_close(g_sms_gid);
        return MMI_FALSE;
    }
    else
    {
	    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_IS_MESSAGES_REENTERING_8, g_msg_cntx.msg_status);
        return MMI_TRUE;
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_check_interrupt
 * DESCRIPTION
 *  check if there is an interrupt (incoming call ringing or alarm playing).
 * PARAMETERS
 *  void
 * RETURNS
 *  1: interrupt existed, 0: interrupt not existed
 *****************************************************************************/
U8 mmi_msg_check_interrupt(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) > 0 || srv_reminder_is_expiring())
    {
    	MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_MMI_MSG_CHECK_INTERRUPT);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}

#if !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_need_new_msg_ind
 * DESCRIPTION
 *  check if new msg indication is required
 * PARAMETERS
 *  void
 * RETURNS
 *  1: indication required, 0: indication not required
 *****************************************************************************/
U8 mmi_msg_need_new_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Return false if the new msg is deleted by AT */
    if (g_msg_cntx.msg_ind_index == SRV_SMS_INVALID_MSG_ID || 
        (srv_sms_is_msg_exist(g_msg_cntx.msg_ind_index) == MMI_FALSE))
    {
        g_msg_cntx.msg_ind_in_idle = MMI_FALSE;
        g_msg_cntx.msg_ind_after_call = MMI_FALSE;
        return KAL_FALSE;
    }
    else
    {
        return g_msg_cntx.msg_ind_in_idle;
    }
}
#endif /* !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)*/

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_need_mem_exceed_ind
 * DESCRIPTION
 *  Check if msg exceed indication is required
 * PARAMETERS
 *  void
 * RETURNS
 *  1: indication required, 0: indication not required
 *****************************************************************************/
U8 mmi_msg_need_mem_exceed_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (g_msg_cntx.msg_exceed_ind &&
    (SCR_ID_MSG_EXCEED_IND != mmi_frm_scrn_get_active_id()));
}

#if  !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_need_waiting_ind
 * DESCRIPTION
 *  Check if msg waiting indication is required
 * PARAMETERS
 *  void
 * RETURNS
 *  non-0: indication required, 0: indication not required
 *****************************************************************************/
U8 mmi_msg_need_waiting_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_msg_cntx.msg_waiting_ind == 1;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_msg_waiting_ind_idle
 * DESCRIPTION
 *  Message waiting indication on idle
 * PARAMETERS
 *        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_msg_waiting_ind_idle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ClearKeyEvents();
    if (IsKeyPadLockState())
    {
         mmi_idle_display();
    }
    else
    {
        mmi_msg_entry_msg_waiting_ind();
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_waiting_scrn_entry
 * DESCRIPTION
 *  Entry Message waiting screen
 * PARAMETERS
 *        
 * RETURNS
 *  void
 *****************************************************************************/

MMI_BOOL mmi_msg_waiting_scrn_entry(mmi_scenario_id scen_id, void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_msg_msg_waiting_ind_idle();

    return MMI_TRUE;
}
#endif /* !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)*/

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_msg_waiting_ind
 * DESCRIPTION
 *  Indicate msg waiting
 * PARAMETERS
 *  type        [IN]        
 *  a(?)        [IN]        Waiting msg type
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_msg_waiting_ind(U8 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_sms_sim_enum sim_id;
    mmi_sim_enum mmi_sim;
#if !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)
		mmi_event_notify_enum evt_type;
#if (MMI_MAX_SIM_NUM >= 2)
    U32 index;
    mmi_event_notify_enum event_type[] = 
    {
        MMI_EVENT_MESSAGE_SIM1_WAITING
        ,MMI_EVENT_MESSAGE_SIM2_WAITING
    #if (MMI_MAX_SIM_NUM >= 3)
        ,MMI_EVENT_MESSAGE_SIM3_WAITING
    #endif
    #if (MMI_MAX_SIM_NUM >= 4)
        ,MMI_EVENT_MESSAGE_SIM4_WAITING
    #endif
    };
#endif /*  (MMI_MAX_SIM_NUM >= 2) */
#endif /*!defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_sim = g_msg_cntx.msg_waiting_info[g_msg_cntx.msg_waiting_line_number].curr_sim;

    sim_id =  SRV_SMS_MMI_SIM_TO_SMS(mmi_sim);

#ifndef __MMI_NCENTER_SUPPORT__
#ifdef __MMI_TELEPHONY_SUPPORT__
    mmi_msg_set_msg_waiting_icon(sim_id, g_msg_cntx.msg_waiting_line_number, type, 1);
#endif
#endif

    /* Only show voicemail indication */
    if (type != 0)
    {
        return;
    }

    g_msg_cntx.msg_waiting_ind = type + 1;

    /* 1 Voice mail, 2 fax, 3 email, 4 video type , only voice mail need to follow ...*/
#if !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)
    {
        evt_type = MMI_EVENT_MESSAGE_WAITING_OTHERS;
    }
    
#if (MMI_MAX_SIM_NUM >= 2)
    index = mmi_frm_sim_to_index(mmi_sim);
    evt_type = event_type[index];
#endif /*  (MMI_MAX_SIM_NUM >= 2) */

    if (msg_waiting_ind_cntx == NULL)
    {
  #ifdef __MMI_WEARABLE_DEVICE__
	     mmi_frm_nmgr_notify_by_app(
            MMI_SCENARIO_ID_MESSAGE_WAITING,
            evt_type,
            mmi_msg_entry_msg_waiting_ind,
            NULL);
  #else /*__MMI_WEARABLE_DEVICE__*/
  	 	mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_MESSAGE_WAITING, evt_type, NULL);

  #endif /*__MMI_WEARABLE_DEVICE__*/
    }
    else
    {
        if ((mmi_frm_group_get_active_id() == msg_waiting_ind_cntx->owner_gid)
            && (mmi_frm_scrn_get_active_id() == SCR_ID_MSG_MSG_WAITING_IND)
            )
        {
            MMI_ID old_gid = msg_waiting_ind_cntx->owner_gid;
            mmi_msg_entry_msg_waiting_ind();
            mmi_frm_group_close(old_gid);
        }
    }
#endif /*!defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)*/
}

#if !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)
/*****************************************************************************
 * FUNCTION
 *  mmi_sms_go_back_from_msg_waiting_ind
 * DESCRIPTION
 *  Reset msg waiting ind before go back screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_go_back_from_msg_waiting_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_msg_cntx.msg_waiting_ind = 0;

    mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_entry_msg_waiting
 * DESCRIPTION
 *  Entry msg waiting indication screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_sms_entry_msg_waiting(mmi_scrn_essential_struct* scrn_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = mmi_frm_scrn_enter(
                scrn_data->group_id, 
                scrn_data->scrn_id,
                mmi_msg_exit_msg_waiting_ind,
                (FuncPtr)mmi_sms_entry_msg_waiting,
                MMI_FRM_FG_ONLY_SCRN);

    if (result)
    {

		mmi_sms_waiting_ind_struct *cntx = (mmi_sms_waiting_ind_struct*)scrn_data->user_data;

#ifdef __MMI_WEARABLE_DEVICE__
		mmi_frm_start_scenario(MMI_SCENARIO_ID_MESSAGE_WAITING);
        ForceSubLCDScreen(mmi_msg_start_msg_sub_anm);

		wgui_showcategory6333_screen(NULL, 
			(UI_string_type)GetString(STR_GLOBAL_DIAL), 
			(UI_string_type)GetString(STR_GLOBAL_BACK),
			(UI_string_type) cntx->msg_waiting_info,
			NULL);
		
		SetLeftSoftkeyFunction(mmi_sms_vm_nmgr_msg_waiting_by_app, KEY_EVENT_UP);
		SetRightSoftkeyFunction(mmi_sms_go_back_from_msg_waiting_ind, KEY_EVENT_UP);
		SetCenterSoftkeyFunction(mmi_sms_vm_nmgr_msg_waiting_by_app, KEY_EVENT_UP);


#else /*__MMI_WEARABLE_DEVICE__*/
      
    #ifdef __LOW_COST_SUPPORT_COMMON__
        MMI_ID img = IMG_NEW_MESSAGE_NOTIFICATION_MSG;
    #else
        MMI_ID img = IMG_ID_SMS_VM_NEW_VOICEMAIL_NOTIFICATION_MSG;
    #endif /* __LOW_COST_SUPPORT_COMMON__ */

        mmi_frm_start_scenario(MMI_SCENARIO_ID_MESSAGE_WAITING);

        ForceSubLCDScreen(mmi_msg_start_msg_sub_anm);

        EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);

        ShowCategory141Screen(
            0,
            0,
            STR_GLOBAL_DIAL,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (U8*) cntx->msg_waiting_info,
            img,
            NULL);

        SetLeftSoftkeyFunction(mmi_sms_vm_nmgr_msg_waiting_by_app, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_sms_vm_nmgr_msg_waiting_by_app, KEY_EVENT_UP);
        SetRightSoftkeyFunction(mmi_sms_go_back_from_msg_waiting_ind, KEY_EVENT_UP);
		
#endif /*__MMI_WEARABLE_DEVICE__*/
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_msg_waiting_ind_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static mmi_ret mmi_sms_msg_waiting_ind_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                         */
    /*----------------------------------------------------------------*/
    mmi_group_event_struct *event = (mmi_group_event_struct*)evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                                                               */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_GROUP_INACTIVE:
            if (!mmi_frm_scrn_get_count(event->sender_id))
            {
                mmi_frm_group_close(event->sender_id);
            }
            break;
    
        case EVT_ID_GROUP_DEINIT:
            if (event->user_data != NULL)
            {
                if (event->user_data == msg_waiting_ind_cntx)
                {
                    msg_waiting_ind_cntx = NULL;
                }

                OslMfree(event->user_data);
            }
            break;

        case EVT_ID_GROUP_GOBACK_IN_END_KEY:
            g_msg_cntx.msg_waiting_ind = 0;
            break;

        default:
            break;
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_msg_waiting_ind
 * DESCRIPTION
 *  Entry msg waiting indication screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_msg_waiting_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_waiting_ind_cntx = (mmi_sms_waiting_ind_struct*)OslMalloc(sizeof(mmi_sms_waiting_ind_struct));

    mmi_sms_vm_get_msg_waiting_msg(msg_waiting_ind_cntx->msg_waiting_info, MMI_NEW_MSG_WAITING_INFO_LEN);

    msg_waiting_ind_cntx->owner_gid = mmi_frm_group_create_ex(
                        GRP_ID_ROOT,
                        GRP_ID_AUTO_GEN,
                        mmi_sms_msg_waiting_ind_proc,
                        msg_waiting_ind_cntx,
                        MMI_FRM_NODE_SMART_CLOSE_FLAG);

    mmi_frm_scrn_first_enter(
        msg_waiting_ind_cntx->owner_gid,
        SCR_ID_MSG_MSG_WAITING_IND,
        (FuncPtr)mmi_sms_entry_msg_waiting,
        msg_waiting_ind_cntx);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_exit_msg_waiting_ind
 * DESCRIPTION
 *  Exit msg waiting indication screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_exit_msg_waiting_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (GetActiveScreenId() != SCR_ID_MSG_MSG_WAITING_IND)
	{
		srv_prof_tone_enum tone_id;

		if (g_msg_cntx.msg_waiting_ind == 1)
		{
			tone_id = SRV_PROF_TONE_ANS_PHONE;
		}
		else
		{
			tone_id = SRV_PROF_TONE_SMS;
		}

		if (srv_prof_is_tone_playing(tone_id))
		{
            srv_prof_stop_tone(tone_id);
		}
	}
	
	mmi_msg_stop_msg_sub_anm();
#ifdef __MMI_WEARABLE_DEVICE__
	 g_msg_cntx.msg_waiting_ind = 0;
#endif
	mmi_frm_end_scenario(MMI_SCENARIO_ID_MESSAGE_WAITING);
}
#endif /* !defined( __MMI_PLUTO_3232_IDLE_NMGR_SLIM__) || defined(__MMI_WEARABLE_DEVICE__)*/

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_go_back_from_mem_exceed_ind
 * DESCRIPTION
 *  Reset msg exceed flag before go back screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_go_back_from_mem_exceed_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_msg_cntx.msg_exceed_ind = MMI_FALSE;
    mmi_frm_scrn_close_active_id();
}


void mmi_msg_exit_mem_exceed_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_WEARABLE_DEVICE__
	g_msg_cntx.msg_exceed_ind = MMI_FALSE;
#endif /*__MMI_WEARABLE_DEVICE__*/

}

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_mem_exceed_ind
 * DESCRIPTION
 *  Entry memory exceed indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_mem_exceed_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
#if (MMI_MAX_SIM_NUM >= 2)
    U16 str_id = 0;
#endif
    U16 sms_memexceed_buff[150];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_ENTRY_MEM_EXCEED_IND, g_msg_cntx.msg_exceed_type);

    sms_memexceed_buff[0] = '\0';

    if (mmi_frm_scrn_enter(
            mmi_idle_get_group_id(),
            SCR_ID_MSG_EXCEED_IND,
            mmi_msg_exit_mem_exceed_ind,
            mmi_msg_entry_mem_exceed_ind,
            MMI_FRM_FG_ONLY_SCRN))
    {
    #if (MMI_MAX_SIM_NUM >= 2)
    	if (g_msg_cntx.msg_exceed_sim == MMI_SIM1)
    	{
    		str_id = STR_ID_SMS_SIM1_COLON;
    	}
    	else if (g_msg_cntx.msg_exceed_sim == MMI_SIM2)
    	{
    		str_id = STR_ID_SMS_SIM2_COLON;
    	}
    #if (MMI_MAX_SIM_NUM >= 3)
        else if (g_msg_cntx.msg_exceed_sim == MMI_SIM3)
    	{
    		str_id = STR_ID_SMS_SIM3_COLON;
    	}
    #endif
    #if (MMI_MAX_SIM_NUM >= 4)
        else if (g_msg_cntx.msg_exceed_sim == MMI_SIM4)
    	{
    		str_id = STR_ID_SMS_SIM4_COLON;
    	}
    #endif

        mmi_ucs2cpy((S8*)sms_memexceed_buff, GetString(str_id));
    #endif

        if (g_msg_cntx.msg_exceed_type == SRV_SMS_MEM_SIM_ONLY)
        {
            mmi_ucs2cat((S8*)sms_memexceed_buff, GetString(STR_SMS_SIM_MEMORY_EXCEEDED));
        }
        else
        {
            mmi_ucs2cat((S8*)sms_memexceed_buff, GetString(STR_SMS_MEMORY_EXCEEDED));
        }

        srv_backlight_turn_on(SRV_BACKLIGHT_SHORT_TIME);

        ShowCategory7Screen(
            STR_SCR6042_CAPTION,
            IMG_SMS_ENTRY_SCRN_CAPTION,
            0,
            0,
            STR_GLOBAL_BACK,
            IMG_GLOBAL_BACK,
            (U8*)sms_memexceed_buff,
            NULL);

        SetRightSoftkeyFunction(mmi_msg_go_back_from_mem_exceed_ind, KEY_EVENT_UP);
        //SetKeyHandler(mmi_msg_go_back_from_mem_exceed_ind, KEY_END, KEY_EVENT_DOWN);
        SetKeyDownHandler(mmi_msg_go_back_from_mem_exceed_ind, KEY_END);
		
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_class0_msg_ind_top
 * DESCRIPTION
 *  Class0 message indication on top
 * PARAMETERS
 *        
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_class0_msg_ind_top()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (MMI_SIM_TOTAL >= 2)
    mmi_msg_set_msg_type_sim(g_msg_cntx.msg_class0_p->curr_sim);
#endif /* (MMI_SIM_TOTAL >= 2) */

    mmi_msg_entry_class0_msg_ind();

        /* display popup*/
#ifdef __MMI_OP11_PROF_SOUND__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __MMI_OP11_PROF_SOUND__ */

#if (MMI_SIM_TOTAL >= 2)
    g_msg_cntx.curr_sim = MMI_SIM_NONE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_class0_scrn_entry
 * DESCRIPTION
 *  entry class 0 message screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/

MMI_BOOL mmi_msg_class0_scrn_entry(mmi_scenario_id scen_id, void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_msg_class0_msg_ind_top();
	return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_class0_msg_ind
 * DESCRIPTION
 *  Indicate class 0 message
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_class0_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_notify_enum evt_type = MMI_EVENT_SMS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_msg_cntx.msg_class0_ind = TRUE;

#if (MMI_MAX_SIM_NUM >= 2)
    if (g_msg_cntx.msg_class0_p->curr_sim == MMI_SIM1)
    {
	evt_type = MMI_EVENT_SMS;
    }
    else if (g_msg_cntx.msg_class0_p->curr_sim == MMI_SIM2)
    {
        evt_type = MMI_EVENT_SLAVE_SMS;
    }
#if (MMI_MAX_SIM_NUM >= 3)
    else if (g_msg_cntx.msg_class0_p->curr_sim == MMI_SIM3)
    {
        evt_type = MMI_EVENT_SIM3_SMS;        
    }    
#endif
#if (MMI_MAX_SIM_NUM >= 4)    
    else if (g_msg_cntx.msg_class0_p->curr_sim == MMI_SIM4)
    {
        evt_type = MMI_EVENT_SIM4_SMS;
    }
#endif
#endif /* (MMI_MAX_SIM_NUM >= 2) */

    if (!mmi_frm_scrn_is_present(mmi_sms_class0_gid, SCR_ID_MSG_CLASS0_MSG, MMI_FRM_NODE_ALL_FLAG))
    {
        if (mmi_frm_nmgr_is_scenario_deferred(MMI_SCENARIO_ID_NEW_CLASS0_SMS, mmi_msg_class0_scrn_entry, NULL))
        {
            mmi_frm_nmgr_cancel_deferred_scenario(MMI_SCENARIO_ID_NEW_CLASS0_SMS, mmi_msg_class0_scrn_entry, NULL);
        }

        if (!mmi_frm_nmgr_notify_by_app(MMI_SCENARIO_ID_NEW_CLASS0_SMS, evt_type, mmi_msg_class0_scrn_entry, NULL))
        {
        #ifdef __OP01__
            mmi_frm_nmgr_set_only_disp_scrn(MMI_TRUE);
            mmi_frm_nmgr_popup(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_SMS, (WCHAR*)GetString(STR_CLASS0_MESSAGE_CAPTION));
            mmi_frm_nmgr_set_only_disp_scrn(MMI_FALSE);
        #endif
        }
    }
    else
    {
        g_msg_cntx.free_class0_data_flag = MMI_FALSE;
        mmi_frm_group_close(mmi_sms_class0_gid);

        if (mmi_frm_nmgr_is_scenario_deferred(MMI_SCENARIO_ID_NEW_CLASS0_SMS, mmi_msg_class0_scrn_entry, NULL))
        {
            mmi_frm_nmgr_cancel_deferred_scenario(MMI_SCENARIO_ID_NEW_CLASS0_SMS, mmi_msg_class0_scrn_entry, NULL);
        }

        if (!mmi_frm_nmgr_notify_by_app(MMI_SCENARIO_ID_NEW_CLASS0_SMS, evt_type, mmi_msg_class0_scrn_entry, NULL))
        {
        #ifdef __OP01__
            mmi_frm_nmgr_set_only_disp_scrn(MMI_TRUE);
            mmi_frm_nmgr_popup(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_SMS, (WCHAR*)GetString(STR_CLASS0_MESSAGE_CAPTION));
            mmi_frm_nmgr_set_only_disp_scrn(MMI_FALSE);
        #endif
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_get_class0_msg
 * DESCRIPTION
 *  Get class 0 message
 * PARAMETERS
 *  void
 * RETURNS
 *  EMSData bufForDisplay
 *****************************************************************************/
EMSData *mmi_msg_get_class0_msg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSData *pEms;
    U16 textLen = g_msg_cntx.msg_class0_p->length;
    CHAR *text = (CHAR *)g_msg_cntx.msg_class0_p->data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    textLen = (textLen / 2);
    GetEMSDataForView(&pEms, 1);
    if ((g_msg_cntx.msg_class0_p->dcs != SRV_SMS_DCS_7BIT) && (g_msg_cntx.msg_class0_p->dcs != SRV_SMS_DCS_UCS2))
    {
        text = (CHAR *)GetString(STR_GLOBAL_NOT_SUPPORTED);
        textLen = mmi_ucs2strlen(text);
    }
#ifndef __ULC_SLIM_EMS__
    AddString(pEms, text, textLen, NULL);
#else /* __ULC_SLIM_EMS__ */
    mmi_sms_append_string_to_ems_buffer(pEms, text, textLen);
#endif /* __ULC_SLIM_EMS__ */
    pEms->ps_dcs = g_msg_cntx.msg_class0_p->dcs;
    pEms->dcs = g_msg_cntx.msg_class0_p->dcs;

    return pEms;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_get_class0_header
 * DESCRIPTION
 *  Get class 0 message header
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_get_class0_header(WCHAR *ucs2_buff, U16 length)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 addr[MAX_DIGITS + 1];
    U16 name[MMI_PHB_NAME_LENGTH + 1];
    U16 ts_date[MAX_TIMESTAMP_SIZE + 1];
    U16 ts_time[MAX_TIMESTAMP_SIZE + 1];
    MYTIME *datetime;
    WCHAR *para;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_ucs2cpy((S8*)addr, (S8*) g_msg_cntx.msg_class0_p->number);

    srv_phb_get_name_by_number(addr, name, MMI_PHB_NAME_LENGTH);

    datetime = &(g_msg_cntx.msg_class0_p->timestamp);

    date_string(datetime, (UI_string_type)ts_date, DT_IDLE_SCREEN);
    time_string(datetime, (UI_string_type)ts_time, DT_IDLE_SCREEN);

    if (name[0])
    {
        para = name;
    }
    else
    {
        para = addr;
    }

    kal_wsprintf(ucs2_buff, 
        "%w\n%w\n%w\n", 
        para,
        (S8*) ts_date,
        (S8*) ts_time);

    MMI_ASSERT(wcslen(ucs2_buff) < (length-1));
}

#ifndef __MMI_SMS_CLASS0_MSG_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_sms_class0_opt_entry_hdlr
 * DESCRIPTION
 *  Pre entry class 0 option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_sms_class0_opt_entry_hdlr(cui_menu_event_struct* menu_evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
#if (defined(__MMI_MESSAGE_SMS_HILITE_VIEWER__) || (MMI_MAX_SIM_NUM >= 2))
    MMI_ID cui_menu_gid = menu_evt->sender_id;
#endif
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if defined(__MMI_MESSAGE_SMS_HILITE_VIEWER__)
    mmi_sms_check_hilite_item_opt(cui_menu_gid);
#endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */

#if (MMI_MAX_SIM_NUM >= 2)
{
    S32 index;
    for (index = 0; index < MMI_SIM_TOTAL; index++)
    {
        MMI_BOOL is_need_to_hide;
        mmi_sim_enum sim = (mmi_frm_index_to_sim(index));
    	is_need_to_hide = (MMI_BOOL)(!srv_sim_ctrl_is_available(sim));
        cui_menu_set_item_hidden(cui_menu_gid, MENU_ID_SMS_CLSASS0_OPT_SAVE_TO_INBOX_BY_SIM1, is_need_to_hide);
    }
    mmi_sms_set_save_send_select_sim_leaf_item(cui_menu_gid, MENU_ID_SMS_CLSASS0_OPT_SAVE_TO_INBOX, srv_sim_ctrl_is_available);
}
#endif

#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
    if (srv_sms_is_highlight_view_setting() == MMI_TRUE)
    {
        cui_menu_set_item_hidden(cui_menu_gid, SMS_CLSASS0_OPT_AUTO_FIND_ON, MMI_TRUE);
        cui_menu_set_item_hidden(cui_menu_gid, SMS_CLSASS0_OPT_AUTO_FIND_OFF, MMI_FALSE);
    }
    else
    {
        cui_menu_set_item_hidden(cui_menu_gid, SMS_CLSASS0_OPT_AUTO_FIND_ON, MMI_FALSE);
        cui_menu_set_item_hidden(cui_menu_gid, SMS_CLSASS0_OPT_AUTO_FIND_OFF, MMI_TRUE);
    }
#endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */

    return MMI_RET_OK;
}

#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
/*****************************************************************************
 * FUNCTION
 *  mmi_sms_class0_viewer_hilite_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static mmi_ret mmi_sms_class0_viewer_hilite_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                         */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                                                               */
    /*----------------------------------------------------------------*/
    switch (evt->evt_id)
    {
        case EVT_ID_CUI_USE_DETAIL_RESULT:
        {
            cui_use_detail_result_event_struct *use_detail_evt = (cui_use_detail_result_event_struct *)evt;
            cui_use_detail_close(use_detail_evt->sender_id);
        }
            break;
    
    }

    return MMI_RET_OK;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_class0_opt_select_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_class0_opt_select_hdlr(mmi_event_struct *menu_evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cui_menu_event_struct *cui_menu_evt = (cui_menu_event_struct*)menu_evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (cui_menu_evt->highlighted_menu_id)
    {
#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
            case MENU_ID_SMS_USE_NUMBER_OPT:
        #if defined(__MMI_EMAIL__)
            case MENU_ID_SMS_USE_EMAIL_OPT:
        #elif defined(__MMI_PHB_OPTIONAL_FIELD__)
            case MENU_ID_SMS_USE_EMAIL_OPT_SAVE_TO_EMAIL:
        #endif /* __MMI_EMAIL__ */
        #ifdef __MMI_MESSAGES_USE_URL__
            case MENU_ID_SMS_USE_URL_OPT:
        #endif /* __MMI_MESSAGES_USE_URL__ */
            case MENU_ID_SMS_SEND_USSD_OPT:
            {
                MMI_ID mmi_sms_hilite_gid = mmi_frm_group_create_ex(
                    g_sms_gid,
                    GRP_ID_AUTO_GEN,
                    mmi_sms_class0_viewer_hilite_proc,
                    NULL,
                    MMI_FRM_NODE_SMART_CLOSE_FLAG);
                mmi_sms_use_detail_hilite_info(mmi_sms_hilite_gid, hilite_cntx.currHiliteItemIndex);
            }
            break;
            
    #ifdef __MMI_SMS_APP_EMS_SUPPORT__
        case MENU_ID_SMS_SAVE_OBJECTS_OPT:
            mmi_ems_pre_entry_save_object_name(mmi_sms_class0_gid);
            break;
    #endif
#elif defined(__MMI_MESSAGE_SMS_USE_DETAIL__)
        case SMS_CLSASS0_OPT_USE_NUMBER_MENUID:
            mmi_msg_entry_class_0_opt_use_number(mmi_sms_class0_gid);
            break;
    #ifdef __MMI_MESSAGES_USE_URL__
        case SMS_CLSASS0_OPT_USE_URL_MENUID:
            mmi_msg_entry_class_0_opt_use_url(mmi_sms_class0_gid);
            break;
    #endif /*__MMI_MESSAGES_USE_URL__ */
#endif /*defined(__MMI_MESSAGE_SMS_USE_DETAIL__) */

        case MENU_ID_SMS_CLSASS0_OPT_SAVE_TO_INBOX:
        #if (MMI_MAX_SIM_NUM >= 2)
            {
                S32 usable_sim_amount = 0;
                S32 i = 0;
                mmi_sim_enum sim_to_use = MMI_SIM1;
                for (; i < MMI_SIM_TOTAL; ++i)
                {
                    mmi_sim_enum current_sim = mmi_frm_index_to_sim(i);
                    /* detect how many sim is avaiable */
                    if (srv_sim_ctrl_is_available(current_sim))
                    {   
                        sim_to_use = current_sim;
                        ++usable_sim_amount;
                    }
                }
                if (1 >= usable_sim_amount)/* only one sim avaible or no sim availabe, do not need to select */
                {
                    mmi_sms_class0_opt_save_to_inbox(SRV_SMS_MMI_SIM_TO_SMS(sim_to_use));
                }
            }
        #else
            mmi_sms_class0_opt_save_to_inbox(SRV_SMS_SIM_1);
        #endif
            break;

    #if defined(__MMI_SMS_SET_AS_REMINDER__) && defined(__MMI_TODOLIST__)
        case MENU_ID_SMS_VIEWER_OPT_ADD_TO_CALENDAR:
            mmi_sms_viewer_opt_add_to_calendar(mmi_sms_class0_gid);
            break;
    #endif

    #ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
        case SMS_CLSASS0_OPT_AUTO_FIND_ON:
            mmi_msg_entry_class_0_opt_auto_find_on();
            break;
        case SMS_CLSASS0_OPT_AUTO_FIND_OFF:
            mmi_msg_entry_class_0_opt_auto_find_off();
            break;
    #endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */

        default:
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_pre_entry_class0_msg_option
 * DESCRIPTION
 *  Pre entry class 0 option
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_pre_entry_class0_msg_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    keep_class0_scrn = MMI_TRUE;

    mmi_sms_entry_menu_cui_options_generic(
        mmi_sms_class0_gid,
        SMS_CLASS0_OPT_MENUID,
        0);
}


#ifdef __MMI_MESSAGE_SMS_USE_DETAIL__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_class_0_opt_use_number
 * DESCRIPTION
 *  Entry function for class 0 use number
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_entry_class_0_opt_use_number(MMI_ID group_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_sms_pre_entry_use_detail_list_sg(
        group_id,
        MMI_SMS_ADDR_PHONENUMBER,
        (S8*)g_msg_cntx.msg_class0_p->data,
        (U16)g_msg_cntx.msg_class0_p->length,
        (S8*)g_msg_cntx.msg_class0_p->number);
}
#endif


#if defined(__MMI_MESSAGE_SMS_USE_DETAIL__) || defined (__MMI_MESSAGE_SMS_HILITE_VIEWER__)
#ifdef __MMI_MESSAGES_USE_URL__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_class_0_opt_use_url
 * DESCRIPTION
 *  Entry function for class 0 use url
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_class_0_opt_use_url(MMI_ID group_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifndef __ULC_SLIM_EMS__
    EMSPosition position;
#endif
    EMSData *pEMS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    GetEMSDataForView(&pEMS, 0);
#ifndef __ULC_SLIM_EMS__
    position = pEMS->CurrentPosition;
    mmi_msg_ems_remove_escape_char(pEMS);
#endif /* __ULC_SLIM_EMS__ */
    mmi_sms_pre_entry_use_detail_list_sg(
        group_id,
        MMI_SMS_ADDR__URL,
        (S8*)g_msg_cntx.msg_class0_p->data,
        (U16)g_msg_cntx.msg_class0_p->length,
        (S8*)g_msg_cntx.msg_class0_p->number);
#ifndef __ULC_SLIM_EMS__
    mmi_msg_ems_add_escape_char(pEMS);
    MoveCursorToPosition(pEMS, &position);
#endif /* __ULC_SLIM_EMS__ */
}
#endif /* __MMI_MESSAGES_USE_URL__ */
#endif /*__MMI_MESSAGE_SMS_USE_DETAIL__ || __MMI_MESSAGE_SMS_HILITE_VIEWER__ */


#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_class_0_opt_auto_find_on
 * DESCRIPTION
 *  entry class 0 auto find on
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_class_0_opt_auto_find_on(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_sms_set_highlight_view_setting(MMI_TRUE);

    mmi_sms_display_popup_ext(
        STR_ID_SMS_AUTO_FIND_ON,
        MMI_EVENT_SUCCESS);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_class_0_opt_auto_find_off
 * DESCRIPTION
 *  entry class 0 auto find off
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_class_0_opt_auto_find_off(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_sms_set_highlight_view_setting(MMI_FALSE);

    mmi_sms_display_popup_ext(
        STR_ID_SMS_AUTO_FIND_OFF,
        MMI_EVENT_SUCCESS);
}
#endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */

#endif /*#ifndef __MMI_SMS_CLASS0_MSG_SLIM__*/
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_free_class0_data
 * DESCRIPTION
 *  Reset class 0 message data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_free_class0_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_msg_cntx.msg_class0_ind = MMI_FALSE;
    if (g_msg_cntx.msg_class0_p != NULL)
    {
        if (g_msg_cntx.msg_class0_p->data != NULL)
        {
            OslMfree(g_msg_cntx.msg_class0_p->data);
            g_msg_cntx.msg_class0_p->data = NULL;
        }
        mmi_msg_deinit_msg_data();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_class0_scrn_leave_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret mmi_sms_class0_scrn_leave_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_SCRN_DEINIT:
		default:
        #ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
            hilite_cntx.isParsed = MMI_FALSE;
        #endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */
        
            if (g_msg_cntx.free_class0_data_flag == MMI_TRUE)
            {
                mmi_msg_free_class0_data();
            }

            mmi_frm_end_scenario(MMI_SCENARIO_ID_NEW_CLASS0_SMS);

            break;
    }

    return MMI_RET_OK; 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_class0_msg
 * DESCRIPTION
 *  Entry class 0 message indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_class0_msg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer = NULL;
    EMSData *pClass0Ems = NULL;
#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
    BOOL isHilite = srv_sms_is_highlight_view_setting();
#endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */
    MMI_ID LSK = 0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_scrn_enter(mmi_sms_class0_gid, SCR_ID_MSG_CLASS0_MSG, mmi_msg_exit_class0_msg_ind, mmi_msg_entry_class0_msg, MMI_FRM_FULL_SCRN))
    {
        WCHAR buffer[MAX_DIGITS + MMI_PHB_NAME_LENGTH + MAX_TIMESTAMP_SIZE + MAX_TIMESTAMP_SIZE +1];

        mmi_frm_start_scenario(MMI_SCENARIO_ID_NEW_CLASS0_SMS);

        ForceSubLCDScreen(mmi_msg_start_msg_sub_anm);

    	g_msg_cntx.free_class0_data_flag = MMI_TRUE;
        pClass0Ems = mmi_msg_get_class0_msg();
        if ((pClass0Ems->dcs == SRV_SMS_DCS_7BIT) || (pClass0Ems->dcs == SRV_SMS_DCS_UCS2))
        { 
            /* supported messages */
            guiBuffer = mmi_frm_scrn_get_gui_buf(mmi_sms_class0_gid, SCR_ID_MSG_CLASS0_MSG);

        #ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
            /* enter a new view screen*/
            if (guiBuffer == NULL)
            {
                if (isHilite)
                {
                    mmi_sms_parse_hilite_list(pClass0Ems, MMI_FALSE);
                    hilite_cntx.isParsed = MMI_TRUE;
                }
                else
                {
                    hilite_cntx.isParsed = MMI_FALSE;
                }
            }
            else
            {
                if (isHilite && hilite_cntx.isParsed == MMI_FALSE)
                {
                    mmi_sms_parse_hilite_list(pClass0Ems, MMI_FALSE);
                    hilite_cntx.isParsed = MMI_TRUE;
                }
            }

            wgui_inputs_EMS_set_hilite_list(
                isHilite ? hilite_cntx.hilite_list : NULL,
                hilite_cntx.totalListItem - 2,
                0,
                mmi_sms_class0_view_hilite_cb,
                mmi_sms_class0_view_hilite_click_cb);
        #endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */

             
#ifndef __MMI_SMS_CLASS0_MSG_SLIM__
            EnableCenterSoftkey(0, IMG_GLOBAL_OPTION_CSK);  
            LSK = STR_GLOBAL_OPTIONS;
#endif
        }
        mmi_msg_get_class0_header(buffer, MAX_DIGITS + MMI_PHB_NAME_LENGTH + MAX_TIMESTAMP_SIZE + MAX_TIMESTAMP_SIZE+1);
#ifdef __ULC_SLIM_EMS__
        ShowCategory74Screen(
            STR_SCR6024_CAPTION,
            IMG_SMS_ENTRY_SCRN_CAPTION,
            LSK,
            IMG_SMS_COMMON_NOIMAGE,
            STR_GLOBAL_BACK,
            IMG_SMS_COMMON_NOIMAGE,
            pClass0Ems->textBuffer,
            pClass0Ems->textLength,
            guiBuffer);
#else /* __ULC_SLIM_EMS__ */
        ShowCategory39Screen(
            STR_SCR6024_CAPTION,
            IMG_SMS_ENTRY_SCRN_CAPTION,
            LSK,
            IMG_SMS_COMMON_NOIMAGE,
            STR_GLOBAL_BACK,
            IMG_SMS_COMMON_NOIMAGE,
            pClass0Ems,
            (U8*)buffer,
            guiBuffer);
#endif /* __ULC_SLIM_EMS__ */
#ifndef __MMI_SMS_CLASS0_MSG_SLIM__
        if (LSK != 0)
        {
            SetLeftSoftkeyFunction(mmi_msg_pre_entry_class0_msg_option, KEY_EVENT_UP);
            SetCenterSoftkeyFunction(mmi_msg_pre_entry_class0_msg_option, KEY_EVENT_UP);
        }
#endif
        mmi_frm_scrn_set_leave_proc(
            mmi_sms_class0_gid,
            SCR_ID_MSG_CLASS0_MSG,
            mmi_sms_class0_scrn_leave_proc);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_class0_msg_ind
 * DESCRIPTION
 *  Entry class 0 message indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_class0_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_frm_scrn_is_present(mmi_sms_class0_gid, SCR_ID_MSG_CLASS0_MSG, MMI_FRM_NODE_ALL_FLAG));
    {
        g_msg_cntx.free_class0_data_flag = MMI_FALSE;
    }

#ifdef __OP02__
    if (!mmi_idle_is_active())
    {
        mmi_sms_group_entry(GRP_ID_ROOT);
    }
    else
#endif
    {
        mmi_sms_group_entry(mmi_idle_get_group_id());
    }

    mmi_sms_class0_gid = g_sms_gid;
    keep_class0_scrn = MMI_FALSE;
    mmi_msg_entry_class0_msg();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_exit_class0_msg_ind
 * DESCRIPTION
 *  exit class 0 message indication screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_exit_class0_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (keep_class0_scrn == MMI_FALSE)
    {
        g_msg_cntx.msg_class0_ind = MMI_FALSE;
    }

	mmi_msg_stop_msg_sub_anm();
}


#ifdef __MMI_OP12_MESSAGE_VOICEMAIL__

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_set_msg_waiting_rsp
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
void mmi_msg_set_msg_waiting_rsp(srv_sms_callback_struct* callback_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


/*****************************************************************************
 * FUNCTION
 *  GetAsciiOrUCS2Char
 * DESCRIPTION
 *  Get Ascii or UCS2 character
 * PARAMETERS
 *  buf         [?]         
 *  a(?)        [IN]        Address of string
 * RETURNS
 *  the description of return value, if any.
 *****************************************************************************/
S16 GetAsciiOrUCS2Char(S8 *buf)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (*buf + ((*(buf + 1)) << 8));
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_handle_new_mt_voicemail
 * DESCRIPTION
 *  Indicate new voice mail as mt message with special pid
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_msg_handle_new_mt_voicemail(srv_sms_event_struct* event_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_sms_event_new_sms_struct* pEvent = (srv_sms_event_new_sms_struct*)event_data->event_info;
    srv_sms_new_msg_struct *pNewSms = (srv_sms_new_msg_struct*)pEvent->msg_data;

    U8 counter;
    U8 counterBuf[3];
    U8 counterLen = 0;
    int i;
    int c;
    mmi_sms_msg_waiting_ind_struct msg;
    S16 contentLen = 0;
    S8 *unicodecontent = NULL;
    S8* content = (S8*)pNewSms->data;
    srv_sms_msg_waiting_struct msg_waiting;
    srv_sms_event_struct sms_event;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pNewSms->pid == 0x5F)
    {
        MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_HANDLE_NEW_MT_VOICEMAIL);

        /* get voicemail counter*/
        if (pNewSms->dcs == SRV_SMS_DCS_UCS2)
        {
            contentLen = pNewSms->message_len;
            unicodecontent = OslMalloc(contentLen + 2);
            memcpy(unicodecontent, content, contentLen);
            memset(unicodecontent + contentLen, 0, 2);
        }
        else
        {
            contentLen = pNewSms->message_len / 2;
            unicodecontent = OslMalloc((contentLen + 1) * 2);
            mmi_asc_n_to_ucs2(unicodecontent, (S8*)content, (U32)contentLen);
            memset(unicodecontent + contentLen * 2, 0, 2);
        }

        memset(counterBuf, 0, 3);
        for (i = 0; i < pNewSms->message_len;)
        {
            c = GetAsciiOrUCS2Char(&(unicodecontent[i]));
            i += ENCODING_LENGTH;
            if (IS_NUM(c))
            {
                if (counterLen >= 2)
                {
                    counterLen = 0;
                    continue;
                }
                counterBuf[counterLen] = c;
                counterLen ++;
            }
            else if (counterLen > 0 && counterLen <= 2)
            {
                counterBuf[counterLen] = '\0';
                break;
            }
            else
            {
                counterLen = 0;
            }
        }

        OslMfree(unicodecontent);

        if (counterLen > 0 && counterLen <= 2)
        {
            counter = (U8)atoi((char*)counterBuf);
            MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_HANDLE_NEW_MT_VOICEMAIL_1, counter);
        }
        else
        {
            MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_HANDLE_NEW_MT_VOICEMAIL_2);
            return MMI_TRUE;
        }

        /* indicate to user or clear the new voice mail message*/
        msg.line_no = 0;
        msg.waiting_num = counter + g_msg_cntx.msg_waiting_info[0].number[0];
        msg.ind_type = 0;
        msg.is_show_num = MMI_TRUE;
        msg.is_from_storage = MMI_FALSE;
        msg.msp_no = 0;
        if (counter > 0)
        {
            msg.is_clear = MMI_FALSE;
        }
        else
        {
            msg.is_clear = MMI_TRUE;
        }
        sms_event.event_info = &msg;
        mmi_sms_handle_msg_waiting_ind((mmi_event_struct *)&sms_event);

        /* set the counter to l4*/
        msg_waiting.ind_type = 0;
        msg_waiting.line_no = 0;
        msg_waiting.waiting_num = counter;
        srv_sms_set_setting_para(SRV_SMS_SET_MSG_WAITING, &msg_waiting, SRV_SMS_SIM_1, mmi_msg_set_msg_waiting_rsp, NULL);

        /* delete the mt message*/
        srv_sms_delete_msg(pEvent->msg_id, NULL, NULL);
        return MMI_TRUE;
    }
    return MMI_FALSE;
}
#endif /* __MMI_OP12_MESSAGE_VOICEMAIL__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_new_msg_ind
 * DESCRIPTION
 *  Indicate new message
 * PARAMETERS
 *  index       [IN]        
 *  a(?)        [IN]        L4 index of new message
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_new_msg_ind(srv_sms_event_new_sms_struct* event_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 msg_id = event_info->msg_id;
    srv_sms_new_msg_struct *new_msg_data = (srv_sms_new_msg_struct*)event_info->msg_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_MMI_MSG_NEW_MSG_IND, msg_id);
    g_sms_cntx.ind_msg_index = msg_id;
    /* Do not play notification if flight mode. */
    /* It happens if the incomplete SMS message that arrives before flight mode timeouts in flight mode. */
#if 0    
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if (defined( __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ ) && (!defined(__MMI_MESSAGES_PREFER_STORAGE_MEMORY_STATUS__)))
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#if (defined( __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ ) && (!defined(__MMI_MESSAGES_PREFER_STORAGE_MEMORY_STATUS__)))
    if (new_msg_data->storage_type == SRV_SMS_STORAGE_SIM)
    {
        g_msg_cntx.sim_msg_ind_index = msg_id;
        g_msg_cntx.sim_msg_ind_in_idle = MMI_TRUE;
    }
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */
    
#if (MMI_MAX_SIM_NUM >= 2)
    if (new_msg_data->sim_id == SRV_SMS_SIM_1)
    {
        g_msg_cntx.curr_sim = MMI_SIM1;
    }
    else if (new_msg_data->sim_id == SRV_SMS_SIM_2)
    {
        g_msg_cntx.curr_sim = MMI_SIM2;
    }
#if (MMI_MAX_SIM_NUM >= 3)
    else if (new_msg_data->sim_id == SRV_SMS_SIM_3)
    {
        g_msg_cntx.curr_sim = MMI_SIM3;
    }
#endif    
#if (MMI_MAX_SIM_NUM >= 4)
    else
    {
        g_msg_cntx.curr_sim = MMI_SIM4;
    }
#endif
#endif /* (MMI_MAX_SIM_NUM >= 2) */

#if defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
    mmi_sms_update_sidebar_info();
    mmi_sms_update_shct_data();
#endif /* #if defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__) */
#if (defined (__UNIFIED_MESSAGE_SIMBOX_SUPPORT__)  && (!defined(__MMI_MESSAGES_PREFER_STORAGE_MEMORY_STATUS__)))
    if (new_msg_data->storage_type == SRV_SMS_STORAGE_SIM)
    {
        mmi_msg_entry_new_sim_msg_ind();
    }
    else
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */
    {
        mmi_msg_entry_new_msg_ind();
    }
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0)
    {
        g_msg_cntx.msg_ind_after_call = MMI_TRUE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_get_new_msg_ind_string
 * DESCRIPTION
 *  Get new msg indication string
 * PARAMETERS
 *  void
 * RETURNS
 *  new msg indication string
 *****************************************************************************/
void mmi_msg_get_new_msg_ind_string(U16 msg_id, WCHAR *ucs2_buff)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 addr[SRV_SMS_MAX_ADDR_LEN + 1];
    U16 name[MMI_PHB_NAME_LENGTH + 1];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifndef __MMI_SMS_SLIM__
    srv_sms_get_msg_address(msg_id, (S8*)addr);
    #else
    mmi_sms_get_hilite_msg_addr((S8*)addr);
    #endif

    srv_phb_get_name_by_number(addr, name, MMI_PHB_NAME_LENGTH);

    if (name[0])
    {
        mmi_ucs2cpy((S8*)ucs2_buff, (S8*)name);
    }
    else
    {
        mmi_ucs2cpy((S8*)ucs2_buff, (S8*)addr);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_new_msg_ind
 * DESCRIPTION
 *  Entry new message indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_new_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_notify_enum event_id = MMI_EVENT_SMS;
#ifdef __OP01__
    U16 indstr = 0;
    WCHAR *display_text = NULL;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __UM_SUPPORT__

#if (MMI_SIM_TOTAL >= 2)
    if (g_msg_cntx.curr_sim == MMI_SIM2)
    {
        event_id = MMI_EVENT_SIM2_SMS;
    }
    else if (g_msg_cntx.curr_sim == MMI_SIM3)
    {
        event_id = MMI_EVENT_SIM3_SMS;
    }
    else if (g_msg_cntx.curr_sim == MMI_SIM4)
    {
        event_id = MMI_EVENT_SIM4_SMS;
    }
#endif /* (MMI_SIM_TOTAL >= 2) */
#endif

#ifdef __OP01__
#if (MMI_SIM_TOTAL == 1)
    indstr = STR_RECEIVED_SMS;
#else /* (MMI_SIM_TOTAL >= 2) */
    if (g_msg_cntx.curr_sim == MMI_SIM1)
    {           
        indstr = STR_ID_SMS_MASTER_RECEIVED_SMS;
    }
    else if (g_msg_cntx.curr_sim == MMI_SIM2)
    {           
        indstr = STR_ID_SMS_SLAVE_RECEIVED_SMS;
    }
#if (MMI_MAX_SIM_NUM >= 3)    
    else if (g_msg_cntx.curr_sim == MMI_SIM3)
    {           
        indstr = STR_ID_SMS_SIM3_RECEIVED_SMS;
    }
#endif
#if (MMI_MAX_SIM_NUM >= 4)    
    else
    {
        indstr = STR_ID_SMS_SIM4_RECEIVED_SMS;
    }
#endif
#endif /* (MMI_SIM_TOTAL >= 2) */
    display_text = (WCHAR*)GetString(indstr);
#endif /* op01 */
    {
        WCHAR preview_text[MMI_PHB_NAME_LENGTH + MMI_PHB_NAME_LENGTH + MMI_PHB_NAME_LENGTH + 1 + 1];
        mmi_frm_nmgr_alert_struct alert_info;
        memset(&alert_info, 0, sizeof(mmi_frm_nmgr_alert_struct));   
        /*fill in app id for NSS query*/
        alert_info.app_id = APP_UNIFIEDMESSAGE; //your app id
        /*fill in the basic info*/
        alert_info.scen_id = MMI_SCENARIO_ID_NEW_SMS; // your scenario ID
        alert_info.event_type = event_id; // your event id
        
        mmi_ucs2cpy((CHAR *)preview_text, (const CHAR *)GetString(STR_RECEIVED_SMS));
        mmi_ucs2cat((CHAR *)preview_text, (const CHAR *)L" ");
        mmi_ucs2cat((CHAR *)preview_text, (const CHAR *)GetString(STR_ID_SMS_FROM_LOWER_CASE));
        mmi_ucs2cat((CHAR *)preview_text, (const CHAR *)L" ");
        {
            U16 number[SRV_SMS_MAX_ADDR_LEN];
	        U16 name[MMI_PHB_NAME_LENGTH + 1];
            U16 *temp;
            #ifndef __MMI_SMS_SLIM__
            srv_sms_get_msg_address(g_sms_cntx.ind_msg_index, (S8*)number);
			#else
			mmi_sms_get_hilite_msg_addr((S8*)number);
			#endif
            srv_phb_get_name_by_number(number, name, MMI_PHB_NAME_LENGTH);

            if (name[0])
            {
                temp = name;
            }
            else
            {
                temp = number;
            }
            mmi_ucs2cat((CHAR *)preview_text, (const CHAR *)temp);
        }
		
		alert_info.status_bar_para.display_string = preview_text;
		alert_info.status_bar_para.image_type = MMI_NMGR_IMG_RES_ID;
		alert_info.status_bar_para.image.id = IMG_SI_SMS_INDICATOR;
	#ifdef __UM_SUPPORT__
        mmi_um_alert_um_inbox_alert(&alert_info);
	#else
		mmi_sms_inbox_alert(&alert_info);
	#endif
    }
/*
    mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_NEW_SMS, event_id, (WCHAR*)GetString(indstr));
//#else
    //mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_NEW_SMS, event_id, NULL);
//#endif
*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_start_msg_sub_anm
 * DESCRIPTION
 *  Start sub-LCD msg animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_start_msg_sub_anm(void)
{
#ifdef __MMI_SUBLCD__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_ALL, NULL) <= 0)
    {
        ExecSubLCDCurrExitHandler();
        if (GetMessagesCurrScrnID() == SCR_ID_MSG_MSG_WAITING_IND)
        {
            ShowCategory304Screen(IMG_NEW_VOICEMAIL_PIC_SUBLCD_MSG, NULL);
        }
        else
        {
            ShowCategory304Screen(IMG_NEW_SMS_PIC_SUBLCD_MSG, NULL);
        }
        SetSubLCDExitHandler(mmi_msg_callback_msg_sub_anm);
        //              srv_gpio_play_pattern(SRV_GPIO_PATN_LED_MSG_IN, SRV_GPIO_PATN_PLAY_START);
        //              StartTimer(MESSAGES_SUBLCD_TIMER_ID, MESSAGES_SUBLCD_TIME_OUT, mmi_msg_callback_msg_sub_anm);
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_stop_msg_sub_anm
 * DESCRIPTION
 *  Stop sub-LCD msg animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_stop_msg_sub_anm(void)
{
    
#ifdef __MMI_SUBLCD__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetMessagesCurrScrnID(0);   /* messagesCurrScrnID */
    mmi_msg_callback_msg_sub_anm();
    GoBackSubLCDHistory();
#endif /* __MMI_SUBLCD__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_callback_msg_sub_anm
 * DESCRIPTION
 *  Call back sub-LCD msg animation
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_callback_msg_sub_anm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_gpio_play_pattern(SRV_GPIO_PATN_LED_MSG_IN, SRV_GPIO_PATN_PLAY_STOP);
    StopTimer(MESSAGES_SUBLCD_TIMER_ID);
}
 

#ifdef __UNIFIED_MESSAGE_BACKGROUND_SEND_SUPPORT__
void mmi_sms_notify_send_failed(U16 msg_id)
{
	WCHAR preview_text[MMI_PHB_NAME_LENGTH + MMI_PHB_NAME_LENGTH + MMI_PHB_NAME_LENGTH + 1 + 1];
	mmi_frm_nmgr_alert_struct alert_info;
	memset(&alert_info, 0, sizeof(mmi_frm_nmgr_alert_struct));	 
	/*fill in the basic info*/
	alert_info.scen_id = MMI_SCENARIO_ID_GENERAL; // your scenario ID
	alert_info.event_type = MMI_EVENT_SEND_FAIL_MSG; // your event id
	{
		U16 number[SRV_SMS_MAX_ADDR_LEN];
		U16 name[MMI_PHB_NAME_LENGTH + 1];
		U16 *temp;
		 #ifndef __MMI_SMS_SLIM__
		srv_sms_get_msg_address(msg_id, (S8*)number);
			#else
			mmi_sms_get_hilite_msg_addr((S8*)number);
			#endif
		srv_phb_get_name_by_number(number, name, MMI_PHB_NAME_LENGTH);

		if (name[0])
		{
			temp = name;
		}
		else
		{
			temp = number;
		}
		mmi_wsprintf(preview_text, ENCODING_LENGTH * (MMI_PHB_NAME_LENGTH + MMI_PHB_NAME_LENGTH), STR_ID_SMS_FAILED_TO_SEND_TO, (WCHAR*)temp);
	}
	alert_info.status_bar_para.display_string = preview_text;
	#if !defined (__MMI_UM_SLIM__) || defined(__MMI_NCENTER_SUPPORT__ )
	mmi_um_alert_um_outbox_alert(&alert_info);
	#endif
}
#endif /* __UNIFIED_MESSAGE_BACKGROUND_SEND_SUPPORT__ */



#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_need_new_sim_msg_ind
 * DESCRIPTION
 *  check if new msg indication is required
 * PARAMETERS
 *  void
 * RETURNS
 *  1: indication required, 0: indication not required
 *****************************************************************************/
U8 mmi_msg_need_new_sim_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 msg_id = g_msg_cntx.sim_msg_ind_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Return false if the new msg is deleted by AT */
    if ((srv_sms_is_msg_exist(msg_id) == MMI_FALSE) ||
        (srv_sms_get_msg_storage_type(msg_id) != SRV_SMS_STORAGE_SIM))
    {
        g_msg_cntx.sim_msg_ind_in_idle = MMI_FALSE;
        g_msg_cntx.msg_ind_after_call = MMI_FALSE;
        return KAL_FALSE;
    }
    else
    {
        return g_msg_cntx.sim_msg_ind_in_idle;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_entry_new_sim_msg_ind
 * DESCRIPTION
 *  Entry new sim message indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_entry_new_sim_msg_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_notify_enum event_id = MMI_EVENT_SMS;
#ifdef __OP01__
    U16 indstr = 0;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if (MMI_SIM_TOTAL >= 2)
    if (g_msg_cntx.curr_sim == MMI_SIM2)
    {
        event_id = MMI_EVENT_SIM2_SMS;
    }
    else if (g_msg_cntx.curr_sim == MMI_SIM3)
    {
        event_id = MMI_EVENT_SIM3_SMS;
    }
    else if (g_msg_cntx.curr_sim == MMI_SIM4)
    {
        event_id = MMI_EVENT_SIM4_SMS;
    }
#endif /* (MMI_SIM_TOTAL >= 2) */

#ifdef __OP01__
#if (MMI_SIM_TOTAL == 1)
    indstr = STR_RECEIVED_SMS;
#else /* (MMI_SIM_TOTAL >= 2) */
    if (g_msg_cntx.curr_sim == MMI_SIM1)
    {           
        indstr = STR_ID_SMS_MASTER_RECEIVED_SMS;
    }
    else if (g_msg_cntx.curr_sim == MMI_SIM2)
    {
        indstr = STR_ID_SMS_SLAVE_RECEIVED_SMS;
    }
#if (MMI_MAX_SIM_NUM >= 3)
    else if (g_msg_cntx.curr_sim == MMI_SIM3)
    {           
        indstr = STR_ID_SMS_SIM3_RECEIVED_SMS;
    }
#endif
#if (MMI_MAX_SIM_NUM >= 4)
    else if (g_msg_cntx.curr_sim == MMI_SIM4)
    {
        indstr = STR_ID_SMS_SIM4_RECEIVED_SMS;
    }
#endif
#endif /* (MMI_SIM_TOTAL >= 2) */
    mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_SIM_SMS, event_id, (WCHAR*)GetString(indstr));
#else
    mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_SIM_SMS, event_id, NULL);
#endif
}
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT_ */

#ifndef __ULC_SLIM_EMS__
#if(!EMS_USE_GSM_EXTENDED)

/* Call after EMSUnpack */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertGSM7BitDefaultEncodingToAscii
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertGSM7BitDefaultEncodingToAscii(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
    {
    #if(EMS_BYTE_ORDER_BIG_ENDIAN)
        c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
    #else 
        c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
    #endif 
        if ((c & 0xff00) != 0)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
        }
        else if (c == EMS_ESCAPE_CHARACTER)
        {
            c = EMS_SPACE_CHARACTER;
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
        }
        else
        {
            if (c == EMS_CR_CHARACTER)
            {
                ForwardCurrentPosition(data, 1);
                CancelCurrentPosition(data, 1);
                BackwardCurrentPosition(data, 1);
            }
            else
            {
                c = DefaultToAsciiArray[c];
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
        }
        if (ForwardCurrentPosition(data, 1) != 1)
        {
            break;
        }
    }
    ResetCurrentPosition(data);
}

/* Call before EMSPack  */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertAsciiEncodingToGSM7BitDefault
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertAsciiEncodingToGSM7BitDefault(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
    {
    #if(EMS_BYTE_ORDER_BIG_ENDIAN)
        c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
    #else 
        c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
    #endif 
        if ((c & 0xff00) == 0)
        {
            c = AsciiToDefaultArray[c];
        }
    #if(EMS_BYTE_ORDER_BIG_ENDIAN)
        textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
        textBuffer[OffsetToText + 0] = (U8) (c >> 8);
    #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
        textBuffer[OffsetToText] = (U8) (c & 0xff);
        textBuffer[OffsetToText + 1] = (U8) (c >> 8);
    #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
        if (ForwardCurrentPosition(data, 1) != 1)
        {
            break;
        }
    }
    ResetCurrentPosition(data);
}

#if defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__)

/* Start : JP */
/* Call after EMSUnpack */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertGSM7BitDefaultEncodingToAsciiWithExtended
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertGSM7BitDefaultEncodingToAsciiWithExtended(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;
    EMSObject *object;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
            if (gui_EMS_input_box_get_next_object(data, &data->CurrentPosition, &c, &object) != 1)
            {
                continue;
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if (c == EMS_ESCAPE_CHARACTER)
            {
                U16 next_char = 0;

            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);

                if (ForwardCurrentPosition(data, 1) != 1)
                {
                    break;
                }
                CancelCurrentPosition(data, 1);
                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
                c = DefaultToExtendedAsciiArray[c];

                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                //textBuffer[OffsetToText]=(U8)(c&0xff);
                //textBuffer[OffsetToText+1]=(U8)(c>>8);
                next_char =
                    (U16) (textBuffer[data->CurrentPosition.OffsetToText] |
                           (textBuffer[data->CurrentPosition.OffsetToText + 1] << 8));

                /* if(ForwardCurrentPosition(data,1)!=1) break; */
                data->CurrentPosition.OffsetToText += ENCODING_LENGTH;  /* JP 20050701 */
                CancelCurrentPosition(data, 1);
                textBufferLength -= ENCODING_LENGTH;    /* JP */

                /* OffsetToText=data->CurrentPosition.OffsetToText; */

                /* c=(U16)(textBuffer[OffsetToText]|(textBuffer[OffsetToText+1]<<8)); */
                c = next_char;
                c = DefaultToExtendedAsciiArray[c];
                if (c == 0x00)
                {
                    textBuffer[OffsetToText] = (U8) (next_char & 0xff);
                    textBuffer[OffsetToText + 1] = (U8) (next_char >> 8);
                    data->CurrentPosition.OffsetToText -= 2;
                }
                else
                {
                    textBuffer[OffsetToText] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 1] = (U8) (c >> 8);
                }
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else
            {
                c = DefaultToAsciiArray[c];
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            /* if(ForwardCurrentPosition(data,1)!=1) break; */
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER_UCS2) c=EMS_EURO_CHARACTER; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    ResetCurrentPosition(data);
}

/* Call before EMSPack  */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertAsciiEncodingToGSM7BitDefaultWithExtended
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertAsciiEncodingToGSM7BitDefaultWithExtended(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;
    EMSObject *object;

#if(EMS_BYTE_ORDER_BIG_ENDIAN)
    U8 ESC_string[] = {0x00, 0x1B};
#else 
    U8 ESC_string[] = {0x1B, 0x00};
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);

    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
            if (gui_EMS_input_box_get_next_object(data, &data->CurrentPosition, &c, &object) != 1)
            {
                continue;
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if (UI_TEST_GSM_EXTENDED(c))
            {
                data->CurrentPosition.OffsetToText -= ENCODING_LENGTH;  /* JP 20050701 */
                AddString(data, ESC_string, 1, NULL);
                OffsetToText = data->CurrentPosition.OffsetToText;
                /* MTK Elvis 20031126 */
                textBufferLength += ENCODING_LENGTH;
                /* MTK end */
                c = ExtendedAsciiToDefaultArray[c];
                data->CurrentPosition.OffsetToText += ENCODING_LENGTH;  /* JP 20050701 */

            }
            else
            {
                c = AsciiToDefaultArray[c];
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            // if(ForwardCurrentPosition(data,1)!=1) break; /* JP */
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER) c=EMS_EURO_CHARACTER_UCS2; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    ResetCurrentPosition(data);
}

#else /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 

/* Call after EMSUnpack */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertGSM7BitDefaultEncodingToAsciiWithExtended
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertGSM7BitDefaultEncodingToAsciiWithExtended(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if ((c & 0xff00) != 0)
            {
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else if (c == EMS_ESCAPE_CHARACTER)
            {
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);

                /* if(ForwardCurrentPosition(data,1)!=1) break; */
                data->CurrentPosition.OffsetToText += 2;
                if ((OffsetToText = data->CurrentPosition.OffsetToText) >= textBufferLength)
                {
                    break;
                }

                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
                c = DefaultToExtendedAsciiArray[c];
                if (c == 0x00)
                {
                    CancelCurrentPosition(data, 1);
                    textBufferLength = data->textLength;
                    data->CurrentPosition.OffsetToText -= 2;
                }
                else
                {
                    textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 0] = (U8) (c >> 8);
                }
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);

                /* if(ForwardCurrentPosition(data,1)!=1) break; */
                data->CurrentPosition.OffsetToText += 2;

                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
                c = DefaultToExtendedAsciiArray[c];
                if (c == 0x00)
                {
                    CancelCurrentPosition(data, 1);
                    textBufferLength = data->textLength;
                    data->CurrentPosition.OffsetToText -= 2;
                }
                else
                {
                    textBuffer[OffsetToText] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 1] = (U8) (c >> 8);
                }
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else
            {
                c = DefaultToAsciiArray[c];
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            /* if(ForwardCurrentPosition(data,1)!=1) break; */
            data->CurrentPosition.OffsetToText += 2;
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 

            //if there is an end character between the sms text, convert it to a SPACE character.
            if (c == '\0')
            {
                c = ' ';

            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else
            {
            /* if(c==EMS_EURO_CHARACTER_UCS2) c=EMS_EURO_CHARACTER; */
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                /* if(ForwardCurrentPosition(data,1)!=1) break; */
            }

            data->CurrentPosition.OffsetToText += 2;
        }
    }
    ResetCurrentPosition(data);
}

/* Call before EMSPack  */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertAsciiEncodingToGSM7BitDefaultWithExtended
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertAsciiEncodingToGSM7BitDefaultWithExtended(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if ((c & 0xff00) == 0)
            {
                if (c == EMS_ESCAPE_CHARACTER)
                {
                #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                    textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 0] = (U8) (c >> 8);
                #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                    textBuffer[OffsetToText] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 1] = (U8) (c >> 8);
                #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                    /* if(ForwardCurrentPosition(data,1)!=1) break; */
                    data->CurrentPosition.OffsetToText += 2;
                    if ((OffsetToText = data->CurrentPosition.OffsetToText) >= textBufferLength)
                    {
                        break;
                    }
                    OffsetToText = data->CurrentPosition.OffsetToText;

                #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                    c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
                #else 
                    c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
                #endif 
                    c = ExtendedAsciiToDefaultArray[c];
                }
                else
                {
                    c = AsciiToDefaultArray[c];
                }
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            /* if(ForwardCurrentPosition(data,1)!=1) break; */
            data->CurrentPosition.OffsetToText += 2;
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER) c=EMS_EURO_CHARACTER_UCS2; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            /* if(ForwardCurrentPosition(data,1)!=1) break; */
            data->CurrentPosition.OffsetToText += 2;
        }
    }
    ResetCurrentPosition(data);
}

#endif /* defined(__MMI_SMART_MESSAGE_MO__) && !defined(__MMI_MESSAGES_EMS__) */ 
/* End : JP */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertGSM7BitDefaultEncodingToAsciiWithoutEMSlib
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertGSM7BitDefaultEncodingToAsciiWithoutEMSlib(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    data->CurrentPosition.OffsetToText = 0;
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if ((c & 0xff00) != 0)
            {
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else if (c == EMS_ESCAPE_CHARACTER)
            {
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText+1]=(U8)(c&0xff);
                textBuffer[OffsetToText+0]=(U8)(c>>8);

                if ((data->CurrentPosition.OffsetToText + 2) > textBufferLength)
                {
                    break;
                }
				data->CurrentPosition.OffsetToText += 2;

                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
                c = DefaultToExtendedAsciiArray[c];

                if (c == 0x00)
                {
                    data->CurrentPosition.OffsetToText -= 2;
                }
                else
                {
                    textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 0] = (U8) (c >> 8);
                }
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText]=(U8)(c&0xff);
                textBuffer[OffsetToText+1]=(U8)(c>>8);

                if ((data->CurrentPosition.OffsetToText + 2) > textBufferLength)
                {
                    break;
                }
				data->CurrentPosition.OffsetToText += 2;
				
                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
                c = DefaultToExtendedAsciiArray[c];

                if (c == 0x00)
                {
                    data->CurrentPosition.OffsetToText -= 2;
                }
                else
                {
                    textBuffer[OffsetToText] = (U8) (c & 0xff);
                    textBuffer[OffsetToText + 1] = (U8) (c >> 8);
                }
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else
            {
                c = DefaultToAsciiArray[c];
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            data->CurrentPosition.OffsetToText += 2;
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER_UCS2) c=EMS_EURO_CHARACTER; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            data->CurrentPosition.OffsetToText += 2;
        }
    }
    data->CurrentPosition.OffsetToText = 0;
}

#else /* (!EMS_USE_GSM_EXTENDED) */ 

/* Call after EMSUnpack */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertGSM7BitDefaultEncodingToAscii
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertGSM7BitDefaultEncodingToAscii(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if (c == EMS_ESCAPE_CHARACTER)
            {
                c = EMS_SPACE_CHARACTER;
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else
            {
                c = DefaultToAsciiArray[c];
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER_UCS2) c=EMS_EURO_CHARACTER; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    ResetCurrentPosition(data);
}

/* Call before EMSPack  */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertAsciiEncodingToGSM7BitDefault
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertAsciiEncodingToGSM7BitDefault(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            c = AsciiToDefaultArray[c];
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER) c=EMS_EURO_CHARACTER_UCS2; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    ResetCurrentPosition(data);
}

/* Call after EMSUnpack */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertGSM7BitDefaultEncodingToAsciiWithExtended
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertGSM7BitDefaultEncodingToAsciiWithExtended(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;
    EMSObject *object;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);
    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
            if (gui_EMS_input_box_get_next_object(data, &data->CurrentPosition, &c, &object) != 1)
            {
                continue;
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if (c == EMS_ESCAPE_CHARACTER)
            {
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);

                if (ForwardCurrentPosition(data, 1) != 1)
                {
                    break;
                }
                CancelCurrentPosition(data, 1);
                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
                c = DefaultToExtendedAsciiArray[c];

                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);

                if (ForwardCurrentPosition(data, 1) != 1)
                {
                    break;
                }
                CancelCurrentPosition(data, 1);
                OffsetToText = data->CurrentPosition.OffsetToText;

                c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
                c = DefaultToExtendedAsciiArray[c];

                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            else
            {
                c = DefaultToAsciiArray[c];
            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 0] = (U8) (c >> 8);
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                textBuffer[OffsetToText] = (U8) (c & 0xff);
                textBuffer[OffsetToText + 1] = (U8) (c >> 8);
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER_UCS2) c=EMS_EURO_CHARACTER; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    ResetCurrentPosition(data);
}

/* Call before EMSPack  */


/*****************************************************************************
 * FUNCTION
 *  EMS_ConvertAsciiEncodingToGSM7BitDefaultWithExtended
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void EMS_ConvertAsciiEncodingToGSM7BitDefaultWithExtended(EMSData *data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 c, OffsetToText;
    U8 *textBuffer = data->textBuffer;
    U16 textBufferLength = data->textLength;
    EMSObject *object;

#if(EMS_BYTE_ORDER_BIG_ENDIAN)
    U8 ESC_string[] = {0x00, 0x1B};
#else 
    U8 ESC_string[] = {0x1B, 0x00};
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (textBuffer == NULL)
    {
        return;
    }
    ResetCurrentPosition(data);

    if (data->dcs == SMSAL_DEFAULT_DCS)
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
            if (gui_EMS_input_box_get_next_object(data, &data->CurrentPosition, &c, &object) != 1)
            {
                continue;
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            if (UI_TEST_GSM_EXTENDED(c))
            {
                AddString(data, ESC_string, 1, NULL);
                OffsetToText = data->CurrentPosition.OffsetToText;
                /* MTK Elvis 20031126 */
                textBufferLength += ENCODING_LENGTH;
                /* MTK end */
                c = ExtendedAsciiToDefaultArray[c];
            }
            else
            {
                c = AsciiToDefaultArray[c];
            }
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    else
    {
        while ((OffsetToText = data->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16) (textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else 
            c = (U16) (textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif 
            /* if(c==EMS_EURO_CHARACTER) c=EMS_EURO_CHARACTER_UCS2; */
        #if(EMS_BYTE_ORDER_BIG_ENDIAN)
            textBuffer[OffsetToText + 1] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 0] = (U8) (c >> 8);
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            textBuffer[OffsetToText] = (U8) (c & 0xff);
            textBuffer[OffsetToText + 1] = (U8) (c >> 8);
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            if (ForwardCurrentPosition(data, 1) != 1)
            {
                break;
            }
        }
    }
    ResetCurrentPosition(data);
}

#endif /* (!EMS_USE_GSM_EXTENDED) */


#ifdef __SMS_R8_NATION_LANGUAGE__
#ifndef __UNIFIED_COMPOSER_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_ems_handle_national_lang_change
 * DESCRIPTION
 *  Handle the national language change
 * PARAMETERS
 *  pEms            [IN/OUT]    EMSData
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_ems_handle_national_lang_change(EMSData *pEms)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pEms->dcs == SMSAL_DEFAULT_DCS)
    {
        EMSNationalLanguageType curr_lang_type;                
        EMSNationalLanguageType sys_lang_type;
        EMSNationalLanguage sys_lang;
    
        curr_lang_type = mmi_7bit_get_national_lang();

        sys_lang_type = mmi_msg_get_system_ems_lang_type();

        if (curr_lang_type != sys_lang_type)
        {
            mmi_7bit_set_national_lang(sys_lang_type);
        }

        mmi_7bit_get_national_lang_table(&sys_lang);
        
        if ((pEms->NLTable.locking_shift != sys_lang.locking_shift) ||
            (pEms->NLTable.single_shift != sys_lang.single_shift))
        {
            U16 edit_char_num = pEms->textLength / 2;
            MMI_BOOL is_ucs2;

            is_ucs2 = mmi_sms_gui_check_ucs2((S8*)pEms->textBuffer, edit_char_num);

            if (is_ucs2 == MMI_TRUE)
            {                
                mmi_msg_ems_remove_escape_char(pEms);
                EMSSetDCSandCancelRedundancyData(pEms, SMSAL_UCS2_DCS);
            }
            else
            {
                /* Check if it's auto dection mode here, don't need to add or remove escape char */
                if (mmi_7bit_get_table_mechanism() != EMS_AUTO_DETECTION)
                {
                    EMSSetNationalLanguageandCancelRedundancy(pEms, &sys_lang);

                    if (mmi_msg_ems_need_add_or_remove_escape_char(pEms) == MMI_TRUE)
                    {
                        mmi_msg_ems_remove_escape_char(pEms);
                        mmi_msg_ems_add_escape_char(pEms);
                    }
                }
            }
        }

        if (curr_lang_type != sys_lang_type)
        {
            mmi_7bit_set_national_lang(curr_lang_type);
        }
    }
}
#endif

#else /* __SMS_R8_NATION_LANGUAGE__ */

#ifndef __UNIFIED_COMPOSER_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_handle_uc_ems_data
 * DESCRIPTION
 *  Handle ems data to UC (remove unused escape char)
 * PARAMETERS
 *  pEms            [IN/OUT]    EMSData
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_handle_edit_ems_data(EMSData *pEms)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pEms->dcs == SMSAL_DEFAULT_DCS)
    {
        if (mmi_msg_ems_need_add_or_remove_escape_char(pEms) == MMI_TRUE)
        {
            mmi_msg_ems_remove_escape_char(pEms);
            mmi_msg_ems_add_escape_char(pEms);
        }
    }
}
#endif
#endif /* __SMS_R8_NATION_LANGUAGE__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_ems_remove_escape_char
 * DESCRIPTION
 *  remove the escape char in the EMS data
 * PARAMETERS
 *  pEms        [IN]    EMSData
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_ems_remove_escape_char(EMSData *pEms)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pEms->textLength > 0)
    {
        U16 c;
        U16 OffsetToText;
        U8 *textBuffer = pEms->textBuffer;
        U16 textBufferLength = pEms->textLength;

        ResetCurrentPosition(pEms);

        while ((OffsetToText = pEms->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if (EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16)(textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */
            c = (U16)(textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */
        
            if (c == EMS_ESCAPE_CHARACTER)
            {
                EMSPosition dummyposition;
                U16 ret_char;
                EMSObject *ret_object;

                dummyposition = pEms->CurrentPosition;

                while (EMSGetNextObject(pEms, &dummyposition, &ret_char, &ret_object) == 2)
                {
                    ForwardCurrentPosition(pEms, 1);
                    dummyposition = pEms->CurrentPosition;

                    if (ret_object->Type == EMS_TYPE_TEXT_FORMAT)
                    {
                        if (EMSGetPreviousObject(pEms, &dummyposition, &ret_char, &ret_object) == 1)
                        {
                            BackwardCurrentPosition(pEms, 1);
                            break;
                        }

                        dummyposition = pEms->CurrentPosition;
                    }
                }

            #if(EMS_BYTE_ORDER_BIG_ENDIAN)
                if (ForwardCurrentPosition(pEms, 1) != 1)
                {
                    break;
                }

                CancelCurrentPosition(pEms, 1);

                OffsetToText = pEms->CurrentPosition.OffsetToText;
                textBufferLength -= ENCODING_LENGTH;
            #else /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
                if (ForwardCurrentPosition(pEms, 1) != 1)
                {
                    break;
                }

                CancelCurrentPosition(pEms, 1);

                c = (U16)(textBuffer[pEms->CurrentPosition.OffsetToText] | (textBuffer[pEms->CurrentPosition.OffsetToText + 1] << 8));
                
                OffsetToText = pEms->CurrentPosition.OffsetToText;
                textBufferLength -= ENCODING_LENGTH;
            #endif /* (EMS_BYTE_ORDER_BIG_ENDIAN) */ 
            }
            
            if (ForwardCurrentPosition(pEms, 1) != 1)
            {
                break;
            }
        }

        GoToEndPosition(pEms);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_ems_add_escape_char
 * DESCRIPTION
 *  Add the escape char to the EMS data
 * PARAMETERS
 *  pEms        [IN]    EMSData
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_ems_add_escape_char(EMSData *pEms)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (pEms->textLength > 0)
    {
        U16 c;
        U16 OffsetToText;
        U8 *textBuffer = pEms->textBuffer;
        U16 textBufferLength = pEms->textLength;
		EMSTextFormat *txt_fmt_p = NULL;
		EMSObject *ret_object;
		EMSPosition dummyposition; 
		U16 ret_char;
		U16 curr_object_offset = 0;
		U16 curr_object_len = 0;

        ResetCurrentPosition(pEms);

        while ((OffsetToText = pEms->CurrentPosition.OffsetToText) < textBufferLength)
        {
        #if (EMS_BYTE_ORDER_BIG_ENDIAN)
            c = (U16)(textBuffer[OffsetToText + 1] | (textBuffer[OffsetToText] << 8));
        #else /* EMS_BYTE_ORDER_BIG_ENDIAN */
            c = (U16)(textBuffer[OffsetToText] | (textBuffer[OffsetToText + 1] << 8));
        #endif /* EMS_BYTE_ORDER_BIG_ENDIAN */

			dummyposition = pEms->CurrentPosition;
			if (EMSGetNextObject(pEms, &dummyposition, &ret_char, &ret_object) == 2)
			{
				curr_object_offset = dummyposition.OffsetToText;
				curr_object_len = dummyposition.Object->data->text_format.textLength;
			}
            if (mmi_7bit_check_gsm_ext_character(c))
            {
                EMSTextFormat txt_fmt;
                U8 ret = EMS_OK;
            #if (EMS_BYTE_ORDER_BIG_ENDIAN)
                U8 ESC_string[] = {0x00, 0x1B};
            #else /* EMS_BYTE_ORDER_BIG_ENDIAN */
                U8 ESC_string[] = {0x1B, 0x00};
            #endif /* EMS_BYTE_ORDER_BIG_ENDIAN */

                dummyposition = pEms->CurrentPosition;
        		if (curr_object_offset + curr_object_len <= pEms->CurrentPosition.OffsetToText)
				{
					ResetTextFormat(&txt_fmt);
					txt_fmt_p = &txt_fmt;
				}			
                
                while (EMSGetNextObject(pEms, &dummyposition, &ret_char, &ret_object) == 2)
                {
                    ForwardCurrentPosition(pEms, 1);
                    dummyposition = pEms->CurrentPosition;

                    if (ret_object->Type == EMS_TYPE_TEXT_FORMAT)
                    {
                        if (EMSGetPreviousObject(pEms, &dummyposition, &ret_char, &ret_object) == 1)
                        {
                            if (pEms->CurrentTextFormatObj)
                            {
                                txt_fmt = pEms->CurrentTextFormatObj->data->text_format;
                                txt_fmt.textLength = 2;
                                txt_fmt_p = &txt_fmt;
                            }

                            BackwardCurrentPosition(pEms, 1);
                            break;
                        }

                        dummyposition = pEms->CurrentPosition;
                    }
                }

                ret = AddString(pEms, ESC_string, 1, txt_fmt_p);

                if (ret != EMS_OK)
                {
                    EMSPosition add_position;

                    add_position = pEms->CurrentPosition;

                    ForwardCurrentPosition(pEms, 1);

                    dummyposition = pEms->CurrentPosition;

                    //If it is the last character, remove it.
                    if (EMSGetNextObject(pEms, &dummyposition, &ret_char, &ret_object) == 0)
                    {
                        CancelCurrentPosition(pEms, 1);
                    }
                    else
                    {
                        GoToEndPosition(pEms);
                        CancelCurrentPosition(pEms, 1);
                        MoveCursorToPosition(pEms, &add_position);
                        ret = AddString(pEms, ESC_string, 1, txt_fmt_p);

                        if (ret != EMS_OK)
                        {
                            break;
                        }
                    }
                }

                OffsetToText = pEms->CurrentPosition.OffsetToText;

                textBufferLength = pEms->textLength;
            }

            if (ForwardCurrentPosition(pEms, 1) != 1)
            {
                break;
            }
        }

        GoToEndPosition(pEms);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_ems_need_add_or_remove_escape_char
 * DESCRIPTION
 *  Check whether the ems data have unused escape char or add escape char
 * PARAMETERS
 *  pEms        [IN]    EMSData
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_msg_ems_need_add_or_remove_escape_char(EMSData *pEms)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *text_buff = (U16*)pEms->textBuffer;
    U16 char_num = pEms->textLength / ENCODING_LENGTH;
    U16 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (i < char_num)
    {
        U16 c = text_buff[i++];

        if (c == EMS_ESCAPE_CHARACTER)
        {
            c = text_buff[i++];

            //Unused escape character, need to remove
            if (!mmi_7bit_check_gsm_ext_character(c))
            {
                return MMI_TRUE;
            }
        }
        else
        {
            //Need to add a escape character
            if (mmi_7bit_check_gsm_ext_character(c))
            {
                return MMI_TRUE;
            }
        }
    }

    return MMI_FALSE;
}
#endif /* __ULC_SLIM_EMS__ */

#ifdef __SMS_R8_NATION_LANGUAGE__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_get_system_ems_lang_type
 * DESCRIPTION
 *  Get System EMS Language Type
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
EMSNationalLanguageType mmi_msg_get_system_ems_lang_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    EMSNationalLanguageType lang;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (strcmp((PS8)gLanguageArray[gCurrLangIndex].aLangSSC, SSC_TURKISH) == 0)
    {
        lang = EMS_NL_TURKISH;
    }
    else if (strcmp((PS8)gLanguageArray[gCurrLangIndex].aLangSSC, SSC_SPANISH) == 0)
    {
        lang = EMS_NL_SPANISH;
    }
    else if (strcmp((PS8)gLanguageArray[gCurrLangIndex].aLangSSC, SSC_PORTUGUESE) == 0)
    {
        lang = EMS_NL_PORTUGUESE;
    }
    else
    {
        lang = EMS_NL_DEFAULT;
    }

    return lang;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_set_system_ems_lang_type
 * DESCRIPTION
 *  Set System EMS Language Type
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_set_system_ems_lang_type(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/    
    EMSNationalLanguageType lang;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    lang = mmi_msg_get_system_ems_lang_type();

    mmi_7bit_set_national_lang(lang);
}

#endif /* __SMS_R8_NATION_LANGUAGE__ */
#ifdef __MMI_URI_AGENT__

#define MMI_MSG_MAX_URI_RECIPIENT		6
#define MMI_MSG_MAX_URI_TOKEN_LENGTH	(MAX_DIGITS_SMS + 10)
#define MMI_MSG_MAX_URI_BUFF_SIZE       2048

typedef enum
{
	SMS_URI_TOKEN_SCHEME,
	SMS_URI_TOKEN_RECIPIENT,
	SMS_URI_TOKEN_GSTN_PHONE,
	SMS_URI_TOKEN_SMS_QUALIFIER,
	SMS_URI_TOKEN_SMSC,
	SMS_URI_TOKEN_PID,
	SMS_URI_TOKEN_VALUE,
	SMS_URI_TOKEN_BODY,
	SMS_URI_TOKEN_BODY_CONTENT,
	SMS_URI_TOKEN_EOF,
	SMS_URI_TOKEN_ERROR
}mmi_msg_uri_token_enum;


typedef enum
{
	SMS_URI_STATE_START,
	SMS_URI_STATE_SCHEME,
	SMS_URI_STATE_RECIPIENT,
	SMS_URI_STATE_GSTN_PHONE,
	SMS_URI_STATE_SMS_QUALIFIER,
	SMS_URI_STATE_SMS_BODY,
	SMS_URI_STATE_VALUE,	
	SMS_URI_STATE_DONE
}mmi_msg_uri_state_enum;


typedef enum
{
	SMS_URI_MASK_GSTN = 0x01,
	SMS_URI_MASK_SMSC = 0x02,
	SMS_URI_MASK_PID = 0x04
}mmi_msg_uri_mask_enum;


typedef struct
{
	S8 ucs2_dest_addr[(MAX_DIGITS_SMS + 1) * ENCODING_LENGTH];
	U8 smsc_addr[MAX_DIGITS_SMS + 1];
	U16 pid;
	U8 mask;
}mmi_msg_uri_recipient_struct;


typedef struct
{
	U16 uri_offset;
	S8 *url_string;
	S8 *sms_uri_url;
	S8 token_string[MMI_MSG_MAX_URI_TOKEN_LENGTH + 1];
	mmi_msg_uri_token_enum token;
}mmi_msg_uri_struct;


extern EMSData *GetEMSDataForEdit(EMSData **p, U8 force);

static S8 mmi_msg_uri_get_next_char(void);
static void mmi_msg_uri_unget_next_char(void);

static MMI_BOOL mmi_msg_is_alpha(S8 ascii_char);
static void mmi_msg_to_lower(S8* str);

static mmi_msg_uri_token_enum mmi_msg_get_uri_token(void);
static void mmi_msg_uri_go_back_from_comfirm(void);
static void mmi_msg_uri_request_write_sms(void);
static void mmi_msg_uri_deinit(void);

static mmi_msg_uri_struct *sms_uri_data;


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_uri_request_handle
 * DESCRIPTION
 *  URI scheme "sms" or "smsto" handle application function
 * PARAMETERS
 *  ura_appid		[IN]	URI request application ID
 *	url				[IN]	URL string
 *	param			[IN]	param part of URL string(except the URI scheme)
 *	options			[IN]	Option
 *	callback		[IN]	URI request handle callbakc  function
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_uri_request_handle(
 			srv_uriagent_appid_enum ura_appid,
 			char *url,
 			char *param,
 			srv_uriagent_options_enum options,
 			srv_uriagent_uri_request_hdlr_cb callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_sms_is_sms_valid() == MMI_TRUE)
    {
    	sms_uri_data = OslMalloc(sizeof(mmi_msg_uri_struct));

    	sms_uri_data->url_string = OslMalloc(strlen(url) + 1);
    	strcpy(sms_uri_data->url_string, (S8*)url);
    	
    	if (options == SRV_URIAGENT_OPTION_NEED_CONFIRM_POPUP)
    	{
            mmi_sms_entry_confirm(
                GRP_ID_ROOT,
                STR_ID_SMS_SEND_SMS_QUERY,
                mmi_msg_uri_request_write_sms,
                mmi_msg_uri_go_back_from_comfirm,
                MMI_TRUE);
    	}
    	else
    	{
    		mmi_msg_uri_request_write_sms();
    	}
    }
    else
    {
        mmi_sms_display_popup_ext(
            STR_GLOBAL_NOT_AVAILABLE,
            MMI_EVENT_FAILURE);
    }

	if (callback != NULL)
	{
		callback(ura_appid, SRV_URIAGENT_APPID_SMS, MMI_TRUE);
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_uri_go_back_from_comfirm
 * DESCRIPTION
 *  Go Back from the Send SMS confirm screen
 * PARAMETERS
 *  void  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_uri_go_back_from_comfirm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_msg_uri_deinit();

	mmi_frm_scrn_close_active_id();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_uri_deinit
 * DESCRIPTION
 *  free the uri data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_uri_deinit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (sms_uri_data != NULL)
	{
		OslMfree(sms_uri_data->url_string);
		OslMfree(sms_uri_data);
		sms_uri_data = NULL;
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_uri_request_write_sms
 * DESCRIPTION
 *  Parse the URL and Launch the SMS Editor
 * PARAMETERS
 *  void  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_uri_request_write_sms(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_msg_uri_token_enum curr_token;
	S8 *content = NULL;
    S8* ucs2_content = NULL;
	mmi_msg_uri_recipient_struct *recipient;
	S8 *ucs2_addr_list[MMI_MSG_MAX_URI_RECIPIENT];
    U16 max_recipient_num;
	U16 recipient_num = 0;
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	sms_uri_data->uri_offset = 0;

    recipient = OslMalloc(sizeof(mmi_msg_uri_recipient_struct) * MMI_MSG_MAX_URI_RECIPIENT);

	curr_token = mmi_msg_get_uri_token();

	if (curr_token == SMS_URI_TOKEN_SCHEME)
	{
		curr_token = mmi_msg_get_uri_token();
        
        do
        {   
            switch (curr_token)
            {
        		case SMS_URI_TOKEN_GSTN_PHONE:
        		{
        			if (recipient_num < MMI_MSG_MAX_URI_RECIPIENT)
        			{
        				recipient[recipient_num].mask = 0;
        			}
        			
        			if (curr_token == SMS_URI_TOKEN_GSTN_PHONE)
        			{
        				if (recipient_num < MMI_MSG_MAX_URI_RECIPIENT)
        				{
                            mmi_asc_to_ucs2(recipient[recipient_num].ucs2_dest_addr,
                                sms_uri_data->token_string);

                            recipient[recipient_num].mask |= SMS_URI_MASK_GSTN;
        				}
        			}
        			else
        			{
                        curr_token = SMS_URI_TOKEN_ERROR;
        		        return;
        			}

        			recipient_num++;
                    break;
        		}            
                case SMS_URI_TOKEN_SMSC:
                {
                    mmi_msg_get_uri_token();
                    if (recipient_num < MMI_MSG_MAX_URI_RECIPIENT)
                    {
                        strncpy((S8*)recipient[recipient_num].smsc_addr,
                            sms_uri_data->token_string, MAX_DIGITS_SMS);
                        recipient[recipient_num].mask |= SMS_URI_MASK_SMSC;
                    }
                    
                    break;
                }
                
                case SMS_URI_TOKEN_PID:
                {
                    mmi_msg_get_uri_token();
                    if (recipient_num < MMI_MSG_MAX_URI_RECIPIENT)
                    {
                        recipient[recipient_num].pid = (U16)atoi(sms_uri_data->token_string);
                        recipient[recipient_num].mask |= SMS_URI_MASK_PID;
                    }
                    
                    break;
                }

        		case SMS_URI_TOKEN_BODY:
        		{
        			content = sms_uri_data->url_string + sms_uri_data->uri_offset + 1;
                    break;
        		}
            }
            
            if (curr_token != SMS_URI_TOKEN_EOF &&
                SMS_URI_TOKEN_ERROR != curr_token)
            {
                curr_token = mmi_msg_get_uri_token();
                continue;
            }
            break;
        }while (1);
	}


    if (curr_token != SMS_URI_TOKEN_EOF)
	{
    	mmi_msg_uri_deinit();
        OslMfree(recipient);

        mmi_sms_display_popup_ext(
            STR_GLOBAL_INVALID_URL,
            MMI_EVENT_FAILURE);
        return;
	}		

	if ((content != NULL) && (*content != '\0'))
	{
        U32 content_len = strlen(content);

        if (content_len > ((MMI_MSG_MAX_URI_BUFF_SIZE / ENCODING_LENGTH) - 1))
        {
       		mmi_msg_uri_deinit();
            OslMfree(recipient);

            mmi_sms_display_popup_ext(
                STR_SMS_FAILURE_DATA_EXCEED,
                MMI_EVENT_FAILURE);
            return;
        }
        else
        {
            ucs2_content = OslMalloc((content_len + 1) * ENCODING_LENGTH);

            mmi_chset_utf8_to_ucs2_string(
            					(U8*)ucs2_content, 
            					((content_len + 1) * ENCODING_LENGTH),
            					(U8*)content);
        }
	}

    max_recipient_num = mmi_sms_get_max_recipient_num();

    if (max_recipient_num > MMI_MSG_MAX_URI_RECIPIENT)
    {
        max_recipient_num = MMI_MSG_MAX_URI_RECIPIENT;
    }

    if (recipient_num > max_recipient_num)
    {
        recipient_num = max_recipient_num;
    }

    for (i = 0; i < recipient_num; i++)
    {
        ucs2_addr_list[i] = recipient[i].ucs2_dest_addr;
    }

    mmi_sms_entry_write_sms(GRP_ID_ROOT ,ucs2_addr_list, recipient_num, ucs2_content);

    if (recipient != NULL)
    {
        OslMfree(recipient);
    }

    if (ucs2_content != NULL)
    {
        OslMfree(ucs2_content);
    }

	mmi_msg_uri_deinit();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_uri_get_next_char
 * DESCRIPTION
 *  get the next char in the URL string buffer
 * PARAMETERS
 *  void  
 * RETURNS
 *  S8		char
 *****************************************************************************/
static S8 mmi_msg_uri_get_next_char(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return sms_uri_data->url_string[sms_uri_data->uri_offset++];
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_uri_unget_next_char
 * DESCRIPTION
 *  un-get the next char in the URL string buffer
 * PARAMETERS
 *  void  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_uri_unget_next_char(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	sms_uri_data->uri_offset--;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_is_alpha
 * DESCRIPTION
 *  Is the char alpha
 * PARAMETERS
 *  ascii_char		[IN] ascii char  
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_msg_is_alpha(S8 ascii_char)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if ((ascii_char >= 'A' && ascii_char <= 'Z')|| 
		(ascii_char >= 'a' && ascii_char <= 'z'))
	{
		return MMI_TRUE;
	}
	else
	{
		return MMI_FALSE;
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_is_gstn_char
 * DESCRIPTION
 *  check the char whether it is a GSTN phone address char
 * PARAMETERS
 *  ascii_char		[IN]	Ascii char  
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_msg_is_gstn_char(S8 ascii_char)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (ascii_char >= '0' && ascii_char <= '9')
	{
		return MMI_TRUE;
	}
	else
	{
		switch (ascii_char)
		{
			case '*':
			case '#':
			case 'p':
			case 'P':
			case 'w':
			case 'W':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case '.':
			case '-':
				return MMI_TRUE;

			default:
				return MMI_FALSE;
		}
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_to_lower
 * DESCRIPTION
 *  change the string to the lower
 * PARAMETERS
 *  str  		[IN]	string will be changed
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_to_lower(S8* str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S8* pstr = str;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    while (*pstr != 0)
    {
        if ((*pstr >= 'A') && (*pstr <= 'Z'))
        {
            *pstr += 'a' - 'A';
        }
        pstr++;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_get_uri_token
 * DESCRIPTION
 *  Get the a token in the URL string
 * PARAMETERS
 *  void  
 * RETURNS
 *  mmi_msg_uri_token_enum
 *****************************************************************************/
static mmi_msg_uri_token_enum mmi_msg_get_uri_token(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 token_length = 0;
	mmi_msg_uri_token_enum curr_token = SMS_URI_TOKEN_ERROR;
	mmi_msg_uri_state_enum state = SMS_URI_STATE_START;
	S8 token_string[MMI_MSG_MAX_URI_TOKEN_LENGTH + 1];
	MMI_BOOL save;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	while (state != SMS_URI_STATE_DONE)
	{
		S8 ascii_char = mmi_msg_uri_get_next_char();

		save = MMI_TRUE;

		switch (state)
		{
			case SMS_URI_STATE_START:
				if (ascii_char == '\0')
				{
					save = MMI_FALSE;
					state = SMS_URI_STATE_DONE;
					curr_token = SMS_URI_TOKEN_EOF;
				}
				else
				if ((ascii_char == ' ') || (ascii_char == '\t') ||
					(ascii_char == '\r') || (ascii_char == '\n'))
				{
					save = MMI_FALSE;
				}
				else if (mmi_msg_is_alpha(ascii_char) == MMI_TRUE)
				{
					state = SMS_URI_STATE_SCHEME;
				}
				else
				{
					switch (ascii_char)
					{
						case ':':
						case ',':
							save = MMI_FALSE;
							state = SMS_URI_STATE_RECIPIENT;
							break;

						case ';':
							save = MMI_FALSE;
							state = SMS_URI_STATE_SMS_QUALIFIER;
							break;
							
						case '?':
							save = MMI_FALSE;
							state = SMS_URI_STATE_SMS_BODY;
							break;

						case '=':
							save = MMI_FALSE;
							state = SMS_URI_STATE_VALUE;
							break;

						default:
							state = SMS_URI_STATE_DONE;
							curr_token = SMS_URI_TOKEN_ERROR;
							break;
					}
				}
				break;

			case SMS_URI_STATE_SCHEME:
				if (mmi_msg_is_alpha(ascii_char) == MMI_FALSE)
				{
					state = SMS_URI_STATE_DONE;
					if (ascii_char == ':')
					{
						save = MMI_FALSE;

						curr_token = SMS_URI_TOKEN_SCHEME;
						mmi_msg_uri_unget_next_char();
					}
					else
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
				}
				break;

			case SMS_URI_STATE_RECIPIENT:
				if ((ascii_char == '+') || (mmi_msg_is_gstn_char(ascii_char) == MMI_TRUE))
				{
					state = SMS_URI_STATE_GSTN_PHONE;
				}
                else if (ascii_char == '?')
                {							
                    save = MMI_FALSE;
					state = SMS_URI_STATE_SMS_BODY;
                }
				else
				{
					state = SMS_URI_STATE_DONE;
					curr_token = SMS_URI_TOKEN_ERROR;
				}
				break;
				
			case SMS_URI_STATE_GSTN_PHONE:
				if (mmi_msg_is_gstn_char(ascii_char) == MMI_TRUE)
				{
					if ((ascii_char == '-') || (ascii_char == '.'))
					{
						save = MMI_FALSE;
					}
				}
				else
				{
					state = SMS_URI_STATE_DONE;
					
					if ((ascii_char == ';') || (ascii_char == '?') || 
						(ascii_char == ',') || (ascii_char == '\0'))
					{
						save = MMI_FALSE;
						curr_token = SMS_URI_TOKEN_GSTN_PHONE;
						mmi_msg_uri_unget_next_char();
					}
					else
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
				}
					
				break;

			case SMS_URI_STATE_SMS_QUALIFIER:
				if (mmi_msg_is_alpha(ascii_char) == MMI_FALSE)
				{
					state = SMS_URI_STATE_DONE;
					if (ascii_char == '=')
					{
						save = MMI_FALSE;
						curr_token = SMS_URI_TOKEN_SMS_QUALIFIER;
						mmi_msg_uri_unget_next_char();
					}
					else
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
				}
				break;
			
			case SMS_URI_STATE_SMS_BODY:
				if (mmi_msg_is_alpha(ascii_char) == MMI_FALSE)
				{
					state = SMS_URI_STATE_DONE;
					if (ascii_char == '=')
					{
						save = MMI_FALSE;
						curr_token = SMS_URI_TOKEN_BODY;
						mmi_msg_uri_unget_next_char();
					}
					else
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
				}
				break;

			case SMS_URI_STATE_VALUE:
				if ((ascii_char == ';') || (ascii_char == '?') ||
					(ascii_char == ',') || (ascii_char == '\0'))
				{
					save = MMI_FALSE;
					state = SMS_URI_STATE_DONE;
					curr_token = SMS_URI_TOKEN_VALUE;
					mmi_msg_uri_unget_next_char();
				}
				break;

			case SMS_URI_STATE_DONE:
			default:
				state = SMS_URI_STATE_DONE;
				curr_token = SMS_URI_TOKEN_ERROR;
				break;
		}

		if ((save == MMI_TRUE) && (token_length < MMI_MSG_MAX_URI_TOKEN_LENGTH))
		{
			token_string[token_length++] = ascii_char;
		}

		if (state == SMS_URI_STATE_DONE)
		{
			token_string[token_length] = '\0';
			
			switch(curr_token)
			{
				case SMS_URI_TOKEN_SCHEME:
					mmi_msg_to_lower(token_string);
					if ((strcmp(token_string, "sms") != 0) &&
						(strcmp(token_string, "smsto") != 0))
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
					break;

				case SMS_URI_TOKEN_BODY:
					if (strcmp(token_string, "body") != 0)
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
					break;

				case SMS_URI_TOKEN_GSTN_PHONE:
					if ((token_length > MAX_DIGITS_SMS) || 
                        ((token_length == MAX_DIGITS_SMS) && (token_string[0] != '+')))
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
					else
					{
						if(srv_sms_check_dst_number((U8*)token_string, (U8)token_length) != MMI_TRUE)
						{
							curr_token = SMS_URI_TOKEN_ERROR;
						}
					}
					break;
					
				case SMS_URI_TOKEN_SMS_QUALIFIER:
					if (strcmp(token_string, "smsc") == 0)
					{
						curr_token = SMS_URI_TOKEN_SMSC;
					}
					else if (strcmp(token_string, "pid") == 0)
					{
						curr_token = SMS_URI_TOKEN_PID;
					}
					else
					{
						curr_token = SMS_URI_TOKEN_ERROR;
					}
					break;
				
				default:
					break;
			}
		}
	}

	memcpy(sms_uri_data->token_string, token_string, (MMI_MSG_MAX_URI_TOKEN_LENGTH + 1));
	return curr_token;
}
#endif /* __MMI_URI_AGENT__ */


#if defined(__MMI_VUI_HOMESCREEN__)

#define MMI_MSG_HS_MAX_SMS_SUBJECT_LENGTH			MAX_SUBMENU_CHARACTERS

#define MMI_MSG_HS_MENU_DATA_SIZE					MMI_HS_MAX_MENU_DATA_NEW_SMS_NUM
#define MMI_MSG_HS_RECENT_EVENT_SMS_SIZE			MMI_HS_MAX_RECENT_EVENT_NUM

static U16 mmi_msg_hs_recent_event_sms_data[MMI_MSG_HS_RECENT_EVENT_SMS_SIZE];
#endif /* defined(__MMI_VUI_HOMESCREEN__) */



#if defined(__MMI_VUI_HOMESCREEN__)
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_get_sms_recent_event
 * DESCRIPTION
 *  get sms recent event
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_hs_get_sms_recent_event(S32 num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	mmi_msg_hs_update_sms_recent_event(num);
}


#ifdef __MMI_MESSAGES_SMS_EMAIL__
typedef struct
{
	mmi_hs_recent_event_struct *recent_event;
	S32 req_num;
	S32 num_of_event;
	U16 list_index;
	U16 inbox_size;
	MMI_BOOL is_update_again;
}mmi_msg_recent_event_data_struct;

static MMI_BOOL mmi_msg_hs_recent_event_sms_get_data(void);
static void mmi_msg_hs_recent_event_sms_handle(void);
static void mmi_msg_hs_recent_event_sms_free_data(void);
static void mmi_msg_hs_recent_event_sms_get_subject_req(void);
static void mmi_msg_hs_recent_event_sms_get_subject_rsp(srv_sms_callback_struct* callback_data);

static mmi_msg_recent_event_data_struct *sms_recent_event_data;


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_update_sms_recent_event
 * DESCRIPTION
 *  Update the Recent Event of SMS
 * PARAMETERS
 *  num			[IN]	number of the recent event
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_hs_update_sms_recent_event(S32 num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_ASSERT(num <= MMI_HS_MAX_RECENT_EVENT_NUM);

    if (srv_sms_is_sms_ready() == MMI_TRUE)
	{
 		U16 inbox_size = srv_sms_get_list_size(SRV_SMS_BOX_INBOX);

		msgbox_info.totalinbox = inbox_size;

		if ((inbox_size > 0) && (num > 0))
		{
			MMI_BOOL is_update_again = MMI_FALSE;

			if (sms_recent_event_data != NULL)
			{
				is_update_again = MMI_TRUE;
				mmi_msg_hs_recent_event_sms_free_data();
			}
			sms_recent_event_data = OslMalloc(sizeof(mmi_msg_recent_event_data_struct) +
											  sizeof(mmi_hs_recent_event_struct) * num);

			sms_recent_event_data->recent_event = (mmi_hs_recent_event_struct*)((U8*)sms_recent_event_data
														+ sizeof(mmi_msg_recent_event_data_struct));
			sms_recent_event_data->list_index = 0;
			sms_recent_event_data->inbox_size = inbox_size;
			sms_recent_event_data->req_num = num;
			sms_recent_event_data->num_of_event = 0;
			sms_recent_event_data->is_update_again = is_update_again;
			
			mmi_msg_hs_recent_event_sms_handle();
		}
		else
		{
			mmi_hs_recent_event_answer(
			        MMI_HS_RECENT_EVENT_SMS,
			        MMI_HS_RESULT_OK,
			        0,
			        NULL,
			        mmi_msg_hs_recent_event_sms_key_handler);
		}
	}
	else
	{
		mmi_hs_recent_event_answer(
		        MMI_HS_RECENT_EVENT_SMS,
		        MMI_HS_RESULT_NOT_READY,
		        0,
		        NULL,
		        mmi_msg_hs_recent_event_sms_key_handler);
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_recent_event_sms_handle
 * DESCRIPTION
 *  Handle the get recent event data flow 
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_hs_recent_event_sms_handle(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	MMI_BOOL is_waiting = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	while ((sms_recent_event_data->list_index < sms_recent_event_data->inbox_size) &&
		   (sms_recent_event_data->num_of_event < sms_recent_event_data->req_num))
	{
		if (mmi_msg_hs_recent_event_sms_get_data() == MMI_TRUE)
		{
			sms_recent_event_data->list_index++;
		}
		else
		{
			is_waiting = MMI_TRUE;
			break;
		}
	}	

	if (is_waiting == MMI_FALSE)
	{
		mmi_hs_recent_event_answer(
		        MMI_HS_RECENT_EVENT_SMS,
		        MMI_HS_RESULT_OK,
		        sms_recent_event_data->num_of_event,
		        sms_recent_event_data->recent_event,
		        mmi_msg_hs_recent_event_sms_key_handler);
		
		mmi_msg_hs_recent_event_sms_free_data();
	}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_recent_event_sms_get_data
 * DESCRIPTION
 *  Get one sms recent event data
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL mmi_msg_hs_recent_event_sms_get_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U16 list_index = sms_recent_event_data->list_index;
	S32 num_of_event = sms_recent_event_data->num_of_event;
	U16 msg_id;
	MMI_BOOL result = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, list_index);

	if (srv_sms_get_msg_recent_event_flag(msg_id) == MMI_TRUE)
	{
		mmi_hs_recent_event_struct *recent_event = &sms_recent_event_data->recent_event[num_of_event];

		mmi_msg_hs_recent_event_sms_data[num_of_event] = msg_id;

		recent_event->user_data = &mmi_msg_hs_recent_event_sms_data[num_of_event];

		/* Time */
        srv_sms_get_msg_timestamp(msg_id, &recent_event->time);

		/* Icon */
		recent_event->icon = mmi_sms_get_icon(msg_id);

		/* Read Flag */
		if (srv_sms_get_msg_status(msg_id) & SRV_SMS_STATUS_UNREAD)
		{
			recent_event->is_read = MMI_FALSE;
		}
		else
		{
			recent_event->is_read = MMI_TRUE;
		}

		/* Subject */
		recent_event->subject = OslMalloc((MMI_MSG_HS_MAX_SMS_SUBJECT_LENGTH + 1) * ENCODING_LENGTH);

		if (srv_sms_get_msg_pid(msg_id) == SRV_SMS_PID_EMAIL)
		{
			mmi_msg_hs_recent_event_sms_get_subject_req();
			result = MMI_FALSE;
		}
		else
		{
            mmi_sms_get_address(
                msg_id,
                recent_event->subject,
                MMI_MSG_HS_MAX_SMS_SUBJECT_LENGTH);

			sms_recent_event_data->num_of_event++;
		}
	}

	return result;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_recent_event_sms_get_subject_req
 * DESCRIPTION
 *  get the sms recent event subject(Email Address) request
 * PARAMETERS
 *  data        [IN]         
 *  mod         [IN]        
 *  result      [IN]   
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_hs_recent_event_sms_get_subject_req(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 msg_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, sms_recent_event_data->list_index);

    srv_sms_get_msg_content_async(
        msg_id,
        mmi_msg_hs_recent_event_sms_get_subject_rsp,
        NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_recent_event_sms_get_subject_rsp
 * DESCRIPTION
 *  get the sms recent event subject(Email Address) request
 * PARAMETERS
 *  num			[IN]	number of the recent event
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_hs_recent_event_sms_get_subject_rsp(srv_sms_callback_struct* callback_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_hs_recent_event_struct *recent_event;
    S8 smsEmailAddress[(MAX_SMS_EMAIL_NUMBER + 1) *ENCODING_LENGTH];
	U8 email_result = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (sms_recent_event_data->is_update_again == MMI_TRUE)
	{
		/* if update again before the previous request is not finished,
		   ignore the previous one, forbid the previous response change or
		   release the data buffer */
		return;
	}

	recent_event = &sms_recent_event_data->recent_event
							[sms_recent_event_data->num_of_event];

	if (callback_data->result == MMI_TRUE)
	{
        srv_sms_get_msg_content_async_cb_struct *get_content_cb;

        get_content_cb = (srv_sms_get_msg_content_async_cb_struct*)callback_data->action_data;

		mmi_msg_get_email_and_subject_from_msgtxt(
							get_content_cb->content,
							SRV_SMS_MSG_INFO_CONTENT_LEN,
							smsEmailAddress,
							(MAX_SMS_EMAIL_NUMBER * ENCODING_LENGTH),
							NULL,
							0,
							NULL,
							NULL);
	}

	if ((email_result == MMI_TRUE) && (mmi_ucs2strlen(smsEmailAddress) > 0))
	{
        mmi_ucs2ncpy(recent_event->subject, smsEmailAddress, MMI_MSG_HS_MAX_SMS_SUBJECT_LENGTH);
	}
	else
	{
        mmi_ucs2cpy(recent_event->subject, GetString(STR_GLOBAL_NO_NUMBER));
	}

	sms_recent_event_data->num_of_event++;
	sms_recent_event_data->list_index++;

	mmi_msg_hs_recent_event_sms_handle();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_recent_event_sms_free_data
 * DESCRIPTION
 *  free the content of the sms recent event data
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_msg_hs_recent_event_sms_free_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 i;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (sms_recent_event_data != NULL)
	{
		for (i = 0; i < sms_recent_event_data->num_of_event; i++)
		{
			if (sms_recent_event_data->recent_event[i].subject != NULL)
			{
				OslMfree(sms_recent_event_data->recent_event[i].subject);
			}
		}

		OslMfree(sms_recent_event_data);
		sms_recent_event_data = NULL;
	}
}

#else /* __MMI_MESSAGES_SMS_EMAIL__ */

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_update_sms_recent_event
 * DESCRIPTION
 *  Update the Recent Event of SMS
 * PARAMETERS
 *  num			[IN]	number of the recent event
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_hs_update_sms_recent_event(S32 num)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_hs_result_enum result = MMI_HS_RESULT_NOT_READY;
	mmi_hs_recent_event_struct *recent_event = NULL;
	S32 num_of_event = 0;
	U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_ASSERT(num <= MMI_HS_MAX_RECENT_EVENT_NUM);

    if (srv_sms_is_sms_ready() == MMI_TRUE)
	{
 		U16 inbox_size = srv_sms_get_list_size(SRV_SMS_BOX_INBOX);

		msgbox_info.totalinbox = inbox_size;

		recent_event = OslMalloc(sizeof(mmi_hs_recent_event_struct) * num);

		for (i = 0; i < inbox_size; i++)
		{
		    U16 msg_id;

            msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, i);

			if (srv_sms_get_msg_recent_event_flag(msg_id) == MMI_TRUE)
			{
				mmi_msg_hs_recent_event_sms_data[num_of_event] = msg_id;

				recent_event[num_of_event].user_data = &mmi_msg_hs_recent_event_sms_data[num_of_event];

				recent_event[num_of_event].subject = OslMalloc((MMI_MSG_HS_MAX_SMS_SUBJECT_LENGTH + 1) * ENCODING_LENGTH);

                mmi_sms_get_address(
                    msg_id,
                    recent_event[num_of_event].subject,
                    MMI_MSG_HS_MAX_SMS_SUBJECT_LENGTH);

                srv_sms_get_msg_timestamp(msg_id, &recent_event[num_of_event].time);

				recent_event[num_of_event].icon = mmi_sms_get_icon(msg_id);

				if (srv_sms_get_msg_status(msg_id) & SRV_SMS_STATUS_UNREAD)
				{
					recent_event[num_of_event].is_read = MMI_FALSE;
				}
				else
				{
					recent_event[num_of_event].is_read = MMI_TRUE;
				}

				num_of_event++;
				if (num_of_event == num)
				{
					break;
				}
			}
		}

		result = MMI_HS_RESULT_OK;
	}

	mmi_hs_recent_event_answer(
	        MMI_HS_RECENT_EVENT_SMS,
	        result,
	        num_of_event,
	        recent_event,
	        mmi_msg_hs_recent_event_sms_key_handler);

	if (recent_event != NULL)
	{
		for (i = 0; i < num_of_event; i++)
		{
			if (recent_event[i].subject != NULL)
			{
				OslMfree(recent_event[i].subject);
			}
		}

		OslMfree(recent_event);
	}
}
#endif /* __MMI_MESSAGES_SMS_EMAIL__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs_recent_event_key_handler
 * DESCRIPTION
 *  recent event screen sms item key handler
 * PARAMETERS
 *  key_code		[IN]	Key code
 *  key_type		[IN]	Key type
 *  user_data		[IN]	the data the sms filled before
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_hs_recent_event_sms_key_handler(U16 key_code, U16 key_type, void *user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U16 index = *(U16*)user_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_sms_cntx.curr_msg_id = index;
    g_sms_cntx.curr_list_type = MMI_SMS_LIST_RECENT_EVENT;
    g_sms_cntx.curr_box_type = SRV_SMS_BOX_INBOX;

	switch (key_code)
	{
        case KEY_CSK:
            mmi_sms_group_entry(GRP_ID_ROOT);
            g_sms_cntx.is_from_hs = MMI_TRUE;
            mmi_sms_view_curr_msg();
            break;

        case KEY_LSK:
        {
            mmi_sms_pre_entry_recent_list_option(GRP_ID_ROOT);
            break;
        }

	    default:
		    break;
	}
}
#endif /* __MMI_VUI_HOMESCREEN__ || __MMI_VUI_HOMESCREEN__*/


#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_nmgr_query_sms_notify
 * DESCRIPTION
 *  SMS notify mananger query function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_nmgr_query_sms_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_sms_is_sms_ready() == MMI_FALSE)
	{
        mmi_nmgr_answer(
            MMI_NMGR_APP_SMS,
            MMI_NMGR_RESULT_NOT_READY,
            NULL,
            NULL);
	}
    else
    {
        mmi_nmgr_info_struct info;
        WCHAR buffer[120];
        mmi_nmgr_hdlr_func_t hdlr;
    #if (MMI_MAX_SIM_NUM >= 2)
        WCHAR idle_text1[120];
    #endif

        memset(&info, 0, sizeof(mmi_nmgr_info_struct));
        info.total_num = srv_sms_get_unread_sms_num();

        if (info.total_num == 0 || g_msg_cntx.msg_ind_in_idle == MMI_FALSE)
        {
            if (info.total_num == 0)
            {
                g_msg_cntx.msg_ind_in_idle = MMI_FALSE;
            }

            hdlr = NULL;
        }
        else
        {
        #ifdef __LOW_COST_SUPPORT_COMMON__
            info.image = IMG_NEW_MESSAGE_NOTIFICATION_MSG;
        #else
            info.image = IMG_NEW_MESSAGE_NOTIFICATION_MSG_IN_IDLE;
        #endif /* __LOW_COST_SUPPORT_COMMON__ */
            info.left_softkey = STR_GLOBAL_READ;
            info.icon = IMG_MESSAGE_UNREAD;

            //if use the UM notification, the below element is not used.
        #if (MMI_MAX_SIM_NUM == 1)
            info.idle_text1 = GetString(STR_NEW_MESSAGE_FROM_ID);
        #else /* (MMI_SIM_TOTAL >= 2) */
            {
                mmi_sim_enum mmi_sim = SRV_SMS_SMS_SIM_TO_MMI(srv_sms_get_msg_sim_id(g_msg_cntx.msg_ind_index));
                U16 simStrId = mmi_sms_get_sim_str_id(mmi_sim);

                mmi_wsprintf(idle_text1, 240, STR_ID_SMS_NEW_SIMX_MESSAGE_FROM_ID, (WCHAR*)GetString(simStrId));

                info.idle_text1 = (S8*)idle_text1;
            }
        #endif /* (MMI_SIM_TOTAL >= 2) */

            mmi_msg_get_new_msg_ind_string(g_msg_cntx.msg_ind_index, buffer);

            info.idle_text2 = (S8*)buffer;

            hdlr = mmi_msg_nmgr_sms_notify_key_handler;
        }

        //if use the UM notification, the LSK key handle function is not used.
        mmi_nmgr_answer(
            MMI_NMGR_APP_SMS,
            MMI_NMGR_RESULT_OK,
            &info,
            hdlr);
    }
}

#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_nmgr_sms_notify_key_handler
 * DESCRIPTION
 *  SMS notification LSK key handler
 * PARAMETERS
 *  user_data		[IN]	the data the sms filled before
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_nmgr_sms_notify_key_handler(void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __MMI_TELEPHONY_SUPPORT__
    mmi_msg_get_msg_new();
    #endif
}

#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_nmgr_cancel_sms_notify
 * DESCRIPTION
 *  Cancel the SMS notification flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_nmgr_cancel_sms_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_msg_cntx.msg_ind_in_idle = MMI_FALSE;

    mmi_um_nmgr_new_msg_cancel(SRV_UM_MSG_SMS);  
}
#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/

#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__

#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_nmgr_query_sim_sms_notify
 * DESCRIPTION
 *  SIM SMS notify mananger query function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_nmgr_query_sim_sms_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_sms_is_sms_ready() == MMI_FALSE)
	{
        mmi_nmgr_answer(
            MMI_NMGR_APP_SIM_SMS,
            MMI_NMGR_RESULT_NOT_READY,
            NULL,
            NULL);
	}
    else
    {
        mmi_nmgr_info_struct info;
        WCHAR buffer[120];
        mmi_nmgr_hdlr_func_t hdlr;
    #if (MMI_MAX_SIM_NUM >= 2)
        WCHAR idle_text1[120];
    #endif

        memset(&info, 0, sizeof(mmi_nmgr_info_struct));
        info.total_num = 1;

        if (g_msg_cntx.sim_msg_ind_in_idle == MMI_FALSE)
        {
            hdlr = NULL;
        }
        else
        {
        #ifdef __LOW_COST_SUPPORT_COMMON__
            info.image = IMG_NEW_MESSAGE_NOTIFICATION_MSG;
        #else
            info.image = IMG_NEW_MESSAGE_NOTIFICATION_MSG_IN_IDLE; 
        #endif /* __LOW_COST_SUPPORT_COMMON__ */
            info.left_softkey = STR_GLOBAL_VIEW;
            info.icon = IMG_MESSAGE_UNREAD;

        #if (MMI_MAX_SIM_NUM == 1)
            info.idle_text1 = GetString(STR_NEW_SIM_MESSAGE_FROM_ID);
        #else /* (MMI_SIM_TOTAL >= 2) */
            {
                mmi_sim_enum mmi_sim = SRV_SMS_SMS_SIM_TO_MMI(srv_sms_get_msg_sim_id(g_msg_cntx.sim_msg_ind_index));
                U16 simStrId = mmi_sms_get_sim_str_id(mmi_sim);

                mmi_wsprintf(idle_text1, 240, STR_ID_SMS_NEW_SIMX_MESSAGE_FROM_ID, (WCHAR*)GetString(simStrId));

                info.idle_text1 = (S8*)idle_text1;
            }
        #endif /* (MMI_SIM_TOTAL >= 2) */

            mmi_msg_get_new_msg_ind_string(g_msg_cntx.sim_msg_ind_index, buffer);

            info.idle_text2 = (S8*)buffer;

            hdlr = mmi_msg_nmgr_sim_sms_notify_key_handler;
        }
        //if use the UM notification, the LSK key handle function is not used.
        mmi_nmgr_answer(
            MMI_NMGR_APP_SIM_SMS,
            MMI_NMGR_RESULT_OK,
            &info,
            hdlr);
    }
}
#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_msg_nmgr_sim_sms_notify_key_handler
 * DESCRIPTION
 *  SIM SMS notification LSK key handler
 * PARAMETERS
 *  user_data		[IN]	the user data of SMS
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_nmgr_sim_sms_notify_key_handler(void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_msg_get_sim_msg_new();
}

#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__
/*****************************************************************************
 * FUNCTION
 *  mmi_msg_nmgr_cancel_sim_sms_notify
 * DESCRIPTION
 *  Cancel the SIM SMS notification flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_nmgr_cancel_sim_sms_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_msg_cntx.sim_msg_ind_in_idle = MMI_FALSE;
}
#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/
#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */


#ifdef __MMI_MESSAGE_SMS_HILITE_VIEWER__
/*****************************************************************************
 * FUNCTION
 *  mmi_sms_class0_view_hilite_cb
 * DESCRIPTION
 *  function for class0 viewer hilite item callback
 * PARAMETERS
 *  idx        [IN]        index of hilite list
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_sms_class0_view_hilite_cb(S32 idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_COMMON_TRC_G6_MSG, TRC_MMI_SMS_MMI_MSG_VIEW_HILITE_CB, idx);
    hilite_cntx.currHiliteItemIndex = idx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_class0_view_hilite_click_cb
 * DESCRIPTION
 *  function for class0 viewer click hilite item callback
 * PARAMETERS
 *  idx        [IN]        index of hilite list
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_sms_class0_view_hilite_click_cb(S32 idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    keep_class0_scrn = MMI_TRUE;

    mmi_sms_view_hilite_opt_pre_entry_hdlr(mmi_sms_class0_gid, idx);
}
#endif /* __MMI_MESSAGE_SMS_HILITE_VIEWER__ */


/*****************************************************************************
* FUNCTION
*  mmi_msg_is_hide_cphs_items
* DESCRIPTION
*  Whether hide sms chps menu items
* PARAMETERS
*  void
* RETURNS
*  void
*****************************************************************************/
MMI_BOOL mmi_msg_is_display_cphs_menu_items(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_CBS_SUPPORT__
    return mmi_cbs_is_show_cb_menu();
#else
    return MMI_FALSE;
#endif
}


#if defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__)
static void mmi_op11_hs32_get_sms_rsp(srv_sms_callback_struct* callback_data);
static void mmi_op11_hs32_get_sms_req(mmi_sms_op11_data_struct *mmi_sms_op11_data);
/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_voicemail_shct_data
 * DESCRIPTION
 *  SIM SMS notification LSK key handler
 * PARAMETERS
 *  sidebar_id		[IN]	the user data of SMS
 *  shct_id		[IN]	the user data of SMS
 *  shct_data		[IN]	the user data of SMS
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_get_voicemail_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (srv_sms_is_sms_ready())
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;

        shct_data_p->item_count = g_msg_cntx.msg_waiting_vm_num;

        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
    }
    else
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);        
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_voicemail_update_op11_hs32_vm_shct_data
 * DESCRIPTION
 *  Cancel the SIM SMS notification flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_voicemail_update_op11_hs32_vm_shct_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* All update HS32 shortcut fucntion, please get the data pointer and verify it first */
    shct_data_p = mmi_op11_hs32_get_shct_data_pointer(MMI_OP11_HS32_AP_CLL, MMI_OP11_HS32_SHCT_CLL_VOICEMAIL);

    if(shct_data_p != NULL)
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_UPDATE;
        shct_data_p->item_count = g_msg_cntx.msg_waiting_vm_num;
        mmi_op11_hs32_answer_shct_data(MMI_OP11_HS32_AP_CLL, MMI_OP11_HS32_SHCT_CLL_VOICEMAIL,shct_data_p);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_read_msg_rsp
 * DESCRIPTION
 *  Entry send screen
 * PARAMETERS
 *  data        [IN]    Dummy
 *  mod         [IN]    Module Type
 *  result      [IN]    SMS Framework Result
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_get_sms_rsp(srv_sms_callback_struct* callback_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_sms_read_msg_cb_struct *read_msg_cb_data;
    srv_sms_msg_data_struct *msg_data;
    mmi_sms_op11_data_struct *mmi_sms_op11_data;
    mmi_sms_msg_status_enum msg_status = SMS_STATUS_UNSUPPORT;
    U16 cur_num;
#ifdef __MMI_MESSAGES_SMS_EMAIL__
    U16 number[MAX_SMS_EMAIL_NUMBER + 1] = {0,0};
#else
    U16 number[SRV_SMS_MAX_ADDR_LEN + 1] = {0,0};
#endif
    U16 name[MMI_PHB_NAME_LENGTH + 1] = {0, 0};
    mmi_op11_hs32_shct_data_struct *shct_data_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    read_msg_cb_data = (srv_sms_read_msg_cb_struct*)callback_data->action_data;
    
    mmi_sms_op11_data = (mmi_sms_op11_data_struct *)callback_data->user_data;
    cur_num = mmi_sms_op11_data->cur_itme;
    msg_data = read_msg_cb_data->msg_data;
    shct_data_p = mmi_op11_hs32_get_shct_data_pointer(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS);
    if (callback_data->result == MMI_FALSE || shct_data_p == NULL || 
        (mmi_sms_op11_data->shct_data_p != shct_data_p))
    {
        OslMfree(msg_data);
        OslMfree(mmi_sms_op11_data);

        return;
    }
    else
    {
        if (msg_data->mti == SRV_SMS_MTI_STATUS_REPORT)
        {
            if (msg_data->tp_st == ST_COMP_MSG_RECV_BY_SME)
            {
                msg_status = SMS_STATUS_DELIVERY_REPORT;
            }
            else
            {
                msg_status = SMS_STATUS_PENDING_REPORT;
            }
        }
        else
        {
            srv_sms_status_enum srv_status = msg_data->status;

            if (srv_sms_is_msg_complete((U16)mmi_sms_op11_data->shct_data_p->item_uid[mmi_sms_op11_data->cur_itme]) == MMI_FALSE)
            {
                mmi_ucs2ncpy(
                    (S8 *)&mmi_sms_op11_data->shct_data_p->item_content[cur_num], 
                    (S8*)GetString(STR_UM_INCOMPLETE_ID), 
                    MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX);
            }                
           else if (srv_status & SRV_SMS_STATUS_UNSUPPORTED)
            {
                msg_status = SMS_STATUS_UNSUPPORT;
                mmi_ucs2ncpy(
                    (S8 *)&mmi_sms_op11_data->shct_data_p->item_content[cur_num], 
                    (S8*)GetString(STR_GLOBAL_NOT_SUPPORTED), 
                    MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX);
            }
            else
            {
                EMSData *ems_data = msg_data->content_ems;

                              
        #ifdef __MMI_MESSAGES_SMS_EMAIL__
            	if (msg_data->pid == SRV_SMS_PID_EMAIL)
            	{
                mmi_msg_get_email_and_subject_from_msgtxt(
                    (S8 *)ems_data->textBuffer,
                    ems_data->textLength,
                	(S8 *)number,
                	((MAX_SMS_EMAIL_NUMBER * ENCODING_LENGTH)),
                	(S8 *)mmi_sms_op11_data->shct_data_p->item_content[cur_num],
                	MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX,
                    NULL,
                    NULL);
            	}
            	else
        #endif /* __MMI_MESSAGES_SMS_EMAIL__ */
            	{
            	    mmi_ucs2ncpy((S8*)mmi_sms_op11_data->shct_data_p->item_content[cur_num], (S8*)ems_data->textBuffer, MMI_OP11_HS32_SHCT_CONTENT_STRLEN_MAX);
            	}
            }
        }
    #ifdef __MMI_MESSAGES_SMS_EMAIL__
        if (msg_data->pid != SRV_SMS_PID_EMAIL)
    #endif
        {
            srv_sms_get_msg_address(mmi_sms_op11_data->shct_data_p->item_uid[mmi_sms_op11_data->cur_itme], (S8*)number);
            srv_phb_get_name_by_number((U16*)msg_data->number, (U16*)name, MMI_PHB_NAME_LENGTH);
        }
      
        if (mmi_ucs2strlen((S8*)name))
        {
            mmi_ucs2ncpy((S8*)mmi_sms_op11_data->shct_data_p->item_name[cur_num], (S8*)name, MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
        }
        else if (mmi_ucs2strlen((S8*)number))
        {
            mmi_ucs2ncpy((S8*)mmi_sms_op11_data->shct_data_p->item_name[cur_num], (S8*)number, MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
        }
        else
        {
            mmi_ucs2ncpy((S8*)mmi_sms_op11_data->shct_data_p->item_name[cur_num], (S8*)number, MMI_OP11_HS32_SHCT_NAME_STRLEN_MAX);
        }
        memcpy(&mmi_sms_op11_data->shct_data_p->item_time[cur_num], &msg_data->timestamp, sizeof(MYTIME)); 
    }
    mmi_sms_op11_data->cur_itme++;
    OslMfree(msg_data);
    mmi_op11_hs32_get_sms_req(mmi_sms_op11_data);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_sms_req
 * DESCRIPTION
 *  SIM SMS notification LSK key handler
 * PARAMETERS
 *  sidebar_id		[IN]	the user data of SMS
 *  shct_id		[IN]	the user data of SMS
 *  shct_data		[IN]	the user data of SMS
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_op11_hs32_get_sms_req(mmi_sms_op11_data_struct *mmi_sms_op11_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/ 
    if (mmi_sms_op11_data->cur_itme < mmi_sms_op11_data->max_item)
    {
        srv_sms_msg_data_struct *msg_data = (srv_sms_msg_data_struct*)OslMalloc(sizeof(srv_sms_msg_data_struct));

        msg_data->para_flag = SRV_SMS_PARA_CONTENT_EMS;
        msg_data->content_ems = (EMSData*)GetEMSDataForView(NULL, 1);
    #ifdef __MMI_MESSAGES_SMS_EMAIL__
        msg_data->para_flag |= SRV_SMS_PARA_PID;
    #endif /* __MMI_MESSAGES_SMS_EMAIL__ */
        msg_data->para_flag |= SRV_SMS_PARA_TIMESTAMP;
        srv_sms_read_msg(
            (U16)mmi_sms_op11_data->shct_data_p->item_uid[mmi_sms_op11_data->cur_itme],
            MMI_FALSE,
            msg_data,
            mmi_op11_hs32_get_sms_rsp,
            (void*)mmi_sms_op11_data);        
    }
    else
    {
        mmi_sms_op11_data->shct_data_p->result_flag = MMI_OP11_HS32_RESULT_UPDATE;
        mmi_op11_hs32_answer_shct_data(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS, mmi_sms_op11_data->shct_data_p);
        OslMfree(mmi_sms_op11_data);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_op11_hs32_get_sms_shct_data
 * DESCRIPTION
 *  SIM SMS notification LSK key handler
 * PARAMETERS
 *  sidebar_id		[IN]	the user data of SMS
 *  shct_id		[IN]	the user data of SMS
 *  shct_data		[IN]	the user data of SMS
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_op11_hs32_get_sms_shct_data(S32 sidebar_id,S32 shct_id, void *shct_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count,n,i; 
    mmi_op11_hs32_shct_data_struct *shct_data_p = (mmi_op11_hs32_shct_data_struct *)shct_data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if (srv_sms_is_sms_ready())
    {
        n = shct_data_p ->item_count = srv_sms_get_unread_sms_num();
        if (shct_data_p ->item_count > MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX)
        {
            n = MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX;
        }
        for (count = 0, i = 0; i < n; i++)
        {
            U16 msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, (U16)count++);   
            
               
            while(!(srv_sms_get_msg_status(msg_id) & SRV_SMS_STATUS_UNREAD))
            {
                msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, (U16)count++); 
            }
            shct_data_p->item_uid[i] = (S32)msg_id;
        }
        if (n > 0)
        {
            mmi_sms_op11_data_struct* mmi_sms_op11_data = (mmi_sms_op11_data_struct*)OslMalloc(sizeof(mmi_sms_op11_data_struct));
            mmi_sms_op11_data->max_item = n;
            mmi_sms_op11_data->shct_data_p = shct_data_p;
            mmi_sms_op11_data->cur_itme = 0;
            mmi_op11_hs32_get_sms_req(mmi_sms_op11_data);
        }
        else
        {
            shct_data_p->result_flag = MMI_OP11_HS32_RESULT_OK;
            mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
        }
    }
    else
    {
        shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_shct_data(sidebar_id, shct_id, shct_data_p);
        /* e.g. send message  */
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_sms_query_sidebar_info
 * DESCRIPTION
 *  SIM SMS notification LSK key handler
 * PARAMETERS
 *  sidebar_id		[IN]	the user data of SMS
 *  shct_id		[IN]	the user data of SMS
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_query_sidebar_info(S32 sidebar_id, S32 indctr_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct data;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if (srv_sms_is_sms_ready())
    {
        data.result_flag = MMI_OP11_HS32_RESULT_OK;
        data.indicator_value = srv_sms_get_unread_sms_num();

        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &data);
    }
    else /* if call log is not ready */
    {
        data.result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
        mmi_op11_hs32_answer_sidebar(sidebar_id, indctr_id, &data);
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_sms_update_sidebar_info
 * DESCRIPTION
 *  Cancel the SIM SMS notification flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_update_sidebar_info(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_op11_hs32_sidebar_query_info_struct data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    data.result_flag = MMI_OP11_HS32_RESULT_UPDATE;
    data.indicator_value = srv_sms_get_unread_sms_num();

    mmi_op11_hs32_answer_sidebar(
        MMI_OP11_HS32_AP_MES,
        MMI_OP11_HS32_INDCTR_MES_NEW_SMS,
        &data);
}

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_update_shct_data
 * DESCRIPTION
 *  when unread sms change, call this function to update HS3.1/3.2
 * PARAMETERS
 * void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_update_shct_data(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 count,n,i; 
    mmi_op11_hs32_shct_data_struct *shct_data_p;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    shct_data_p = mmi_op11_hs32_get_shct_data_pointer(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS);
    if (shct_data_p != NULL)
    {
        if (srv_sms_is_sms_ready())
        {
            n = shct_data_p ->item_count = srv_sms_get_unread_sms_num();
            if (shct_data_p ->item_count > MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX)
            {
                n = MMI_OP11_HS32_SHCT_ITEM_COUNT_MAX;
            }
            for (count = 0, i = 0; i < n; i++)
            {
                U16 msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, (U16)count++);   
            
               
                while(!(srv_sms_get_msg_status(msg_id) & SRV_SMS_STATUS_UNREAD))
                {
                    msg_id = srv_sms_get_msg_id(SRV_SMS_BOX_INBOX, (U16)count++); 
                }
                shct_data_p->item_uid[i] = (S32)msg_id;
            }
            if (n > 0)
            {
                mmi_sms_op11_data_struct* mmi_sms_op11_data = (mmi_sms_op11_data_struct*)OslMalloc(sizeof(mmi_sms_op11_data_struct));
                mmi_sms_op11_data->max_item = n;
                mmi_sms_op11_data->shct_data_p = shct_data_p;
                mmi_sms_op11_data->cur_itme = 0;
                mmi_op11_hs32_get_sms_req(mmi_sms_op11_data);
            }
            else
            {
                shct_data_p->result_flag = MMI_OP11_HS32_RESULT_UPDATE;
                mmi_op11_hs32_answer_shct_data(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS, shct_data_p);
            }
        }
        else
        {
            shct_data_p->result_flag = MMI_OP11_HS32_RESULT_NOT_READY;
            mmi_op11_hs32_answer_shct_data(MMI_OP11_HS32_AP_MES, MMI_OP11_HS32_SHCT_MES_NEW_SMS, shct_data_p);
        }
    }/* (shct_data_p != NULL) */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_hs32_menu_data_short_cut
 * DESCRIPTION
 *  homescreen message menu sms highlight key handler
 * PARAMETERS
 *  key_code		[IN]	Key code
 *  key_type		[IN]	Key type
 *  user_data		[IN]	the data the sms filled before
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_msg_hs32_menu_view_curr_message(U16 msg_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_sms_cntx.curr_msg_id = msg_id;
    g_sms_cntx.curr_list_type = MMI_SMS_LIST_MESSAGING_DATA;
    g_sms_cntx.curr_box_type = SRV_SMS_BOX_INBOX;

    mmi_sms_group_entry(GRP_ID_ROOT);
    g_sms_cntx.is_from_hs = MMI_TRUE;
    mmi_sms_view_curr_msg();
}
#endif /* defined( __MMI_OP11_HOMESCREEN_0301__) || defined(__MMI_OP11_HOMESCREEN_0302__) */


#ifdef __MMI_UM_REPORT_BOX__
static void mmi_sms_nmgr_report_notify_key_hdlr(void* user_data);


#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_nmgr_query_report_notify
 * DESCRIPTION
 *  SMS notify mananger query function
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_nmgr_query_report_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_sms_is_sms_ready() == MMI_FALSE)
	{
        mmi_nmgr_answer(
            MMI_NMGR_APP_SMS_REPORT,
            MMI_NMGR_RESULT_NOT_READY,
            NULL,
            NULL);
	}
    else
    {
        mmi_nmgr_info_struct info;
        WCHAR name[MMI_PHB_NAME_LENGTH + 1];
        mmi_nmgr_hdlr_func_t hdlr;

        memset(&info, 0, sizeof(mmi_nmgr_info_struct));

        if (g_sms_cntx.report_count > 0)
        {
            srv_sms_status_report_struct report_data;

            info.total_num = g_sms_cntx.report_count;
        #ifdef __LOW_COST_SUPPORT_COMMON__
            info.image = IMG_NEW_MESSAGE_NOTIFICATION_MSG;
        #else
            info.image = IMG_NEW_MESSAGE_NOTIFICATION_MSG_IN_IDLE;
        #endif /* __LOW_COST_SUPPORT_COMMON__ */
            info.left_softkey = STR_GLOBAL_VIEW;
            info.idle_text1 = GetString(STR_ID_SMS_NEW_DELIVERY_REPORT);

            srv_sms_get_report_info(&report_data, g_sms_cntx.curr_report_id);

            srv_phb_get_name_by_number((U16*)report_data.number, (U16*)name, MMI_PHB_NAME_LENGTH);
            if (mmi_wcslen(name) == 0)
            {
                mmi_wcscpy(name, report_data.number);
            }

            info.idle_text2 = (S8*)name;

        #if (MMI_SIM_TOTAL == 2)
            if (report_data.sim_id == SRV_SMS_SIM_2)
            {
                info.icon = IMG_ID_SMS_STATUS_REPORT_SIM2;
            }
            else
            {
                info.icon = IMG_ID_SMS_STATUS_REPORT_SIM1;
            }
        #else /* (MMI_SIM_TOTAL >= 2) */
            info.icon = IMG_ID_SMS_STATUS_REPORT;
        #endif /* (MMI_SIM_TOTAL >= 2) */

            hdlr = mmi_sms_nmgr_report_notify_key_hdlr;
        }
        else
        {
            hdlr = NULL;
        }

        mmi_nmgr_answer(
            MMI_NMGR_APP_SMS_REPORT,
            MMI_NMGR_RESULT_OK,
            &info,
            hdlr);
    }
}
#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_nmgr_report_notify_key_hdlr
 * DESCRIPTION
 *  SMS notification LSK key handler
 * PARAMETERS
 *  user_data		[IN]	the data the sms filled before
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_sms_nmgr_report_notify_key_hdlr(void* user_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_um_entry_report();
}

#ifndef __MMI_PLUTO_3232_IDLE_NMGR_SLIM__

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_nmgr_cancel_report_notify
 * DESCRIPTION
 *  Cancel the SMS notification flag
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_sms_nmgr_cancel_report_notify(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_sms_cntx.report_count = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_nmgr_need_report_ind
 * DESCRIPTION
 *  check if new msg indication is required
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
U8 mmi_sms_nmgr_need_report_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_sms_cntx.report_count > 0)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}
#endif /*__MMI_PLUTO_3232_IDLE_NMGR_SLIM__*/

#else /* __MMI_UM_REPORT_BOX__ */

typedef struct
{
    MMI_ID owner_gid;
    U16 status_icon_id;
    U16 status_str_id;
    MMI_BOOL icon_flag;
    WCHAR *report_msg;
} mmi_sms_report_ind_struct;

static MMI_BOOL mmi_sms_entry_report_ind(mmi_scenario_id scen_id, void *arg);
static void mmi_sms_report_ind_launch(MMI_ID parent_gid);
static void mmi_sms_convert_report_msg(
                mmi_sms_report_ind_struct* report_ind,
                srv_sms_status_report_struct *report_data);
static void mmi_sms_entry_report_ind_ext(mmi_scrn_essential_struct* scrn_data);
static mmi_ret mmi_sms_report_ind_proc(mmi_event_struct* evt);

#define MMI_SMS_REPORT_MSG_LEN          120

static mmi_sms_report_ind_struct *report_ind_cntx;


/*****************************************************************************
 * FUNCTION
 *  mmi_cbs_entry_new_msg_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
static MMI_BOOL mmi_sms_entry_report_ind(mmi_scenario_id scen_id, void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_sms_report_ind_launch(mmi_idle_get_group_id());

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_report_ind_launch
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_sms_report_ind_launch(MMI_ID parent_gid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID curr_gid;
    srv_sms_status_report_struct* report_data;
    mmi_sms_report_ind_struct *ind_cntx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    report_data = g_sms_cntx.report_data[g_sms_cntx.report_count - 1];

    ind_cntx = OslMalloc(sizeof(srv_sms_status_report_struct));

    curr_gid = mmi_frm_group_create(
                    parent_gid,
                    GRP_ID_AUTO_GEN,
                    mmi_sms_report_ind_proc,
                    ind_cntx);

    ind_cntx->owner_gid = curr_gid;

    ind_cntx->report_msg = OslMalloc(MMI_SMS_REPORT_MSG_LEN * sizeof(WCHAR));

    mmi_sms_convert_report_msg(ind_cntx, report_data);

    mmi_frm_group_enter(curr_gid, MMI_FRM_NODE_SMART_CLOSE_FLAG);

    mmi_frm_scrn_first_enter(
        curr_gid,
        SCR_ID_MSG_DELIVER_REPORT,
        (FuncPtr)mmi_sms_entry_report_ind_ext,
        ind_cntx);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_get_deliver_report_msg
 * DESCRIPTION
 *  Get delivery report msg
 * PARAMETERS
 *  void
 * RETURNS
 *  string for delivery report indication
 *****************************************************************************/
static void mmi_sms_convert_report_msg(
                mmi_sms_report_ind_struct* report_ind,
                srv_sms_status_report_struct *report_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    WCHAR name[MMI_PHB_NAME_LENGTH + 1];
    WCHAR ts_date[(MMI_SMS_MAX_DATE_SIZE + 1)];
    WCHAR ts_time[(MMI_SMS_MAX_TIME_SIZE + 1)];
    WCHAR *receiver_ptr = report_data->number;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (report_data->status == SRV_SMS_SRS_SUCC)
    {
        report_ind->icon_flag = MMI_TRUE;
        #ifndef __MMI_SMS_BOX_ICON_SLIM__
        report_ind->status_icon_id = IMG_MESSAGE_SENT;
         #else
       report_ind->status_icon_id =  IMG_MESSAGE_READ;
        #endif
        report_ind->status_str_id = STR_SUCCESS_CAPTION;
    }
    else
    {
        report_ind->icon_flag = MMI_FALSE;
        #ifndef __MMI_SMS_BOX_ICON_SLIM__
        report_ind->status_icon_id = IMG_MESSAGE_UNSENT;
        #else
       report_ind->status_icon_id =  IMG_MESSAGE_READ;
        #endif
        report_ind->status_str_id = STR_FAILURE_CAPTION;
    }

    srv_phb_get_name_by_number((U16*)receiver_ptr, (U16*)name, MMI_PHB_NAME_LENGTH);

    date_string(&report_data->timestamp, (UI_string_type)ts_date, DT_IDLE_SCREEN);
    time_string(&report_data->timestamp, (UI_string_type)ts_time, DT_IDLE_SCREEN);

    if (mmi_wcslen(name))
    {
        receiver_ptr = name;
    }

#ifdef __MMI_SMS_SLIM__
    kal_wsprintf(report_ind->report_msg, "%w\n%w\n%w\n%w\n", (U16*) GetString(report_ind->status_str_id),receiver_ptr, ts_date, ts_time);
    #else
    kal_wsprintf(report_ind->report_msg, "\n%w\n%w\n%w\n", receiver_ptr, ts_date, ts_time);
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_entry_report_ind_ext
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_sms_entry_report_ind_ext(mmi_scrn_essential_struct* scrn_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = mmi_frm_scrn_enter(
                scrn_data->group_id, 
                scrn_data->scrn_id,
                NULL,
                (FuncPtr)mmi_sms_entry_report_ind_ext,
                MMI_FRM_FULL_SCRN);

    if (result)
    {
        U8 *gui_buffer = NULL;
        mmi_sms_report_ind_struct *ind_cntx = (mmi_sms_report_ind_struct*)scrn_data->user_data;
	#ifndef __MMI_SMS_SLIM__
        U32 icon_flag = 0;
	#endif

        gui_buffer = mmi_frm_scrn_get_active_gui_buf();

        EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
#ifdef __MMI_SMS_SLIM__
wgui_cat_setup_special_style(WGUI_CAT_TEXT_VIEWER_HORIZONTAL_CENTER);

ShowCategory74Screen(
                    STR_SR_DELIVERD_ID,
                    IMG_SMS_ENTRY_SCRN_CAPTION,
                    STR_GLOBAL_OK,
                    IMG_GLOBAL_OK,
                    0,
                    0,
                    (U8*)ind_cntx->report_msg,
                    MMI_SMS_REPORT_MSG_LEN,
                    (U8*) gui_buffer);
#else

        ShowCategory145Screen(
            ((U8*)GetString(STR_SR_DELIVERD_ID)),
            IMG_SMS_ENTRY_SCRN_CAPTION,
            STR_GLOBAL_OK,
            IMG_GLOBAL_OK,
            0,
            0,
            ind_cntx->status_icon_id,
            (U8*)GetString(ind_cntx->status_str_id),
            (U8*)ind_cntx->report_msg,
            icon_flag,
            gui_buffer);
  #endif          

        SetLeftSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
        SetCenterSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_cbs_ind_viewer_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
static mmi_ret mmi_sms_report_ind_proc(mmi_event_struct* evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                                                         */
    /*----------------------------------------------------------------*/
    U16 event_id = evt->evt_id;
    mmi_sms_report_ind_struct *ind_cntx = (mmi_sms_report_ind_struct*)evt->user_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                                                               */
    /*----------------------------------------------------------------*/
    switch (event_id)
    {
        case EVT_ID_GROUP_ACTIVE:
            report_ind_cntx = ind_cntx;
            break;
    
        case EVT_ID_GROUP_DEINIT:
        {
            if (report_ind_cntx == ind_cntx)
            {
                report_ind_cntx = NULL;
            }

            OslMfree(ind_cntx->report_msg);
            OslMfree(ind_cntx);
            break;
        }

        case EVT_ID_GROUP_GOBACK:
        {
            g_sms_cntx.report_count--;

            OslMfree(g_sms_cntx.report_data[g_sms_cntx.report_count]);
            g_sms_cntx.report_data[g_sms_cntx.report_count] = NULL;
            break;
        }

        case EVT_ID_GROUP_GOBACK_IN_END_KEY:
        {
            U32 i;
        
            for (i = 0; i < g_sms_cntx.report_count; i++)
            {
                OslMfree(g_sms_cntx.report_data[i]);
                g_sms_cntx.report_data[i] = NULL;
            }
            
            g_sms_cntx.report_count = 0;
            break;
        }

        default:
            break;
    }

    return MMI_RET_OK;
}
#endif /* __MMI_UM_REPORT_BOX__ */


/*****************************************************************************
 * FUNCTION
 *  mmi_msg_need_delivery_report_ind
 * DESCRIPTION
 *  Check if delivery report indication is required
 * PARAMETERS
 *  void
 * RETURNS
 *  non-0: indication required, 0: indication not required
 *****************************************************************************/
U8 mmi_sms_need_delivery_report_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UM_REPORT_BOX__
    return MMI_FALSE;
#else /* __MMI_UM_REPORT_BOX__ */
    return g_sms_cntx.report_count;
#endif /* __MMI_UM_REPORT_BOX__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_sms_entry_delivery_report_ind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
void mmi_sms_entry_delivery_report_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UM_REPORT_BOX__
    mmi_frm_nmgr_notify_by_idle(MMI_SCENARIO_ID_NEW_SMS_REPORT, MMI_EVENT_SMS, NULL);
#else /* __MMI_UM_REPORT_BOX__ */
    if (report_ind_cntx == NULL)
    {
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif
    
       // if (!is_deffered)
        {
            mmi_frm_nmgr_notify_by_app(
                MMI_SCENARIO_ID_NEW_SMS_REPORT,
                MMI_EVENT_SMS,
                mmi_sms_entry_report_ind,
                NULL);
        }
    }
    else
    {
        if ((mmi_frm_group_get_active_id() == report_ind_cntx->owner_gid) &&
            (mmi_frm_scrn_get_active_id() == SCR_ID_MSG_DELIVER_REPORT))
        {
            MMI_ID old_gid = report_ind_cntx->owner_gid;

            mmi_frm_nmgr_notify_by_app(
                MMI_SCENARIO_ID_NEW_SMS_REPORT,
                MMI_EVENT_SMS,
                mmi_sms_entry_report_ind,
                NULL);

            mmi_frm_group_close(old_gid);
        }
    }
#endif /* __MMI_UM_REPORT_BOX__ */
}

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_entry_delivery_report_ind
 * DESCRIPTION
 * Function used by idle to show the screen 
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
void mmi_sms_report_ind_idle_launch()
{
 mmi_sms_report_ind_launch(mmi_idle_get_group_id());

}

/*****************************************************************************
 * FUNCTION
 *  mmi_sms_report_available
 * DESCRIPTION
 *  returns if the delivery report is available
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
U8 mmi_sms_report_available()
{
	if(g_sms_cntx.report_count != 0)
		return TRUE;
	else
		return FALSE;
}
