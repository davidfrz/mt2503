/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/

#include "MMI_features.h"

#include "DLAgentSrvWPS.h"

#ifdef __MMI_DA_WPS_UTIL__

//#include "ConnectManageGProt.h"
//#include "ProtocolEvents.h"
//#include "Wap_ps_struct.h"
//#include "Wapadp.h"
#include "BrowserSrvGprot.h"
#include "app_ua.h"

#include "DLAgentSrvIProt.h"
#include "DLAgentSrvProt.h"
#include "CbmSrvGprot.h"
#include "DtcntSrvGprot.h"
#if defined(OBIGO_Q03C)
#define SRV_DA_WPS_SLOW_BG_DL_SUPPORT
#endif

#ifndef _ABM_API_H
#include "abm_api.h"
#endif



    #include "abm_api.h"
    #include "MMI_conn_app_trc.h"
    #include "DebugInitDef_Int.h"
    #include "MMIDataType.h"
    #include "kal_general_types.h"
    #include "wps_struct.h"
    #include "stack_msgs.h"
    #include "mmi_frm_mem_gprot.h"
    #include "kal_public_api.h"
    #include "string.h"
    #include "cbm_api.h"
    #include "wgui_categories_util.h"
    #include "GlobalMenuItems.h"
    #include "GlobalResDef.h"
    #include "Unicodexdcl.h"
    #include "app_ltlcom.h"
    #include "mmi_conn_app_trc.h"
    #include "kal_trace.h"
    #include "stdio.h"
    #include "stack_config.h"
    #include "mmi_frm_events_gprot.h"
    #include "mmi_frm_queue_gprot.h"
    #include "mmi_frm_timer_gprot.h"
    #include "fs_errcode.h"
    #include "cbm_consts.h"
#ifdef __MMI_DOWNLOAD_AGENT__
#include "mmi_rp_srv_downloadagent_def.h"
#endif
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
#include "CbmCuiGprot.h"
#include "custom_data_account.h"
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */

#ifdef __HTTP_INTERFACE__

/****************************************************************************
 * Constants & Configurations
 ****************************************************************************/

#define MMI_DA_WPS_TRACE_GROUP      MMI_CONN_TRC_G1_DLAGENT




/****************************************************************************
* Define - Macro
*****************************************************************************/

#define DA_WPS_TRACE_FUNC1(func, p1)            srv_da_trace_func_ex(DA_TRACE_##func, p1, 0, 0)
#define DA_WPS_TRACE_FUNC2(func, p1, p2)        srv_da_trace_func_ex(DA_TRACE_##func, p1, p2, 0)
#define DA_WPS_TRACE_FUNC3(func, p1, p2, p3)    srv_da_trace_func_ex(DA_TRACE_##func, p1, p2, p3)

#define DA_WPS_TRACE                            MMI_TRACE


/****************************************************************************
* Typedef - Enum
*****************************************************************************/

#define SRV_DA_WPS_TRACE_ITEM(func) DA_TRACE_##func

typedef enum
{
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_create_session) = 0x000A0000,
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_free_session),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_notify_active_downloads),

    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_bearer_fallback_proc),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_get_wap_profile),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_cbm_fallback_grp_proc),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_handle_bearer_switch),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_recv_set_channel_rsp),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_nwk_fsm_bearer_info_ind),

    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_handle_bearer_info_ind) = 0x000A0100,
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_can_switch_to_wlan),
    SRV_DA_WPS_TRACE_ITEM(srv_da_wps_is_wlan_in_use_for_app),
	SRV_DA_WPS_TRACE_ITEM(srv_da_wps_handle_bearer_network_switch_event),

    DA_TRACE_WPS_TRACE_END_OF_ENUM
} srv_da_wps_trace_enum; /* this enum is for TRACE usage */

#undef SRV_DA_WPS_TRACE_ITEM

#endif
    
/****************************************************************************
 * Static Variable
 ****************************************************************************/

static srv_da_wps_context_struct srv_da_wps_context;

#ifdef __HTTP_INTERFACE__

/****************************************************************************
 * Global Variable
 ****************************************************************************/
extern void srv_da_trace_func_ex(S32 func_enum, S32 p1, S32 p2, S32 p3);


/****************************************************************************
 * Function Declaration
 *****************************************************************************/
static void srv_da_wps_free_session(srv_da_wps_session_struct *session);

static MMI_BOOL srv_da_wps_send_set_channel_req(srv_da_wps_session_struct *session, srv_da_wps_channel_struct* channel);
static MMI_BOOL srv_da_wps_recv_set_channel_rsp(void *MsgStruct);
static MMI_BOOL srv_da_wps_send_unset_channel_req(srv_da_wps_channel_struct* channel);
static MMI_BOOL srv_da_wps_recv_unset_channel_rsp(void *MsgStruct);

static MMI_BOOL srv_da_wps_send_http_req(srv_da_wps_session_struct *session, U8 http_method,
                                     S8 * url, S8 *header, S8 * post_data, PU16 file_path, U8 reply_type);
static MMI_BOOL srv_da_wps_recv_http_rsp(void *MsgStruct, S32 mod_src, void *ilm_p);
static MMI_BOOL srv_da_wps_send_cancel_req(srv_da_wps_session_struct *session);
static MMI_BOOL srv_da_wps_recv_cancel_rsp(void *MsgStruct);
static MMI_BOOL srv_da_wps_recv_dl_progress_ind(void *MsgStruct);
static MMI_BOOL srv_da_wps_recv_http_auth_ind(void *MsgStruct);
static MMI_BOOL srv_da_wps_send_http_auth_res(srv_da_wps_session_struct *session, U8 *username, U8 *password);

//#if defined(SRV_DA_WPS_SLOW_BG_DL_SUPPORT)
static void srv_da_wps_delay_dl_progress_res(void* param);
//#endif
#define END_OF_FUNCTION_DECLARATION


/****************************************************************************
 * Private Functions
 ****************************************************************************/


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_is_session_valid
 * DESCRIPTION
 *  To test if a session is valid.
 * PARAMETERS
 *  session     [IN] Session
 * RETURNS
 *  MMI_TRUE if valid.
 *****************************************************************************/
static MMI_BOOL srv_da_wps_is_session_valid(srv_da_wps_session_struct *session)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_session_struct *in_table;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (session == NULL)
    {
        return MMI_FALSE;
    }

    in_table = srv_da_wps_context.session_table[session->session_idx];
    
    if (in_table == session)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_get_channel_by_channel_id
 * DESCRIPTION
 *  Get channel by channel ID.
 * PARAMETERS
 *  channel_id      [IN] Channel ID
 * RETURNS
 *  Channel
 *****************************************************************************/
static srv_da_wps_channel_struct* srv_da_wps_get_channel_by_channel_id(U8 channel_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_channel_struct *ch;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ch = NULL;

    if (srv_da_wps_context.dl_channel.is_set &&
        srv_da_wps_context.dl_channel.channel_id == channel_id)
    {
        ch = &(srv_da_wps_context.dl_channel);
    }
    else if (srv_da_wps_context.post_channel.is_set &&
        srv_da_wps_context.post_channel.channel_id == channel_id)
    {
        ch = &(srv_da_wps_context.post_channel);
    }
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    else
    {
        U32 i;
    
        for (i = 0; i < SRV_DA_WPS_MAX_CUST_SESSION; i++)
        {
            if (srv_da_wps_context.cust_ch[i].is_set &&
                srv_da_wps_context.cust_ch[i].channel_id == channel_id)
            {
                ch = &(srv_da_wps_context.cust_ch[i]);
                break;
            }
        }
    }
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */


    return ch;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_get_session_by_http_req_id
 * DESCRIPTION
 *  Get the session according to HTTP request ID.
 * PARAMETERS
 *  request_id      [IN] Request ID
 * RETURNS
 *  Session. If no session is responsible for the ID, NULL will be returned.
 *****************************************************************************/
static srv_da_wps_session_struct* srv_da_wps_get_session_by_http_req_id(U16 request_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (i = 0; i < SRV_DA_WPS_MAX_SESSION; i++)
    {
        if (srv_da_wps_context.session_table[i] != NULL &&
            srv_da_wps_context.session_table[i]->request_id == request_id)
        {
            return srv_da_wps_context.session_table[i];
        }
    }

    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_assign_new_request_id
 * DESCRIPTION
 *  Assign a new request ID the the session.
 * PARAMETERS
 *  session     [IN] Session
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_wps_assign_new_request_id(srv_da_wps_session_struct *session)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U8 request_id = (U8)1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (request_id == 0) /* To avoid request ID is 0 */
    {
        request_id = 1;
    }
    
    session->request_id = request_id;
    request_id++;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_get_request_id
 * DESCRIPTION
 *  Get the HTTP request ID can be used for the session.
 * PARAMETERS
 *  session     [IN] Session
 * RETURNS
 *  Request ID.
 *****************************************************************************/
#define srv_da_wps_get_request_id(session_p) ((session_p)->request_id)
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_is_cust_channel
 * DESCRIPTION
 *  Returns MMI_TRUE if the channel is in cust-channel.
 * PARAMETERS
 *  channel     [IN] Channel
 * RETURNS
 *  MMI_TRUE if it is a cust-channel.
 *****************************************************************************/
static MMI_BOOL srv_da_wps_is_cust_channel(srv_da_wps_channel_struct *channel)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (channel != &(srv_da_wps_context.dl_channel) &&
        channel != &(srv_da_wps_context.post_channel));
}


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_notify_active_downloads
 * DESCRIPTION
 *  To notify how many downloads is running. This function will check the
 *  number of running downloads & sessions, to decide whether to close
 *  channels.
 * PARAMETERS
 *  n_active_downloads      [IN] Is there active download
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_notify_active_downloads(MMI_BOOL active_download)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (srv_da_wps_context.active_download != active_download)
    {
#ifdef __HTTP_INTERFACE__
        DA_WPS_TRACE_FUNC2(srv_da_wps_notify_active_downloads, srv_da_wps_context.active_download, active_download);    
#endif
        srv_da_wps_context.active_download = active_download;
    }

    /* Once the channel is built and continue some download,
       destroy the channel only when no download is active */
    if (!srv_da_wps_context.active_download &&
        srv_da_wps_context.dl_channel.ref_count == 0 &&
        srv_da_wps_context.post_channel.ref_count == 0)
    {
        /* No active download, unset channels */
        if (srv_da_wps_context.dl_channel.is_set &&
            srv_da_wps_context.dl_channel.ref_count == 0)
        {
            srv_da_wps_send_unset_channel_req(&(srv_da_wps_context.dl_channel));
        }
        if (srv_da_wps_context.post_channel.is_set &&
            srv_da_wps_context.post_channel.ref_count == 0)
        {
            srv_da_wps_send_unset_channel_req(&(srv_da_wps_context.post_channel));
        }
    }
}






MMI_BOOL srv_da_wps_is_wlan_in_use_for_app (U8 app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    cbm_bearer_status_query_struct info;
    U32 status = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&info, 0, sizeof(info));
    info.by_app = KAL_TRUE;
    info.by_bearer = KAL_TRUE;
    info.app_id = app_id;
    info.bearer = CBM_WIFI;

    status = cbm_get_bearer_status_ext(&info);
#ifdef __HTTP_INTERFACE__
    DA_WPS_TRACE_FUNC2(srv_da_wps_is_wlan_in_use_for_app, status, app_id);
#endif
    if (status == CBM_ACTIVATING || status == CBM_ACTIVATED)
    {
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}


MMI_BOOL srv_da_wps_can_switch_to_wlan (void)
{
#ifdef BROWSER_SUPPORT
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 opera_acct_id = 0;
    U32 ori_acct_id = 0;
    cbm_sim_id_enum  sim_id;
    U8 app_id;
    MMI_BOOL  always_ask;
	srv_brw_profile_content_struct *profile;


    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	profile = (srv_brw_profile_content_struct*)
        srv_da_adp_mem_allocate(sizeof(srv_brw_profile_content_struct));
	srv_brw_get_active_browser_profile(profile);
	if (profile!=NULL)
	{
		opera_acct_id = profile->data_account_primary_id;
    cbm_decode_data_account_id(opera_acct_id, &sim_id, &app_id, &always_ask, &ori_acct_id);
	}

	OslMfree(profile);
#ifdef __HTTP_INTERFACE__
    DA_WPS_TRACE_FUNC2(srv_da_wps_can_switch_to_wlan, opera_acct_id, app_id);
#endif
    if (srv_da_wps_is_wlan_in_use_for_app (app_id))
    {
#ifdef __HTTP_INTERFACE__
        DA_WPS_TRACE_FUNC2(srv_da_wps_can_switch_to_wlan, 0, app_id);
#endif
        return MMI_FALSE;
    }

    if (srv_da_wps_is_wlan_in_use_for_app (srv_da_wps_context.cbm_app_id))
    {
#ifdef __HTTP_INTERFACE__
        DA_WPS_TRACE_FUNC2(srv_da_wps_can_switch_to_wlan, 1, srv_da_wps_context.cbm_app_id);
#endif
        return MMI_FALSE;
    }
#endif
    DA_WPS_TRACE_FUNC1(srv_da_wps_can_switch_to_wlan, 2);
    return MMI_TRUE;
   
}
#endif /* __HTTP_INTERFACE__ */

#ifdef MMI_DA_WLAN_PREFER_SUPPORT
void srv_da_wps_reset_account_id (void)
{
    srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_TOTAL;
}

void srv_da_wps_handle_bearer_info_ind (srv_da_wps_channel_struct *ch, MMI_BOOL is_activated)
{
    U16 i;
    if (ch->is_set) /* Channel was set successfully */
    {
        if(ch->ref_count == 0)
        {
            srv_da_wps_send_unset_channel_req(ch);
        }
        else
        {
            MMI_BOOL is_reset = MMI_FALSE;
            for(i=0 ;i<SRV_DA_WPS_MAX_SESSION; i++)
            {
                if(srv_da_wps_context.session_table[i] &&
                    srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
                    srv_da_wps_context.session_table[i]->channel == ch)
                {
                    is_reset = MMI_TRUE;
                    srv_da_wps_context.session_table[i]->state = SRV_DA_WPS_SESSION_STATE_READY;
                    srv_da_wps_context.session_table[i]->create_cb(is_activated, srv_da_wps_context.session_table[i]->arg);
                }
            }
            if (!is_reset)
            {
                srv_da_wps_send_unset_channel_req(ch);
            }
        }
    }
    else
    {
        MMI_BOOL is_reset = MMI_FALSE;

        ch->is_set = MMI_TRUE;
        ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_FREE;

        for (i = 0; i < SRV_DA_WPS_MAX_SESSION; i++)
        {
            if(srv_da_wps_context.session_table[i] &&
                srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
                srv_da_wps_context.session_table[i]->channel == ch)
            {
                is_reset = MMI_TRUE;
                srv_da_wps_context.session_table[i]->create_cb(MMI_FALSE, srv_da_wps_context.session_table[i]->arg);
                DA_WPS_TRACE_FUNC1(srv_da_wps_handle_bearer_info_ind, 1);
                /*
                 * srv_da_wps_context.session_table[i] will be freed when client call
                 * srv_da_wps_close_session(). So not necessary to free it here.
                 */
            }
        }
        if (!is_reset)
        {
            srv_da_wps_send_unset_channel_req(ch);
        }
    }
}
#endif
#ifdef __HTTP_INTERFACE__
mmi_ret srv_da_wps_nwk_fsm_bearer_info_ind(mmi_event_struct *evt)
{
    srv_da_wps_session_struct *session = NULL;
    srv_cbm_bearer_info_struct *bearer_info_p = (srv_cbm_bearer_info_struct*)evt;
    srv_da_wps_channel_struct  *ch;
	U32 arg;
	MMI_BOOL is_reset = MMI_FALSE;
	S32 i;
   
    DA_WPS_TRACE_FUNC3(srv_da_wps_nwk_fsm_bearer_info_ind, 0, bearer_info_p->state, bearer_info_p->account_id);
	if (srv_da_wps_context.setting_type == SRV_DA_WPS_SETTING_DEFAULT)
{
	ch = &(srv_da_wps_context.dl_channel);
}
else
{
	ch = &(srv_da_wps_context.post_channel);
}
#ifdef __HTTP_INTERFACE__
	DA_WPS_TRACE_FUNC2(srv_da_wps_nwk_fsm_bearer_info_ind, 4, ch->busy_flag);
#endif

	for(i=0;i<SRV_DA_WPS_MAX_SESSION;i++)
	{
		if(srv_da_wps_context.session_table[i] &&
			srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
			srv_da_wps_context.session_table[i]->channel == ch)
		{
			session = srv_da_wps_context.session_table[i];
			break;
		}
	}
	if (session != NULL)
	arg = session->arg;
	else
		arg = 0;
	if (bearer_info_p->error_cause == ABM_E_REJECTED)
	{
		DA_WPS_TRACE_FUNC2(srv_da_wps_nwk_fsm_bearer_info_ind, 5, ch->busy_flag);
		srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_TOTAL;
		if (ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_IN_AUTHENTICATING)
		{
		
		
			ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_FREE;
		}
		if (srv_da_get_first_job() != NULL)
		{
			DA_WPS_TRACE_FUNC2(srv_da_wps_nwk_fsm_bearer_info_ind, 6, ch->busy_flag);
		srv_da_suspend_all_job(SRV_DA_ERROR_OTHERS);
		}
		else
		{
			DA_WPS_TRACE_FUNC2(srv_da_wps_nwk_fsm_bearer_info_ind, 7, ch->busy_flag);
			if(srv_da_wps_context.session_table[i]) 
			{
				is_reset = MMI_TRUE;
				DA_WPS_TRACE_FUNC2(srv_da_wps_nwk_fsm_bearer_info_ind, 8, ch->busy_flag);
				srv_da_wps_context.session_table[i]->create_cb(MMI_FALSE, srv_da_wps_context.session_table[i]->arg);
				DA_WPS_TRACE_FUNC3(srv_da_wps_nwk_fsm_bearer_info_ind, 16,bearer_info_p->account_id, srv_da_wps_context.acc_id);

				/*
				 * mmi_da_wps_context.session_table[i] will be freed when client call
				 * mmi_da_wps_close_session(). So not necessary to free it here.
				 */
				srv_da_free_job_and_remove_screens_ex((srv_da_job_struct *)arg);
			}
			 
		}


		
	}
	else
	{
    switch (bearer_info_p->state)
    {
    case SRV_CBM_ACTIVATED:
        {
			DA_WPS_TRACE_FUNC3(srv_da_wps_nwk_fsm_bearer_info_ind, 4,bearer_info_p->account_id, srv_da_wps_context.acc_id);

    if (ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_IN_AUTHENTICATING)
    {
#ifdef __HTTP_INTERFACE__
        DA_WPS_TRACE_FUNC2(srv_da_wps_nwk_fsm_bearer_info_ind, 1, ch->ref_count);
#endif
        
				if (bearer_info_p->account_id != srv_da_wps_context.acc_id)
        {
            DA_WPS_TRACE_FUNC1(srv_da_wps_nwk_fsm_bearer_info_ind, 10);
            return MMI_RET_OK;
        }
			
            ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_FREE;
			if (session != NULL)
					srv_da_wps_send_set_channel_req(session, ch);

            }
	break;

        }
    case SRV_CBM_DEACTIVATED:
		{
			
			DA_WPS_TRACE_FUNC3(srv_da_wps_nwk_fsm_bearer_info_ind, 14,bearer_info_p->account_id, srv_da_wps_context.acc_id);
			if (ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_IN_AUTHENTICATING)
			{
			if (bearer_info_p->account_id == srv_da_wps_context.acc_id)
			{

				
				ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_FREE;
				srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_TOTAL;
							DA_WPS_TRACE_FUNC3(srv_da_wps_nwk_fsm_bearer_info_ind, 15,bearer_info_p->account_id, srv_da_wps_context.acc_id);

							if(srv_da_wps_context.session_table[i]) 
					{
						is_reset = MMI_TRUE;
						srv_da_wps_context.session_table[i]->create_cb(MMI_FALSE, srv_da_wps_context.session_table[i]->arg);
								DA_WPS_TRACE_FUNC3(srv_da_wps_nwk_fsm_bearer_info_ind, 16,bearer_info_p->account_id, srv_da_wps_context.acc_id);

						/*
						 * mmi_da_wps_context.session_table[i] will be freed when client call
						 * mmi_da_wps_close_session(). So not necessary to free it here.
						 */
					}
						
				if (!is_reset)
				{
					if(ch->is_set)
					srv_da_wps_send_unset_channel_req(ch);
				}
    }
		}
				break;
    }
    }
	}

	

    return MMI_RET_OK;
}


void srv_da_wap_reset_bearer_type (void)
{
    srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_TOTAL;
}
#endif
#ifdef MMI_DA_WLAN_PREFER_SUPPORT

static mmi_ret srv_da_wps_cbm_fallback_grp_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __HTTP_INTERFACE__
/* under construction !*/
        #endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    return MMI_RET_OK;

}

static mmi_ret srv_da_wps_handle_bearer_switch (U16 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U32 encoded_dtcnt_id;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __HTTP_INTERFACE__
    DA_WPS_TRACE_FUNC2(srv_da_wps_handle_bearer_switch, type, srv_da_wps_context.cbm_bearer_type);
#endif
    if (type == SRV_DA_SWITCH_BEARER_WLAN)
    {
		//if (srv_da_wps_context.cbm_bearer_type != SRV_DA_SWITCH_BEARER_WLAN)
		//{
            
                srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_WLAN;
                srv_da_suspend_and_resume_all_download();
		//}
            
            
        srv_da_reset_bearer_switching();
        return SRV_CBM_OK;
    }
    else if (type == SRV_DA_SWITCH_BEARER_CELLULAR)
    {
        srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_CELLULAR;
		srv_da_suspend_and_resume_all_download();
        srv_da_reset_bearer_switching();
        return SRV_CBM_OK;
	}
    return SRV_CBM_ERROR;
}



void srv_da_wps_switch_to_other_wlan (void)
{
    srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_WLAN;
    srv_da_suspend_and_resume_all_download();
}
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */


static mmi_ret srv_da_wps_bearer_fallback_proc(mmi_event_struct *evnt)
{
#if 0
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
#endif /* 0 */
    return SRV_CBM_ERROR;
}

#ifdef MMI_DA_WLAN_PREFER_SUPPORT
void srv_da_wps_handle_bearer_fallback_proc (U16 type)
{
    srv_da_wps_handle_bearer_switch (type);
}

static mmi_ret srv_da_wps_handle_bearer_network_switch_event (mmi_event_struct *evnt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_cbm_bearer_event_struct *evt = (srv_cbm_bearer_event_struct*) evnt;
    U16 switch_type = SRV_DA_SWITCH_BEARER_TOTAL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
DA_WPS_TRACE_FUNC3(srv_da_wps_handle_bearer_network_switch_event, evt->type, evt->user_result, evt->switch_type);
 if(evt->type == SRV_CBM_BEARER_EVENT_DISCONNECT)
	 return MMI_RET_OK;
 else
 {
    if (evt->user_result)
    {
        if ((evt->switch_type == SRV_CBM_BEARER_SWITCH_WIFI_TO_WIFI) || (evt->switch_type ==  SRV_CBM_BEARER_SWITCH_PS_TO_WIFI))
        {
            switch_type = SRV_DA_SWITCH_BEARER_WLAN;
        }
        else if (evt->switch_type == SRV_CBM_BEARER_SWITCH_WIFI_TO_PS)
        {
            switch_type = SRV_DA_SWITCH_BEARER_CELLULAR;
        }
        srv_da_wps_handle_bearer_switch (switch_type);
    }
	else
	{
		srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_TOTAL;
		srv_da_suspend_all_job(SRV_DA_ERROR_OTHERS);
		
	}

	return MMI_RET_OK;
 }
}
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */

#ifdef __HTTP_INTERFACE__
U8 srv_da_wps_get_cbm_id (U8 cbm_id)
{
	switch (cbm_id)
	{

	case SRV_DA_CBM_APP_ID1:
		return srv_da_wps_context.cbm_app_id1;
		
	case SRV_DA_CBM_APP_ID2:
		return srv_da_wps_context.cbm_app_id2;

	default:
		return srv_da_wps_context.cbm_app_id;
		
	}
}

void srv_da_wps_set_cbm_id (U8 app_id, U32 cbm_app_id)
{
	switch (app_id)
	{

	case SRV_DA_CBM_APP_ID1:
		srv_da_wps_context.cbm_app_id1 = cbm_app_id;
        srv_da_wps_context.cbm_app_id = cbm_app_id;
		break;
		
	case SRV_DA_CBM_APP_ID2:
	    srv_da_wps_context.cbm_app_id2 = cbm_app_id;
		break;

	default:
		
		break;
		
	}
}
#endif
/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_register_bearer_fallback
 * DESCRIPTION
 *  Register bearer fallback level.
 * PARAMETERS
 *  app_id      [IN] App ID.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_register_bearer_fallback(U8 app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    srv_cbm_register_bearer_event(
        SRV_CBM_BEARER_FB_L1,
        app_id,
        srv_da_wps_bearer_fallback_proc,
        &srv_da_wps_context);

#ifdef MMI_DA_WLAN_PREFER_SUPPORT
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */

    srv_cbm_register_bearer_event(
        SRV_CBM_BEARER_EVENT_SWITCH | SRV_CBM_BEARER_EVENT_DISCONNECT,
        app_id,
        srv_da_wps_handle_bearer_network_switch_event,
        &srv_da_wps_context);

    srv_da_wps_context.cbm_grp_id = GRP_ID_INVALID;
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
}



#ifdef BROWSER_SUPPORT


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_get_ps_profile
 * DESCRIPTION
 *  This function is to return the active profile content to DLAgent
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_get_profile_info(srv_brw_profile_content_struct *active_prof, U32 acc_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_dtcnt_prof_proxy_info_struct  dtcnt_proxy_struct;
    U32 proxy_len;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    memset(active_prof, 0, sizeof(srv_brw_profile_content_struct));    
    memset(&dtcnt_proxy_struct, 0 , (sizeof( srv_dtcnt_prof_proxy_info_struct)));

    if(MMI_FALSE == srv_dtcnt_get_proxy_info(
            acc_id,
            &dtcnt_proxy_struct,
            SRV_DTCNT_ACCOUNT_PRIMARY))
    {
        active_prof->proxy_ip = srv_da_adp_mem_allocate(4);
        active_prof->proxy_port = 0;  
        strcpy((CHAR*) active_prof->proxy_ip, (CHAR*) "");
        active_prof->conn_type = SRV_BRW_PROF_CONN_TYPE_NONE;
        strcpy((S8*) active_prof->username, (S8*)"");
        strcpy((S8*) active_prof->password, (S8*)"");
    }
    else
    {
        proxy_len = strlen((S8*)dtcnt_proxy_struct.px_addr) + 1;
        active_prof->proxy_ip = srv_da_adp_mem_allocate(sizeof(kal_uint8) * proxy_len);
        memset(active_prof->proxy_ip, 0, sizeof(kal_uint8) * proxy_len);
        active_prof->proxy_port = dtcnt_proxy_struct.px_port;
        strncpy((CHAR*) active_prof->proxy_ip, (CHAR*) dtcnt_proxy_struct.px_addr, proxy_len - 1);
        
        switch (dtcnt_proxy_struct.px_service)
        {
        case SRV_DTCNT_PROF_PX_SRV_CL_WSP:
        case SRV_DTCNT_PROF_PX_SRV_CO_WSP:
            {
                active_prof->conn_type = SRV_BRW_PROF_CONN_TYPE_CONNECTION_OREINTED;
                break;
            }

        case SRV_DTCNT_PROF_PX_SRV_CL_SEC_WSP:
        case SRV_DTCNT_PROF_PX_SRV_CO_SEC_WSP:
            {
                active_prof->conn_type = SRV_BRW_PROF_CONN_TYPE_CONNECTION_OREINTED_SECURE;
                break;
            }

        case SRV_DTCNT_PROF_PX_SRV_HTTP:
        case SRV_DTCNT_PROF_PX_SRV_HTTP_TLS:
            {
                active_prof->conn_type = SRV_BRW_PROF_CONN_TYPE_HTTP;
                break;
            }

        default:
            {
                active_prof->conn_type = SRV_BRW_PROF_CONN_TYPE_NONE;
                break;
            }
        }
        strncpy((S8*) active_prof->username, (S8*) dtcnt_proxy_struct.px_authid, NVRAM_WAP_PROF_PROFILE_USERNAME_LEN-1);
        strncpy((S8*) active_prof->password, (S8*) dtcnt_proxy_struct.px_authpw, NVRAM_WAP_PROF_PROFILE_PASSWORD_LEN-1); 
    }
}



/*****************************************************************************
 * FUNCTION
 *  mmi_da_wps_get_wlan_profile
 * DESCRIPTION
 *  This function is to return the active profile content to DLAgent
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_get_wlan_profile(srv_brw_profile_content_struct *active_prof)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 acc_id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    acc_id = cbm_encode_data_account_id(
        CBM_WIFI_ACCT_ID, 
        CBM_SIM_ID_SIM1, 
        srv_da_wps_context.cbm_app_id, 
        KAL_FALSE);

    srv_da_wps_get_profile_info (active_prof, acc_id);
    active_prof->data_account_primary_id = acc_id;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_da_wps_get_bearer_profile_
 * DESCRIPTION
 *  Get WAP's active profile. It should be freed by OslMfree() after the use.
 * PARAMETERS
 *  void
 * RETURNS
 *  Profile structure. NULL if not available.
 *****************************************************************************/
srv_brw_profile_content_struct* srv_da_wps_get_bearer_profile(U32 s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    srv_brw_profile_content_struct *profile;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    profile = (srv_brw_profile_content_struct*)
        srv_da_adp_mem_allocate(sizeof(srv_brw_profile_content_struct));
#ifdef __HTTP_INTERFACE__
    if (srv_da_wps_context.cbm_bearer_type == SRV_DA_SWITCH_BEARER_WLAN)
    {
        srv_da_wps_get_wlan_profile(profile);
        /*TODO: Need to take WIFI profile from UPP */
	}
    else
    {
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
			if (srv_da_get_current_job_type(s) == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
			{
				srv_da_wps_get_profile_info(profile, srv_da_get_current_job_acc_id(s));
				profile->data_account_primary_id = srv_da_get_current_job_acc_id(s);
	        }
			else
#endif
    srv_brw_get_active_browser_profile(profile);
     }
#endif
   
    return profile;  

		
    }

/*****************************************************************************
 * FUNCTION
 *  mmi_da_wps_get_wap_profile
 * DESCRIPTION
 *  Get WAP's active profile. It should be freed by OslMfree() after the use.
 * PARAMETERS
 *  void
 * RETURNS
 *  Profile structure. NULL if not available.
 *****************************************************************************/
static srv_brw_profile_content_struct* srv_da_wps_get_wap_profile(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    srv_brw_profile_content_struct *profile;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	profile = (srv_brw_profile_content_struct*)
        srv_da_adp_mem_allocate(sizeof(srv_brw_profile_content_struct));
#ifdef __HTTP_INTERFACE__
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
    DA_WPS_TRACE_FUNC1(srv_da_wps_get_wap_profile, srv_da_wps_context.cbm_bearer_type);

    srv_da_wps_get_profile_info(profile, srv_da_wps_context.acc_id);
    profile->data_account_primary_id = srv_da_wps_context.acc_id;	


#else /* MMI_DA_WLAN_PREFER_SUPPORT */
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
	if (srv_da_get_current_job_type(arg) == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
{
		srv_da_wps_get_profile_info(profile, srv_da_wps_context.acc_id);
		profile->data_account_primary_id = srv_da_wps_context.acc_id;
}
else

#endif
    srv_brw_get_active_browser_profile(profile);
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
#endif
    return profile;
   

}
#endif /* BROWSER_SUPPORT */


#ifdef __HTTP_INTERFACE__

/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_get_default_set_channel_req
 * DESCRIPTION
 *  Use cust_ch_req if it is assigned; otherwise, use default values.
 * PARAMETERS
 *  channel             [IN]  Channel
 *  set_channel_req     [OUT] Channel request
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_wps_get_default_set_channel_req(void *session,
    srv_da_wps_channel_struct *channel,
    wps_set_channel_req_struct *set_channel_req)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint8 ref_count;
    kal_uint16 msg_len;
	srv_da_wps_session_struct *s = (srv_da_wps_session_struct *)session;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Store ref_count & msg_len*/
    ref_count = set_channel_req->ref_count;
    msg_len = set_channel_req->msg_len;

    
    if (channel->cust_ch_req != NULL)
    {
        memcpy(set_channel_req, channel->cust_ch_req, sizeof(wps_set_channel_req_struct));
    }
    else
    {
#ifdef BROWSER_SUPPORT
        srv_brw_profile_content_struct *profile;
#endif
    
        memset(set_channel_req, 0, sizeof(wps_set_channel_req_struct));

#ifdef BROWSER_SUPPORT
        profile = srv_da_wps_get_wap_profile(s->arg);



        if (profile != NULL)
        {
            set_channel_req->use_default = KAL_FALSE;
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
			set_channel_req->net_id = profile->data_account_primary_id;
#else
            /* profile->data_account_primary_id is already encoded data account for bearer fallback */
            set_channel_req->net_id =
                cbm_set_app_id(profile->data_account_primary_id,
                srv_da_wps_context.cbm_app_id);
#endif

            switch (profile->conn_type)
            {
                case SRV_BRW_PROF_CONN_TYPE_CONNECTION_OREINTED:
                case SRV_BRW_PROF_CONN_TYPE_CONNECTION_OREINTED_SECURE:
                    set_channel_req->conn_type = WPS_CONN_TYPE_WSP_CO;
                    break;
                    
                case SRV_BRW_PROF_CONN_TYPE_HTTP:
                default:
                    set_channel_req->conn_type = WPS_CONN_TYPE_HTTP;
                    break;
            }

            if (profile->proxy_ip && strlen((S8*)profile->proxy_ip))
            {
                set_channel_req->use_proxy = KAL_TRUE;
                //memcpy(set_channel_req->prx_ip, profile->proxy_ip, sizeof(set_channel_req->prx_ip));
                set_channel_req->prx_port = profile->proxy_port;
				strcpy((CHAR*)set_channel_req->prx_addr, (CHAR*)profile->proxy_ip);
                strcpy((CHAR*)set_channel_req->username, (CHAR*)profile->username);
                strcpy((CHAR*)set_channel_req->password, (CHAR*)profile->password);
            }
            else
            {
                set_channel_req->use_proxy = KAL_FALSE;
            }

            set_channel_req->timeout = SRV_DA_WPS_DEFAULT_TIMEOUT;
			if (profile->proxy_ip)
			OslMfree(profile->proxy_ip);
            OslMfree(profile);
        }
        else
#endif /* BROWSER_SUPPORT */
        {
            set_channel_req->use_default = KAL_TRUE;
        }
    }


    /* Restore ref_count & msg_len*/
    set_channel_req->ref_count = ref_count;
    set_channel_req->msg_len = msg_len;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_get_oma_report_set_channel_req
 * DESCRIPTION
 *  Use the channel setting of sending OMA report.
 * PARAMETERS
 *  channel             [IN]  Channel
 *  set_channel_req     [OUT] Channel request
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_wps_get_oma_report_set_channel_req(void *session,
    srv_da_wps_channel_struct *channel,
    wps_set_channel_req_struct *set_channel_req)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_wps_get_default_set_channel_req(session, channel, set_channel_req);
    set_channel_req->timeout = SRV_DA_OMA_REPORT_TIMEOUT;
}

#endif /* __HTTP_INTERFACE__ */

/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_init
 * DESCRIPTION
 *  Initialize WPS module
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

#ifdef __HTTP_INTERFACE__
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    S32 i;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    memset(&srv_da_wps_context, 0, sizeof(srv_da_wps_context));
    
    srv_da_wps_context.dl_channel.is_set = MMI_FALSE;
    srv_da_wps_context.dl_channel.is_reserved = MMI_FALSE;
    srv_da_wps_context.dl_channel.get_set_channel_req =
        srv_da_wps_get_default_set_channel_req;
    
    srv_da_wps_context.post_channel.is_set = MMI_FALSE;
    srv_da_wps_context.post_channel.is_reserved = MMI_FALSE;
    srv_da_wps_context.post_channel.get_set_channel_req =
        srv_da_wps_get_oma_report_set_channel_req;
    
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    for(i = 0; i < SRV_DA_WPS_MAX_CUST_SESSION; i++)
    {
        srv_da_wps_context.cust_ch[i].is_set = MMI_FALSE;
        srv_da_wps_context.cust_ch[i].is_reserved = MMI_FALSE;
        srv_da_wps_context.cust_ch[i].get_set_channel_req =
            srv_da_wps_get_default_set_channel_req;
    }
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */
	srv_da_wps_context.cbm_bearer_type = SRV_DA_SWITCH_BEARER_TOTAL;
#endif /* __HTTP_INTERFACE__ */
}


#ifdef __HTTP_INTERFACE__

/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_call_create_cb_for_success
 * DESCRIPTION
 *  Call create_cb() of the session to notify the session is created successfully.
 * PARAMETERS
 *  arg     [IN] (srv_da_wps_session_struct*)Session
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_wps_call_create_cb_for_success(void *arg, S32 session_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_session_struct  *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    session = (srv_da_wps_session_struct*)arg;

    if (srv_da_wps_is_session_valid(session) && session->id == session_id)
    {
        session->create_cb(MMI_TRUE, session->arg);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_new_session_id
 * DESCRIPTION
 *  Generate a new session ID.
 * PARAMETERS
 *  void
 * RETURNS
 *  Unique session ID.
 *****************************************************************************/
static U16 srv_da_wps_new_session_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U16 id = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (id++);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_reserve_cust_channel
 * DESCRIPTION
 *  Reserve channel resource.
 * PARAMETERS
 *  ch_req      [IN] Channel request
 * RETURNS
 *  Channel handler
 *****************************************************************************/
srv_da_wps_channel_handle srv_da_wps_reserve_cust_channel(wps_set_channel_req_struct *ch_req)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_channel_struct *channel;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(ch_req != NULL);

    channel = NULL;

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    {
        U32 i;
    
        for (i = 0; i < SRV_DA_WPS_MAX_CUST_SESSION; i++)
        {
            channel = &(srv_da_wps_context.cust_ch[i]);
            
            if (!channel->is_set &&
                !channel->is_reserved &&
                channel->busy_flag == SRV_DA_WPS_CHANNEL_STATE_FREE &&
                channel->cust_ch_req == NULL)
            {
                /* Empty channel slot */
                
                channel->cust_ch_req = (wps_set_channel_req_struct*)srv_da_adp_mem_allocate(sizeof(wps_set_channel_req_struct));
                memcpy(channel->cust_ch_req, ch_req, sizeof(wps_set_channel_req_struct));
                channel->get_set_channel_req = srv_da_wps_get_default_set_channel_req;
                channel->is_reserved = MMI_TRUE;
                break;
            }
        }
    }
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */

    return (srv_da_wps_channel_handle)channel;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_release_channel
 * DESCRIPTION
 *  Release a reserved channel.
 * PARAMETERS
 *  channel_hdlr      [IN] Channel handler
 * RETURNS
 *  MMI_TRUE if success
 *****************************************************************************/
MMI_BOOL srv_da_wps_release_channel(srv_da_wps_channel_handle channel_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_channel_struct *channel;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    channel = (srv_da_wps_channel_struct*)channel_hdlr;

    if (channel == NULL)
    {
        return MMI_TRUE;
    }

    channel->is_reserved = MMI_FALSE;

    if (channel->ref_count > 0)
    {
        return MMI_FALSE;
    }

    if (channel->is_set &&
        channel->busy_flag == SRV_DA_WPS_CHANNEL_STATE_FREE)
    {
        srv_da_wps_send_unset_channel_req(channel);
        OslMfree(channel->cust_ch_req);
        channel->cust_ch_req = NULL;
    }

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_create_session_ex
 * DESCRIPTION
 *  Create a WPS session.
 * PARAMETERS
 *  arg             [IN] To be passed to callback functions.
 *  setting         [IN] Use which parameter set for channel. Only useful
 *                       when cust_channel == DEFAULT_CHANNEL.
 *  cust_channel    [IN] Use the channel reserved before. Also DEFAULT_CHANNEL
 *                       can be specified.
 *  create_cb       [IN] Callback to notify the result of session creation.
 *  http_rsp_cb     [IN] HTTP response callback.
 *  http_auth_cb    [IN] HTTP authentication callback.
 *  dl_progress_cb  [IN] To notify download progress.
 * RETURNS
 *  Session ID
 *****************************************************************************/
srv_da_wps_session_handle srv_da_wps_create_session_ex(
    U32 arg,
    srv_da_wps_setting_enum setting,
    srv_da_wps_channel_handle cust_channel,
    srv_da_wps_session_created_funcptr_type create_cb,
    srv_da_wps_http_response_funcptr_type http_rsp_cb,
    srv_da_wps_http_auth_ind_funcptr_type http_auth_cb,
    srv_da_wps_dl_progress_funcptr_type dl_progress_cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    srv_da_wps_session_struct  *session;

	kal_int8 ret = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* If failed, we may have to increase SRV_DA_WPS_MAX_SESSION */
    MMI_ASSERT(srv_da_wps_context.session_num < SRV_DA_WPS_MAX_SESSION);

    /* find a empty slot */
    for(i = 0; i < SRV_DA_WPS_MAX_SESSION; i++)
    {
        if(srv_da_wps_context.session_table[i] == NULL)
        {
            break;
        }
    }
    MMI_ASSERT(i < SRV_DA_WPS_MAX_SESSION);

    /* alloc resource */
    session = (srv_da_wps_session_struct  *)srv_da_adp_mem_allocate(sizeof(srv_da_wps_session_struct));

    memset(session, 0, sizeof(srv_da_wps_session_struct));

    srv_da_wps_context.session_table[i] = session;
    srv_da_wps_context.session_num++;

    session->id = srv_da_wps_new_session_id();
    session->request_id = 0;
    session->session_idx = i;
    session->arg = arg;
    session->create_cb = create_cb;
    session->http_rsp_cb = http_rsp_cb;
    session->http_auth_cb = http_auth_cb;
    session->dl_progress_cb = dl_progress_cb;
    session->state = SRV_DA_WPS_SESSION_STATE_INIT;
    session->unbuffered_write = MMI_FALSE;
	srv_da_wps_context.setting_type = setting;

    if (cust_channel == SRV_DA_WPS_DEFAULT_CHANNEL)
    {
        if (setting == SRV_DA_WPS_SETTING_DEFAULT)
        {
            session->channel = &(srv_da_wps_context.dl_channel);
        }
        else
        {
            session->channel = &(srv_da_wps_context.post_channel);
        }
    }
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    else
    {
        session->channel = (srv_da_wps_channel_struct*)cust_channel;
    }
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */
        
    session->channel->ref_count++;

    DA_WPS_TRACE_FUNC3(srv_da_wps_create_session, srv_da_wps_context.dl_channel.busy_flag, srv_da_wps_context.session_num, i);

    if(session->channel->is_set)
    {
        switch(session->channel->busy_flag)
        {
            case SRV_DA_WPS_CHANNEL_STATE_FREE:
                session->state = SRV_DA_WPS_SESSION_STATE_READY;
                // create_cb((srv_da_wps_session_handle)session, arg);
                srv_da_util_trigger_proc_ext(srv_da_wps_call_create_cb_for_success, session, session->id);
                break;
            case SRV_DA_WPS_CHANNEL_STATE_IN_UNSETTING:
                /* do nothing, when unset_rsp we will check if there are session or not */
                break;

            case SRV_DA_WPS_CHANNEL_STATE_IN_SETTING:
            default:
                MMI_ASSERT(0);
        }
    }
    else /* not inited yet */
    {
        switch(session->channel->busy_flag)
        {
            case SRV_DA_WPS_CHANNEL_STATE_FREE:
                /* session->channel->cust_ch_req = ch_req will be used in this function */
                ///srv_da_wps_send_set_channel_req(session->channel);
if (cust_channel == SRV_DA_WPS_DEFAULT_CHANNEL)
{
				ret = srv_da_open_bearer(arg);
				DA_WPS_TRACE_FUNC1(srv_da_open_bearer, ret);
				if(ret == CBM_WOULDBLOCK)
				{
					//return;
					session->channel->busy_flag = SRV_DA_WPS_CHANNEL_STATE_IN_AUTHENTICATING;

				}
				else if (ret == CBM_OK)
				{
                srv_da_wps_send_set_channel_req(session, session->channel);
				}
				else 
				{
					//return;
				}
}
else
	 srv_da_wps_send_set_channel_req(session, session->channel);
                break;
                
            case SRV_DA_WPS_CHANNEL_STATE_IN_SETTING:
			case SRV_DA_WPS_CHANNEL_STATE_IN_AUTHENTICATING:
                /* already in setting. do nothing */
                break;

            case SRV_DA_WPS_CHANNEL_STATE_IN_UNSETTING:
            default:
                MMI_ASSERT(0);
        }
    }

    return (srv_da_wps_session_handle)session;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_create_session
 * DESCRIPTION
 *  Create a WPS session.
 * PARAMETERS
 *  arg             [IN] To be passed to callback functions.
 *  setting         [IN] Use which parameter set for channel.
 *  create_cb       [IN] Callback to notify the result of session creation.
 *  http_rsp_cb     [IN] HTTP response callback.
 *  http_auth_cb    [IN] HTTP authentication callback.
 *  dl_progress_cb  [IN] To notify download progress.
 * RETURNS
 *  Session ID
 *****************************************************************************/
srv_da_wps_session_handle srv_da_wps_create_session(
    U32 arg,
    srv_da_wps_setting_enum setting,
    srv_da_wps_session_created_funcptr_type create_cb,
    srv_da_wps_http_response_funcptr_type http_rsp_cb,
    srv_da_wps_http_auth_ind_funcptr_type http_auth_cb,
    srv_da_wps_dl_progress_funcptr_type dl_progress_cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return srv_da_wps_create_session_ex(
        arg,
        setting,
        NULL,
        create_cb,
        http_rsp_cb,
        http_auth_cb,
        dl_progress_cb);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_session_set_option
 * DESCRIPTION
 *  Set option of the session.
 * PARAMETERS
 *  session     [IN] Session
 *  option      [IN] Option type
 *  value_p     [IN] Pointer of option value; the value should be put in *value_p
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_session_set_option(
    srv_da_wps_session_handle session,
    srv_da_wps_option_enum option,
    void *value_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_session_struct *s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    s = (srv_da_wps_session_struct*)session;

    switch (option)
    {
        case SRV_DA_WPS_OPTION_UNBUFFERED_WRITE:
            s->unbuffered_write = *(MMI_BOOL*)value_p;
            break;
            
        default:
            break;
    }
}


MMI_BOOL srv_da_wps_http_req(srv_da_wps_session_handle session_id, 
                         U8 method,
                         S8 *url,
                         S8 *header,
                         S8 *post_data,
                         U16 *filepath,
                         U8 reply_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_session_struct   *s;
    srv_da_wps_channel_struct   *ch;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    s = (srv_da_wps_session_struct*)session_id;
    MMI_ASSERT(s);

    ch = s->channel;
    if(!ch->is_set)
        return MMI_FALSE;
    
    if(s->state != SRV_DA_WPS_SESSION_STATE_READY)
        return MMI_FALSE;
    
    if (srv_da_wps_send_http_req(s, method, url, header, post_data, filepath, reply_type))
    {
        MMI_ASSERT(s->state != SRV_DA_WPS_SESSION_STATE_READY);
        return MMI_TRUE;
    }
    
    return MMI_FALSE;
}

MMI_BOOL srv_da_wps_session_auth(srv_da_wps_session_handle session_id, U8 *username, U8 *password)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_session_struct *s;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    s = (srv_da_wps_session_struct*)session_id;
    MMI_ASSERT(s);
    MMI_ASSERT(s->state == SRV_DA_WPS_SESSION_STATE_DOWNLOADING);
    
    return (MMI_BOOL)srv_da_wps_send_http_auth_res(s, username, password);
}

MMI_BOOL srv_da_wps_session_auth_UCS2(srv_da_wps_session_handle session, U16 *username, U16 *password)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8          *usr, *pwd;
    MMI_BOOL    bret;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(username && password);
    usr = (U8 *)srv_da_adp_mem_allocate(mmi_ucs2strlen((S8*)username)+1);
    mmi_ucs2_to_asc((S8*)usr, (S8*)username);
    pwd = (U8 *)srv_da_adp_mem_allocate(mmi_ucs2strlen((S8*)password)+1);
    mmi_ucs2_to_asc((S8*)pwd, (S8*)password);

    bret = srv_da_wps_session_auth(session, usr, pwd);

    OslMfree(usr);
    OslMfree(pwd);
    return bret;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_close_session
 * DESCRIPTION
 *  Close a WPS session. NOTE that the abort_cb may be executed before this
 *  function returns.
 * PARAMETERS
 *  session_id  [IN] Session ID
 *  abort_cb    [IN] Abort callback. May be executed before this function
 *                   returns.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_wps_close_session(srv_da_wps_session_handle session_id,
                              srv_da_wps_session_aborted_funcptr_type abort_cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_session_struct *s;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    s = (srv_da_wps_session_struct*)session_id;

    if (!srv_da_wps_is_session_valid(s))
    {
        return;
    }

    switch (s->state)
    {
        case SRV_DA_WPS_SESSION_STATE_INIT:
        case SRV_DA_WPS_SESSION_STATE_READY:
            
            if (abort_cb != NULL)
            {
                abort_cb(s->arg);
            }

            srv_da_wps_free_session(s);
            
            break;

        default:
            /* still running, abort it */
            s->abort_cb = abort_cb;
            s->state = SRV_DA_WPS_SESSION_STATE_ABORTING;
            srv_da_wps_send_cancel_req(s);
            break;
    }
}


static void srv_da_wps_free_session(srv_da_wps_session_struct *s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_channel_struct* ch;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(s != NULL);
    MMI_ASSERT(s->state == SRV_DA_WPS_SESSION_STATE_INIT ||
        s->state == SRV_DA_WPS_SESSION_STATE_READY);

    MMI_ASSERT(srv_da_wps_context.session_table[s->session_idx] == s);
    srv_da_wps_context.session_table[s->session_idx] = NULL;
    srv_da_wps_context.session_num--;
    
    ch = s->channel;
    ch->ref_count--;
    
    OslMfree(s);

    DA_WPS_TRACE_FUNC3(srv_da_wps_free_session, ch->busy_flag, ch->ref_count, ch->is_reserved);

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if (srv_da_wps_is_cust_channel(ch))
    {
        if (!ch->is_reserved)
        {
            srv_da_wps_release_channel(ch); /* To unset channel */
        }
    }
    else
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */
    {
        /* Check whether to close channels */
        srv_da_wps_notify_active_downloads(srv_da_wps_context.active_download);
    }
}


static MMI_BOOL srv_da_wps_is_channel_ready(srv_da_wps_channel_struct *ch)
{
    if (ch->is_set &&
            ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_FREE)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_send_set_channel_req
* DESCRIPTION
*   send setup channel request
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
//#define STATIC_HEADER "Content-Type: text/plain; charset=UTF-8\r\nUser-Agent: Nokia7260/2.0 (04.91) Profile/MIDP-2.0 Configuration/CLDC-1.1\r\nAccept-Charset: *\r\nAccept-Encoding: gzip, deflate\r\nTE: deflate, gzip\r\nAccept: */*\r\n"
#define STATIC_HEADER "Accept-Charset: *\r\nAccept: */*\r\n"


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_new_request_id_for_channel
 * DESCRIPTION
 *  Returns a request ID to request channel.
 * PARAMETERS
 *  void
 * RETURNS
 *  Request ID.
 *****************************************************************************/
static U32 srv_da_wps_new_request_id_for_channel(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U32 request_id = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (request_id == 0)
    {
        request_id = 1;
    }
    
    return (request_id++);
}


static MMI_BOOL srv_da_wps_send_set_channel_req(srv_da_wps_session_struct  *session, srv_da_wps_channel_struct* channel)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_set_channel_req_struct      *set_channel_req;
    peer_buff_struct                *peer_buff_ptr = NULL;
    wps_set_channel_req_var_struct  set_channel_req_var;
    U16                             len, pdu_length;
    kal_uint8                       ref_count;
    kal_uint16                      msg_len;
    const S8*                       user_agent_string;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(!channel->is_set && channel->busy_flag == SRV_DA_WPS_CHANNEL_STATE_FREE);

    user_agent_string = (const S8*)applib_inet_get_user_agent_string();

    channel->request_id = srv_da_wps_new_request_id_for_channel();
    channel->busy_flag = SRV_DA_WPS_CHANNEL_STATE_IN_SETTING;

    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_SET_CHANNEL_REQ, channel->request_id);
   
    set_channel_req = (wps_set_channel_req_struct *) construct_local_para(sizeof(wps_set_channel_req_struct), TD_CTRL);
    msg_len = set_channel_req->msg_len;
    ref_count = set_channel_req->ref_count;

    channel->get_set_channel_req(session, channel, set_channel_req);
    
    set_channel_req->app_id = srv_da_wps_context.cbm_app_id;
    set_channel_req->req_id = channel->request_id;
    set_channel_req->msg_len = msg_len;
    set_channel_req->ref_count = ref_count;
    set_channel_req_var.static_header_len = len =
        strlen("User-Agent: ")+
        strlen(user_agent_string)+
        strlen("\r\n")+
        strlen(STATIC_HEADER);
    set_channel_req_var.static_header = get_ctrl_buffer((len+1));
    sprintf((S8*)set_channel_req_var.static_header,"User-Agent: %s\r\n%s", user_agent_string, STATIC_HEADER);

    pdu_length= wps_pun_var_part(WPS_PUN_SIZE,MSG_ID_WPS_SET_CHANNEL_REQ,&set_channel_req_var,NULL);

    if( pdu_length > 0)
    {
        peer_buff_ptr = construct_peer_buff(pdu_length, 0, 0, TD_RESET);
        if (wps_pun_var_part(WPS_PUN_PACK, MSG_ID_WPS_SET_CHANNEL_REQ, &set_channel_req_var, get_pdu_ptr(peer_buff_ptr, &len)) !=
            pdu_length)
        {
            free_peer_buff(peer_buff_ptr);
            peer_buff_ptr = NULL;
        }
    }

    free_ctrl_buffer(set_channel_req_var.static_header);

    mmi_frm_set_protocol_event_handler(MSG_ID_WPS_SET_CHANNEL_RSP, (PsIntFuncPtr)srv_da_wps_recv_set_channel_rsp, MMI_TRUE);
    
    srv_da_send_ilm(set_channel_req, peer_buff_ptr, MSG_ID_WPS_SET_CHANNEL_REQ, MOD_WPS);

    
    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_recv_set_channel_rsp
* DESCRIPTION
*   Handler function to handle set channel response, save channel_id to context
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_recv_set_channel_rsp(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_set_channel_rsp_struct *p = (wps_set_channel_rsp_struct *) MsgStruct;
    S32 i;
    srv_da_wps_channel_struct   *ch;
	//kal_int8 ret = CBM_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_SET_CHANNEL_RSP, p->req_id, p->channel_id);

    ch = NULL;
    if (srv_da_wps_context.dl_channel.request_id == p->req_id)
    {
        ch = &(srv_da_wps_context.dl_channel);
    }
    else if (srv_da_wps_context.post_channel.request_id == p->req_id)
    {
        ch = &(srv_da_wps_context.post_channel);
    }
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    else
    {
        for (i = 0; i < SRV_DA_WPS_MAX_CUST_SESSION; i++)
        {
            if (srv_da_wps_context.cust_ch[i].request_id == p->req_id)
            {
                ch = &(srv_da_wps_context.cust_ch[i]);
                break;
            }
        }
    }
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */

    if (ch == NULL)
    {
        return MMI_FALSE;
    }
    
    ch->request_id = 0;

    MMI_ASSERT(ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_IN_SETTING);
    MMI_ASSERT(!ch->is_set);

    if (p->result == WPS_OK)
    {
        ch->channel_id = p->channel_id;
        ch->is_set = MMI_TRUE;
    }
    
    ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_FREE;


    /* if there is pending action */
    if (ch->is_set) /* Channel was set successfully */
    {
        if(ch->ref_count == 0)
        {
            srv_da_wps_send_unset_channel_req(ch);
        }
        else
        {
            for(i=0;i<SRV_DA_WPS_MAX_SESSION;i++)
            {
                if(srv_da_wps_context.session_table[i] &&
                    srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
                    srv_da_wps_context.session_table[i]->channel == ch)
                {
                    srv_da_wps_context.session_table[i]->state = SRV_DA_WPS_SESSION_STATE_READY;
                    srv_da_wps_context.session_table[i]->create_cb(MMI_TRUE, srv_da_wps_context.session_table[i]->arg);
                }
            }
        }
    }
    else
    {
        for (i = 0; i < SRV_DA_WPS_MAX_SESSION; i++)
        {
            if(srv_da_wps_context.session_table[i] &&
                srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
                srv_da_wps_context.session_table[i]->channel == ch)
            {
                srv_da_wps_context.session_table[i]->create_cb(MMI_FALSE, srv_da_wps_context.session_table[i]->arg);
                /*
                 * srv_da_wps_context.session_table[i] will be freed when client call
                 * srv_da_wps_close_session(). So not necessary to free it here.
                 */
            }
        }
    }

    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_send_unset_channel_req
* DESCRIPTION
*   Send "Unset channel" request to wap to destory channel
* PARAMETERS
*   void
* RETURNS
*   MMI_TRUE: OK
*   MMI_FALSE: FAIL
*****************************************************************************/
static MMI_BOOL srv_da_wps_send_unset_channel_req(srv_da_wps_channel_struct* ch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_unset_channel_req_struct *unset_channel_req = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(ch->is_set);

    if(ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_FREE)
    {
        DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_UNSET_CHANNEL_REQ, ch->channel_id);
    
        unset_channel_req =
            (wps_unset_channel_req_struct *) construct_local_para(sizeof(wps_unset_channel_req_struct), TD_CTRL);
        unset_channel_req->channel_id = ch->channel_id;
        srv_da_send_ilm(unset_channel_req, NULL, MSG_ID_WPS_UNSET_CHANNEL_REQ, MOD_WPS);

        mmi_frm_set_protocol_event_handler(MSG_ID_WPS_UNSET_CHANNEL_RSP, (PsIntFuncPtr)srv_da_wps_recv_unset_channel_rsp, MMI_TRUE);

        ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_IN_UNSETTING;
   #ifdef MMI_DA_WLAN_PREFER_SUPPORT
        ch->curr_account_id = 0;
    #endif
        
        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_recv_unset_channel_rsp
* DESCRIPTION
*   Handler function: To handle "unset channel response", reset the channel_id
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_recv_unset_channel_rsp(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_channel_struct       *ch;
    wps_unset_channel_rsp_struct    *p = (wps_unset_channel_rsp_struct *) MsgStruct;
    S32 i;
//#ifdef MMI_DA_WLAN_PREFER_SUPPORT
	kal_int8 ret = 0;
//#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_UNSET_CHANNEL_RSP, p->channel_id, p->result);

    ch = srv_da_wps_get_channel_by_channel_id(p->channel_id);

    if (ch == NULL)
    {
        return MMI_FALSE; /* Ignore */
    }
    
    MMI_ASSERT(ch->busy_flag == SRV_DA_WPS_CHANNEL_STATE_IN_UNSETTING);

    if (p->result == WPS_OK)
    {
        ch->is_set = MMI_FALSE;
        ch->channel_id = 0;
        ch->request_id = 0;
    }
    
    ch->busy_flag = SRV_DA_WPS_CHANNEL_STATE_FREE;

    if(ch->ref_count > 0)
    {
        if(ch->is_set)
        {
            /* unset channel failed, channel still VALID, call back */
            for(i=0;i<SRV_DA_WPS_MAX_SESSION;i++)
            {
                if(srv_da_wps_context.session_table[i] &&
                    srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
                    srv_da_wps_context.session_table[i]->channel == ch)
                {
                    srv_da_wps_context.session_table[i]->state = SRV_DA_WPS_SESSION_STATE_READY;
                    srv_da_wps_context.session_table[i]->create_cb(MMI_TRUE, srv_da_wps_context.session_table[i]->arg);
                }
            }
        }
        else
        {
            /* set channel again */
						
			srv_da_wps_session_struct *session = NULL;
					for(i=0;i<SRV_DA_WPS_MAX_SESSION;i++)
					{
						if(srv_da_wps_context.session_table[i] &&
							srv_da_wps_context.session_table[i]->state == SRV_DA_WPS_SESSION_STATE_INIT &&
							srv_da_wps_context.session_table[i]->channel == ch)
						{
					session = srv_da_wps_context.session_table[i];
						}
					}

			MMI_ASSERT (session);
//#ifdef MMI_DA_WLAN_PREFER_SUPPORT

						
			ret = srv_da_open_bearer(session->arg);
			DA_WPS_TRACE_FUNC1(srv_da_open_bearer, ret);
			if(ret == CBM_WOULDBLOCK)
			{
				//return;
				session->channel->busy_flag = SRV_DA_WPS_CHANNEL_STATE_IN_AUTHENTICATING;                  
				}
				else if (ret == CBM_OK)
				{
				srv_da_wps_send_set_channel_req(session, ch);
				}
			else 
				{
					//return;
				}
//#else
           // srv_da_wps_send_set_channel_req(session, ch);
//#endif
        }
    }

    return MMI_TRUE;
}


static MMI_BOOL srv_da_wps_send_http_req(
    srv_da_wps_session_struct *session,
    U8 http_method,
    S8 *url,
    S8 *header,
    S8 *post_data,
    PU16 file_path,
	U8 reply_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_channel_struct *ch;
    wps_http_req_struct     *http_req;
	wps_http_req_var_struct http_req_var = {0};
    peer_buff_struct        *peer_buff_ptr = NULL;
    U16                     pdu_length;
    U16                     len;
    S8                      *header_buffer;
    S8                      *header_buffer_tail;
    U32                     filesize;
    S8                      temp[2];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    ch = session->channel;
    MMI_ASSERT(srv_da_wps_is_channel_ready(ch));

    srv_da_wps_assign_new_request_id(session);

    http_req = (wps_http_req_struct *) construct_local_para(sizeof(wps_http_req_struct), TD_CTRL);
    http_req->channel_id = ch->channel_id;
    http_req->request_id = srv_da_wps_get_request_id(session);
    http_req->method = http_method;
    http_req->option = 0; /* MAUI_02625437, do not use WPS_HTTP_OPTION_NO_CACHE */

    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_HTTP_REQ, http_req->channel_id, http_req->request_id);

    header_buffer = (S8 *)srv_da_adp_mem_allocate(240);
    
    if (header != NULL)
    {
        strcpy(header_buffer, header);
    }
    else
    {
        header_buffer[0] = '\0';
    }
    header_buffer_tail = header_buffer + strlen(header_buffer);

    /* Let header end with "\r\n" if it is not empty */
    if (header_buffer_tail != header_buffer &&
        (header_buffer_tail - header_buffer > 2))
    {
        if (strcmp(header_buffer_tail - 2, "\r\n") != 0)
        {
            strcpy(header_buffer_tail, "\r\n");
            header_buffer_tail += strlen(header_buffer_tail);
        }
    }

	memset (&http_req_var, 0, sizeof (wps_http_req_var_struct));

    http_req_var.request_url_len = (kal_uint32) strlen(url);
    http_req_var.request_url = (kal_uint8 *) url;
    http_req_var.request_header_len = 0;
    http_req_var.request_header = NULL;

    if (http_method == WPS_HTTP_METHOD_POST)
    {
        MMI_ASSERT(post_data != NULL);
        http_req->reply_type = WPS_DATA_TYPE_BUFFER;
        http_req->reply_segment_len = 0;        /* no use here */
        http_req->post_type = WPS_DATA_TYPE_BUFFER;
        http_req->post_path[0] = '\0';
        http_req->post_path[1] = '\0';
        http_req->post_total_len = strlen(post_data);
        http_req->more_post = MMI_FALSE;
        http_req_var.post_segment_len = strlen(post_data);
        http_req_var.post_segment = (kal_uint8 *) post_data;

        strcpy(header_buffer_tail, "Content-Type: text/plain; charset=UTF-8\r\n");
        header_buffer_tail += strlen(header_buffer_tail);

        session->state = SRV_DA_WPS_SESSION_STATE_POSTING;
    }
    else if (http_method == WPS_HTTP_METHOD_GET)
    {
        wps_clear_req_struct *clear_cache_req;
        wps_clear_req_var_struct clear_cache_var;
    
        MMI_ASSERT(file_path != NULL && mmi_ucs2strlen((S8 *) file_path) < 256);
        http_req->reply_type = reply_type;
        mmi_ucs2cpy((S8 *) http_req->reply_path, (S8 *) file_path);
        http_req->reply_segment_len = 0;        /* no use here */
        http_req->post_type = WPS_DATA_TYPE_BUFFER;
        http_req->post_path[0] = '\0';
        http_req->post_path[1] = '\0';
        http_req->post_total_len = 0;
        http_req->more_post = MMI_FALSE;
        http_req_var.post_segment_len = 0;
        http_req_var.post_segment = NULL;

        /*
         * This flag indicates applying larger pipe to download, to improve the download speed
         * while using high-speed bearer. Otherwise, the processor resource can not afford the
         * speed requirement because of significant context-switching overhead on Obigo solution.
         */
        http_req->option |= WPS_HTTP_OPTION_USE_LARGE_PIPE;
        
        if (session->unbuffered_write)
        {
            http_req->option |= WPS_HTTP_OPTION_FS_COMMIT;
        }

		if (srv_da_get_current_job_type(session->arg) == SRV_DA_JOB_TYPE_YT_DOWNLOAD || srv_da_get_current_job_type(session->arg) == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
		{
            http_req->option |= WPS_HTTP_OPTION_USE_PGDL_DOWNLOAD;
        }

        if (srv_da_util_extract_from_header(header_buffer, "Range", temp, sizeof(temp)) == NULL)
        {
            /* No Range header */
            filesize = srv_da_util_get_file_size(file_path);
            
            if (filesize > 0)
            {
                sprintf(header_buffer_tail, "Range: bytes=%u-\r\n", filesize);
                header_buffer_tail += strlen(header_buffer_tail);
                http_req->reply_type = WPS_DATA_TYPE_FILE_RESUME;
            }
        }
        else
        {
            http_req->reply_type = WPS_DATA_TYPE_FILE_RESUME;
        }
        
        session->state = SRV_DA_WPS_SESSION_STATE_DOWNLOADING;

        /*
         * Clear cache before we send request for an OMA download object.
         * This will force to trigger authentication step first, to avoid
         * fails to be authorized while sending report. (Because we might
         * only get the object from phone, not really request the server
         * and not authorized.
         */
        clear_cache_var.cache_url = (kal_uint8*)url;
        clear_cache_var.cache_url_len = strlen(url);
        pdu_length = wps_pun_var_part(WPS_PUN_SIZE, MSG_ID_WPS_CLEAR_REQ, &clear_cache_var, NULL);
        MMI_EXT_ASSERT(pdu_length > 0, pdu_length, 0, 0);
        peer_buff_ptr = construct_peer_buff(pdu_length, 0, 0, TD_RESET);
        if (wps_pun_var_part(
                WPS_PUN_PACK,
                MSG_ID_WPS_CLEAR_REQ,
                &clear_cache_var,
                get_pdu_ptr(peer_buff_ptr, &len)) > pdu_length)
        {
            MMI_ASSERT(0);
        }

        clear_cache_req = (wps_clear_req_struct*)
            OslConstructDataPtr(sizeof(wps_clear_req_struct));
        clear_cache_req->channel_id = http_req->channel_id;
        clear_cache_req->request_id = http_req->request_id;
        clear_cache_req->operation = WPS_CLEAR_CACHE_URL_MATCH;

        srv_da_send_ilm(clear_cache_req, peer_buff_ptr, MSG_ID_WPS_CLEAR_REQ, MOD_WPS);
        /*
         * [MAUI_02631261]
         * Temp solution: 
         * Clear the protocol event handler of browser, so that browser will
         * not mis-processed the response to DLAgent.
         */
        mmi_frm_clear_protocol_event_handler(MSG_ID_WPS_CLEAR_RSP, NULL);
    }
    else
    {
        MMI_EXT_ASSERT(MMI_FALSE, http_method, 0, 0);
    }

    if (header_buffer_tail - header_buffer > 0)
    {
        http_req_var.request_header_len = header_buffer_tail - header_buffer;
        http_req_var.request_header = (kal_uint8*)header_buffer;
    }

    pdu_length = wps_pun_var_part(WPS_PUN_SIZE, MSG_ID_WPS_HTTP_REQ, &http_req_var, NULL);
    MMI_EXT_ASSERT(pdu_length > 0, pdu_length, 0, 0);
    peer_buff_ptr = construct_peer_buff(pdu_length, 0, 0, TD_RESET);
    if (wps_pun_var_part(
            WPS_PUN_PACK,
            MSG_ID_WPS_HTTP_REQ,
            &http_req_var, 
            get_pdu_ptr(peer_buff_ptr, &len)) > pdu_length)
    {
        MMI_ASSERT(0);
    }

    mmi_frm_set_protocol_event_handler(MSG_ID_WPS_HTTP_RSP, (PsIntFuncPtr)srv_da_wps_recv_http_rsp, MMI_TRUE);
    mmi_frm_set_protocol_event_handler(MSG_ID_WPS_DL_PROGRESS_IND, (PsIntFuncPtr)srv_da_wps_recv_dl_progress_ind, MMI_TRUE);
    mmi_frm_set_protocol_event_handler(MSG_ID_WPS_HTTP_AUTH_IND, (PsIntFuncPtr)srv_da_wps_recv_http_auth_ind, MMI_TRUE);

    srv_da_send_ilm(http_req, peer_buff_ptr, MSG_ID_WPS_HTTP_REQ, MOD_WPS);

    OslMfree(header_buffer);

    return MMI_TRUE;
}

/*****************************************************************************
* FUNCTION
*   srv_da_wps_recv_http_rsp
* DESCRIPTION
*   Handler function: To handle "http response". We will save content_type at oma_content
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_recv_http_rsp(void *MsgStruct, S32 mod_src, void *ilm_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_http_rsp_struct *p = (wps_http_rsp_struct *) MsgStruct;
    srv_da_wps_session_struct  *session;
    ilm_struct          *ilm_ptr;
    wps_http_rsp_var_struct http_rsp_var;
    S8                  *header;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    session = srv_da_wps_get_session_by_http_req_id(p->request_id);

    if (session == NULL)
    {
        return MMI_FALSE;
    }

    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_HTTP_RSP, session->channel->channel_id, p->request_id, p->status);
    
    ilm_ptr = (ilm_struct*)ilm_p;
    header = "";

    switch(session->state)
    {
    case SRV_DA_WPS_SESSION_STATE_ABORTING:
        // We are aborting / waiting cancel rsp, do nothing
        break;

    case SRV_DA_WPS_SESSION_STATE_POSTING:
    case SRV_DA_WPS_SESSION_STATE_DOWNLOADING:

        if(p->result != WPS_OK)
        {
            session->state = SRV_DA_WPS_SESSION_STATE_READY;
        }
        else
        {
            if (ilm_ptr->peer_buff_ptr != NULL)
            {
                U16 len;
                
                if (wps_pun_var_part(
                    WPS_PUN_UNPACK,
                    ilm_ptr->msg_id,
                    &http_rsp_var,
                    get_pdu_ptr(ilm_ptr->peer_buff_ptr, &len)) > 0)
                {
                    header = (S8*)http_rsp_var.reply_header;
                }
            }

            if (session->state == SRV_DA_WPS_SESSION_STATE_POSTING)
            {
                session->state = SRV_DA_WPS_SESSION_STATE_READY;
            }
        }
        

        session->http_rsp_cb(
            session->arg,
            p->result,
            p->status,
            header,
            (S8*)p->content_type,
            p->content_length,
            p);
        
        break;

    default:
        MMI_ASSERT(0);
        break;
    }

    return MMI_TRUE;
}

/*****************************************************************************
* FUNCTION
*   srv_da_wps_send_cancel_req
* DESCRIPTION
*   Send "cancel request" to WAP task to cancel an action.
* PARAMETERS
*   request_id  IN  action, reference to mmi_da_oma_request_id_enum
* RETURNS
*   MMI_TRUE:  OK
*   MMI_FALSE:  false
*****************************************************************************/
static MMI_BOOL srv_da_wps_send_cancel_req(srv_da_wps_session_struct *session)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_cancel_req_struct   *cancel_req;
    srv_da_wps_channel_struct   *ch;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ch = session->channel;

    MMI_ASSERT(srv_da_wps_is_channel_ready(ch));

    cancel_req = (wps_cancel_req_struct *) construct_local_para(sizeof(wps_cancel_req_struct), TD_CTRL);
    cancel_req->request_id = srv_da_wps_get_request_id(session);
    cancel_req->channel_id = ch->channel_id;

    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_CANCEL_REQ, cancel_req->channel_id, cancel_req->channel_id);
    
    srv_da_send_ilm(cancel_req, NULL, MSG_ID_WPS_CANCEL_REQ, MOD_WPS);

    mmi_frm_set_protocol_event_handler(MSG_ID_WPS_CANCEL_RSP, (PsIntFuncPtr)srv_da_wps_recv_cancel_rsp, MMI_TRUE);

    return MMI_TRUE;
}

/*****************************************************************************
* FUNCTION
*   srv_da_wps_recv_cancel_rsp
* DESCRIPTION
*   Handler function: To handle "cancel response".
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_recv_cancel_rsp(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_cancel_rsp_struct   *p = (wps_cancel_rsp_struct *) MsgStruct;
    srv_da_wps_session_struct      *session;
	srv_da_wps_session_aborted_funcptr_type abort_cb = NULL;
	U32 arg;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    session = srv_da_wps_get_session_by_http_req_id(p->request_id);

    if (session == NULL)
    {
        return MMI_FALSE;
    }

    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_CANCEL_RSP, session->channel->channel_id, p->request_id, p->result);

    MMI_ASSERT(session->state == SRV_DA_WPS_SESSION_STATE_ABORTING);

    session->state = SRV_DA_WPS_SESSION_STATE_READY;

    abort_cb = session->abort_cb;
	arg = session->arg;

    
    srv_da_wps_free_session(session);

	
	 if(abort_cb)
    {
        abort_cb(arg);
    }

    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_recv_dl_progress_ind
* DESCRIPTION
*   Handler function: To handle "progress indication". We will save status,
    sequence number, and total size to oma_context
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_recv_dl_progress_ind(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_dl_progress_ind_struct *p = (wps_dl_progress_ind_struct *) MsgStruct;
    srv_da_wps_session_struct  *s;
	srv_da_job_struct *job;
	//srv_da_normal_dl_job_struct *job_data;
	//FS_HANDLE fh;
	//U32 nBytes = 0;
	//U32 length = 0;
	U32 job_type;
	U32 curr_size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_DL_PROGRESS_IND, p->request_id, p->seq_num, p->acc_size);

    s = srv_da_wps_get_session_by_http_req_id(p->request_id);

	if (s == NULL)
    {
        return MMI_FALSE;
    }

    switch(s->state)
    {
        case SRV_DA_WPS_SESSION_STATE_ABORTING:
            return MMI_TRUE;

        case SRV_DA_WPS_SESSION_STATE_DOWNLOADING:
            break;

        default:
            MMI_ASSERT(0);
            break;
    }

	job_type = srv_da_get_current_job_type(s->arg);
	curr_size = srv_da_get_current_job_data_size(s->arg);
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
    if (p->acc_size == 0)
	s->time_stamp1 = srv_da_get_current_time();
DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_DL_PROGRESS_IND, p->request_id, p->seq_num, curr_size);	
	if (p->acc_size)
        {
                s->acc_size = s->acc_size + (p->acc_size - curr_size);
		s->time_stamp2 = srv_da_get_current_time();
         }
DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_RECV_DL_PROGRESS_IND, s->acc_size, s->time_stamp1, s->time_stamp2);
#endif
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
	if (job_type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD &&  srv_da_get_current_job_need_sent(s->arg) == MMI_FALSE)
	{
		/*wait for user confirmation. send the response on its confirmation */
		srv_da_save_session_info(s->arg, s, p->seq_num, p->status);
		srv_da_set_current_job_need_sent(s->arg, MMI_TRUE);
		srv_da_set_http_flag(s->arg, MMI_TRUE);
		

	}

	else if ((job_type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD || job_type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)  &&  srv_da_get_current_job_need_sent(s->arg) == MMI_TRUE && srv_da_get_http_flag(s->arg))
	{
		if (p->acc_size)
		{
				//S8 *buffer = OslMalloc(2048);
			//if (p->acc_size > 255)
			//length = 255;
		srv_da_set_http_flag(s->arg, MMI_FALSE);
	
		job = srv_da_get_current_job(s->arg);
		//job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
		//fh = FS_Open((U16*)job_data->filepath, FS_OPEN_SHARED);
		
		
		//FS_Read(fh, buffer, length, &nBytes);
		srv_da_set_job_data_length(job, p->dl_buff_len);
		srv_da_set_job_content(job, (S8 *)p->dl_buff);
		
		srv_da_http_dl_inform_app(job);
		//memcpy(p->dl_buff, "Vineet", 20);
			//FS_Close(fh);
				//OslMfree(buffer);
			}
	
		srv_da_wps_send_dl_progress_res(s, p->seq_num, (wps_dl_status_enum)p->status, NULL, p->dl_buff_len, p->dl_buff);

			
	}

	else
#endif

	{
		srv_da_wps_send_dl_progress_res(s, p->seq_num, (wps_dl_status_enum)p->status, NULL, 0, NULL);
	}
    switch(p->status)
    {
        case WPS_DL_STATUS_ABORT:
        case WPS_DL_STATUS_COMPLETE:
            s->state = SRV_DA_WPS_SESSION_STATE_READY;
			if (s->dl_progress_cb != NULL)
			{
				s->dl_progress_cb(s->arg, p->status, p->acc_size, p->cause);
			}

            break;
            
        case WPS_DL_STATUS_DOWNLOADING:
			{
			    if (s->dl_progress_cb != NULL && p->acc_size > 0)
				{
					s->dl_progress_cb(s->arg, p->status, p->acc_size, p->cause);
				}
			}
            break;

        default:
            MMI_ASSERT(0);
            break;
    }

    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_send_dl_progress_res
* DESCRIPTION
*   Send "progress rsp" to WAP task
* PARAMETERS
*   request_id  IN  action, reference to mmi_da_oma_request_id_enum
* RETURNS
*   MMI_TRUE:  OK
*   MMI_FALSE:  false
*****************************************************************************/
MMI_BOOL srv_da_wps_send_dl_progress_res(srv_da_wps_session_struct *session, S32 seq_num, wps_dl_status_enum status, kal_wchar *filepath, kal_uint32 dl_buff_len, kal_uint8 *dl_buff)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_dl_progress_res_struct  *progress_res;
    srv_da_wps_channel_struct   *ch;
	U32 avg_bit_rate = 0;
	U32 timer = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ch = session->channel;
    MMI_ASSERT(ch);

    progress_res = (wps_dl_progress_res_struct *) construct_local_para(sizeof(wps_dl_progress_res_struct), TD_CTRL);
    progress_res->request_id = srv_da_wps_get_request_id(session);
    progress_res->channel_id = ch->channel_id;
    progress_res->seq_num = seq_num;
	//progress_res->reply_path = filepath;
	mmi_ucs2cpy((CHAR *)(progress_res->reply_path), (CHAR *)filepath);
	progress_res->dl_buff_len = dl_buff_len;
	//progress_res->dl_buff = dl_buff;
    if (dl_buff_len > WPS_DEFAULT_DL_BUFF_LEN) // Need to check.
        dl_buff_len = WPS_DEFAULT_DL_BUFF_LEN;

	memcpy((kal_uint8 *)(progress_res->dl_buff), (kal_uint8 *)dl_buff, dl_buff_len);
    DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, progress_res->request_id, progress_res->seq_num);
	if (srv_da_job_is_pgdl(session->arg))
	{
		DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 100, session->acc_size);
    
		if (session->acc_size)
		{
                        DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 101, session->acc_size);
			avg_bit_rate = (session->acc_size*1000)/((session->time_stamp2-session->time_stamp1)*128);
			DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 102, avg_bit_rate);
			        if (avg_bit_rate > 250)
			        {
				DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 103, status);
				        if (status == WPS_DL_STATUS_DOWNLOADING)
				        {
					DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 104, timer);
					        timer = (session->acc_size/32) - (session->time_stamp2 - session->time_stamp1); 
					DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 105, timer);
					/* in Slow mode, we start a timer to send response to WPS */
                            StartTimerEx(
					        (U16)(SRV_DA_WPS_TIMER_0 + session->session_idx),
					        timer,
					        srv_da_wps_delay_dl_progress_res,
					        progress_res);
				        }
			        }
			        else
			        {
				DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 106, avg_bit_rate);
				        srv_da_send_ilm(progress_res, NULL, MSG_ID_WPS_DL_PROGRESS_RES, MOD_WPS);

			        }
            }
            else
            {
			DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 107, session->acc_size);
			srv_da_send_ilm(progress_res, NULL, MSG_ID_WPS_DL_PROGRESS_RES, MOD_WPS);

		}
	}
	else
	{
		DA_WPS_TRACE(MMI_DA_WPS_TRACE_GROUP, MMI_DA_WPS_SEND_DL_PROGRESS_RES, 108, session->acc_size);
#if defined(SRV_DA_WPS_SLOW_BG_DL_SUPPORT)
    if (status == WPS_DL_STATUS_DOWNLOADING)
    {
        /* in Slow mode, we start a timer to send response to WPS */
        StartTimerEx(
            (U16)(SRV_DA_WPS_TIMER_0 + session->session_idx),
            10,
            srv_da_wps_delay_dl_progress_res,
            progress_res);
    }
    else
#endif
    {
        srv_da_send_ilm(progress_res, NULL, MSG_ID_WPS_DL_PROGRESS_RES, MOD_WPS);
    }
    
	}

	

    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_recv_http_auth_ind
* DESCRIPTION
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_recv_http_auth_ind(void *MsgStruct)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_http_auth_ind_struct    *p;
    srv_da_wps_session_struct   *session;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    p = (wps_http_auth_ind_struct*) MsgStruct;

    session = srv_da_wps_get_session_by_http_req_id(p->request_id);

    if (session == NULL)
    {
        return MMI_FALSE;
    }
    
    MMI_ASSERT(p->channel_id == session->channel->channel_id);

    switch(session->state)
    {
    case SRV_DA_WPS_SESSION_STATE_DOWNLOADING:
    case SRV_DA_WPS_SESSION_STATE_POSTING:
        session->http_auth_cb(session->arg);
        break;

    case SRV_DA_WPS_SESSION_STATE_ABORTING:
        break;

    default:
        MMI_ASSERT(0);
        break;
    }

    return MMI_TRUE;
}


/*****************************************************************************
* FUNCTION
*   srv_da_wps_send_http_auth_res
* DESCRIPTION
* PARAMETERS
*   Message
* RETURNS
*   void
*****************************************************************************/
static MMI_BOOL srv_da_wps_send_http_auth_res(srv_da_wps_session_struct *session, U8 *username, U8 *password)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_http_auth_res_struct    *p;
    srv_da_wps_channel_struct   *ch;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ch = session->channel;
    MMI_ASSERT(ch);

    p = (wps_http_auth_res_struct *) construct_local_para(sizeof(wps_http_auth_res_struct), TD_CTRL);

    p->channel_id = ch->channel_id;
    p->request_id = srv_da_wps_get_request_id(session);
    strcpy((S8*)p->username, (S8*)username);
    strcpy((S8*)p->password, (S8*)password);

    srv_da_send_ilm(p, NULL, MSG_ID_WPS_HTTP_AUTH_RES, MOD_WPS);
    return MMI_TRUE;

}


//#if defined(SRV_DA_WPS_SLOW_BG_DL_SUPPORT)

/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_delay_dl_progress_res
 * DESCRIPTION
 *  Send DL_PROGRESS_RES for corresponding DL_PROGRESS_IND.
 * PARAMETERS
 *  arg     [IN] wps_dl_progress_res_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_wps_delay_dl_progress_res(void* arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wps_dl_progress_res_struct *progress_res;
    srv_da_wps_session_struct  *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    progress_res = (wps_dl_progress_res_struct*)arg;

    session = srv_da_wps_get_session_by_http_req_id(progress_res->request_id);
    
    if (srv_da_wps_is_session_valid(session) &&
        session->state == SRV_DA_WPS_SESSION_STATE_DOWNLOADING)
    {
        srv_da_send_ilm(progress_res, NULL, MSG_ID_WPS_DL_PROGRESS_RES, MOD_WPS);
    }
    else
    {
        OslFreeDataPtr(progress_res);
    }
}

//#endif /* SRV_DA_WPS_SLOW_BG_DL_SUPPORT */


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_map_error_code
 * DESCRIPTION
 *  Map WPS error code to srv_da_error_enum
 * PARAMETERS
 *  wps_error_code  [IN] WPS error code
 * RETURNS
 *  srv_da_error_enum
 *****************************************************************************/
srv_da_error_enum srv_da_wps_map_error_code(S32 wps_error_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_error_enum error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    error = SRV_DA_ERROR_OTHERS;

    switch (wps_error_code)
    {
        case WPS_OK:
            error = SRV_DA_SUCCESS;
            break;
    
        case WPS_ERROR_FILE_ACCESS:
            error = SRV_DA_ERROR_FILE_ACCESS;
            break;

        case WPS_ERROR_REQ_ABORT:
            error = SRV_DA_ERROR_CONNECTION_CLOSED;
            break;

        default:
            if (wps_error_code == FS_DISK_FULL)
            {
                error = SRV_DA_ERROR_DISK_FULL;
            }
            else if (wps_error_code < 0)
            {
                error = SRV_DA_ERROR_FILE_ACCESS;
            }
            else
            {
                error = SRV_DA_ERROR_OTHERS;
            }
            break;
    }

    return error;
}

#endif /* __HTTP_INTERFACE__ */


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_is_bearer_activated
 * DESCRIPTION
 *  Check whether the bearer is activated.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if activated.
 *****************************************************************************/
MMI_BOOL srv_da_wps_is_bearer_activated(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef BROWSER_SUPPORT
    MMI_BOOL activated;
    srv_brw_profile_content_struct *profile;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    activated = MMI_FALSE;

    profile = srv_da_wps_get_wap_profile(arg);

    if (profile != NULL)
    {
        kal_uint32 da_account_id;
#ifdef MMI_DA_WLAN_PREFER_SUPPORT       
        da_account_id = profile->data_account_primary_id;
#else
        
        da_account_id = cbm_set_app_id(profile->data_account_primary_id,
                srv_da_wps_context.cbm_app_id);
#endif
        if(cbm_get_bearer_status(da_account_id) == CBM_ACTIVATED)
            activated = MMI_TRUE;
        else
            activated = MMI_FALSE;
    
        OslMfree(profile);
    }

    return activated;
    
#else

    return MMI_FALSE;

#endif
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_estimate_time_to_download_by_bearer_type
 * DESCRIPTION
 *  Estimate the time to download a file by given bearer
 * PARAMETERS
 *  bearer_type [IN] Bearer type
 *  filesize    [IN] File size
 * RETURNS
 *  Time in seconds; may be MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN
 *****************************************************************************/
static U32 srv_da_wps_estimate_time_to_download_by_bearer_type(
    cbm_bearer_enum bearer_type,
    U32 filesize)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 bytes_per_sec;
    U32 time_in_sec;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    bytes_per_sec = 0;
    
    switch (bearer_type)
    {
        case CBM_CSD:
        case CBM_GPRS:
            bytes_per_sec = 5 * 1024; /* 5kb / sec */
            break;
            
        case CBM_EDGE:
            bytes_per_sec = 12 * 1024; /* 12kb / sec */
            break;

        case CBM_UMTS:
            bytes_per_sec = 40 * 1024; /* 40kb / sec */
            break;
            
        case CBM_WIFI:
            bytes_per_sec = 116 * 1024; /* 116kb / sec */
            break;
            
        default:
            bytes_per_sec = 0; /* Unknown */
            break;
    }

    time_in_sec = ((bytes_per_sec > 0) ? (filesize / bytes_per_sec + 1) : MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN);

    return time_in_sec;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_estimate_time_to_download
 * DESCRIPTION
 *  Estimate the time to download a file by current bearer
 * PARAMETERS
 *  filesize    [IN] File size
 * RETURNS
 *  Time in seconds; may be MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN
 *****************************************************************************/
U32 srv_da_wps_estimate_time_to_download(U32 arg, MMI_BOOL da_account_first, U32 filesize)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    #define MMI_DA_WPS_MAX_ESTIMATE_TIME_ACCOUNT_NUM 2

    cbm_bearer_enum bearer_type;
#ifdef BROWSER_SUPPORT
    srv_brw_profile_content_struct *profile;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    bearer_type = CBM_BEARER_NONE;

#ifdef BROWSER_SUPPORT
    profile = srv_da_wps_get_wap_profile(arg);

    if (profile != NULL)
    {
        kal_int32 bearer_status;
        kal_uint32 da_account_id;
        S32 i;
    
        struct {
            kal_uint32 account_id;
        } priority[MMI_DA_WPS_MAX_ESTIMATE_TIME_ACCOUNT_NUM];

        da_account_id = cbm_set_app_id(profile->data_account_primary_id,
                srv_da_wps_context.cbm_app_id);

        if (da_account_first)
        {
            priority[0].account_id = da_account_id;
            priority[1].account_id = profile->data_account_primary_id;
        }
        else
        {
            priority[0].account_id = profile->data_account_primary_id;
            priority[1].account_id = da_account_id;
        }

        for (i = 0; i < MMI_DA_WPS_MAX_ESTIMATE_TIME_ACCOUNT_NUM; i++)
        {
            bearer_status = cbm_get_bearer_status(priority[i].account_id);

            if (bearer_status == CBM_ACTIVATED || bearer_status == CBM_ACTIVATING)
            {
                if (cbm_get_bearer_type(priority[i].account_id, &bearer_type) != CBM_OK)
                {
                    bearer_type = CBM_BEARER_NONE;
                }
            }

            if (bearer_type != CBM_BEARER_NONE)
            {
                break;
            }
        }

        /* No bearer is activated, determine by data account only. */
        if (bearer_type == CBM_BEARER_NONE)
        {
            if (cbm_get_bearer_type(priority[0].account_id, &bearer_type) != CBM_OK)
            {
                bearer_type = CBM_BEARER_NONE;
            }
        }

        OslMfree(profile);
    }
#endif /* BROWSER_SUPPORT */

    return srv_da_wps_estimate_time_to_download_by_bearer_type(bearer_type, filesize);
}


#ifdef __HTTP_INTERFACE__
/*****************************************************************************
 * FUNCTION
 *  srv_da_wps_estimate_time_to_download_by_channel
 * DESCRIPTION
 *  Estimate the time to download a file by the bearer type of the reserved channel
 * PARAMETERS
 *  cust_channel    [IN] Reserved channel
 *  filesize        [IN] File size
 * RETURNS
 *  Time in seconds; may be MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN
 *****************************************************************************/
U32 srv_da_wps_estimate_time_to_download_by_channel(U32 arg, srv_da_wps_channel_handle cust_channel, U32 filesize)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 time_to_download;
    srv_da_wps_channel_struct *channel;
    cbm_bearer_enum bearer_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    time_to_download = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;
    
    if (cust_channel == SRV_DA_WPS_DEFAULT_CHANNEL)
    {
        time_to_download = srv_da_wps_estimate_time_to_download(arg, MMI_TRUE, filesize);
    }
    else
    {
        channel = (srv_da_wps_channel_struct*)cust_channel;

        if (channel->cust_ch_req != NULL &&
            cbm_get_bearer_type(channel->cust_ch_req->net_id, &bearer_type) == CBM_OK)
        {
            time_to_download = srv_da_wps_estimate_time_to_download_by_bearer_type(bearer_type, filesize);
        }
    }

    return time_to_download;
}


U32 srv_da_wps_get_account_id(void)
{
	return srv_da_wps_context.dl_channel.curr_account_id;
}

U8 srv_da_wps_get_app_id(void)
{
	return srv_da_wps_context.cbm_app_id;
}

extern void srv_da_wps_set_cbm_app_id(void)
{
	srv_da_wps_context.cbm_app_id = srv_da_wps_context.cbm_app_id2;
}

void srv_da_wps_reset_cbm_app_id(U8 app_id)
{
    if(app_id == srv_da_wps_context.cbm_app_id2)
	srv_da_wps_context.cbm_app_id = srv_da_wps_context.cbm_app_id1;
}

void srv_da_wps_set_account_id(U32 net_id)
{
	srv_da_wps_context.acc_id = net_id;
}





#endif /* __HTTP_INTERFACE__ */

#endif /* __MMI_DA_WPS_UTIL__ */

