/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 *   video_types_v2.h
 *
 * Project:
 * --------
 *	MTK
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 *
 ****************************************************************************/
#ifndef VIDEO_TYPES_V2_H
#define VIDEO_TYPES_V2_H

#include "drv_features_video.h"
//#ifdef __VE_VIDEO_ARCHI_V2__

/* The following files are newly added for RHR. */
#include "kal_general_types.h"
#include "video_buffer_management_v2.h"
#include "mpl_omx_core.h"
#include "kal_general_types.h"

typedef enum
{
    VIDEO_COMMAND_STATESET = 0,
    VIDEO_COMMAND_NOTIFY,
    VIDEO_COMMAND_MAX
} VIDEO_COMMAND_TYPE_T;


typedef enum
{
    VIDEO_PORT_NONE,
    VIDEO_PORT_AUDIO_DATA,
    VIDEO_PORT_VIDEO_DATA,
    VIDEO_PORT_SUBTITLE,
    VIDEO_PORT_TIME,
    VIDEO_PORT_MAX
} VIDEO_PORT_TYPE_T;


typedef enum
{
    VIDEO_DEC_MODE_CUSTOMER_SETTING,   //customer setting
    VIDEO_DEC_MODE_BEST_QUALITY,       //standard mode
    VIDEO_DEC_MODE_FAVOR_QUALITY,      //adaptive control decode mode , quality first
    VIDEO_DEC_MODE_FAVOR_FLUENCY,      //adaptive control decode mode , fluency first
    VIDEO_DEC_MODE_BEST_FLUENCY,       //fast mode
    VIDEO_DEC_MODE_INVALID = 0xFF
} VIDEO_DECODE_MODE_T;

typedef enum
{
    VIDEO_PARAM_INPUT_BUFFER_PARAM = 0,
    VIDEO_PARAM_OUTPUT_BUFFER_PARAM,

    VIDEO_PARAM_ERROR_TYPE,

    // file reader parameters
    VIDEO_PARAM_PARSER_HANDLER = 100,
    VIDEO_PARAM_FILE_HANDLER,
    VIDEO_PARAM_TIME_POS,
    VIDEO_PARAM_PREV_I_TIME,
    VIDEO_PARAM_CODEC_TYPE,
    VIDEO_PARAM_CODEC_FRAMERATE,
    VIDEO_PARAM_TRACK_DURATION,
    VIDEO_PARAM_FRAME_WIDTH,
    VIDEO_PARAM_FRAME_HEIGHT,
    VIDEO_PARAM_FRAME_SIZE_STRUCT,

    // decoder parameters
    VIDEO_PARAM_QUERY_RESOLUTION_AHEAD = 200,
    VIDEO_PARAM_QUERY_RESOLUTION,
    VIDEO_PARAM_QUERY_DECODE_TIME,
    VIDEO_PARAM_QUERY_PREDICATION_TIME,
    VIDEO_PARAM_IS_I_FRM_IN_QUEUE,
    VIDEO_PARAM_FLUSH_FRM_BEFORE_I,
    VIDEO_PARAM_FLUSH_FRM,
    VIDEO_PARAM_FRAMERATE,
    VIDEO_PARAM_BITRATE,
    VIDEO_PARAM_ELAPSE_TICKS_BEFORE_SLEEP,
    VIDEO_PARAM_SLEEP_TICKS,
    VIDEO_PARAM_START_BUFFERING,
    VIDEO_PARAM_BUFFERING_DONE,
    VIDEO_PARAM_HEADER_RETRY,
    VIDEO_PARAM_DECRYPTION_MODE,
    VIDEO_PARAM_SET_DECODE_MODE,
    VIDEO_PARAM_GET_DECODE_MODE,
    VIDEO_PARAM_SET_CTRL_VOS,
    VIDEO_PARAM_GET_SBSFLAG,
    VIDEO_PARAM_SET_START_TIME,

    // scheduler parameters
    VIDEO_PARAM_AVSYNC_TOLERANCE0 = 300,
    VIDEO_PARAM_AVSYNC_TOLERANCE1,
    VIDEO_PARAM_AVSYNC_TOLERANCE2,
    VIDEO_PARAM_RECOVER_RESET0,
    VIDEO_PARAM_RECOVER_RESET1,
    VIDEO_PARAM_RECOVER_RESET2,
    VIDEO_PARAM_JUMP_TIMESTAMP,

    //clock parameters
    VIDEO_PARAM_AUDIO_ON = 400,
    VIDEO_PARAM_AUDIO_TYPE,
    VIDEO_PARAM_MEDIA_FORMAT,
    VIDEO_PARAM_AUDIO_SAMPLING_FREQUENCY_INDEX,
    VIDEO_PARAM_PLAY_SPEED,
    VIDEO_PARAM_START_TIME,
    VIDEO_PARAM_STOP_TIME,
    VIDEO_PARAM_CURR_TIME,
    VIDEO_PARAM_CLOCK_ENABLE,
    VIDEO_PARAM_CLOCK_BUF_NUM_RDY,
    VIDEO_PARAM_AV_TIMEBASE,
    VIDEO_PARAM_MAXVIDEO_TIME,
    VIDEO_PARAM_RESET_QUEUE,

    //render parameters
    VIDEO_PARAM_RENDER_MODE = 500,
    VIDEO_PARAM_ENABLE_DISPLAY,
    VIDEO_PARAM_RENDER_SETTING,
    VIDEO_PARAM_RENDER_DISPLY_ADDR, // test code

    //recorder source parameters
    VIDEO_PARAM_RECODER_SOURCE_KEEP_INTERVAL = 600,  // 1 measn all keep, 3 measn 3 keep 1, 4 means 4 keep 1
    VIDEO_PARAM_RECODER_SOURCE_YUV_BUFFER,
    VIDEO_PARAM_RECODER_SOURCE_YUV_INTERVAL,
    VIDEO_PARAM_RECORDER_SOURCE_STOP_INSTANTLY,      // Encoder does not need to return all YUV buffers back to Source at STOP.

    // The Recorder Clock component has become a set of utility functions,
    // and it is not a component any more.

    //recorder encoder parameters
    VIDEO_PARAM_ENCODER_ENCODE_TYPE = 800,
    VIDEO_PARAM_ENCODER_SYNC_INTERVAL,
    VIDEO_PARAM_ENCODER_BITRATE,
    VIDEO_PARAM_ENCODER_MAX_PKG_SIZE,           // set the maximum size of a video packet
    VIDEO_PARAM_ENCODER_ENCODE_I,               // command the encoder to encode the next frame as an I-frame
    VIDEO_PARAM_ENCODER_QUALITY,
    VIDEO_PARAM_ENCODER_FRAME_RATE,             // set/get frame rate
    VIDEO_PARAM_ENCODER_GEN_HEADER_FRM_RATE,
    VIDEO_PARAM_ENCODER_STOP_INSTANTLY,         // Force encoder the next stop should stop instantly (comparing to encode all frames)
    VIDEO_PARAM_ENCODER_ROTATE,                 // set rotate angle
    VIDEO_PARAM_ENCODER_IS_BLOCKBASED_YUV,
    VIDEO_PARAM_ENCODER_COLOR_FORMAT,           // Set color format
    VIDEO_PARAM_ENCODER_LEFTOVER_OF_FIRST_THRESHOLD,     // The size of the first cluster left for bitstream buffer
    VIDEO_PARAM_ENCODER_VT_RESTART,                 // set rotate angle
    VIDEO_PARAM_ENCODER_CHANGE_PRIORITY,
    VIDEO_PARAM_ENCODER_RESTORE_PRIORITY,
    VIDEO_PARAM_ENCODER_SET_UPLINK_CALLBACK,
    VIDEO_PARAM_ENCODER_SETUP_CODEC,
    VIDEO_PARAM_ENCODER_GET_STATE,
    VIDEO_PARAM_ENCODER_LIMIT_FRM_BUFF,
    VIDEO_PARAM_ENCODER_RESOLUTION,
    VIDEO_PARAM_ENCODER_SET_TIME_LIMIT,         // Encoder would not encode the frames later than the time and would notify IL the timeout
    VIDEO_PARAM_ENCODER_SET_TIME_LAPSE_CAPTURE_FRAME_DURATION,
    VIDEO_PARAM_ENCODER_SET_TIME_LAPSE_FRAME_RATE,
    VIDEO_PARAM_ENCODER_GET_TIME_LAPSE_ENCODED_FRAME_COUNT,

    //recorder file writer parameters
    VIDEO_PARAM_FILEWRITER_TMP_META_FILE_HANDLE = 900,
    VIDEO_PARAM_FILEWRITER_META_FILE_HANDLE,
    VIDEO_PARAM_FILEWRITER_VIDEO_FILE_HANDLE,
    VIDEO_PARAM_FILEWRITER_WIDTH,
    VIDEO_PARAM_FILEWRITER_HEIGHT,
    VIDEO_PARAM_FILEWRITER_ENCODE_TYPE,
    VIDEO_PARAM_FILEWRITER_ENCODE_STOP_TIME,
    VIDEO_PARAM_FILEWRITER_FLUSH_VIDEO_FILE,
    VIDEO_PARAM_FILEWRITER_FLUSH_META_FILE,
    VIDEO_PARAM_FILEWRITER_CREATE_FILE,
    VIDEO_PARAM_FILEWRITER_BITSTREAM_FILE_SIZE,
    VIDEO_PARAM_FILEWRITER_TMP_META_FILE_SIZE,
    VIDEO_PARAM_FILEWRITER_EVALUATE_META_FILE_SIZE,
    VIDEO_PARAM_FILEWRITER_MDAT_POS,
    VIDEO_PARAM_FILEWRITER_MOOV_POS,
    VIDEO_PARAM_FILEWRITER_MOOV_SIZE,
    VIDEO_PARAM_FILEWRITER_META_FILE_DURATION,
#if 1 // __AVI_ENC_SUPPORT__
    VIDEO_PARAM_FILEWRITER_FILE_SIZE_LIMIT,
#endif  // __AVI_ENC_SUPPORT__

    // video renderer parameters
    VIDEO_PARAM_RENDERER_BYPASS = 1000,         /**< arg type: kal_bool*, default KAL_FALSE, if KAL_TRUE, Video Renderer does not renderer when in RUN state. */
    VIDEO_PARAM_RENDERER_DST_COLOR_FORMAT,      /**< arg type: VA2_VIDEO_RENDERER_COLOR_FORMAT_T*, color format of destination frame buffer. */
    VIDEO_PARAM_RENDERER_DST_FB_ADDR,           /**< arg type: va2_video_renderer_dst_fb_t*, address(es) to destination frame buffer(s). */
    VIDEO_PARAM_RENDERER_DST_FB_SIZE,           /**< arg type: VA2_FRAME_SIZE_T*, frame size (width x height in pixel) of a destination frame buffer. */
    VIDEO_PARAM_RENDERER_TRIGGER_DISPLAY,       /**< arg type: kal_bool*, if KAL_TRUE, the content of destination frame buffer will be updated to display device. KAL_FALSE, o.w. */
    VIDEO_PARAM_RENDERER_DISABLE_DC_MODE,       /**< arg type: kal_bool*, if KAL_TRUE, disable MT6268 DC mode, KAL_FALSE, o.w.(this param will be used by MT6268 only) */
    VIDEO_PARAM_RENDERER_DISPLAY_SURFACE,       /**< arg type: va2_video_renderer_display_surface_t*, The parameters of a display surface. */
    VIDEO_PARAM_RENDERER_SEMI_AUTO_RENDER_MODE, /**< arg type: VA2_VIDEO_RENDERER_RENDER_MODE_T* */
    VIDEO_PARAM_RENDERER_KEEP_CURR_PTR,         /**< arg type: kal_bool*, if KAL_TRUE, when renderer is transitioned to RUN state from STOP, the last displayed video frame will be rendered again. KAL_FALSE, o.w. */
    VIDEO_PARAM_RENDERER_RENDER_DISPLAY_BUFFER, /**< arg type: kal_uint32*, This is a special function which commands video renderer to render in non-RUN state. */
    VIDEO_PARAM_RENDERER_INTERNAL_MEMORY,       /**< arg type: VA2_MEMORY_BLOCK_T*, internal memory block for Video Renderer to use. @remark HW dependent. @remark MUST be set before transition to IDLE state... */
    VIDEO_PARAM_RENDERER_ROTATE_FLIP,           /**< arg type: va2_video_renderer_rotate_flip_t* */
    VIDEO_PARAM_RENDERER_VIDEO_FRAME_ROTATE_FLIP,/**< arg type: va2_video_renderer_rotate_flip_t* */
    VIDEO_PARAM_RENDERER_3D_MODE,               /**< arg type: VA2_VIDEO_RENDERER_3D_MODE_T* */
    VIDEO_PARAM_RENDERER_SUBTITLE_DST_COLOR_FORMAT,      /**< arg type: VA2_VIDEO_RENDERER_COLOR_FORMAT_T*, color format of destination frame buffer. */
    VIDEO_PARAM_RENDERER_SUBTITLE_DST_FB_ADDR,           /**< arg type: va2_video_renderer_dst_fb_t*, address(es) to destination frame buffer(s). */
    VIDEO_PARAM_RENDERER_SUBTITLE_DST_FB_SIZE,           /**< arg type: VA2_FRAME_SIZE_T*, frame size (width x height in pixel) of a destination frame buffer. */
    VIDEO_PARAM_RENDERER_SUBTITLE_DISPLAY_SURFACE,       /**< arg type: va2_video_renderer_display_surface_t*, The parameters of a display surface. */
    VIDEO_PARAM_RENDERER_PORT_FLUSH,                     /**< arg type: kal_uint32*, if 0, Video Renderer will flush all the buffer header it keep in Video buffer queue. If 1, subtitle buffer queue is cleared. */
    VIDEO_PARAM_RENDERER_SUBTITLE_CURRENT_BUFFER_HEADER, /**< arg type: VIDEO_BUFFERHEADER_TYPE_T*, if 0, Video Renderer will return latest subtitle buffer header. */

    // video renderer configs
    VIDEO_CONFIG_RENDERER_SRC_FB_ADDR = 1100,   /**< arg type: VA2_FRAME_BUFFER_ADDRESS_T* */
    VIDEO_CONFIG_RENDERER_SRC_COLOR_FORMAT,     /**< arg type: VA2_VIDEO_RENDERER_COLOR_FORMAT_T* */
    VIDEO_CONFIG_RENDERER_SRC_SIZE,             /**< arg type: VA2_FRAME_SIZE_T* */
    VIDEO_CONFIG_RENDERER_SRC_CLIP,             /**< arg type: VA2_CLIP_WINDOW_T* */
    VIDEO_CONFIG_RENDERER_RESIZE_DST_SIZE,      /**< arg type: VA2_FRAME_SIZE_T* */
    VIDEO_CONFIG_RENDERER_DST_CLIP,             /**< arg type: VA2_CLIP_WINDOW_T* */
    VIDEO_CONFIG_RENDERER_DST_FB_START_ADDR,    /**< arg type: va2_video_renderer_dst_fb_t* */
    VIDEO_CONFIG_RENDERER_POST_PROCESS,         /**< arg type: va2_video_renderer_post_process_config_t* */
    VIDEO_CONFIG_RENDERER_STATUS,               /**< arg type: VIDEO_STATE_TYPE_T*, cannot be set */
    VIDEO_CONFIG_RENDERER_MP4DEBLK_Q_BUF,       /**< arg type: kal_uint32*, pointer to a kal_uint32, which is the physical addr of a MP4DBLK quantization buffer. */
    VIDEO_CONFIG_RENDERER_SOURCE_FRAME_PERIOD,      /**< arg type: kal_uint32*, in the unit of milisecond(ms) */
    VIDEO_CONFIG_RENDERER_DECODE_TIME,              /**< arg type: kal_uint32*, in the unit of milisecond(ms) */
    VIDEO_CONFIG_RENDERER_BYPASS_HW_LAYER_SRC_RECT, /**< arg type: kal_bool*, if KAL_TRUE, Renderer will bypass source rectangle configuration and restore this param back to KAL_FALSE. KAL_FALSE, o.w. */
    VIDEO_CONFIG_RENDERER_SUBTITLE_SRC_FB_ADDR,   /**< arg type: VA2_FRAME_BUFFER_ADDRESS_T* */
    VIDEO_CONFIG_RENDERER_SUBTITLE_SRC_COLOR_FORMAT,     /**< arg type: VA2_VIDEO_RENDERER_COLOR_FORMAT_T* */
    VIDEO_CONFIG_RENDERER_SUBTITLE_SRC_SIZE,             /**< arg type: VA2_FRAME_SIZE_T* */
    VIDEO_CONFIG_RENDERER_SUBTITLE_RESIZE_DST_SIZE,      /**< arg type: VA2_FRAME_SIZE_T* */

    // source provider parameter
    VIDEO_PARAM_SOURCE_PROVIDER_VID_STREAM_INFO = 1200,
    VIDEO_PARAM_SOURCE_PROVIDER_AUD_STREAM_INFO,
    VIDEO_PARAM_SOURCE_PROVIDER_SUBT_STREAM_INFO,
    VIDEO_PARAM_SOURCE_PROVIDER_METADATA_INFO,
    VIDEO_PARAM_SOURCE_PROVIDER_CAPABILITY,
    VIDEO_PARAM_SOURCE_PROVIDER_KEY_FRAME_TIME,
    VIDEO_PARAM_SOURCE_PROVIDER_TIME_TO_FRAME,
    VIDEO_PARAM_SOURCE_PROVIDER_FRAME_TO_TIME,
    VIDEO_PARAM_SOURCE_PROVIDER_QUERY_FRAME_BUF,
    VIDEO_PARAM_SOURCE_PROVIDER_DRM_FSAL,
    VIDEO_PARAM_SOURCE_PROVIDER_STREAMING_BUF,
    VIDEO_PARAM_SOURCE_PROVIDER_SEEK_TIME,
    VIDEO_PARAM_SOURCE_PROVIDER_DIRECT_SEEK,
    VIDEO_PARAM_SOURCE_PROVIDER_SELECT_PORT,
    VIDEO_PARAM_SOURCE_PROVIDER_SELECT_STREAM,
    //VIDEO_PARAM_SOURCE_PROVIDER_DESELECT_STREAM,
    VIDEO_PARAM_SOURCE_PROVIDER_FLUSH_BUFFER,
    VIDEO_PARAM_SOURCE_PROVIDER_QUICK_CLOSE,
    VIDEO_PARAM_SOURCE_PROVIDER_ABORT_PROCESS,
    VIDEO_PARAM_SOURCE_PROVIDER_MTK_FILE,
    VIDEO_PARAM_SOURCE_PROVIDER_TRANSFORMATION_INFO,
    VIDEO_PARAM_SOURCE_PROVIDER_CHANGE_HIGH_TASK_PRIORITY,
    VIDEO_PARAM_SOURCE_PROVIDER_AVC_CONF_RECORD,
    VIDEO_PARAM_SOURCE_PROVIDER_EMPTY_FUNC,
    VIDEO_PARAM_SOURCE_PROVIDER_3D_SBS,
    VIDEO_PARAM_SOURCE_PROVIDER_FREE_STREAM_BUFFER,
    VIDEO_PARAM_SOURCE_PROVIDER_PORT_INFO,

    // video muxer configs
    MUXER_PARAM_START = 1300,
    MUXER_GET_MIN_SPACE_TO_RECORD,
    MUXER_GET_MEMORY_SIZE,
    MUXER_IS_TEMP_FILE_EXISTED,
    MUXER_GET_CURRENT_FILE_SIZE,
    MUXER_GET_VIDEO_BITSTREAM_LEFTOVER,
    MUXER_GET_AUDIO_HEADERSIZE,
    MUXER_GET_RETURNING_VIDEO_BUFFER_NUMBER,
    MUXER_GET_RETURNING_AUDIO_BUFFER_NUMBER,
    MUXER_GET_RTP_SEQ_HEADER,

    MUXER_SET_CONTAINER_TYPE,
    MUXER_SET_SCENARIO,
    MUXER_SET_CALLBACK,
    MUXER_SET_VIDEO_CONFIG,
    MUXER_SET_AUDIO_CONFIG,
    MUXER_SET_WORKING_PATH,
    MUXER_SET_FILE_NAME_PATH,
    MUXER_SET_SIZE_LIMIT,
    MUXER_SET_TIME_LIMIT,
    MUXER_SET_VIDEO_WRITE_THRESHOLD,
    MUXER_SET_RTP_INSTANT_STOP,

    MUXER_CLEAR_TEMP_FILE,
    MUXER_SET_TIME_LAPSE_FRAME_RATE,
    MUXER_SET_VIDEO_RTP_HANDLE,
    MUXER_SET_AUDIO_RTP_HANDLE,
    MUXER_PARAM_END,

    VIDEO_PARAM_VSD_CODEC = 1400,
    VIDEO_PARAM_VSD_FONT_ENGINE_API,
    VIDEO_PARAM_VSD_FONT_ENCODING,
    VIDEO_PARAM_VSD_PARTIAL_RESET,      // VIDEO_PARAM_VSD_RESET_BACK_END
    VIDEO_PARAM_VSD_RESET_QUEUES,
    VIDEO_PARAM_VSD_RESOLUTION,
    VIDEO_PARAM_VSD_FONT_SIZE,
    VIDEO_PARAM_VSD_FONT_STYLES,        /* bold, italic, underline, strikeout, outline, shadow */
    VIDEO_PARAM_VSD_COLORS,             /* primary color, background color, alpha level */
    VIDEO_PARAM_VSD_ALIGNMENT,          /* horizontal, vertical */
    // VIDEO_PARAM_VSD_MARGINS,            /* left, right, vertical */ /* Display location is set to Render by MPL. */

    VIDEO_PARAM_MAX
} VIDEO_PARAM_TYPE_T;

typedef enum
{
    VIDEO_EVENT_COMPLETE = 0,
    VIDEO_EVENT_ERROR,

    //Decoder event
    VIDEO_EVENT_RESOLUTION_NOT_SUPPORT = 100,
    VIDEO_EVENT_NO_FRAME_DECODED_B4_EOF,
    VIDEO_EVENT_FLUSH_DONE,
    VIDEO_EVENT_EXCEED_MAX_RETRY,
    //Decoder event

    //Scheduler event
    VIDEO_EVENT_RECOVER_JUMPI = 200,
    VIDEO_EVENT_RECOVER_STOPAUDIO,
    VIDEO_EVENT_GET_JUMPTIME,
    VIDEO_EVENT_STOP,
    VIDEO_EVENT_EXPECTED_BUF_NUM_RDY,
    //Scheduler event

    //Source event
    VIDEO_EVENT_TIMEOUT = 300,
    VIDEO_EVENT_SET_PORT,
    VIDEO_EVENT_SEEK_TIME,
    VIDEO_EVENT_GET_KEY_FRAME_TIME,
    VIDEO_EVENT_MEM_LACK,
    VIDEO_EVENT_PARSER_ERROR,
    VIDEO_EVENT_PARSER_DELAY_ERROR,
    VIDEO_EVENT_PARSER_PGDL_UNDERFLOW,
    VIDEO_EVENT_FLUSH_STREAM_BUFFER,
    VIDEO_EVENT_QUERY_FRAME_BUFFER_DONE,
    //Source event

    //SubtitleDecoder event
    VIDEO_EVENT_VSD_RESET_Q_DONE = 400,
    //SubtitleDecoder event

    VIDEO_EVENT_NO_DISK = 500,
    VIDEO_EVENT_DISK_IS_FULL,
    VIDEO_EVENT_NO_VIDEO_FRAME_ENCODED,
    VIDEO_EVENT_MUXER_FILE_CREATED,
    VIDEO_EVENT_MUXER_REACH_SIZE_LIMIT,
    VIDEO_EVENT_MUXER_RETURN_AUDIO_BUFFER,  /* Not used any more after video clipper is supported. */
    VIDEO_EVENT_MUXER_ABORT_SAVING_DONE,
    VIDEO_EVENT_MUXER_ABORT_SAVING_FAIL,
    VIDEO_EVENT_REACH_TIME_LIMIT,
    VIDEO_EVENT_VIDEO_EOS,
    VIDEO_EVENT_AUDIO_EOS,

    // Seems no longer used
    VIDEO_EVENT_START = 1000,
    VIDEO_EVENT_ERROR_WITH_CODE,
    VIDEO_EVENT_INPUT_EMPTY,
    VIDEO_EVENT_WAIT_BUFFER,
    VIDEO_EVENT_FATAL_ERROR,
    VIDEO_EVENT_MAX
} VIDEO_EVENT_TYPE_T;


typedef enum
{
    VIDEO_STATE_CLOSE,
    VIDEO_STATE_INIT,
    VIDEO_STATE_IDLE,
    VIDEO_STATE_RUN,
    VIDEO_STATE_STOP,
    VIDEO_STATE_MAX
} VIDEO_STATE_TYPE_T;


typedef enum
{
    VIDEO_RECORDER_SOURCE_COMM
} VIDEO_RECORDER_SOURCE_TYPE_T;


typedef enum
{
    VIDEO_ENCODER_MPEG4,
    VIDEO_ENCODER_H263,
    VIDEO_ENCODER_MPEG4_VT,
    VIDEO_ENCODER_H263_VT,
    VIDEO_ENCODER_UNKNOWN_VT,
    VIDEO_ENCODER_RECORD_YUV,
    VIDEO_ENCODER_MJPEG,            // __AVI_ENC_SUPPORT__
    VIDEO_ENCODER_MJPEG_DIRECT_COUPLE,
    VIDEO_ENCODER_H264,
    VIDEO_ENCODER_UNKNOWN
} VIDEO_ENCODER_TYPE_T;


typedef enum
{
    VIDEO_ENCODER_QUALITY_NONE,
    VIDEO_ENCODER_QUALITY_LOW,
    VIDEO_ENCODER_QUALITY_NORMAL,
    VIDEO_ENCODER_QUALITY_GOOD,
    VIDEO_ENCODER_QUALITY_FINE,
    VIDEO_ENCODER_QUALITY_CUSTOM
} VIDEO_ENCODER_QUALITY_T;


typedef enum
{
    VIDEO_ENCODER_SCENARIO_NONE,
    VIDEO_ENCODER_SCENARIO_DECODER,
    VIDEO_ENCODER_SCENARIO_ENCODER,
    VIDEO_ENCODER_SCENARIO_VT,
    VIDEO_ENCODER_SCENARIO_BYPASS
} VIDEO_ENCODER_SCENARIO_T;


typedef enum
{
    ENCODER_CODEC_TYPE_NONE,
    ENCODER_CODEC_TYPE_MPEG4,
    ENCODER_CODEC_TYPE_H263,
    ENCODER_CODEC_TYPE_H264
} VIDEO_ENCODER_CODEC_T;


typedef enum
{
    VIDEO_FILEWRITER_MP4,
// #if defined(__VE_H264_ENC_SW_SUPPORT__)
    VIDEO_FILEWRITER_H264,
// #endif  // defined(__VE_H264_ENC_SW_SUPPORT__)
    VIDEO_FILEWRITER_AVI            // __AVI_ENC_SUPPORT__
} VIDEO_FILEWRITER_TYPE_T;


typedef enum
{
    VIDEO_FILEREADER_MP4
} VIDEO_FILEREADER_TYPE_T;

typedef enum
{
    VIDEO_CODEC_MPEG4,
    VIDEO_CODEC_H263,
    VIDEO_CODEC_H264,
    VIDEO_CODEC_RV9_10,
    VIDEO_CODEC_MJPEG,
    VIDEO_CODEC_VP8,
    VIDEO_CODEC_UNKNOWN
} VIDEO_DECODER_CODEC_T;

typedef enum
{
    VIDEO_SCENARIO_PLAYER,
    VIDEO_SCENARIO_VT,
    VIDEO_SCENARIO_QVGA,      // Must QVGA
    VIDEO_SCENARIO_PREVIEW,
    VIDEO_SCENARIO_QCIF,
    VIDEO_SCENARIO_VGA,
    VIDEO_SCENARIO_CIF,       // Must CIF
    VIDEO_SCENARIO_PLAYER_DECRYPTION,
    VIDEO_SCENARIO_UPTOQVGA, // Player <-> QVGA
    VIDEO_SCENARIO_UPTOCIF,  // Player <-> CIF
    VIDEO_SCENARIO_QVGA_MPEG4SP,
    VIDEO_SCENARIO_KMV, 
    VIDEO_SCENARIO_PREVIEW_KMV, 
    VIDEO_SCENARIO_UNKNOWN
} VIDEO_DECODER_SCENARIO_T;

typedef struct
{
    kal_uint32 u4ContainerWidth;
    kal_uint32 u4ContainerHeight;
} VIDEO_CONTAINER_INFO_T;

typedef struct
{
    VIDEO_DECODER_CODEC_T       eCodec;
    VIDEO_DECODER_SCENARIO_T    eScenario;
    VIDEO_EXTMEM_HANDLER_T*     prExtMemHdr;
    VIDEO_INTMEM_HANDLER_T*     prIntMexHdr;
    VIDEO_CONTAINER_INFO_T*     prContainerInfo;
} VIDEO_DECODER_HDLR_INFO_T;


typedef enum
{
    VIDEO_CLOCK_RECORDER,
    VIDEO_CLOCK_DECORDER
} VIDEO_CLOCK_TYPE_T;


typedef enum
{
    VIDEO_SCHEDULER_COMM
} VIDEO_SCHEDULER_TYPE_T;


typedef enum
{
    VIDEO_RENDER_COMM
} VIDEO_RENDER_TYPE_T;

typedef enum
{
    VIDEO_RENDERER_COLOR_DEFAULT_ERR = 0 /**< default error. */
  , VIDEO_RENDERER_COLOR_RGB565
  , VIDEO_RENDERER_COLOR_RGB888 /**< R in MSB. */
  , VIDEO_RENDERER_COLOR_BGR888 /**< B in MSB. */
  , VIDEO_RENDERER_COLOR_ARGB8888
  , VIDEO_RENDERER_COLOR_PACKED_UYVY422
  , VIDEO_RENDERER_COLOR_YUV444 /**< YUV444 planar format. */
  , VIDEO_RENDERER_COLOR_YUV422 /**< YUV422 planar format. */
  , VIDEO_RENDERER_COLOR_YUV420 /**< YUV420 planar format. */
  , VIDEO_RENDERER_COLOR_YUV411 /**< YUV411 planar format. */
  , VIDEO_RENDERER_COLOR_YUV400 /**< YUV400 planar format. */
  , VIDEO_RENDERER_COLOR_4X4_BLOCK_YUV420 /**< MTK specific 4x4 block-based YUV420 planar format produced by HW video codec. */
  , VIDEO_RENDERER_COLOR_MAX
} VA2_VIDEO_RENDERER_COLOR_FORMAT_T;

typedef struct
{
    kal_uint8 *pu1ParamStream;
    kal_uint32 u4ParamLength;
    kal_uint32 u4Width;
    kal_uint32 u4Height;
} VIDEO_QUERY_FRAME_SIZE_TYPE_T;

typedef struct
{
    kal_uint32 u4SrcWidth;
    kal_uint32 u4SrcHeight;
    kal_uint32 u4MaxAvailableFactor;
    kal_uint32 u4MinAvailableFactor;
    kal_uint32 u4SelectedWidthFactor;
    kal_uint32 u4SelectedHeightFactor;
} VIDEO_RESIZE_FACTOR_TYPE_T;


typedef struct
{
    VIDEO_ERROR_TYPE_T (*pfnDecoderQueryFrameSizeCallback)(VIDEO_QUERY_FRAME_SIZE_TYPE_T *pParam);
} VIDEO_QUERY_FRAME_SIZE_CALLBACK_TYPE_T;


/* This is the buffer header transmitted between two components. */
// Make sure: VIDEO_COMM_INPUT_Q_ITEM_SIZE  >= sizeof(VIDEO_BUFFERHEADER_TYPE_T)
// Make sure: VIDEO_COMM_OUTPUT_Q_ITEM_SIZE >= sizeof(VIDEO_BUFFERHEADER_TYPE_T)
#define VIDEO_COMM_INPUT_Q_ITEM_SIZE            56
#define VIDEO_COMM_OUTPUT_Q_ITEM_SIZE           56

typedef VIDEO_ERROR_TYPE_T (*PFN_EVENT_HANDLER_T)(VIDEO_EVENT_TYPE_T eEvent, kal_uint32 u4Data1, kal_uint32 u4Data2, void *pData);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_EVENT_HANDLER_T)(void* pvHandle, VIDEO_EVENT_TYPE_T eEvent, kal_uint32 u4Data1, kal_uint32 u4Data2, void *pData);

typedef struct
{
    PFN_EVENT_HANDLER_T pfnEventHandler;
    PFN_MI_EVENT_HANDLER_T pfnMIEventHandler;
} VIDEO_CALLBACK_TYPE_T;


/******************************************************************************
* The function table in a component.
******************************************************************************/
typedef VIDEO_ERROR_TYPE_T (*PFN_INIT_T)(void);
typedef VIDEO_ERROR_TYPE_T (*PFN_SEND_COMMAND_T)(VIDEO_COMMAND_TYPE_T eCmd, kal_uint32 u4Param);
typedef VIDEO_ERROR_TYPE_T (*PFN_GET_PARAMETER_T)(VIDEO_PARAM_TYPE_T eCmd, void *pParam);
typedef VIDEO_ERROR_TYPE_T (*PFN_SET_PARAMETER_T)(VIDEO_PARAM_TYPE_T eCmd, void *pParam);
typedef VIDEO_ERROR_TYPE_T (*PFN_USE_BUFFER_T)(kal_uint8 *pu1Buff, kal_uint32 u4Size);
typedef VIDEO_ERROR_TYPE_T (*PFN_EMPTY_THIS_BUFFER_T)(VIDEO_BUFFERHEADER_TYPE_T *prBuffHeader);
typedef VIDEO_ERROR_TYPE_T (*PFN_FILL_THIS_BUFFER_T)(VIDEO_BUFFERHEADER_TYPE_T *prBuffHeader);
typedef VIDEO_ERROR_TYPE_T (*PFN_SET_CALLBACK_T)(VIDEO_CALLBACK_TYPE_T *pfnCallbacks);
typedef VIDEO_ERROR_TYPE_T (*PFN_DEINIT_T)(void);


typedef VIDEO_ERROR_TYPE_T (*PFN_PROCESS_BUFFER_T)(VIDEO_BUFFERHEADER_TYPE_T*);


/* each component should implement this type*/
typedef struct
{
    PFN_INIT_T              pfnInit;
    PFN_SEND_COMMAND_T      pfnSendCommand;
    PFN_GET_PARAMETER_T     pfnGetParameter;
    PFN_SET_PARAMETER_T     pfnSetParameter;
    PFN_USE_BUFFER_T        pfnUseBuffer;
    PFN_EMPTY_THIS_BUFFER_T pfnEmptyThisBuffer;
    PFN_FILL_THIS_BUFFER_T  pfnFillThisBuffer;
    PFN_SET_CALLBACK_T      pfnSetCallbacks;
    PFN_DEINIT_T            pfnDeInit;
} VIDEO_COMPONENT_TYPE_T;

/* MI stands for Multiple Instance */
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_INIT_T)(void* pvHandle);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_SEND_COMMAND_T)(void* pvHandle, VIDEO_COMMAND_TYPE_T eCmd, kal_uint32 u4Param);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_GET_PARAMETER_T)(void* pvHandle, VIDEO_PARAM_TYPE_T eCmd, void *pParam);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_SET_PARAMETER_T)(void* pvHandle, VIDEO_PARAM_TYPE_T eCmd, void *pParam);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_USE_BUFFER_T)(void* pvHandle, kal_uint8 *pu1Buff, kal_uint32 u4Size);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_EMPTY_THIS_BUFFER_T)(void* pvHandle, VIDEO_BUFFERHEADER_TYPE_T *prBuffHeader);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_FILL_THIS_BUFFER_T)(void* pvHandle, VIDEO_BUFFERHEADER_TYPE_T *prBuffHeader);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_SET_CALLBACK_T)(void* pvHandle, VIDEO_CALLBACK_TYPE_T *pfnCallbacks);
typedef VIDEO_ERROR_TYPE_T (*PFN_MI_DEINIT_T)(void* pvHandle);

typedef struct
{
    PFN_MI_INIT_T pfnInit;
    PFN_MI_SEND_COMMAND_T pfnSendCommand;
    PFN_MI_GET_PARAMETER_T pfnGetParameter;
    PFN_MI_SET_PARAMETER_T pfnSetParameter;
    PFN_MI_USE_BUFFER_T pfnUseBuffer;
    PFN_MI_EMPTY_THIS_BUFFER_T pfnEmptyThisBuffer;
    PFN_MI_FILL_THIS_BUFFER_T pfnFillThisBuffer;
    PFN_MI_SET_CALLBACK_T pfnSetCallbacks;
    PFN_MI_DEINIT_T pfnDeInit;
} VIDEO_COMPONENT_MI_TYPE_T;

/* component use this structure to config port when initialize */
typedef struct
{
    VIDEO_PORT_TYPE_T ePortType;
    kal_bool fgSupplier;
    kal_uint32 u4BuffSize;
} VIDEO_PORT_CONFIG_T;


typedef struct
{
    VIDEO_PORT_CONFIG_T *prInputPort1;
    VIDEO_PORT_CONFIG_T *prInputPort2;
    VIDEO_PORT_CONFIG_T *prOutputPort1;
    VIDEO_PORT_CONFIG_T *prOutputPort2;
    kal_uint32 u4CmdQSize;
    kal_uint32 u4InputBuffQSize;
    kal_uint32 u4InputBuffQSize2;
    kal_uint32 u4OutputBuffQSize;
    kal_uint32 u4OutputBuffQSize2;
    VIDEO_EXTMEM_HANDLER_T* prExtMemHdlr;
    kal_mutexid eMutex;
} VIDEO_COMPONENT_INIT_T;

typedef enum
{
    VIDEO_PORT_INPUT = 0,
    VIDEO_PORT_OUTPUT
}VIDEO_PORT_T;

typedef struct
{
    VIDEO_PORT_T ePort;
    VIDEO_PORT_CONFIG_T rConfig;
    kal_uint32 u4BuffQSize;
    kal_uint32 u4PortIndex;
    VIDEO_EXTMEM_HANDLER_T* prExtMemHdlr;
} VIDEO_COMPONENT_INIT_PORT_T;

/* component use this to query/setting corresponding component parameters */
typedef struct
{
    VIDEO_COMPONENT_TYPE_T *prComp;
    PFN_PROCESS_BUFFER_T pfnProcessThisBuffer;
    kal_uint32 u4PortIndex;     // Port index of the component connected to the current component
} VIDEO_COMPONENT_PARAM_T;

/**
 *  Origianl aspect ratio.
 */
typedef struct
{
    kal_int32 i4AspectRatioWidth;
    kal_int32 i4AspectRatioHeight;
} VA2_FRAME_ASPECT_RATIO_T;

/**
 *  frame buffer address(es).
 */
typedef struct
{
    kal_uint32  u4_fb_addr_plane0; /**< If RGB or YUV packed format is in use, only plane0 is in use. If YUV planar format, Y plane frame buffer address. */
    kal_uint32  u4_fb_addr_plane1; /**< If YUV planar format, U plane frame buffer address. */
    kal_uint32  u4_fb_addr_plane2; /**< If YUV planar format, V plane frame buffer address. */
} VA2_FRAME_BUFFER_ADDRESS_T;

/**
 *  frame dimension.
 */
typedef struct
{
    kal_uint32  u4_width; /**< width in pixel. */
    kal_uint32  u4_height; /**< height in pixel. */
} VA2_FRAME_SIZE_T;

/**
 *  clip region.
 */
typedef struct
{
    kal_bool    b_clip_enable; /**< KAL_TRUE to enable clipping function. */
    kal_uint32  u4_clip_top; /**< [0, u4_clip_bottom]. */
    kal_uint32  u4_clip_left; /**< [0, u4_clip_right]. */
    kal_uint32  u4_clip_bottom; /**< [u4_clip_top, (height-1)] */
    kal_uint32  u4_clip_right; /**< [u4_clip_left, (width-1)] */
} VA2_CLIP_WINDOW_T;

/**
 *  sw dithering info.
 */
typedef struct
{
    kal_uint8  u1TotalBufNs;   // all buffer in video component
    kal_uint8  u1TotalListNs;   // clock queue list size
    kal_uint8  u1WaitingDispNs; // waiting display size
    kal_uint64 u8CurrentPlayTime; //scheduler provider current time (audio)
    kal_uint64 u4AVunSyncTime; // AV Unsync Time
    kal_uint64 u4MaxAVunSyncTime; // Maximum AV Unsync Time
} VA2_DITHERING_INFO_T;


/**
 *  video frame type.
 *  @remark used in the private data of buffer headers which are to be sent to va2_comp_video_renderer.
 */
typedef struct
{
    VA2_FRAME_BUFFER_ADDRESS_T  r_fb_addr;
    VA2_FRAME_SIZE_T            r_fb_size;
    VA2_CLIP_WINDOW_T           r_clip_window;
    VA2_VIDEO_RENDERER_COLOR_FORMAT_T   eFrameColorFmt;
    VA2_DITHERING_INFO_T  r_dithering_info;
    VA2_FRAME_ASPECT_RATIO_T  r_frame_aspect_ratio;
    void                        *pv_extra; /**< This is used to carry extra info, such as MP4 DBLK quantization buffer pointer... */
} VA2_VIDEO_FRAME_T;

/**
 *  video scheduler/clock passing data
 *  @remark used in the private data of buffer headers which are to be sent between scheduler and clock.
 */
typedef struct
{
    kal_uint64 u8CurrTime;
    VA2_VIDEO_FRAME_T*    pr_clip_window;
} VA2_VIDEO_SCH_CLK_T;

typedef struct
{
    kal_uint32  u4_start_addr;
    kal_uint32  u4_size;
} VA2_MEMORY_BLOCK_T;

/**
 *  VT uplink buffer info.
 */
typedef struct
{
    kal_uint8 u1denominator;
    kal_uint8 u1numerator;
} VCALL_UPLINK_INFO_T;

typedef struct
{
    kal_uint8 *pu1BufferAddr;
    kal_uint32 u4BuffSize;
} VT_CTRL_VOS_T;

typedef void (*PFN_VCALL_GET_UPLINKINFO_T) (VCALL_UPLINK_INFO_T *);

typedef enum
{
    VIDEO_DECODER_ERROR_NONE = 0,
    VIDEO_DECODER_ERROR_UNKNOWN_CODEC,
    VIDEO_DECODER_ERROR_INSUFFICIENT_MEMORY,
    VIDEO_DECODER_ERROR_MAX
}
VIDEO_DECODER_ERROR_TYPE_T;

typedef struct
{
    VIDEO_COMPONENT_TYPE_T*      pComponent;
    VIDEO_DECODER_ERROR_TYPE_T   eErrorType;
}VIDEO_DECODER_COMPONENT_TYPE_T;

#include "video_dbg_v2.h"
#include "video_comm_v2.h"

//#endif /* __VE_VIDEO_ARCHI_V2__ */
#endif /* VIDEO_TYPES_V2_H */

