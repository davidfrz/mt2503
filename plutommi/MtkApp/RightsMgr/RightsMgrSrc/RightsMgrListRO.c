/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  RightsMgrListRO.c
 *
 * Project:
 * --------
 *  PlutoMMI
 *
 * Description:
 * ------------
 *  List RO screen of Rights Manager  
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *          HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/*
 * Include 
 */
#include "MMI_include.h"
#ifdef __MMI_RMGR__

//#include "custom_mmi_default_value.h"
#include "RightsMgrGprot.h"
#include "RightsMgrProt.h"
#include "FileMgr.h"
//#include "StatusIconRes.h"
//#include "CommonScreens.h"
//#include "SettingProfile.h"
#include "dmuigprot.h"


#include "drm_gprot.h"
//#include "drm_msg.h"
//#include "FileManagerResDef.h"
#include "FileManagerGProt.h"           /* GetFileSystemErrorString */
#include "app_str.h"
//#include "CommonScreens.h"  /* gIndexIconsImageList */
//#include "CallManagementGprot.h" /* isinCall */
#ifdef __MMI_UCM__
#include "UcmSrvGprot.h"
#endif
#ifdef __MMI_FTE_SUPPORT__
#include "wgui_touch_screen.h"
#endif /*__MMI_FTE_SUPPORT__*/

#include "MMI_features.h"
#include "MMIDataType.h"
#include "FileMgrSrvGProt.h"
#include "wgui_categories_list.h"
#include "gui_data_types.h"
#include "kal_general_types.h"
#include "mmi_rp_app_rmgr_def.h"
#include "wgui_categories_util.h"
#include "GlobalConstants.h"
#include "Unicodexdcl.h"
#include "mmi_frm_scenario_gprot.h"
#include "RightsMgrResDef.h"
#include "mmi_frm_events_gprot.h"
#include "string.h"
#include "drm_def.h"
#include "wgui_categories_text_viewer.h"
#include "GlobalResDef.h"
#include "drm_errcode.h"
#include "CustDataRes.h"
#include "AlertScreen.h"
#include "mmi_rp_srv_filemanager_def.h"
#include "kal_public_api.h"
#include "CommonScreensResDef.h"
#include "mmiapi_dm_struct.h"
#include "TimerEvents.h"
#include "mmi_frm_timer_gprot.h"
#include "mmi_frm_input_gprot.h"
#include "menucuigprot.h"
#include "mmi_frm_history_gprot.h"
#include "DmSrvGprot.h"

/*
 * Static Declaration
 */

#ifdef __DM_LAWMO_SUPPORT__  

static MMI_BOOL rmgr_phone_lock_flag;

#endif /*__DM_LAWMO_SUPPORT__*/

rmgr_list_ro_cntx_struct rmgr_list_ro_cntx;
S8 ro_alias[SRV_FMGR_PATH_MAX_FILE_NAME_LEN * ENCODING_LENGTH];

/*
 * Global Variable
 */

/*
 * Local Function
 */
static void mmi_rmgr_list_ro_main_highlight_hdlr(S32 menu_idx);
static void mmi_rmgr_list_ro_set_execute_key_hdlr(FuncPtr key_hdlr);
static void mmi_rmgr_list_ro_entry_detail(void);
static void mmi_rmgr_list_ro_delete_entry(void);
static void mmi_rmgr_list_ro_delete_all_entry(void);
static void mmi_rmgr_list_ro_entry_delete(void);
static void mmi_rmgr_list_ro_option_highlight_hdlr(S32 menu_idx);
static void mmi_rmgr_list_ro_entry_option(void);

/*
 * Local Variable
 */
static FuncPtr delete_hdlr = NULL;
static kal_char content_drv;
    
extern pBOOL IsBackHistory;

/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_get_alias_item
 * DESCRIPTION
 *  
 * PARAMETERS
 *  item_index          [IN]        
 *  str_buff            [IN]        
 *  img_buff_p          [?]         
 *  str_img_mask        [IN]        
 *  menu_idx(?)         [IN]        Menu item index
 * RETURNS
 *  void
 *****************************************************************************/

S32 mmi_rmgr_get_alias_item(S32 start_index, gui_iconlist_menu_item *menu_data, S32 data_size)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	kal_wchar *ptr;
    kal_int32 result;
	S32 index =0;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	for (index = 0; index < data_size; index++)
	{
		result = DRM_get_ro_list((start_index+index), (char *)&ro_alias[0], SRV_FMGR_PATH_MAX_FILE_NAME_LEN * ENCODING_LENGTH,DRM_DB_GET_VALID);
		if (result < 0)
		{
			return index;
		}
		menu_data[index].image_list[0] = get_image(IMG_ID_RMGR_UNLOCK);
		mmi_ucs2ncpy((S8 *)menu_data[index].item_list[0], (const S8 *)&ro_alias[0], MAX_SUBMENU_CHARACTERS);
		ptr = app_ucs2_strstr(menu_data[index].item_list[0] + (app_ucs2_strlen((kal_int8 *)menu_data[index].item_list[0]) - 4), (kal_wchar *)L".mp3");

		if (ptr)
		{
			*ptr = 0;
		}

		ptr = app_ucs2_strstr(menu_data[index].item_list[0] + (app_ucs2_strlen((kal_int8 *)menu_data[index].item_list[0]) - 4), (kal_wchar *)L".mp2");

		if (ptr)
		{
			*ptr = 0;
		}
	}
	return data_size;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_main_highlight_hdlr
 * DESCRIPTION
 *  Highlight handler of the list ro main screen
 * PARAMETERS
 *  menu_idx        [IN]        Menu item index
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_main_highlight_hdlr(S32 menu_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_rmgr_p->ro_idx = menu_idx;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_set_execute_key_hdlr
 * DESCRIPTION
 *  Set the execution key handler
 * PARAMETERS
 *  key_hdlr        [IN]        Key handler function pointer
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_set_execute_key_hdlr(FuncPtr key_hdlr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    SetLeftSoftkeyFunction(key_hdlr, KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_entry_detail
 * DESCRIPTION
 *  Entry function of the list ro detail screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_entry_detail(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 *guiBuffer, *info;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //EntryNewScreen(SCR_ID_RMGR_LIST_RO_DETAIL, NULL, mmi_rmgr_list_ro_entry_detail, NULL);
if(mmi_frm_scrn_enter(
       GRP_ID_RMGR_MAIN, 
       SCR_ID_RMGR_LIST_RO_DETAIL, 
       NULL, 
       mmi_rmgr_list_ro_entry_detail, 
       MMI_FRM_FULL_SCRN))
{
    guiBuffer = mmi_frm_scrn_get_gui_buf (GRP_ID_RMGR_MAIN, SCR_ID_RMGR_LIST_RO_DETAIL);

    info = (PU8) subMenuData;

    memset(info, 0x00, sizeof(kal_wchar));

#ifdef __DRM_V02__    
    /* Shared */
    mmi_ucs2cat((PS8) info, (PS8) GetString(STR_ID_RMGR_SHARED_RO));
    mmi_ucs2cat((PS8) info, (PS8) L"\n");

    if (DRM_get_ro_shareability(mmi_rmgr_p->ro_idx))
    {
        mmi_ucs2cat((PS8) info, (PS8) GetString(STR_GLOBAL_YES));
    }
    else
    {
        mmi_ucs2cat((PS8) info, (PS8) GetString(STR_GLOBAL_NO));
    }
    mmi_ucs2cat((PS8) info, (PS8) L"\n");
#endif /* __DRM_V02__ */

    /* Summary */
    mmi_rmgr_populate_drm_info_aux(NULL, DRM_PERMISSION_ALL, info, sizeof(subMenuData), mmi_rmgr_p->ro_idx);
        
    ShowCategory74Screen(
        STR_GLOBAL_DETAILS,
        mmi_rmgr_get_root_icon(),
        0,
        0,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        (PU8) subMenuData,
        MAX_SUB_MENUS * MAX_SUB_MENU_SIZE,
        guiBuffer);

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
}
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_del_callback
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_del_callback(kal_uint8 serial, kal_int32 result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    rmgr_list_ro_cntx.refresh = MMI_TRUE;
#ifdef __DM_LAWMO_SUPPORT__
	if (rmgr_phone_lock_flag)
	{
		/*No popup*/
	}
	else
#endif /*__DM_LAWMO_SUPPORT__*/
	{
    if (result == DRM_RESULT_OK)
    {
        mmi_popup_display((WCHAR*)GetString(STR_GLOBAL_DELETED), MMI_EVENT_SUCCESS, NULL);

        if (rmgr_list_ro_cntx.ro_num <= 1)
        {
            //DeleteScreenIfPresent(SCR_ID_RMGR_LIST_RO_MAIN);
            mmi_frm_scrn_close(GRP_ID_RMGR_MAIN, SCR_ID_RMGR_LIST_RO_MAIN);
        }
	else
	{
               if(mmi_rmgr_p->ro_idx == rmgr_list_ro_cntx.ro_num)
               {
               	mmi_rmgr_p->current_idx = mmi_rmgr_p->ro_idx - 1;
               }
		 else
		 {
                     mmi_rmgr_p->current_idx = mmi_rmgr_p->ro_idx;
		 }
	}
    }
    else
    {
        if (result == DRM_RESULT_CANCELED)
        {
            mmi_popup_display((WCHAR*)GetString(FMGR_FS_ABORTED_ERROR_TEXT), MMI_EVENT_SUCCESS, NULL);
        }
        else
        {
            mmi_popup_display((WCHAR*)GetString(srv_fmgr_fs_error_get_string(result)), MMI_EVENT_FAILURE, NULL);
        }
    }
    }

    mmi_frm_scrn_close(GRP_ID_RMGR_MAIN, SCR_ID_RMGR_PROGRESS);
    //DeleteScreenIfPresent(SCR_ID_RMGR_PROGRESS);
    //DeleteScreenIfPresent(SCR_ID_RMGR_LIST_RO_OPTION);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_delete_entry
 * DESCRIPTION
 *  Entry function of the list ro delete done screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_delete_entry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (!DRM_consume_table_is_in_use())
    {
        mmi_rmgr_entry_db_progressing(STR_GLOBAL_DELETING, 0, MMI_FALSE, MMI_FALSE);

        DRM_process_database(
            DRM_PROCESS_DATABASE_DELETE_SINGLE_FROM_VALID,
            mmi_rmgr_p->ro_idx,
            NULL,
            NULL,
            mmi_rmgr_list_ro_del_callback);
    }
    else
    {
        mmi_popup_display((WCHAR*)GetString(STR_ID_DRM_DB_LOCKED_BY_APP), MMI_EVENT_FAILURE, NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_delete_all_entry
 * DESCRIPTION
 *  Entry function of the list ro delete done screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_delete_all_entry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (!DRM_consume_table_is_in_use())
    {
        kal_uint8 serial;

        /* reset the ro_num to zero, in callback function
           we will delete the list screen and go back to main menu */

        rmgr_list_ro_cntx.ro_num = 0;

        if (content_drv)
        {
            kal_wchar path[4];

            kal_wsprintf(path, "%c:\\", content_drv);
            DRM_process_database(
                DRM_PROCESS_DATABASE_DELETE_ALL,
                0,
                path,
                (kal_uint8*) & serial,
                mmi_rmgr_list_ro_del_callback);
        }
        else
        {
            DRM_process_database(
                DRM_PROCESS_DATABASE_DELETE_ALL,
                0,
                NULL,
                (kal_uint8*) & serial,
                mmi_rmgr_list_ro_del_callback);
        }
	#ifdef __DM_LAWMO_SUPPORT__   
		if (rmgr_phone_lock_flag)
		{
			/* Do not show progressing screen*/
		}
		else
	#endif /*__DM_LAWMO_SUPPORT__*/
		{
            mmi_rmgr_entry_db_progressing(STR_GLOBAL_DELETING, serial, MMI_TRUE, MMI_FALSE);
        }
    }
    else
    {
        mmi_popup_display((WCHAR*)GetString(STR_ID_DRM_DB_LOCKED_BY_APP), MMI_EVENT_FAILURE, NULL);
    }
    content_drv = 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_entry_delete
 * DESCRIPTION
 *  Entry function of the list ro delete screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_entry_delete(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *delete_str;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (delete_hdlr == mmi_rmgr_list_ro_delete_all_entry)
    {
        delete_str = (U16 *)GetString(STR_ID_RMGR_DELETE_ALL_QUERY);
    }
    else
    {
        delete_str = (U16 *)GetString(STR_ID_RMGR_DELETE_QUERY);
    }
    
    {
	mmi_confirm_property_struct arg;
	mmi_confirm_property_init(&arg, CNFM_TYPE_YESNO);
	arg.parent_id = GRP_ID_RMGR_MAIN;
	arg.callback = (mmi_proc_func)mmi_rmgr_list_ro_delete_conf_callback;
	arg.f_auto_map_empty_softkey = MMI_FALSE;
      arg.user_tag = NULL;
	mmi_confirm_display((WCHAR *)delete_str, MMI_EVENT_QUERY, &arg);
    }
}

mmi_ret mmi_rmgr_list_ro_delete_conf_callback(mmi_event_struct *evt)
{
    mmi_alert_result_evt_struct *alertEvt = (mmi_alert_result_evt_struct *)evt;

    if (alertEvt->evt_id == EVT_ID_ALERT_QUIT)
    {
        switch (alertEvt->result)
        {
        case MMI_ALERT_CNFM_YES:
            (*delete_hdlr)();
	    break;
        case MMI_ALERT_CNFM_NO:
            mmi_frm_scrn_close_active_id();
            break;
	  default:
	  	break;
        }
    }
    return MMI_RET_OK;
}



static void mmi_rmgr_format_popup_handler()
{
      mmi_id g_id;
	g_id = mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_RMGR_MAIN, mmi_rmgr_main_evt_hdlr, NULL);
	mmi_frm_group_enter(g_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
	mmi_rmgr_list_ro_entry_delete();
}		





/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_format_notify_timeout_hdlr
 * DESCRIPTION
 *  Post formatting notification handler
 * PARAMETERS
 *  void
 *  para(?)             [IN]        Additional parameter
 *  notify_flag(?)      [IN]        MMI_FMGR_NOTIFY_DRV_POST_FORMAT
 * RETURNS
 *  MMI_BOOL: always return true
 *****************************************************************************/
void mmi_rmgr_format_notify_timeout_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL block_screen = MMI_FALSE;
     mmi_id g_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UCM__
    if (srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0)
    {
        block_screen = MMI_TRUE;

    #ifdef __MMI_BACKGROUND_CALL__
        if (srv_ucm_is_background_call())
        {
            block_screen = MMI_FALSE;
        }
    #endif /* __MMI_BACKGROUND_CALL__ */ 
    }

    if (block_screen)
    {
        return;
    }
#endif /* __MMI_UCM__ */ 

   
   mmi_frm_nmgr_notify_by_app(MMI_SCENARIO_ID_DEFAULT, MMI_EVENT_NON_TONE, mmi_rmgr_format_popup_handler, NULL);
   //mmi_rmgr_list_ro_entry_delete();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_format_notify_hdlr
 * DESCRIPTION
 *  Post formatting notification handler
 * PARAMETERS
 *  notify_flag        [IN]        MMI_FMGR_NOTIFY_DRV_POST_FORMAT
 *  para               [IN]        additional parameter
 * RETURNS
 *  MMI_BOOL: always return true
 *****************************************************************************/
mmi_ret mmi_rmgr_format_notify_hdlr(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 drv_enum;
    srv_fmgr_notification_format_event_struct *format_evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch(param->evt_id)
	{
		case EVT_ID_SRV_FMGR_NOTIFICATION_FORMAT:
			format_evt = (srv_fmgr_notification_format_event_struct*)param;
			if(format_evt->state == SRV_FMGR_NOTIFICATION_STATE_AFTER)
			{
				//mmi_fmgr_get_drive_enum_by_letter(format_evt->drv_letter, &drv_enum);
#ifdef __DM_LAWMO_SUPPORT__
				rmgr_phone_lock_flag = MMI_FALSE;   
				if (srv_dm_lawmo_is_wiping())
				{
					rmgr_phone_lock_flag = MMI_TRUE;
					mmi_rmgr_list_ro_delete_all_entry();
				}
				else
#endif /*__DM_LAWMO_SUPPORT__*/
			    {
			        delete_hdlr = mmi_rmgr_list_ro_delete_all_entry;
			        content_drv = format_evt->drv_letter;// ((kal_char *)para)[0];

			        StartTimer(RMGR_SCAN_DISK_TIMER, 1500, mmi_rmgr_format_notify_timeout_hdlr);
				}
			}
			break;
		default:
			break;
    }
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_option_highlight_hdlr
 * DESCRIPTION
 *  Highlight handler of the list ro option screen
 * PARAMETERS
 *  menu_idx        [IN]        Menu item index
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_option_highlight_hdlr(S32 menu_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (menu_idx == 0)
    {
        mmi_rmgr_list_ro_set_execute_key_hdlr(mmi_rmgr_list_ro_entry_detail);
        SetKeyHandler(mmi_rmgr_list_ro_entry_detail, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    else if (menu_idx == 1)
    {
        
        delete_hdlr = mmi_rmgr_list_ro_delete_entry;
        mmi_rmgr_list_ro_set_execute_key_hdlr(mmi_rmgr_list_ro_entry_delete);
        SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
    else
    {
        delete_hdlr = mmi_rmgr_list_ro_delete_all_entry;
        mmi_rmgr_list_ro_set_execute_key_hdlr(mmi_rmgr_list_ro_entry_delete);
        SetKeyHandler(NULL, KEY_RIGHT_ARROW, KEY_EVENT_DOWN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_entry_option
 * DESCRIPTION
 *  Entry function of the list ro option screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_rmgr_list_ro_entry_option(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 g_id;
    U16 menu_cui_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_id = mmi_frm_group_create(GRP_ID_RMGR_MAIN, GRP_ID_RMGR_RO_OPTIONS, mmi_rmgr_ro_options_evt_hdlr, NULL);
    mmi_frm_group_enter(g_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);

	menu_cui_id = cui_menu_create(
             g_id, 
             CUI_MENU_SRC_TYPE_RESOURCE, 
             CUI_MENU_TYPE_OPTION, 
             MENU_ID_RMGR_RO_OPTIONS, 
             MMI_FALSE, 
             NULL);

    cui_menu_set_default_title_image(menu_cui_id,(UI_image_type)GetImage(mmi_rmgr_get_root_icon()));
    cui_menu_run(menu_cui_id);
    
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif /*0*/
}


/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_ro_options_evt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  evt     [?]     
 * RETURNS
 *  
 *****************************************************************************/
mmi_ret mmi_rmgr_ro_options_evt_hdlr(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/
	cui_menu_event_struct *menu_evt = (cui_menu_event_struct *)evt;

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/

switch (evt->evt_id)
    {

        case EVT_ID_SCRN_GOBACK:
            break;

        case EVT_ID_GROUP_DEINIT:
            break;

        case EVT_ID_GROUP_EXIT:
            break;

        case EVT_ID_GROUP_INACTIVE:
            break;

        case EVT_ID_GROUP_GOBACK:
            break;

        case EVT_ID_CUI_MENU_ITEM_SELECT:
        case EVT_ID_CUI_MENU_ITEM_CSK_SELECT:
        {
            switch (menu_evt->highlighted_menu_id)
            {
                case MENU_ID_RMGR_LIST_RO_DETAIL:
                    mmi_rmgr_list_ro_entry_detail();
                    break;

                case MENU_ID_RMGR_LIST_RO_DELETE:
                    delete_hdlr = mmi_rmgr_list_ro_delete_entry;
                    mmi_rmgr_list_ro_entry_delete();
                    break;

                case MENU_ID_RMGR_LIST_RO_DELETEALL:
                    delete_hdlr = mmi_rmgr_list_ro_delete_all_entry;
                    mmi_rmgr_list_ro_entry_delete();
                    break;
                default:
                    break;

            }
        }
	  break;  /* */
        case EVT_ID_CUI_MENU_ITEM_HILITE:
        {

        }
		break;
	  case EVT_ID_CUI_MENU_CLOSE_REQUEST:
             cui_menu_close(menu_evt->sender_id);
         break;
        default:
            break;
    }
    return MMI_RET_OK;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_main_delete_cb
 * DESCRIPTION
 *  Entry function of the list ro main screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
U8 mmi_rmgr_list_ro_entry_main_delete_cb(void *in_param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DRM_free_ro_list();

    return MMI_FALSE;
}

#ifdef __MMI_FTE_SUPPORT__


/*****************************************************************************
 * FUNCTION
 	mmi_rmgr_ro_list_tap_callback
 * DESCRIPTION
 	Finger touch tap callback
 * PARAMETERS
 	tap_type : tap to highlight etc.
 	index : right object index
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rmgr_ro_list_tap_callback(mmi_tap_type_enum tap_type, S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/*No action. not an intuitive command*/
	return;
}
#endif /* __MMI_FTE_SUPPORT__*/

mmi_ret mmi_rmgr_ro_list_leave_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
     switch (evt->evt_id)
    {
        case EVT_ID_SCRN_DEINIT:
            break;

        case EVT_ID_SCRN_DELETE_REQ:
        mmi_rmgr_list_ro_entry_main_delete_cb(NULL);
        break;
        default:
            break;
    }

    return MMI_RET_OK;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_entry_real_main
 * DESCRIPTION
 *  Entry function of the list ro main screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rmgr_list_ro_entry_real_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 max_ro_num = 0;
    U8 *guiBuffer;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* check if it is empty, and popup if it is the first time enter the screen */
    max_ro_num = rmgr_list_ro_cntx.ro_num;

    if (max_ro_num <= 0)
    {
        DRM_free_ro_list();
        mmi_popup_display((WCHAR*)GetString(STR_GLOBAL_EMPTY), MMI_EVENT_FAILURE, NULL);
	return;
    }
	if(mmi_frm_scrn_enter(
       GRP_ID_RMGR_MAIN, 
       SCR_ID_RMGR_LIST_RO_MAIN, 
       NULL, 
       mmi_rmgr_list_ro_entry_main, 
       MMI_FRM_SMALL_SCRN))
		{
    guiBuffer = mmi_frm_scrn_get_gui_buf (GRP_ID_RMGR_MAIN, SCR_ID_RMGR_LIST_RO_MAIN);

        /* EntryNewScreen(SCR_ID_RMGR_LIST_RO_MAIN, NULL, mmi_rmgr_list_ro_entry_main, NULL); */

    RegisterHighlightHandler(mmi_rmgr_list_ro_main_highlight_hdlr);
    EnableCenterSoftkey(0, IMG_GLOBAL_COMMON_CSK);
/*
    ShowCategory284Screen(
        STR_ID_RMGR_LIST_RO,
        mmi_rmgr_get_root_icon(),
        STR_GLOBAL_OPTIONS,
        IMG_GLOBAL_OPTIONS,
        STR_GLOBAL_BACK,
        IMG_GLOBAL_BACK,
        max_ro_num,
        mmi_rmgr_get_alias_item,
        NULL,
        mmi_rmgr_p->current_idx,
        guiBuffer);
*/

    wgui_cat1032_show(
        (WCHAR*)GetString(STR_ID_RMGR_LIST_RO),
        (PU8)GetImage(mmi_rmgr_get_root_icon()),
        (WCHAR*)GetString(STR_GLOBAL_OPTIONS),
        (PU8)GetImage(IMG_GLOBAL_OPTIONS),
        (WCHAR*)GetString(STR_GLOBAL_BACK),
        (PU8)GetImage(IMG_GLOBAL_BACK),
        max_ro_num,
        mmi_rmgr_get_alias_item,
        NULL,
        mmi_rmgr_p->current_idx,
        0,
        IMG_ID_RMGR_UNLOCK,
        0,
        guiBuffer,
        NULL);
        
        
        
        
        

    

    SetRightSoftkeyFunction(mmi_frm_scrn_close_active_id, KEY_EVENT_UP);
    SetCenterSoftkeyFunction(mmi_rmgr_list_ro_entry_detail, KEY_EVENT_UP);
    //SetKeyHandler(mmi_frm_scrn_close_active_id, KEY_LEFT_ARROW, KEY_EVENT_DOWN);
    mmi_rmgr_list_ro_set_execute_key_hdlr(mmi_rmgr_list_ro_entry_option);
    mmi_frm_scrn_set_leave_proc (GRP_ID_RMGR_MAIN, SCR_ID_RMGR_LIST_RO_MAIN, mmi_rmgr_ro_list_leave_proc);
    //SetDelScrnIDCallbackHandler(SCR_ID_RMGR_LIST_RO_MAIN, mmi_rmgr_list_ro_entry_main_delete_cb);
    #ifdef __MMI_FTE_SUPPORT__ 
    wgui_register_list_tap_callback(mmi_rmgr_ro_list_tap_callback);
    #endif 
}
}

/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_get_num_callback_copy
 * DESCRIPTION
 * PARAMETERS
 *  serial      [IN]        
 *  result      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rmgr_list_ro_get_num_callback_copy(kal_uint8 serial, kal_int32 result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    rmgr_list_ro_cntx.ro_num = result;
	mmi_rmgr_list_ro_entry_real_main();
	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_rmgr_list_ro_get_num_callback
 * DESCRIPTION
 * PARAMETERS
 *  serial      [IN]        
 *  result      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_rmgr_list_ro_get_num_callback(kal_uint8 serial, kal_int32 result)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    rmgr_list_ro_cntx.ro_num = result;

    if (result < DRM_RESULT_OK)
    {

        if (result == DRM_RESULT_CANCELED)
        {
            mmi_popup_display((WCHAR*) GetString(FMGR_FS_ABORTED_ERROR_TEXT), MMI_EVENT_SUCCESS, NULL);
        }
        else
        {
            mmi_popup_display((WCHAR*) GetString(srv_fmgr_fs_error_get_string(result)), MMI_EVENT_FAILURE, NULL);
        }

        mmi_frm_scrn_close(GRP_ID_RMGR_MAIN, SCR_ID_RMGR_PROGRESS);

        /* remember to free history buffer hold by framework */
        /* mmi_frm_free_history_buffer(SCR_ID_RMGR_LIST_RO_MAIN); */
        return;
    }

    /* the screen is covered by another screen , we just replace the history and then leave */
	if (mmi_frm_scrn_is_present (GRP_ID_RMGR_MAIN, SCR_ID_RMGR_PROGRESS, MMI_FRM_NODE_EXCLUDE_ACTIVE_SCRN_FLAG))
/*    if (IsScreenPresent(SCR_ID_RMGR_PROGRESS))*/
    {
        mmi_frm_node_struct new_node_info;
		
        new_node_info.id = SCR_ID_RMGR_LIST_RO_MAIN;
        new_node_info.entry_proc = (mmi_proc_func)mmi_rmgr_list_ro_entry_main;
	
        mmi_frm_scrn_replace(GRP_ID_RMGR_MAIN, SCR_ID_RMGR_PROGRESS, &new_node_info);    
		
        //HistoryReplace(SCR_ID_RMGR_PROGRESS, SCR_ID_RMGR_LIST_RO_MAIN, mmi_rmgr_list_ro_entry_main);
        //SetDelScrnIDCallbackHandler(SCR_ID_RMGR_LIST_RO_MAIN, mmi_rmgr_list_ro_entry_main_delete_cb);
        mmi_frm_scrn_set_leave_proc(GRP_ID_RMGR_MAIN, SCR_ID_RMGR_LIST_RO_MAIN, mmi_rmgr_ro_list_leave_proc);
    }
    else if (mmi_frm_scrn_get_active_id() == SCR_ID_RMGR_PROGRESS)
    {
        mmi_rmgr_list_ro_entry_real_main();
        mmi_frm_scrn_close(GRP_ID_RMGR_MAIN, SCR_ID_RMGR_PROGRESS);
    }
    else /* the processing screen is deleted by other application */
    {
        DRM_free_ro_list();

    }
    /* remember to free history buffer hold by framework */
    /* mmi_frm_free_history_buffer(SCR_ID_RMGR_LIST_RO_MAIN); */
}

/*****************************************************************************
 * FUNCTION
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *****************************************************************************/
void mmi_rmgr_list_ro_entry_main(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint8 serial;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* 1. redraw by small screen
       2. gobackhistory and no need refresh screen */
    if(!mmi_frm_group_is_present(GRP_ID_RMGR_MAIN))
    {     
         mmi_id g_id;
         g_id = mmi_frm_group_create(GRP_ID_ROOT, GRP_ID_RMGR_MAIN, mmi_rmgr_main_evt_hdlr, NULL);
	 mmi_frm_group_enter(g_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    }
    if (mmi_is_redrawing_bk_screens() || rmgr_list_ro_cntx.refresh == MMI_FALSE)
    {
        /* do not reget the data, just use old data */
        //mmi_rmgr_list_ro_entry_real_main();
		DRM_get_ro_num(&serial, mmi_rmgr_list_ro_get_num_callback_copy,DRM_DB_GET_VALID) ;
    }
    else
    {
        /* reserve the highlight information in guibuffer */
        /*if (mmi_frm_scrn_is_present (GRP_ID_RMGR_MAIN, SCR_ID_RMGR_LIST_RO_MAIN, MMI_FRM_NODE_ALL_FLAG))//IsScreenPresent(SCR_ID_RMGR_LIST_RO_MAIN))
        {
            mmi_frm_hold_history_buffer(SCR_ID_RMGR_LIST_RO_MAIN);
        }*/

        rmgr_list_ro_cntx.refresh = MMI_FALSE;
        DRM_get_ro_num(&serial, mmi_rmgr_list_ro_get_num_callback,DRM_DB_GET_VALID);
        mmi_rmgr_entry_db_progressing(STR_ID_RMGR_PROCESSING, serial, MMI_TRUE, MMI_FALSE);
    }
}


#endif /* __MMI_RMGR__ */
