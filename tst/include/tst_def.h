/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * tst_def.h
 *
 * Project:
 * --------
 *   Maui_Software
 *
 * Description:
 * ------------
 *   This file provides typedefs and definiton for PS index trace.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#ifndef _TST_DEF_H
#define _TST_DEF_H

#include "kal_trace.h"
#include "kal_general_types.h"
#include "stack_config.h"
#include "stack_common.h"
#include "stack_msgs.h"

#ifdef __EM_MODE__
  #ifndef _EM_STRUCT_H
    #include "em_struct.h"
  #endif  //#ifndef _EM_STRUCT_H
#endif  //#ifdef __EM_MODE__

#include "dcl.h"

#include "kal_public_defs.h"
#include "kal_public_api.h"
#include "stack_timer.h"

#ifndef LOW_COST_SUPPORT
  #include "sysconf_statistics.h"
#endif  //#ifndef LOW_COST_SUPPORT

#include "swtr.h" //for SWTR defs

//Kevin: Don't include windows.h in this file
//       This file is included by lots of MMI files
//       MMI will define some data types as windows.h and that results in compile errors.

extern kal_eventgrpid	tst_event_group;
#define TST_EVENT_WRITE_OK   0x01
#define TST_EVENT_SYNC       0x02
#define TST_EVENT_IRCOMM     0x04
#define TST_EVENT_LOGMSG     0x08
#define TST_EVENT_KDWPHOOK   0x10
#define TST_EVENT_LOG_IDLE   0x20
#define TST_EVENT_PORT_NOT_SWITCHING  0x40
#define TST_EVENT_PORT_NOT_USING      0x80
#define TST_EVENT_CTI_TO_LOG 0x0100
#define TST_EVENT_OPEN_FILE 0x0200
#define TST_EVENT_OPEN_FILE_OK 0x0400
#define TST_EVENT_CLOSE_FILE 0x0800
#define TST_EVENT_CLOSE_FILE_OK 0x1000
#define TST_EVENT_WRITE_TO_FILE 0x2000
#define TST_EVENT_WRITE_TO_FILE_OK 0x4000
#define TST_EVENT_WRITE_CREATE_TO_FILE 0x8000
#define TST_EVENT_WRITE_CREATE_TO_FILE_OK 0x010000
#define TST_EVENT_LOGACC_TST_WAKEUP 0x020000
#define TST_EVENT_PORT_CHANGING 0x040000
#define TST_EVENT_LMU_SYNC_SEND 0x080000
#define TST_EVENT_LGA_LOG2FILE_REQ 0x100000

/*Note: 
	When tiny system(feature option in project makefile is TINY_SYS) is enabled, 
	logging buffer size under tiny-mode will be half of the TST_RING_BUFFER_SIZE on AP-mode, but max-size is restricted to 10kB.
	If TST_RING_BUFFER_SIZE is changed, please notify scatgen owner to check tiny-mode logging buffer size setting,
	which is defined in GetTS_ResLoggingMemSize() in sysGenUtility.pm
*/
#if defined(UNIT_TEST)
  #define TST_RING_BUFFER_SIZE (1<<20)
#elif defined(FORCE_TST_RING_BUFFER_SCALE)
  #define TST_RING_BUFFER_SIZE (1<<FORCE_TST_RING_BUFFER_SCALE)
#elif defined(NEPTUNE_BB) || defined(NEPTUNE_BW_BB) || defined(LOW_COST_SUPPORT) || defined(__TST_USE_MINI_LOG_BUF__)
  #define TST_RING_BUFFER_SIZE (1<<13)
#elif defined(__UMTS_RAT__)
/* under construction !*/
  #if defined(MT6276)
/* under construction !*/
  #else
/* under construction !*/
  #endif  
#else
  #define TST_RING_BUFFER_SIZE (1<<15)
#endif


//Due to [MAUI_02866707][[Need Patch] 11A.W11.05 build error for SPARROW51V2_DEMO_gsm(GEMINI)], it is removed in 2011/01/27
#if defined(__MTK_INTERNAL__)
  #if defined(MT6251) //Per Shalyn's request
/* under construction !*/
/* under construction !*/
  #endif  //#if defined(MT6251)
#endif  //__MTK_INTERNAL__


//The length to skip if we want to erase the data in the PS ring buffer 
#define TST_RING_BUFFER_JUMP_LEN (1<<16)

#define TST_DONT_SAVE_FILTER_TOKEN (0x2454E677) //E677 == 0-0x1989

//extern UART_PORT   TST_PORT;
extern DCL_DEV   tst_L1Trc_port;
extern DCL_DEV   tst_PsTrc_port;
extern DCL_DEV   tst_rx_port;
extern UART_FLOW_CTRL_MODE_T tst_l1_flowCtrlMode;
extern UART_FLOW_CTRL_MODE_T tst_ps_flowCtrlMode;
extern UART_BAUDRATE_T tst_L1Trc_baudrate;
extern UART_BAUDRATE_T tst_PsTrc_baudrate;
extern kal_bool  tst_is_L1Trc_open;
extern kal_bool  tst_is_PsTrc_open;
//extern kal_bool  tst_is_uart_open;
extern kal_bool  tst_is_l1_writing_uart;/*protect UART Port from closing while writing*/
extern kal_bool  tst_is_ps_writing_uart;/*protect UART Port from closing while writing*/
extern kal_bool  tst_is_auto_memory_dump;

/*for close/open UART port in run time*/
extern kal_bool tst_is_uart_open;
extern kal_bool  tst_is_writing_uart;

extern kal_uint8  tst_ring_buffer[];
extern kal_uint32 tst_ptr_buffer_start;
extern kal_uint32 tst_ptr_buffer_end;

#define  MSG_ID_LOGGED_PRIMITIVE          0x0001
#define  MSG_ID_PS_INDEX_TRACE            0x0002
#define  MSG_ID_PROMPT_TRACE              0x0003
#define  MSG_ID_SYSTEM_TRACE              0x0004
#define  MSG_ID_READ_VARIABLE			  0x0005
#define  MSG_ID_SIM_REPORT				  0x0006
#define  MSG_ID_EXCEPTION_REPORT          0x0007
#define  MSG_ID_STATISTIC_REPORT          0x0008
#define  MSG_ID_READ_MEMORY               0x0009
#define  MSG_ID_VRT												0x000A
#define	 MSG_ID_VRSAMPLE_IND							0x000B
#define	 MSG_ID_QUERY_MEMORY_RANGE				0x000C
 
 
#define TST_MUX_BUFFER_SIZE 256

#define  INJECT_STRING_TO_MODULE_MAX_LENGTH  (128)
#define  INJECT_STRING_TO_TST_READER_MAX_LENGTH  (64)
#define  INJECT_AT_COMMAND_MAX_LENGTH        (128)

#ifndef UNIT_TEST
#define  MAX_TST_RECEIVE_BUFFER_LENGTH       256
#else
#define  MAX_TST_RECEIVE_BUFFER_LENGTH       (64*1024-1)
/*950105: In Monza, a frame may exceed the length of 32k,
 and TSTR should copy a whole frame (to tst_rcv_buf) one time from CShare in MNT.
 So, change it to 64KB.
*/
#endif  /* UNIT_TEST */

#define TST_ASSERT_RS232_BUFFER_LENGTH         1300

#ifndef UNIT_TEST
  #ifdef __UMTS_RAT__
/* under construction !*/
  #else //__UMTS_RAT__
    #define  MAX_TST_ASSERT_RECEIVE_BUFFER_LENGTH       256
  #endif  //__UMTS_RAT__
#else //#ifndef UNIT_TEST
  #define  MAX_TST_ASSERT_RECEIVE_BUFFER_LENGTH       (64*1024-1)
#endif  /* UNIT_TEST */

#define   MUX_KEY_WORD		    0x5A
#define   SOFT_FLOW_CTRL_BYTE   0x77

#define  ESC_NOT_DETECT 0
#define  ESC_DETECT     1


//RX
#define  RS232_LOGGED_PRIMITIVE_TYPE   0x60
#define  RS232_PS_TRACE_TYPE           0x61
#define  RS232_PS_PROMPT_TRACE_TYPE    0x62
#define  RS232_COMMAND_TYPE_OCTET      0x63
#define  RS232_INJECT_PRIMITIVE_OCTET  0x64
#define  RS232_INJECT_UT_PRIMITIVE     0x65
#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)
  #define  RS232_POSTMAN_COMMAND_TYPE_OCTET      0x99
#endif  //#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)
#define  RS232_INJECT_PRIMITIVE_OCTET_MD2 		 0xA0  // keep 0xA0 ~ 0xAF for multi modem
#define  RS232_INJECT_PRIMITIVE_OCTET_MAX		 0xAF

//TX
/* defined in kal_trace.h
#define LOGGED_PRIMITIVE_TYPE       0x60
#define PS_TRACE_INDEX_TRACE_TYPE   0x61
#define PS_PROMPT_TRACE_TYPE        0x62
#define CONTROL_COMMAND_TYPE        0x63
#define INJECT_PRIMITIVE_TYPE       0x64
#define SYS_TRACE_TYPE              0x65
#define LOGGED_PRIMITIVE_TYPE_MD2 	0xB0  // keep 0xB0 ~ 0xBF for multi modem
#define LOGGED_PRIMITIVE_TYPE_MAX   0xB7
#define SYS_TRACE_TYPE_MD2 			0xB8
#define SYS_TRACE_TYPE_MAX          0xBF
*/
#define  RS232_READ_VARIABLE_RETURN    0x66
#define  RS232_EM_DATA				   0x67
#define  RS232_SIM_DATA				   0x68
#define  RS232_EXCEPTION_DATA          0x69
#define  RS232_STATISTIC_DATA          0x70
#define  RS232_WAP_TRACE               0x71
#define  RS232_READ_MEMORY_REPORT      0x72
#define  RS232_VRT_DATA                0x73
#define  RS232_QUERY_MEMORY_RANGE      0x74
#define  RS232_QUERY_SOFT_FC_CHAR      0x75
#define  RS232_KDWP_PACKET             0x76
#define  RS232_CTI_PACKET              0x77
#define  RS232_REPORT_VERSION          0x78
#define  RS232_PS_RAWDATA_TRACE_TYPE   0x79
#define  RS232_PS_RAWDATA_TRACE2_TYPE  0x7A
#define  RS232_UBDB_RESPONSE           0x7B
#define  RS232_GDI_SNAPSHOT            0x7C
#define  RS232_SLEEP_MODE_RESPONSE     0x7D
#define  RS232_FILE_TRANSFER_REPORT    0x7E
#define  RS232_DYNAMIC_STACK_STATISTICS  0x7F
#define  RS232_ST_REPORT               0x80
#define  RS232_MA_SYS_TRACE_TYPE       0x81
#define  RS232_SIMPLE_ACK_TYPE         0x82
#define  RS232_VIRTUAL_CHANNEL         0x83
#define  RS232_PRIMITIVE_3G_CPHY_CONTAINER_TYPE       0x84
#define  RS232_PRIMITIVE_COMPRESSED_TYPE       0x85
#ifndef LOW_COST_SUPPORT
  #define  RS232_QUERY_HISR_NAME_TYPE       0x86
#endif  //#ifndef LOW_COST_SUPPORT
#define  RS232_QUERY_SWLA_EMI_CONFIG_TYPE 0x87
#if !defined(LOW_COST_SUPPORT) || defined(__AUTO_TCL__)
  #define RS232_FILE_SAVE_REPORT         0x88
#endif  //#if !defined(LOW_COST_SUPPORT) || defined(__AUTO_TCL__)
//RX token for internal trace
#define RS232_PS_INTERNAL_INDEX_TRACE 0x89
#define RS232_QUERY_CMD_ACK_REPORT 0x90
//#define RS232_QUERY_FCORE_MEMORY_RANGE 0x91
#define RS232_QUERY_SWLA_HEADER_REPORT 0x92
#define RS232_QUERY_BUF_MONITOR_REPORT 0x93
#define RS232_PS_BRIEF_TRACE 0x94
#define RS232_PS_BRIEF_INTERNAL_TRACE 0x95
#define RS232_PS_BRIEF_NO_MODULE_TRACE 0x96
#define RS232_PS_BRIEF_NO_MODULE_INTERNAL_TRACE 0x97
#define RS232_CATCHER_DATA_ACK 0x98
#define RS232_CATCHER_QUICK_SCR_CAPTURE_ACK 0x9b
#define RS232_SD_MEMORY_DUMP 0x9c
// keep 0xB0 ~ 0xBF for multi modem, and define in kal_trace.h
// TX ==>


/* Define the rs232 frame states */
#define  RS232_FRAME_STX               0
#define  RS232_FRAME_LENHI             1
#define  RS232_FRAME_LENLO             2
#define  RS232_FRAME_TYPE              3
#define  RS232_FRAME_COMMAND_DATA      4
#define  RS232_FRAME_COMMAND_HEADER    5
#define  RS232_FRAME_CHECKSUM          6
#define  RS232_FRAME_INJECT_PIRIMITIVE_HEADER 7
#define  RS232_FRAME_PRIM_LOCAL_PARA_DATA 8
#define  RS232_FRAME_PRIM_PEER_DATA    9
#define  RS232_FRAME_UT_DATA				10
#define  RS232_FRAME_KEYWORD			11
#define  RS232_FRAME_SOFT_CTRL         12
#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)
  #define  RS232_POSTMAN_COMMAND_TOKEN         13
  #define  RS232_POSTMAN_COMMAND_CMD_TYPE         14
  #define  RS232_POSTMAN_COMMAND_CMD_DATA         15
#endif  //#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)

#define  RS232_FRAME_INJECT_META_PIRIMITIVE_HEADER 16
#define  RS232_FRAME_META_PRIM_LOCAL_PARA_DATA 17
#define  RS232_FRAME_META_PRIM_PEER_DATA    18

#define  STX_OCTET            0x55

#if defined(__TST_LMU_LOGGING_WITH_PS_CRC__)
  #define PS_SHORT_LOG_OCTET 0x56
  #define PS_LONG_LOG_OCTET 0x57
#else //#if defined(__TST_LMU_LOGGING_WITH_PS_CRC__)
  #define PS_SHORT_LOG_OCTET 0x58
  #define PS_LONG_LOG_OCTET 0x59
#endif  //#if defined(__TST_LMU_LOGGING_WITH_PS_CRC__)

#define L1_LMU_LOG_OCTET 0xA6
#define  TST_ACCESS_EXCEPTION   1
#define  TST_ACCESS_STATISTIC   2


//Allow users to set the module filters for "END_OF_MOD_ID"
#define TST_MODULE_FILTER_LEN		((END_OF_MOD_ID+8)/8)

#define TST_SAP_FILTER_LEN			(LAST_SAP_CODE+1)

#define TST_TRACE_FILTER_LEN		(2*(END_OF_MOD_ID+1))


#define TST_TOTAL_FILTER_LEN    (TST_MODULE_FILTER_LEN+ TST_SAP_FILTER_LEN+ TST_TRACE_FILTER_LEN)
											

#define TST_TIMER_ID_POOL_QUERY 0
#define TST_TIMER_ID_PSLOG_IDLE 1
#define TST_TIMER_ID_USB_DMA_Enable 2
#define TST_TIMER_ID_LMU_SYNC 3

#define __TST_META_MODE_TRACE_ENABLE__  // for MOD_FT 

//Init commands 
//#define INIT_CMDS_RESEND_EXCEPTION_INFO	0
//#define INIT_CMDS_MEMORY_DUMP_SWITCH	1
//#define INIT_CMDS_QUERY_SWLA_HEADER		2
//#define INIT_CMDS_ECHO_SIM_MAPPING		3
typedef enum
{
  INIT_CMDS_RESEND_EXCEPTION_INFO = 0,
  INIT_CMDS_MEMORY_DUMP_SWITCH,
  INIT_CMDS_QUERY_SWLA_HEADER,
  INIT_CMDS_QUERY_TARGET_VERSION,
  INIT_CMDS_ECHO_SIM_MAPPING,
	INIT_CMDS_QUERY_LOAD_VERSION,
	INIT_CMDS_QUERY_CALIBRATION,
	INIT_CMDS_QUERY_SWLA_INFO
}
tst_init_cmd_set_enum_t;

typedef enum
{
  TST_NULL_COMMAND                          = 0x00,
  TST_LOG_ON_OFF                            = 0x01,
  TST_SET_PRIM_MOD_FILTER                   = 0x02,
  TST_SET_PRIM_SAP_FILTER                   = 0x03,
  TST_SET_PS_TRC_FILTER                     = 0x04,
  TST_SET_L1_TRC_FILTER                     = 0x05,
  TST_INJECT_STRING_TO_MODULE               = 0x06,
  TST_INJECT_AT_CMD                         = 0x07,
  TST_REBOOT_TARGET_CMD                     = 0x08,
#if defined(UNIT_TEST) || defined(UT_ON_TARGET)  
  TST_SET_TRAP_FILTER                       = 0x09,
#endif  //#if defined(UNIT_TEST) || defined(UT_ON_TARGET)  
  TST_READ_GLOBAL_VARIABLE                  = 0x0A,
  TST_WRITE_GLOBAL_VARIABLE                 = 0x0B,
#ifdef __EM_MODE__  
  TST_EM_MODE_CONFIG                        = 0x0C,
#endif  //#ifdef __EM_MODE__  
#if !defined(__L1_STANDALONE__)&&!defined(LOW_COST_SUPPORT)
  TST_SIM_FILE_INFO_REQ                     = 0x0D,
  TST_SIM_READ_REQ                          = 0x0E,
  TST_SIM_WRITE_REQ                         = 0x0F,
#endif  //#if !defined(__L1_STANDALONE__)&&!defined(LOW_COST_SUPPORT)  
  TST_FT_MODE_CONFIG                        = 0x10,
#ifndef __L1_STANDALONE__  
  TST_NVRAM_EXCEPTION_CMD                   = 0x11,
  TST_NVRAM_STATISTIC_CMD                   = 0x12,
#endif  //#ifndef __L1_STANDALONE__  
  TST_READ_MEMORY_ADDR_CMD                  = 0x13,
  TST_QUERY_MEMORY_RANGE_CMD                = 0x14,
  TST_FORCE_ASSERT_CMD                      = 0x15,
  //TST_QUERY_SOFT_FC_CHAR_CMD                = 0x16,   //phased out
#ifdef KDWP_DEBUG    
  TST_KDWP_RECV_CMD                         = 0x17,
  TST_KDWP_CONTROL_CMD                      = 0x18,
#endif  //#ifdef KDWP_DEBUG    
  TST_FLUSH_SWDBG_CMD                       = 0x19,
  TST_CTI_COMMAND_CMD                       = 0x1A,
  TST_WRITE_MEMORY_CMD                      = 0x1B,
#if (defined(PLUTO_MMI) && (!defined(LOW_COST_SUPPORT)))  
  TST_GDI_SNAPSHOT_CMD                      = 0x1C,
#endif  //#if (defined(PLUTO_MMI) && (!defined(LOW_COST_SUPPORT)))  
  TST_SLEEP_MODE_CMD                        = 0x1D,
#if !defined(LOW_COST_SUPPORT) || defined(__AUTO_TCL__)
  TST_FILE_TRANSFER_CMD                     = 0x1E,
#endif //#if !defined(LOW_COST_SUPPORT) || defined(__AUTO_TCL__)
#ifdef _MAUI_TST_MODELING_    
  TST_CONFIG_SWLA_CMD                       = 0x1F,
#endif  //#ifdef _MAUI_TST_MODELING_  
#if defined(__MAUI_SOFTWARE_TRACER__)                 
  TST_ST_START_CMD                          = 0x20,
  TST_ST_STOP_CMD                           = 0x21,
#endif  //#if defined(__MAUI_SOFTWARE_TRACER__)                 
#if defined(UNIT_TEST) || defined(UT_ON_TARGET)                  
  TST_SET_TRAP_MSG_CMD                      = 0x22,
#endif  //#if defined(UNIT_TEST) || defined(UT_ON_TARGET)                    
#ifndef __L1_STANDALONE__    
  TST_REBOOT_FOR_MMI_AUTO_TEST_CMD          = 0x23,
#endif  //#ifndef __L1_STANDALONE__      
#if (defined(__UMTS_RAT__) && (!defined(__L1_STANDALONE__)))
/* under construction !*/
#endif  //#if (defined(__UMTS_RAT__) && (!defined(__L1_STANDALONE__)))  
#if defined(__UMTS_RAT__) && (!defined(UNIT_TEST)) && defined(__UMTS_FDD_MODE__)                
/* under construction !*/
#endif  //#if defined(__UMTS_RAT__) && (!defined(UNIT_TEST)) && defined(__UMTS_FDD_MODE__)                  
  TST_VC_CMD                                = 0x26,
  TST_SIMPLE_CMD                            = 0x27,  
#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && (defined(MT6236) || defined(MT6268))      
/* under construction !*/
#endif  //#if defined(__MTK_INTERNAL__) && defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__) && (defined(MT6236) || defined(MT6268))      
#if !defined(LOW_COST_SUPPORT) || defined(__AUTO_TCL__)
  TST_FILE_SAVE_CMD                         = 0x29,  //save file to the target
#endif  //#if !defined(LOW_COST_SUPPORT) || defined(__AUTO_TCL__)  
#if defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__)  
  TST_SWLA_START_CMD                        = 0x2A,
  TST_SWLA_STOP_CMD                         = 0x2B,
#endif  //#if defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__)  
  TST_SWLA_QUERY_HEADER_CMD                 = 0x2C,
#if defined(UNIT_TEST) && defined(__FLC2__) && defined(DEBUG_KAL) && defined(DEBUG_BUF2)  
  TST_QUERY_CTRL_BUF_MONITOR_DATA_CMD       = 0x2D,
  TST_QUERY_FLC_BUF_MONITOR_DATA_CMD        = 0x2E,
#endif  //#if defined(UNIT_TEST) && defined(__FLC2__) && defined(DEBUG_KAL) && defined(DEBUG_BUF2)
#if !defined(UNIT_TEST) && defined(MTK_SLEEP_ENABLE)  
  TST_WDT_IRQ_ENABLE_CMD                    = 0x2F,
#endif  //#if !defined(UNIT_TEST) && defined(MTK_SLEEP_ENABLE)  
  TST_CATCHER_CONNECT_CMD                   = 0x30,
  TST_CATCHER_DATA_LOOPBACK_CMD             = 0x31,  
#ifdef VOICE_RECOGNITION_TEST  
  TST_VRT_CMD                               = 0x32, 
#endif    //#ifdef VOICE_RECOGNITION_TEST  
  TST_SET_DSP_FILTER_CMD                    = 0x33,  
  TST_INJECT_STRING_TO_TST_READER           = 0x34,
#if defined(UNIT_TEST) || defined(UT_ON_TARGET)  
  TST_SET_TRAP_FILTER_ALL                   = 0x37,
#endif  //#if defined(UNIT_TEST) || defined(UT_ON_TARGET)    
  TST_QUICK_CAPTURE_SCREEN_CMD              = 0x38,
#if defined(__MTK_TARGET__) && !defined(__MAUI_BASIC__)  
  TST_SWLA_DEFAULT_START_ENABLE_CMD							= 0x39,
  TST_SWLA_DEFAULT_START_DISABLE_CMD						= 0x3A,
#endif
#ifdef __SMART_PHONE_MODEM__
  TST_SP_CONFIG_CMD = 0x3E,
#endif //#ifdef __SMART_PHONE_MODEM__
  TST_COMMAND_TYPE_LAST_CMD
  
}
tst_command_type;


#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)
typedef enum
{
  TST_POSTMAN_NULL_COMMAND,
	TST_POSTMAN_READ_MEM_COMMAND = 0x20600001,	
	TST_POSTMAN_WRITE_MEM_COMMAND = 0x20600002,
	TST_POSTMAN_READ_NVRAM_COMMAND = 0x20600003,	
	TST_POSTMAN_WRITE_NVRAM_COMMAND = 0x20600004,	
	TST_POSTMAN_REBOOT_COMMAND = 0x20600005,	
	TST_POSTMAN_COMMAND_TYPE_LAST_CMD
}
tst_postman_command_type;
#endif  //#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)

typedef struct
{
    kal_uint8   dummy;    
}
tst_command_type_last_cmd_struct;


typedef struct
{
    void        *address;
    kal_uint32  length;
    kal_uint8   token;  
    kal_uint32 mem_type;  
	kal_uint32 access_type; //Note if this filed is 0x24540000/0x24540001/0x24540002, it will force TST to read target memory by 1/2/4 bytes
}
tst_read_memory_addr_cmd_struct;


//typedef kal_uint8 tst_catcher_connect_cmd_struct;
typedef struct
{
  kal_bool connect; //KAL_FALSE: disconnect, KAL_TRUE: connect
  kal_uint32 init_cmds;
}
tst_catcher_connect_cmd_struct;

typedef struct
{
    void        *address;
    kal_uint32  length;
    kal_uint8   data[1];
}
tst_write_memory_cmd_struct;

typedef struct
{
    kal_uint32  token;
}
tst_gdi_snapshot_cmd_struct;
	
typedef struct
{
    kal_uint32  token;
    kal_uint8   cmd;
}
tst_sleep_mode_cmd_struct;


typedef struct
{   
    kal_uint32  token;
    kal_uint32  start_address; //if 0xFFFFFFFF => to delete the file
    kal_uint32  buf_length;
    kal_uint8   buf[1];	// full path
}
tst_file_transfer_cmd_struct;
typedef struct
{
	  kal_uint8   token;
	  kal_uint8   command; //0: db_reset, 1:db_write, 2:db_read, 3:db_delete
	                       //4: db_snap, 5:db_exist
    kal_uint16  length;
    kal_uint8   buf[1];
}
tst_ubdb_cmd_struct;

typedef struct {
  char filter[32];
}
tst_set_3g_filter_cmd_struct;

typedef struct
{
   kal_uint8     token;
   kal_uint8     command;
   kal_uint16     length;
}
tst_ubdb_response_header_struct;

typedef struct
{
   kal_uint8     token;
   kal_uint8     command;
   kal_uint16     length;
   kal_uint8     buf[1];
}
tst_ubdb_response_struct;

typedef struct
{   
    kal_uint32  token;
    kal_uint8   mode;	// 0: assert when tst ring buffer is full, 
                      // 1: when the rest of tst ring buffer is under the threshold, call SLA_TriggerLogging
                      // 2. disable both
    kal_uint8    threshold;
}
tst_config_swla_cmd_struct;



typedef struct
{   
  kal_uint32 mem_type_num;
  kal_uint8	token;
  kal_bool last;
}
tst_query_memory_range_report_header_struct;


typedef struct
{   
  kal_uint32 mem_type_num;
  kal_uint8 token;
  kal_bool last;
  kal_uint32	buf[1];
}
tst_query_memory_range_report_struct;

typedef struct
{   
    kal_uint32  fc_chars;
}
tst_query_soft_fc_char_report_struct;

typedef struct
{   
    kal_uint8   token;
    kal_uint8   encoded; //0 for not encoded, 1 for encoded with RLE
    const void  *address;
    kal_uint32  length;
    kal_uint32 mem_type;  
} tst_read_memory_addr_report_header_struct;


typedef struct
{   
    kal_uint8   token;
    kal_uint8   encoded; //0 for not encoded, 1 for encoded with RLE
    const void  *address;
    kal_uint32  length;
    kal_uint32 mem_type;  
    kal_uint8  buf[1];
} tst_read_memory_addr_report_struct;


typedef struct
{   
    kal_uint32  time_stamp;    
	kal_uint32  token;
    kal_uint16  status;
    kal_uint8   layer_count;
    kal_uint8   drive_index;
    kal_uint16  clip_index;
    kal_uint32  clip_length;
}
tst_gdi_snapshot_report_header_struct;

typedef struct
{       
    kal_uint32  time_stamp;    
	kal_uint32  token;
    kal_uint16  status;
    kal_uint8   layer_count;
    kal_uint8   drive_index;
    kal_uint16  clip_index; //0xFFFF: end of a series of clips
    kal_uint32  clip_length;
    kal_uint8   buf[1];
}
tst_gdi_snapshot_report_struct;
/*
tst_gdi_snapshot_report_struct.status
0 => Normal Mode, success
1 => MNT
2 => ASSERT MODE
3 => Failed to close the log file
4 => Failed at FS_Write
5 => Failed to dump jpeg file (gdi_layer_save_jpeg_file)
6 => No Space To Save
7 => Failed to open or create the file
*/



typedef enum
{
	TSCT_USB_LOGGING_CONNECT,
	TSCT_USB_LOGGING_DISCONNECT,
	TSCT_DNT_LOGGING_CONNECT,		//3G logging on DNT
	TSCT_DNT_LOGGING_DISCONNECT, //3G logging on DNT
	//... for use in the future
	TSCT_LAST_ID
}
tst_simple_command_type;

typedef struct {
  kal_uint16 token;
  tst_simple_command_type  cmd;
}
tst_simple_cmd_struct;

typedef struct
{   
  kal_uint16 token;
  tst_simple_command_type  cmd;
}
tst_simple_ack_struct;
   
typedef enum
{
   NVRAM_READ,
   NVRAM_RESET,
   NVRAM_WRITE,
   NVRAM_RESET_FLAG,
   NVRAM_READ_DYNAMIC
}
nvram_actions; 

typedef struct
{
    nvram_actions act;
}    
tst_nvram_exception_cmd_struct;

typedef struct
{
    nvram_actions act;    
}
tst_nvram_statistic_cmd_struct;


#ifdef VOICE_RECOGNITION_TEST
#ifndef MAX_VM_FILE_NAME
#define MAX_VM_FILE_NAME 20
#endif /*MAX_VM_FILE_NAME*/

typedef struct
{
	kal_uint8 message_type;
	kal_uint16	clip_index;
}
tst_vrt_cmd_struct;

#endif /*VOICE_RECOGNITION_TEST*/

#ifndef LOW_COST_SUPPORT
//This structure is used to keep the HISR name
//every HISR name has at most 8 bytes
typedef struct
{
	kal_uint32 HISR_pair_num;
	kal_char HISR_Name[KAL_MAX_NUM_HISRS*STACK_STATS_HISR_MAX_NAME];	
}
tst_HISR_name_struct;

typedef struct
{
	stack_statistics_struct statistic;
	tst_HISR_name_struct hisr_name_struct;
}
tst_stack_statistics_struct;
#endif  //#ifndef LOW_COST_SUPPORT 
    
typedef struct
{
    kal_uint8   enable;    
}
tst_ft_mode_config_struct;


typedef struct
{
#ifdef __EM_MODE__
	em_info_status_enum  info_request[NUM_OF_EM_INFO];
	kal_uint32 sim_selection;   //Accompanied with one option in Catcher_Version_Info_Enum (CATCHER_EM_MULTIPLE_SIM_ENABLE)
#else	//#ifdef __EM_MODE__
  //The reason we keep the old declaration here is that we don't want to change the order of tst_command_type
  //MLT uses the flake database
  kal_uint8 enable;
#endif	//#ifdef __EM_MODE__
}
tst_em_mode_config_struct;

typedef struct
{
	kal_uint32 sim_num;
	kal_uint16 file_idx;
	kal_uint8 file_path[6];
}
tst_sim_file_info_req_struct;

typedef struct
{
	kal_uint32 sim_num;
	kal_uint16	file_idx;
	kal_uint16	para;
	kal_uint16	length;
	kal_uint8 file_path[6];
}
tst_sim_read_req_struct;

typedef struct
{
	/* Check the 260 is a constant */
	kal_uint32 sim_num;
	kal_uint16	file_idx;
	kal_uint16	para;
	kal_uint8	data[260];
	kal_uint16	length;
	kal_uint8 file_path[6];
}
tst_sim_write_req_struct;


typedef struct
{
    kal_uint32	token;
    kal_char	data[1];
}
tst_read_global_variable_struct;

typedef struct
{
    kal_uint16		size1;
    kal_uint16		size2;
}
tst_write_global_variable_struct;

typedef struct
{
   kal_uint8	token;
   kal_uint16  size;
   kal_char    data[1];
}
tst_gv_return;

typedef struct
{
	kal_uint8	token;
   kal_uint16  size;
}
tst_gv_header_struct;



typedef kal_uint8 tst_null_command_struct ;

typedef kal_uint8 tst_set_l1_trc_filter_struct;

typedef kal_uint8 tst_reboot_target_cmd_struct;

typedef kal_uint8 tst_query_memory_range_cmd_struct;

typedef kal_uint8 tst_query_soft_fc_char_cmd_struct;

typedef kal_uint8 tst_force_assert_cmd_struct;

typedef kal_uint8 tst_flush_swdbg_cmd_struct;

typedef kal_uint8 tst_st_stop_cmd_struct;

typedef kal_uint8 tst_reboot_for_mmi_auto_test_cmd_struct;

typedef struct
{
   kal_bool    is_logging;
}
tst_log_on_off_struct;

typedef struct
{
   kal_uint8   mod_filter[TST_MODULE_FILTER_LEN];
}
tst_set_prim_mod_filter_struct;

typedef struct
{
   kal_uint8   sap_filter[TST_SAP_FILTER_LEN];
   kal_uint32 index;
}
tst_set_prim_sap_filter_struct;

typedef struct
{
	kal_uint16 	sap_id;
	kal_uint8   is_trap;
}
tst_set_trap_filter_struct;

typedef struct
{
	kal_uint8   trap_filter[(LAST_SAP_CODE+7)/8];
}
tst_set_trap_filter_all_struct;

typedef struct
{
   kal_uint16  sap_filter[END_OF_MOD_ID+1];
}tst_set_ps_trc_filter_struct;


typedef struct
{
   module_type    dest_mod;
   kal_uint8      index;
   kal_uint8      string[INJECT_STRING_TO_MODULE_MAX_LENGTH];
}tst_inject_string_to_module_struct;

typedef struct
{
   module_type    dest_mod;
   kal_uint8      index;
   kal_uint8      string[INJECT_STRING_TO_TST_READER_MAX_LENGTH];
}tst_inject_string_to_tst_reader_struct;

typedef struct
{
   kal_uint8   ref_count;
   kal_uint16  params_len;
   kal_uint8   index;
   kal_uint8   string[INJECT_STRING_TO_MODULE_MAX_LENGTH];
}
tst_inject_string_struct;




typedef struct
{
   kal_uint8      atcmd[INJECT_AT_COMMAND_MAX_LENGTH];
}tst_inject_at_cmd_struct;

typedef struct {
	kal_uint32	m_CmdCount;
} tst_set_dsp_filter_cmd_struct;

typedef struct {
	void        *m_Addr;
	kal_uint16	m_Value;
} tst_dsp_command;

typedef struct
{
   kal_uint32     time_stamp;
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;
   kal_uint32     local_addr;
   kal_uint32     peer_addr;
}
tst_log_prim_header_struct;


typedef struct
{
   //<== tst_log_prim_header_struct 
   kal_uint32     time_stamp;
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;
   kal_uint32     local_addr;
   kal_uint32     peer_addr;
   // tst_log_prim_header_struct ==>
     
   kal_uint8      offset[2];  /*local param, peer buffer*/
   kal_uint16     org_len[2]; /*local param, peer buffer, 0 means this part is not compressed*/   
}
tst_log_prim_header_compressed_struct;

//Shengkai: 2009-03-19 revise cphy_msg_container_req_struct
//Add two more field
//5: buffer 0..3, peer buffer
//9: buffer 0..3, h_msg_buffer[2], e_msg_buffer[2]
#define TST_CPHY_CONTAINER_MSG_FIELD_LEN 9  
typedef struct
{
   kal_uint32     time_stamp;
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;   /*compressed length*/
   kal_uint32     local_addr;
   kal_uint32     peer_addr;
   kal_uint8      offset[TST_CPHY_CONTAINER_MSG_FIELD_LEN];  /*secondary buffer 0..3, peer buffer*/
   kal_uint16     cpr_len[TST_CPHY_CONTAINER_MSG_FIELD_LEN]; /*compressed length*/
   kal_uint16     org_len[TST_CPHY_CONTAINER_MSG_FIELD_LEN]; /*secondary buffer 0..3, peer buffer*/   
}
tst_log_prim_header_cphy_container_struct;

typedef struct
{
   kal_uint32     frame_number;
   kal_uint32     time_stamp;
   kal_uint8    src_mod_id; //module_type
   kal_uint8    dest_mod_id; //module_type
   kal_uint8      sap_id; //sap_type
   kal_uint8	padding;
   kal_uint16       msg_id; //msg_type
   kal_uint16     local_len;
   kal_uint16     peer_len;
}
tst_log_prim_header_factory_mode_struct;

typedef struct
{
  kal_uint32        time_stamp; 
  kal_uint32        msg_index;
  trace_class_enum  trace_class;
#ifdef __GEMINI__
/* under construction !*/
#endif  //#ifdef __GEMINI__
}
tst_index_trace_header_struct;

typedef struct
{
   kal_uint32     time_stamp;
   kal_uint32     msg_index;
   trace_class_enum  trace_class;
   kal_uint16     rawdata_length;
}
tst_rawdata_trace2_header_struct;

typedef struct
{
  kal_uint32  time_stamp;
	kal_uint32 token;
	kal_uint8 status;
}
tst_sleep_mode_report_struct;

typedef struct
{   
    kal_uint32  time_stamp;
    kal_uint32  token;
    kal_uint32  start_address;//0xFFFFFFFF , to delete the file
    kal_uint32  path_length;
    kal_uint32  data_length; //0: end-of-file or file deleted
    //kal_uint8   buf[1];	// path + file content
}
tst_file_transfer_report_header_struct;

typedef struct
{   
    kal_uint32  time_stamp;
    kal_uint32  token;
    kal_uint32  start_address;
    kal_uint32  path_length;
    kal_uint32  data_length;
    kal_uint8   buf[1];	// path + file content
}
tst_file_transfer_report_struct;

typedef struct
{   
    kal_uint32          time_stamp;
    kal_uint32  buf_length; //sizeof(stack_statistics_struct)
}
tst_dynamic_stack_statistics_header;

#ifndef LOW_COST_SUPPORT
//Shengkai: add the header for HISR name report
typedef struct
{   
    kal_uint32          time_stamp;
    kal_uint32 buf_length; //sizeof(stack_statistics_struct)
}
tst_query_HISR_name_header;
#endif  //#ifndef LOW_COST_SUPPORT

typedef struct
{   
    kal_uint32          time_stamp;
    kal_uint32  buf_length; //sizeof(stack_statistics_struct)
    kal_uint8   buf[1]; //stack_statistics_struct
}
tst_dynamic_stack_statistics;


typedef struct
{   
	  //ST_input_struct
    kal_int32 trace_time_scale;
    kal_bool all_task; 
    kal_bool trace_register;
    kal_bool trace_call_stack;
    kal_bool trace_data; 
    kal_int32 task_filter[6];
    kal_int32 trace_stack_size;
    kal_int32* data_address[16];
    kal_int32 reserved[16];
}
tst_st_start_cmd_struct;

typedef struct
{   
    kal_uint32  time_stamp;
    //ST_return_struct
    kal_int32 start_time1;
    kal_int32 start_time2;
    kal_int32* buffer_start_addr;
    kal_int32* buffer_end_addr;
    kal_int32* buffer_current_index_addr;
    kal_int32 time_scale_for_one_sec;
    kal_int32 reserved[4];
    kal_bool buffer_wrap_around;
}
tst_st_report_struct;

typedef struct
{
  kal_uint32          time_stamp;
  module_type         module_id;
  trace_class_enum    trace_class;      
}
tst_wap_trace_header_struct;

//Kevin: merge wap trace and prompt trace
typedef tst_wap_trace_header_struct tst_prompt_trace_header_struct;


typedef struct
{
   kal_uint32     frame_number;   
   kal_uint32     time_stamp;
   kal_uint16     buf_length;
}
tst_sys_trace_header_struct;


typedef struct
{
   tst_command_type  command_type;
   kal_uint16        cmd_len;
}
tst_command_header_struct;


typedef struct
{
   tst_command_header_struct  command;
   kal_uint16                 received_cmd_length;
   kal_uint16                 received_data_length;
   kal_uint8                  *header_buf;
   kal_uint8                  *command_buf;
}
tst_current_handle_command;


typedef struct
{
   kal_uint8    src_mod_id; //module_type
   kal_uint8    dest_mod_id;  //module_type
   kal_uint8       sap_id; //sap_type
   kal_uint16       msg_id; //msg_type
   kal_uint16     local_len;
   kal_uint16     peer_len;
}
tst_inject_factory_primitive_header_struct;

typedef struct
{
   module_type    src_mod_id;
   module_type    dest_mod_id;
   sap_type       sap_id;
   msg_type       msg_id;
   kal_uint16     local_len;
   kal_uint16     peer_len;
}
tst_inject_primitive_header_struct;


typedef struct
{
   tst_inject_primitive_header_struct inject_prim;
   kal_uint16     received_prim_header_length;
   kal_uint16     received_prim_local_para_length;
   kal_uint16     received_prim_peer_length;
   kal_uint8      *header_ptr;
   kal_uint8      *local_ptr;
   kal_uint8      *peer_ptr;
}
tst_current_handle_primitive;

typedef struct
{
   tst_inject_factory_primitive_header_struct inject_prim;
   kal_uint16     received_prim_header_length;
   kal_uint16     received_prim_local_para_length;
   kal_uint16     received_prim_peer_length;
   kal_uint8      *header_ptr;
   kal_uint8      *local_ptr;
   kal_uint8      *peer_ptr;
}
tst_current_handle_factory_primitive;

#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)
typedef struct
{
   kal_uint32 bytesToRead;
   kal_uint32 token;
   kal_uint32 cmd_type; //tst_postman_command_type   
   kal_uint32 cmd_len;
   kal_uint8 *cmd_data;
   kal_uint8 *cmd_data_ptr;
}
tst_current_handle_postman_command;
#endif  //#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)

typedef struct {
    kal_uint16		no_peer_buff_ptr;
    kal_uint16		peer_buff_ptr_size;
    kal_uint8		*peer_buff_ptr;
    kal_uint8		ref_count;
    kal_uint8		header_len;
    kal_uint8		tail_len;
    kal_uint8		unused1;
} asn_peer_buff_struct;

typedef struct {
    kal_uint8		ref_count;
    kal_uint16		no_local_params_ptr;
    kal_uint16		local_params_ptr_size;
    kal_uint8		*local_params_ptr;
} asn_local_para_struct;

typedef struct {
    module_type	    src_mod_id;
    module_type	    dest_mod_id;
    sap_type		sap_id;
    msg_type		msg_id;
    asn_local_para_struct	local_params;
    asn_peer_buff_struct	peer_buff;
} ilmessage;


typedef struct
{
	kal_uint16	received_data_length;
	kal_uint16  data_length;
	kal_char	*data;
	kal_char    *iterator;
}
tst_current_handle_ut_primitive;


typedef union
{
    tst_current_handle_command			command;
    tst_current_handle_primitive		primitive;
    tst_current_handle_ut_primitive	    ut_primitive;
#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)
    tst_current_handle_postman_command postman_cmd;
#endif  //#if defined(__TST_DCC_ENABLED__) && defined(__TST_POSTMAN_SUPPORT__)    
    tst_current_handle_factory_primitive		meta_prim;
}
tst_current_handle_rs232_frame;

typedef struct
{
	const kal_uint8* pTraceHeader;
	const kal_uint8* pData;
	const kal_uint8* pData2;
	kal_uint32 lenTraceHeader;
	kal_uint32 lenData;
	kal_uint32 lenData2;
	kal_uint32 frameMessageType;
}
tst_trace_frame_arg;

typedef struct
{
	const kal_uint8* pTraceHeader;
	const kal_uint8* pData;
	const kal_uint8* pData2;
	kal_uint32 lenTraceHeader;
	kal_uint32 lenData;
	kal_uint32 lenData2;
	kal_uint32 frameMessageType;
	kal_uint8 pTraceAccessType;
	kal_uint8 pDataAccessType;
	kal_uint8 pData2eAccessType;
}
tst_trace_exception_frame_arg;

#define STAT_TYPE_SIZE 3
#define STAT_ALLOCA_TYPE_SIZE 4 //alloceted size for tst_ps_lost_count[]
#define STAT_TYPE_TRACE 0
#define STAT_TYPE_PRIMITIVE 1
#define STAT_TYPE_OTHER 2
#define STAT_BUFFER_SLOT_SIZE 7


typedef struct
{
	kal_uint32 count_on; //0 for OFF, non-zeor for ON
	kal_uint32 count_log[STAT_TYPE_SIZE];
	kal_uint32 count_lost[STAT_TYPE_SIZE];
	kal_uint32 count_lost_no_buffer[STAT_TYPE_SIZE][STAT_BUFFER_SLOT_SIZE];
	kal_uint32 count_lost_full_queue[STAT_TYPE_SIZE];
}
tst_statistics_struct;

//[maggie]
typedef struct
{
	kal_uint32 type_count[STAT_TYPE_SIZE];
	kal_uint32 lost_size;
	kal_uint32 request_size;
}
tst_usage_statistics_struct;

#ifdef KDWP_DEBUG   
//<-- for KDWP
#define KDWP_CATCHER_SWITCH_ON       1
#define KDWP_CATCHER_SWITCH_OFF      2
#define KDWP_CATCHER_SOCKET_HOOKED   3
#define KDWP_CATCHER_SOCKET_UNHOOKED 4

#define KDWP_KVM_START_SESSION     0
#define KDWP_KVM_END_SESSION       1
#define KDWP_KVM_DATA_MID          2
#define KDWP_KVM_DATA_END          3

extern kal_bool tst_java_debug_mode;
extern kal_bool tst_java_debug_hooked;

extern kal_bool tst_kdwp_start_session(void);
extern kal_bool tst_kdwp_end_session(void);
extern kal_bool tst_kdwp_send(const kal_uint8 *pData, kal_uint32 nLen, kal_bool bEnd);
#endif  //#ifdef KDWP_DEBUG   

typedef struct
{
   kal_uint32     buf_length;
}
tst_kdwp_packet_header_struct;

typedef struct
{
   kal_uint32     buf_length;
}
tst_cti_response_header_struct;

typedef struct
{
    kal_uint8* pData;
}    
tst_kdwp_recv_cmd_struct;

typedef struct
{
    kal_uint8* pData;
}    
tst_cti_command_cmd_struct;

typedef struct
{
   kal_uint8    kdwp_control;
}
tst_kdwp_control_cmd_struct;
//-- for KDWP -->

//for MSG_ID_TIMER_EXPIRY
typedef stack_timer_struct timer_expiry_struct;

//for query HW version and SW version
typedef struct
{
	kal_uint16 nHWVerLen;
	kal_uint16 nSWVerLen;
}
tst_report_version_header_struct;


//=================== For GDI Logger
typedef struct
{
	kal_int32  nFreeSpace[4]; //max number of drives (no system drives)
	kal_uint8  ucDrive[4];//drive letter
	kal_uint32 nGDIFileSN;
	//kal_uint8  nFormat; //0: raw, 1: jpeg, 2: unknown 
  WCHAR strFSName[32];//i.e. X:\GDILog\00000.log
  kal_uint8 fsBuf[512];
  tst_gdi_snapshot_report_header_struct	trace_header;  
}
tst_gdi_logger_context_struct;

extern void tst_switch_sleep_mode(kal_uint32 token, kal_uint32 cmd);
extern void tst_dump_file_clip(const tst_file_transfer_cmd_struct *pCmd);
kal_uint32 tst_RLE_Encode(kal_uint32 nBytesPerPixel, const kal_uint8* pRawDataBuffer, kal_uint32 RawDataLength, kal_uint8* pOutputBuffer, kal_uint32 *pOutputLength, kal_uint32 *pReadLength);

//===================

typedef struct
{
  kal_uint16  nCount;
  kal_uint16  MsgIDs[1];
}    
tst_set_trap_msg_cmd_struct;


//<==== Virtual Channel
typedef struct
{
   kal_uint8      channel_id;
   kal_uint32     buf_length;
}
tst_vc_packet_header_struct;

typedef struct
{
    kal_uint8     channel_id;
    kal_uint8     pData[1];
}    
tst_vc_cmd_struct;
// Virtual Channel ===>

extern kal_uint32 L1I_GetTimeStamp(void);
#define L1I_GET_TIMESTAMP L1I_GetTimeStamp

//select the emi monitor master command
#define TST_SWLA_EMI_MONITOR_MASTER_NUM 3
typedef struct
{
  kal_uint16 master_select[TST_SWLA_EMI_MONITOR_MASTER_NUM];  
}
tst_swla_emi_monitor_master_select_cmd_struct;

typedef enum
{
  TST_FS_DELETE_FILE = -1,
  TST_FS_ALWAYS_CREATE,
  TST_FS_APPEND_END,
  TST_FS_SEEK_AND_APPEND
}
tst_file_save_action_t;

typedef struct
{
  kal_uint32 token;
  tst_file_save_action_t action;  //0: create, 1: append to the end, 2. open and append the seek pos, 0xFFFFFFFF: delete
  kal_int32 seek_pos;  
  kal_uint32 data_len;  //the total length of data[1] array
  kal_uint32 content_offset;  //the offset of file content start in the data[1] array
  kal_uint8 data[1];  //file path name and file content segment
}
tst_file_save_cmd_struct;

typedef struct
{
  kal_uint32  time_stamp;
  kal_uint32 token;
  kal_uint32 action;  //0: create, 1: append to the end, 2. open and append the seek pos, 0xFFFFFFFF: delete
  kal_uint32 fill_data_len;  
}
tst_file_save_report_headerstruct;

typedef struct
{
  kal_uint32 token; //indicate the transaction id  
  kal_bool enable;  //specify if we would like to enable/disable SWLA
}
tst_swla_start_cmd_struct;

typedef tst_swla_start_cmd_struct tst_swla_stop_cmd_struct;
typedef tst_swla_start_cmd_struct tst_swla_default_start_enable_cmd_struct;
typedef tst_swla_start_cmd_struct tst_swla_default_start_disable_cmd_struct;

typedef struct
{
  kal_uint32 token; //token number to the original request
  tst_command_type ack_cmd_type;  // the cmd to be acked
  kal_uint32 return_code; // a simple code for the execution result 
  kal_uint32 lenData;
  kal_uint32 lenData2;
  kal_uint8* pData;
  kal_uint8* pData2;
}
tst_general_query_cmd_ack_parameter_list_struct;

typedef struct
{
  kal_uint32  time_stamp;
  kal_uint32 token; //token number to the original request
  tst_command_type ack_cmd_type;  // the cmd to be acked
  kal_uint32 return_code; // a simple code for the execution result
}
tst_general_query_cmd_ack_report_struct;

typedef kal_uint8 tst_swla_query_header_cmd_struct;

typedef struct
{
  kal_uint32 main_desc_len;
  kal_uint32 addon_desc_len;
  kal_uint32 init_blk_len;
}
tst_swla_query_header_report;

typedef struct
{
  kal_uint32 token;  
}
tst_query_ctrl_buf_monitor_data_cmd_struct;

typedef struct
{
  kal_uint32 token;  
}
tst_query_flc_buf_monitor_data_cmd_struct;

typedef struct
{       
    kal_uint32  token;
    kal_uint32  ack_type; //0: ctrl buffer, 1: flc buffer    
    kal_uint32  path_length;    
    kal_uint8   buf[1];	// path + file content
}
tst_query_buf_monitor_report_struct;

typedef struct
{
  kal_uint32 token; //indicate the transaction id  
  kal_bool enable;  //specify if we would like to enable/disable WDT IRQ
}
tst_wdt_irq_enable_cmd_struct;

//Define structure for UT
typedef struct
{
   kal_uint8 ref_count;
   kal_uint16 msg_len;
   kal_uint8 list_ref;
   kal_uint8 list_len;
   kal_uint16 arfcn_list[33];
   kal_int16 rla_in_quarter_dbm[33];
}
tst_ut_msg1_struct;

//define the struct for L2Copro NVRAM saving/retrieving
//Define structure for UT
typedef struct
{
   kal_uint8 ref_count;
   kal_uint16 msg_len;
   kal_uint32 reserved;
}
tst_l2copro_filter_retrieval_struct;

typedef struct
{
   kal_uint8 ref_count;
   kal_uint16 msg_len;
   kal_uint32 reserved;
}
tst_l2copro_filter_save_struct;

typedef struct
{
   kal_uint32        msg_index;   
#ifdef __GEMINI__ 
/* under construction !*/
#endif //#ifdef __GEMINI__  
}
tst_brief_trace_header_struct;

#ifdef __GEMINI__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //#ifdef __GEMINI__

typedef struct
{
  kal_uint8 ref_count;
  kal_uint16 msg_len;
  kal_uint32 channel;
  kal_uint32 data[2];
  kal_uint32 reserved;
}
tst_ut_ccci_msg_struct;

typedef struct
{
  kal_uint8 ref_count;
  kal_uint16 msg_len;
  kal_uint32 cmd;
  kal_uint32 data[2];  
}
tst_tr_internal_struct;

typedef struct
{
  kal_uint32 token;
  kal_uint32 data_len;  //the total length of data[1] array
}
tst_catcher_data_loopback_header_struct;

typedef struct
{
  kal_uint32 token;
  kal_uint32 data_len;  //the total length of data[1] array
  kal_uint8  data[1];  //file path name and file content segment
}
tst_catcher_data_loopback_cmd_struct;

typedef struct
{
  kal_uint32 token;
}
tst_quick_capture_screen_cmd_struct;


typedef struct
{
  kal_int32 res;
  kal_uint32 token;
  kal_uint32 time;
  kal_uint32 data_len;
}
tst_quick_capture_screen_report_header_struct;

typedef struct
{
  kal_int32 res;
  kal_uint32 token;
  kal_uint32 time;
  kal_uint32 data_len;
  kal_uint8  data[1];
}
tst_quick_capture_screen_report_struct;

#ifdef __SMART_PHONE_MODEM__
typedef struct
{
  kal_uint32 token; //indicate the transaction id  
  kal_uint32 trigger_threshold;  //specify the threshold of buffer to trigger
  kal_uint32 trigger_interval;  //specify the time interval to trigger 
}
tst_sp_config_cmd_struct;
#endif

//Generic memory dump definitions
#if defined(GEN_FOR_PC)
  #define Define_TST_Mem_Dump_Type_Start() typedef enum {
  #define Define_TST_Mem_Dump_Type_Item(type, string, length) string##__size__##length,
  #define Define_TST_Mem_Dump_Type_End()   tst_mem_type_string_end} tst_mem_type_string_enum;
#else
  #define Define_TST_Mem_Dump_Type_Start() typedef enum {
  #define Define_TST_Mem_Dump_Type_Item(type, string, length) type,
  #define Define_TST_Mem_Dump_Type_End()   tst_mem_type_end} tst_mem_type_enum;
#endif 

typedef enum
{
	QUERY_FAIL,
	QUERY_CONTINUE,
	QUERY_END	
}
query_mem_range_result;

//Used for Log2SD on smartphone
#define TST_LOG2SD_FCORE_MEM_CHUNK_SIZE 0x2000
#define TST_LOG2SD_AST_MEM_CHUNK_SIZE 0x400

//You can't use the defs in the following macros

Define_TST_Mem_Dump_Type_Start()
Define_TST_Mem_Dump_Type_Item(tst_system_mem_type, sys_mem, 0xFFFFFFFF)
Define_TST_Mem_Dump_Type_Item(tst_dsp_mem_type, dsp_mem, 0xFFFFFFFF)
Define_TST_Mem_Dump_Type_Item(tst_bb_mem_type, bb_reg, 0xFFFFFFFF)
Define_TST_Mem_Dump_Type_Item(tst_swla_mem_type, swla, 0xFFFFFFFF)
#if defined(__DSP_FCORE4__) && !defined(UNIT_TEST)
Define_TST_Mem_Dump_Type_Item(tst_fcore_mem_type, fcore_mem, 0x2000)
#endif
#if defined(__AST_TL1_TDD__) && !defined(UNIT_TEST)
  Define_TST_Mem_Dump_Type_Item(tst_ast_mem_type, ast_mem, 0x400)
#endif  

Define_TST_Mem_Dump_Type_Item(tst_mmv2_mem_type, mmv2_mem, 0xFFFFFFFF)

#if defined (__TINY_SYS__)
Define_TST_Mem_Dump_Type_Item(tst_tiny_system_mem_type, tiny_sys_mem, 0xFFFFFFFF)
Define_TST_Mem_Dump_Type_Item(tst_tiny_reg_mem_type, tiny_reg_mem, 0xFFFFFFFF)
#endif

Define_TST_Mem_Dump_Type_Item(tst_ubin_mem_type, ubin_mem, 0xFFFFFFFF)

Define_TST_Mem_Dump_Type_End()


#endif /* _TST_DEF_H */

