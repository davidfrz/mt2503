/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/

#include "MMI_include.h"

#if defined (__MMI_DOWNLOAD_AGENT__)

#include "CommonScreens.h"
//#include "ProtocolEvents.h"
#include "app_mine.h"
#include "drm_def.h"
#include "DLAgentSrvDef.h"
#include "DLAgentSrvGprot.h"
#include "DLAgentSrvIProt.h"
#include "DLAgentSrvProt.h"
#ifdef __MMI_DOWNLOAD_AGENT__
#include "mmi_rp_srv_downloadagent_def.h"
#endif
#include "DLAgentSrvWPS.h"
#include "DLAgentSrvOMA.h"
//#include "XML_def.h"
#include "das_struct.h"                 /* WAP_DL_MAX_URL_LEN */
//#include "SettingDefs.h"                /* ST_NOTIFICATION */
//#include "PhoneBookDef.h"               /* IMG_PROCESSING_PHONEBOOK */
//#include "Wap_ps_struct.h"
//#include "Wapadp.h"
//#include "wgui_categories_inputs.h"    /* INPUT_TYPE_USE_ONLY_ENGLISH_MODES */
#include "Conversions.h"
//#include "FileMgr.h"
//#include "FileManagerGProt.h"           /* PUBLIC PRIVATE DRV */
//#include "FileManagerDef.h"             /*FMGR_FS_ACCESS_DENIED_TEXT*/
#include "FileMgrSrvGprot.h"
#include "Drm_gprot.h"


    #include "MMIDataType.h"
    #include "kal_general_types.h"
    #include "MMI_features.h"
    #include "wps_struct.h"
    #include "string.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "mmi_frm_mem_gprot.h"
    #include "Unicodexdcl.h"
    #include "app_str.h"
    #include "GlobalResDef.h"
    #include "CustDataRes.h"
    #include "mmi_rp_srv_downloadagent_def.h"
    #include "mmi_frm_events_gprot.h"
    #include "mmi_frm_input_gprot.h"
    #include "mmi_frm_history_gprot.h"
    #include "CustMenuRes.h"
    #include "wgui_categories_util.h"
    #include "wgui_categories_list.h"
    #include "GlobalConstants.h"
    #include "fs_type.h"
    #include "fs_func.h"
    #include "wgui_categories_text_viewer.h"
    #include "browser_api.h"
    #include "MMI_conn_app_trc.h"
    #include "mmi_conn_app_trc.h"
    #include "kal_trace.h"
    #include "fs_errcode.h"
    #include "FileMgrType.h"
    #include "mmi_rp_file_type_def.h"

/****************************************************************************
* Define
*****************************************************************************/

#if !defined(__MMI_FMGR_CUSTICON_SUPPORT__) && defined(__MMI_DA_OMA_ICONURI_SUPPORT__)
/* __MMI_DA_OMA_ICONURI_SUPPORTED__ depends on  __MMI_FMGR_CUSTICON_SUPPORT__ */
#undef __MMI_DA_OMA_ICONURI_SUPPORT__
#endif

#if defined(__MMI_OMA_DD_DOWNLOAD__)
/****************************************************************************
* Define - Macro
*****************************************************************************/


    

/****************************************************************************
* Typedef - Struct
*****************************************************************************/


typedef struct
{
    srv_da_job_struct   *curr_job;
} srv_da_oma_context_struct;


/****************************************************************************
* Static Variable
*****************************************************************************/

static srv_da_oma_context_struct da_oma_context;
#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
static MMI_BOOL da_storage_selection;
#endif /* __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__ */

/****************************************************************************
* Global Variable
*****************************************************************************/

static void srv_da_oma_init_module(void);
static void srv_da_oma_get_name(const srv_da_job_struct *job, U16 *buffer, U32 buffer_len);
static const U16* srv_da_oma_get_item_filepath(const srv_da_job_struct* job);
static U32  srv_da_oma_get_item_progress(const srv_da_job_struct* job, srv_da_item_progress_struct *info);
static U16 srv_da_oma_get_job_id(const srv_da_job_struct* job);
void srv_da_oma_get_setting(const srv_da_job_struct *job, srv_da_setting_struct *setting_data);
static MMI_BOOL srv_da_oma_is_object_desc_available(const srv_da_job_struct* job);
static void srv_da_oma_get_object_desc(
    const srv_da_job_struct *job,
    U16* string_buffer,
    const U32 buffer_len);
static void srv_da_oma_get_item_status_desc(
    const srv_da_job_struct *job,
    U16 *string_buffer[],       /* string_buffer[num_of_buffers] */
    const U32 buffer_len,       /* Max length per buffer */
    const U32 num_of_buffers,   /* Number of buffers */
    U32 *num_of_filled);
static const S8* srv_da_oma_get_infoURL(const srv_da_job_struct* job);
static MMI_BOOL srv_da_oma_free_job(srv_da_job_struct* job);
static void srv_da_oma_abort_job(srv_da_job_struct* job, S32 prev_state, MMI_BOOL pauseOnly,
                                  srv_da_abort_callback_type end_callback);
static void srv_da_oma_dispatch_job(const srv_da_job_struct* job);
static void srv_da_oma_assign_filepath(srv_da_job_struct* job, const U16* new_filepath);
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
static void srv_da_oma_resume_job(srv_da_job_struct* job);
#endif
#ifdef __MMI_DA_RESUME__
static void srv_da_oma_auto_resume_try_to_resume(void *arg, S32 unique_id);
#endif
void srv_da_oma_select_storage(srv_da_job_struct *job);

const srv_da_module_funcptr_table srv_da_oma_module =
{
    srv_da_oma_init_module

    ,srv_da_oma_get_name
    ,srv_da_oma_get_item_filepath
    ,srv_da_oma_get_item_progress
    ,srv_da_oma_get_job_id
    ,srv_da_oma_get_setting
    ,srv_da_oma_is_object_desc_available
    ,srv_da_oma_get_object_desc
    ,srv_da_oma_get_item_status_desc
    ,srv_da_oma_get_infoURL

    ,srv_da_oma_free_job
    ,srv_da_oma_abort_job
    ,srv_da_oma_dispatch_job
    ,srv_da_oma_assign_filepath
    
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    ,srv_da_oma_resume_job
#endif    
};


/****************************************************************************
* Function Forward Declaration
*****************************************************************************/

static void srv_da_oma_parse_dd_and_show_confirm(srv_da_job_struct *job);
void srv_da_oma_session_created_callback(MMI_BOOL success, U32 arg);
void srv_da_oma_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp);
void srv_da_oma_session_dl_progress_callback(U32 arg, U8 status, U32 curr_size, S32 cause);


/* iconURI */
static void srv_da_oma_icon_terminate_download(
                srv_da_job_struct *job,
                srv_da_oma_icon_state_enum next_icon_state);
static void srv_da_oma_icon_register_for_job(srv_da_job_struct* job);
static void srv_da_oma_icon_register_for_file(srv_da_oma_icon_struct* icon, U16 *filepath);

#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__
static void srv_da_oma_icon_start_download(srv_da_job_struct* job);
static void srv_da_oma_icon_trigger_next_procedure(srv_da_job_struct *job);
static void srv_da_oma_icon_session_created_callback(MMI_BOOL success, U32 arg);
static void srv_da_oma_icon_session_http_response_callback(
                U32 arg,
                U8 result,
                U16 status,
                S8 *header,
                S8 *content_type,
                U32 content_len,
                const wps_http_rsp_struct *rsp);
static void srv_da_oma_icon_session_http_auth_ind_callback(U32 arg);
static void srv_da_oma_icon_session_dl_progress_callback(U32 arg, U8 status, U32 curr_size, S32 cause);
#endif

static void srv_da_oma_send_install_noti_result_callback(
    void *arg,
    srv_da_oma_send_report_result_enum result,
    U32 status);

void srv_da_oma_open_nextURL(srv_da_job_struct *job);
void srv_da_oma_cancel_download(void *arg, MMI_BOOL is_deleted);

/* UI related */


/* Tool API */
static void srv_da_oma_close_session(srv_da_job_struct* job);
MMI_BOOL srv_da_oma_popup_and_send_report(srv_da_job_struct *job, S32 error, MMI_BOOL end_job, MMI_BOOL bpopup);

#ifdef __DRM_SUPPORT__
static void srv_da_oma_drm_process(srv_da_job_struct *job);
#endif                                            

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
/* Resume */
static void srv_da_oma_resume_session_created_callback(MMI_BOOL success, U32 arg);
static void srv_da_oma_resume_http_auth_ind_callback(U32 arg);
static void srv_da_oma_resume_cancel_callback(void *arg, MMI_BOOL is_deleted);
#endif


#define END_OF_FUNCTION_DECLARATION
/****************************************************************************
* Function Section
*****************************************************************************/

/*****************************************************************************
* FUNCTION
*   srv_da_oma_init_module
* DESCRIPTION
* PARAMETERS
* RETURNS
*   void
*****************************************************************************/
static void srv_da_oma_init_module(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    da_oma_context.curr_job = NULL;
}

/*****************************************************************************
* FUNCTION
*   srv_da_oma_dd_setting
* DESCRIPTION
*   When the file is downloaded from WAP browser, we set it as oma download
*   else, we save it to file system only.
* PARAMETERS
* RETURNS
*   void
*****************************************************************************/
void srv_da_oma_dd_setting(
    S32 session_id,
    S32 mime_type,                  /* applib_mime_type_enum */
    S32 mime_subtype,               /* applib_mime_subtype_enum */
	S32 action,
    U32 filesize,
    S8  *url,                        /* WAP_DL_MAX_URL_LEN */
    S8  *mime_type_string,           /* WAP_DL _MAX_MIME_TYPE_LEN */
    U32 content_len,
    S8  *content,
    srv_da_setting_struct * setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if( action == MMI_DA_WAP_DOWNLOAD ) /* OMA DL */
    {
        srv_da_bypass_setting(
            session_id, mime_type, mime_subtype, action,
            filesize, url, mime_type_string, content_len,
            content, setting);
        setting->can_minimize = MMI_FALSE;
    }
    else    /* treat this as normal file, dont dispatch */
    {
        srv_da_default_setting(
            session_id, mime_type, mime_subtype, action,
            filesize, url, mime_type_string, content_len,
            content, setting);
        setting->do_dispatch = MMI_FALSE;
    }

}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_dd_presetting
 * DESCRIPTION
 *  Set the presetting to default values.
 * PARAMETERS
 *  param       [IN]  Parameters to determine pre-setting
 *  presetting  [OUT] Pre-setting
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_dd_presetting(
    const srv_da_presetting_param_struct *param,
    srv_da_presetting_struct *presetting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Start to download without confirmation */
    presetting->confirm_download = MMI_FALSE;

    /* Not need content to determine setting */
    presetting->need_content = MMI_FALSE;
}


/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static MMI_BOOL srv_da_oma_job_match_dd_func(const srv_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct               *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    
    if(job->type != SRV_DA_JOB_TYPE_OMADL)
        return MMI_FALSE;
        
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    if(!job_data)
        return MMI_FALSE;
    
    if(strcmp((S8*)criteria, job_data->dd_url) == 0)
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
srv_da_job_struct* srv_da_oma_find_job_by_dd(S8* dd_url)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return srv_da_find_job(srv_da_oma_job_match_dd_func, (U32)dd_url);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_new_unique_id
 * DESCRIPTION
 *  Allocate a unique ID
 * PARAMETERS
 *  void
 * RETURNS
 *  An unique ID
 *****************************************************************************/
U16 srv_da_oma_get_new_unique_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U16 next_id = 0;
    U16 return_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return_id = next_id;
    next_id = (next_id + 1) & 0x7fff;

    return return_id;
}

#define PROCESS_DD

/*************************************************************************
* FUNCTION
*   srv_da_oma_process_dd_file
* DESCRIPTION
*   Start to handle dd file
* PARAMETERS
*   mime_type   [IN]    the mime type of file
*   mime_subtype[IN]    the sub mime type of file
*   action_type [IN]    defined in Download agent
*   filename    [IN]    the filepath of file
*   download_url[IN]    the source of file, normally is a link
*   mime_type_string    [IN]    the originaly mime type string get from server
* RETURNS
*   void
*************************************************************************/
void srv_da_oma_process_dd_file(S32 session_id, S32 mime_type, S32 mime_subtype,
                                S32 action_type, PU16 filename, PS8 download_url,
                                PS8 mime_type_string)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* parse message & allocate a new job */
    job = srv_da_job_create_ex(SRV_DA_JOB_TYPE_OMADL, NULL);
    if (!job)
    {
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        /* 1. there is another job setuping, 2. no memory */
        switch(srv_da_get_last_error())
        {
        case SRV_DA_IERROR_EXCEED_MAX_JOB:
        case SRV_DA_IERROR_EXCEED_MAX_DL:
            MMI_ASSERT(0);
            break;

        default:
            break;
        }
#endif
        srv_da_oma_popup_and_send_report(NULL, SRV_DA_OMA_DEVICE_ABORTED, MMI_TRUE, MMI_TRUE);
        
        return;
    }

    DA_ALLOC_OBJ(job_data, srv_da_omadl_job_struct);

    job->data_ptr = job_data;
    
    job_data->oma_state = SRV_DA_OMA_STATE_PREPROCESSING;
    job_data->unique_id = srv_da_job_get_new_unique_id();
    job_data->icon = NULL;
    job_data->etag = NULL;
    job_data->size = 0;
    job_data->channel = SRV_DA_WPS_DEFAULT_CHANNEL;
    
    job_data->drm_status = SRV_DA_DRM_STATUS_NONE;
#ifdef __DRM_SUPPORT__
    job_data->drm_method = DRM_METHOD_NONE;
#endif
    job_data->drm_process_session = NULL;
    job_data->drm_wait_for_rights_session = NULL;
    job_data->time_to_wait_for_rights = -1;
    
    UCS2_STR_MALLOC_COPY(job_data->dd_filepath, filename);
    ANSI_STR_MALLOC_COPY(job_data->dd_url, download_url, WAP_DL_MAX_URL_LEN);

    srv_da_oma_parse_dd_and_show_confirm(job);
}


/*************************************************************************
 * FUNCTION
 *  srv_da_oma_parse_dd_and_show_confirm
 * DESCRIPTION
 *  Parse DD file and show confirm dialog to user.
 *  If app decide to skip confirm step, it will go to select-storage.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *************************************************************************/
static void srv_da_oma_parse_dd_and_show_confirm(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    MMI_BOOL is_dd_valid;
    srv_da_oma_error_enum error;
    srv_da_oma_dd_struct *dd_info;
    srv_da_presetting_struct presetting;
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    is_dd_valid = srv_da_oma_parse_dd(job_data->dd_filepath, job, &(job_data->dd_info), job_data->dd_url);

    if (!is_dd_valid)
    {
        error = SRV_DA_OMA_INVALID_DESCRIPTOR;
        goto on_error;
    }

    dd_info = &job_data->dd_info;

    /* only support "1.0" */
    if (dd_info->DDVersion != NULL && mmi_ucs2cmp(dd_info->DDVersion, (S8*)L"1.0") != 0)
    {
        DA_TRACE_FUNC1(srv_da_oma_parse_dd_and_show_confirm, 1);
        error = SRV_DA_OMA_INVALID_DDVSERSION;
        goto on_error;
    }

    if (dd_info->objectURI == NULL)
    {
        DA_TRACE_FUNC1(srv_da_oma_parse_dd_and_show_confirm, 2);
        error = SRV_DA_OMA_INVALID_DESCRIPTOR;
        goto on_error;
    }

    /* size */
    if (dd_info->size == 0)
    {
        DA_TRACE_FUNC1(srv_da_oma_parse_dd_and_show_confirm, 3);
        error = SRV_DA_OMA_INVALID_DESCRIPTOR;
        goto on_error;
    }

    /* type */
    if (dd_info->type[0] == NULL)
    {
        DA_TRACE_FUNC1(srv_da_oma_parse_dd_and_show_confirm, 4);
        error = SRV_DA_OMA_INVALID_DESCRIPTOR;
        goto on_error;
    }

    /* content-type check */
    for (i = 0; i < 4; i++)
    {
        if (dd_info->type[i] != NULL &&
            applib_mime_type_look_up((kal_char*)dd_info->type[i], NULL, 0, 0) == NULL)
        {
            DA_TRACE_FUNC1(srv_da_oma_parse_dd_and_show_confirm, 5);
            error = SRV_DA_OMA_NON_ACCEPTABLE_CONTENT;
            goto on_error;
        }
    }

    job->mime_type = srv_da_util_lookup_mime_type_ascii((U8*)dd_info->type[0], 
                                                  srv_da_util_get_extension_ascii((S8*)dd_info->objectURI),
                                                  0, 0);
    job->type_handler = srv_da_search_mime_type_handler(job->mime_type);
    job_data->size = dd_info->size;

#if 0 /* MAUI_01200815: The drive to store file may be system drive, so the following check is incorrect.*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    /* app check */
    {
        const srv_da_oma_install_check_tbl_struct* check_hdlr;
        check_hdlr = srv_da_oma_search_install_check_handler(job->mime_type);
        if(check_hdlr)
        {
            if(!check_hdlr->handler(&job_data->dd_info))
            {
                DA_TRACE_FUNC1(srv_da_oma_parse_dd_and_show_confirm, 7);
                error = SRV_DA_OMA_NON_ACCEPTABLE_CONTENT;
                goto on_error;
            }
        }
    }

    /* Get presetting */
    {
        srv_da_presetting_param_struct param;

        param.action = MMI_DA_OMA_DOWNLOAD;
        param.mime_type = job->mime_type;
        param.uri = job_data->dd_info.objectURI;

        if (job->type_handler->get_presetting != NULL)
        {
            job->type_handler->get_presetting(&param, &presetting);
        }
        else
        {
            srv_da_default_presetting(&param, &presetting);
        }
    }

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if (job->dl_flag & DA_DL_FLAG_SKIP_CONFIRM)
    {
        srv_da_oma_select_storage(job);
        return;
    }
#endif
#ifndef MMI_DA_PLUTO_SLIM
    if (presetting.confirm_download)
    {


		if (srv_da_oma_extract_dd_content_string(job))
{
			srv_da_adp_show_choice_screen(
            MMI_FALSE,
            (void*)job,
            sizeof (srv_da_job_struct),
            srv_da_oma_confirm_download_callback,
            srv_da_oma_download_cancel_callback,
            srv_da_oma_delete_screen_callback, 
            MMI_TRUE);
            }
            }
            else
#endif
            {
        srv_da_oma_select_storage(job);
    }

    return;

on_error:
    srv_da_oma_popup_and_send_report(job, error, MMI_TRUE, MMI_TRUE);
}

void srv_da_oma_get_setting(const srv_da_job_struct *job, srv_da_setting_struct *setting_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_setting_hdlr         setting_hdlr;
    srv_da_omadl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    /* get setting */
    setting_hdlr = srv_da_default_setting;
    MMI_ASSERT(job->type_handler);
    if(job->type_handler->setting_hdlr)
        setting_hdlr = job->type_handler->setting_hdlr;

    setting_hdlr(
        0, 
        job->mime_type ? job->mime_type->mime_type : 0,
        job->mime_type ? job->mime_type->mime_subtype : 0,
        MMI_DA_OMA_DOWNLOAD,
        job_data->dd_info.size,
        job_data->dd_info.objectURI,
        job_data->dd_info.type[0],
        0,
        NULL,
        setting_data
    );

    MMI_ASSERT(srv_da_setting_check(setting_data));
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_infoURL
 * DESCRIPTION
 *  Get <infoURL> of the job. If not present, returns NULL.
 * PARAMETERS
 *  job     [IN] The job.
 * RETURNS
 *  <infoURL>
 *****************************************************************************/
static const S8* srv_da_oma_get_infoURL(const srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    return job_data->dd_info.infoURL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_decide_default_filename
 * DESCRIPTION
 *  To decide default filename by job and setting_data.
 * PARAMETERS
 *  job             [IN] Job.
 *  setting_data    [IN] Setting
 *  filename        [OUT] Filename
 *  file_ext        [OUT] File extension name
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_decide_default_filename(
    const srv_da_job_struct *job,
    const srv_da_setting_struct *setting_data,
    U16 *filename,
    U16 *fileext)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    U16 *ucs2_name;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    filename[0] = L'\0';
    fileext[0] = L'\0';

    if (setting_data->default_filename || setting_data->filename[0] == L'\0')
    {
        if (job_data->dd_info.name != NULL)
        {
            ucs2_name = (U16*)job_data->dd_info.name;
            
            if (srv_da_util_is_valid_filename(ucs2_name))
            {
                srv_da_extract_filepath(ucs2_name, filename, fileext);
            }
            else
            {
                srv_da_extract_filename_from_url(job_data->dd_info.objectURI, filename, fileext);
            }
        }
        else
        {
            srv_da_extract_filename_from_url(job_data->dd_info.objectURI, filename, fileext);
        }
    }
    else
    {
        srv_da_extract_filepath((U16*)setting_data->filename, filename, fileext);
    }

    if(job->mime_type != NULL)
    {
        mmi_asc_n_to_wcs(fileext, job->mime_type->file_ext, SRV_FMGR_PATH_MAX_FILE_EXT_LEN);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_select_storage
 * DESCRIPTION
 *  Start to select storage for the download.
 * PARAMETERS
 *  job     [IN] The job.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_select_storage(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct     *job_data;
    srv_da_setting_struct       *setting_data;
    srv_da_storage_parameter_struct *para;
    void *select_storage_instance;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;



    /* Delete in filename_done() */
    // DeleteScreenIfPresent(SCR_ID_DA_OMA_DOWNLOAD_OPTION);

    /* retrieve setting */
    setting_data = srv_da_get_setting_buffer();
    srv_da_oma_get_setting(job, setting_data);
    srv_da_copy_setting(job, setting_data);

    /* prepare storage parameter */

    para = (srv_da_storage_parameter_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_storage_parameter_struct));
        
    memset(para, 0, sizeof(srv_da_storage_parameter_struct));
    
    para->drv = setting_data->drv;
    para->storage = setting_data->storage;
    
#ifdef MMI_DA_CFG_SELECT_STORAGE_BEFORE_DOWNLOAD
    para->select_storage = setting_data->storage == SRV_DA_STORAGE_NONE ? MMI_TRUE : MMI_FALSE;
#else
    if (para->storage == SRV_DA_STORAGE_NONE)
    {
        para->storage = SRV_DA_STORAGE_AUTO;
    }
    para->select_storage = MMI_FALSE;
#endif

    mmi_wcscpy(para->folder, setting_data->folder);

    srv_da_oma_decide_default_filename(job, setting_data, para->filename, para->fileext);
    
#ifdef MMI_DA_CFG_INPUT_FILENAME_BEFORE_DOWNLOAD
    para->select_filename = (!setting_data->default_filename && setting_data->filename[0] == 0) ? MMI_TRUE : MMI_FALSE;
#else
    para->select_filename = MMI_FALSE;
#endif

#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
    if (!da_storage_selection)
    {
        if (para->storage == SRV_DA_STORAGE_NONE)
        {
            para->storage = SRV_DA_STORAGE_AUTO;
        }
        para->select_storage = MMI_FALSE;
    }
#endif /* __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__*/

    para->filesize = job_data->dd_info.size;

#ifdef __DRM_SUPPORT__
    /* DRM processing require twice space */
    if( job->mime_type && 
        (job->mime_type->mime_subtype == MIME_SUBTYPE_DRM_CONTENT ||
         job->mime_type->mime_subtype == MIME_SUBTYPE_DRM_MESSAGE) )
    {
        para->filesize *= 2;
    }
#endif

    para->filecheck_func = srv_da_does_job_with_filepath_exist;

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if(job->dl_flag & DA_DL_FLAG_SPECIAL)
        para->skip_exist_check = MMI_TRUE;
#endif

    /* confirmed, select storage now. */
    srv_da_adp_display_select_storage ((U32) job, para, MMI_DA_OMA_DOWNLOAD);
    srv_srv_da_adp_mem_free(para);
}

srv_da_acceptance_enum srv_da_oma_filename_done(
    U32 criteria, U16* filepath, MMI_BOOL canback, MMI_BOOL canpopup, void *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;

    srv_da_setting_struct       *setting;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)criteria;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
    da_storage_selection = MMI_TRUE;
#endif
    
    if (filepath == NULL)
    {
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#if 0 //sahil to do in app 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
 #ifndef __COSMOS_MMI_PACKAGE__             
/* under construction !*/
#endif
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif  //0  
    }

    srv_da_set_allow_to_trigger_connection(MMI_TRUE);
    
    UCS2_STR_MALLOC_COPY(job_data->filepath, filepath);

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if(job->dl_flag & DA_DL_FLAG_SPECIAL)
    {
        FS_HANDLE hd;
        if ((hd = FS_Open((PU16)filepath, FS_READ_ONLY)) >= 0)
        {
            FS_GetFileSize(hd, &(job_data->curr_size));
            FS_Close(hd);
        }
    }

    if(!(job->dl_flag & DA_DL_FLAG_SKIP_CONFIRM))
    {
        if (job_data->size != job_data->curr_size)/* MAUI_02636426: Only processing required no download initiated */
        {
#ifndef __COSMOS_MMI_PACKAGE__
            srv_da_adp_show_progressing(
                SRV_DA_ACTION_SCR_PLEASE_WAIT,
                SRV_DA_PROCESSING,
                srv_da_job_get_title_icon(job),
                SRV_DA_PLEASE_WAIT,
                MMI_TRUE,
                job,
                srv_da_oma_cancel_download);
#endif 
        }
    }
#else
#ifndef __COSMOS_MMI_PACKAGE__
    srv_da_adp_show_progressing(
        SRV_DA_ACTION_SCR_PLEASE_WAIT,
        SRV_DA_PROCESSING,
        srv_da_job_get_title_icon(job),
        SRV_DA_PLEASE_WAIT,
        MMI_TRUE,
        job,
        srv_da_oma_cancel_download);
#endif
#endif
    //sahil to do in app
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef MMI_DA_PLUTO_SLIM
    ClearDelScrnIDCallbackHandler(SRV_DA_ACTION_SCR_OMA_DOWNLOAD_OPTION, NULL);
    DeleteScreenIfPresent(SRV_DA_ACTION_SCR_OMA_DOWNLOAD_OPTION);
#endif 
#endif 

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if (job->dl_flag & DA_DL_FLAG_SPECIAL)
    {
        if (job_data->size == job_data->curr_size)
        {
            /* MAUI_02636426: Very specific case when user manage to pull out battery while Job was in processing state */
            setting = srv_da_get_setting_buffer();
            srv_da_oma_get_setting(job, setting);
            srv_da_copy_setting(job, setting);
	    job->state = SRV_DA_JOB_STATE_DOWNLOADING;
            srv_da_job_start(job);
            MMI_ASSERT(job->reporting);

	    job_data->oma_state = SRV_DA_OMA_STATE_DOWNLOADING;

	    job->state = SRV_DA_JOB_STATE_COMPLETED;
            srv_da_oma_do_next_procedure (job);
            return SRV_DA_ACCEPTANCE_ACCEPT;
        }
    }
#endif
        
    da_oma_context.curr_job = NULL;
    srv_da_adp_set_active_select_storage_instance(NULL);

    job_data->session = srv_da_wps_create_session_ex(
        (U32)job,
        SRV_DA_WPS_SETTING_DEFAULT,
        job_data->channel,
        srv_da_oma_session_created_callback,
        srv_da_oma_http_response_callback,
        srv_da_oma_http_auth_ind_callback,
        srv_da_oma_session_dl_progress_callback);

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if (job->dl_flag & DA_DL_FLAG_SPECIAL)
    {
        MMI_BOOL unbuffered_write;
        unbuffered_write = MMI_TRUE;
        srv_da_wps_session_set_option(job_data->session, SRV_DA_WPS_OPTION_UNBUFFERED_WRITE, &(unbuffered_write));
    }
#endif



    return SRV_DA_ACCEPTANCE_ACCEPT;

}

/*************************************************************************
 * FUNCTION
 *  srv_da_oma_open_nextURL
 * DESCRIPTION
 *  Open nextURL in background
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *************************************************************************/
void srv_da_oma_open_nextURL(srv_da_job_struct *job)
{
#ifdef BROWSER_SUPPORT
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    
    if (job_data->dd_info.nextURL != NULL)
    {
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
        if(!(job->dl_flag & DA_DL_FLAG_SPECIAL))
#endif
        {
            if (wap_browser_is_open())
            {
                wap_start_browser(WAP_BROWSER_GOTO_URL_BACKGROUND, (kal_uint8*)job_data->dd_info.nextURL);
                DA_FREE_BUFFER(job_data->dd_info.nextURL);
                job_data->dd_info.nextURL = NULL; /* Make sure again */
            }
        }
    }
#endif
}

#define OMA_SEND_REQUEST


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_cancel_download
 * DESCRIPTION
 *  Cancel handler for the "Please wait" of initializing WPS session and
 *  sending HTTP request
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 *  is_deleted  [IN] In delete context
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_cancel_download(void *arg, MMI_BOOL is_deleted)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;

    srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_TRUE, (MMI_BOOL)(!is_deleted));
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_show_screen_for_http_response
 * DESCRIPTION
 *  Show job list or detail screen for the job.
 * PARAMETERS
 *  arg             [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_show_screen_for_http_response(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)arg;

    if (!srv_da_is_job_valid(job))
    {
        return;
    }
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(job->setting_info.can_minimize)
    {
        /* bring up list screen */
        srv_da_adp_display_job_list(job, MMI_TRUE);
    }
    else
#endif        
    {
        srv_da_adp_display_job_detail(job);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_session_created_callback
 * DESCRIPTION
 *  Callback for WPS session created. Start to send HTTP requrest.
 * PARAMETERS
 *  success     [IN] Whether the session created successfully
 *  arg         [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_session_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (!success) /* If limit of channel resource */
    {
        srv_da_oma_open_nextURL(job);
        /* job_data->session will be closed by following function */
		//job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_DEVICE_ABORTED, MMI_FALSE, MMI_TRUE);
		//srv_da_update_job_status(job);
		#ifndef __COSMOS_MMI_PACKAGE__
		srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
        #endif
        return;
    }

    /* send request */
    if (!srv_da_wps_http_req(
        job_data->session,
        WPS_HTTP_METHOD_GET,
        job_data->dd_info.objectURI,
        NULL,
        NULL,
        job_data->filepath, /* Decided in mmi_da_oma_filename_done() */
        WPS_DATA_TYPE_FILE))
    {
        MMI_ASSERT(0);
    }

   srv_da_oma_open_nextURL(job);
    
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_is_type_in_the_list
 * DESCRIPTION
 *  Check if the MIME type is in the type_list[].
 * PARAMETERS
 *  mime_type   [IN] MIME type to be checked
 *  type_list   [IN] String array of types
 *  n_types     [IN] Number of elements in the type_list
 * RETURNS
 *  MMI_TRUE if the mime_type is found in the list
 *****************************************************************************/
static MMI_BOOL srv_da_oma_is_type_in_the_list(
    const applib_mime_type_struct *mime_type,
    S8 *type_list[],
    const U32 n_types)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;
    const applib_mime_type_struct *type_element;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mime_type == NULL)
    {
        return MMI_FALSE;
    }
    
    for (i = 0; i < n_types; i++)
    {
        if (type_list[i] != NULL)
        {
            type_element = applib_mime_type_look_up((kal_char*)type_list[i], NULL, 0, 0);

            /*
             * We should not check the entry pointer directly, because one type can be
             * mapped to multiple MIME strings and multiple entries.
             */
            if (type_element != NULL &&
                mime_type->mime_subtype == type_element->mime_subtype)
            {
                return MMI_TRUE;
            }
        }
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_http_response_callback
 * DESCRIPTION
 *  HTTP response handler for manual resumption.
 * PARAMETERS
 *  arg             [IN] (mmi_da_oma_send_report_session_struct*)Session
 *  result          [IN] Result
 *  status          [IN] Status code which server responded
 *  header          [IN] HTTP header
 *  content_type    [IN] Content-Type
 *  content_len     [IN] Content-Length
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_http_response_callback(
                U32 arg,
                U8 result,
                U16 status,
                S8 *header,
                S8 *content_type,
                U32 content_len,
                const wps_http_rsp_struct *rsp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;
    srv_da_oma_error_enum       error;
    MMI_BOOL                    user_cancel = MMI_FALSE;
    MMI_BOOL                    is_resume;
    srv_da_setting_struct       *setting;
    const applib_mime_type_struct *mime_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC2(srv_da_oma_http_response_callback, 0, content_len);

    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(srv_da_is_job_valid(job));
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_INIT || job->state == SRV_DA_JOB_STATE_RESUMING);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    is_resume = (job_data->curr_size > 0);

    /* check result */
    if(result != WPS_OK)
    {
        DA_TRACE_FUNC2(srv_da_oma_http_response_callback, 1, result);
        if( result == WPS_ERROR_FILE_ACCESS )
            error = SRV_DA_OMA_FILE_ACCESS_ERROR;
        else
            error = SRV_DA_OMA_LOADER_ERROR;
        if( result == WPS_ERROR_REQ_ABORT && job->state == SRV_DA_JOB_STATE_RESUMING)
            user_cancel = MMI_FALSE;
        goto on_error;
    }


    if (status >= 300 || status < 200)
    {
        DA_TRACE_FUNC2(srv_da_oma_http_response_callback, 3, status);
        error = SRV_DA_OMA_LOADER_ERROR;
        goto on_error;
    }
    else if (status == 401 || status == 407)
    {
        DA_TRACE_FUNC2(srv_da_oma_http_response_callback, 2, status);
        error = SRV_DA_OMA_UNAUTHORIZED;
        goto on_error;
    }

    if (status == 206)
    {
        if (content_len > 0)
        {
            if (content_len + job_data->curr_size == job_data->size)
            {
                /* OK */
            }
            else if (content_len == job_data->size)
            {
                /*
                 * [MAUI_02630704]
                 * Some server may send the total file length for Content-Length
                 * even for 206 Partial Content.
                 */
            }
            else
            {
                DA_TRACE_FUNC1(srv_da_oma_http_response_callback, 119);
                error = SRV_DA_OMA_LOADER_ERROR;
                goto on_error;
            }
        }
    }
    else if(status == 200)
    {
        if (!is_resume)
        {
            if (content_len > 0)
            {
                job_data->size = content_len;
            }
        }
        else
        {
            if (content_len != job_data->size)
            {
                /* Content-length mismatch */
                DA_TRACE_FUNC1(srv_da_oma_http_response_callback, 120);
                error = SRV_DA_OMA_LOADER_ERROR;
                goto on_error;
            }
        }
    }
    else
    {
        DA_TRACE_FUNC1(srv_da_oma_http_response_callback, 121);
        error = SRV_DA_OMA_LOADER_ERROR;
        goto on_error;
    }
    
    /* update content type */
    mime_type = srv_da_util_lookup_mime_type((U8*)content_type, 
                                                  srv_da_util_get_extension((U16*)job_data->filepath),
                                                  0, 0);

    DA_TRACE1(MMI_DA_TRC_MIMETYPE, (mime_type != NULL ? mime_type->mime_subtype : 0));

    if (is_resume && mime_type != job->mime_type)
    {
        /* MIME type mismatch */
        error = SRV_DA_OMA_LOADER_ERROR;
        goto on_error;
    }

    job->mime_type = mime_type;

    if (job->mime_type == NULL)
    {
        DA_TRACE_FUNC1(srv_da_oma_http_response_callback, 5);
        error = SRV_DA_OMA_NON_ACCEPTABLE_CONTENT;
        goto on_error;
    }

    if (!srv_da_oma_is_type_in_the_list(job->mime_type, job_data->dd_info.type, 4))
    {
#ifdef __DRM_SUPPORT__
        /*
         * MAUI_01253376: <type> in some DD only describes the content of DRM file
         * but not DRM format itself. So for DRM files, we should let it pass.
         */
        if (!srv_da_is_drm_content(job->mime_type))
#endif
        {
            DA_TRACE_FUNC1(srv_da_oma_http_response_callback, 6);
            error = SRV_DA_OMA_ATTRIBUTE_MISMATCH;
            goto on_error;
        }
    }

    job->type_handler = srv_da_search_mime_type_handler(job->mime_type);
    setting = srv_da_get_setting_buffer();
    srv_da_oma_get_setting(job, setting);
    srv_da_copy_setting(job, setting);

    /* its all ok now, Download start! */
    job->state = SRV_DA_JOB_STATE_DOWNLOADING;
    job_data->oma_state = SRV_DA_OMA_STATE_DOWNLOADING;

    /* Extract Etag for resumption */
    if (header != NULL)
    {
        if (job_data->etag == NULL)
        {
            S8 *etag;
        
            etag = (S8*)srv_da_adp_mem_allocate(MMI_DA_MAX_HTTP_ETAG_LEN);
            
            if (srv_da_util_extract_from_header(header, "ETag", etag, MMI_DA_MAX_HTTP_ETAG_LEN) == NULL)
            {
                srv_srv_da_adp_mem_free(etag);
            }
            else
            {
                job_data->etag = etag;
            }
        }

#ifdef __DRM_SUPPORT_SD_CALLBACK__
        srv_da_drm_extract_info_from_http_header(header, &(job_data->time_to_wait_for_rights));
#endif
        
        DA_TRACE_FUNC3(srv_da_oma_http_response_callback, 10, (S32)job_data->etag, job_data->time_to_wait_for_rights);
    }

    if(status != 206)
        job_data->curr_size = 0;
    
	if (!is_resume)
    {
    srv_da_job_start(job);
#ifndef __COSMOS_MMI_PACKAGE__
#if defined (__MMI_NCENTER_SUPPORT__)
        srv_da_adp_show_ncenter (job, SRV_DA_JOB_TYPE_OMADL);
#endif
#endif
        
    }
    kal_get_time(&job_data->dl_start_tick);

    /* DL start now, auth data is OK */
    job_data->auth_is_info_valid = MMI_TRUE;

    
    if (job->reporting && job->setting_info.filepath_hdlr != NULL)
    {
        S32 job_id = DA_MAKE_UNIQUE_ID(job, srv_da_oma_get_job_id(job));
    
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);

        job->setting_info.filepath_hdlr(
            job_id,
            job->mime_type->mime_type,
            job->mime_type->mime_subtype,
            job_data->filepath);
    }

    // srv_da_adp_oma_handle_http_rsp ((U32) job, status);
 #ifndef __COSMOS_MMI_PACKAGE__ 
	srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif
    if (!is_resume)
    srv_da_oma_show_screen_for_http_response(job);  //TODO: Need not to call this API

    
    
    return;

on_error:

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)

    if(job->state == SRV_DA_JOB_STATE_RESUMING && !user_cancel)
    {
        if (is_resume)
        {
            	job->state = SRV_DA_JOB_STATE_PAUSED;
			srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, SRV_DA_ERROR_RESUME_FAIL, MMI_FALSE);
        }
        else
        {
            srv_da_oma_popup_and_send_report(job, error, MMI_FALSE, MMI_FALSE);
        }

        srv_da_oma_close_session(job);
    }
    else
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) */
    {
        srv_da_oma_popup_and_send_report(job, error, MMI_TRUE, MMI_TRUE);
    }
 #ifndef __COSMOS_MMI_PACKAGE__ 
   srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif

}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_session_dl_progress_callback
 * DESCRIPTION
 *  Download progress handler for MO download.
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 *  status      [IN] wps_dl_status_enum
 *  curr_size   [IN] Size already downloaded.
 *  cause       [IN] Error cause if any error
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_session_dl_progress_callback(U32 arg, U8 status, U32 curr_size, S32 cause)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;
    srv_da_oma_error_enum       oma_error;
    MMI_BOOL                    popup_error_afterward;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    /* state checking */
    if(job->state == SRV_DA_JOB_STATE_ABORTING ||
        job_data->session == SRV_DA_WPS_INVALID_SESSION)
    {
        return;
    }
    
    if(job->state != SRV_DA_JOB_STATE_DOWNLOADING)
    {
        MMI_ASSERT(0);
        return;
    }

    /* update status */
    job_data->curr_size = curr_size;
    kal_get_time(&job_data->dl_latest_tick);

    if(job_data->curr_size > job_data->dd_info.size)
        job_data->dd_info.size = job_data->curr_size;
    
    switch(status)
    {
        case WPS_DL_STATUS_ABORT:
            job->error_cause = srv_da_wps_map_error_code(cause);

#ifdef __MMI_DA_RESUME__
            if (cause > 0 && /* Network problem */
                !job->was_stopped_by_upper_layer &&
                job_data->size > 0 &&
                srv_da_is_allowed_to_trigger_connection())
            {
        #ifdef MMI_DA_WLAN_PREFER_SUPPORT
                /*
                 * MAUI_02662312: When auto resume channel does not get unset because this job status is still in 
                 * downloading, pause download and change the total active download count of WPS, it will be dcreased
                 * and now channel will be released if it is only active download.
                 */
                job->state = SRV_DA_JOB_STATE_PAUSED;
                srv_da_update_job_status(job);
                job->state = SRV_DA_JOB_STATE_DOWNLOADING;
        #endif /* MMI_DA_WLAN_PREFER_SUPPORT */                
                if(job_data->session != SRV_DA_WPS_INVALID_SESSION)
                {
                    srv_da_wps_close_session(job_data->session, NULL);
                    job_data->session = SRV_DA_WPS_INVALID_SESSION;
                }

            #ifdef MMI_DA_WLAN_PREFER_SUPPORT
                if (!srv_da_is_bearer_switching())
            #endif
				{
					if (!srv_da_is_pdp_switching())
                srv_da_util_trigger_proc_ext(srv_da_oma_auto_resume_try_to_resume, job, job_data->unique_id);
				}

                break;
            }
#endif /* __MMI_DA_RESUME__ */

            popup_error_afterward = MMI_TRUE;

            if (cause < 0) /* File system error */
            {
                oma_error = (cause == FS_DISK_FULL) ? SRV_DA_OMA_INSUFFICIENT_MEMORY : SRV_DA_OMA_FILE_ACCESS_ERROR;
                popup_error_afterward = MMI_FALSE;
                srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_FS_ERROR, cause, 0,  MMI_FALSE);
            }
            else /* Network error */
            {
                oma_error = SRV_DA_OMA_LOSS_OF_SERVICE;
            }
            
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
            if(job->setting_info.can_minimize || job->reporting)
            {
                job->state = SRV_DA_JOB_STATE_PAUSED;
                srv_da_oma_popup_and_send_report(job, oma_error, MMI_FALSE, popup_error_afterward);
            }
            else
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) */
            {
                job->state = SRV_DA_JOB_STATE_ABORTED;
                srv_da_oma_popup_and_send_report(job, oma_error, MMI_TRUE, popup_error_afterward);
                return;
            }

            break;
            
        case WPS_DL_STATUS_COMPLETE:
            if (curr_size == 0)
            {
                job->state = SRV_DA_JOB_STATE_ABORTED;
                cause = SRV_DA_OMA_ATTRIBUTE_MISMATCH;
                srv_da_oma_popup_and_send_report(job, cause, MMI_TRUE, MMI_TRUE);
                return;
            }

            job->state = SRV_DA_JOB_STATE_COMPLETED;
            srv_da_oma_close_session(job);

            srv_da_oma_do_next_procedure(job);
            
            return;
            
        case WPS_DL_STATUS_DOWNLOADING:
            job->state = SRV_DA_JOB_STATE_DOWNLOADING;
            job_data->oma_state = SRV_DA_OMA_STATE_DOWNLOADING;
            break;
            
        default:
            MMI_ASSERT(0);
            break;
    }

    srv_da_update_job_status(job);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_do_next_procedure
 * DESCRIPTION
 *  Do next procedure according to current job state(job->data_ptr->oma_state)
 *  This function will change job's state to next suitable state.
 *  BE SURE to call this function at the END of a function! Otherwise,
 *  it can not guarantee the correctness of the following procedure of the function.
 * PARAMETERS
 *  job     [IN/OUT] Target job
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_do_next_procedure(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    DA_TRACE_FUNC2(srv_da_oma_do_next_procedure, job->state, job_data->oma_state);

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        return;
    }

    switch (job_data->oma_state)
    {
        case SRV_DA_OMA_STATE_DOWNLOADING:
        
#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__

            if (job_data->dd_info.iconURI != NULL &&
                job_data->filepath[0] != SRV_FMGR_SYSTEM_DRV && /* DO NOT download icon to system drive */
                (job_data->icon == NULL || job_data->icon->state != SRV_DA_OMA_ICON_STATE_SUCCEED))
            {
                job->state = SRV_DA_JOB_STATE_PROCESSING;
                job_data->oma_state = SRV_DA_OMA_STATE_DOWNLOADING_ICON;
                    
                srv_da_oma_icon_start_download(job);
                
                break;
            }

            /* Go through */
            
        case SRV_DA_OMA_STATE_DOWNLOADING_ICON:
        
#endif /* __MMI_DA_OMA_ICONURI_SUPPORT__ */

            if (srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_SUCCESS, MMI_FALSE, MMI_FALSE))
            {
                /* We have to wait for sending report successfully */
                job->state = SRV_DA_JOB_STATE_PROCESSING;
                job_data->oma_state = SRV_DA_OMA_STATE_SENDING_INSTALL_NOTIFICATION;
                break;
            }

            /* Go through */
           
        case SRV_DA_OMA_STATE_SENDING_INSTALL_NOTIFICATION:

            /*
             * NOTE: The report sending may fail.
             * In this condition, make sure it won't go here.
             */

            job->state = SRV_DA_JOB_STATE_PROCESSING;
            job_data->oma_state = SRV_DA_OMA_STATE_POSTPROCESSING;
            
#ifdef __DRM_SUPPORT__
            /* parse DRM type first */
            if (srv_da_is_drm_require_processing(job->mime_type))
            {
                srv_da_oma_drm_process(job);
                return;
            }
#endif

            srv_da_oma_icon_register_for_job(job);

            job->state = SRV_DA_JOB_STATE_COMPLETED;

            break;

        default:

            /* Unexpected state */
            MMI_EXT_ASSERT(MMI_FALSE, (job_data->oma_state), 0, 0);
            
            break;
    }

    srv_da_update_job_status(job);
}


static void srv_da_oma_session_aborted_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct               *job_data;
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    U32                         size;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(srv_da_oma_session_aborted_callback);

    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    /* session closed */
    job_data->session = SRV_DA_WPS_INVALID_SESSION;
    
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTING);
    job->state = SRV_DA_JOB_STATE_ABORTED;
    srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_FALSE, MMI_FALSE);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    size = srv_da_util_get_file_size(job_data->filepath);
    if(size)
        job_data->curr_size = size;
#endif

    if(job_data->abort_callback)
        job_data->abort_callback(job, 0);
    // After callback, job may be removed, do not use it.
}

static void srv_da_oma_close_session(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    
    if(job_data && job_data->session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
    }
}

#define OMA_JOB_TABLE

static MMI_BOOL srv_da_oma_free_job(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct     *job_data;
    srv_da_oma_dd_struct        *dd_info;
    S32                         i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(job->type != SRV_DA_JOB_TYPE_OMADL)
        return MMI_FALSE;
        
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if(job_data == NULL)
        return MMI_FALSE;

    if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
    }

    if (job->state != SRV_DA_JOB_STATE_COMPLETED && job_data->filepath != NULL && !job->reporting)
    {
        srv_da_util_file_delete(job_data->filepath);
    }

    MMI_ASSERT(job_data->drm_process_session == NULL);

#ifdef __DRM_SUPPORT_SD_CALLBACK__
    if (job_data->drm_wait_for_rights_session != NULL)
    {
        srv_da_drm_wait_for_rights_cancel(job_data->drm_wait_for_rights_session);
        job_data->drm_wait_for_rights_session = NULL;
    }
#endif
    
    /* always delte DD file */
    FS_Delete(job_data->dd_filepath);
    
    /* free DD info */
    dd_info = &job_data->dd_info;
    DA_FREE_BUFFER(dd_info->objectURI);
    DA_FREE_BUFFER(dd_info->installNotifyURI);
    DA_FREE_BUFFER(dd_info->nextURL);
    DA_FREE_BUFFER(dd_info->DDVersion);
    DA_FREE_BUFFER(dd_info->name);
    DA_FREE_BUFFER(dd_info->description);
    DA_FREE_BUFFER(dd_info->vendor);
    DA_FREE_BUFFER(dd_info->infoURL);
    DA_FREE_BUFFER(dd_info->iconURI);
    DA_FREE_BUFFER(dd_info->installParam);
    for(i=0; i<4; i++)
        DA_FREE_BUFFER(dd_info->type[i]);

    DA_FREE_BUFFER(job_data->dd_url);
    DA_FREE_BUFFER(job_data->dd_filepath);
    DA_FREE_BUFFER(job_data->filepath);
    DA_FREE_BUFFER(job_data->etag);
    DA_FREE_BUFFER(job_data->auth_username);
    DA_FREE_BUFFER(job_data->auth_password);
    
    if (job_data->channel != SRV_DA_WPS_DEFAULT_CHANNEL)
    {
        srv_da_wps_release_channel(job_data->channel);
    }

    if (job_data->icon != NULL)
    {
        /* We don't need to remove the icon file since it has beed registered and moved,
           or deleted during abort. */
        DA_FREE_BUFFER(job_data->icon->filepath);
        DA_FREE_BUFFER(job_data->icon);
    }

    srv_srv_da_adp_mem_free(job_data);
    job->data_ptr = NULL;
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_name
 * DESCRIPTION
 *  Get item name to be displayed
 * PARAMETERS
 *  job         [IN] Job
 *  buffer      [IN] Buffer to be filled in
 *  buffer_len  [IN] Buffer length
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_get_name(const srv_da_job_struct *job, U16 *buffer, U32 buffer_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    mmi_wcsncpy(buffer, job_data->filepath, buffer_len - 1);
    srv_da_util_process_filepath_to_be_displayed(buffer);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_item_filepath
 * DESCRIPTION
 *  Get the file path of the job.
 * PARAMETERS
 *  job         [IN] Job
 * RETURNS
 *  Filepath. NOTE: The pointer returned should not be held permanently.
 *****************************************************************************/
static const U16* srv_da_oma_get_item_filepath(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    
    return (job_data->filepath);
}

static U32  srv_da_oma_get_item_progress(const srv_da_job_struct* job, srv_da_item_progress_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    U32 secs;
    U32 progress;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    info->fileSize = job_data->size;
    info->currSize = job_data->curr_size;
    secs = srv_da_util_ticks_to_milli_seconds(job_data->dl_latest_tick - job_data->dl_start_tick) / 1000;
    if(job_data->size && job_data->curr_size && secs)
        {
        info->secs_remain = (U32)((U64)secs * (U64)(job_data->size - job_data->curr_size) / (U64)job_data->curr_size);
    }
    else
    {
        info->secs_remain = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;
    }
        
    progress = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;

    if(job_data->size > 0)
    {
        progress = (U32)( ((U64)job_data->curr_size * (U64)100) / (U64)(job_data->size) );

        if (progress > 100)
        {
            progress = 100;
        }
    }
    else
    {
    switch (job->state)
    {
        case SRV_DA_JOB_STATE_COMPLETED:
            case SRV_DA_JOB_STATE_PROCESSING:
            progress = 100;
            break;
            
        default:
                progress = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;
            break;
    }
    }

    return progress;
   
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_is_object_desc_available
 * DESCRIPTION
 *  Query function for object description. Returns MMI_TRUE if the description
 *  is available by calling srv_da_oma_get_object_desc().
 * PARAMETERS
 *  job     [IN] Job to be queried.
 * RETURNS
 *  MMI_TRUE if if the description is available by calling srv_da_oma_get_object_desc().
 *****************************************************************************/
static MMI_BOOL srv_da_oma_is_object_desc_available(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    return (job_data->dd_info.name != NULL || job_data->dd_info.description != NULL);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_object_desc
 * DESCRIPTION
 *  Fill the object description of job in string_buffer[]
 * PARAMETERS
 *  job             [IN] Job.
 *  string_buffer   [IN] String buffer
 *  buffer_len      [IN] Length of string_buffer (in U16)
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_get_object_desc(
                const srv_da_job_struct *job,
                U16* string_buffer,
                const U32 buffer_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    U16* buffer_end;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    buffer_end = string_buffer;
#if 0 //sahil to do in app
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0
}

/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_item_status_desc
 * DESCRIPTION
 *  Fill the object description of job in string_buffer[]
 * PARAMETERS
 *  job                 [IN]  Job.
 *  string_buffer       [IN]  Array of string buffers
 *  buffer_len          [IN]  Length of each string buffer element (in U16)
 *  num_of_buffers      [IN]  Number of string buffers. That is, this function can only
 *                            fill string_buffer[0..number_of_buffers-1]
 *  num_of_filled       [OUT] Number of filled buffer by this function
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_get_item_status_desc(
                const srv_da_job_struct *job,
                U16 *string_buffer[],       /* string_buffer[num_of_buffers] */
                const U32 buffer_len,       /* Max length per buffer */
                const U32 num_of_buffers,   /* Number of buffers */
                U32 *num_of_filled)
{
            
}


static void srv_da_oma_abort_job(srv_da_job_struct* job, S32 prev_state, MMI_BOOL pauseOnly,
                                  srv_da_abort_callback_type end_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTING);
    MMI_ASSERT(end_callback);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    job_data->abort_callback = end_callback;

    DA_TRACE_FUNC1(srv_da_oma_abort_job, prev_state);
    
    switch(prev_state)
    {
    case SRV_DA_JOB_STATE_DOWNLOADING:
	case SRV_DA_JOB_STATE_RESUMING:
        if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
        {
            srv_da_wps_close_session(job_data->session, srv_da_oma_session_aborted_callback);
            job_data->session = SRV_DA_WPS_INVALID_SESSION;
        }
        break;

    case SRV_DA_JOB_STATE_PROCESSING: /* abort when downloading icon or sending report. */
        
        srv_da_oma_icon_terminate_download(job, SRV_DA_OMA_ICON_STATE_CANCELLED);

        switch (job_data->oma_state)
        {
            case SRV_DA_OMA_STATE_DOWNLOADING_ICON:
                /* The callback function will free the job */
                if (job_data->abort_callback != NULL)
                {
                    job->state = SRV_DA_JOB_STATE_ABORTED;
                    srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_FALSE, MMI_TRUE);
                    job_data->abort_callback(job, 0);
                }
                else
                {
                    srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_TRUE, MMI_TRUE);
                }

                break;

            case SRV_DA_OMA_STATE_SENDING_INSTALL_NOTIFICATION:

                MMI_ASSERT(job_data->install_noti_session != 0);
                MMI_ASSERT(pauseOnly == MMI_FALSE);     // can not suspend in this state

                srv_da_oma_send_report_cancel(job_data->install_noti_session);
                job_data->install_noti_session = 0;

                srv_da_adp_popup_for_job(job,
                    SRV_DA_POPUP_TYPE_INFO,
                    SRV_DA_OMA_ERROR_SEND_REPORT_CANCEL,
                    MMI_FALSE,
					NULL);

                job->state = SRV_DA_JOB_STATE_ABORTED;

                if (end_callback != NULL)
                {
                    end_callback(job, 0);
                }

                break;

            case SRV_DA_OMA_STATE_POSTPROCESSING:

#ifdef __DRM_SUPPORT__
                if (job_data->drm_process_session != NULL)
                {
                    /* State will be changed to be ABORTED and the abort_cb()
                       will be called in the callback */
                    srv_da_drm_process_cancel(job_data->drm_process_session);
                    job_data->drm_process_session = NULL;
                    return;
                }
#endif

#ifdef __DRM_SUPPORT_SD_CALLBACK__
                if (job_data->drm_wait_for_rights_session != NULL)
                {
                    srv_da_drm_wait_for_rights_cancel(job_data->drm_wait_for_rights_session);
                    job_data->drm_wait_for_rights_session = NULL;
                }
#endif /* __DRM_SUPPORT_SD_CALLBACK__ */

                job->state = SRV_DA_JOB_STATE_ABORTED;
                job_data->drm_status = SRV_DA_DRM_STATUS_NONE;

                if (end_callback != NULL)
                {
                    end_callback(job, 0);
                }

                break;
        }

        break;

    default:
        MMI_ASSERT(0);
        break;
    }
    
}

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
static void srv_da_oma_resume_job(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    U32                     size;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    switch (job_data->oma_state)
    {
        case SRV_DA_OMA_STATE_DOWNLOADING:
#ifndef __COSMOS_MMI_PACKAGE__
            srv_da_adp_show_progressing(
                SRV_DA_ACTION_SCR_PLEASE_WAIT,
                SRV_DA_PROCESSING,
                srv_da_job_get_title_icon(job),
                SRV_DA_PLEASE_WAIT,
                MMI_TRUE,
                job,
                srv_da_oma_resume_cancel_callback);  //TODO: No need to display progress in resumption for */
#endif

            /* Before resume, check the file length again */
            size = srv_da_util_get_file_size(job_data->filepath);
            if(size)
                job_data->curr_size = size;
            
            MMI_ASSERT(job->state == SRV_DA_JOB_STATE_RESUMING);
#if 0           
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
           
            job_data->session = srv_da_wps_create_session((U32)job,
                                      SRV_DA_WPS_SETTING_DEFAULT,
                                      srv_da_oma_resume_session_created_callback,
                                      srv_da_oma_http_response_callback,
                                      srv_da_oma_resume_http_auth_ind_callback,
                                      srv_da_oma_session_dl_progress_callback);
            break;

        case SRV_DA_OMA_STATE_DOWNLOADING_ICON:
        case SRV_DA_OMA_STATE_POSTPROCESSING:
            job->state = SRV_DA_JOB_STATE_DOWNLOADING;
            job_data->oma_state = SRV_DA_OMA_STATE_DOWNLOADING;
            //srv_da_oma_show_screen_for_http_response(job);
            srv_da_oma_do_next_procedure(job);
            
            break;
        case SRV_DA_OMA_STATE_SENDING_INSTALL_NOTIFICATION:
            job->state = SRV_DA_JOB_STATE_PROCESSING;
            job_data->oma_state = SRV_DA_OMA_STATE_DOWNLOADING;
            srv_da_oma_do_next_procedure(job);
            break;

        default:
            break;
    }
}
#endif

static void srv_da_oma_dispatch_job(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    srv_da_dispatch_to_app(
        DA_MAKE_UNIQUE_ID(job, srv_da_oma_get_job_id(job)),
        job->mime_type,
        MMI_DA_OMA_DOWNLOAD,
        job_data->filepath,
        job_data->dd_info.objectURI,
        NULL,
        job->type_handler);

}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_job_id
 * DESCRIPTION
 *  Get LOCAL ID of an OMA download job.
 * PARAMETERS
 *  job         [IN] Job
 * RETURNS
 *  Local ID
 *****************************************************************************/
static U16 srv_da_oma_get_job_id(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    return job_data->unique_id;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_assign_filepath
 * DESCRIPTION
 *  Assign a new filepath for the file of the job.
 * PARAMETERS
 *  job             [IN/OUT] Job
 *  new_filepath    [IN]     Filepath
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_assign_filepath(srv_da_job_struct* job, const U16* new_filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_COMPLETED);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    UCS2_STR_MALLOC_COPY(job_data->filepath, new_filepath);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_installParam
 * DESCRIPTION
 *  Get the value of <installParam> of an OMA download.
 * PARAMETERS
 *  session_id      [IN] Session ID
 * RETURNS
 *  The value of <installParam>. If absent, returns NULL.
 *****************************************************************************/
const S8* srv_da_oma_get_installParam(S32 session_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    S8 *installParam;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    installParam = NULL;
    
    job = srv_da_find_job(srv_da_job_match_id_func, session_id);

    if (job != NULL &&
        job->type == SRV_DA_JOB_TYPE_OMADL)
    {
        job_data = (srv_da_omadl_job_struct*)job->data_ptr;
        installParam = job_data->dd_info.installParam;
    }

    return installParam;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_get_progressiveDownloadFlag
 * DESCRIPTION
 *  Get the value of <progressiveDownloadFlag> of an OMA download.
 * PARAMETERS
 *  session_id      [IN] Session ID
 * RETURNS
 *  The value of <progressiveDownloadFlag>.
 *  By default it returns MMI_FALSE if absent.
 *****************************************************************************/
MMI_BOOL srv_da_oma_get_progressiveDownloadFlag(S32 session_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    MMI_BOOL progressiveDownloadFlag;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    progressiveDownloadFlag = MMI_FALSE;

    job = srv_da_find_job(srv_da_job_match_id_func, session_id);

    if (job != NULL &&
        job->type == SRV_DA_JOB_TYPE_OMADL)
    {
        job_data = (srv_da_omadl_job_struct*)job->data_ptr;
        progressiveDownloadFlag = job_data->dd_info.progressiveDownloadFlag;
    }

    return progressiveDownloadFlag;
}




void srv_da_oma_user_auth_callback(U32 criteria, U16* username, U16* password)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)criteria;
    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if(!username || !password)
    {
        if(job->state != SRV_DA_JOB_STATE_INIT && job->state != SRV_DA_JOB_STATE_PAUSED && job->state != SRV_DA_JOB_STATE_RESUMING) 
        {    
            MMI_ASSERT(0);
        }
        if(job->state == SRV_DA_JOB_STATE_PAUSED || job->state == SRV_DA_JOB_STATE_RESUMING)
            job->state = SRV_DA_JOB_STATE_ABORTED;

        srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_TRUE, MMI_TRUE);
#ifndef __COSMOS_MMI_PACKAGE__
		srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif
    }
    else
    {
        // Cache last username/password
        UCS2_STR_MALLOC_COPY(job_data->auth_username, username);
        UCS2_STR_MALLOC_COPY(job_data->auth_password, password);

        /* User input info, it is not valid yet */
        job_data->auth_is_info_valid = MMI_FALSE;
        
        srv_da_wps_session_auth_UCS2(job_data->session, username, password);
    }
}


#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)

#define RESUME

static void srv_da_oma_resume_session_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct               *job_data;
    S8                          *header;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (!success)
    {
        /* fail to create section */
		 job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, SRV_DA_ERROR_RESUME_FAIL, MMI_FALSE);
  #ifndef __COSMOS_MMI_PACKAGE__ 
		srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
        return;
    }

    header = (S8 *)srv_da_adp_mem_allocate(128);
    
    /* send request */
    if(!srv_da_wps_http_req(
        job_data->session,
        WPS_HTTP_METHOD_GET,
        job_data->dd_info.objectURI,
        srv_da_util_gen_http_header_to_resume(header, job_data->etag, job_data->curr_size),
        NULL,
        job_data->filepath,
        WPS_DATA_TYPE_FILE))
    {
        MMI_ASSERT(0);
    }

    srv_srv_da_adp_mem_free(header);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_resume_http_auth_ind_callback
 * DESCRIPTION
 *  HTTP auth ind handler for resumption.
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_resume_http_auth_ind_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    /* if auth info not valid yet, it means user need re-input */
    if(!job_data->auth_password || !job_data->auth_username || !job_data->auth_is_info_valid)
    {
    #ifndef MMI_DA_PLUTO_SLIM
        srv_da_adp_show_user_auth_screen((U32) job, srv_da_oma_user_auth_callback);
   	#endif
    }
    else
    {
        srv_da_wps_session_auth_UCS2(job_data->session, job_data->auth_username, job_data->auth_password);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_resume_cancel_callback
 * DESCRIPTION
 *  Cancel callback of trying resumption.
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 *  is_deleted  [IN] In delete context
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_resume_cancel_callback(void *arg, MMI_BOOL is_deleted)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    if (job->state == SRV_DA_JOB_STATE_RESUMING);
    {
        if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
        {
            srv_da_wps_close_session(job_data->session, NULL);
            job_data->session = SRV_DA_WPS_INVALID_SESSION;
        }
        job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_update_job_status(job);
    }
}

#endif

#define ICONURI


#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_start_download
 * DESCRIPTION
 *  Start to download the job's icon. If the icon has been downloaded or
 *  no icon can be downloaded, this function will do nothing.
 * PARAMETERS
 *  job         [IN/OUT]    The job to download icon.
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_start_download(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC1(srv_da_oma_icon_start_download, 0);
    
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    
    if (job_data->dd_info.iconURI != NULL)
    {
        /* We have to download icon */
        srv_da_oma_icon_struct *icon;
    
        if (job_data->icon == NULL)
        {
            job_data->icon = (srv_da_oma_icon_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_oma_icon_struct));
            
            icon = job_data->icon;
            icon->session = SRV_DA_WPS_INVALID_SESSION;
            icon->filepath = NULL;
            icon->state = SRV_DA_OMA_ICON_STATE_NONE;
            icon->mime_type = NULL;
            icon->job = job;
        }

        icon = job_data->icon;

        DA_TRACE_FUNC2(srv_da_oma_icon_start_download, 1, (icon->state));

        switch (icon->state)
        {
            case SRV_DA_OMA_ICON_STATE_DOWNLOADING:
                /* We are unnecessary to do anything.
                   Next procedure will be triggered after download completed or aborted. */
                break;
                
            case SRV_DA_OMA_ICON_STATE_SUCCEED:
                srv_da_oma_icon_trigger_next_procedure(job);
                break;
                
            default: /* NONE, FAILED, CANCELLED */
                icon->state = SRV_DA_OMA_ICON_STATE_DOWNLOADING;

                DA_TRACE_FUNC1(srv_da_oma_icon_start_download, 2);
                
                icon->session = srv_da_wps_create_session_ex((U32)icon,
                    SRV_DA_WPS_SETTING_DEFAULT,
                    job_data->channel,
                    srv_da_oma_icon_session_created_callback,
                    srv_da_oma_icon_session_http_response_callback,
                    srv_da_oma_icon_session_http_auth_ind_callback,
                    srv_da_oma_icon_session_dl_progress_callback);

                break; /* Next procedure will be triggered afterward */
        }

    }

}
#endif /* __MMI_DA_OMA_ICONURI_SUPPORT__ */


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_terminate_download
 * DESCRIPTION
 *  Termiate the icon downloading. This will delete the icon file even
 *  if the icon has been downloaded successfuly.
 * PARAMETERS
 *  job                 [IN/OUT]    The job whose icon downloading will be terminated.
 *  next_icon_state     [IN]        The next state that the job_data->icon will be.
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_terminate_download(
                srv_da_job_struct *job,
                srv_da_oma_icon_state_enum next_icon_state)
{
#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    srv_da_oma_icon_struct *icon;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    icon = job_data->icon;

    if (icon != NULL)
    {
        DA_TRACE_FUNC2(srv_da_oma_icon_terminate_download, (icon->state), next_icon_state);

        if (icon->state == SRV_DA_OMA_ICON_STATE_DOWNLOADING)
        {
            if (icon->session != SRV_DA_WPS_INVALID_SESSION)
            {
                srv_da_wps_close_session(icon->session, NULL);
                icon->session = SRV_DA_WPS_INVALID_SESSION;
            }
        }

        if (icon->filepath != NULL)
        {
            FS_Delete(icon->filepath);
            srv_srv_da_adp_mem_free(icon->filepath);
            icon->filepath = NULL;
        }


        MMI_EXT_ASSERT(next_icon_state == SRV_DA_OMA_ICON_STATE_CANCELLED ||
                        next_icon_state == SRV_DA_OMA_ICON_STATE_FAILED,
                        next_icon_state, 0, 0);
        
        icon->state = next_icon_state;
    }
    
#endif /* __MMI_DA_OMA_ICONURI_SUPPORT__*/
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_register_for_file
 * DESCRIPTION
 *  Register icon for the file downloaded.
 * PARAMETERS
 *  icon        [IN] the pointer of icon structure.
 *                   If icon == NULL or invalid, the icon of the filepath will be cleaned.
 *  filepath    [IN] file path
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_register_for_file(srv_da_oma_icon_struct *icon, U16 *filepath)
{
#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 register_result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (icon != NULL && icon->state == SRV_DA_OMA_ICON_STATE_SUCCEED)
    {
        DA_TRACE_FUNC1(srv_da_oma_icon_register_for_file, 10);

        /* Correct the file extension of the icon.
           Note that we didn't give any extension when send HTTP request */
        {
            U16 *new_icon_filepath;
            
            new_icon_filepath = (U16 *)srv_da_adp_mem_allocate(SRV_FMGR_PATH_MAX_LEN);
            kal_wsprintf(new_icon_filepath, "%w.%s", icon->filepath, icon->mime_type->file_ext);
            FS_Rename(icon->filepath, new_icon_filepath); /* FS_Rename(old_name, new_name) */
            mmi_wcscpy(icon->filepath, new_icon_filepath); /* mmi_wcscpy(dest, src) */
            srv_srv_da_adp_mem_free(new_icon_filepath);
        }
        
        /* register to file manager */
        register_result = srv_fmgr_custicon_do(SRV_FMGR_CUSTICON_OP_REGISTER, filepath, icon->filepath);
        
        if (register_result != SRV_FMGR_CUSTICON_RESULT_OK)
        {
            /* Failed */
            DA_TRACE_FUNC2(srv_da_oma_icon_register_for_file, 11, register_result);
            srv_da_oma_icon_terminate_download(icon->job, SRV_DA_OMA_ICON_STATE_CANCELLED);
        }
    }
    else
    {
        /* clean icon for the filepath */
        register_result = srv_fmgr_custicon_do(SRV_FMGR_CUSTICON_OP_DEREGISTER, filepath, NULL);
        DA_TRACE_FUNC2(srv_da_oma_icon_register_for_file, 20, register_result);
    }
#endif /* __MMI_DA_OMA_ICONURI_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_register_for_job
 * DESCRIPTION
 *  Register icon for the file downloaded. If job->icon == NULL or invalid,
 *  the icon of the file will be cleaned.
 * PARAMETERS
 *  job         [IN] job which has an icon associated.
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_register_for_job(srv_da_job_struct* job)
{
#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    srv_da_oma_icon_register_for_file(job_data->icon, job_data->filepath);
#endif /* __MMI_DA_OMA_ICONURI_SUPPORT__ */
}


#ifdef __MMI_DA_OMA_ICONURI_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_trigger_next_procedure
 * DESCRIPTION
 *  Trigger next procedure if it is necessary.
 *  [NOTE & BE CAREFUL]
 *  We have to make sure ALL break points of icon downloading call this function.
 * PARAMETERS
 *  icon         [IN] The icon structure of the job.
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_trigger_next_procedure(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(srv_da_oma_icon_trigger_next_procedure);

    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    /* We can trigger next procedure only when oma_state == DOWNLOADING_ICON */
    MMI_ASSERT(job_data->oma_state == SRV_DA_OMA_STATE_DOWNLOADING_ICON);
    srv_da_oma_do_next_procedure(job);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_session_created_callback
 * DESCRIPTION
 *  Callback function for WPS session created for icon downloading.
 *  This function will determine the filepath of icon.
 * PARAMETERS
 *  success     [IN] Suceessfully created
 *  arg         [IN] srv_da_oma_icon_struct* icon
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_session_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_icon_struct *icon;
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    icon = (srv_da_oma_icon_struct*)arg;
    job = icon->job;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    DA_TRACE_FUNC1(srv_da_oma_icon_session_created_callback, success);

    /* We only allocate & assign filepath in this function */
    MMI_ASSERT(icon->filepath == NULL);

    if (success)
    {
        U16 *folder_path;
        MMI_BOOL filepath_ok;

        filepath_ok = MMI_FALSE;

        icon->filepath = (U16*)srv_da_adp_mem_allocate(sizeof(U16) * (SRV_FMGR_PATH_MAX_LEN + 1));

        /* Get a temp file in FMGR_DEFAULT_FOLDER_RECEIVED */
        folder_path = (U16*)srv_da_adp_mem_allocate(sizeof(U16) * (SRV_FMGR_PATH_MAX_LEN + 4));
        kal_wsprintf(folder_path, "%c:\\%w", job_data->filepath[0], FMGR_DEFAULT_FOLDER_TEMP);
        if (srv_da_util_create_file_dir(folder_path, MMI_FALSE) >= 0)
        {
            filepath_ok = srv_da_util_get_temp_filename(folder_path, icon->filepath, SRV_FMGR_PATH_MAX_LEN);
        }
        srv_srv_da_adp_mem_free(folder_path);

        if (!filepath_ok)
        {
            goto srv_da_oma_icon_session_created_callback_terminate;
        }

        if (!srv_da_wps_http_req(
            icon->session,
            WPS_HTTP_METHOD_GET,
            job_data->dd_info.iconURI,
            NULL,
            NULL,
            icon->filepath,
            WPS_DATA_TYPE_FILE) )
        {
            goto srv_da_oma_icon_session_created_callback_terminate;
        }
    }
    else
    {
        /* session is invalid */
        icon->state = SRV_DA_OMA_ICON_STATE_FAILED;
        srv_da_wps_close_session(icon->session, NULL);
        icon->session = SRV_DA_WPS_INVALID_SESSION;

        srv_da_oma_icon_trigger_next_procedure(job);
    }

    return;

srv_da_oma_icon_session_created_callback_terminate:

    srv_da_oma_icon_terminate_download(job, SRV_DA_OMA_ICON_STATE_FAILED);

    srv_da_oma_icon_trigger_next_procedure(job);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_session_http_auth_ind_callback
 * DESCRIPTION
 *  Callback function for HTTP authencation indication for icon downloading.
 *  If authentication is needed, we will terminate the icon download.
 * PARAMETERS
 *  arg         [IN] srv_da_oma_icon_struct* icon
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_session_http_auth_ind_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_icon_struct *icon;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(srv_da_oma_icon_session_http_auth_ind_callback);
    
    icon = (srv_da_oma_icon_struct*)arg;
    
    /* We abandon downloading icon if it needs authentication */
    srv_da_oma_icon_terminate_download(icon->job, SRV_DA_OMA_ICON_STATE_CANCELLED);

    srv_da_oma_icon_trigger_next_procedure(icon->job);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_session_http_response_callback
 * DESCRIPTION
 *  Callback function for HTTP response for icon downloading.
 *  We will cancel some icon format here.
 * PARAMETERS
 *  arg             [IN] srv_da_oma_icon_struct* icon
 *  result          [IN] message->result
 *  status          [IN] message->status
 *  content_type    [IN] Content-Type from HTTP response
 *  content_len     [IN] Length of Content-Type
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_session_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_icon_struct *icon;
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    filetypes_file_type_enum icon_filetype;
    srv_da_oma_icon_state_enum next_icon_state_on_error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC3(srv_da_oma_icon_session_http_response_callback, 0, result, status);
    
    icon = (srv_da_oma_icon_struct*)arg;
    job = icon->job;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    MMI_ASSERT(job->state != SRV_DA_JOB_STATE_INIT);
    MMI_ASSERT(icon->session != SRV_DA_WPS_INVALID_SESSION);

    /*********************************************************************
     * Note: Be sure to trigger next procedure if terminate the download *
     * in this function.                                                 *
     *********************************************************************/

    /*** Server denied / connetion failed ***/
    next_icon_state_on_error = SRV_DA_OMA_ICON_STATE_FAILED;
    
    if (result != WPS_OK || status != 200)
    {
        goto srv_da_oma_icon_session_http_response_callback_terminate;
    }
    
    /********* Cancelled by device **********/
    next_icon_state_on_error = SRV_DA_OMA_ICON_STATE_CANCELLED;

    /* Query FMGR whether the type of the icon is supported */
    {
        U16 *ext_in_U16;
        
        icon->mime_type = srv_da_util_lookup_mime_type((U8*)content_type, NULL, 0, 0);

        if (icon->mime_type == NULL || icon->mime_type->file_ext == NULL)
        {
            /* Invalid MIME type or unsupported MIME type */
            DA_TRACE_FUNC1(srv_da_oma_icon_session_http_response_callback, 10);
            goto srv_da_oma_icon_session_http_response_callback_terminate;
        }
        
        ext_in_U16 = (U16*)srv_da_adp_mem_allocate((strlen(icon->mime_type->file_ext) + 1) * sizeof(U16));
        mmi_asc_to_wcs(ext_in_U16, icon->mime_type->file_ext);
        icon_filetype = srv_fmgr_types_find_type_by_extension_str(ext_in_U16);
        srv_srv_da_adp_mem_free(ext_in_U16);

        /* Now we got icon_filetype */
    }

    if (!srv_fmgr_custicon_is_type_support(icon_filetype))
    {
        DA_TRACE_FUNC1(srv_da_oma_icon_session_http_response_callback, 20);
        goto srv_da_oma_icon_session_http_response_callback_terminate;
    }
    
    if (content_len > SRV_DA_OMA_MAX_ICON_SIZE)
    {
        DA_TRACE_FUNC1(srv_da_oma_icon_session_http_response_callback, 30);
        goto srv_da_oma_icon_session_http_response_callback_terminate;
    }

    if (srv_da_util_check_free_space(icon->filepath[0], content_len) == MMI_FALSE)
    {
        DA_TRACE_FUNC1(srv_da_oma_icon_session_http_response_callback, 40);
        goto srv_da_oma_icon_session_http_response_callback_terminate;
    }


    DA_TRACE_FUNC1(srv_da_oma_icon_session_http_response_callback, 99);

    return;
    
srv_da_oma_icon_session_http_response_callback_terminate:

    srv_da_oma_icon_terminate_download(job, next_icon_state_on_error);
    srv_da_oma_icon_trigger_next_procedure(job);
    
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_icon_session_dl_progress_callback
 * DESCRIPTION
 *  Callback function for progress indication for icon downloading.
 * PARAMETERS
 *  arg         [IN] srv_da_oma_icon_struct* icon
 *  status      [IN] message->status
 *  curr_size   [IN] file size
 *  cause       [IN] error cause (WPS internal value, do not use this field)
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_icon_session_dl_progress_callback(U32 arg, U8 status, U32 curr_size, S32 cause)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_icon_struct *icon;
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    icon = (srv_da_oma_icon_struct*)arg;
    job = icon->job;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (icon->session == SRV_DA_WPS_INVALID_SESSION)
    {
        return;
    }

    switch (status)
    {
        case WPS_DL_STATUS_DOWNLOADING:

            if (curr_size > SRV_DA_OMA_MAX_ICON_SIZE)
            {
                DA_TRACE_FUNC2(srv_da_oma_icon_session_dl_progress_callback, 10, curr_size);
                srv_da_oma_icon_terminate_download(job, SRV_DA_OMA_ICON_STATE_CANCELLED);
                srv_da_oma_icon_trigger_next_procedure(job);
            }
            
            break;
            
        case WPS_DL_STATUS_COMPLETE:
            DA_TRACE_FUNC1(srv_da_oma_icon_session_dl_progress_callback, 20);
            
            srv_da_wps_close_session(icon->session, NULL);
            icon->session = SRV_DA_WPS_INVALID_SESSION;
            icon->state = SRV_DA_OMA_ICON_STATE_SUCCEED;
            
            srv_da_oma_icon_trigger_next_procedure(job);
            
            break;
            
        case WPS_DL_STATUS_ABORT:
            DA_TRACE_FUNC2(srv_da_oma_icon_session_dl_progress_callback, 30, cause);
        
            if (icon->state != SRV_DA_OMA_ICON_STATE_CANCELLED)
            {
                /* Icon download was aborted by lower layer */
                srv_da_oma_icon_terminate_download(job, SRV_DA_OMA_ICON_STATE_FAILED);
                srv_da_oma_icon_trigger_next_procedure(job);
            }
            
            break;
    }
}

#endif /* __MMI_DA_OMA_ICONURI_SUPPORT__ */


#define SEND_REPORT

/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_terminate_job
 * DESCRIPTION
 *  Terminate a job. The job will be set in a termination state and update to
 *  client & user. Before termination, the resource hold by the job shall be
 *  released before.
 * PARAMETERS
 *  job     [IN/OUT] The job to be terminated
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_terminate_job(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job != NULL);
    
    if (job == da_oma_context.curr_job)
    {
        da_oma_context.curr_job = NULL;
    }

    if (job->state == SRV_DA_JOB_STATE_INIT)
    {
        srv_da_job_cancel(job);
    }
    else if (job->state == SRV_DA_JOB_STATE_PAUSED)
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
        srv_da_update_job_status(job);
    }
	else if (job->state == SRV_DA_JOB_STATE_RESUMING)
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
        srv_da_update_job_status(job);
    }
    else if (job->state == SRV_DA_JOB_STATE_ABORTED ||
             job->state == SRV_DA_JOB_STATE_FAILED)
    {
        srv_da_update_job_status(job);
    }
    else
    {
        MMI_ASSERT(0);
    }
}


/*****************************************************************************
* FUNCTION
*   srv_da_oma_popup_and_send_report
* DESCRIPTION
*   Send status report to server. After finish, we will destory the channel.
* PARAMETERS
*   error   IN  status code
* RETURNS
*   void
*****************************************************************************/
MMI_BOOL srv_da_oma_popup_and_send_report(srv_da_job_struct *job, S32 error, MMI_BOOL end_job, MMI_BOOL bpopup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct     *job_data = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC1(srv_da_oma_popup_and_send_report, error);

    /* if need do status report */
    if (job != NULL)
    {
        job_data = (srv_da_omadl_job_struct*)job->data_ptr;
        if(job_data)
        {
        if (job_data->dd_info.installNotifyURI != NULL)
        {
            if (srv_da_is_allowed_to_trigger_connection())
            {
                S8 *report_content;
                void (*result_callback)(void *arg, srv_da_oma_send_report_result_enum result, U32 status_code);
                
                srv_da_oma_report_map_string(error, NULL, &report_content);

                if (error == SRV_DA_OMA_SUCCESS)
                {
                    /* We need to wait for response */
                    result_callback = srv_da_oma_send_install_noti_result_callback;
                }
                else
                {
                    result_callback = NULL;
                }

                if (job_data->install_noti_session != 0)
                {
                    srv_da_oma_send_report_cancel(job_data->install_noti_session);
                }
                    
                job_data->install_noti_session = srv_da_oma_send_report(
                    job_data->dd_info.installNotifyURI,
                    report_content,
                    SRV_DA_OMA_SEND_REPORT_DEFAULT_NUM_TO_TRY,
                    job_data->channel,
                    job,
                    result_callback);

                if (error == SRV_DA_OMA_SUCCESS)
                {
                    /* We have to wait for result */
                    return MMI_TRUE;
                }
            }
            else if (error == SRV_DA_OMA_SUCCESS)
            {
                error = SRV_DA_OMA_USER_CANCELLED;
                end_job = MMI_TRUE;
                bpopup = MMI_TRUE;
            }
        }
    }
    }


    if (error != SRV_DA_OMA_SUCCESS)
    {
        if (bpopup)
        {
            srv_da_adp_oma_popup_message(job, (srv_da_oma_error_enum)error, end_job);
        }

        if (job_data != NULL && job_data->filepath != NULL && end_job)
        {
            srv_da_util_file_delete(job_data->filepath);
        }

        if (job != NULL)
        {
            srv_da_oma_close_session(job);
        }
        
        if (job != NULL && end_job)
        {
            srv_da_oma_terminate_job(job);
        }
    }
    else
    {
        MMI_ASSERT(job && (job->state == SRV_DA_JOB_STATE_COMPLETED ||
            job->state == SRV_DA_JOB_STATE_PROCESSING));
        /* clean up process will be done after dispatching */
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_install_noti_result_callback
 * DESCRIPTION
 *  Callback of sending install notification. If success, this function will
 *  release the object. Otherwise, the object will be discarded.
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 *  result      [IN] Result
 *  status      [IN] Status code the server responded
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_send_install_noti_result_callback(
    void *arg,
    srv_da_oma_send_report_result_enum result,
    U32 status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    U32                     err_stringid;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC2(srv_da_oma_send_report_callback, result, status);
    
    MMI_ASSERT(arg != NULL);
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;
    
    job_data->install_noti_session = 0;
    
    err_stringid = 0;
    
    if (result == SRV_DA_OMA_SEND_REPORT_RESULT_OK)
    {
        err_stringid = 0;
    }
    else if (result == SRV_DA_OMA_SEND_REPORT_RESULT_TIMEOUT)
    {
        /* "Well-Intentioned Attempt" */
        /* Since we do our best to send report but no response from server,
           allow to release object to user */
        err_stringid = 0;
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_OMA_WELL_INTENT_ATTEMPT, srv_da_oma_get_job_id(job));
    }
    else if(status == 401 || status == 407)
    {
        err_stringid = SRV_DA_AHTUENTICATION_FAILED;
    }
    else
    {
        err_stringid = SRV_DA_OMA_ERROR_SEND_REPORT_FAIL;
    }

    if(!job)
    {
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        if(err_stringid)
        {
            srv_da_adp_popup(err_stringid, 0, SRV_DA_POPUP_TYPE_ERROR);
        }
#endif
        return;
    }

    /* handle complete job */
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_PROCESSING);
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if(err_stringid)
    {
        /* there is error */
        job->state = SRV_DA_JOB_STATE_ABORTED;
        srv_da_util_file_delete(job_data->filepath);
        srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, err_stringid, MMI_TRUE);
        srv_da_update_job_status(job);

        return;
    }
    else
    {
        MMI_ASSERT(job_data->oma_state == SRV_DA_OMA_STATE_SENDING_INSTALL_NOTIFICATION);
        srv_da_oma_do_next_procedure(job);
    }
}


#define DRM_PROC

#ifdef __DRM_SUPPORT__

#ifdef __DRM_SUPPORT_SD_CALLBACK__

/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_drm_rights_arrived_callback
 * DESCRIPTION
 *  To be notified that DRM rights has been arrived.
 * PARAMETERS
 *  arg                     [IN]  srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_drm_rights_arrived_callback(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    srv_da_setting_struct setting;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    job_data->drm_wait_for_rights_session = NULL;
    job_data->drm_status = SRV_DA_DRM_STATUS_RIGHTS_ARRIVED;    
    job->state = SRV_DA_JOB_STATE_COMPLETED;

    /* Update do_dispatch */
    srv_da_oma_get_setting(job, &setting);
    srv_da_copy_setting(job, &setting);

    job->notified_complete = MMI_FALSE;

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    
    srv_da_update_job_status(job);
    
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

    srv_da_job_drm_save_as(job, job_data->drm_method);
        
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_drm_fail_to_wait_callback
 * DESCRIPTION
 *  Callback function for waiting DRM rights failed.
 * PARAMETERS
 *  arg                     [IN]  srv_da_job_struct*
 *  can_continue_waiting    [IN]  If MMI_TRUE, continue_waiting can set to be MMI_TRUE
 *  continue_waiting        [OUT] Continue waiting for rights infinitely
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_drm_fail_to_wait_callback(
    void *arg,
    drm_sd_expiry_type_enum cause,
    MMI_BOOL can_continue_waiting,
    MMI_BOOL *continue_waiting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (can_continue_waiting)
    {
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__

        *continue_waiting = MMI_TRUE;

        if (cause == DRM_SD_EXPIRY_TIMEOUT)
        {
            
            srv_da_adp_popup_long_msg_for_job(job, job_data->filepath)  ;
        }
            
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

        *continue_waiting = MMI_FALSE;
        job_data->drm_wait_for_rights_session = NULL;
        if (cause == DRM_SD_EXPIRY_TIMEOUT)
        {
            srv_da_adp_popup(SRV_DA_RIGHTS_DID_NOT_ARRIVE_ON_TIME, 0, SRV_DA_POPUP_TYPE_INFO);
        }

#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

    }
    else
    {
        *continue_waiting = MMI_FALSE;
        job_data->drm_wait_for_rights_session = NULL;
    }

    job_data->drm_status = SRV_DA_DRM_STATUS_NO_RIGHTS;
    job->state = SRV_DA_JOB_STATE_COMPLETED;
    
    /* notifyed_complete will be reset when rights arrived */
    job->notified_complete = MMI_TRUE;

    srv_da_update_job_status(job);
}

#endif /*__DRM_SUPPORT_SD_CALLBACK__ */


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_drm_process_callback
 * DESCRIPTION
 *  Callback for DRM processing result.
 * PARAMETERS
 *  arg             [IN] srv_da_job_struct*
 *  result          [IN] Processing result
 *  new_filepath    [IN] The filepath of processing result(output), it may be
 *                       the same to original path.
 *  method          [IN] DRM method
 *  is_archive      [IN] archive
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_drm_process_callback(
    void *arg,
    S32 result,
    const U16 *new_filepath,
    const applib_mime_type_struct *new_mime_type,
    drm_method_enum method,
    const srv_da_drm_result_info_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_omadl_job_struct *job_data;
    const applib_mime_type_struct *mime_type_to_rename;
    srv_da_setting_struct setting;
    U16 *filepath_after_moved;
    U16 *filename;
    U16 file_drive;
    S32 fs_error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    job_data->drm_process_session = NULL;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
    
        if (job_data->abort_callback != NULL)
        {
            job_data->abort_callback(job, 0);
        }

        return;
    }

    if (srv_da_job_update_content_by_drm_processing_result(
        job,
        MMI_DA_OMA_DOWNLOAD,
        result,
        new_filepath,
        new_mime_type,
        info))
    {
        mime_type_to_rename = new_mime_type;
        
#ifdef __DRM_V02__
        if(method == DRM_METHOD_V2) /* use .odf for drm 2.0 files */
        {
            mime_type_to_rename = applib_mime_type_look_up(NULL, NULL, MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_CONTENT_V2);
        }
#endif /* __DRM_V02__ */

        srv_da_oma_get_setting(job, &setting);

        filepath_after_moved = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_LEN + 1) * sizeof(U16));

        /* MAUI_01867210: Delete before moving can avoid name collision */
        if (mmi_wcsicmp(job_data->filepath, new_filepath) != 0)
        {
            /* Delete old file */
            srv_da_util_file_delete(job_data->filepath);
        }

        filename = srv_da_util_get_filename(job_data->filepath);
        
        /*
         * MAUI_01867210:
         * To let srv_da_move_as_new_type() can use original name.
         * Skip the name checking by srv_da_does_job_with_filepath_exist()
         */
        file_drive = job_data->filepath[0];
        job_data->filepath[0] = L'\0';
        
        fs_error = srv_da_move_as_new_type(
            new_filepath,
            setting.folder,
            filename,
            mime_type_to_rename,
            filepath_after_moved);

        /* Restore the full filepath to let redrawing correct */
        job_data->filepath[0] = file_drive;

        if (fs_error == FS_NO_ERROR)
        {
            U32 filepath_len;

            /* Reassign the filepath of the DRM processing result to job */
            filepath_len = mmi_wcslen(filepath_after_moved);
            srv_srv_da_adp_mem_free(job_data->filepath);
            job_data->filepath = (U16 *)srv_da_adp_mem_allocate((filepath_len + 1) * sizeof(U16));
            mmi_wcscpy(job_data->filepath, filepath_after_moved);

            srv_da_copy_setting(job, &setting);
            DRM_register_file((kal_wchar*)job_data->filepath);
            job_data->drm_method = method;

            /* Register icon first. If the file will be moved to another folder,
               it will notify FMGR to change the filepath later. */
            srv_da_oma_icon_register_for_file(job_data->icon, job_data->filepath);

#ifdef __DRM_SUPPORT_SD_CALLBACK__
            if (job_data->time_to_wait_for_rights >= 0 &&
                job->mime_type != NULL && /* Only wait for rights when the MIME type is supported */
                !srv_da_drm_has_rights(job_data->filepath, job->mime_type))
            {
                job_data->drm_wait_for_rights_session = srv_da_drm_wait_for_rights(
                    job_data->filepath,
                    job_data->time_to_wait_for_rights,
                    job,
                    srv_da_oma_drm_rights_arrived_callback,
                    srv_da_oma_drm_fail_to_wait_callback);

                if (job_data->drm_wait_for_rights_session != NULL)
                {
                    job_data->drm_status = SRV_DA_DRM_STATUS_WAITING_FOR_RIGHTS;
                }
                else
                {
                    /* Treat as fail to wait, no rights */
                    job_data->drm_status = SRV_DA_DRM_STATUS_NO_RIGHTS;
                    job->state = SRV_DA_JOB_STATE_COMPLETED;
                    job->setting_info.confirm_dispatch = MMI_FALSE;
                    job->setting_info.do_dispatch = MMI_FALSE;
                }

                srv_da_update_job_status(job);
                
            }
            else
#endif /* __DRM_SUPPORT_SD_CALLBACK__ */
            {
                job->state = SRV_DA_JOB_STATE_COMPLETED;
            
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__

                srv_da_update_job_status(job);
                
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

                srv_da_job_drm_save_as(job, method);
                    
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
            }
        }
        else
        {
            srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_FS_ERROR, fs_error, 0, MMI_TRUE);
            srv_da_update_job_status(job);
        }

        srv_srv_da_adp_mem_free(filepath_after_moved);
    }
    else
    {
        srv_da_update_job_status(job);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_drm_process
 * DESCRIPTION
 *  Do DRM process for the job. srv_da_oma_drm_process_callback will be called
 *  to notify the processing result.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_drm_process(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    MMI_BOOL need_to_wait;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    job->state = SRV_DA_JOB_STATE_PROCESSING;

    job_data->drm_wait_for_rights_session = NULL;
    job_data->drm_process_session = srv_da_drm_process(
        job_data->filepath,
        job->mime_type,
        &need_to_wait,
        job,
        srv_da_oma_drm_process_callback);

    if (job_data->drm_process_session != NULL)
    {
        if (need_to_wait)
        {
            job_data->drm_status = SRV_DA_DRM_STATUS_PROCESSING;
            srv_da_update_job_status(job);
        }
    }
    else
    {
        /* If no need to wait, it will call the callback function directly */
        /* Whatever the case is, the callback function will be called finally. */
    }
}


#endif /* __DRM_SUPPORT__ */

#define AUTO_RESUME

#ifdef __MMI_DA_RESUME__
/*
 * Yes, the code is very similar to HTTP auto-resume.
 * But it is not easy to extract common code and init/destroy requests gracefully.
 * If we have template mechanism like C++, we can do this easily.
 */

/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_auto_resume_failed
 * DESCRIPTION
 *  Procedure for auto-resume failed.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_auto_resume_failed(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
    }
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if (job->setting_info.can_minimize)
    {
        job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_LOSS_OF_SERVICE, MMI_FALSE, MMI_TRUE);
        srv_da_update_job_status(job);
    }
    else
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
        srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_LOSS_OF_SERVICE, MMI_TRUE, MMI_TRUE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_auto_resume_wps_created_callback
 * DESCRIPTION
 *  Auto-resume
 *  When WPS session is created successfully, send HTTP request.
 * PARAMETERS
 *  success     [IN] Session is created successfully
 *  arg         [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_auto_resume_wps_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;
    S8                          *header;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        return;
    }

    MMI_EXT_ASSERT(job->state == SRV_DA_JOB_STATE_DOWNLOADING, job->state, 0, 0);

    if (!success)
    {
        srv_da_oma_auto_resume_failed(job);
    }
    else
    {
        header = (S8 *)srv_da_adp_mem_allocate(128);
        
        if (!srv_da_wps_http_req(
            job_data->session,
            WPS_HTTP_METHOD_GET,
            job_data->dd_info.objectURI,
            srv_da_util_gen_http_header_to_resume(header, job_data->etag, job_data->curr_size),
            NULL,
            job_data->filepath,
            0))
        {
            MMI_ASSERT(0);
        }

        srv_srv_da_adp_mem_free(header);
    }
    
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_auto_resume_wps_created_callback
 * DESCRIPTION
 *  For auto-resume.
 *  Check the HTTP response, to determine whether we successfully resumed.
 *  If not, prompt error message to the user eventually.
 * PARAMETERS
 *  arg             [IN] (mmi_da_oma_send_report_session_struct*)Session
 *  result          [IN] Result
 *  status          [IN] Status code which server responded
 *  header          [IN] HTTP header
 *  content_type    [IN] Content-Type
 *  content_len     [IN] Content-Length
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_auto_resume_wps_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;
    const applib_mime_type_struct *mime_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        return;
    }

    MMI_EXT_ASSERT(job->state == SRV_DA_JOB_STATE_DOWNLOADING, job->state, 0, 0);

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_AUTO_RESUME_HTTP_RSP,
            DA_MAKE_UNIQUE_ID(job, job_data->unique_id), result, status,
            job_data->curr_size, content_len, job_data->size);

    /* check result */
    if(result != WPS_OK)
    {
        goto auto_resume_failed;
    }
    else
    {
        if (status != 206)
        {
            goto auto_resume_failed;
        }
        else
        {
            if (content_len == 0)
            {
                /* We can not guarantee the content is the same to before */
                goto auto_resume_failed;
            }
            else if (job_data->curr_size + content_len != job_data->size)
            {
                goto auto_resume_failed;
            }
        }
    }
    
    /* check mimetype */
    mime_type = srv_da_util_lookup_mime_type((U8*)content_type, NULL, 0, 0);

    /* Suppose their pointers will be the same (the same entry of our MIME type table) */
    if(job->mime_type != mime_type)
    {
        goto auto_resume_failed;
    }
    
    return;
    
auto_resume_failed:

    srv_da_oma_auto_resume_failed(job);
    
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_auto_resume_auth_ind_callback
 * DESCRIPTION
 *  Treat as resume failed if need authentication again.
 * PARAMETERS
 *  arg         [IN] (srv_da_job_struct*)Job
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_auto_resume_auth_ind_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
	srv_da_omadl_job_struct		*job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)arg;

    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    /* if auth info not valid yet, it means user need re-input */
    if(!job_data->auth_password || !job_data->auth_username || !job_data->auth_is_info_valid)
    {
   #ifndef MMI_DA_PLUTO_SLIM
        srv_da_adp_show_user_auth_screen((U32) job, srv_da_oma_user_auth_callback);
   #endif
    }
    else
    {
        srv_da_wps_session_auth_UCS2(job_data->session, job_data->auth_username, job_data->auth_password);
    }
    }




/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_auto_resume_try_to_resume
 * DESCRIPTION
 *  For auto-resume.
 *  Try to resume. If the job is not in DOWNLOADING state, the resumption
 *  will not be triggered.
 * PARAMETERS
 *  arg         [IN] (srv_da_job_struct*)Job
 *  unique_id   [IN] This ID should match the job's
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_auto_resume_try_to_resume(void *arg, S32 unique_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if (!srv_da_is_job_valid(job) ||
        job->type != SRV_DA_JOB_TYPE_OMADL ||
        job_data->unique_id != unique_id)
    {
        return;
    }

    /* To auto resume, the state should be still DOWNLOADING */
    if (job->state != SRV_DA_JOB_STATE_DOWNLOADING)
    {
        return;
    }
    
    MMI_ASSERT(job_data->session == SRV_DA_WPS_INVALID_SESSION);

    if (srv_da_is_allowed_to_trigger_connection())
    {
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_AUTO_RESUME_TRY,
            DA_MAKE_UNIQUE_ID(job, job_data->unique_id), job_data->curr_size);
    
        job_data->session = srv_da_wps_create_session_ex((U32)job,
                              SRV_DA_WPS_SETTING_DEFAULT,
                              job_data->channel,
                              srv_da_oma_auto_resume_wps_created_callback,
                              srv_da_oma_auto_resume_wps_http_response_callback,
                              srv_da_oma_auto_resume_auth_ind_callback,
                              srv_da_oma_session_dl_progress_callback);

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
        if (job->dl_flag & DA_DL_FLAG_SPECIAL)
        {
            MMI_BOOL unbuffered_write = MMI_TRUE;
            srv_da_wps_session_set_option(job_data->session,
                SRV_DA_WPS_OPTION_UNBUFFERED_WRITE,
                &(unbuffered_write));
        }
#endif /* __MMI_DA_OMADL_CUST_CHL_SUPPORT__ */

    }
    else
    {
        srv_da_oma_auto_resume_failed(job);
    }
}

#endif /* __MMI_DA_RESUME__ */

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  srv_da_start_oma_download
 * DESCRIPTION
 *  Now only DM can call this function.
 *  WILL BE DISCARDED IN THE FUTURE!
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_start_oma_download(
    S8* dd_filepath,
    void* req_data, 
    BOOL show_confirm,
    srv_da_dl_report_callback cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;
    wps_set_channel_req_struct  *req = (wps_set_channel_req_struct*)req_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_START_OMA_DL, (U32)dd_filepath, (U32)req_data, show_confirm, (U32)cb);
    
    DA_TRACE_FUNC2(srv_da_start_oma_download, 1, show_confirm);

    /* parse message & allocate a new job */
    job = srv_da_job_create_ex(SRV_DA_JOB_TYPE_OMADL, NULL);
    
    if (!job)
    {
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        DA_TRACE_FUNC2(srv_da_start_oma_download, 2, srv_da_get_last_error());
#endif

        srv_da_oma_popup_and_send_report(NULL, SRV_DA_OMA_DEVICE_ABORTED, MMI_TRUE, MMI_FALSE);
        
        if (cb != NULL)
        {
            cb(MMI_FALSE);
        }
        
        return;
    }
    
    job->dl_flag = DA_DL_FLAG_SPECIAL;
    
    srv_da_job_set_notify_callback(job, cb);
    
    if(!show_confirm)
        job->dl_flag |= DA_DL_FLAG_SKIP_CONFIRM;

    DA_ALLOC_OBJ(job_data, srv_da_omadl_job_struct);

    job->data_ptr = job_data;
     
    UCS2_STR_MALLOC_COPY(job_data->dd_filepath, dd_filepath);
    ANSI_STR_MALLOC_COPY(job_data->dd_url, "local://", 10);
    job_data->unique_id = srv_da_job_get_new_unique_id();
    job_data->etag = NULL;
    job_data->drm_status = SRV_DA_DRM_STATUS_NONE;
#ifdef __DRM_SUPPORT__
    job_data->drm_method = DRM_METHOD_NONE;
#endif
    job_data->drm_process_session = NULL;
    job_data->drm_wait_for_rights_session = NULL;
    job_data->time_to_wait_for_rights = -1;
    job_data->size = 0;
    
    if (req != NULL)
    {
        job_data->channel = srv_da_wps_reserve_cust_channel(req);
    }
    else
    {
        job_data->channel = SRV_DA_WPS_DEFAULT_CHANNEL;
    }
    
    srv_da_oma_parse_dd_and_show_confirm(job);
}
#endif

srv_da_job_struct* srv_da_oma_get_current_job (void)
{
    return da_oma_context.curr_job;
}

void srv_da_oma_set_current_job (srv_da_job_struct *job)
{
    da_oma_context.curr_job = job;
}

MMI_BOOL srv_da_oma_is_oma_processing_required (const applib_mime_type_struct *type)
{
    if (type &&
        (
    #ifdef __MMI_OMA_DD_DOWNLOAD__
         type->mime_subtype == MIME_SUBTYPE_OMA_DD ||
    #endif
    #ifdef __MMI_OMA_DD2_DOWNLOAD__
         type->mime_subtype == MIME_SUBTYPE_OMA_DD2 ||
    #endif
         MMI_FALSE ))
    {
        return MMI_TRUE;
    }
    return MMI_FALSE;
}

MMI_BOOL srv_da_oma_extract_dd_content_string (srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_omadl_job_struct *job_data;
    S8          ddcontent[1000];
    S8          ddcontent2[2000];
    FS_HANDLE   hd = -1;
    UINT        fileSize, sizeRead;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = job->data_ptr;
    
    /* load text from DD */
    if ((hd = FS_Open(job_data->dd_filepath, FS_READ_ONLY)) < 0)
        goto errorFs;

    if(FS_GetFileSize(hd, &fileSize) < 0)
        goto errorFs;

    if(FS_Read(hd, ddcontent, fileSize, &sizeRead)<0)
        goto errorFs;

    ddcontent[sizeRead] = '\0';
    FS_Close(hd);
    hd = -1;

    mmi_chset_convert(MMI_CHSET_UTF8, MMI_CHSET_UCS2, (S8*)ddcontent, (S8*)ddcontent2, 1998); /*TODO: remove hardcoding */

    return MMI_TRUE;

    /* clean up if there is error */
errorFs:
    srv_da_adp_popup(0, hd, SRV_DA_POPUP_TYPE_FS_ERROR);

    if(hd >= 0)
        FS_Close(hd);
    return MMI_FALSE;
}


void srv_da_oma_fill_message_string(void *arg, U16 *buffer, U32 buffer_len)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */
}



void srv_da_oma_http_auth_ind_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && job->type == SRV_DA_JOB_TYPE_OMADL);
#ifndef MMI_DA_PLUTO_SLIM
    srv_da_adp_show_user_auth_screen ((U32) job, srv_da_oma_user_auth_callback);
#endif
#if 0
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
/* under construction !*/
#if 0 //sahil to do in app       
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0
/* under construction !*/
#endif /* 0 */
}


void srv_da_oma_confirm_download_callback(void *arg, U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_omadl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_omadl_job_struct*)job->data_ptr;

    if(filepath == NULL)
    {
        /*----------------------------------------------------------------*/
        /* Local Variables                                                */
        /*----------------------------------------------------------------*/

        /*----------------------------------------------------------------*/
        /* Code Body                                                      */
        /*----------------------------------------------------------------*/
        MMI_ASSERT(srv_da_oma_get_current_job() == NULL || srv_da_oma_get_current_job() == job);
    #ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
        if (job->dl_flag & DA_DL_FLAG_SPECIAL)
        {
            srv_da_oma_select_storage(job);
            return;
        }
    #endif

    #ifdef MMI_DA_CFG_OMA_EXPOSE_DD_TO_USER
        srv_da_oma_set_current_job(job);
        srv_da_adp_display_oma_download_options((U32)job);
    #else
        srv_da_oma_select_storage(job);
    #endif
    }
    else
    {
    srv_da_set_allow_to_trigger_connection(MMI_TRUE);
    
    UCS2_STR_MALLOC_COPY(job_data->filepath, filepath);

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if(job->dl_flag & DA_DL_FLAG_SPECIAL)
    {
        FS_HANDLE hd;
        if ((hd = FS_Open((PU16)filepath, FS_READ_ONLY)) >= 0)
        {
            FS_GetFileSize(hd, &(job_data->curr_size));
            FS_Close(hd);
        }
    }
#endif
        
    srv_da_oma_set_current_job(NULL);

    job_data->session = srv_da_wps_create_session_ex(
        (U32)job,
        SRV_DA_WPS_SETTING_DEFAULT,
        job_data->channel,
        srv_da_oma_session_created_callback,
        srv_da_oma_http_response_callback,
        srv_da_oma_http_auth_ind_callback,
        srv_da_oma_session_dl_progress_callback);

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if (job->dl_flag & DA_DL_FLAG_SPECIAL)
    {
        MMI_BOOL unbuffered_write;
        unbuffered_write = MMI_TRUE;
        srv_da_wps_session_set_option(job_data->session, SRV_DA_WPS_OPTION_UNBUFFERED_WRITE, &(unbuffered_write));
    }
#endif
}
}

void srv_da_oma_download_cancel_callback(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    
    srv_da_oma_open_nextURL(job);
    /* VIKAS */
    srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_TRUE, MMI_FALSE);
}

void srv_da_oma_delete_screen_callback(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    srv_da_oma_popup_and_send_report(job, SRV_DA_OMA_USER_CANCELLED, MMI_TRUE, MMI_FALSE);
}



/****************************************************************************
 * [Report Service]
 *
 * This utility is used to send OMA report. It provides capability of retrying,
 * and session automatical handling. It can send report in background, so that
 * clients can "launch-and-forget."
 ****************************************************************************/

/****************************************************************************
 * Constants & Configurations
 ****************************************************************************/

/*
 * If number of session sending report >= this value,
 * the session which has smallest num_to_try will stop re-sending.
 */
#define SRV_DA_OMA_SEND_REPORT_RESEND_THRESHOLD 3


#define SRV_DA_OMA_SEND_REPORT_INITED_MAGIC 0x68473827


/****************************************************************************
 * Typedef
 ****************************************************************************/

typedef struct srv_da_oma_send_report_session_struct_s
{
    U32 id;
    S8 *uri_to_post;
    S8 *content;
    U32 num_to_try;
    void *arg;
    void (*result_callback)(void *arg, srv_da_oma_send_report_result_enum result, U32 status_code);
    
    srv_da_wps_session_handle wps_session;

    struct srv_da_oma_send_report_session_struct_s *next;
} srv_da_oma_send_report_session_struct;


typedef struct
{
    /* For lazy initialization. If initialized, this field will set to SRV_DA_OMA_SEND_REPORT_INITED_MAGIC */
    U32 inited_magic;
    
    srv_da_oma_send_report_session_struct *session_list;
    U16 num_of_sessions;
    
    MMI_BOOL can_retry;
} srv_da_oma_send_report_context_struct;


/****************************************************************************
 * Global Variable
 ****************************************************************************/

static srv_da_oma_send_report_context_struct g_srv_da_oma_send_report_cntx;


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_init
 * DESCRIPTION
 *  Initialize send-report service. Before using send-report, be sure to
 *  initialize first.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_send_report_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (g_srv_da_oma_send_report_cntx.inited_magic != SRV_DA_OMA_SEND_REPORT_INITED_MAGIC)
    {
        g_srv_da_oma_send_report_cntx.num_of_sessions = 0;
        g_srv_da_oma_send_report_cntx.session_list = NULL;
        g_srv_da_oma_send_report_cntx.can_retry = MMI_TRUE;
        g_srv_da_oma_send_report_cntx.inited_magic = SRV_DA_OMA_SEND_REPORT_INITED_MAGIC;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_can_retry
 * DESCRIPTION
 *  Test if it is proper to resend in current situation.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
#define srv_da_oma_send_report_can_retry() \
    (g_srv_da_oma_send_report_cntx.can_retry && srv_da_is_allowed_to_trigger_connection())


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_is_session_valid
 * DESCRIPTION
 *  Check the validity of a session.
 * PARAMETERS
 *  session     [IN] Session
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL srv_da_oma_send_report_is_session_valid(srv_da_oma_send_report_session_struct *session)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session_in_list;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (session_in_list = g_srv_da_oma_send_report_cntx.session_list; session_in_list != NULL; session_in_list = session_in_list->next)
    {
        if (session_in_list == session)
        {
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_new_session_id
 * DESCRIPTION
 *  Get a new and unique ID for session.
 * PARAMETERS
 *  void
 * RETURNS
 *  Unique ID
 *****************************************************************************/
static U32 srv_da_oma_send_report_new_session_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U32 next_id = 1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (next_id++);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_free_session
 * DESCRIPTION
 *  Free session. This function will remove the session from list and
 *  free all resource it used.
 * PARAMETERS
 *  session     [IN] Session
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_send_report_free_session(srv_da_oma_send_report_session_struct *session)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *s_in_list;
    srv_da_oma_send_report_session_struct *prev;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    prev = NULL;
    for (s_in_list = g_srv_da_oma_send_report_cntx.session_list; s_in_list != NULL; s_in_list = s_in_list->next)
    {
        if (s_in_list == session && s_in_list->id == session->id)
        {
            break;
        }

        prev = s_in_list;
    }

    if (s_in_list == NULL)
    {
        return;
    }

    /* Remove from list */
    if (prev == NULL)
    {
        g_srv_da_oma_send_report_cntx.session_list = session->next;
    }
    else
    {
        prev->next = session->next;
    }

    g_srv_da_oma_send_report_cntx.num_of_sessions--;
    
    
    srv_srv_da_adp_mem_free(session->uri_to_post);
    srv_srv_da_adp_mem_free(session->content);
    if (session->wps_session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(session->wps_session, NULL);
    }
    srv_srv_da_adp_mem_free(session);

}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_get_session_by_id
 * DESCRIPTION
 *  Search the list, get the session which ID equals to the given.
 * PARAMETERS
 *  id      [IN] Session ID
 * RETURNS
 *  Session; NULL if not found.
 *****************************************************************************/
static srv_da_oma_send_report_session_struct* srv_da_oma_send_report_get_session_by_id(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (session = g_srv_da_oma_send_report_cntx.session_list; session != NULL; session = session->next)
    {
        if (session->id == id)
        {
            break;
        }
    }

    return session; /* If not found, returns NULL */
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_do_post
 * DESCRIPTION
 *  Post report to server and decrease num_to_try.
 * PARAMETERS
 *  arg     [IN/OUT] (srv_da_oma_send_report_session_struct*)Session
 *  id      [IN] Session ID
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_send_report_do_post(void *arg, S32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    session = (srv_da_oma_send_report_session_struct*)arg;

    if (!srv_da_oma_send_report_is_session_valid(session) || session->id != (U32)id)
    {
        return;
    }

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_OMA_SEND_REPORT, session->id, session->num_to_try);

    if (session->num_to_try > 0)
    {
        session->num_to_try--;
    }

    srv_da_wps_http_req(session->wps_session,
        WPS_HTTP_METHOD_POST,
        session->uri_to_post,
        NULL,
        session->content,
        NULL,
        0);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_session_created_callback
 * DESCRIPTION
 *  Session created handler for WPS service.
 * PARAMETERS
 *  success     [IN] MMI_TRUE if session is created successfully.
 *  arg         [IN] Session
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_send_report_session_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    session = (srv_da_oma_send_report_session_struct*)arg;

    if (!srv_da_oma_send_report_is_session_valid(session))
    {
        return;
    }

    if (!success)
    {
        if (session->result_callback != NULL)
        {
            session->result_callback(session->arg, SRV_DA_OMA_SEND_REPORT_RESULT_FAILED, 0);
        }
        srv_da_oma_send_report_free_session(session);
        return;
    }
    
    srv_da_oma_send_report_do_post(session, session->id);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_http_response_callback
 * DESCRIPTION
 *  HTTP response handler for WPS session.
 * PARAMETERS
 *  arg             [IN] (srv_da_oma_send_report_session_struct*)Session
 *  result          [IN] Result
 *  status          [IN] Status code which server responded
 *  header          [IN] HTTP header
 *  content_type    [IN] Content-Type
 *  content_len     [IN] Content-Length
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_send_report_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    session = (srv_da_oma_send_report_session_struct*)arg;

    if (!srv_da_oma_send_report_is_session_valid(session))
    {
        return;
    }

    if (result == WPS_OK)
    {
        if (session->result_callback != NULL)
        {
            srv_da_oma_send_report_result_enum result;

            if (200 <= status && status < 300)
            {
                result = SRV_DA_OMA_SEND_REPORT_RESULT_OK;
            }
            else if (status == 504) /* 504 Gateway timeout */
            {
                result = SRV_DA_OMA_SEND_REPORT_RESULT_TIMEOUT;
            }
            else
            {
                result = SRV_DA_OMA_SEND_REPORT_RESULT_FAILED;
            }

            srv_da_wps_close_session(session->wps_session, NULL);
            session->wps_session = SRV_DA_WPS_INVALID_SESSION;
        
            session->result_callback(session->arg, result, status);
        }
        
        srv_da_oma_send_report_free_session(session);
    }
    else if ((result == WPS_ERROR_REQ_ABORT && rsp->cause == WPS_CAUSE_COMM_NO_RESPONSE) && /* Timeout */
        srv_da_oma_send_report_can_retry())
    {
        if (session->num_to_try > 0)
        {
            srv_da_util_trigger_proc_ext(srv_da_oma_send_report_do_post, session, session->id);
        }
        else /* Exceeds max number to retry */
        {
            srv_da_wps_close_session(session->wps_session, NULL);
            session->wps_session = SRV_DA_WPS_INVALID_SESSION;

            if (session->result_callback != NULL)
            {
                session->result_callback(session->arg, SRV_DA_OMA_SEND_REPORT_RESULT_TIMEOUT, status);
            }

            srv_da_oma_send_report_free_session(session);
        }
    }
    else /* Other error */
    {
        if (session->num_to_try > 0 &&
            srv_da_oma_send_report_can_retry() &&
            (session->result_callback != NULL && srv_da_wps_is_bearer_activated((U32)session->arg)))
        {
            srv_da_util_trigger_proc_ext(srv_da_oma_send_report_do_post, session, session->id);
        }
        else
        {
            if (session->num_to_try > 0)
            {
                MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_OMA_SEND_REPORT_STOP_RETRY, session->id, session->num_to_try);
            }
        
            if (session->result_callback != NULL)
            {
                srv_da_wps_close_session(session->wps_session, NULL);
                session->wps_session = SRV_DA_WPS_INVALID_SESSION;
            
                session->result_callback(session->arg, SRV_DA_OMA_SEND_REPORT_RESULT_FAILED, status);
            }

            srv_da_oma_send_report_free_session(session);
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_http_auth_callback
 * DESCRIPTION
 *  HTTP authtication handler for WPS session.
 *  Stop sending report and notify FAILED.
 * PARAMETERS
 *  arg         [IN] (srv_da_oma_send_report_session_struct*)Session
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_oma_send_report_http_auth_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    session = (srv_da_oma_send_report_session_struct*)arg;

    if (!srv_da_oma_send_report_is_session_valid(session))
    {
        return;
    }
    
    if (session->result_callback != NULL)
    {
        srv_da_wps_close_session(session->wps_session, NULL);
        session->wps_session = SRV_DA_WPS_INVALID_SESSION;
        
        session->result_callback(session->arg, SRV_DA_OMA_SEND_REPORT_RESULT_FAILED, 401); /* 401 Unauthroized */
    }

    srv_da_oma_send_report_free_session(session);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report
 * DESCRIPTION
 *  Start to send report.
 * PARAMETERS
 *  uri_to_post     [IN] The URI to post report.
 *  content         [IN] Report
 *  num_to_try      [IN] The total number to send report if no response.
 *  channel         [IN] Use specific channel, can be SRV_DA_WPS_DEFAULT_CHANNEL.
 *  arg             [IN] Will be passed to result_callback()
 *  result_callback [IN] Result callback function
 * RETURNS
 *  Session ID; will not be 0 if the session was created successfully
 *****************************************************************************/
U32 srv_da_oma_send_report(
    const S8 *uri_to_post,
    const S8 *content,
    U32 num_to_try,
    srv_da_wps_channel_handle channel,
    void *arg,
    void (*result_callback)(void *arg, srv_da_oma_send_report_result_enum result, U32 status_code))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_init();
    
    if (num_to_try == 0)
    {
        num_to_try = SRV_DA_OMA_SEND_REPORT_DEFAULT_NUM_TO_TRY;
    }

    g_srv_da_oma_send_report_cntx.can_retry = MMI_TRUE;
    
    session = (srv_da_oma_send_report_session_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_oma_send_report_session_struct));

    session->id = srv_da_oma_send_report_new_session_id();
    session->uri_to_post = (S8 *) srv_da_adp_mem_allocate(strlen(uri_to_post) + 1);
    strcpy(session->uri_to_post, uri_to_post);
    session->content = (S8 *)srv_da_adp_mem_allocate(strlen(content) + 1);
    strcpy(session->content, content);
    session->num_to_try = num_to_try;
    session->arg = arg;
    session->result_callback = result_callback;
    session->wps_session = SRV_DA_WPS_INVALID_SESSION;

    session->next = g_srv_da_oma_send_report_cntx.session_list;
    g_srv_da_oma_send_report_cntx.session_list = session;
    g_srv_da_oma_send_report_cntx.num_of_sessions++;


    if (g_srv_da_oma_send_report_cntx.num_of_sessions >= SRV_DA_OMA_SEND_REPORT_RESEND_THRESHOLD)
    {
        srv_da_oma_send_report_session_struct *candidate;
        srv_da_oma_send_report_session_struct *s_in_list;

        candidate = session->next;

        if (candidate != NULL)
        {
            /* Pick the session which has smallest num_to_try */
            for (s_in_list = candidate; s_in_list != NULL; s_in_list = s_in_list->next)
            {
                if (s_in_list->result_callback == NULL && candidate->result_callback != NULL)
                {
                    /* Pick the report not need to notify user first */
                    candidate = s_in_list;
                }
                else if (
                    ((s_in_list->result_callback != NULL && candidate->result_callback != NULL) ||
                        (s_in_list->result_callback == NULL && candidate->result_callback == NULL)) &&
                    s_in_list->num_to_try < candidate->num_to_try)
                {
                    /* Pick the report has smallest num_to_try first */
                    candidate = s_in_list;
                }
            }

            MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_OMA_SEND_REPORT_STOP_RETRY,
                candidate->id, candidate->num_to_try);

            /* Stop retrying */
            candidate->num_to_try = 0;
        }
    }

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if (channel != SRV_DA_WPS_DEFAULT_CHANNEL)
    {
        session->wps_session = srv_da_wps_create_session_ex(
            (U32)session,
            SRV_DA_WPS_SETTING_OMA_REPORT,
            channel,
            srv_da_oma_send_report_session_created_callback,
            srv_da_oma_send_report_http_response_callback,
            srv_da_oma_send_report_http_auth_callback,
            NULL);
    }
    else
#endif
    {
        session->wps_session = srv_da_wps_create_session(
            (U32)session,
            SRV_DA_WPS_SETTING_OMA_REPORT,
            srv_da_oma_send_report_session_created_callback,
            srv_da_oma_send_report_http_response_callback,
            srv_da_oma_send_report_http_auth_callback,
            NULL);
    }

    return session->id;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_cancel
 * DESCRIPTION
 *  Stop sending report.
 * PARAMETERS
 *  session_id  [IN] Session ID
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_send_report_cancel(U32 session_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_send_report_session_struct *session;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    session = srv_da_oma_send_report_get_session_by_id(session_id);

    if (session == NULL)
    {
        return;
    }

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_OMA_SEND_REPORT_CANCEL, session->id, session->num_to_try);

    srv_da_oma_send_report_free_session(session);
    
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_get_number_of_sessions
 * DESCRIPTION
 *  Get the number of reports sending.
 * PARAMETERS
 *  void
 * RETURNS
 *  The number of reports sending.
 *****************************************************************************/
U32 srv_da_oma_send_report_get_number_of_sessions(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_srv_da_oma_send_report_cntx.num_of_sessions;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_oma_send_report_stop_retrying
 * DESCRIPTION
 *  Stop re-sending.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_oma_send_report_stop_retrying(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_srv_da_oma_send_report_cntx.can_retry = MMI_FALSE;
}
void srv_da_oma_set_storage_selection(MMI_BOOL new_value)
{
#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
    da_storage_selection = new_value;
#endif
}
#endif /*__MMI_OMA_DD_DOWNLOAD__ */
#endif /* __MMI_DOWNLOAD_AGENT__ */

