/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

#include "MMI_include.h"

#if defined (__MMI_DOWNLOAD_AGENT__)

//#include "CommonScreens.h"
//#include "ProtocolEvents.h"
#include "app_mine.h"

#include "FileMgrSrvGprot.h"
#include "FileMgrCuiGProt.h"            /* cui_file_option_is_any_option */

//#include "drm_def.h"                    /* DRM_PROC_RESULT_OK */
//#include "drm_gprot.h"
#include "DLAgentSrvDef.h"
//#include "DLAgentGprot.h"
#include "DLAgentSrvIProt.h"
#include "DLAgentSrvProt.h"
#ifdef __MMI_DOWNLOAD_AGENT__
#include "mmi_rp_srv_downloadagent_def.h"
#endif

//#include "SimDetectionDef.h"            /* SCR_SIM_INSERTION and SCR_SIM_BLOCK */
#include "IdleAppDef.h"                 /* IDLE_SCREEN_ID */
#include "UCMGProt.h"

//#include "wps_struct.h"
#include "das_struct.h"

//#include "SimDetectionGprot.h"          /* for EDGE status */

#ifndef __COSMOS_MMI_PACKAGE__
#if !defined(__IOT__)
#ifdef __UM_SUPPORT__
#include "mmi_rp_app_unifiedmessage_def.h"
#else
#include "mmi_rp_app_sms_def.h"
#endif
#endif
#endif



    #include "MMIDataType.h"
    #include "stack_msgs.h"
    #include "mmi_frm_queue_gprot.h"
    #include "app_ltlcom.h"
    #include "stack_config.h"
    #include "stack_common.h"
    #include "kal_general_types.h"
    #include "UcmSrvGprot.h"
    #include "fs_errcode.h"
    #include "mmi_rp_srv_downloadagent_def.h"
    #include "GlobalResDef.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "fs_func.h"
    #include "MMI_features.h"
    #include "fs_type.h"
    #include "MMI_conn_app_trc.h"
    #include "mmi_conn_app_trc.h"
    #include "kal_trace.h"
    #include "Unicodexdcl.h"
    #include "FileMgrType.h"
    #include "string.h"
    #include "stdlib.h"
    #include "mmi_frm_mem_gprot.h"
    #include "stdio.h"
    #include "CustDataRes.h"
    #include "app_str.h"
    #include "lcd_sw_inc.h"
    #include "Gui_Setting.h"
    #include "mmi_res_range_def.h"
    #include "wgui_categories_util.h"
    #include "GlobalMenuItems.h"
    #include "mmi_frm_timer_gprot.h"
    #include "mmi_frm_events_gprot.h"

/*****************************************************************************
 * Function Declarations
 *****************************************************************************/
 
static void srv_da_timer_triggered_proc_init(void);


/*****************************************************************************
 * Global Functions
 *****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  srv_da_util_init
 * DESCRIPTION
 *  Initialize utilities.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_util_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_timer_triggered_proc_init();
}



/*************************************************************************
* FUNCTION
*   srv_da_is_in_voice_call
* DESCRIPTION
*   this function use to detect taht current have voice call or not
* PARAMETERS
*   void
* RETURNS
*   KAL_TRUE or KAL_FALSE
*************************************************************************/
MMI_BOOL srv_da_is_in_voice_call(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(srv_ucm_query_call_count(SRV_UCM_CALL_STATE_ALL, SRV_UCM_CALL_TYPE_NO_CSD, NULL) > 0)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
srv_da_error_enum srv_da_wap_error_to_internal_error(S32 error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* original error code in DL , do not transfer */
    switch(error)
    {
        case WAP_DL_ERROR_OK:
            return SRV_DA_SUCCESS;
        case WAP_DL_ERROR_CONNECTION_CLOSED:
            return SRV_DA_ERROR_CONNECTION_CLOSED;
        case FS_DISK_FULL:
        case WAP_DL_ERROR_DISK_FULL:
            return SRV_DA_ERROR_DISK_FULL;
        case WAP_DL_ERROR_FILE_ACCESS:
            return SRV_DA_ERROR_FILE_ACCESS;
        default:
            if (error < 0)
            {
                return SRV_DA_ERROR_FILE_ACCESS;
            }
            break;
    }

    return SRV_DA_ERROR_OTHERS;
}

S32 srv_da_util_state_transfer(srv_da_job_state_enum state)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    // TODO: revise the state
    switch(state)
    {
    case SRV_DA_JOB_STATE_INIT:
        return SRV_DA_STATE_INIT;

    case SRV_DA_JOB_STATE_ABORTING:
    case SRV_DA_JOB_STATE_PROCESSING:
    case SRV_DA_JOB_STATE_DOWNLOADING:
        return SRV_DA_STATE_DOWNLOADING;

    case SRV_DA_JOB_STATE_PAUSED:
	case SRV_DA_JOB_STATE_RESUMING:
        return SRV_DA_STATE_PAUSE;
        
    case SRV_DA_JOB_STATE_ABORTED:
    case SRV_DA_JOB_STATE_FAILED:
        return SRV_DA_STATE_ABORT;
        
    case SRV_DA_JOB_STATE_COMPLETED:
        return SRV_DA_STATE_COMPLETE;

    default:
        MMI_ASSERT(0);
        return SRV_DA_STATE_INIT;
    }
}


#define API_FILE


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_file_delete
 * DESCRIPTION
 *  Delete a file downloaded.
 *  For temporary files, FS_Delete() can be called directly to improve performance.
 * PARAMETERS
 *  filepath    [IN] file path
 * RETURNS
 *  Error code returned by file system delete function
 *****************************************************************************/
S32 srv_da_util_file_delete(const U16* filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    result = FS_Delete(filepath);

#ifdef __MMI_FMGR_CUSTICON_SUPPORT__
    if (result == FS_NO_ERROR)
    {
        srv_fmgr_custicon_do(SRV_FMGR_CUSTICON_OP_DEREGISTER, (const WCHAR*)filepath, NULL);
    }
#endif /* __MMI_FMGR_CUSTICON_SUPPORT__ */

    DA_TRACE_FUNC1(srv_da_util_file_delete, result);

    return result;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_file_move
 * DESCRIPTION
 *  Move a file. It a wrapper of FS_Move
 * PARAMETERS
 *  src_path    [IN] Source path
 *  dest_path   [IN] Destination path
 *  flags       [IN] Flags
 * RETURNS
 *  Error code returned by file system move function
 *****************************************************************************/
S32 srv_da_util_file_move(const U16 *src_path, const U16 *dest_path, U32 flags)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (flags == 0)
    {
        flags = FS_MOVE_KILL;
    }
    
    if (src_path[0] == dest_path[0] && flags == FS_MOVE_KILL)
    {
        result = FS_Rename(src_path, dest_path);
    }
    else
    {
        result = FS_Move(src_path, dest_path, flags, NULL, NULL, 0);
    }

#ifdef __MMI_FMGR_CUSTICON_SUPPORT__
    if (result == FS_NO_ERROR)
    {
        srv_fmgr_custicon_do(
            SRV_FMGR_CUSTICON_OP_MOVE_OBJECT,
            (const WCHAR*)src_path,
            (const WCHAR*)dest_path);
    }
#endif /* __MMI_FMGR_CUSTICON_SUPPORT__ */

    DA_TRACE_FUNC1(srv_da_util_file_move, result);

    return result;
}


/*****************************************************************************
* FUNCTION
*   srv_da_util_check_free_space
* DESCRIPTION
*   check if have enought space to save file
* PARAMETERS
*   drv         [IN]    Check which storage
*   need_space  [IN]    how many space we need.
* RETURNS
*   MMI_TRUE or MMI_FALSE
*****************************************************************************/
MMI_BOOL srv_da_util_check_free_space(U16 drv, U64 need_space)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32         fs_ret;
    FS_DiskInfo disk_info;
    U16         path[4];
    U64         disk_free_space = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    path[0] = drv;
    path[1] = L':';
    path[2] = L'\\';
    path[3] = L'\0';
    
	fs_ret = FS_GetDevStatus(drv, FS_MOUNT_STATE_ENUM);  // Confirm the drive is ready
    if (fs_ret<0) 
		return MMI_FALSE;

    fs_ret = FS_GetDevStatus(drv, FS_FEATURE_STATE_ENUM);  // Confirm the drive is not busy
    if (fs_ret<0) 
		return MMI_FALSE;
    
    fs_ret = FS_GetDiskInfo((PU16) path, &disk_info, FS_DI_BASIC_INFO | FS_DI_FREE_SPACE);
    
    if (fs_ret >= 0)
    {
        disk_free_space = (U64)disk_info.FreeClusters * disk_info.SectorsPerCluster * disk_info.BytesPerSector;

        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)drv, (S32)need_space, (S32)disk_free_space);

        if(disk_free_space == 0)
        {
            return MMI_FALSE;
        }
        
        if (disk_free_space < need_space)
        {
            return MMI_FALSE;
        }
        else
        {
            return MMI_TRUE;
        }
    }
    else
    {
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)drv, (S32)need_space, (S32)fs_ret);
    }

    
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_is_drive_available
 * DESCRIPTION
 *  To test whether a drive is available.
 * PARAMETERS
 *  drv     [IN] Drive to be tested.
 * RETURNS
 *  MMI_TRUE if the drive can be used now.
 *****************************************************************************/
MMI_BOOL srv_da_util_is_drive_available(U16 drv)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL available;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (FS_GetDevStatus(drv, FS_MOUNT_STATE_ENUM) == FS_NO_ERROR)
		available = MMI_TRUE;
	else
		available = MMI_FALSE;

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_IS_DRIVE_AVAILABLE, (S8)drv, (available ? 'Y' : 'N'));

    return available;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_get_max_number_of_drives
 * DESCRIPTION
 *  Get the number of drives. The number will include currently unavailable drives.
 * PARAMETERS
 *  void
 * RETURNS
 *  Total number of drives.
 *****************************************************************************/
U32 srv_da_get_max_number_of_drives(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    SRV_FMGR_DRVLIST_HANDLE handle;
    U32 n_drives;
            
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    handle = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE);
    n_drives = (U32)srv_fmgr_drivelist_count(handle);
    srv_fmgr_drivelist_destroy(handle);

    return n_drives;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_get_number_of_available_drives
 * DESCRIPTION
 *  Get the number of drives. If a drive is not available currently,
 *  it won't be counted in.
 * PARAMETERS
 *  void
 * RETURNS
 *  Total number of available drives.
 *****************************************************************************/
U32 srv_da_get_number_of_available_drives(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    SRV_FMGR_DRVLIST_HANDLE handle;
    U32 n_drives;
            
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    handle = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE_ONLY);
    n_drives = (U32)srv_fmgr_drivelist_count(handle);
    srv_fmgr_drivelist_destroy(handle);

    return n_drives;
}


/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
U32 srv_da_util_get_file_size(const U16* filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE   filehandle;
    UINT        size = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!filepath)
        return 0;
    filehandle = FS_Open((U16*)filepath, FS_READ_ONLY);
    if(filehandle >= 0)
    {
        FS_GetFileSize(filehandle, &size);
        FS_Close(filehandle);
    }
    return (U32)size;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_does_file_exist
 * DESCRIPTION
 *  check whether does a file exist
 * PARAMETERS
 *  path        [IN]
 * RETURNS
 * MMI_BOOL
 *****************************************************************************/
MMI_BOOL srv_da_util_does_file_exist(const U16 *path)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE hd;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((hd = FS_Open((PU16) path, FS_READ_ONLY)) >= 0)
    {
        FS_Close(hd);
        return MMI_TRUE;
    }
    else
    {
        return MMI_FALSE;
    }
}

//#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
/*****************************************************************************
* FUNCTION
*   mmi_da_util_create_file_dir_ext()
* DESCRIPTION
*   create directly from a file path (resursivly)
* PARAMETERS
*   filepath      IN          file path to create, coding in UCS2
* RETURNS
*   >=0 success
*   < 0 fail
*****************************************************************************/
S32 srv_da_util_create_file_dir_ext(U16 *filepath, MMI_BOOL is_filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buf_createpath[128];
    S8 buf_filepath[(SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH];
    S32 str_len;
    S32 cmp_ret;
    S32 i;
    U16 *ptr;
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    mmi_ucs2cpy((PS8) buf_filepath, (PS8) filepath);

    if(is_filepath)
    {
        ptr = srv_da_util_get_filename((U16*)buf_filepath);
        *ptr = 0;
    }
    
    file_handle = FS_Open((U16 *) buf_filepath, FS_OPEN_DIR | FS_READ_ONLY);

    /* path already exist */
    if (file_handle >= 0)
    {
        FS_Close(file_handle);
        return file_handle;
    }
    
    /* path not exist */
    if( FS_FILE_NOT_FOUND == file_handle)
    {
        /* create directory if it is not there */
        str_len = mmi_ucs2strlen((PS8) buf_filepath);
        str_len *= ENCODING_LENGTH;

        /* skip drive. "C:\" */
        for (i = 3 * ENCODING_LENGTH; i < str_len; i += ENCODING_LENGTH)
        {
            cmp_ret = mmi_ucs2ncmp((PS8) & buf_filepath[i], (PS8) L"\\", 1);
            if (cmp_ret == 0)
            {
                mmi_ucs2ncpy((PS8) buf_createpath, (PS8) buf_filepath, i / ENCODING_LENGTH);

                /* remove '\' */
                buf_createpath[i] = buf_createpath[i + 1] = '\0';

                file_handle = FS_CreateDir((PU16) buf_createpath);

                if (FS_FILE_EXISTS == file_handle)
                {
                    /* Do Nothing need to continue */
                }
                else if (file_handle < 0)
                {
                    /* error */
                    return file_handle;
                }

                /* if this is temp folder, set hidden */
                if( mmi_ucs2ncmp((S8*)buf_createpath + 3 * ENCODING_LENGTH , (S8*)FMGR_DEFAULT_FOLDER_TEMP,
                                        mmi_ucs2strlen((S8*)FMGR_DEFAULT_FOLDER_TEMP)-1) == 0)
                {
                    FS_SetAttributes((unsigned short*)buf_createpath, FS_ATTR_DIR | FS_ATTR_HIDDEN);
                }
            }
        }
    }
    
    return file_handle;
}
//#endif /* __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__ */

/*****************************************************************************
* FUNCTION
*   srv_da_util_create_file_dir
* DESCRIPTION
*   create directly from a file path (resursivly)
* PARAMETERS
*   filepath      IN          file path to create, coding in UCS2
* RETURNS
*   >=0 success
*   < 0 fail
*****************************************************************************/
S32 srv_da_util_create_yt_file_dir(U16 *filepath, MMI_BOOL is_filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buf_createpath[128];
    S8 buf_filepath[(SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH];
    S32 str_len;
    S32 cmp_ret;
    S32 i;
    U16 *ptr;
    FS_HANDLE file_handle = 0;
	MMI_BOOL check = MMI_TRUE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    mmi_ucs2cpy((PS8) buf_filepath, (PS8) filepath);

    if(is_filepath)
    {
        ptr = srv_da_util_get_filename((U16*)buf_filepath);
        *ptr = 0;
    }
    




		FS_XDelete((UI_string_type) buf_filepath, FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE, NULL, 0);

    
    {
        /* create directory if it is not there */
        str_len = mmi_ucs2strlen((PS8) buf_filepath);
        str_len *= ENCODING_LENGTH;

        /* skip drive. "C:\" */
        for (i = 3 * ENCODING_LENGTH; i < str_len; i += ENCODING_LENGTH)
        {
            cmp_ret = mmi_ucs2ncmp((PS8) & buf_filepath[i], (PS8) L"\\", 1);
            if (cmp_ret == 0)
            {
				if (check)
				{
					check = MMI_FALSE;
					mmi_ucs2ncpy((PS8) buf_createpath, (PS8) buf_filepath, i / ENCODING_LENGTH);

					/* remove '\' */
					buf_createpath[i] = buf_createpath[i + 1] = '\0';

					file_handle = FS_CreateDir((PU16) buf_createpath);
					MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)file_handle, 34, 35);
					if (file_handle == FS_FILE_EXISTS || file_handle >= 0)
					{
                    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)file_handle, 36, 37);
						continue;
					}
					else
					{
						MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)file_handle, 38, 39);
                    return file_handle;
					}
					
				}
				mmi_ucs2ncpy((PS8) buf_createpath, (PS8) buf_filepath, i / ENCODING_LENGTH);

                /* remove '\' */
                buf_createpath[i] = buf_createpath[i + 1] = '\0';

                file_handle = FS_CreateDir((PU16) buf_createpath);
MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)file_handle, 40, 41);
                if (file_handle < 0)
                {
                    /* error */
				MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_CHECK_FREE_SPACE, (S8)file_handle, 42, 43);
                    return file_handle;
                }

				else
                {
                    FS_SetAttributes((unsigned short*)buf_createpath, FS_ATTR_DIR | FS_ATTR_HIDDEN);
                }
            }
        }
    }
    
    return file_handle;
}



/*****************************************************************************
* FUNCTION
*   srv_da_util_create_file_dir
* DESCRIPTION
*   create directly from a file path (resursivly)
* PARAMETERS
*   filepath      IN          file path to create, coding in UCS2
* RETURNS
*   >=0 success
*   < 0 fail
*****************************************************************************/
S32 srv_da_util_create_file_dir(U16 *filepath, MMI_BOOL is_filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 buf_createpath[128];
    S8 buf_filepath[(SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH];
    S32 str_len;
    S32 cmp_ret;
    S32 i;
    U16 *ptr;
    FS_HANDLE file_handle;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    mmi_ucs2cpy((PS8) buf_filepath, (PS8) filepath);

    if(is_filepath)
    {
        ptr = srv_da_util_get_filename((U16*)buf_filepath);
        *ptr = 0;
    }
    
    file_handle = FS_Open((U16 *) buf_filepath, FS_OPEN_DIR | FS_READ_ONLY);

    /* path already exist */
    if (file_handle >= 0)
    {
        FS_Close(file_handle);
        return file_handle;
    }
    
    /* path not exist */
    if( FS_FILE_NOT_FOUND == file_handle)
    {
        /* create directory if it is not there */
        str_len = mmi_ucs2strlen((PS8) buf_filepath);
        str_len *= ENCODING_LENGTH;

        /* skip drive. "C:\" */
        for (i = 3 * ENCODING_LENGTH; i < str_len; i += ENCODING_LENGTH)
        {
            cmp_ret = mmi_ucs2ncmp((PS8) & buf_filepath[i], (PS8) L"\\", 1);
            if (cmp_ret == 0)
            {
                mmi_ucs2ncpy((PS8) buf_createpath, (PS8) buf_filepath, i / ENCODING_LENGTH);

                /* remove '\' */
                buf_createpath[i] = buf_createpath[i + 1] = '\0';

                file_handle = FS_CreateDir((PU16) buf_createpath);

                if (file_handle < 0)
                {
                    /* error */
                    return file_handle;
                }

                /* if this is temp folder, set hidden */
                if( mmi_ucs2ncmp((S8*)buf_createpath + 3 * ENCODING_LENGTH , (S8*)FMGR_DEFAULT_FOLDER_TEMP,
                                        mmi_ucs2strlen((S8*)FMGR_DEFAULT_FOLDER_TEMP)-1) == 0)
                {
                    FS_SetAttributes((unsigned short*)buf_createpath, FS_ATTR_DIR | FS_ATTR_HIDDEN);
                }
            }
        }
    }
    
    return file_handle;
}

/*****************************************************************************
* FUNCTION
*  srv_da_util_get_extension
* DESCRIPTION
*  get extension file name of a file path
* PARAMETERS
*  filepath   IN  The file path
* RETURNS
*  Return the pointer where the extension file name start.
*   Return NULL if the filepath do not have extension file name.
*****************************************************************************/
U16 *srv_da_util_get_extension(U16 * filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length, i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = mmi_ucs2strlen((S8 *) filepath);

    /* search from head ... mp3.log.tmp */
    for (i = length - 1; i >= 0; i--)
    {
        if (filepath[i] == '.')
        {
            return &filepath[i + 1];
        }
        else if( filepath[i] == '\\' || filepath[i] == '/' )
        {
            return NULL;
        }
    }
    return NULL;
}

/*****************************************************************************
* FUNCTION
*  srv_da_util_get_extension_ascii
* DESCRIPTION
*  get extension file name of a file path
* PARAMETERS
*  filepath   IN  The file path
* RETURNS
*  Return the pointer where the extension file name start.
*   Return NULL if the filepath do not have extension file name.
*****************************************************************************/
S8 *srv_da_util_get_extension_ascii(S8 * filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length, i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = strlen(filepath);

    /* search from head ... mp3.log.tmp */
    for (i = length - 1; i >= 0; i--)
    {
        if (filepath[i] == '.')
        {
            return &filepath[i + 1];
        }
        else if( filepath[i] == '\\' || filepath[i] == '/' )
        {
            return NULL;
        }
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_extract_folder
 * DESCRIPTION
 *  Extract root folder of the filepath
 * PARAMETERS
 *  path    [IN]  Fildpath
 *  folder  [OUT] Folder
 * RETURNS
 *  Folder
 *****************************************************************************/
U16 *srv_da_util_extract_folder(const U16 *path, U16 *folder)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16 *src_p;
    U16 *dest_p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    folder[0] = L'\0';
    
    if (path[1] == L':' && path[2] == L'\\')
    {
        src_p = &(path[3]);
        dest_p = folder;

        while (*src_p != L'\\' && *src_p != L'\0')
        {
            *dest_p = *src_p;
            src_p++;
            dest_p++;
        }
        *(dest_p++) = L'\\';
        *dest_p = L'\0';

        if (*src_p == L'\0')
        {
            folder[0] = L'\0';
        }
    }

    return folder;
}


/*****************************************************************************
* FUNCTION
*  srv_da_util_get_filename
* DESCRIPTION
*  get file name of a file path
* PARAMETERS
*  filepath   IN  File path
* RETURNS
*  return the pointer where file name start
*****************************************************************************/
U16 *srv_da_util_get_filename(U16 * filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length, i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = mmi_ucs2strlen((S8 *) filepath);

    for (i = length - 1; i >= 0; i--)
    {
        if (filepath[i] == L'\\' || filepath[i] == L'/')
        {
            return &filepath[i + 1];
        }
    }
    return filepath;
}

/*****************************************************************************
* FUNCTION
*  srv_da_util_get_filename_ascii
* DESCRIPTION
*  get file name of a file path
* PARAMETERS
*  filepath   IN  File path
* RETURNS
*  return the pointer where file name start
*****************************************************************************/
S8 *srv_da_util_get_filename_ascii(S8 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length, i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    length = strlen(filepath);

    for (i = length - 1; i >= 0; i--)
    {
        if (filepath[i] == '\\' || filepath[i] == '/')
        {
            return &filepath[i + 1];
        }
    }
    return filepath;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
MMI_BOOL srv_da_util_get_temp_filename(U16* pathname, U16* filename, U32 filename_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    FS_HANDLE       ffh;
    U32             seed, length;
    U16             temp[20];

    U16             retry_count = 5;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    kal_get_time(&seed);
    srand(seed);
    length = mmi_ucs2strlen((S8*)pathname);
    MMI_ASSERT(filename_len > length + 9);  /* daxxxxx.* = 9 digits */
    
    do { 
        /* compose a random name first */
        seed = rand();
        
        kal_wsprintf(filename, "%wda%05d.*", pathname, seed % 100000); /* use last 5 digit */

        /* check if the file exist */
        ffh = FS_FindFirst(filename, 0, 0, NULL, (U16*) temp, 20);
        if(ffh == FS_FILE_NOT_FOUND || ffh == FS_NO_MORE_FILES)
        {
            filename[length + 7] = 0;
            return MMI_TRUE;
        }

        FS_FindClose(ffh);
        
    } while(retry_count--);

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_get_clear_filepath
 * DESCRIPTION
 *  If there is already a file occupies the filepath, this function will
 *  append (n) to the filename. The result filepath is clear; that is,
 *  no file on the filepath.
 * PARAMETERS
 *  filepath    [IN/OUT] filepath
 *  is_in_use   [IN] If the filepath is in use, returns MMI_TRUE. Can be NULL.
 * RETURNS
 *  filepath
 *****************************************************************************/
U16* srv_da_util_get_clear_filepath(
    U16 *filepath,
    MMI_BOOL (*is_in_use)(const U16* filepath, MMI_BOOL do_popup))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *filename_in_filepath;
    U16 *filename;
    U16 *file_ext;
    U16 filename_suffix[10];
    U32 filename_len;
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    filename_in_filepath = srv_da_util_get_filename(filepath);
    MMI_ASSERT(filename_in_filepath != NULL);

    if (srv_da_util_does_file_exist(filepath) ||
        (is_in_use != NULL && is_in_use(filepath, MMI_FALSE))) /* Filepath is already used by some download */
    {
        filename = (U16 *)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_LEN + 21) * sizeof(U16));
        mmi_wcsncpy(filename, filename_in_filepath, SRV_FMGR_PATH_MAX_LEN + 20);

        file_ext = srv_da_util_get_extension(filename);
        if (file_ext != NULL && *(file_ext - 1) == L'.')
        {
            /* Remove the extension name in filename */
            *(file_ext - 1) = L'\0';
        }
        else
        {
            file_ext = NULL;
        }

        filename_len = mmi_wcslen(filename);

        for (i = 1; i < 10000; i++)
        {
            U16 *start_to_append_in_filepath;
            U32 suffix_len;
            
            kal_wsprintf(filename_suffix, "(%d)", i);
            suffix_len = mmi_wcslen(filename_suffix);

            if (filename_len + suffix_len <= MMI_DA_MAX_FILENAME_INPUT_LEN)
            {
                /* We can append directly */
                start_to_append_in_filepath = filename_in_filepath + filename_len;
            }
            else
            {
                /* We have to cut part of filename */
                start_to_append_in_filepath = filename_in_filepath + MMI_DA_MAX_FILENAME_INPUT_LEN - suffix_len;
            }

            if (file_ext != NULL)
            {
                kal_wsprintf(start_to_append_in_filepath, "%w.%w", filename_suffix, file_ext);
            }
            else
            {
                mmi_wcscpy(start_to_append_in_filepath, filename_suffix);
            }

            if (!srv_da_util_does_file_exist(filepath) &&
                (is_in_use == NULL || !is_in_use(filepath, MMI_FALSE))) /* Not used by other downloads */
            {
                /* We got it */
                break;
            }
        }

        OslMfree(filename);
    }

    return filepath;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_process_filepath_to_be_displayed
 * DESCRIPTION
 *  If the string to be displayed is a filepath/filename, there are some
 *  restrictions. This function is used to process the string.
 * PARAMETERS
 *  filepath    [IN/OUT] filepath
 * RETURNS
 *  filepath
 *****************************************************************************/
U16* srv_da_util_process_filepath_to_be_displayed(U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *ch_p;
    U16 *filename;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    srv_fmgr_path_hide_extension(filepath);

    /*
     * MAUI_01034914:
     * To show x:\Download\xxx, but Download\ is a hidden folder,
     * we should eliminate x:\Download\ to only show the filename.
     */
    if (mmi_wcsncmp((filepath + 1), L":\\", 2) == 0 &&
        mmi_wcsstr((filepath + 3), FMGR_DEFAULT_FOLDER_TEMP) == (filepath + 3))
    {
        /* filepath begins with hidden folder */

        /* Only reserve the filename */
        filename = srv_da_util_get_filename(filepath);
        ch_p = filepath;
        
        while (*filename != L'\0')
        {
            *(ch_p++) = *(filename++);
        }
        
        *ch_p = L'\0';
    }

    return filepath;
}


MMI_BOOL srv_da_util_is_valid_filename(U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (srv_fmgr_path_is_filename_valid(filepath));
}


/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
applib_mime_type_struct* srv_da_util_lookup_mime_type(U8* mime_string, U16* ext,
                            applib_mime_type_enum mime_type,
                            applib_mime_subtype_enum mime_subtype)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 ext_ascii[SRV_FMGR_PATH_MAX_FILE_EXT_LEN + 1];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(ext_ascii, 0, SRV_FMGR_PATH_MAX_FILE_EXT_LEN + 1);
    if(ext)
    {
        mmi_ucs2_n_to_asc((S8*)ext_ascii, (S8*)ext, SRV_FMGR_PATH_MAX_FILE_EXT_LEN * 2);
        return srv_da_util_lookup_mime_type_ascii(mime_string, ext_ascii, mime_type, mime_subtype);
    }

    return srv_da_util_lookup_mime_type_ascii(mime_string, NULL, mime_type, mime_subtype);
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
applib_mime_type_struct* srv_da_util_lookup_mime_type_ascii(U8* mime_string, S8* ext,
                            applib_mime_type_enum mime_type,
                            applib_mime_subtype_enum mime_subtype)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    applib_mime_type_struct *result = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if( mime_string && ext )
        result = applib_mime_type_look_up((kal_char *) mime_string, ext, mime_type, mime_subtype);
    if( !result && mime_string)
        result = applib_mime_type_look_up((kal_char *) mime_string, NULL, mime_type, mime_subtype);
    if( !result && ext )
        result = applib_mime_type_look_up(NULL, ext, MIME_TYPE_NONE, MIME_SUBTYPE_NONE);
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_is_invalid_filename_char
 * DESCRIPTION
 *  Test if a character is an invalid character for filename
 * PARAMETERS
 *  ch      [IN] Character
 * RETURNS
 *  MMI_TRUE if it is an invalid character
 *****************************************************************************/
static MMI_BOOL srv_da_util_is_invalid_filename_char(const U16 ch)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static const U16 invalid_char[] = L"/\\:*?\"<>|\r\n";

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Found in the invalid character list, it should be an invalid character */
    if (mmi_wcschr(invalid_char, ch) != NULL)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_replace_invalid_filename_char
 * DESCRIPTION
 *  Replace all invalid filename characters in str by '_'
 * PARAMETERS
 *  str     [IN/OUT] String
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_util_replace_invalid_filename_char(U16 *str)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *char_in_str;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    for (char_in_str = str; *char_in_str != '\0'; char_in_str++)
    {
        if (srv_da_util_is_invalid_filename_char(*char_in_str))
        {
            *char_in_str = '_';
        }
    }
    
}


MMI_BOOL srv_da_util_is_supported_by_fmgr(const WCHAR *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __MMI_ULTRA_SLIM_FILE_MANAGER__
    return cui_file_option_is_any_option(filepath);
#else
	return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_extract_filepath
 * DESCRIPTION
 *  Extract filename and extension name from a filepath
 * PARAMETERS
 *  filepath    [IN]  Filepath
 *  filename    [OUT] Filename extracted from filepath
 *  fileext     [OUT] File extension name extracted from filepath
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_extract_filepath(U16* filepath, U16* filename, U16* fileext)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *name_in_filepath, *ext_in_filepath;
    U32 max_filename_len;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Find the positions of filename and extention name  */
    name_in_filepath = srv_da_util_get_filename(filepath);
    ext_in_filepath = srv_da_util_get_extension(name_in_filepath);
    
    max_filename_len = MMI_DA_MAX_FILENAME_INPUT_LEN;

    if (ext_in_filepath != NULL)
    {
        max_filename_len = ext_in_filepath - name_in_filepath - 1;
        if (max_filename_len > MMI_DA_MAX_FILENAME_INPUT_LEN)
        {
            max_filename_len = MMI_DA_MAX_FILENAME_INPUT_LEN;
        }
    }

    /* Copy filename */
    mmi_wcsncpy(filename, name_in_filepath, max_filename_len);

    /* Copy extention name */
    if (ext_in_filepath != NULL)
    {
        mmi_wcsncpy(fileext, ext_in_filepath, SRV_FMGR_PATH_MAX_FILE_EXT_LEN);
    }
    else
    {
        fileext[0] = L'\0';
    }

    /* The filename may contain invalid characters, replace them */
    srv_da_util_replace_invalid_filename_char(filename);
    srv_da_util_replace_invalid_filename_char(fileext);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_extract_filename_from_url
 * DESCRIPTION
 *  Extract filename and extension name from URL.
 * PARAMETERS
 *  url         [IN]  URL string
 *  filename    [OUT] Filename
 *  fileext     [OUT] Extension name
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_extract_filename_from_url_ext(const S8 *url, U16 *filename)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *filename_in_url;
    S8 *fileext_in_url;
    S32 max_filename_len;
    S32 len;
    S8 *str_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    filename[0] = L'\0';
    
    filename_in_url = srv_da_util_get_filename_ascii((S8*)url);
    fileext_in_url = srv_da_util_get_extension_ascii(filename_in_url);

    /* Extract filename */
    len = 0;
    max_filename_len = MMI_DA_MAX_FILENAME_INPUT_LEN;

    if (fileext_in_url != NULL)
    {
        max_filename_len = fileext_in_url - filename_in_url - 1;
        if (max_filename_len > MMI_DA_MAX_FILENAME_INPUT_LEN)
        {
            max_filename_len = MMI_DA_MAX_FILENAME_INPUT_LEN;
        }
    }

    for (str_p = filename_in_url; len < max_filename_len && *str_p != '\0'; str_p++)
    {
        U16 ch;

        ch = (U16)*str_p;
    
        if (!srv_da_util_is_invalid_filename_char(ch))
        {
            len++;
        }
        else
        {
            break;
        }
    }

    mmi_asc_n_to_wcs(filename, filename_in_url, len);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_extract_filename_from_url
 * DESCRIPTION
 *  Extract filename and extension name from URL.
 * PARAMETERS
 *  url         [IN]  URL string
 *  filename    [OUT] Filename
 *  fileext     [OUT] Extension name
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_extract_filename_from_url(const S8 *url, U16 *filename, U16 *fileext)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S8 *filename_in_url;
    S8 *fileext_in_url;
    S32 max_filename_len;
    S32 len;
    S8 *str_p;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    filename[0] = L'\0';
    fileext[0] = L'\0';

    filename_in_url = srv_da_util_get_filename_ascii((S8*)url);
    fileext_in_url = srv_da_util_get_extension_ascii(filename_in_url);

    /* Extract filename */
    len = 0;
    max_filename_len = MMI_DA_MAX_FILENAME_INPUT_LEN;

    if (fileext_in_url != NULL)
    {
        max_filename_len = fileext_in_url - filename_in_url - 1;
        if (max_filename_len > MMI_DA_MAX_FILENAME_INPUT_LEN)
        {
            max_filename_len = MMI_DA_MAX_FILENAME_INPUT_LEN;
        }
    }

    for (str_p = filename_in_url; len < max_filename_len && *str_p != '\0'; str_p++)
    {
        U16 ch;

        ch = (U16)*str_p;
    
        if (!srv_da_util_is_invalid_filename_char(ch))
        {
            len++;
        }
        else
        {
            break;
        }
    }

    mmi_asc_n_to_wcs(filename, filename_in_url, len);

    /* Extract extension name */
    if (fileext_in_url != NULL)
    {
        len = 0;
    
        for (str_p = fileext_in_url; len < SRV_FMGR_PATH_MAX_FILE_EXT_LEN && *str_p != '\0'; str_p++)
        {
            U16 ch;
        
            ch = (U16)*str_p;
            
            if (!srv_da_util_is_invalid_filename_char(ch))
            {
                len++;
            }
            else
            {
                break;
            }
        }

        mmi_asc_n_to_wcs(fileext, fileext_in_url, len);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_to_lower
 * DESCRIPTION
 *  Upper case to lower case. For non-alphabet char returns original one directly.
 * PARAMETERS
 *  c       [IN] char
 * RETURNS
 *  Lower case of char
 *****************************************************************************/
#define srv_da_util_to_lower(c) ( ((c) >= 'A' && (c) <= 'Z') ? ((c) - 'A' + 'a') : (c) )


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_str_find_ignore_case
 * DESCRIPTION
 *  Find pattern in string but ignore case.
 * PARAMETERS
 *  str     [IN] The string to search
 *  pattern [IN] Pattern
 * RETURNS
 *  The pointer of the begin of the pattern in str. NULL if not found.
 *****************************************************************************/
static S8* srv_da_util_str_find_ignore_case(const S8 *str, const S8 *pattern)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const S8 *ch;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    ch = str;
    while (*ch != '\0')
    {
        if (*ch == pattern[0])
        {
            register const S8 *ch_in_str, *ch_in_pattern;

            ch_in_str = ch;
            ch_in_pattern = pattern;

            while (*ch_in_str != '\0' &&
                *ch_in_pattern != '\0' &&
                srv_da_util_to_lower(*ch_in_str)== srv_da_util_to_lower(*ch_in_pattern))
            {
                ch_in_str++;
                ch_in_pattern++;
            }

            if (*ch_in_pattern == '\0')
            {
                /* Found */
                break;
            }
            else if (*ch_in_str == '\0')
            {
                /* strlen(ch) < strlen(pattern) */
                ch = ch_in_str;
                break;
            }
        }

        ch++;
    }

    return (S8*)(*ch != '\0' ? ch : NULL);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_extract_from_header
 * DESCRIPTION
 *  Extract field from HTTP header.
 * PARAMETERS
 *  header          [IN]  HTTP header
 *  tag             [IN]  Field tag to extract
 *  value_buffer    [OUT] The field value which be extracted will be put in this buffer
 *  buffer_len      [IN]  Maximum length of buffer
 * RETURNS
 *  NULL if not exist. Otherwise if something is extracted, it will fill the
 *  value in value_buffer[] and return value_buffer;
 *****************************************************************************/
S8* srv_da_util_extract_from_header(const S8 *header, const S8 *tag, S8 *value_buffer, U32 buffer_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    register const S8 *pos;
    U32 tag_str_len;
    U32 value_len;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    tag_str_len = strlen(tag);
    value_len = 0;
    value_buffer[0] = '\0';
    pos = header;

    do {
        pos = srv_da_util_str_find_ignore_case(pos, tag);
    
        if (pos != NULL)
        {
            if ((pos == header || *(pos - 1) == '\n') && *(pos + tag_str_len) == ':')
            {
                /* Skip tag */
                pos += tag_str_len + 1 ;

                /* Skip spaces */
                while (*pos == ' ')
                {
                    pos++;
                }

                /* Copy value to value_buffer */
                while (*pos != '\0' && *pos != '\r' && *pos != '\n' && value_len < buffer_len - 1)
                {
                    value_buffer[value_len++] = *pos;
                    pos++;
                }

                value_buffer[value_len] = '\0';

                /* We found and copied */
                break;
            }
            else
            {
                /* Skip current line */
                while (*pos != '\0' && *pos != '\r' && *pos != '\n')
                {
                    pos++;
                }
            }
        }
        else
        {
            /* Not found, pos == NULL */
            break;
        }
    } while (1);


    return (S8*)((pos != NULL) ? value_buffer : NULL);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_gen_http_header_to_resume
 * DESCRIPTION
 *  Generate the HTTP header for resumption.
 * PARAMETERS
 *  header_buffer   [OUT] Header buffer, it should be large enough
 *  etag            [IN]  Etag. If NULL then no "If-Range" header
 *  from_bytes      [IN]  To generate "Ranges" header
 * RETURNS
 *  header_buffer
 *****************************************************************************/
S8* srv_da_util_gen_http_header_to_resume(S8 *header_buffer, const S8 *etag, U32 from_bytes)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (from_bytes > 0)
    {
        if (etag == NULL)
        {
            sprintf(header_buffer, "Range: bytes=%u-\r\n", from_bytes);
        }
        else
        {
            sprintf(header_buffer, "If-Range: %s\r\nRange: bytes=%u-\r\n", etag, from_bytes);
        }
    }
    else
    {
        header_buffer[0] = '\0';
    }

    return header_buffer;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_ticks_to_milli_seconds
 * DESCRIPTION
 *  Convert ticks to milli-seconds.
 * PARAMETERS
 *  ticks       [IN] ticks
 * RETURNS
 *  Milli-seconds.
 *****************************************************************************/
U32 srv_da_util_ticks_to_milli_seconds(U32 ticks)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (U32)kal_ticks_to_milli_secs(ticks);
}


#define API_ESTIMATED

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
S8 *srv_da_util_format_size_total(U32 curr, U32 total)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static S8       buffer[21];
    S8*             ptr;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    app_strlcpy(buffer, srv_da_util_format_size(curr), sizeof(buffer));

    if(total)
    {
        ptr = buffer + strlen(buffer);
        ptr[0] = '/';
        ptr++;
        app_strlcpy(ptr, srv_da_util_format_size(total), sizeof(buffer) - (ptr - buffer));
    }

    return buffer;
}

S8  *srv_da_util_format_size(U64 size)
{
#if (MAIN_LCD_DEVICE_WIDTH > 128)
    #define DA_DISPLAY_UNIT 1024
#else
    #define DA_DISPLAY_UNIT 1000
#endif
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static S8       buffer[27]; /* Max display is "65536.9GB", which is 8 bytes long */
    S8              unit[5] = {'0',};
    U16             remain;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(size >= DA_DISPLAY_UNIT*1024*1024)
    {
        size = size / (1024*1024);
        strcpy (unit, "GB");
    }
    else if(size >= DA_DISPLAY_UNIT*1024)
    {
        size = size / 1024;
        strcpy (unit, "MB");
    }
    else if(size >= DA_DISPLAY_UNIT)
    {
        strcpy (unit, "KB");
    }
    else
        strcpy (unit, "B");

    if(size >= DA_DISPLAY_UNIT)
    {
        remain = (U16)((size % 1024) / 103);
        size = size / 1024;
    }
    else
        remain = 0;    

#if (MAIN_LCD_DEVICE_WIDTH > 128)
    if(remain)
#else
    if(remain && size < 100)    /* 128 width, size is limited to 3 or 2.1digits */
#endif
    {
        sprintf(buffer, "%d.%d", (U16)size, (U16)remain);
    }
    else
    {
        sprintf(buffer, "%d", (U16)size);
    }
    strcat (buffer, " ");
    strcat (buffer, unit);

    MMI_ASSERT(strlen(buffer) < 10);
    return buffer;
}


void srv_da_util_get_available_size (U16 *buffer, U16 drv)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8  drvLetter;
    S8 *ptr;
   
    U64 totalSize;
    U64 freeSize;
    S8       buff[24] = {'0',}; /* Max display is "(65536.9G)", which is 10 bytes long */
                
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (drv == SRV_DA_DRIVE_MEMORY_CARD)
    {
        drvLetter = (U8)srv_fmgr_drv_get_letter_by_type (SRV_FMGR_DRV_CARD_TYPE);
    }
    else
    {
        drvLetter = (U8)srv_fmgr_drv_get_letter_by_type (SRV_FMGR_DRV_PHONE_TYPE);
    }

    srv_fmgr_drv_get_size(drvLetter, &totalSize, &freeSize);
    buff[0] = '(';
    ptr = buff + strlen(buff);
    app_strlcpy(ptr, srv_da_util_format_size(freeSize), sizeof(buff) - (ptr - buff));
    ptr = buff + strlen(buff);
    ptr[0] = ')';
    mmi_asc_to_ucs2 ((S8*)buffer, (S8*)buff);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_atoi
 * DESCRIPTION
 *  Convert string to S32. Note that if the value is larger that S32 can respresent,
 *  the value would be meanless.
 * PARAMETERS
 *  str     [IN]    String
 *  value   [OUT]
 * RETURNS
 *   If successfully parse str, returns MMI_TRUE.
 *****************************************************************************/
MMI_BOOL srv_da_util_atoi(const S8 *str, S32 *value)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL positive;
    register S32 v;
    register const S8 *p;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    positive = MMI_TRUE;
    p = str;

    if (*p == '-')
    {
        positive = MMI_FALSE;
        p++;
    }

    if (*p == '\0')
    {
        return MMI_FALSE;
    }

    v = 0;

    while (*p >= '0' && *p <= '9')
    {
        v = v * 10 + (S32)(*p - '0');
        p++;
    }

    if (!positive)
    {
        v = -v;
    }

    *value = v;

   if (*p == '\0')
	   return MMI_TRUE;
   else
	   return MMI_FALSE;
}


/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
U16 srv_da_util_get_icon_from_appid(U16 app_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    switch(app_id)
    {
    case APP_WAP:
        return GetRootTitleIcon(SERVICES_WAP_MENU_ID);
#ifndef __COSMOS_MMI_PACKAGE__
    case APP_MESSAGES:
    #if !defined(__IOT__)
        return GetRootTitleIcon(MAIN_MENU_MESSAGES_MENUID);
    #else
        return 0;
    #endif
#endif

    default:
        return 0;
    }
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef __COSMOS_MMI_PACKAGE__
/* under construction !*/
/* under construction !*/
#endif
#ifndef __COSMOS_MMI_PACKAGE__ 
/* under construction !*/
#endif 
/* under construction !*/
#endif


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_decide_drive_to_save_file
 * DESCRIPTION
 *  Decide the drive to save a file. It will check whether the drive is available
 *  and sufficient of space. If no drive is available, returns MMI_FALSE;
 * PARAMETERS
 *  original_filepath   [IN] Filepath of the original file if there is. NULL
 *                           represents no original file.
 *  filesize    [IN]  File size to check the space.
 *  drive       [OUT] Result drive
 *  storage     [OUT] Result storage
 * RETURNS
 *  MMI_TRUE if both drive and storage are valid.
 *  MMI_TRUE if no drive is available. In this case, drive and storage are both invalid.
 *****************************************************************************/
MMI_BOOL srv_da_util_decide_drive_yt_save_file(
    const U16 *original_filepath,
    U32 filesize,
    U16 *drive,
    srv_da_storage_enum *storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_storage_enum t_storage;
	kal_int32 drive_letter;
    kal_int32 accessible;
	kal_int32 busy, presence;
    U16 t_drive = SRV_FMGR_PUBLIC_DRV;
    MMI_BOOL success = MMI_FALSE;




    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	drive_letter = FS_GetDrive(FS_DRIVE_V_REMOVABLE, 1, FS_NO_ALT_DRIVE);

    if (drive_letter > 0) 
	{
        accessible = FS_GetDevStatus(drive_letter, FS_MOUNT_STATE_ENUM);
    
        if (accessible == FS_NO_ERROR)  
		{
            // the memory card is mounted, determine the access ability

            busy = FS_GetDevStatus(drive_letter, FS_FEATURE_STATE_ENUM);

            if (busy < 0)
			{
                // device is busy (busy == FS_DEVICE_BUSY), and read only
            }
            else 
			{
                // device is fully accessible
    t_drive = SRV_FMGR_CARD_DRV;
            }
        }
		else 
		{
            // determine the type of mount error
            presence = FS_GetDevStatus(drive_letter, FS_DEVICE_PRESENCE_ENUM);

            if (presence < 0) 
			{
                // error handling: memory card not present
                t_drive = SRV_FMGR_PUBLIC_DRV;
            }
		}
	}
	else 
	{
        // error handling: drive not exist in current project
		t_drive = SRV_FMGR_PUBLIC_DRV;
    }
  
    
    if (t_drive == SRV_FMGR_CARD_DRV)
    {
        t_storage = SRV_DA_STORAGE_MEMORY_CARD;
    }
    else
    {
        t_storage = SRV_DA_STORAGE_PHONE;
    }

    /*
     * MAUI_01732726: The file size and free space may be both zero at the same time
     * In this case, a full drive may be selected.
     */

    if (!srv_da_util_check_free_space(t_drive, filesize))
    {
        /* If phone storage is too small, try card drive */
        t_storage = SRV_DA_STORAGE_PHONE;
        t_drive = SRV_FMGR_PUBLIC_DRV;
        
        if (!srv_da_util_check_free_space(t_drive, filesize))
        {
            

            success = MMI_FALSE;
        }
    }
    else
    {
        success = MMI_TRUE;
    }

    *drive = t_drive;
    *storage = t_storage;

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_DECIDE_DRIVE_TO_SAVE, filesize, success, (S8)t_drive, t_storage);

    return success;
	
	
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_decide_drive_to_save_file
 * DESCRIPTION
 *  Decide the drive to save a file. It will check whether the drive is available
 *  and sufficient of space. If no drive is available, returns MMI_FALSE;
 * PARAMETERS
 *  original_filepath   [IN] Filepath of the original file if there is. NULL
 *                           represents no original file.
 *  filesize    [IN]  File size to check the space.
 *  drive       [OUT] Result drive
 *  storage     [OUT] Result storage
 * RETURNS
 *  MMI_TRUE if both drive and storage are valid.
 *  MMI_TRUE if no drive is available. In this case, drive and storage are both invalid.
 *****************************************************************************/
MMI_BOOL srv_da_util_decide_drive_to_save_file(
    const U16 *original_filepath,
    U32 filesize,
    U16 *drive,
    srv_da_storage_enum *storage)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_storage_enum t_storage;
    U16 t_drive;
    MMI_BOOL success;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (original_filepath != NULL)
    {
        t_drive = original_filepath[0];
        
        if (t_drive != SRV_FMGR_SYSTEM_DRV &&
            t_drive != SRV_FMGR_PRIVATE_DRV &&
            filesize <= srv_da_util_get_file_size(original_filepath))
        {
            /* Extra space is not needed, allow to use original drive */
            if (t_drive == SRV_FMGR_CARD_DRV)
            {
                t_storage = SRV_DA_STORAGE_MEMORY_CARD;
            }
            else
            {
                t_storage = SRV_DA_STORAGE_PHONE;
            }
        
            *drive = t_drive;
            *storage = t_storage;
            return MMI_TRUE;
        }
    }

    success = MMI_FALSE;
    
    /* Save to public drive */
    t_drive = SRV_FMGR_PUBLIC_DRV;
    if (t_drive == SRV_FMGR_CARD_DRV)
    {
        t_storage = SRV_DA_STORAGE_MEMORY_CARD;
    }
    else
    {
        t_storage = SRV_DA_STORAGE_PHONE;
    }

    /*
     * MAUI_01732726: The file size and free space may be both zero at the same time
     * In this case, a full drive may be selected.
     */
    if (filesize == 0)
    {
        filesize = 1; /* To decide a storage at least 1 byte */
    }

    if (!srv_da_util_check_free_space(t_drive, filesize))
    {
        /* If phone storage is too small, try card drive */
        t_storage = SRV_DA_STORAGE_MEMORY_CARD;
        t_drive = SRV_FMGR_CARD_DRV;
        
        if (!srv_da_util_check_free_space(t_drive, filesize))
        {
            SRV_FMGR_DRVLIST_HANDLE drv_list;
            S32 n_available;
            S32 i;
            
            drv_list = srv_fmgr_drivelist_create(SRV_FMGR_DRIVELIST_TYPE_ACCESSIBLE);
            n_available = srv_fmgr_drivelist_count(drv_list);
            for (i = 0; i < n_available; i++)
            {
                t_drive = srv_fmgr_drivelist_get_drv_letter(drv_list, i);

                if (t_drive != SRV_FMGR_PUBLIC_DRV && /* to skip the drive already checked */
                    t_drive != SRV_FMGR_CARD_DRV &&
                    srv_da_util_check_free_space(t_drive, filesize))
                {
                    /* Pass space check */
                    t_storage = SRV_DA_STORAGE_OTHERS;
                    success = MMI_TRUE;
                    break;
                }
            }
            srv_fmgr_drivelist_destroy(drv_list);
        }
        else
        {
            success = MMI_TRUE;
        }
    }
    else
    {
        success = MMI_TRUE;
    }

    *drive = t_drive;
    *storage = t_storage;

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_DECIDE_DRIVE_TO_SAVE, filesize, success, (S8)t_drive, t_storage);

    return success;
}


/****************************************************************************
 * [Asynchronous move utility]
 *
 * To perform asynchronous move operation. Only available when FMT is present.
 ****************************************************************************/

#define MMI_DA_UTIL_ASYNC_MOVE

/****************************************************************************
 * Typedef
 ****************************************************************************/

typedef struct {

#ifdef __MMI_FMGR_CUSTICON_SUPPORT__
    U16 *src_path;
    U16 *dest_path;
#endif /* __FMGR_CUSTICON_SUPPORT__ */

    S32 job_id;
    void *arg;
    void (*result_callback)(void *arg, S32 error_code);
} srv_da_util_async_move_cntx_struct;


/****************************************************************************
 * Global Variable
 ****************************************************************************/

static srv_da_util_async_move_cntx_struct *g_srv_da_util_async_move_cntx_p = NULL;


/****************************************************************************
 * Local Function
 ****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  srv_da_util_async_move_free_cntx
 * DESCRIPTION
 *  Free context structure.
 * PARAMETERS
 *  cntx        [IN] Context structure
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_util_async_move_free_cntx(srv_da_util_async_move_cntx_struct* cntx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (cntx != NULL)
    {
#ifdef __MMI_FMGR_CUSTICON_SUPPORT__
        if (cntx->src_path != NULL)
        {
            OslMfree(cntx->src_path);
        }
        if (cntx->dest_path != NULL)
        {
            OslMfree(cntx->dest_path);
        }
#endif /* __MMI_FMGR_CUSTICON_SUPPORT__ */

        OslMfree(cntx);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_async_move_proc
 * DESCRIPTION
 *  Callback function for FMGR response of asynchronous move.
 * PARAMETERS
 *  evt     [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret srv_da_util_async_move_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_util_async_move_cntx_struct *cntx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_SRV_FMGR_ASYNC_DONE)
    {
        srv_fmgr_async_done_event_struct *done_evt;

        done_evt = (srv_fmgr_async_done_event_struct*)evt;
        cntx = g_srv_da_util_async_move_cntx_p;

        /* Because of racing, the response may arrive after cancelled.
           I don't assume FMGR checked this condition. */
        if (cntx != NULL)
        {
            MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_UTIL_FMGR_MOVE_RESULT,
                (U32)(cntx->result_callback), done_evt->result);
            
            g_srv_da_util_async_move_cntx_p = NULL;

#ifdef __MMI_FMGR_CUSTICON_SUPPORT__
            if (done_evt->result == FS_NO_ERROR)
            {
                srv_fmgr_custicon_do(SRV_FMGR_CUSTICON_OP_MOVE_OBJECT,
                    cntx->src_path,
                    cntx->dest_path);
            }
#endif /* __MMI_FMGR_CUSTICON_SUPPORT__ */

            if (cntx->result_callback != NULL)
            {
                cntx->result_callback(cntx->arg, done_evt->result);
            }

            srv_da_util_async_move_free_cntx(cntx);
        }
    }

    return MMI_RET_OK;
}


/****************************************************************************
 * Global Function
 ****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  srv_da_util_async_move
 * DESCRIPTION
 *  Asynchronous move
 * PARAMETERS
 *  src_path        [IN] Source path
 *  dest_path       [IN] Destination path
 *  arg             [IN] Client argument pointer, this pointer will be passed to
 *                       result_callback()
 *  result_callback [IN] Result callback function. Note if client cancel the move
 *                       by itself, this function will not be called.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_util_async_move(
        U16 *src_path,
        U16 *dest_path,
        void *arg, /* Pass to result_callback */
        void (*result_callback)(void *arg, S32 error_code))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_util_async_move_cntx_struct *cntx;
    S32 job_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(g_srv_da_util_async_move_cntx_p == NULL);

    cntx = (srv_da_util_async_move_cntx_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_util_async_move_cntx_struct));
    
    job_id = srv_fmgr_async_move(
        src_path,
        dest_path,
        SRV_FMGR_ASYNC_FLAG_PRIORITY_FG | SRV_FMGR_ASYNC_FLAG_NO_PROGRESS,
        srv_da_util_async_move_proc,
        cntx);

    if (job_id < 0)
    {
        OslMfree(cntx);
        result_callback(arg, job_id);
        return;
    }

    g_srv_da_util_async_move_cntx_p = cntx;

#ifdef __MMI_FMGR_CUSTICON_SUPPORT__
    cntx->src_path = (U16*)srv_da_adp_mem_allocate((mmi_wcslen(src_path) + 1) * sizeof(U16));
    mmi_wcscpy(cntx->src_path, src_path);
    cntx->dest_path = (U16*)srv_da_adp_mem_allocate((mmi_wcslen(dest_path) + 1) * sizeof(U16));
    mmi_wcscpy(cntx->dest_path, dest_path);
#endif /* __MMI_FMGR_CUSTICON_SUPPORT__ */

    cntx->arg = arg;
    cntx->result_callback = result_callback;
    cntx->job_id = job_id;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_cancel_async_move
 * DESCRIPTION
 *  Cancel asynchronous move
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_util_cancel_async_move(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_srv_da_util_async_move_cntx_p != NULL)
    {
        srv_fmgr_async_abort(
            g_srv_da_util_async_move_cntx_p->job_id,
            MMI_FALSE);
    }
}


/****************************************************************************
 * [TIMER_TRIGGERED_PROCEDURE]
 *
 * Trigger a procedure after timeout.
 ****************************************************************************/

#define TIMER_TRIGGERED_PROCEDURE


/****************************************************************************
 * Configurations
 ****************************************************************************/

#define SRV_DA_MAX_TIMER_TRIGGERED_PROC_NUM 5


/****************************************************************************
 * Typedef
 ****************************************************************************/
 
typedef struct srv_da_set_timer_procedure_struct_s
{
    U16 timer_id;
    void *arg_p;
    S32 arg_v;
    void (*func)(void *arg_p, S32 arg_v);

    struct srv_da_set_timer_procedure_struct_s *next;
} srv_da_timer_triggered_proc_struct;


typedef struct
{
    srv_da_timer_triggered_proc_struct *scheduled;

    /* The first free timer is free_timer_ids[free_top - 1] */
    U16 free_timer_ids[SRV_DA_MAX_TIMER_TRIGGERED_PROC_NUM];
    U32 free_top;
} srv_da_timer_triggered_proc_context_struct;


/****************************************************************************
 * Global Variables
 ****************************************************************************/

static srv_da_timer_triggered_proc_context_struct g_srv_da_timer_triggered_proc_cntx;


/****************************************************************************
 * Static Functions
 ****************************************************************************/

/*****************************************************************************
 * FUNCTION
 *  srv_da_timer_triggered_proc_init
 * DESCRIPTION
 *  Initialize the utility of timer-triggered-proc.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_timer_triggered_proc_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_srv_da_timer_triggered_proc_cntx.scheduled = NULL;
    
    for (i = 0; i < SRV_DA_MAX_TIMER_TRIGGERED_PROC_NUM; i++)
    {
        g_srv_da_timer_triggered_proc_cntx.free_timer_ids[i] = SRV_DA_TIMER_TRIGGERED_PROC_TIMER_BASE + i;
    }
    g_srv_da_timer_triggered_proc_cntx.free_top = SRV_DA_MAX_TIMER_TRIGGERED_PROC_NUM;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_timer_triggered_proc_timeout_hdlr
 * DESCRIPTION
 *  Timeout handler for timer-trigger-proc.
 * PARAMETERS
 *  arg     [IN] srv_da_timer_triggered_proc_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_timer_triggered_proc_timeout_hdlr(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_timer_triggered_proc_struct *proc;
    srv_da_timer_triggered_proc_struct *prev;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Remove from list */
    prev = NULL;
    for (proc = g_srv_da_timer_triggered_proc_cntx.scheduled; proc != NULL; proc = proc->next)
    {
        if (proc == (srv_da_timer_triggered_proc_struct*)arg)
        {
            break;
        }

        prev = proc;
    }

    if (proc == NULL)
    {
        /* It is possible, we may cancel a proc but it is already in queue */
        return;
    }

    if (proc == g_srv_da_timer_triggered_proc_cntx.scheduled)
    {
        g_srv_da_timer_triggered_proc_cntx.scheduled = proc->next;
    }
    else
    {
        prev->next = proc->next;
    }

    /* Free timer ID */
    g_srv_da_timer_triggered_proc_cntx.free_timer_ids[g_srv_da_timer_triggered_proc_cntx.free_top] = proc->timer_id;
    g_srv_da_timer_triggered_proc_cntx.free_top++;

    proc->func(proc->arg_p, proc->arg_v);

    OslMfree(proc);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_timer_triggered_proc_set
 * DESCRIPTION
 *  Set a timer-triggered procedure.
 * PARAMETERS
 *  ms      [IN] Milli-seconds.
 *  func    [IN] After timeout, this function will be called.
 *  arg_p   [IN] Will be passed into func() (Pointer type)
 *  arg_v   [IN] Will be passed into func() (Integer type)
 * RETURNS
 *  Timer ID, can be used to cancel a scheduled procedure.
 *****************************************************************************/
U16 srv_da_timer_triggered_proc_set(U32 ms, void (*func)(void *arg, S32 arg_v), void *arg_p, S32 arg_v)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_timer_triggered_proc_struct *proc;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    proc = (srv_da_timer_triggered_proc_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_timer_triggered_proc_struct));

    MMI_ASSERT(g_srv_da_timer_triggered_proc_cntx.free_top > 0);

    /* Allocate timer ID */
    g_srv_da_timer_triggered_proc_cntx.free_top--;
    proc->timer_id = g_srv_da_timer_triggered_proc_cntx.free_timer_ids[g_srv_da_timer_triggered_proc_cntx.free_top];
    
    proc->func = func;
    proc->arg_p = arg_p;
    proc->arg_v = arg_v;

    /* Add to list */
    proc->next = g_srv_da_timer_triggered_proc_cntx.scheduled;
    g_srv_da_timer_triggered_proc_cntx.scheduled = proc;

    StartTimerEx(proc->timer_id, ms, srv_da_timer_triggered_proc_timeout_hdlr, proc);

    return (proc->timer_id);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_timer_triggered_proc_cancel
 * DESCRIPTION
 *  Cancel a scheduled procedure.
 * PARAMETERS
 *  timer_id    [IN] The timer ID of the scheduled procedure to be cancelled.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_timer_triggered_proc_cancel(U16 timer_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_timer_triggered_proc_struct *proc;
    srv_da_timer_triggered_proc_struct *prev;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    /* Remove from list */
    prev = NULL;
    for (proc = g_srv_da_timer_triggered_proc_cntx.scheduled; proc != NULL; proc = proc->next)
    {
        if (proc->timer_id == timer_id)
        {
            break;
        }

        prev = proc;
    }

    if (proc == NULL)
    {
        return;
    }

    if (proc == g_srv_da_timer_triggered_proc_cntx.scheduled)
    {
        g_srv_da_timer_triggered_proc_cntx.scheduled = proc->next;
    }
    else
    {
        prev->next = proc->next;
    }

    StopTimer(proc->timer_id);

    /* Free timer ID */
    g_srv_da_timer_triggered_proc_cntx.free_timer_ids[g_srv_da_timer_triggered_proc_cntx.free_top] = proc->timer_id;
    g_srv_da_timer_triggered_proc_cntx.free_top++;

    OslMfree(proc);
}


/*****************************************************************************
 * [Trigger Procedure Utility]
 *
 * Utility to trigger a procedure in another event cycle.
 *****************************************************************************/

#define TRIGGER_PROCEDURE

/*
 * This structure is used to send a primitive to DLAgent itself
 * to trigger a procedure in another event cycle.
 */
typedef struct
{
    MMI_EVT_PARAM_HEADER
    
    void *arg_p;
    kal_int32 arg_v;
    void (*func)(void *arg_p);
    void (*func2)(void *arg_p, kal_int32 arg_v);
} srv_da_trigger_proc_post_evt_struct;


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_trigger_proc_ind_proc
 * DESCRIPTION
 *  Event
 * PARAMETERS
 *  msg     [IN] mmi_da_trigger_proc_ind_struct*
 *  src_mod [IN] Source module
 *  ilm_p   [IN] ILM
 * RETURNS
 *  void
 *****************************************************************************/
static mmi_ret srv_da_util_trigger_proc_ind_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_trigger_proc_post_evt_struct *proc_evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    proc_evt = (srv_da_trigger_proc_post_evt_struct*)evt;

    if (proc_evt->func != NULL)
    {
        proc_evt->func(proc_evt->arg_p);
    }
    else if (proc_evt->func2 != NULL)
    {
        proc_evt->func2(proc_evt->arg_p, proc_evt->arg_v);
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_trigger_proc
 * DESCRIPTION
 *  Trigger procedure in another event cycle. This utility sends a primitive
 *  it itself, calls func when received.
 * PARAMETERS
 *  func        [IN] Function to be called
 *  arg         [IN] Argument to be passed to func
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_util_trigger_proc(void (*func)(void *arg), void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_trigger_proc_post_evt_struct proc_evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&proc_evt, 0);

    proc_evt.func = func;
    proc_evt.func2 = NULL;
    proc_evt.arg_p = arg;
    proc_evt.arg_v = 0;

    MMI_FRM_POST_EVENT(&proc_evt, srv_da_util_trigger_proc_ind_proc, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_util_trigger_proc_ext
 * DESCRIPTION
 *  Trigger procedure in another event cycle. This utility sends a primitive
 *  it itself, calls func when received.
 * PARAMETERS
 *  func        [IN] Function to be called
 *  arg_p       [IN] Argument to be passed to func (pointer type)
 *  arg_v       [IN] Argument to be passed to func (integer type)
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_util_trigger_proc_ext(void (*func)(void *arg_p, S32 arg_v), void *arg_p, S32 arg_v)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_trigger_proc_post_evt_struct proc_evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&proc_evt, 0);

    proc_evt.func = NULL;
    proc_evt.func2 = func;
    proc_evt.arg_p = arg_p;
    proc_evt.arg_v = arg_v;

    MMI_FRM_POST_EVENT(&proc_evt, srv_da_util_trigger_proc_ind_proc, NULL);
}


#endif /* defined(__MMI_DOWNLOAD_AGENT__) */
